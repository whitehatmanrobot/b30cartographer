dLF(const HCLOOP hCLoop);
extern void   CLoopSetAddLF(const HCLOOP hCLoop, const int fAddLF);
extern int	  CLoopGetASCII7(const HCLOOP hCLoop);
extern void   CLoopSetASCII7(const HCLOOP hCLoop, const int fASCII7);
extern int	  CLoopGetEchoplex(const HCLOOP hCLoop);
extern void   CLoopSetEchoplex(const HCLOOP hCLoop, const int fEchoplex);
//extern int	CLoopGetWrapLines(const HCLOOP hCLoop);
//extern void	CLoopSetWrapLines(const HCLOOP hCLoop, const int fWrapLines);
extern int	  CLoopGetShowHex(const HCLOOP hCLoop);
extern void   CLoopSetShowHex(const HCLOOP hCLoop, const int fShowHex);
extern int	  CLoopGetTabSizeIn(const HCLOOP hCLoop);
extern void   CLoopSetTabSizeIn(const HCLOOP hCLoop, const int nTabSizeIn);

extern int SetCLoopMBCSState(HCLOOP hCLoop, int nState);
extern int QueryCLoopMBCSState(HCLOOP hCLoop);

extern void   CLoopCharOut(HCLOOP hCLoop, TCHAR chOut);
extern void CLoopBufrOut(HCLOOP hCLoop, TCHAR *pchOut, int nLen);


extern int	  CLoopSend
					(
					const HCLOOP	hCLoop,
						  void	   *pvData,
					const size_t	sztItems,
						  unsigned	uOptions);
extern int	  CLoopSendTextFile(const HCLOOP hCLoop, TCHAR *pszFileName);
extern void   CLoopClearOutput(const HCLOOP hCLoop);
extern unsigned long CLoopGetOutputCount(const HCLOOP pstCLoop);
extern int 	  CLoopInitHdl(const HCLOOP pstCLoop);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cnct.h ===
/*	File: D:\WACKER\tdll\cnct.h (Created: 10-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 10/09/01 9:46a $
 */

/* --- Connection driver handle definition (struct never defined) --- */

typedef struct stCnctDriverPublic *HDRIVER;

/* --- Error return codes --- */

#define CNCT_BAD_HANDLE 		-1	// invalid connection handle
#define CNCT_NO_THREAD			-2	// couldn't create a connection thread
#define CNCT_ALREADY_OPEN		-3	// connection is already opened
#define CNCT_FIND_DLL_FAILED	-4	// couldn't find DLL
#define CNCT_LOAD_DLL_FAILED	-5	// couldn't load DLL
#define CNCT_ERROR				-6	// general error
#define CNCT_NOT_SUPPORTED		-7	// driver doesn't support this function
#define CNCT_IN_DISCONNECT      -8  // Already attempting to disconnect.

/* --- Connection status codes --- */

#define CNCT_STATUS_FALSE			   0	// disconnected state
#define CNCT_STATUS_TRUE			   1	// connected state
#define CNCT_STATUS_CONNECTING		   2	// trying to connect
#define CNCT_STATUS_DISCONNECTING	   3	// trying to disconnect
#define CNCT_STATUS_ANSWERING          4    // waiting for caller

/* --- cnctConnect Flags (must be powers of two) --- */

#define CNCT_NOCONFIRM				0x0001	// do not pop-up confirmation dialog
#define CNCT_NEW					0x0002	// this is a new connection
#define CNCT_DIALNOW				0x0004	// disconnect flag that forces redial
#define CNCT_PORTONLY				0x0008	// don't dial phone number
#define DISCNCT_NOBEEP				0x0010	// don't beep on disconnect
#define CNCT_WINSOCK                0x0020  // try to connect w/ Winsock to ip address
#define CNCT_ANSWER                 0x0040  // wait for a call
#ifdef INCL_EXIT_ON_DISCONNECT
#define DISCNCT_EXIT				0x0080	// exit on disconnect
#else
#define DISCNCT_EXIT				0x0000	// no meaning whatsoever - just a placeholder
#endif
#define CNCT_XFERABORTCONFIRM       0x0100  // Prompt for confirmation to abort file transfers.
#define CNCT_LOSTCARRIER            0x0200  // Loss of carrier.

/* --- Function Prototypes --- */

HCNCT cnctCreateHdl(const HSESSION hSession);
void cnctDestroyHdl(const HCNCT hCnct);
int cnctQueryStatus(const HCNCT hCnct);
int cnctIsModemConnection(const HCNCT hCnct);
int cnctConnect(const HCNCT hCnct, const unsigned int uCnctFlags);
int cnctSetDevice(const HCNCT hCnct, const LPTSTR pachDevice);
int cnctDisconnect(const HCNCT hCnct, const unsigned int uCnctFlags);
int cnctComEvent(const HCNCT hCnct, const enum COM_EVENTS event);
HDRIVER cnctQueryDriverHdl(const HCNCT hCnct);
int cnctLoad(const HCNCT hCnct);
int cnctSave(const HCNCT hCnct);
int cnctSetStartTime(HCNCT hCnct);
int cnctQueryStartTime(const HCNCT hCnct, time_t *pTime);
int cnctQueryElapsedTime(HCNCT hCnct, time_t *pTime);
int cnctInit(const HCNCT hCnct);
void cnctMessage(const HCNCT hCnct, const int idMsg);
int cnctSetDestination(const HCNCT hCnct, TCHAR * const ach, const size_t cb);
int cnctGetComSettingsString(const HCNCT hCnct, LPTSTR pach, const size_t cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cnct.hh ===
/*	File: D:\WACKER\tdll\cnct.hh (Created: 10-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 7/08/02 6:39p $
 */

typedef struct stCnctPrivate *HHCNCT;

struct stCnctPrivate
	{
	HSESSION hSession;
	CRITICAL_SECTION csCnct;		// for snychronizing access
	HDRIVER hDriver;				// baby you can drive my connect
	HMODULE hModule;				// driver's lib module handle
	TCHAR achDllName[MAX_PATH];			// name of file containing driver

	time_t	tStartTime;				// Start time

	int (WINAPI *pfDestroy)(const HDRIVER hDriver);
	int (WINAPI *pfQueryStatus)(const HDRIVER hDriver);
	int (WINAPI *pfConnect)(const HDRIVER hDriver, const unsigned int uFlags);
	int (WINAPI *pfDisconnect)(const HDRIVER hDriver, const unsigned int uFlags);
	int (WINAPI *pfComEvent)(const HDRIVER hDriver, const enum COM_EVENTS event);
	int (WINAPI *pfInit)(const HDRIVER hDriver);
	int (WINAPI *pfLoad)(const HDRIVER hDriver);
	int (WINAPI *pfSave)(const HDRIVER hDriver);
	int (WINAPI *pfSetDestination)(const HDRIVER hDriver, TCHAR *const ach, const size_t cb);
	int (WINAPI *pfGetComSettingsString)(const HDRIVER hDriver, LPTSTR pachStr, const size_t cb);
	};

void cnctLock(const HHCNCT hhCnct);
void cnctUnlock(const HHCNCT hhCnct);
void cnctStubAll(const HHCNCT hhCnct);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cloopset.c ===
/*	File: cloopset.c (created 02/19/94, JKH)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 3/20/02 12:43p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include <tdll\assert.h>
#include "session.h"
#include "timers.h"
#include "sf.h"
#include "htchar.h"
#include "cloop.h"
#include "cloop.hh"

/* --- Session file access functions --- */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopInitHdl
 *
 * DESCRIPTION:
 *	Set all cloop user settings to valid, default values.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int CLoopInitHdl(const HCLOOP hCLoop)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;

	pstCLoop->stWorkSettings.fSendCRLF		   = FALSE;
	pstCLoop->stWorkSettings.fExpandBlankLines = FALSE;
	pstCLoop->stWorkSettings.fLocalEcho 	   = FALSE;
	pstCLoop->stWorkSettings.fLineWait		   = FALSE;
	pstCLoop->stWorkSettings.chWaitChar 	   = TEXT('\r');
	pstCLoop->stWorkSettings.fExpandTabsOut    = FALSE;
	pstCLoop->stWorkSettings.nTabSizeOut	   = 8;
	pstCLoop->stWorkSettings.nLineDelay 	   = 0;
	pstCLoop->stWorkSettings.nCharDelay 	   = 0;

	pstCLoop->stWorkSettings.fAddLF 		   = FALSE;
	pstCLoop->stWorkSettings.fASCII7		   = FALSE;
	pstCLoop->stWorkSettings.fEchoplex		   = FALSE;
	pstCLoop->stWorkSettings.fShowHex		   = FALSE;
	pstCLoop->stWorkSettings.nTabSizeIn 	   = 8;

	// Original settings and working settings must match initially
	// If they no longer match at save time, then changes occurred.
	pstCLoop->stOrigSettings = pstCLoop->stWorkSettings;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopLoadHdl
 *
 * DESCRIPTION:
 *	Loads CLoop user settings from the session file
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int CLoopLoadHdl(const HCLOOP hCLoop)
	{
	unsigned long	   ul;
	ST_CLOOP		  *pstCLoop = (ST_CLOOP *)hCLoop;
	ST_CLOOP_SETTINGS *pstSettings;
	const SF_HANDLE    sfhdl = sessQuerySysFileHdl(pstCLoop->hSession);

	// Start off with default settings
	CLoopInitHdl(hCLoop);

	pstSettings = &pstCLoop->stOrigSettings;

	ul = sizeof(pstSettings->fSendCRLF);
	sfGetSessionItem(sfhdl, SF_CLOOP_SENDCRLF, &ul, &pstSettings->fSendCRLF);

	ul = sizeof(pstSettings->fExpandBlankLines);
	sfGetSessionItem(sfhdl, SF_CLOOP_EXPAND, &ul, &pstSettings->fExpandBlankLines);

	ul = sizeof(pstSettings->fLocalEcho);
	sfGetSessionItem(sfhdl, SF_CLOOP_LOCALECHO, &ul, &pstSettings->fLocalEcho);

	ul = sizeof(pstSettings->fLineWait);
	sfGetSessionItem(sfhdl, SF_CLOOP_LINEWAIT, &ul, &pstSettings->fLineWait);

	ul = sizeof(pstSettings->chWaitChar);
	sfGetSessionItem(sfhdl, SF_CLOOP_WAITCHAR, &ul, &pstSettings->chWaitChar);

	ul = sizeof(pstSettings->fExpandTabsOut);
	sfGetSessionItem(sfhdl, SF_CLOOP_EXTABSOUT, &ul, &pstSettings->fExpandTabsOut);

	ul = sizeof(pstSettings->nTabSizeOut);
	sfGetSessionItem(sfhdl, SF_CLOOP_TABSIZEOUT, &ul, &pstSettings->nTabSizeOut);

	ul = sizeof(pstSettings->nLineDelay);
	sfGetSessionItem(sfhdl, SF_CLOOP_LINEDELAY, &ul, &pstSettings->nLineDelay);

	ul = sizeof(pstSettings->nCharDelay);
	sfGetSessionItem(sfhdl, SF_CLOOP_CHARDELAY, &ul, &pstSettings->nCharDelay);

	ul = sizeof(pstSettings->fAddLF);
	sfGetSessionItem(sfhdl, SF_CLOOP_ADDLF, &ul, &pstSettings->fAddLF);

	ul = sizeof(pstSettings->fASCII7);
	sfGetSessionItem(sfhdl, SF_CLOOP_ASCII7, &ul, &pstSettings->fASCII7);

	ul = sizeof(pstSettings->fEchoplex);
	sfGetSessionItem(sfhdl, SF_CLOOP_ECHOPLEX, &ul, &pstSettings->fEchoplex);

	ul = sizeof(pstSettings->fShowHex);
	sfGetSessionItem(sfhdl, SF_CLOOP_SHOWHEX, &ul, &pstSettings->fShowHex);

	ul = sizeof(pstSettings->nTabSizeIn);
	sfGetSessionItem(sfhdl, SF_CLOOP_TABSIZEIN, &ul, &pstSettings->nTabSizeIn);

	ul = sizeof(pstCLoop->fDoMBCS);
	sfGetSessionItem(sfhdl, SF_CLOOP_DBCS, &ul, &pstCLoop->fDoMBCS);

	pstCLoop->stWorkSettings = pstCLoop->stOrigSettings;
	return 0;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopSaveHdl
 *
 * DESCRIPTION:
 *	Saves CLoop user settings in the session file if any changes have
 *	been made.
 *
 * ARGUMENTS:
 *	hCLoop -- The CLoop handle created by CLoopCreateHandle
 *
 * RETURNS:
 *	nothing
 */
int CLoopSaveHdl(const HCLOOP hCLoop)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;
	ST_CLOOP_SETTINGS *pstSettings;
	SF_HANDLE hSF;
	#define PutItem(v,i) sfPutSessionItem(hSF, i, sizeof(v), &(v))

	EnterCriticalSection(&pstCLoop->csect);

	hSF = sessQuerySysFileHdl(pstCLoop->hSession);

	// If any settings have changed, write all settings out to session file
	// Outgoing line endings
#if 1
	// Decided on 3/23 to modify design so handles will write out all
	// settings and session file routiines will decide what has changed
	if (TRUE)
#else
	if (memcmp(&pstCLoop->stWorkSettings, &pstCLoop->stOrigSettings,
		   sizeof(pstCLoop->stWorkSettings)) != 0)
#endif
		{
		pstSettings = &pstCLoop->stWorkSettings;

		PutItem(pstSettings->fSendCRLF, SF_CLOOP_SENDCRLF);
		PutItem(pstSettings->fExpandBlankLines, SF_CLOOP_EXPAND);
		PutItem(pstSettings->fLocalEcho, SF_CLOOP_LOCALECHO);
		PutItem(pstSettings->fLineWait, SF_CLOOP_LINEWAIT);
		PutItem(pstSettings->chWaitChar, SF_CLOOP_WAITCHAR);
		PutItem(pstSettings->fExpandTabsOut, SF_CLOOP_EXTABSOUT);
		PutItem(pstSettings->nTabSizeOut, SF_CLOOP_TABSIZEOUT);
		PutItem(pstSettings->nLineDelay, SF_CLOOP_LINEDELAY);
		PutItem(pstSettings->nCharDelay, SF_CLOOP_CHARDELAY);
		PutItem(pstSettings->fAddLF, SF_CLOOP_ADDLF);
		PutItem(pstSettings->fASCII7, SF_CLOOP_ASCII7);
		PutItem(pstSettings->fEchoplex, SF_CLOOP_ECHOPLEX);
		PutItem(pstSettings->fShowHex, SF_CLOOP_SHOWHEX);
		PutItem(pstSettings->nTabSizeIn, SF_CLOOP_TABSIZEIN);
		PutItem(pstCLoop->fDoMBCS, SF_CLOOP_DBCS);

		pstCLoop->stOrigSettings = pstCLoop->stWorkSettings;
		}

	LeaveCriticalSection(&pstCLoop->csect);
	return SF_OK;
	}

/* --- Access functions for user settings --- */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopGetXXXXX (several functions)
 *
 * DESCRIPTION:
 *	Retrieves the named user setting.
 *
 * ARGUMENTS:
 *	hCLoop -- Value returned from CLoopCreateHandle
 *
 * RETURNS:
 *	The requested user setting.
 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopSetXXXXX (several functions)
 *
 * DESCRIPTION:
 *	Sets the named user setting
 *
 * ARGUMENTS:
 *	hCLoop -- Value returned from CLoopCreateHandle
 *	<varname> -- The value to be set
 *
 * RETURNS:
 *	nothing
 */

/* ------------------------------------------------------------*/

int CLoopGetSendCRLF(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal =	((ST_CLOOP *)hCLoop)->stWorkSettings.fSendCRLF;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetSendCRLF(const HCLOOP hCLoop, const int fSendCRLF)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fSendCRLF = fSendCRLF;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetExpandBlankLines(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fExpandBlankLines;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetExpandBlankLines(const HCLOOP hCLoop, const int fExpandBlankLines)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fExpandBlankLines = fExpandBlankLines;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetLocalEcho(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fLocalEcho;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetLocalEcho(const HCLOOP hCLoop, const int fLocalEcho)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fLocalEcho = fLocalEcho;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetLineWait(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fLineWait;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetLineWait(const HCLOOP hCLoop, const int fLineWait)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fLineWait = fLineWait;

	// Clear line wait flag in case option is turned off while waiting
	CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_LINEWAIT);
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

TCHAR CLoopGetWaitChar(const HCLOOP hCLoop)
	{
	TCHAR chVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	chVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.chWaitChar;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return chVal;
	}

void CLoopSetWaitChar(const HCLOOP hCLoop, TCHAR chWaitChar)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.chWaitChar = chWaitChar;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetExpandTabsOut(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fExpandTabsOut;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetExpandTabsOut(const HCLOOP hCLoop, const int fExpandTabsOut)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fExpandTabsOut = fExpandTabsOut;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetTabSizeOut(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.nTabSizeOut;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetTabSizeOut(const HCLOOP hCLoop, const int nTabSizeOut)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.nTabSizeOut = nTabSizeOut;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetLineDelay(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal =	((ST_CLOOP *)hCLoop)->stWorkSettings.nLineDelay;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetLineDelay(const HCLOOP hCLoop, const int nLineDelay)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.nLineDelay = nLineDelay;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetCharDelay(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.nCharDelay;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetCharDelay(const HCLOOP hCLoop, const int nCharDelay)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.nCharDelay = nCharDelay;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetAddLF(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fAddLF;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetAddLF(const HCLOOP hCLoop, const int fAddLF)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fAddLF = fAddLF;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetASCII7(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fASCII7;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetASCII7(const HCLOOP hCLoop, const int fASCII7)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fASCII7 = fASCII7;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetEchoplex(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fEchoplex;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetEchoplex(const HCLOOP hCLoop, const int fEchoplex)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fEchoplex = fEchoplex;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

#if 0
int CLoopGetWrapLines(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fWrapLines;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetWrapLines(const HCLOOP hCLoop, const int fWrapLines)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fWrapLines = fWrapLines;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}
#endif

/* ------------------------------------------------------------*/

int CLoopGetShowHex(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.fShowHex;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetShowHex(const HCLOOP hCLoop, const int fShowHex)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.fShowHex = fShowHex;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/

int CLoopGetTabSizeIn(const HCLOOP hCLoop)
	{
	int iVal;

	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	iVal = ((ST_CLOOP *)hCLoop)->stWorkSettings.nTabSizeIn;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return iVal;
	}

void CLoopSetTabSizeIn(const HCLOOP hCLoop, const int nTabSizeIn)
	{
	assert(hCLoop);
	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	((ST_CLOOP *)hCLoop)->stWorkSettings.nTabSizeIn = nTabSizeIn;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	}

/* ------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\com.c ===
/* com.c -- High level com routines
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 15 $
 *	$Date: 7/08/02 6:40p $
 */

#include <windows.h>
#pragma hdrstop

// #define DEBUGSTR
#include <time.h>

#include "stdtyp.h"
#include "session.h"
#include "cnct.h"
#include "assert.h"
#include "mc.h"
#include "cloop.h"
#include "tdll.h"
#include "sf.h"
#include "htchar.h"
#include "com.h"
#include "comdev.h"
#include "com.hh"
#include <comstd\comstd.hh> // Drivers are linked directly in in this vers.
#if defined(INCL_WINSOCK)
#include <comwsock\comwsock.hh>
#endif  // defined(INCL_WINSOCK)
#include "XFER_MSC.HH"     // XD_TYPE

int WINAPI WsckDeviceInitialize(HCOM hCom,
    unsigned nInterfaceVersion,
    void **ppvDriverData);


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComCreateHandle
 *
 * DESCRIPTION:
 *	Creates a communications handle to be used with subsequent Com calls.
 *	The resulting com handle will not be associated with any actual device
 *	or port initially.
 *
 * ARGUMENTS:
 *	hSession   -- Session handle of session creating com handle
 *	hwndNotify -- Window to receive Com notifications
 *	phcom	   -- pointer to a var. of type HCOM to receive new com handle
 *
 * RETURNS:
 *	COM_OK
 *	COM_NOT_ENOUGH_MEMORY if there is insufficient memory
 *	COM_FAILED			  if resources could not be obtained
 *  COM_INVALID_HANDLE    if handle to Com is invalid
 */
int ComCreateHandle(const HSESSION hSession, HCOM *phcom)
	{
	int  iRet = COM_OK;
	HCOM pstCom;

	DBGOUT_NORMAL("+ComCreateHandle for session %08lX\r\n", hSession,0,0,0,0);

	assert(phcom);
	if (phcom)
		{
		pstCom = *phcom;

		if(pstCom && ComValidHandle(pstCom))
			{
			// Disconnect from driver
			ComFreeDevice(pstCom);

			if (pstCom->hRcvEvent)
				{
				ResetEvent(pstCom->hRcvEvent);
				CloseHandle(pstCom->hRcvEvent);
				pstCom->hRcvEvent = NULL;
				}
			if (pstCom->hSndReady)
				{
				ResetEvent(pstCom->hSndReady);
				CloseHandle(pstCom->hSndReady);
				pstCom->hSndReady = NULL;
				}
			*phcom = NULL;
			}
		}

	// See if we can get memory for a handle
	if ((pstCom = malloc(sizeof(*pstCom))) == NULL)
		{
		// This error can't be reported by ComReportError because no
		//	Com Handle exists yet.
		//* utilReportError(hSession, RE_ERROR | RE_OK, NM_NEED_MEM,
		//* 	   strldGet(mGetStrldHdl(hSession), NM_CREATE_SESSION));
		DBGOUT_NORMAL("-ComCreateHandle returning COM_NOT_ENOUGH_MEMORY",
				0,0,0,0,0);
		iRet = COM_NOT_ENOUGH_MEMORY;
		goto Checkout;
		}

	// Initialize to all zeros just to be on the safe side
	memset(pstCom, 0, sizeof(*pstCom));

	// ComInitHdl will initialize most values. We must pre-initialize
	// enough so that ComInitHdl knows if it needs to shut anything down.
	pstCom->hSession	  = hSession;
	pstCom->hDriverModule = (HANDLE)0;
	pstCom->fPortActive   = FALSE;
	pstCom->nGuard		  = COM_VERSION;

	pstCom->hRcvEvent = NULL;
	pstCom->hSndReady = NULL;
	pstCom->hRcvEvent = CreateEvent(NULL,
									TRUE,	// must be manually reset
									FALSE,	// create unsignalled
									NULL);  // unnamed
	if (pstCom->hRcvEvent == NULL)
		{
		iRet = COM_FAILED;
		goto Checkout;
		}

    pstCom->hSndReady = CreateEvent(NULL,
									TRUE,	// must be manually reset
									FALSE,	// create unsignalled
									NULL);     // unnamed
    if (pstCom->hSndReady == NULL)
        {
		CloseHandle(pstCom->hRcvEvent);
		pstCom->hRcvEvent = NULL;
        iRet = COM_FAILED;
        goto Checkout;
        }

	if ((iRet = ComInitHdl(pstCom)) != COM_OK)
		{
		goto Checkout;
		}


	Checkout:

	if (iRet == COM_OK)
		{
		*phcom = (HCOM)pstCom;
		}
	else
		{
		*phcom = NULL;
		if (pstCom)
			{
			if (pstCom->hRcvEvent)
				{
				ResetEvent(pstCom->hRcvEvent);
				CloseHandle(pstCom->hRcvEvent);
				pstCom->hRcvEvent = NULL;
				}
            if (pstCom->hSndReady)
				{
				ResetEvent(pstCom->hSndReady);
                CloseHandle(pstCom->hSndReady);
				pstCom->hSndReady = NULL;
				}
			free(pstCom);
			pstCom = NULL;
			}
		}

	DBGOUT_NORMAL("ComCreateHandle returning %d, pstCom == %08lX\r\n",
			iRet, pstCom, 0,0,0);

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDestroyHandle
 *
 * DESCRIPTION:
 *	Shuts down an existing com handle and frees all resources assigned to it.
 *
 * ARGUMENTS:
 *	hCom -- A com handle returned from an earlier call to ComCreateHandle
 *			(or ComCreateWudgeHandle)
 *
 * RETURNS:
 *	COM_OK
 */
int ComDestroyHandle(HCOM *phCom)
	{
	int   iRetVal = COM_OK;
	HCOM  pstCom;

	DBGOUT_NORMAL("+ComDestroyHandle(%#08lx)\r\n", *phCom,0,0,0,0);
	assert(phCom);

	// OK to pass null handle to this function
	if (*phCom == NULL)
		{
		DBGOUT_NORMAL("-ComDestroyHandle returning COM_OK\r\n", 0,0,0,0,0);
		return COM_OK;
		}

	pstCom = *phCom;
	assert(ComValidHandle(pstCom));

	// Disconnect from driver
	ComFreeDevice(pstCom);

	if (pstCom->hRcvEvent)
		{
		ResetEvent(pstCom->hRcvEvent);;
		CloseHandle(pstCom->hRcvEvent);
		pstCom->hRcvEvent = NULL;
		}
    if (pstCom->hSndReady)
		{
		ResetEvent(pstCom->hSndReady);
        CloseHandle(pstCom->hSndReady);
		pstCom->hSndReady = NULL;
		}

	free(pstCom);
	*phCom = NULL;
	DBGOUT_NORMAL("-ComDestroyHandle returned %d\r\n",
			usRetVal,0,0,0,0);
	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ComInitHdl
 *
 * DESCRIPTION:
 *	Called to initialize the Com handle to its default state. Calling this
 *	function will clear any existing settings or states and reset for a
 *	new session.
 *
 * ARGUMENTS:
 *	pstCom -- Pointer to our handle data.
 *
 * RETURNS:
 *	COM_OK if all is well.
 */
int ComInitHdl(const HCOM pstCom)
	{
	int iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	// Make sure we're disconnected from any driver loaded earlier
	ComFreeDevice(pstCom);

	// Fill in default values in exported com structure
	pstCom->stComCntrl.puchRBData		= &pstCom->chDummy;
	pstCom->stComCntrl.puchRBDataLimit	= &pstCom->chDummy;

	// Fill in default values for user-settable fields
	pstCom->stWorkSettings.szDeviceFile[0] = TEXT('\0');
	pstCom->stWorkSettings.szPortName[0] = TEXT('\0');
	pstCom->stFileSettings = pstCom->stWorkSettings;

	// Fill in default values in private com structure
	pstCom->fPortActive    = FALSE;
	pstCom->fErrorReported = FALSE;
	pstCom->hDriverModule  = (HANDLE)0;
	pstCom->szDeviceName[0]= (TCHAR)0;
	pstCom->chDummy 	   = (TCHAR)0;
	pstCom->afOverride	   = 0;

    //
    // Free the send bufers prior to setting to NULL so we don't have
    // a memory leak when the buffers get malloc'd.  REV: 02/27/2001.
    //
    if (pstCom->puchSendBufr1)
        {
        free(pstCom->puchSendBufr1);
        pstCom->puchSendBufr1 = NULL;
        }
    if (pstCom->puchSendBufr2)
        {
        free(pstCom->puchSendBufr2);
        pstCom->puchSendBufr2 = NULL;
        }

    pstCom->puchSendBufr = pstCom->puchSendBufr1;
    pstCom->puchSendPut = pstCom->puchSendBufr1;

	pstCom->nSBufrSize	   = 0;
	pstCom->nSendCount	   = 0;
	pstCom->fUserCalled    = FALSE;
	pstCom->pfUserFunction = ComSendDefaultStatusFunction;

	// fill in defaults for driver functions

	pstCom->pfDeviceClose		  = ComDefDoNothing;
	pstCom->pfDeviceDialog		  = ComDefDeviceDialog;
	pstCom->pfDeviceGetCommon	  = ComDefDeviceGetCommon;
	pstCom->pfDeviceSetCommon	  = ComDefDeviceSetCommon;
	pstCom->pfDeviceSpecial 	  = ComDefDeviceSpecial;
	pstCom->pfDeviceLoadHdl 	  = ComDefDeviceLoadSaveHdl;
	pstCom->pfDeviceSaveHdl 	  = ComDefDeviceLoadSaveHdl;
	pstCom->pfPortConfigure 	  = ComDefDoNothing;
	pstCom->pfPortPreconnect	  = ComDefPortPreconnect;
	pstCom->pfPortActivate		  = ComDefPortActivate;
	pstCom->pfPortDeactivate	  = ComDefDoNothing;

	pstCom->pfPortConnected 	  = ComDefDoNothing;
	pstCom->pfRcvRefill 		  = ComDefBufrRefill;
	pstCom->pfRcvClear			  = ComDefDoNothing;
	pstCom->pfSndBufrSend		  = ComDefSndBufrSend;
	pstCom->pfSndBufrIsBusy 	  = ComDefSndBufrBusy;
	pstCom->pfSndBufrClear		  = ComDefSndBufrClear;
	pstCom->pfSndBufrQuery		  = ComDefSndBufrQuery;
	pstCom->pfSendXon			  = ComDefDoNothing;

	pstCom->pvDriverData		  = NULL;

	if (pstCom->hRcvEvent)
		{
		ResetEvent(pstCom->hRcvEvent);
		}
	if (pstCom->hSndReady)
		{
	    ResetEvent(pstCom->hSndReady);
		}

	// Normally, we would load the port type and port name values from the session file and set them,
	// but since we inherit such things from TAPI, just call ComSetDeviceFromFile with a dummy
	// name to get the proper initialization of the com driver.
	ComSetDeviceFromFile((HCOM)pstCom, "comstd.dll");

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ComLoadHdl
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int ComLoadHdl(const HCOM pstCom)
	{
	const SF_HANDLE sfHdl = sessQuerySysFileHdl(pstCom->hSession);
    int (WINAPI *pfDeviceLoadHdl)(void *pvDevData, SF_HANDLE sfHdl);
    int     iRetVal;

    pfDeviceLoadHdl = DeviceLoadHdl;
    iRetVal = (*pfDeviceLoadHdl)(pstCom->pvDriverData, sfHdl);

#if defined(INCL_WINSOCK)
    if (iRetVal == SF_OK)
        {
        pfDeviceLoadHdl = WsckDeviceLoadHdl;
        iRetVal = (*pfDeviceLoadHdl)(pstCom->pvDriverData, sfHdl);
        }
#endif  // defined(INCL_WINSOCK)

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ComSaveHdl
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int ComSaveHdl(const HCOM pstCom)
	{
	const SF_HANDLE sfHdl = sessQuerySysFileHdl(pstCom->hSession);
	int (WINAPI *pfDeviceSaveHdl)(void *pvDevData, SF_HANDLE sfHdl);
    int     iRetVal;

    pfDeviceSaveHdl = DeviceSaveHdl;
    iRetVal = (*pfDeviceSaveHdl)(pstCom->pvDriverData, sfHdl);

#if defined(INCL_WINSOCK)
    if (iRetVal == SF_OK)
        {
        pfDeviceSaveHdl = WsckDeviceSaveHdl;
        iRetVal = (*pfDeviceSaveHdl)(pstCom->pvDriverData, sfHdl);
        }
#endif  // defined(INCL_WINSOCK)

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int ComSetDeviceFromFile(const HCOM pstCom, const TCHAR * const pszFileName)
	{
	int    iRetVal = COM_OK;
	int    (WINAPI *pfDeviceInit)(HCOM, unsigned, void **);

	if (pstCom->pvDriverData)
		return COM_OK;
	
	// If loadable com drivers were actually implemented, we wouldl load the proper .DLL module here
	// and initialize it. In this version, though, we have only one com driver and it is linked right
	// in. So rather than doing GetProcAddress calls to link to the driver, we can simply load function
	// addresses right into function pointers.
    //
    // Not true anymore! We now have two com drivers to support. But since
    // we still don't load from DLLs, we just let the two drivers share the
    // driver data structure, and each initializes its own specific members.
    // - jmh 02-22-96
	pstCom->hDriverModule = (HANDLE)1;		// Set this to fake value so we can close
	pfDeviceInit = DeviceInitialize;

	if ((iRetVal = (*pfDeviceInit)(pstCom, COM_VERSION,
			&pstCom->pvDriverData)) != COM_OK)
		{
		// The device driver cannot report errors itself until it has
		// been initialized. So we must report any errors it encountered.
		//* if (iRetVal == COM_DEVICE_VERSION_ERROR)
		//* ComReportError(pstCom, CM_ERR_WRONG_VERSION, pszFileName, TRUE);
		//* else
		//* ComReportError(pstCom, CM_ERR_CANT_INIT, pszFileName, TRUE);

		DBGOUT_NORMAL(" ComSetDevice: *pfDeviceInit failed\r\n",0,0,0,0,0);
		goto Checkout;
		}

#if defined(INCL_WINSOCK)
    // Initialize the driver data structure members specific to WinSock.
    //
	pfDeviceInit = WsckDeviceInitialize;

	if ((iRetVal = (*pfDeviceInit)(pstCom, COM_VERSION,
			&pstCom->pvDriverData)) != COM_OK)
		{
		goto Checkout;
		}
#endif  // defined(INCL_WINSOCK)

	pstCom->pfDeviceClose = DeviceClose;
	pstCom->pfDeviceDialog = DeviceDialog;
	pstCom->pfDeviceGetCommon = DeviceGetCommon;
	pstCom->pfDeviceSetCommon = DeviceSetCommon;
	pstCom->pfDeviceSpecial = DeviceSpecial;
	pstCom->pfPortConfigure = PortConfigure;
	//pstCom->pfPortPreconnect = PortPreconnect;
	pstCom->pfPortPreconnect = ComDefPortPreconnect;
	pstCom->pfPortActivate = PortActivate;

	Checkout:
	// if something went wrong, set comm to invalid driver state and return err
	if (iRetVal != COM_OK)
		ComFreeDevice(pstCom);

	DBGOUT_NORMAL("-ComSetDevice returning %d\r\n", iRetVal,0,0,0,0);
	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetDeviceName
 *
 * DESCRIPTION:
 *	Returns name of device associated with a com handle
 *
 * ARGUMENTS:
 *	pstCom	-- com handle returned from earlier call to ComCreateHandle
 *	pszName -- pointer to buffer to receive device name (may be NULL)
 *	pusLen	-- pointer length variable. If pszName is not NULL, this variable
 *				should contain the size of the buffer pointed to by pszName.
 *				In either case, *pusLen will be set to the size of the
 *				device name to be returned.
 *
 * RETURNS:
 *	COM_OK
 *	COM_INVALID_HANDLE
 */
int ComGetDeviceName(const HCOM pstCom,
			TCHAR * const pszName,
			int * const pnLen)
	{
	int iRetVal = COM_OK;
	int nTheirLen;

	DBGOUT_NORMAL("+ComGetDevice(%#08lx)\r\n", pstCom,0,0,0,0);
	assert(ComValidHandle(pstCom));
	assert(pnLen);

	nTheirLen = *pnLen;
	*pnLen = StrCharGetByteCount(pstCom->szDeviceName);

	if (pszName)
		{
		assert(nTheirLen >= (*pnLen + 1));
		if (nTheirLen >= (*pnLen + 1))
			StrCharCopyN(pszName, pstCom->szDeviceName, *pnLen);
		DBGOUT_NORMAL(" ComGetDevice: providing name (%s)\r\n", pszName,0,0,0,0);
		}
	DBGOUT_NORMAL("-ComGetDevice returning %d\r\n", iRetVal,0,0,0,0);
	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ComGetRcvEvent
 *
 * DESCRIPTION:
 *	Returns a handle to an event object that can be used to wait for
 *	received data to be available from the com routines.
 *
 * ARGUMENTS:
 *	pstCom	  -- com handle returned from earlier call to ComCreateHandle
 *
 * RETURNS:
 *	The Receive event object
 */
HANDLE ComGetRcvEvent(HCOM pstCom)
	{
	return pstCom->hRcvEvent;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetSession
 *
 * DESCRIPTION:
 *	Returns Session Handle associated with a Com handle
 *
 * ARGUMENTS:
 *	pstCom	  -- com handle returned from earlier call to ComCreateHandle
 *	phSession -- pointer to session handle to receive result
 *
 * RETURNS:
 *	always returns COM_OK
 */
int ComGetSession(const HCOM pstCom, HSESSION * const phSession)
	{
	assert(ComValidHandle(pstCom));
	assert(phSession);

	*phSession = pstCom->hSession;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComNotify
 *
 * DESCRIPTION:
 *	Called by driver modules to notify com routines of significant events
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void ComNotify(const HCOM pstCom, enum COM_EVENTS event)
	{

	assert(ComValidHandle(pstCom));

	switch (event)
		{
	case CONNECT:
		cnctComEvent(sessQueryCnctHdl(pstCom->hSession), CONNECT);
        //
        // Set the send and recieve events so we'll wake the COM thread
        // and start sending and/or receiving data. REV: 08/27/2001
        //
        SetEvent(pstCom->hSndReady);
		SetEvent(pstCom->hRcvEvent);
		break;

	case DATA_RECEIVED:
		SetEvent(pstCom->hRcvEvent);
		CLoopRcvControl(sessQueryCLoopHdl(pstCom->hSession), CLOOP_RESUME,
				CLOOP_RB_NODATA);
		break;

	case NODATA:
		ResetEvent(pstCom->hRcvEvent);
		break;

	case SEND_STARTED:
		// NotifyClient(pstCom->hSession, EVENT_LED_SD_ON, 0);
		//DbgOutStr("Send started\n",0,0,0,0,0);
        ResetEvent(pstCom->hSndReady);
		break;

	case SEND_DONE:
		// NotifyClient(pstCom->hSession, EVENT_LED_SD_OFF, 0);
		//DbgOutStr("Send done\n",0,0,0,0,0);
        SetEvent(pstCom->hSndReady);
		break;

	default:
		assert(FALSE);
		break;
		}
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComIsActive
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComIsActive(const HCOM pstCom)
	{
	int iRet = COM_OK;

	assert(ComValidHandle(pstCom));

	if (pstCom == NULL || !pstCom->fPortActive)
		{
		iRet = COM_PORT_NOT_OPEN;
		}

	return iRet;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSetPortName
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSetPortName(const HCOM pstCom, const TCHAR * const pszPortName)
	{
	int iRetVal = COM_OK;

	DBGOUT_NORMAL("+ComSetPortName(%#08lx, %s)\r\n", pstCom, pszPortName,0,0,0);
	assert(ComValidHandle(pstCom));

	if (!pszPortName)
		iRetVal = COM_PORT_INVALID_NAME;

	else if (ComIsActive(pstCom) == COM_OK)
		iRetVal = COM_PORT_IN_USE;

	if (StrCharCmp(pszPortName, pstCom->stWorkSettings.szPortName) != 0)
		{
		//* TODO: call driver to check validity of name
		StrCharCopyN(pstCom->stWorkSettings.szPortName, pszPortName, COM_MAX_PORT_NAME);
		}

	DBGOUT_NORMAL("-ComSetPortName returned %u\r\n", iRetVal, 0,0,0,0);

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetPortName
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComGetPortName(const HCOM pstCom, TCHAR * const pszName, int nLen)
	{
	int iRetVal = COM_INVALID_HANDLE;

	DBGOUT_NORMAL("+ComGetPortName(%#08lx)\r\n", pstCom, 0,0,0,0);

	if (pstCom && ComValidHandle(pstCom))
		{
		if (pszName)
			{
			if (nLen > StrCharGetStrLength(pstCom->stWorkSettings.szPortName))
				{
				iRetVal = COM_OK;
				StrCharCopyN(pszName, pstCom->stWorkSettings.szPortName, nLen);
				}
			else
				{
				iRetVal = COM_NOT_ENOUGH_MEMORY;
				pszName[0] = TEXT('\0');
				}
			}
		else
			{
			iRetVal = COM_PORT_INVALID_NAME;
			pszName[0] = TEXT('\0');
			}
		}

	DBGOUT_NORMAL("-ComGetPortName returning %u, size = %u, name = %s\r\n",
			iRetVal, nLen, pszName ? pszName : " ",0,0);

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetAutoDetect
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComGetAutoDetect(HCOM pstCom, int *pfAutoDetect)
	{
	int iRet = COM_OK;
	struct s_common stCommon;

	assert(ComValidHandle(pstCom));
	assert(pfAutoDetect);

	if (pstCom->pfDeviceGetCommon == NULL)
		iRet = COM_NOT_SUPPORTED;
	else if ((*pstCom->pfDeviceGetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
		iRet = COM_DEVICE_ERROR;
	else if (!bittest(stCommon.afItem, COM_AUTO))
		iRet = COM_NOT_SUPPORTED;
	else if (pfAutoDetect)
		*pfAutoDetect = stCommon.fAutoDetect;

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSetAutoDetect
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int ComSetAutoDetect(HCOM pstCom, int fAutoDetect)
	{
	struct s_common stCommon;
	int 	  		fDummy;
	int 			iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	if (ComGetAutoDetect(pstCom, &fDummy) == COM_NOT_SUPPORTED)
        {
		iRetVal = COM_NOT_SUPPORTED;
        }
    else
        {
		stCommon.afItem = COM_AUTO;
		stCommon.fAutoDetect = fAutoDetect;

		if ((*pstCom->pfDeviceSetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
            {
			iRetVal = COM_DEVICE_ERROR;
            }
        }

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetBaud
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComGetBaud(const HCOM pstCom, long * const plBaud)
	{
	ST_COMMON stCommon;

	assert(ComValidHandle(pstCom));
	assert(plBaud);

	if (pstCom->pfDeviceGetCommon == NULL)
		return COM_NOT_SUPPORTED;

	if ((*pstCom->pfDeviceGetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
		return COM_DEVICE_ERROR;

	if (!bittest(stCommon.afItem, COM_BAUD))
		return COM_NOT_SUPPORTED;

	*plBaud = stCommon.lBaud;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSetBaud
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSetBaud(const HCOM pstCom, const long lBaud)
	{
	ST_COMMON stCommon;
	long	  lDummy;
	int 	  iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	if (ComGetBaud(pstCom, &lDummy) == COM_NOT_SUPPORTED)
        {
		iRetVal =  COM_NOT_SUPPORTED;
        }
    else
        {
		stCommon.afItem = COM_BAUD;
		stCommon.lBaud = lBaud;

		if ((*pstCom->pfDeviceSetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
            {
			iRetVal = COM_DEVICE_ERROR;
            }
        }

    return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetDataBits
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComGetDataBits(const HCOM pstCom, int * const pnDataBits)
	{
	ST_COMMON stCommon;

	assert(ComValidHandle(pstCom));
	assert(pnDataBits);

	if (pstCom->pfDeviceGetCommon == NULL)
		return COM_NOT_SUPPORTED;

	if ((*pstCom->pfDeviceGetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
		return COM_DEVICE_ERROR;

	if (!bittest(stCommon.afItem, COM_DATABITS))
		return COM_NOT_SUPPORTED;

	*pnDataBits = stCommon.nDataBits;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSetDataBits
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSetDataBits(const HCOM pstCom, const int nDataBits)
	{
	ST_COMMON stCommon;
	int 	  nDummy;
	int 	  iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	if (ComGetDataBits(pstCom, &nDummy) == COM_NOT_SUPPORTED)
        {
		iRetVal = COM_NOT_SUPPORTED;
        }
    else
        {
	    stCommon.afItem = COM_DATABITS;
	    stCommon.nDataBits = nDataBits;

	    if ((*pstCom->pfDeviceSetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
            {
		    iRetVal = COM_DEVICE_ERROR;
            }
        }

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetStopBits
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComGetStopBits(const HCOM pstCom, int * const pnStopBits)
	{
	ST_COMMON stCommon;

	assert(ComValidHandle(pstCom));
	assert(pnStopBits);

	if (pstCom->pfDeviceGetCommon == NULL)
		return COM_NOT_SUPPORTED;

	if ((*pstCom->pfDeviceGetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
		return COM_DEVICE_ERROR;

	if (!bittest(stCommon.afItem, COM_STOPBITS))
		return COM_NOT_SUPPORTED;

	*pnStopBits = stCommon.nStopBits;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSetStopBits
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSetStopBits(const HCOM pstCom, const int nStopBits)
	{
	ST_COMMON stCommon;
	int 	  nDummy;
	int 	  iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	if (ComGetStopBits(pstCom, &nDummy) == COM_NOT_SUPPORTED)
        {
		iRetVal = COM_NOT_SUPPORTED;
        }
    else
        {
	    stCommon.afItem = COM_STOPBITS;
	    stCommon.nStopBits = nStopBits;

	    if ((*pstCom->pfDeviceSetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
            {
		    iRetVal = COM_DEVICE_ERROR;
            }
        }

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComGetParity
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComGetParity(const HCOM pstCom, int * const pnParity)
	{
	ST_COMMON stCommon;

	assert(ComValidHandle(pstCom));
	assert(pnParity);

	if (pstCom->pfDeviceGetCommon == NULL)
		return COM_NOT_SUPPORTED;

	if ((*pstCom->pfDeviceGetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
		return COM_DEVICE_ERROR;

	if (!bittest(stCommon.afItem, COM_PARITY))
		return COM_NOT_SUPPORTED;

	*pnParity = stCommon.nParity;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSetParity
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSetParity(const HCOM pstCom, const int nParity)
	{
	ST_COMMON stCommon;
	int 	  nDummy;
	int 	  iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	if (ComGetParity(pstCom, &nDummy) == COM_NOT_SUPPORTED)
        {
		iRetVal = COM_NOT_SUPPORTED;
        }
    else
        {
	    stCommon.afItem = COM_PARITY;
	    stCommon.nParity = nParity;

	    if ((*pstCom->pfDeviceSetCommon)(pstCom->pvDriverData, &stCommon) != COM_OK)
            {
		    iRetVal = COM_DEVICE_ERROR;
            }
        }

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComPreconnect
 *
 * DESCRIPTION:
 *	This function is called just before a connection is attempted. It is
 *	called at a point in the connection process when user interaction is
 *	straight-forward. Certain devices may need to interact with the user
 *	in order to work (having user insert a card, or select from a pool of
 *	devices, etc.). User interaction may not be possible at the time that
 *	ComActivatePort is called, so it should be done here. This routine
 *	may lay claim to a resource and hold it pending the call to
 *	ComActivatePort. Once this routine is called, ComActivatePort will
 *	usually be called (but not necessarily always); ComDeactivatePort will
 *	always be called.
 *
 * ARGUMENTS:
 *	pstCom		-- a com handle as returned by ComCreateHandle
 *
 * RETURNS:
 *	COM_OK		-- if the connection attempt should continue
 *	COM_FAILED	-- if the connection attempt should be abandoned. (in this
 *				   case, it is up to the driver to display the reason
 *				   before returning)
 */
int ComPreconnect(const HCOM pstCom)
	{
	int iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	iRetVal = (*pstCom->pfPortPreconnect)(pstCom->pvDriverData,
			pstCom->stWorkSettings.szPortName, sessQueryHwnd(pstCom->hSession));

	if (iRetVal != COM_OK)
		{
		iRetVal = COM_FAILED;
		}

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComActivatePort
 *
 * DESCRIPTION:
 *	Attempts to activate the port associated with a com handle. This call
 *	will not necessarily attempt to complete a connection.
 *	Note: this function will display an error messages for all errors except
 *		  COM_PORT_IN_USE. If a COM_PORT_IN_USE error is encountered and
 *		  is not rectified by borrowing or changing ports, the error message
 *		  should be displayed by the calling routine.
 *
 * ARGUMENTS:
 *	pstCom		-- a com handle as returned by ComCreateHandle
 *
 * RETURNS:
 *	COM_OK
 *	COM_PORT_IN_USE -- Port is in use by another process.
 *	or error code as defined in COM.H
 */
int ComActivatePort(const HCOM pstCom, DWORD_PTR dwMediaHdl)
	{
	int iRetVal = COM_OK;

	// This function (or the functions it calls) should report all errors
	//	 except for COM_PORT_IN_USE. Higher level routines may want to
	//	 try some recovery techniques before reporting an unavailable port
	assert(ComValidHandle(pstCom));

	DBGOUT_NORMAL("+ComActivatePort(%#08x)\r\n", pstCom, 0,0,0,0);
	if (ComIsActive(pstCom) != COM_OK)
		{
		//* TODO: this is temporary until we resolve how driver and program
		//		 decide on size of send buffers.
		pstCom->nSBufrSize = 128;

        //
        // Free the send bufers prior to setting to malloc so we don't
        // have a memory leak.  REV: 02/27/2001.
        //
        if (pstCom->puchSendBufr1)
            {
            free(pstCom->puchSendBufr1);
            pstCom->puchSendBufr1 = NULL;
            }
        if (pstCom->puchSendBufr2)
            {
            free(pstCom->puchSendBufr2);
            pstCom->puchSendBufr2 = NULL;
            }

		// Allocate ComSend buffers
		if ((pstCom->puchSendBufr1 =
				malloc((size_t)pstCom->nSBufrSize)) == NULL ||
				(pstCom->puchSendBufr2 =
				malloc((size_t)pstCom->nSBufrSize)) == NULL)
			{
			DBGOUT_NORMAL(" ComActivatePort -- no memory for send buffers\r\n",
					0,0,0,0,0);
			//* ComReportError(pstCom, NM_NEED_MEMFOR,
			//* 		strldGet(mGetStrldHdl(pstCom->hSession), CM_NM_COMDRIVER), TRUE);
			iRetVal = COM_NOT_ENOUGH_MEMORY;
			goto checkout;
			}

		pstCom->puchSendBufr = pstCom->puchSendPut = pstCom->puchSendBufr1;
		pstCom->nSendCount = 0;
		pstCom->fUserCalled = FALSE;
		pstCom->pfUserFunction = ComSendDefaultStatusFunction;

 		// Now call on driver code to activate the physical device
		if ((iRetVal = (*pstCom->pfPortActivate)(pstCom->pvDriverData,
				pstCom->stWorkSettings.szPortName, dwMediaHdl)) == COM_OK)
            {
            //
            // Reset the transfer's loss of carrier flag. REV: 08/23/2001
            //
            XD_TYPE* pX = (XD_TYPE*)sessQueryXferHdl(pstCom->hSession);

            if (pX != NULL)
                {
                pX->nCarrierLost = FALSE;
                }

			pstCom->fPortActive = TRUE;
            }
		}

	checkout:
	if (iRetVal != COM_OK)
		{
		ComDeactivatePort(pstCom);
		}
	DBGOUT_NORMAL("-ComActivatePort returning %u\r\n", iRetVal, 0,0,0,0);
	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDeactivatePort
 *
 * DESCRIPTION:
 *	Attempts to deactivate the port associated with a com handle. This call
 *
 * ARGUMENTS:
 *	pstCom		-- a com handle as returned by ComCreateHandle
 *
 * RETURNS:
 *	COM_OK
 *	or error code as defined in COM.H
 */
int ComDeactivatePort(const HCOM pstCom)
	{
	int iRetVal = COM_OK;
	int iPortConnected = COM_PORT_NOT_OPEN;

	DBGOUT_NORMAL("+ComDeactivatePort(%#08x)\r\n", pstCom,0,0,0,0);

	if (ComValidHandle(pstCom) == FALSE || pstCom == NULL)
		{
		assert(0);
		return COM_INVALID_HANDLE;
		}

	if (pstCom->pvDriverData != NULL)
		{
		iPortConnected = (*pstCom->pfPortConnected)(pstCom->pvDriverData);
		}

	if (pstCom->fPortActive || iPortConnected != COM_PORT_NOT_OPEN)
		{
		// Call on driver code to deactivate the physical device
		if ((iRetVal =
				(*pstCom->pfPortDeactivate)(pstCom->pvDriverData)) == COM_OK)
            {
            //
            // Reset the transfer's loss of carrier flag. REV: 08/23/2001
            //
            XD_TYPE* pX = (XD_TYPE*)sessQueryXferHdl(pstCom->hSession);

            if (pX != NULL)
                {
                pX->nCarrierLost = TRUE;
                }

			pstCom->fPortActive = FALSE;
            }
		}

    if (pstCom->pfSndBufrClear)
        {
		// Call on driver code to clear the send buffer
		iRetVal = (*pstCom->pfSndBufrClear)(pstCom->pvDriverData);
        }

	if (pstCom->hSndReady)
		{
	    ResetEvent(pstCom->hSndReady);
		}

    if (pstCom->pfRcvClear)
        {
		// Call on driver code to clear the receive buffer
		iRetVal = (*pstCom->pfRcvClear)(pstCom->pvDriverData);
        }

	if (pstCom->hRcvEvent)
		{
		ResetEvent(pstCom->hRcvEvent);
		}

	pstCom->pfPortDeactivate	= ComDefDoNothing;
	pstCom->pfPortConnected 	= ComDefDoNothing;
	pstCom->pfRcvRefill 		= ComDefBufrRefill;
	pstCom->pfRcvClear			= ComDefDoNothing;
	pstCom->pfSndBufrSend		= ComDefSndBufrSend;
	pstCom->pfSndBufrIsBusy 	= ComDefSndBufrBusy;
	pstCom->pfSndBufrClear		= ComDefSndBufrClear;
	pstCom->pfSndBufrQuery		= ComDefSndBufrQuery;
	pstCom->pfSendXon			= ComDefDoNothing;

    if (pstCom->puchSendBufr1)
        {
        free(pstCom->puchSendBufr1);
        pstCom->puchSendBufr1 = NULL;
        }
    if (pstCom->puchSendBufr2)
        {
        free(pstCom->puchSendBufr2);
        pstCom->puchSendBufr2 = NULL;
        }

	pstCom->puchSendBufr = pstCom->puchSendPut = pstCom->puchSendBufr1;
	pstCom->nSendCount = 0;
    pstCom->nSBufrSize = 0;
	pstCom->fUserCalled = FALSE;

	DBGOUT_NORMAL("-ComDeactivatePort returned %u\r\n", iRetVal, 0,0,0,0);
	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComOverride
 *
 * DESCRIPTION:
 *	Used to temporarily override the current com settings. Allows setting
 *	the com channel to support specific data transfer needs without
 *	specific knowledge of the current com device or its settings.
 *
 * ARGUMENTS:
 *	pstCom			Com handle returned by an call to CreateComHandle
 *	uiOptions		Options which specify transfer requirements. Currently:
 *						COM_OVERRIDE_8BIT	temporarily switchs port to
 *											8 bit, no parity mode
 *						COM_OVERRIDE_RCVALL temporarily suspends any com
 *											settings that would prevent some
 *											characters from being received:
 *											typically suspends recognition
 *											of received XON/XOFF codes
 *						COM_OVERRIDE_SNDALL temporarily suspends any com
 *											settings that would prevent some
 *											characters from being sent.
 *	puiOldOptions	Pointer to a unsigned variable to receive the options in
 *					force prior to this call. The value returned in this
 *					field should be used to restore the com driver when
 *					the override is no longer needed. If this value is not
 *					needed, puiOldOptions can be set to NULL.
 *
 * RETURNS:
 *	COM_OK if requested override is possible with the current com device
 *	COM_CANT_OVERRIDE if the current device cannot support the request
 *
 */
int ComOverride(const HCOM pstCom,
			const unsigned afOptions,
				  unsigned * const pafOldOptions)
	{
	unsigned afOldOverride;
	int 	 iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));

	afOldOverride = pstCom->afOverride;
	if (pafOldOptions)
		*pafOldOptions = afOldOverride;
	pstCom->afOverride = afOptions;

	if ((iRetVal = ComConfigurePort(pstCom)) == COM_CANT_OVERRIDE)
		pstCom->afOverride = afOldOverride;

	return iRetVal;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComQueryOverride
 *
 * DESCRIPTION:
 *	Returns the value of the override flags as described in ComOverride
 *
 * ARGUMENTS:
 *	pstCom			Com handle returned by an call to CreateComHandle
 *	pafOptions		Pointer to UINT to receive copy of override option flags
 *
 * RETURNS:
 *	Always returns COM_OK
 */
int ComQueryOverride(HCOM pstCom, unsigned *pafOptions)
	{
	assert(ComValidHandle(pstCom));
	assert(pafOptions);

	*pafOptions = pstCom->afOverride;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComConfigurePort
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComConfigurePort(const HCOM pstCom)
	{
	int iRetVal = COM_OK;

	DBGOUT_NORMAL("+ComconfigurePort(%#08x)\r\n", pstCom, 0,0,0,0);
	assert(ComValidHandle(pstCom));

	if (ComIsActive(pstCom) == COM_OK)
		iRetVal = (*pstCom->pfPortConfigure)(pstCom->pvDriverData);

	DBGOUT_NORMAL("-ComConfigurePort returning %u\r\n", iRetVal, 0,0,0,0);
	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComRcvBufrRefill
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComRcvBufrRefill(const HCOM pstCom, TCHAR * const tc, const int fRemoveChar)
	{
	int iRetVal;
	ST_COM_CONTROL *pstComCntrl = (ST_COM_CONTROL *)pstCom;

	iRetVal = (*pstCom->pfRcvRefill)(pstCom->pvDriverData);
	if (iRetVal)
		{
		if (tc)
			*tc = *pstComCntrl->puchRBData;
		if (fRemoveChar)
			++pstComCntrl->puchRBData;
		}

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComRcvBufrClear
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComRcvBufrClear(const HCOM pstCom)
	{
	return ((*pstCom->pfRcvClear)(pstCom->pvDriverData));
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSndBufrSend
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSndBufrSend(
		const HCOM pstCom,
		void * const pvBufr,
		const int nCount,
		const int nWait)
	{
	int iRetVal = COM_OK;

	assert(ComValidHandle(pstCom));
	assert(pvBufr);
	if (nCount > 0)
		{
        if ((*pstCom->pfPortConnected)(pstCom->pvDriverData) == COM_PORT_NOT_OPEN)
            {
            iRetVal = COM_PORT_NOT_OPEN;
            }
		else if (ComSndBufrBusy(pstCom) == COM_BUSY &&
				(!nWait || ComSndBufrWait(pstCom, nWait) != COM_OK))
			iRetVal = COM_BUSY;
		else
			{
			iRetVal = (*pstCom->pfSndBufrSend)(pstCom->pvDriverData,
					pvBufr, nCount);
			}
		}

	return iRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSndBufrBusy
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSndBufrBusy(const HCOM pstCom)
	{
	int usResult;

	usResult =	(*pstCom->pfSndBufrIsBusy)(pstCom->pvDriverData);

	return usResult;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSndBufrWait
 *
 * DESCRIPTION:
 *	Waits until the Com driver can transmit more data. The amount of time to
 *	wait can be specified. While waiting, a settable idle function is
 *	repeatedly called.
 *
 * ARGUMENTS:
 *	pstCom -- Com handle
 *	nWait -- Time to wait in tenths of a second
 *
 * RETURNS:
 *	COM_OK if driver can accept new data within the timeout interval
 *	COM_BUSY if the transmitter is still not available after timeout interval
 */
int ComSndBufrWait(const HCOM pstCom, const int nWait)
	{
	int     iRetVal = COM_OK;
	DWORD   dwRet;

    //
    // See if the port is currently connected.  If not, then return an
    // error stating the port is not connected. REV: 08/24/2001
    //
    if ((*pstCom->pfPortConnected)(pstCom->pvDriverData) == COM_PORT_NOT_OPEN)
        {
        iRetVal = COM_PORT_NOT_OPEN;
        }
	else if ((iRetVal = ComSndBufrBusy(pstCom)) != COM_OK && nWait)
		{
        //DbgOutStr("DBG_WRITE: %d Wait started\n",GetTickCount(),0,0,0,0);
        dwRet = WaitForSingleObject(pstCom->hSndReady, nWait * 100);
        if (dwRet != WAIT_OBJECT_0)
            {
            iRetVal = COM_BUSY;
            }
        else
            {
            iRetVal = COM_OK;
            }
        }
    else
        {
        //DbgOutStr("DBG_WRITE: %d No wait\n",GetTickCount(),0,0,0,0);
        }

	return iRetVal;

#if 0   // jmh 01-11-96 This was the previous method, which didn't block at all
	int  iRetVal = COM_OK;
	DWORD dwTimer;

	if ((iRetVal = ComSndBufrBusy(pstCom)) != COM_OK && nWait)
		{
		dwTimer = startinterval();
		while (interval(dwTimer) < (DWORD)nWait)
			{
			//* With thread model, not sure we still need ComIdle
			//* ComIdle(pstCom);	// Keep from locking up the program
			if (ComSndBufrBusy(pstCom) == COM_OK)
				{
				iRetVal = COM_OK;
				break;
				}
			}
		}

	return iRetVal;
#endif  // 0
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSndBufrClear
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSndBufrClear(const HCOM pstCom)
	{
	return (*pstCom->pfSndBufrClear)(pstCom->pvDriverData);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSndBufrQuery
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComSndBufrQuery(const HCOM pstCom, unsigned * const pafStatus,
		long * const plHandshakeDelay)
	{
	return (*pstCom->pfSndBufrQuery)(pstCom->pvDriverData, pafStatus,
				plHandshakeDelay);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDeviceDialog
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComDeviceDialog(const HCOM pstCom, const HWND hwndParent)
	{
	int iRetVal;

	assert(ComValidHandle(pstCom));
	iRetVal = (*pstCom->pfDeviceDialog)(pstCom->pvDriverData, hwndParent);

	return iRetVal;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDriverSpecial
 *
 * DESCRIPTION:
 *	Allows access to special features of specific Com Device Drivers using
 *	a common API.
 *
 * ARGUMENTS:
 *	pstCom			-- A Com Handle
 *	pszInstructions -- A driver specific string providing instructions
 *					   on what task a driver should carry out.
 *	pszResults		-- A buffer to receive a driver specific result string.
 *	uiBufrSize		-- The size (in bytes) of the pszResults buffer.
 *
 * RETURNS:
 *
 */
int ComDriverSpecial(const HCOM pstCom, const TCHAR * const pszInstructions,
						 TCHAR * const pszResults, const int nBufrSize)
	{
	int iRetVal = COM_NOT_SUPPORTED;

	if (pstCom == NULL)
		return iRetVal;

	if (pstCom->pfDeviceSpecial)
		iRetVal = (*pstCom->pfDeviceSpecial)(pstCom->pvDriverData,
				pszInstructions, pszResults, nBufrSize);

	return iRetVal;
	}





/* --- Internal functions --- */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComReportError
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void ComReportError(const HCOM pstCom, int iErrStr,
		const TCHAR * const pszOptInfo, const int fFirstOnly)
	{
	if (!fFirstOnly || !pstCom->fErrorReported)
		{
		//* if (iErrStr == 0)
		//* 	iErrStr = GM_TEST_FORMAT;  // just %s

		// Most error messages can be reported with a message error
		// string and (maybe) an optional string field. The optional
		// string is passed to utilReportError whether needed or not
		// since it does no harm if it is not referenced.

		//* utilReportError(pstCom->hSession, RE_ERROR | RE_OK,
		//* 		iErrStr, pszOptInfo);

		if (fFirstOnly)
			pstCom->fErrorReported = TRUE;
		}

	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComFreeDevice
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void ComFreeDevice(const HCOM pstCom)
	{
	if (pstCom == NULL)
		{
		assert(FALSE);
		return;
		}

	ComDeactivatePort(pstCom);

	if (pstCom->hDriverModule != (HANDLE)0)
		{
		if (pstCom->pfDeviceClose)
			{
			(void)(*pstCom->pfDeviceClose)(pstCom->pvDriverData);
			pstCom->pvDriverData = 0;
			// FreeLibrary(pstCom->hDriverModule);
			}

		pstCom->hDriverModule = (HANDLE)0;
		}

	pstCom->pfDeviceClose		           = ComDefDoNothing;
	pstCom->pfDeviceDialog		           = ComDefDeviceDialog;
	pstCom->pfDeviceGetCommon	           = ComDefDeviceGetCommon;
	pstCom->pfDeviceSetCommon	           = ComDefDeviceSetCommon;
	pstCom->pfDeviceSpecial 	           = ComDefDeviceSpecial;
    pstCom->pfDeviceLoadHdl 	           = ComDefDeviceLoadSaveHdl;
	pstCom->pfDeviceSaveHdl 	           = ComDefDeviceLoadSaveHdl;
	pstCom->pfPortConfigure 	           = ComDefDoNothing;
	pstCom->pfPortPreconnect	           = ComDefPortPreconnect;
	pstCom->pfPortActivate		           = ComDefPortActivate;
	pstCom->pfPortDeactivate	           = ComDefDoNothing;
	pstCom->fPortActive                    = FALSE;
	pstCom->szDeviceName[0]                = TEXT('\0');
	pstCom->stWorkSettings.szDeviceFile[0] = TEXT('\0');
	pstCom->stWorkSettings.szPortName[0]   = TEXT('\0');

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ComValidHandle
 *
 * DESCRIPTION:
 *	Tests whether a com handle points to a valid, initialize structure
 *
 * ARGUMENTS:
 *	pstCom -- com handle to be tested
 *
 * RETURNS:
 *	TRUE if com handle appears to be valid
 *	FALSE if com handle if NULL or points to an invalid structure
 */
BOOL ComValidHandle(HCOM pstCom)
	{
	BOOL bReturnValue = TRUE;

	if (pstCom == NULL)
		{
		bReturnValue = FALSE;
		}
#if !defined(NDEBUG)
	else if (pstCom->nGuard != COM_VERSION)
		{
		bReturnValue = FALSE;
		}
#endif //!defined(NDEBUG)

	return bReturnValue;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cncthdl.c ===
/*	File: D:\WACKER\tdll\cncthdl.c (Created: 10-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 10 $
 *	$Date: 7/08/02 6:40p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <time.h>

#include "stdtyp.h"
#include "session.h"
#include "mc.h"
#include "globals.h"
#include "assert.h"
#include "errorbox.h"
#include <term\res.h>
#include "cnct.h"
#include "cnct.hh"
#include <cncttapi\cncttapi.hh>
#include <emu\emu.h>
#include "htchar.h"
#include "tdll.h"

static int cnctLoadDriver(const HHCNCT hhCnct);

#define	USE_FORMATMSG

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctCreateHdl
 *
 * DESCRIPTION:
 *	Creates a connection handle which is used to perform a connection
 *	activity.
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *
 * RETURNS:
 *	Connection handle or zero on error.
 *
 */
HCNCT cnctCreateHdl(const HSESSION hSession)
	{
	HHCNCT hhCnct = 0;

	hhCnct = malloc(sizeof(*hhCnct));

	if (hhCnct == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	memset(hhCnct, 0, sizeof(*hhCnct));
	hhCnct->hSession = hSession;
	InitializeCriticalSection(&hhCnct->csCnct);
	cnctStubAll(hhCnct);

	/* Lower Wacker is hardwired to this */
	cnctSetDevice((HCNCT)hhCnct, 0);

	return (HCNCT)hhCnct;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctDestroyHdl
 *
 * DESCRIPTION:
 *	Destroys a valid connection handle.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle.
 *
 * RETURNS:
 *	void
 *
 */
void cnctDestroyHdl(const HCNCT hCnct)
	{
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	if (hhCnct == 0)
		return;

	DeleteCriticalSection(&hhCnct->csCnct);

	if (hhCnct->hDriver)
		{
		(*hhCnct->pfDestroy)(hhCnct->hDriver);
		}

	if (hhCnct->hModule)
		{
		FreeLibrary(hhCnct->hModule);
		}

	free(hhCnct);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctLock
 *
 * DESCRIPTION:
 *	Locks the connection handle critical section semaphore
 *
 * ARGUMENTS:
 *	hhCnct	- private connection handle
 *
 * RETURNS:
 *	void
 *
 */
void cnctLock(const HHCNCT hhCnct)
	{
	EnterCriticalSection(&hhCnct->csCnct);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctUnlock
 *
 * DESCRIPTION:
 *	Unlocks the connection handle critical section semaphore
 *
 * ARGUMENTS:
 *	hhCnct	- private connection handle
 *
 * RETURNS:
 *	void
 *
 */
void cnctUnlock(const HHCNCT hhCnct)
	{
	LeaveCriticalSection(&hhCnct->csCnct);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctSetDevice
 *
 * DESCRIPTION:
 *	Sets the connection device
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	0=success, else error code
 *
 */
int cnctSetDevice(const HCNCT hCnct, const LPTSTR pachDevice)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	if (hhCnct == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	/* --- Can't set a device while we're connected --- */

	cnctLock(hhCnct);
	iRet = cnctQueryStatus(hCnct);

	if (iRet != CNCT_STATUS_FALSE && iRet != CNCT_NOT_SUPPORTED)
		{
		assert(FALSE);
		return CNCT_ERROR;
		}

	/* --- Wacker has only one driver (TAPI) so hard code it here --- */

	iRet = cnctLoadDriver(hhCnct);	// driver reports errors
	cnctUnlock(hhCnct);

	return iRet;
	}

#if 0  // mcc 01/06/95 -- hacked in to test Winsock
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctLoadDriver
 *
 * DESCRIPTION:
 *	staticly binds to Winsock connection code
 *
 * ARGUMENTS:
 *	hhCnct	- private connection handle
 *
 * RETURNS:
 *	0=success, else error code
 *
 */
static int cnctLoadDriver(const HHCNCT hhCnct)
	{
	if (cnctLoadWinsockDriver(hhCnct) != 0)
		{
		assert(FALSE);
		return CNCT_LOAD_DLL_FAILED;
		}

	return 0;
	}
#endif

#if 1 // mcc 01/05/95 -- this is the "real" Wacker one
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctLoadDriver
 *
 * DESCRIPTION:
 *	staticly binds to TAPI connection code
 *
 * ARGUMENTS:
 *	hhCnct	- private connection handle
 *
 * RETURNS:
 *	0=success, else error code
 *
 */
static int cnctLoadDriver(const HHCNCT hhCnct)
	{
	if (hhCnct->hDriver)
		return 0;

	hhCnct->hDriver = cnctdrvCreate((HCNCT)hhCnct, hhCnct->hSession);

	if (hhCnct->hDriver == 0)
		{
		assert(FALSE);
		return CNCT_LOAD_DLL_FAILED;
		}

	cnctStubAll(hhCnct);

	hhCnct->pfDestroy = (int (WINAPI *)(const HDRIVER))cnctdrvDestroy;
	hhCnct->pfQueryStatus = (int (WINAPI *)(const HDRIVER))cnctdrvQueryStatus;

	hhCnct->pfConnect = (int (WINAPI *)(const HDRIVER, const unsigned int))
		cnctdrvConnect;

	hhCnct->pfDisconnect = (int (WINAPI *)(const HDRIVER, const unsigned int))
		cnctdrvDisconnect;

	hhCnct->pfComEvent = (int (WINAPI *)(const HDRIVER, const enum COM_EVENTS))
        cnctdrvComEvent;
	hhCnct->pfInit = (int (WINAPI *)(const HDRIVER))cnctdrvInit;
	hhCnct->pfLoad = (int (WINAPI *)(const HDRIVER))cnctdrvLoad;
	hhCnct->pfSave = (int (WINAPI *)(const HDRIVER))cnctdrvSave;

	hhCnct->pfSetDestination = 
		(int (WINAPI *)(const HDRIVER, TCHAR *const, const size_t))
			cnctdrvSetDestination;

	hhCnct->pfGetComSettingsString = (int (WINAPI *)(const HDRIVER,
		LPTSTR pachStr, const size_t cb))cnctdrvGetComSettingsString;

	return 0;
	}
#endif


#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctLoadDriver
 *
 * DESCRIPTION:
 *	Tries to load the given dll
 *
 * ARGUMENTS:
 *	hhCnct	- private connection handle
 *	pachDllName - name of dll to load
 *
 * RETURNS:
 *	0=success, else error code
 *
 */
static int cnctLoadDriver(const HHCNCT hhCnct, const LPTSTR pachDllName)
	{
	#define LOADPROC(x,y) \
		(FARPROC)x = (fp = GetProcAddress(hhCnct->hModule, y)) ? fp : x

	HMODULE hModule;
	HDRIVER hDriver;
	FARPROC fp;
	HDRIVER (WINAPI *pfCreate)(const HCNCT hCnct, const HSESSION hSession);

	/* --- Check to see if we've loaded the driver already --- */

	if (hhCnct->hDriver && StrCharCmp(hhCnct->achDllName, pachDllName) == 0)
		return 0;

	/* --- Try to load the given library name --- */

	hModule = LoadLibrary(pachDllName);

	if (hModule == 0)
		{
		assert(FALSE);
		return CNCT_FIND_DLL_FAILED;
		}

	/* --- Get the create function --- */

	(FARPROC)pfCreate = GetProcAddress(hModule, "cnctwsCreate@8");

	if (pfCreate == 0)
		{
		assert(FALSE);
		FreeLibrary(hModule);
		return CNCT_LOAD_DLL_FAILED;
		}

	/* --- Call the init function --- */

	hDriver = (*pfCreate)((HCNCT)hhCnct, hhCnct->hSession);

	if (hDriver == 0)
		{
		assert(FALSE);
		FreeLibrary(hModule);
		return CNCT_LOAD_DLL_FAILED;
		}

	/* --- If driver initialized, then we can commit to this handle ---*/

	if (hhCnct->hModule)
		FreeLibrary(hhCnct->hModule);

	cnctStubAll(hhCnct);
	hhCnct->hModule = hModule;
	hhCnct->hDriver = hDriver;
	StrCharCopyN(hhCnct->achDllName, pachDllName, MAX_PATH);

	/* --- Drivers only required to support a Create function --- */

	LOADPROC(hhCnct->pfDestroy, "cnctwsDestroy@4");
	LOADPROC(hhCnct->pfQueryStatus, "cnctwsQueryStatus@4");
	LOADPROC(hhCnct->pfConnect, "cnctwsConnect@8");
	LOADPROC(hhCnct->pfDisconnect, "cnctwsDisconnect@8");
	LOADPROC(hhCnct->pfComEvent, "cnctwsComEvent@4");
	return 0;

	#undef LOADPROC
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctQueryStatus
 *
 * DESCRIPTION:
 *	Returns the status of the connection.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	status of connection or error code.
 *
 */
int cnctQueryStatus(const HCNCT hCnct)
	{
	int iStatus;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	if (hhCnct == 0 || hhCnct->pfQueryStatus == NULL)
		{
		assert(FALSE);
		iStatus = CNCT_BAD_HANDLE;
		}
	else
		{
		cnctLock(hhCnct);
		iStatus = (*hhCnct->pfQueryStatus)(hhCnct->hDriver);
		cnctUnlock(hhCnct);
		}

	return iStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctIsModemConnection
 *
 * DESCRIPTION:
 *	Returns if the connection type is a TAPI device.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	1 if the connection is a Modem, 0 if not a modem or error.
 *
 */
int cnctIsModemConnection(const HCNCT hCnct)
    {
    int nReturn = 0;

    HHDRIVER hhDriver = (HHDRIVER)cnctQueryDriverHdl(hCnct);

    //
    // See if this connection is with a TAPI device
    // (not DIRECT_COM1-DIRECT_COM4, DIRECT_COM_DEVICE,
    // or DIRECT_COMWINSOCK)
    //

	if (!hhDriver)
        {
        nReturn = -1;
        }
        
    else if (!IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) &&
        hhDriver->dwPermanentLineId != DIRECT_COM_DEVICE &&
        hhDriver->dwPermanentLineId != DIRECT_COMWINSOCK)
        {
        nReturn = 1;
        }

    return nReturn;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctConnect
 *
 * DESCRIPTION:
 *	Establishes a connection.
 *
 * ARGUMENTS:
 *	hCnct		- public connect handle
 *	uCnctFlags	- how to connect
 *
 * RETURNS:
 *	0=success, or error-code.
 *
 */
int cnctConnect(const HCNCT hCnct, const unsigned int uCnctFlags)
	{
	int iStatus;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	if (hhCnct == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	cnctLock(hhCnct);
	iStatus = (*hhCnct->pfConnect)(hhCnct->hDriver, uCnctFlags);
	cnctUnlock(hhCnct);

	return iStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctDisconnect
 *
 * DESCRIPTION:
 *	Terminates a connection
 *
 * ARGUMENTS:
 *	hCnct		- public connect handle
 *	uCnctFlags	- how to connect
 *
 * RETURNS:
 *	0=success, or error-code.
 *
 */
int cnctDisconnect(const HCNCT hCnct, const unsigned int uCnctFlags)
	{
	static BOOL  inDisconnect = FALSE;
	int          iStatus = CNCT_IN_DISCONNECT;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	if (hhCnct == 0 || hhCnct->pfDisconnect == NULL)
		{
		assert(FALSE);
		iStatus = CNCT_BAD_HANDLE;
		}
	else if (!((uCnctFlags & CNCT_XFERABORTCONFIRM) && inDisconnect == TRUE))
		{
		cnctLock(hhCnct);
		inDisconnect = TRUE;
		iStatus = (*hhCnct->pfDisconnect)(hhCnct->hDriver, uCnctFlags);
		inDisconnect = FALSE;
		cnctUnlock(hhCnct);
		}

	return iStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctInit
 *
 * DESCRIPTION:
 *	Initializes the connection driver to a base state
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	0=OK
 *
 */
int cnctInit(const HCNCT hCnct)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	cnctLock(hhCnct);
	iRet = (*hhCnct->pfInit)(hhCnct->hDriver);
	cnctUnlock(hhCnct);

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctLoad
 *
 * DESCRIPTION:
 *	Reads session file values.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	0=OK
 *
 */
int cnctLoad(const HCNCT hCnct)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	cnctLock(hhCnct);
	iRet = (*hhCnct->pfLoad)(hhCnct->hDriver);
	cnctUnlock(hhCnct);

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctSave
 *
 * DESCRIPTION:
 *	Saves connection stuff to session file.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	0=OK
 *
 */
int cnctSave(const HCNCT hCnct)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	cnctLock(hhCnct);
	iRet = (*hhCnct->pfSave)(hhCnct->hDriver);
	cnctUnlock(hhCnct);

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctQueryDriverHdl
 *
 * DESCRIPTION:
 *  Return the driver handle.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *
 * RETURNS:
 *	0 or error
 *
 */
HDRIVER cnctQueryDriverHdl(const HCNCT hCnct)
	{
	const HHCNCT hhCnct = (HHCNCT)hCnct;
	return hhCnct->hDriver;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctSetStartTime
 *
 * DESCRIPTION:
 *	This function should only be called by the connection driver.  It
 *	records the current system time when the connection is estabalished
 *	which only the driver really knows.
 *
 * ARGUMENTS:
 *	HCNCT	hCnct	- exteranl connection handle.
 *
 * RETURNS:
 *	0 if everything is OK.
 *
 */
int cnctSetStartTime(HCNCT hCnct)
	{
	time_t  t;
	HHCNCT  hhCnct = (HHCNCT)hCnct;

	assert(hCnct);

	if (hCnct == (HCNCT)0)
		return -1;

	time(&t);
	hhCnct->tStartTime = t;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctQueryStartTime
 *
 * DESCRIPTION:
 *	Returns the time in C standard time_t format of when the connection
 *	was established.
 *
 * ARGUMENTS:
 *	HCNCT		hCnct	    - external connection handle
 *	time_t FAR *pTime		- pointer to time_t variable for time.
 *
 * RETURNS:
 *
 */
int cnctQueryStartTime(const HCNCT hCnct, time_t *pTime)
	{
	HHCNCT	hhCnct;

	assert(hCnct && pTime);

	if (hCnct == (HCNCT)0)
		return -1;

	hhCnct = (HHCNCT)hCnct;

	*pTime = hhCnct->tStartTime;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctQueryElapsedTime
 *
 * DESCRIPTION:
 *	Returns the number of seconds since the connection was established.
 *	This function set *pTime to zero of a connection is not established.
 *
 * ARGUMENTS:
 *	HCNCT		hCnct   	- external connection handle
 *	time_t FAR *pTime		- pointer to time_t variable for time.
 *
 * RETURNS:
 *	0 if everything is OK.
 *
 */
int cnctQueryElapsedTime(HCNCT hCnct, time_t *pTime)
	{
	int		iRet,  iStatus;
	time_t 	tTime, tStartTime;

	assert(hCnct && pTime);

	if (hCnct == (HCNCT)0)
		return -1;

	if ((iStatus = cnctQueryStatus(hCnct)) != CNCT_STATUS_TRUE)
		{
		*pTime = (time_t)0;
		return 0;
		}

	iRet = cnctQueryStartTime(hCnct, &tStartTime);

	time(&tTime);
	*pTime = tTime - tStartTime;

	if (*pTime < 0 || *pTime >= 86400) // rollover after 24 hours
		{
		cnctSetStartTime(hCnct);
		*pTime = 0;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctMessage
 *
 * DESCRIPTION:
 *	Calls emuDataIn and gives it the requested string.	Useful for
 *	displaying connected, disconnected message
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *	idMsg	- rc identifier of message
 *
 * RETURNS:
 *	void
 *
 */

#if FALSE

void cnctMessage(const HCNCT hCnct, const int idMsg)
	{
	TCHAR 		 ach[256], achFormat[256];
	TCHAR		 *pach, *pachTime, *pachDate;
	int 		 i, nSize;
	const HHCNCT hhCnct = (HHCNCT)hCnct;
	const HEMU 	 hEmu = sessQueryEmuHdl(hhCnct->hSession);
	LCID		 lcId = GetSystemDefaultLCID();
	SYSTEMTIME	 stSysTimeDate;
	LPTSTR 		 acPtrs[3];
	TCHAR 		 acArg1[100], acArg2[100];

	// Load the "====> Connected %1, %2" or "====> Disconnected %1, %2" msg
	// from the resource...
	//
	TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
	if (LoadString(glblQueryDllHinst(), idMsg, achFormat,
		sizeof(achFormat) / sizeof(TCHAR)) == 0)
		{
		assert(FALSE);
		return;
		}

	// Get formats appropriate for the given locale...
	//
 	nSize = GetTimeFormat(lcId, 0, NULL, NULL, NULL, 0);
 	pachTime = malloc((unsigned int)(nSize+1) * sizeof(TCHAR));
 	TCHAR_Fill(pachTime, TEXT('\0'), (unsigned int)(nSize+1));

	GetLocalTime(&stSysTimeDate);
	GetTimeFormat(lcId,	0, &stSysTimeDate, NULL, pachTime, nSize+1);

	// NOTE: The 2nd parameter to GetDateFormat() should be DATE_LONGDATE but
	// right now that causes the function to return garbage, so for now use
	// what works!
	//
	nSize = GetDateFormat(lcId, 0, NULL, NULL, NULL, 0);
 	pachDate = malloc((unsigned int)(nSize+1) * sizeof(TCHAR));
 	TCHAR_Fill(pachDate, TEXT('\0'), (unsigned int)(nSize+1));

	GetDateFormat(lcId,	0, &stSysTimeDate, NULL, pachDate, nSize+1);

	// Format the string...
	//
	wsprintf(acArg1, "%s", pachTime);
	wsprintf(acArg2, "%s", pachDate);

	acPtrs[0] = acArg1;
	acPtrs[1] = acArg2;
	acPtrs[2] = NULL;

#if defined(USE_FORMATMSG)

	FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
				achFormat, 0, 0, ach, sizeof(ach) / sizeof(TCHAR), acPtrs);

#else
	// Hard code until FormatMessage() works!
	//
	if (idMsg == IDS_CNCT_CLOSE)
		wsprintf(ach, "\r\n=====> Disconnected  %s, %s", acPtrs[0], acPtrs[1]);
	else
		wsprintf(ach, "\r\n=====> Connected %s, %s\r\n", acPtrs[0], acPtrs[1]);
#endif

	free(pachTime);
	pachTime = NULL;
	free(pachDate);
	pachDate = NULL;

	// Display the message on terminal window...
	//
	pach = ach;
	for (i = StrCharGetStrLength(ach); i > 0; --i, pach = StrCharNext(pach))
		emuDataIn(hEmu, *pach);

	return;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctSetDestination
 *
 * DESCRIPTION:
 *	Sets the destination to be dialed
 *
 * ARGUMENTS:
 *	HCNCT		hCnct	    - external connection handle
 *	char		*ach		- destination
 *	size_t		cb			- sizeof of buffer
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int	cnctSetDestination(const HCNCT hCnct, TCHAR *const ach, const size_t cb)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	cnctLock(hhCnct);
	iRet = (*hhCnct->pfSetDestination)(hhCnct->hDriver, ach, cb);
	cnctUnlock(hhCnct);

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctGetComSettingsString
 *
 * DESCRIPTION:
 *	Returns a string suitable for use in the com settings portion of the
 *	status bar.
 *
 * ARGUMENTS:
 *	hCnct	- public connection handle
 *	pach	- buffer to store string
 *	cb		- max size of buffer
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int cnctGetComSettingsString(const HCNCT hCnct, LPTSTR pach, const size_t cb)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	cnctLock(hhCnct);
	iRet = (*hhCnct->pfGetComSettingsString)(hhCnct->hDriver, pach, cb);
	cnctUnlock(hhCnct);

	return iRet;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctComEvent
 *
 * DESCRIPTION:
 *	Calls the driver-specific function to handle notifications from the COM 
 *  driver
 *
 * ARGUMENTS:
 *	HCNCT		hCnct	    - external connection handle
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int	cnctComEvent(const HCNCT hCnct, const enum COM_EVENTS event)
	{
	int iRet;
	const HHCNCT hhCnct = (HHCNCT)hCnct;

	cnctLock(hhCnct);
	iRet = (*hhCnct->pfComEvent)(hhCnct->hDriver, event);
	cnctUnlock(hhCnct);

	return iRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cnctstub.c ===
/*	File: D:\WACKER\tdll\cnctstub.c (Created: 18-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 5/09/01 4:42p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>

#include "stdtyp.h"
#include "session.h"
#include "cnct.h"
#include "cnct.hh"
#include "htchar.h"

static int WINAPI cnctstub(const HDRIVER hDriver);
static int WINAPI cnctstubQueryStatus(const HDRIVER hDriver);
static int WINAPI cnctstubConnect(const HDRIVER hDriver, const unsigned int uCnctFlags);
static int WINAPI cnctstubGetComSettingsString(const HDRIVER hDriver, LPTSTR pachStr, const size_t cb);
static int WINAPI cnctstubComEvent(const HDRIVER hDriver, const enum COM_EVENTS event);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctStubAll
 *
 * DESCRIPTION:
 *	Stubs all function pointers in a connection handle to a stub
 *	procedure so that the connection handle can function without
 *	a driver.
 *
 * ARGUMENTS:
 *	hhCnct	- private connection handle
 *
 * RETURNS:
 *	void
 *
 */
void cnctStubAll(const HHCNCT hhCnct)
	{
	hhCnct->pfDestroy = cnctstub;
	hhCnct->pfQueryStatus = cnctstubQueryStatus;
	hhCnct->pfConnect = cnctstubConnect;
	hhCnct->pfDisconnect = cnctstubConnect;
	hhCnct->pfComEvent = cnctstubComEvent;
	hhCnct->pfInit = cnctstub;
	hhCnct->pfLoad = cnctstub;
	hhCnct->pfSave = cnctstub;
	hhCnct->pfGetComSettingsString = cnctstubGetComSettingsString;
	return;
	}

/* --- Stub Functions --- */

static int WINAPI cnctstub(const HDRIVER hDriver)
	{
	return CNCT_NOT_SUPPORTED;
	}

static int WINAPI cnctstubQueryStatus(const HDRIVER hDriver)
	{
	return CNCT_NOT_SUPPORTED;
	}

static int WINAPI cnctstubConnect(const HDRIVER hDriver,
		const unsigned int uCnctFlags)
	{
	return CNCT_NOT_SUPPORTED;
	}

static int WINAPI cnctstubGetComSettingsString(const HDRIVER hDriver,
		LPTSTR pachStr, const size_t cb)
	{
	return CNCT_NOT_SUPPORTED;
	}

static int WINAPI cnctstubComEvent(const HDRIVER hDriver,
        const enum COM_EVENTS event)
    {
    return CNCT_NOT_SUPPORTED;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\comdev.h ===
/* comdev.h -- Exported definitions for communications device routines
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:40p $
 */

#define COM_MAX_DEVICE_NAME 40
#define COM_MAX_PORT_NAME	120

typedef struct
	{
	int 	 iAction;
	int 	 iReserved;
	TCHAR	 szDeviceName[COM_MAX_DEVICE_NAME];
	TCHAR	 szFileName[MAX_PATH];
	HANDLE	 hFind;
	WIN32_FIND_DATA stFindData;
	} COM_FIND_DEVICE;

typedef struct
	{
	int 	  iAction;
	TCHAR	  szPortName[COM_MAX_PORT_NAME];
	HINSTANCE hModule;
	long	  lReserved1;
	long	  lReserved2;
	long	  lReserved3;
	long	  lReserved4;
	void	 *pvData;
	} COM_FIND_PORT;

// Values for usAction field in COM_FIND_DEVICE and COM_FIND_PORT
#define COM_FIND_FIRST	0
#define COM_FIND_NEXT	1
#define COM_FIND_DONE	2


// -=-=-=-=-=-=-=-=-=-=-=- EXPORTED PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-

extern int ComFindDevices(COM_FIND_DEVICE * const pstFind);

int ComGetFileNameFromDeviceName(const TCHAR * const pszDeviceName,
							TCHAR * const pszFileName,
							const int nSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\com.hh ===
/* com.hh -- Internal definitions for communications routines
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/01/01 3:33p $
 */

// -=-=-=-=-=-=-=-=-=-=-=-=-=- DEBUG CONTROL -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// These constants are used to turn on various types of debug display
// #define DBG_NORMAL
// #define DBG_RCV
// #define DBG_SEND

#if defined(DBG_NORMAL)
	#define DEBUGSTR
	#define DBGOUT_NORMAL(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
	#define DBGOUT_NORMAL(s,a1,a2,a3,a4,a5)
#endif

#if defined(DBG_RCV)
	#define DEBUGSTR
	#define DBGOUT_RCV(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
	#define DBGOUT_RCV(s,a1,a2,a3,a4,a5)
#endif

#if defined(DBG_SEND)
	#define DEBUGSTR
	#define DBGOUT_SEND(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
	#define DBGOUT_SEND(s,a1,a2,a3,a4,a5)
#endif

// -=-=-=-=-=-=-=-=-=-=-=-=-=- DEFINITIONS -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#define STANDARD_RBUFR_SIZE 100
#define STANDARD_SBUFR_SIZE 100


// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-= TYPES =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


typedef struct
	{
	TCHAR szDeviceFile[MAX_PATH];			 // Name of driver file
	TCHAR szPortName[COM_MAX_PORT_NAME];	 // Name of individual port
	} ST_COM_SETTINGS;

// This is the main com structure used to hang on to all the working details
typedef struct s_com
	{
	// The s_com_control structure must always be the first item in this
	//	 structure so that a pointer to this structure can be cast into
	//	 a pointer to it.
	ST_COM_CONTROL stComCntrl; // The exported part of the structure

	// User-settable com values
	ST_COM_SETTINGS stFileSettings;
	ST_COM_SETTINGS stWorkSettings;

	// Control fields for com routines
	HSESSION	hSession;			 // Session we belong to
	int 		fPortActive;		 // TRUE when port has been activated
	int 		fErrorReported; 	 // TRUE if driver has encountered error
	HINSTANCE	hDriverModule;		 // Handle of .DLL module
	TCHAR		szDeviceName[COM_MAX_DEVICE_NAME]; // Name of device type
	TCHAR		chDummy;			 // Dummy address for buffer pointers
	unsigned	afOverride; 		 // Allows tmp. override of com details
	HANDLE		hRcvEvent;			 // Signalled whenever rcv data is avail
    HANDLE      hSndReady;           // Signalled whenever send is not busy

	// Control	fields for sending:
	TCHAR	  * puchSendBufr1;		 // allocated buffers for holding
	TCHAR	  * puchSendBufr2;		 //   chars. waiting to be sent
	TCHAR	  * puchSendBufr;		 // pointer to bufr being filled
	TCHAR	  * puchSendPut;		 // Insertion point in current buffer
	TCHAR		auchDummyBufr[5];	 // Place to rest idle pointers
	int 		nSBufrSize; 		 // Size of send buffers
	int 		nSendCount; 		 // Chars. in current bufr.
	int 		fUserCalled;		 // TRUE if status function called
	STATUSFUNCT pfUserFunction; 	 // User supplied status function

	void		(*pfIdleFunction)(void);  // Registered idle function

	// These funtion pointers get set to point into whatever com device
	// driver is loaded. (If no driver is loaded or if the driver is invalid,
	// they are set to point to default, mostly do-nothing routines

	// There are two groups of function pointers, the first group is set to
	// point into the device driver as soon as the driver is loaded and stay
	// there until the driver us unloaded. The second group are not set to
	// point into the driver until an actual port is activated. These are
	// set to point back to default routines whenever the port is deactivated.

	// -------------------------------------------------------------------
	// These are the function pointers that point into the driver whenever
	// it is loaded.

	int 	 (WINAPI *pfDeviceClose)(void *pvDevData);
	int 	 (WINAPI *pfDeviceDialog)(void *pvDevData, HWND hwndParent);
	int 	 (WINAPI *pfDeviceGetCommon)(void *pvDevData, ST_COMMON *pstCommon);
	int 	 (WINAPI *pfDeviceSetCommon)(void *pvDevData, ST_COMMON *pstCommon);
	int 	 (WINAPI *pfDeviceSpecial)(void *, const TCHAR *, TCHAR *, int);
	int 	 (WINAPI *pfDeviceLoadHdl)(void *pvDevData, SF_HANDLE sfHdl);
	int 	 (WINAPI *pfDeviceSaveHdl)(void *pvDevData, SF_HANDLE sfHdl);
	int 	 (WINAPI *pfPortConfigure)(void *pvDevData);
	int 	 (WINAPI *pfPortActivate)(void *pvDevData,
						TCHAR *pszPortName,
						DWORD_PTR dwMediaHdl);
	int 	 (WINAPI *pfPortPreconnect)(void *pvDevData,
						TCHAR *pszPortName, HWND hwndParent);

	// These function pointers point into the driver only when a port has
	// been activated.

	int 	 (WINAPI *pfPortDeactivate)(void *pvDevData);
	int 	 (WINAPI *pfPortConnected)(void *pvDevData);


	int 	 (WINAPI *pfRcvRefill)(void *pvDevData);
	int 	 (WINAPI *pfRcvClear)(void *pvDevData);

	int 	 (WINAPI *pfSndBufrSend)(void *pvDevData,
				 void *pvBufr, int nCount);
	int 	 (WINAPI *pfSndBufrIsBusy)(void *pvDevData);
	int 	 (WINAPI *pfSndBufrClear)(void *pvDevData);
	int 	 (WINAPI *pfSndBufrQuery)(void *pvDevData, unsigned *pafStatus,
				 long *plHandshakeDelay);
	int 	 (WINAPI *pfSendXon)(void *pvDevData);

	//----------------------------------------------------------------------

	void *	 pvDriverData;		  // Space for drivers data

	unsigned nGuard;			  // to check for memory overwrites
	} ST_COM;




// -=-=-=-=-=-=-=-=-=-=-=- INTERNAL PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-

extern void ComReportError(const HCOM pstCom,
						  int iErrStr,
					const TCHAR * const pszOptInfo,
					const int fFirstOnly);
extern void ComFreeDevice(const HCOM pstCom);
extern int	ComSendDefaultStatusFunction(int iReason,
					unsigned fusHsStatus, long lDelay);

// These are the set of default functions that the function pointers in
//	the com handle point to when there is no com driver loaded or when
//	it is inactive
int  WINAPI ComDefDoNothing(void *pvDriverData);
int  WINAPI ComDefPortPreconnect(void *pvDriverData,
		TCHAR *pszPortName,
		HWND hwndParent);
int  WINAPI ComDefDeviceDialog(void *pvDriverData, HWND hwndParent);
int  WINAPI ComDefPortActivate(void *pvDriverData,
		TCHAR *pszPortName,
		DWORD_PTR dwMediaHdl);
int  WINAPI ComDefBufrRefill(void *pvDriverData);
int  WINAPI ComDefSndBufrSend(void *pvDriverData, void *pvBufr, int nCount);
int  WINAPI ComDefSndBufrBusy(void *pvDriverData);
int  WINAPI ComDefSndBufrClear(void *pvDriverData);
int  WINAPI ComDefSndBufrQuery(void *pvDriverData,
		unsigned *pafStatus,
		long *plHandshakeDelay);
void WINAPI ComDefIdle(void);
int  WINAPI ComDefDeviceGetCommon(void *pvPrivate, ST_COMMON *pstCommon);
int  WINAPI ComDefDeviceSetCommon(void *pvPrivate, struct s_common *pstCommon);
int  WINAPI ComDefDeviceSpecial(void *pvPrivate,
		const TCHAR *pszInstructions,
		TCHAR *pszResult,
		int nBufrSize);
int  WINAPI ComDefDeviceLoadSaveHdl(void *pvPrivate, SF_HANDLE sfHdl);

// Functions made available to driver .DLLs through func. pointers
extern void * ComMalloc(size_t size);
extern void   ComFree(void *pvItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cpf_dlg.c ===
/*	File: C:\WACKER\TDLL\CPF_DLG.C (Created: 12-Jan-94)
 *
 *	Copyright 1990,1993,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 3/26/02 8:48a $
 */
#include <windows.h>
#pragma hdrstop

#define	DO_RAW_MODE	1

#include "stdtyp.h"
#include "mc.h"

#include <term\res.h>
#include "tdll.h"
#include "misc.h"
#include "assert.h"
#include "globals.h"
#include "session.h"
#include "capture.h"
#include "load_res.h"
#include "open_msc.h"
#include "errorbox.h"
#include "hlptable.h"
#include "htchar.h"
#include "file_msc.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	HSESSION hSession;
	};

typedef	struct stSaveDlgStuff SDS;

#define IDC_TF_FILE     100
#define	FNAME_EDIT		105
#define IDC_TF_DIR      106
#define	DIRECTORY_TEXT	107
#define BROWSE_BTN		123
#define IDC_PB_START    124

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CaptureFileDlg
 *
 * DESCRIPTION:
 *	This is the dialog proc for the capture to file dialog.  No suprises
 *	here.
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK CaptureFileDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	BOOL          fRc;
	DWORD         dwMaxComponentLength;
	DWORD         dwFileSystemFlags;
	HWND	      hwndChild;
	INT		      nId;
	INT		      nNtfy;
	SDS          *pS;
	HSESSION      hSession;
	LPTSTR	      pszStr;
	TCHAR         acBuffer[MAX_PATH];
	static	DWORD aHlpTable[] = {FNAME_EDIT,		IDH_TERM_CAPT_FILENAME,
								 IDC_TF_FILE,		IDH_TERM_CAPT_FILENAME,
								 BROWSE_BTN,		IDH_BROWSE,
								 IDC_TF_DIR,		IDH_TERM_CAPT_DIRECTORY,
								 DIRECTORY_TEXT,	IDH_TERM_CAPT_DIRECTORY,
                                 IDC_PB_START,      IDH_TERM_CAPT_START,
                                 IDCANCEL,                           IDH_CANCEL,
                                 IDOK,                               IDH_OK,
								 0, 				0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		{
		DWORD dwStyle = SS_WORDELLIPSIS;

		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			break;
			}

		pS->hSession = (HSESSION)lPar;

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		hSession = pS->hSession;

		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		// Determine whether long filenames are supported.  JRJ	12/94
		fRc = GetVolumeInformation(NULL,  // pointer to root dir path buffer
								 NULL,	  // pointer to volume name buffer
								 0,		  // length of volume name buffer
								 NULL,    // pointer to volume serial number buffer
								 &dwMaxComponentLength,	// the prize - what I'm after
								 &dwFileSystemFlags,  // ptr to file system flag DWORD
								 NULL,	  // pointer to file system name buffer
								 0);	  // length of file system name buffer

		if(dwMaxComponentLength == 255)
			{
			// There is support for long file names.
			SendDlgItemMessage(hDlg, FNAME_EDIT, EM_SETLIMITTEXT, FNAME_LEN, 0);
			}
		else
			{
			// There IS NOT support for long file names. Limit to twelve.
			SendDlgItemMessage(hDlg, FNAME_EDIT, EM_SETLIMITTEXT, 12, 0);
			}

		/* Get the file name first */
		TCHAR_Fill(acBuffer, TEXT('\0'), MAX_PATH);

		cpfGetCaptureFilename(sessQueryCaptureFileHdl(hSession),
							  acBuffer, MAX_PATH);

		SetDlgItemText(hDlg, FNAME_EDIT, acBuffer);

		mscStripName(acBuffer);

		pszStr = StrCharLast(acBuffer);

		// Remove the trailing backslash from the name
		// returned from mscStripName.	Leave it on
		// in the case of a root directory specification.
		//
		if (pszStr > acBuffer + (3 * sizeof(TCHAR)) )
			{
			if (pszStr &&  ( *pszStr == TEXT('\\') || *pszStr == TEXT('/')))
				{
				*pszStr = TEXT('\0');
				}
			}

		if (GetWindowsMajorVersion() >  4)
			{
			dwStyle = SS_PATHELLIPSIS;
			}

		mscModifyToFit(GetDlgItem(hDlg, DIRECTORY_TEXT), acBuffer, dwStyle);
		SetDlgItemText(hDlg, DIRECTORY_TEXT, acBuffer);

		}
		break;

	case WM_DESTROY:
		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDC_PB_START:
			{
			int nDef;

			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			assert(pS);

			hSession = pS->hSession;

			/*
			 * Do whatever saving is necessary
			 */
			nDef = TRUE;

			TCHAR_Fill(acBuffer, TEXT('\0'), MAX_PATH);
			GetDlgItemText(hDlg, FNAME_EDIT, acBuffer, MAX_PATH);

			// Error check the user-supplied name.
			if(ValidateFileName(acBuffer) == 1)
				{
				cpfSetCaptureFilename(sessQueryCaptureFileHdl(hSession),
										acBuffer, nDef);


#if defined(DO_RAW_MODE)
				cpfSetCaptureMode(sessQueryCaptureFileHdl(hSession),
									CPF_MODE_RAW,
									FALSE);
#endif

				/*
				 * TODO: actually start the capture to file
				 */
				cpfSetCaptureState(sessQueryCaptureFileHdl(hSession),
									CPF_CAPTURE_ON);

				/* Free the storage */
				free(pS);
				pS = (SDS *)0;
				EndDialog(hDlg, TRUE);
				}
			else
				{
				// There were problems.
				//   e.g. The user specified a bad capture file name, or
				//        for some other reason the file couldn't be created.
				mscMessageBeep(MB_ICONHAND);

				// For now, I'm going to assume that whatever the problem is,
				//  the only thing the user can do to try again is to specify
				//  a different filename. So, I'm setting the focus back to
				//  the filename edit control.
				SetFocus(GetDlgItem(hDlg,FNAME_EDIT));
				}
			}
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		case BROWSE_BTN:
			{
			DWORD dwStyle = SS_WORDELLIPSIS;

			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			if (pS)
				{
				LPTSTR pszRet;
				TCHAR acTitle[64];
				TCHAR acList[64];

				hSession = pS->hSession;

				pszRet = NULL;
				TCHAR_Fill(acBuffer, TEXT('\0'), MAX_PATH);

				GetDlgItemText(hDlg, DIRECTORY_TEXT, acBuffer, MAX_PATH - 1);

				LoadString(glblQueryDllHinst(),
							IDS_CPF_DLG_FILE,
							acTitle,
							sizeof(acTitle) / sizeof(TCHAR));

				resLoadFileMask(glblQueryDllHinst(),
							IDS_CPF_FILES1,
							2,
							acList,
							sizeof(acList) / sizeof(TCHAR));

                //jmh 3/24/97 This was gnrcFindFileDialog, but this lets you
                // enter a non-existent file name, which is what we really want
				pszRet = gnrcSaveFileDialog(hDlg,
							acTitle,
							acBuffer,
							acList,
                            "");

				if (pszRet != NULL)
					{
					StrCharCopyN(acBuffer, pszRet, MAX_PATH);
                    acBuffer[MAX_PATH - 1] = TEXT('\0');
					SetDlgItemText(hDlg, FNAME_EDIT, pszRet);

					free(pszRet);
					pszRet = NULL;

					mscStripName(acBuffer);

					pszStr = StrCharLast(acBuffer);

					// Remove the trailing backslash from the name
					// returned from mscStripName.	Leave it on
					// in the case of a root directory specification.
					//
					if (pszStr > acBuffer + (3 * sizeof(TCHAR)) )
						{
						if (pszStr &&  ( *pszStr == TEXT('\\') || *pszStr == TEXT('/')))
							{
							*pszStr = TEXT('\0');
							}
						}

					if (GetWindowsMajorVersion() >  4)
						{
						dwStyle = SS_PATHELLIPSIS;
						}

					mscModifyToFit(GetDlgItem(hDlg, DIRECTORY_TEXT), acBuffer, dwStyle);
					SetDlgItemText(hDlg, DIRECTORY_TEXT, acBuffer);
					}
				}
			}
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\comdef.c ===
/* comdef.c -- Default com driver routines.
 *			   These routines are pointed to by various com function pointers
 *			   before a valid device driver is loaded.
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/09/01 4:42p $
 */
#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include <tdll\assert.h>
#include "sf.h"
#include "com.h"
#include "comdev.h"
#include "com.hh"

// since these are all dummy functions that serve as place-holders for
//	real functions during the time when no driver is loaded, they often
//	do not use the arguments passed to them. The following line will
//	suppress the warnings that lint issues
/*lint -e715*/

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefDoNothing
 *
 * DESCRIPTION:
 *	A filler function that various com function pointers can be set to
 *	until they receive actual values from a com driver. This prevents
 *	the function pointers from pointing to invalid code.
 *
 * ARGUMENTS:
 *	pvDriverData -- Data being passed to driver
 *
 * RETURNS:
 *	always returns COM_PORT_NOT_OPEN;
 */
int WINAPI ComDefDoNothing(void *pvDriverData)
	{
	pvDriverData = pvDriverData;

	return COM_PORT_NOT_OPEN;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefPortPreconnect(void *pvDriverData,
		TCHAR *pszPortName,
		HWND hwndParent)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;
	pszPortName = pszPortName;
	hwndParent = hwndParent;

	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefDeviceDialog
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefDeviceDialog(void *pvDriverData, HWND hwndParent)
	{
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefPortActivate(void *pvDriverData,
			TCHAR *pszPortName,
			DWORD_PTR dwMediaHdl)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;
	pszPortName = pszPortName;
	dwMediaHdl = dwMediaHdl;

	return COM_DEVICE_INVALID;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefBufrRefill
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefBufrRefill(void *pvDriverData)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;

	return FALSE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefSndBufrSend
 *
 * DESCRIPTION:
 *	Starts background transmission of a buffer of characters. Optionally
 *	waits for any prior buffer transmission to be completed.
 *
 * ARGUMENTS:
 *	pvDriverData
 *	pchBufr -- Pointer to buffer of characters to be transmitted
 *	usCount -- Number of characters in buffer
 *	usWait	-- Time (in tenths of a second) to wait for any prior,
 *				unfinished buffer to finish. If this value is zero, the call
 *				will fail immediately if the transmitter is busy.
 *
 * RETURNS:
 *	COM_OK if transmission is started. Note that this call returns as soon
 *			as the transmission is started -- it does not wait for the entire
 *			transmission to be completed.
 *	COM_BUSY if transmitter is busy with a prior buffer and time limit is
 *			exceeded
 *	COM_PORT_NOT_OPEN if called when no port is active
 */
int WINAPI ComDefSndBufrSend(void *pvDriverData, void *pvBufr, int nCount)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;
	pvBufr = pvBufr;
	nCount = nCount;

	return COM_PORT_NOT_OPEN;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComSndBufrBusy
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefSndBufrBusy(void *pvDriverData)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;

	// Act like we're never busy to keep program from hanging when
	//	no com driver is active.
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefSndBufrClear(void *pvDriverData)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;

	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefSndBufrQuery(void *pvDriverData,
		unsigned *pafStatus,
		long *plHandshakeDelay)
	{
	// Avoid lint complaints
	pvDriverData = pvDriverData;
	if (pafStatus)
		*pafStatus = 0;

	if (plHandshakeDelay)
		*plHandshakeDelay = 0L;

	return COM_OK;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void WINAPI ComDefIdle(void)
	{
	// Do nothing. This fills in for real function that can be set by caller.
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefDeviceGetCommon
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefDeviceGetCommon(void *pvPrivate, ST_COMMON *pstCommon)
	{
	// Keep lint from complaining
	pvPrivate = pvPrivate;
	// Indicate that we do not support any common items
	pstCommon->afItem = 0;

	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefDeviceSetCommon
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI ComDefDeviceSetCommon(void *pvPrivate, struct s_common *pstCommon)
	{
	// Keep lint from complaining
	pvPrivate = pvPrivate;
	pstCommon = pstCommon;

	// Don't set anything, pretend that all is well
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComDefDeviceSpecial
 *
 * DESCRIPTION:
 *	The means for others to control any special features in this driver
 *	that are not supported by all drivers.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *	COM_NOT_SUPPORTED if the instruction string was not recognized
 *	otherwise depends on instruction string
 */
int WINAPI ComDefDeviceSpecial(void *pvPrivate,
		const TCHAR *pszInstructions,
		TCHAR *pszResult,
		int nBufrSize)
	{
	return COM_NOT_SUPPORTED;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ComDefDeviceLoadSaveHdl
 *
 * DESCRIPTION:
 *	Dummy routine for pfDeviceLoadHdl and pfDeviceSaveHdl used when no
 *	com driver is loaded
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *	always returns TRUE
 */
int WINAPI ComDefDeviceLoadSaveHdl(void *pvPrivate, SF_HANDLE sfHdl)
	{
	pvPrivate = pvPrivate;
	sfHdl = sfHdl;

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\com.h ===
/* com.h -- Exported definitions for main communications routines
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/22/02 3:21p $
 */

#if !defined(H_COM)
#define H_COM

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-= CONSTANTS =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#define COM_VERSION 20

// Function return codes
#define COM_OK						0
#define COM_INVALID_HANDLE			1
#define COM_NOT_ENOUGH_MEMORY		2
#define COM_PORT_NOT_OPEN			3
#define COM_PORT_OPEN               4
#define COM_PORT_UNINITIALIZED      5
#define COM_PORT_IN_USE 			6
#define COM_PORT_INVALID_NAME		7
#define COM_CANCELLED				8
#define COM_SEND_QUEUE_STUCK		12
#define COM_DEVICE_INVALID			13
#define COM_DEVICE_VERSION_ERROR	15
#define COM_DEVICE_ERROR			16
#define COM_DEVICE_LIBERROR 		14
#define COM_DEVICE_INVALID_SETTING	17
#define COM_BUSY					18
#define COM_NOT_SUPPORTED			19
#define COM_FAILED					21
#define COM_NOT_FOUND				22
#define COM_CANT_OVERRIDE			25

// bits in fsStatus value
#define COMSB_WAIT_XON	 0x01
#define COMSB_WAIT_CTS	 0x02
#define COMSB_WAIT_DSR	 0x04
#define COMSB_WAIT_DCD	 0x08
#define COMSB_WAIT_BUSY	 0x40	/* flow controlled off for some other reason */
#define COMSB_RESERVED	 0x80	/* reserved for use by textsend */

// Bit definition of common fields
#define COM_BAUD		0x01
#define COM_DATABITS	0x02
#define COM_STOPBITS	0x04
#define COM_PARITY		0x08
#define COM_AUTO		0x10

// Common field constants
#define COM_PARITY_MIN	 0
#define COM_PARITY_NONE  0
#define COM_PARITY_ODD	 1
#define COM_PARITY_EVEN  2
#define COM_PARITY_MARK  3
#define COM_PARITY_SPACE 4
#define COM_PARITY_MAX	 4

#define COM_STOPBITS_1	 0
#define COM_STOPBITS_1_5 1
#define COM_STOPBITS_2	 2

/* Values for usReason arg. to caller supplied status functions */
#define COMSEND_LOCAL			   0  /* so callers can call their own
										 handler function without confusion */
#define COMSEND_FIRSTCALL		   1  /* Handler is being registered */
#define COMSEND_LASTCALL		   2  /* Handler is being replaced */
#define COMSEND_DATA_WAITING	   3  /* Unbuffered data is pending */
#define COMSEND_NORMAL			   4  /* Routine call, all data is buffered */


/* Return values from caller supplied status functions */
#define COMSEND_OK				   0
#define COMSEND_GIVEUP			   1
#define COMSEND_CLEAR_DATA		   2
#define COMSEND_FORCE_CONTINUATION 3


// Options for ComOverride()
#define COM_OVERRIDE_8BIT	  0x0001	// forces 8-bit (no parity) mode
#define COM_OVERRIDE_RCVALL   0x0002	// suspends any features that would
										//	prevent any character from
										//	being received (XON/XOFF etc.)
#define COM_OVERRIDE_SNDALL   0x0004	// ditto for sending


// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-= TYPES =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// Enumeration type for ComNotify
enum COM_EVENTS
	{
	CONNECT,
	DATA_RECEIVED,
	NODATA,
	SEND_STARTED,
	SEND_DONE
	};

// Type for use with ComSend routines
typedef int (*STATUSFUNCT)(int, unsigned, long);

typedef struct s_com_control
	{
	// Pointers to allow quick macros to access received chars.
	UCHAR FAR *puchRBData;				// points to next valid received char.
	UCHAR FAR *puchRBDataLimit; 		// limit of valid received chars.
	} ST_COM_CONTROL;


// Structure for transferring common data into & out of driver
typedef struct s_common
	{
	unsigned  afItem;
	long	  lBaud;
	int 	  nDataBits;
	int 	  nStopBits;
	int 	  nParity;
	int 	  fAutoDetect;
	int 	  nPrivateSize;
	} ST_COMMON;


// -=-=-=-=-=-=-=-=-=-=-=-=-=- PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

extern int	ComCreateHandle(const HSESSION hSession, HCOM *phcom);
extern int	ComDestroyHandle(HCOM *phCom);
extern int	ComInitHdl(const HCOM pstCom);
extern int	ComLoadHdl(const HCOM pstCom);
extern int	ComSaveHdl(const HCOM pstCom);
extern int	ComSetDeviceFromName(const HCOM pstCom,
				const TCHAR * const pszDeviceName);
extern int	ComSetDeviceFromFile(const HCOM pstCom,
				const TCHAR * const pszFileName);
extern int	ComGetDeviceName(const HCOM pstCom,
				TCHAR * const pszName,
				int * const pnLen);
extern HANDLE ComGetRcvEvent(HCOM pstCom);
extern int	ComGetSession(const HCOM pstCom, HSESSION * const phSession);
extern void ComNotify(const HCOM pstCom, enum COM_EVENTS event);
extern int	ComIsActive(const HCOM pstCom);
extern int	ComSetPortName(const HCOM pstCom,
				const TCHAR * const pszPortName);
extern int	ComGetPortName(const HCOM pstCom, TCHAR * const pszName, int nLen);
extern int	ComGetBaud(const HCOM pstCom, long * const plBaud);
extern int	ComSetBaud(const HCOM pstCom, const long lBaud);
extern int	ComGetDataBits(const HCOM pstCom, int * const pnDataBits);
extern int	ComSetDataBits(const HCOM pstCom, const int nDataBits);
extern int	ComGetStopBits(const HCOM pstCom, int * const pnStopBits);
extern int	ComSetStopBits(const HCOM pstCom, const int nStopBits);
extern int	ComGetParity(const HCOM pstCom, int * const pnParity);
extern int	ComSetParity(const HCOM pstCom, const int nParity);
extern int	ComGetAutoDetect(HCOM pstCom, int *pfAutoDetect);
extern int	ComSetAutoDetect(HCOM pstCom, int fAutoDetect);
extern int	ComPreconnect(const HCOM pstCom);
extern int	ComActivatePort(const HCOM pstCom, DWORD_PTR dwMediaHdl);
extern int	ComDeactivatePort(const HCOM pstCom);
extern int	ComOverride(const HCOM pstCom,
				const unsigned afOptions,
				unsigned * const pafOldOptions);
extern int	ComQueryOverride(HCOM pstCom, unsigned *pafOptions);
extern int	ComConfigurePort(const HCOM pstCom);
extern int	ComRcvBufrRefill(const HCOM pstCom, TCHAR * const tc, const int fRemoveChar);
extern int	ComRcvBufrClear(const HCOM pstCom);
extern int	ComSndBufrSend(
				const HCOM pstCom,
				void * const pvBufr,
				const int nCount,
				const int nWait);
extern int	ComSndBufrBusy(const HCOM pstCom);
extern int	ComSndBufrWait(const HCOM pstCom, const int nWait);
extern int	ComSndBufrClear(const HCOM pstCom);
extern int	ComSndBufrQuery(const HCOM pstCom, unsigned * const pafStatus,
				long * const plHandshakeDelay);
extern int	ComDeviceDialog(const HCOM pstCom, const HWND hwndParent);
extern int	ComDriverSpecial(const HCOM pstCom, const TCHAR * const pszInstructions,
				TCHAR * const pszResults, const int nBufrSize);

extern int	ComSendChar(const HCOM pstCom, const TCHAR chCode);
extern int	ComSendCharNow(const HCOM pstCom, const TCHAR chCode);
extern int	ComSendPush(const HCOM pstCom);
extern int	ComSendWait(const HCOM pstCom);
extern int	ComSendClear(const HCOM pstCom);
extern int	ComSendSetStatusFunction(const HCOM pstCom, STATUSFUNCT pfNewStatusFunct,
				STATUSFUNCT *ppfOldStatusFunct);

extern int ComLoadWinsockDriver(HCOM pstCom);
extern int ComLoadStdcomDriver(HCOM pstCom);

extern int	ComValidHandle(HCOM pstCom);

// Function replacement macros
#define PCOM ST_COM_CONTROL *

#define mComRcvChar(h,p)	 ((((PCOM)h)->puchRBData < ((PCOM)h)->puchRBDataLimit) ? \
							 (*(p) = *((PCOM)h)->puchRBData++, TRUE) : \
							 ComRcvBufrRefill((h), (p), TRUE))

#define mComRcvBufrPeek(h,p) ((((PCOM)h)->puchRBData < ((PCOM)h)->puchRBDataLimit) ? \
							 (*(p) = *((PCOM)h)->puchRBData, TRUE) : \
							 ComRcvBufrRefill((h), (p), FALSE))

#define mComRcvBufrPutback(h,c)  ((VOID)(*--((PCOM)h)->puchRBData = (TCHAR)(c)))



#endif	// !defined(H_COM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\comsend.c ===
/* ComSend -- Text sending routines for HyperACCESS
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 8 $
 *	$Date: 7/12/02 10:45a $
 */
#include <windows.h>
#pragma hdrstop

// #define DEBUGSTR

#include "stdtyp.h"
#include <tdll\assert.h>
#include "com.h"
#include "comdev.h"
#include "com.hh"

/* --- Internal prototypes --- */

static int ComSendCheck(const HCOM pstCom, const int fDataWaiting);



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendChar
 *
 * DESCRIPTION:
 *	Adds a character to the send buffer to be transmitted. The
 *	character will not actually be transferred to the transmit
 *	routines until the buffer fills up or a call to ComSendCharNow
 *	is made or a call to ComSendPush is made while the transmitter
 *	is not busy.
 *
 * ARGUMENTS:
 *	pstCom	  -- handle to comm session
 *	uchCode -- The character to be transmitted.
 *
 * RETURNS:
 *	COM_OK if the character is successfully buffered.
 *	COM_INVALID_HANDLE if invalid com handle
 *	COM_SEND_BUFFER_FULL if the buffer is full and the
 *		caller-supplied handshake function returns a code
 *		indicating that waiting data should be discarded.
 */
int ComSendChar(const HCOM pstCom, const TCHAR chCode)
	{
	assert(ComValidHandle(pstCom));

	while (pstCom->nSBufrSize > 0 && (pstCom->nSendCount >= pstCom->nSBufrSize))
		{
		/* wait until there is room in buffer or we're told to give up. */
		if (ComSendCheck(pstCom, TRUE) != COM_OK)
			return FALSE;
		if (pstCom->nSendCount >= pstCom->nSBufrSize)
			(void)ComSndBufrWait(pstCom, 2);
		}

	/* Place char in buffer and assume it will get launched later. */

	if(pstCom && &pstCom->puchSendPut) 
		{
		*pstCom->puchSendPut++ = chCode;
		++pstCom->nSendCount;
		}
	return TRUE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendCharNow
 *
 * DESCRIPTION:	Adds a character to the send buffer and then waits to make
 *				sure the send buffer gets passed to the transmission routine.
 *				This function does NOT wait until the character is actually
 *				transmitted. Handshaking may still delay actual transmission
 *				but no subsequent calls to any ComSend??? routines are needed
 *				to get the character on its way. ComSendWait can be used to
 *				wait until all characters are actually out the port.
 *
 * ARGUMENTS:	pstCom -- handle to comm session
 *				chCode -- The character to be transmitted.
 *
 * RETURNS:		COM_OK if the character is successfully buffered and passed to
 *					 the transmission routines.
 *				COM_INVALID_HANDLE if invalid com handle
 *				COM_SEND_QUEUE_STUCK if the caller-supplied handshake function
 *					 returns a code indicating that waiting data should be
 *					 discarded before the buffer can be	queued for transmission.
 */
int ComSendCharNow(const HCOM pstCom, const TCHAR chCode)
	{
	assert(ComValidHandle(pstCom));

	while (pstCom->nSBufrSize > 0 && (pstCom->nSendCount >= pstCom->nSBufrSize))
		{
		/* buffer is full, wait until there is room or we are
		 *	 told to give up
		 */
		if (ComSendCheck(pstCom, TRUE) != COM_OK)
			return FALSE;
		if (pstCom->nSendCount >= pstCom->nSBufrSize)
			ComSndBufrWait(pstCom, 2);
		}

	if(pstCom && pstCom->puchSendPut) 
		{
		*pstCom->puchSendPut++ = chCode;
		++pstCom->nSendCount;

		/* wait until local buffer is passed to SndBufr or we are
		 * told to give up
		 */
		while (pstCom->nSendCount > 0)
			{
			// This will pass buffer to SndBufr as soon as possible
			if (ComSendCheck(pstCom, TRUE) != COM_OK)
				return FALSE;
			if (pstCom->nSendCount > 0)
				ComSndBufrWait(pstCom, 2);
			}
		}
	return TRUE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendPush
 *
 * DESCRIPTION:	This routine should be called periodically by any code that
 *				uses ComSendChar() when there are no characters to be
 *				transmitted immediately. Calling this function accomplishes
 *				two things.
 *	1. It will cause any buffered send characters to be passed to the actual
 *		transmission routines as soon as they are not busy.
 *	2. It will cause the caller-registered handshake handler function to be
 *		called if transmission is suspended by handshaking.
 *
 * ARGUMENTS:	pstCom -- handle to comm session
 *
 * RETURNS:		same as ComSendCheck()
 */
int ComSendPush(const HCOM pstCom)
	{
	return ComSendCheck(pstCom, FALSE);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendWait
 *
 * DESCRIPTION:	This function waits until all buffered send data is actually
 *				passed to the transmit hardware or until the handshake handling
 *				function returns a code indicating that data should be discared.
 *
 * ARGUMENTS:	pstCom -- handle to comm session
 *	none
 *
 * RETURNS:		COM_OK if all data has been transmitted.
 *				COM_SEND_QUEUE_STUCK if a handshake handling function
 *					 indicated that data should be discarded.
 */
int ComSendWait(const HCOM pstCom)
	{
	assert(ComValidHandle(pstCom));

	while (pstCom->nSendCount > 0 || ComSndBufrWait(pstCom, 2) != COM_OK)
		{
		if (ComSendCheck(pstCom, FALSE) != COM_OK)
			{
			return COM_SEND_QUEUE_STUCK;
			}
		}
	return COM_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendClear
 *
 * DESCRIPTION:	Clears all data waiting for tranmission, both in the local
 *				ComSend buffer and the SndBufr buffer currently being
 *				transmitted.
 *
 * ARGUMENTS:	pstCom -- handle to comm session
 *
 * RETURNS: 	always returns COM_OK
 */
int ComSendClear(const HCOM pstCom)
	{
	assert(ComValidHandle(pstCom));

	ComSndBufrClear(pstCom);
	pstCom->puchSendPut = pstCom->puchSendBufr;
	pstCom->nSendCount = 0;
	return COM_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendSetStatusFunction
 *
 * DESCRIPTION:	Registers a function to be called to handle handshaking status
 *				displays, timeouts, etc. while sending.
 *
 *	The registered function is called when it is registered, when it is being
 *	replaced, and during sending when a handshaking suspension is detected.
 *	Normally, the function is not called if transmission is not suspended.
 *  After being called one or more times with a suspension, though, it will
 *	be called one additional time after the suspension clears to allow the
 *	function to clear any visible indicators.
 *
 *	The registered function is passed the following arguments
 *		usReason	-- Contains a code indicating the reason the function
 *					   was called. It will be one of:
 *					   COMSEND_FIRSTCALL -- if function is being installed
 *					   COMSEND_LASTCALL  -- if function is being replaced
 *					   COMSEND_DATA_WAITING -- if there is data waiting
 *							that will not fit in the send buffer.
 *					   COMSEND_NORMAL	 -- if called due to handshake
 *							condition but no data is in danger of being lost.
 *		fusHsStatus -- A value contining bits which indicate what transmission
 *							is waiting for. The bits are defined in com.h as
 *							COMSB_WAIT_XXX.
 *		lDelay		-- The amount of time in tenths of seconds since
 *							transmission was suspended. This time will not
 *							begin incrementing until there is data to transmit.
 *
 *	The registered function should return a value indicating what action the
 *	  ComSend routines should take regarding handshake suspensions:
 *		COMSEND_OK					no action, if data is waiting, keep waiting
 *		COMSEND_GIVEUP				if data is waiting, discard it and return
 *									  from ComSend??? call.
 *		COMSEND_CLEAR_DATA			discard all transmit buffers, this discards
 *									  any data waiting in a ComSend command
 *									  AND any data previously buffered.
 *		COMSEND_FORCE_CONTINUATION	force data to be transmitted, if waiting
 *									  for XON, pretend it was received. If
 *									  waiting for hardware handshake, disable
 *									  it. ComSend routine will continue trying
 *									  to send any waiting data.
 *
 * ARGUMENTS:	pstCom -- handle to comm session
 *				pfNewStatusFunct -- A pointer to a function matching the specs
 *					 described above or NULL if a default, do-nothing function
 *					 should be used. If the default function is used, ComSend
 *					 commands will essentially wait forever to send data.
 *				ppfOldStatusFunct -- Address of pointer to put the pointer to
 *					 the previously registered function
 *
 * RETURNS:		COM_OK if everything went ok
 *				COM_INVALID_HANDLE if invalid com handle
 */
int ComSendSetStatusFunction(const HCOM pstCom, STATUSFUNCT pfNewStatusFunct,
			 STATUSFUNCT *ppfOldStatusFunct)
	{

	STATUSFUNCT pfHold = pstCom->pfUserFunction;
	unsigned afXmitStatus;
	long   lHandshakeDelay;

	assert(ComValidHandle(pstCom));

	/* If user want's no status function, use an internal function to
	 *	 avoid constant checks for null
	 */
	if (pfNewStatusFunct == NULL)
		{
		pfNewStatusFunct = ComSendDefaultStatusFunction;
		}

	if (pfNewStatusFunct != pfHold)
		{
		ComSndBufrQuery(pstCom, &afXmitStatus, &lHandshakeDelay);

		/* call old function to give it a change to clear up details */
		(void)(*pfHold)(COMSEND_LASTCALL, afXmitStatus, lHandshakeDelay);

		/* call new function so it can initialize */
		pstCom->pfUserFunction = pfNewStatusFunct;
		(void)(*(pstCom->pfUserFunction))(COMSEND_FIRSTCALL, afXmitStatus,
				lHandshakeDelay);
		}

	if (ppfOldStatusFunct)
		*ppfOldStatusFunct = pfHold;

	return COM_OK;
	}



/* * * * * * * * * * * *
 *	Private functions  *
 * * * * * * * * * * * */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendDefaultStatusFunction
 *
 * DESCRIPTION:	This function is used as the handshake handling function when
 *				no caller-supplied function is available, that is, at program
 *				start up or when the caller registeres the NULL function.
 *
 * ARGUMENTS:	See description of handler in ComSendSetStatusFunction
 *
 * RETURNS: 	See description of handler in ComSendSetStatusFunction
 */
int ComSendDefaultStatusFunction(int iReason, unsigned afHsStatus,
		long lDelay)
	{
	/* suppress complaints from lint and the compiler */
	iReason = iReason;
	afHsStatus = afHsStatus;
	lDelay = lDelay;

	/* This function does nothing, it is here to have something to point
	 * pfUserFunction to when ComSendSetStatusFunction is called with
	 * NULL argument.
	 */
	return COM_OK;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ComSendCheck
 *
 * DESCRIPTION:	This function is used internally to keep the flow of
 *				transmitted data moving. It handles setting up and calling the
 *				handshake handling functions and getting the local transmit
 *				buffer passed to the SndBufr routines when they are ready.
 *
 * ARGUMENTS:	pstCom -- handle to comm session
 *				fDataWaiting -- TRUE if being called by a function that has
 *					 data to place in the send buffer when the buffer is full.
 *
 * RETURNS:		COM_OK if the calling function should continue waiting for
 *					 space in the transmit buffer.
 *				COM_INVALID_HANDLE if invalid com handle
 *				COM_SEND_QUEUE_STUCK if the calling function should discard
 *					 any unbuffered data and return.
 */
static int ComSendCheck(const HCOM pstCom, const int fDataWaiting)
	{
	int 	 fResult = TRUE;
	unsigned afXmitStatus;
	long	 lHandshakeDelay;

	if (ComSndBufrBusy(pstCom) != COM_OK)
		{
		ComSndBufrQuery(pstCom, &afXmitStatus, &lHandshakeDelay);

		if (afXmitStatus != 0)
			{
			switch((*(pstCom->pfUserFunction))(fDataWaiting ?
					COMSEND_DATA_WAITING : COMSEND_NORMAL,
					afXmitStatus, lHandshakeDelay))
				{
			case COMSEND_OK:
				break;

			case COMSEND_GIVEUP:
				fResult = FALSE;
				break;

			case COMSEND_CLEAR_DATA:
				ComSendClear(pstCom);
				fResult = FALSE;
				break;

#if 0	//* this should be replaced with a more general mechanism
			case COMSEND_FORCE_CONTINUATION:
				if (bittest(afXmitStatus, COMSB_WAIT_XON))
					ComSendXon(pstCom);
				else if (bittest(afXmitStatus,
						(COMSB_WAIT_CTS | COMSB_WAIT_DSR | COMSB_WAIT_DCD)))
					{
					// TODO: this will be replaced by ComSndBufrForce or such
					// (VOID)ComDisableHHS(pstCom);
					}
				else if (bittest(afXmitStatus, COMSB_WAIT_BUSY))
					{
					ComSendClear(pstCom);
					fResult = FALSE;
					}
				break;
#endif
			default:
				assert(FALSE);
				break;
				}

			pstCom->fUserCalled = TRUE;
			}
		else if (pstCom->fUserCalled)
			{
			(void)(*(pstCom->pfUserFunction))(COMSEND_NORMAL, 0, 0L);
			pstCom->fUserCalled = FALSE;
			}
		}
	else
		{
		int rc = COM_OK;

		if (pstCom->nSendCount > 0)
			{
			rc = ComSndBufrSend(pstCom, pstCom->puchSendBufr, pstCom->nSendCount, 1);

			assert(rc == COM_OK);

			if (rc == COM_OK)
				{
				pstCom->puchSendBufr = pstCom->puchSendPut =
					((pstCom->puchSendBufr == pstCom->puchSendBufr1) ?
					pstCom->puchSendBufr2 :
				    pstCom->puchSendBufr1);
				pstCom->nSendCount = 0;
				}
			else if (rc == COM_PORT_NOT_OPEN)
				{
				#if !defined(NDEBUG)
				MessageBox(NULL,
					       "Attempting to send data when not connected.  Unable to send data.",
						   NULL,
						   MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);
				#endif // !defined(NDEBUG)
				//
				// TODO:REV 4/26/2002 We need to disconnect here with loss of carrier.
				//
				//NotifyClient(pstCom->hSession, EVENT_LOST_CONNECTION,
				//			 CNCT_LOSTCARRIER | (sessQueryExit(pstCom->hSession) ? DISCNCT_EXIT :  0 ));

				ComSendClear(pstCom);
				fResult = FALSE;
				}
			}

		if (pstCom->fUserCalled)
			{
			(void)(*(pstCom->pfUserFunction))(COMSEND_NORMAL, 0, 0L);
			pstCom->fUserCalled = FALSE;
			}
		}

	return(fResult ? COM_OK : COM_SEND_QUEUE_STUCK);
	}


/********************** end of comsend.c ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\errorbox.h ===
/*	File: D:\WACKER\tdll\errorbox.h (Created: 26-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:37p $
 */

extern int TimedMessageBox(HWND hwndOwner,
						LPCTSTR lpszText,
						LPCTSTR lpszTitle,
						UINT fuStyle,
						int nTimeout);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\dodialog.c ===
/*	File: D:\WACKER\tdll\dodialog.c (Created: 30-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/22/01 11:27a $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "session.h"
#include "tdll.h"
#include "globals.h"
#include "statusbr.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	DoDialog
 *
 * DESCRIPTION: Use this routine to call dialogs.  It creates ProcInstance
 *				of the dialog procedure automatically and destroys it on
 *				exit.
 *
 * ARGUMENTS:	hInstance	   - instance handle of template's module
 *				lpTemplateName - name of dialog-box template
 *				hwndParent	   - window thats get focus when done
 *				lpProc		   - far pointer to the dialog procedure.
 *							   - Note: lpProc is NOT the pointer
 *								 obtained from MakeProcInstance...
 *				lPar		   - Can be used to pass data to dlg proc.
 *
 * RETURNS: 	Whatever the dilogbox returns on exit.
 *
 */
INT_PTR DoDialog(HINSTANCE hInstance, LPCTSTR lpTemplateName,
			     HWND hwndParent, DLGPROC lpProc, LPARAM lPar)
	{
	INT_PTR		sRetVal;			// return value for DialogBox()
	HWND		hwndFrame;
	HSESSION	hSession;

	// Normal dialog box stuff...

	sRetVal = DialogBoxParam(hInstance, lpTemplateName, hwndParent,
		lpProc, lPar);

	#if !defined(NDEBUG)
		if (sRetVal == -1)
			{
			TCHAR str[128], awch[50];

			OemToChar("Couldn't load %s. (%s, %d)", awch);
			wsprintf(str, awch, lpTemplateName, (LPTSTR)__FILE__, __LINE__);

			OemToChar("Internal Error", awch);
			MessageBox(hwndParent, str, awch, MB_OK | MB_ICONHAND);
			}
	#endif

	// We should force the statusbar window ro refresh its display
	// here to reflect the state of the keys the user might have pressed while
	// the dialog was up.
	//
	// Yes, I know we are relying on the fact that the frame window is the
	// the session window.  This may have to change in UPPER-WACKER.
	//
	hwndFrame = glblQueryHwndFrame();

	if (IsWindow(hwndFrame) && (hwndFrame == hwndParent))
		{
		hSession = (HSESSION)GetWindowLongPtr(hwndFrame, GWLP_USERDATA);
		PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
			SBR_KEY_PARTS, 0);
		}

	return sRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	DoModelessDialog
 *
 * DESCRIPTION: This is a verion of the previous function that differs
 *				in that it creates and registers a modeless dialog
 *
 * ARGUMENTS:	hInstance	   - instance handle of template's module
 *				lpTemplateName - name of dialog-box template
 *				hwndOwner	   - window thats get focus when done
 *				lpProc		   - far pointer to the dialog procedure.
 *							   - Note: lpProc is NOT the pointer
 *								 obtained from MakeProcInstance...
 *				lPar		   - Can be used to pass data to dlg proc.
 *
 * RETURNS:
 *	The window handle of the dialog box that was created.
 *
 */
HWND DoModelessDialog(HINSTANCE hInstance, LPCTSTR lpTemplateName,
			 HWND hwndOwner, DLGPROC lpProc, LPARAM lPar)
	{
	HWND		hwndBox;

	hwndBox = CreateDialogParam(hInstance,
								lpTemplateName,
								hwndOwner,
								lpProc,
								lPar);

	if (hwndBox)
		{
		glblAddModelessDlgHwnd(hwndBox);
		}

	#if !defined(NDEBUG)
		if (hwndBox == NULL)
			{
			TCHAR str[128], awch[50];

			OemToChar("Couldn't load %s. (%s, %d)", awch);
			wsprintf(str, awch, lpTemplateName, (LPTSTR)__FILE__, __LINE__);

			OemToChar("Internal Error", awch);
			MessageBox(hwndOwner, str, awch, MB_OK | MB_ICONHAND);
			}
	#endif

	return hwndBox;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	EndModelessDialog
 *
 * DESCRIPTION:
 *	This function is used to remove a modeless dialog from whatever we are
 *	doing with it.
 *
 * PARAMETERS:
 *	hDlg -- the window handle of the modeless dialog
 *
 * RETURNS:
 *	ZERO for now.  Maybe something else later.
 *
 */
INT EndModelessDialog(HWND hDlg)
	{
	if (IsWindow(hDlg))
		PostMessage(glblQueryHwndFrame(), WM_SESS_ENDDLG, 0, (LPARAM)hDlg);

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\features.h ===
/*      File: D:\WACKER\tdll\features.h (Created: 24-Aug-1994)
 *
 *      Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *      All rights reserved
 *
 *      $Revision: 21 $
 *      $Date: 1/29/02 2:30p $
 */


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *                           R E A D   M E
 *
 * This file is a replacement for the INC.H file that was used in HAWIN
 * and HA/5.  It controls optional features that may or may not be built
 * into this product.  This file CANNOT have anything except defines in
 * it.  It is for control and configuration only.  Violate this rule at
 * your peril.  (Please ?)
 *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *                           R E A D   M E
 *
 * This file has been organized into sections based on language.  To find
 * which features are enabled search for the language you are building.
 *
 * The following section contains descriptions of the settings currently
 * available for each language.
 *
 * The end of the file contains a series of test to verify that required
 * settings have been set.
 *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/


#if !defined(FEATURES_H_INCLUDED)
#define FEATURES_H_INCLUDED

#if defined(EXTENDED_FEATURES)

#define INCL_ZMODEM_CRASH_RECOVERY
#define INCL_REDIAL_ON_BUSY
#define INCL_USE_TERMINAL_FONT
#define INCL_SPINNING_GLOBE
#define INCL_PRIVATE_EDITION_BANNER
#define USE_PRIVATE_EDITION_3_BANNER
#define INCL_WINSOCK
#define INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
#define INCL_CALL_ANSWERING
#define INCL_DEFAULT_TELNET_APP
#define INCL_VT100COLORS
#define INCL_EXIT_ON_DISCONNECT
#define INCL_VT220                              // Added 20-Jan-98. rde
#if defined(INCL_VT220)                         // The 320 requires the 220 be defined.
#define INCL_VT320                              // Added 24-Jan-98. rde
#endif // INCL_VT220
// This next define is for host controlled printing - raw versus windows 
// It should be enabled for commercial builds. MPT 11-18-99
#define INCL_PRINT_PASSTHROUGH
// A customer specific version. Added 16 Feb 98. rde
//#define INCL_ULTC_VERSION                        

//Private Edition 4 features
#define INCL_TERMINAL_SIZE_AND_COLORS
#define INCL_KEY_MACROS
#define INCL_TERMINAL_CLEAR
//#define INCL_USE_HTML_HELP //removed due to a requirement to redistribute a 404k support program
#define INCL_NAG_SCREEN
#define INCL_COOL_TOOLBARS

#if !defined(USA)
#define USA
#endif // USA
#undef JAPANESE

#endif //EXTENDED_FEATURES
#if defined(NT_EDITION)

#undef  EXTENDED_FEATURES	// There are no extended features in the Microsoft version.
#undef  INCL_SPINNING_GLOBE
#undef  INCL_PRIVATE_EDITION_BANNER // There is no banner screen in the Microsoft version.
#undef  USE_PRIVATE_EDITION_3_BANNER  // There is no banner screen in the Microsoft version.
#undef  INCL_VT100COLORS
#undef  INCL_EXIT_ON_DISCONNECT
#undef  INCL_VT220                              // Added 20-Jan-98. rde
#undef  INCL_VT320                              // Added 24-Jan-98. rde
#undef  INCL_PRINT_PASSTHROUGH
#undef  INCL_TERMINAL_SIZE_AND_COLORS
#undef  INCL_KEY_MACROS
#undef  INCL_TERMINAL_CLEAR
#undef  INCL_NAG_SCREEN	// There is no nag screen in the Microsoft version.
#undef  INCL_COOL_TOOLBARS

#define INCL_ZMODEM_CRASH_RECOVERY
#define INCL_REDIAL_ON_BUSY
#define INCL_USE_TERMINAL_FONT
#define INCL_WINSOCK
#define INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
#define INCL_CALL_ANSWERING
#define INCL_DEFAULT_TELNET_APP
//mpt:08-22-97 added HTML help for Microsoft's version
#if !defined(INCL_USE_HTML_HELP)
 #define INCL_USE_HTML_HELP
#endif //INCL_USE_HTML_HELP
//mpt:04-29-98 added new Printing Common Dialogs for Microsoft
#if(WINVER >= 0x0500 && ISOLATION_AWARE_ENABLED)
#if !defined(INCL_USE_NEWPRINTDLG)
#define INCL_USE_NEWPRINTDLG
#endif //INCL_USE_NEWPRINTDLG
#endif // WINVER >= 0x0500
//mpt:09-24-99 added new browse dialog for Microsoft
#if !defined(INCL_USE_NEWFOLDERDLG)
#define INCL_USE_NEWFOLDERDLG
#endif //INCL_USE_NEWFOLDERDLG
#if !defined(INCL_VTUTF8)
#define INCL_VTUTF8
#endif //INCL_VTUTF8

#undef USA
#if !defined(JAPANESE)
#define JAPANESE
#endif // JAPANESE

#endif // NT_EDITION

/*
 * Minitel and Prestel terminals are now included standard
 */
#define INCL_MINITEL
#define INCL_VIEWDATA

/*
 * This feature is used in the FAR EAST version.  It provides code to
 * support an optional character translation DLL.  This DLL is called to
 * translate the data stream on both input and output.  It does not
 * translate the underlying character values (at the present time), only
 * the encoding method.  The initial version of this will only translate
 * between JIS and Shift-JIS.  For commercial release, additional operations
 * such as JIS escape recovery, UNICODE, and EUC encoding can be added just
 * by changing the DLL.  In fact, the new DLL can be offered as an upgrade
 * to the lower version of the product.
 *
 * #define CHARACTER_TRANSLATION
 */

/*
 * These next feature sets are used to control the character width that we
 * are compiling for.  There are 3 disjoint choices.  Only one can be selected.
 * One MUST be selected.  We will have code in here to cause noise if none or
 * more than one is selected.
 *
 * The 3 choices are:
 *
 *      CHAR_NARROW
 *      This is what we use for the U.S. and European versions.  It means all
 *      characters are a single "byte" and each one takes up 8 bits.
 *
 *      CHAR_WIDE
 *      This is what we will use for the UNICODE version if and when it ever
 *      decides to become an option.  It means that all characters are a single
 *      "byte" and each one takes up 16 (for now) bits.
 *
 *      CHAR_MIXED
 *      This is what we use for the FAR EAST (DBCS) version.  It means that the
 *      characters may take up one or two  "bytes" and each one takes up
 *      8 or 16 bits.
 * #define  CHAR_NARROW
 * #define  CHAR_WIDE
 * #define  CHAR_MIXED
 */

#if defined(USA)
    #define  CHAR_NARROW
	#undef FAR_EAST
	#undef INCL_VT100J
	#undef INCL_ANSIW
    #undef CHAR_MIXED
    #undef CHARACTER_TRANSLATION


#elif defined(JAPANESE)
    #undef  CHAR_NARROW
	#define FAR_EAST
	#define INCL_VT100J
	#define INCL_ANSIW
    #define CHAR_MIXED
    #define CHARACTER_TRANSLATION
#endif

/* ************* THIS SECTION MUST BE AT THE END OF THE FILE*************
 *
 * It tests to see if required settings have been set for the current build
 *
 */
#if 0
#if !defined(CHAR_NARROW) && !defined(CHAR_WIDE) && !defined(CHAR_MIXED)
#error  Remember, one of these must be defined.
#endif

#if defined(CHAR_NARROW) && defined(CHAR_WIDE)
#error  Remember, only one of these can be defined.
#endif

#if defined(CHAR_NARROW) && defined(CHAR_MIXED)
#error  Remember, only one of these can be defined.
#endif

#if defined(CHAR_WIDE) && defined(CHAR_MIXED)
#error  Remember, only one of these can be defined.
#endif
#endif //0

#if !defined(CHAR_WIDE) && !defined(CHAR_MIXED) && defined(INCL_VTUTF8)
#error  Remember, We must have CHAR_WIDE or CHAR_MIXED to have INCL_VTUTF8 defined.
#undef  INCL_VTUTF8
#endif

#endif // FEATURES_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\file_io.c ===
/*	File: D:\WACKER\tdll\file_io.c (Created: 26-Jan-1994)
 *
 *	Copyright 1994,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/15/02 12:19p $
 */
#include <windows.h>
#pragma hdrstop

// #define	DEBUGSTR	1
#include "stdtyp.h"
#include "mc.h"
#include <tdll\assert.h>

#include "file_io.h"
#include "file_msc.h"

/*
 * This stuff is a replacement for some sort of buffered file I/O.
 *
 * It is directly modeled after (read lifted from) the "stdio.h" stuff.
 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	_fio_fill_buf
 *
 * DESCRIPTION:
 *	This is an "internal" function called by the "fio_getc" macro.  It is a
 *	replacement for the "_filbuf" function in "stdio".
 *
 * PARAMETERS:
 *	pF -- a pointer to a file structure.
 *
 * RETURNS:
 *	The next character available or an EOF.
 */
int _fio_fill_buf(ST_IOBUF *pF)
	{
	DWORD dwSize;
	int   iRet;

	assert(pF);
	assert(pF->_fio_magic == _FIO_MAGIC);

	if (pF->_fio_flag != 0)
		return EOF;

	if (pF->_fio_base == NULL)
		{
		pF->_fio_base = malloc(pF->_fio_bufsiz);
		if (pF->_fio_base == NULL)
			{
			pF->_fio_flag |= _FIO_IOERR;
			return EOF;
			}
		}

	pF->_fio_ptr = pF->_fio_base;

	dwSize = 0;
	DbgOutStr("fio_fill_buf reads %d bytes", pF->_fio_bufsiz, 0,0,0,0);
	iRet = ReadFile(pF->_fio_handle,
			        pF->_fio_ptr,
			        pF->_fio_bufsiz,
			        &dwSize,
			        NULL);
	DbgOutStr("...done\r\n", 0,0,0,0,0);

	if (dwSize == 0 || iRet == FALSE)
		{
		pF->_fio_flag |= _FIO_IOEOF;
		return EOF;
		}

	pF->_fio_cnt = dwSize;

	return (fio_getc(pF));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	_fio_flush_buf
 *
 * DESCRIPTION:
 *	This is an "internal" function called by the "fio_putc" macro.  It is a
 *	replacement for the "_flsbuf" function in "stdio".
 *
 * PARAMETERS:
 *	c   -- the next character to be written out
 *	pF  -- a pointer to a file structure
 *
 * RETURNS:
 *	The character buffered of an EOF.
 */
int _fio_flush_buf(int c, ST_IOBUF *pF)
	{
	int size;
	DWORD dwFoo;

	assert(pF);
	assert(pF->_fio_magic == _FIO_MAGIC);

	if (pF->_fio_flag != 0)
		return EOF;

	if (pF->_fio_base == NULL)
		{
		pF->_fio_base = malloc(pF->_fio_bufsiz);
		if (pF->_fio_base == NULL)
			{
			pF->_fio_flag |= _FIO_IOERR;
			return EOF;
			}
		}
	else
		{
		/* We have been here before, dump the buffer */
		size = (int)(pF->_fio_ptr - pF->_fio_base);
		if (size > 0)
			{
			DbgOutStr("fio_putc writes %d bytes", size, 0,0,0,0);
			WriteFile(pF->_fio_handle,
					pF->_fio_base,
					size,
					&dwFoo,
					NULL);
			DbgOutStr("...done\r\n", 0,0,0,0,0);
			}
		}
	pF->_fio_ptr = pF->_fio_base;
	pF->_fio_cnt = pF->_fio_bufsiz;

	return fio_putc(c, pF);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fio_open
 *
 * DESCRIPTION:
 *	This function creates a file structure handle and initializes the handle.
 *
 * PARAMETERS:
 *	fname -- a pointer to the file name
 *	mode  -- flags, see file_io.h
 *
 * RETURNS:
 *	A pointer to an initialize structure or a NULL.
 */
ST_IOBUF *fio_open(char *fname, int mode)
	{
	int nFileExists;
	DWORD dwMode;
	DWORD dwShare;
	DWORD dwCreate;
	ST_IOBUF *pF;

	nFileExists = GetFileSizeFromName(fname, NULL);

	dwMode = 0;
	if ((mode & FIO_READ) != 0)
		dwMode |= GENERIC_READ;
	if ((mode & FIO_WRITE) != 0)
		dwMode |= GENERIC_WRITE;
	if (dwMode == 0)
		return NULL;

	dwShare = FILE_SHARE_READ;
	if ((mode & FIO_WRITE) == 0)
		dwShare |= FILE_SHARE_WRITE;

	dwCreate = 0;
	if ((mode & FIO_CREATE) == 0)
		{
		/* Don't wack the file here */
		if (nFileExists)
			{
			dwCreate = OPEN_EXISTING;
			}
		else
			{
			dwCreate = CREATE_NEW;
			}
		}
	else
		{
		/* FIO_CREATE means always wack the file */
		if (nFileExists)
			{
			if ((mode & FIO_WRITE) == 0)
				{
				dwCreate = OPEN_EXISTING;
				}
			else
				{
				dwCreate = TRUNCATE_EXISTING;
				}
			}
		else
			{
			dwCreate = CREATE_NEW;
			}
		}

	pF = (ST_IOBUF *)malloc(sizeof(ST_IOBUF));
	if (pF != (ST_IOBUF *)0)
		{
		pF->_fio_magic = 0;
		pF->_fio_ptr = NULL;
		pF->_fio_cnt = 0;
		pF->_fio_base = NULL;
		pF->_fio_flag = 0;
		pF->_file = 0;
		pF->_fio_handle = 0;
		pF->_fio_mode = mode;
		pF->_fio_charbuf = 0;
		pF->_fio_bufsiz = _FIO_BSIZE;
		pF->_fio_tmpfname = NULL;

		/*
		 * Try and open the file
		 */
		pF->_fio_handle = CreateFile(fname,
									dwMode,
									dwShare,
									NULL,
									dwCreate,
									0,
									NULL);
		if (pF->_fio_handle == INVALID_HANDLE_VALUE)
			{
			free(pF);
			pF = (ST_IOBUF *)0;
			}
		}
	if (pF)
		{
		if ((mode & FIO_APPEND) != 0)
			{
			SetFilePointer(pF->_fio_handle,
							0,
							NULL,
							FILE_END);
			}
		}
	if (pF)
		{
		/* Mark as a valid structure */
		pF->_fio_magic = _FIO_MAGIC;
		}
	return pF;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fio_close
 *
 * DESCRIPTION:
 *	This function flushes whatever data needs to be flushed and closes stuff
 *	up.
 *
 * PARAMETERS:
 *	pF  -- a pointer to a file structure
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an EOF.
 */
int fio_close(ST_IOBUF *pF)
	{
	int size;
	DWORD dwFoo;

	assert(pF);
	assert(pF->_fio_magic == _FIO_MAGIC);

	if (pF)
		{
		/*
		 * Make sure any data is written out
		 */
		if ((pF->_fio_mode & FIO_WRITE) != 0)
			{
			if (pF->_fio_ptr != NULL)
				{
				size = (int)(pF->_fio_ptr - pF->_fio_base);
				if (size > 0)
					{
					DbgOutStr("fio_close writes %d bytes", size, 0,0,0,0);
					WriteFile(pF->_fio_handle,
							pF->_fio_base,
							size,
							&dwFoo,
							NULL);
					DbgOutStr("...done\r\n", 0,0,0,0,0);
					}
				}
			}

		CloseHandle(pF->_fio_handle);
		pF->_fio_handle = INVALID_HANDLE_VALUE;
		free(pF);
		pF = NULL;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fio_seek
 *
 * DESCRIPTION:
 *	This function is a replacement for the fseek function.
 *
 * PARAMETERS:
 *	pF       -- a pointer to a file structure
 *	position -- where to move the file pointer to
 *	mode     -- starting address of the move
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an EOF.
 */
int fio_seek(ST_IOBUF *pF, size_t position, int mode)
	{
	DWORD dwMethod;
	int size;

	assert(pF);
	assert(pF->_fio_magic == _FIO_MAGIC);

	switch (mode)
		{
		default:
			return EOF;
		case FIO_SEEK_CUR:
			dwMethod = FILE_CURRENT;
			break;
		case FIO_SEEK_END:
			dwMethod = FILE_END;
			break;
		case FIO_SEEK_SET:
			dwMethod = FILE_BEGIN;
			break;
		}

	if (pF)
		{
		/*
		 * Make sure any data is written out
		 */
		if ((pF->_fio_mode & FIO_WRITE) != 0)
			{
			if (pF->_fio_ptr != NULL)
				{
				size = (int)(pF->_fio_ptr - pF->_fio_base);
				if (size > 0)
					{
					DbgOutStr("fio_seek writes %d bytes", size, 0,0,0,0);
					WriteFile(pF->_fio_handle,
							pF->_fio_base,
							size,
							NULL,
							NULL);
					DbgOutStr("...done\r\n", 0,0,0,0,0);
					}
				}
			}
		pF->_fio_cnt = 0;

		SetFilePointer(pF->_fio_handle,
						position,
						NULL,
						dwMethod);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fio_read
 *
 * DESCRIPTION:
 *	This function is a replacement for the "fread" function in "stdio".
 *
 * PARAMETERS:
 *	buffer -- address of the data to read
 *	size   -- the size of each item (object?) to read
 *	count  -- the number of items to read
 *	pF     -- a pointer to a file structure
 *
 * RETURNS:
 *	The number of items read from the file, ZERO indicating EOF.
 */
int fio_read(void *buffer, size_t size, size_t count, ST_IOBUF *pF)
	{
	DWORD dwSize;
	DWORD dwGot;
	int   iRet;

	assert(pF);
	assert(pF->_fio_magic == _FIO_MAGIC);

	/* For now, don't allow intermix of buffered and non_buffered */
	assert(pF->_fio_base == NULL);

	if (pF)
		{
		dwSize = (DWORD)(size * count);
		dwGot = 0;
		DbgOutStr("fio_read reads %d bytes", dwSize, 0,0,0,0);
		iRet = ReadFile(pF->_fio_handle,
				        buffer,
				        dwSize,
				        &dwGot,
				        NULL);
		DbgOutStr("...done\r\n", 0,0,0,0,0);

		if (dwGot == 0 || iRet == FALSE)
			{
			pF->_fio_flag |= _FIO_IOEOF;
			}
		return dwGot / size;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fio_write
 *
 * DESCRIPTION:
 *	This function is a replacement for the "fwrite" function in "stdio".
 *
 * PARAMETERS:
 *	buffer -- address of the data to write
 *	size   -- the size of each item (object?) to write
 *	count  -- the number of items to write
 *	pF     -- a pointer to a file structure
 *
 * RETURNS:
 *	The number of items written to the file.
 */
int fio_write(void *buffer, size_t size, size_t count, ST_IOBUF *pF)
	{
	DWORD dwSize;
	DWORD dwPut;

	assert(pF);
	assert(pF->_fio_magic == _FIO_MAGIC);

	/* For now, don't allow intermix of buffered and non_buffered */
	assert(pF->_fio_base == NULL);

	if (pF)
		{
		dwSize = (DWORD)(size * count);
		dwPut = 0;
		DbgOutStr("fio_write writes %d bytes", dwSize, 0,0,0,0);
		WriteFile(pF->_fio_handle,
				buffer,
				dwSize,
				&dwPut,
				NULL);
		DbgOutStr("...done\r\n", 0,0,0,0,0);
		if (dwPut == 0)
			{
			pF->_fio_flag |= _FIO_IOEOF;
			}
		return dwPut / size;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\errorbox.c ===
/*	File: C:\WACKER\TDLL\error_box.c (Created: 22-Dec-1993)
 *
 *	Copyright 1990,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 10 $
 *	$Date: 4/17/02 10:00a $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "assert.h"

#include "tdll.h"
#include "htchar.h"
#include "globals.h"
#include "errorbox.h"
#include "misc.h"

#include <term\res.h>

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * Global Variables:
 *
 *	These global variables are used to tell if the timer expored.  At some
 *	future time it may become necessary to lock them, but not yet.
 */

#define	TMB_IDLE		0
#define	TMB_ACTIVE		1
#define	TMB_EXPIRED		2

static int nState = TMB_IDLE;
static LPCTSTR pszMsgTitle;
static HWND hwndMsgOwner;
static BOOL CALLBACK TMTPproc(HWND hwnd, LPARAM lP);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	TimedMessageTimerProc
 *
 * DESCRIPTION:
 *	This is the function that is passed to SetTimer when TimedMessageBox is
 *	called.
 *
 * PARAMETERS:
 *	As per the Win32 documentation.
 *
 * RETURNS:
 *	As per the Win32 documentation.
 */
VOID CALLBACK TimedMessageTimerProc(HWND hwnd,
									UINT uMsg,
									UINT_PTR idEvent,
									DWORD dwTime)
	{
	// EnumThreadWindows(GetWindowThreadProcessId(hwndMsgOwner, NULL),
	//				TMTPproc, 0);
	/*
	 * This works, but it is a very chancy thing to be doing.
	 * TODO: figure out a better way to kill the sucker.
	 */
	EnumWindows(TMTPproc, 0);
	}

static BOOL CALLBACK TMTPproc(HWND hwnd, LPARAM lP)
	{
	TCHAR cBuffer[128];

	cBuffer[0] = TEXT('\0');
	/* Get the title of the window */
	GetWindowText(hwnd, cBuffer, 128);
	/* Compare to what we are looking for */
	if (StrCharCmp(cBuffer, pszMsgTitle) == 0)
		{
		/* TODO: remove this after debugging is done */
		mscMessageBeep(MB_ICONHAND);
		nState = TMB_EXPIRED;
		/* Take that, you rogue window ! */
		PostMessage(hwnd, WM_CLOSE, 0, 0);
		return FALSE;
		}
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	TimedMessageBox
 *
 * DESCRIPTION:
 *	This function is a replacement for MessageBox.  It has the added feature
 *	of having a timeout feature.  The timeout feature is necessary for any
 *	type of HOST mode or script feature.
 *
 * PARAMETERS:
 *	The parameters are the same as those passed to MessageBox plus our own
 *	timeout value.  If the timeout value is greater than ZERO, then the
 *	timeout feature is active.  If it is less than or equal to ZERO, the
 *	timeout feature is disabled.
 *
 * RETURNS:
 *	This function returns the usual MessageBox return values.  It can also
 *	return a new value for a timeout.  Each instance of calling this box
 *	should take care to handle the timeout return in an useful manner.
 *
 *	For now, the timeout return value is set to (-1)
 */
int TimedMessageBox(HWND hwndOwner,
					LPCTSTR lpszText,
					LPCTSTR lpszTitle,
					UINT fuStyle,
					int nTimeout)
	{
	int 	 nRet = 0;
	UINT_PTR uTimer = 0;
	TCHAR	 acTitle[256];
	LPTSTR   pTitle = (LPTSTR)lpszTitle;

	if (lpszText == NULL || StrCharGetStrLength(lpszText) == 0)
		{
		UINT uiBeep;
		
		if (fuStyle & MB_ICONASTERISK)
			{
			uiBeep = MB_ICONASTERISK;
			}
		else if (fuStyle & MB_ICONEXCLAMATION)
			{
			uiBeep = MB_ICONEXCLAMATION;
			}
		else if (fuStyle & MB_ICONHAND)
			{
			uiBeep = MB_ICONHAND;
			}
		else if (fuStyle & MB_ICONQUESTION)
			{
			uiBeep = MB_ICONQUESTION;
			}
		else if(fuStyle & MB_OK)
			{
			uiBeep = MB_OK;
			}
		else
			{
			uiBeep = -1;
			}

		mscMessageBeep(uiBeep);
		return nRet;
		}

	if ((lpszTitle == 0 || StrCharGetStrLength(lpszTitle) == 0) &&
		LoadString(glblQueryDllHinst(), IDS_MB_TITLE_ERR, acTitle, 256) != 0)
		{
		pTitle = acTitle;
		}

	/*
	 * A small hack because of the way the timeout stuff works.
	 * TODO: get this to work better.
	 */
	if (nTimeout > 0)
		{
		nTimeout *= 1000L;			/* Convert seconds to milliseconds */

		/* TODO: put something more unique into the title for ID purposes */
		/* something like the parent window handle or similar */
		pszMsgTitle = lpszTitle;	/* Used to ID the window */
		hwndMsgOwner = hwndOwner;

		nState = TMB_ACTIVE;
		if ((uTimer = SetTimer(NULL, 0, nTimeout, TimedMessageTimerProc)) == 0)
			{
			assert(FALSE);
			/* Return failure */
			return nRet;
			}
		}

	fuStyle |= MB_SETFOREGROUND;

	// TODO: May have to use MessageBoxEx() which provides a way of including
	// a language specification so that pre-defined buttons appear with the
	// correct language on them, OR MessageBoxIndirect() which allows for a
	// definition of a hook-proc which can process the HELP messages - jac.
	//
	// REV: 3/27/2002 -- The following is a clipping from the MSDN documentation:
	//
	// The MessageBox function creates, displays, and operates a message box.
	// The message box contains an application-defined message and title, plus
	// any combination of predefined icons and push buttons. 
	//
	// The MessageBoxEx function creates, displays, and operates a message box.
	// The message box contains an application-defined message and title, plus
	// any combination of predefined icons and push buttons. The buttons are in
	// the language of the system user interface.
	//
	// Currently MessageBoxEx and MessageBox work the same way.
	//
	// TODO: We still need to make sure the sounds are transmitted when running
	// in a Terminal Service session (Remote Desktop Connection) when the sound
	// is anything other than -1.
	//

	nRet = MessageBox(hwndOwner,
					  lpszText,
					  pTitle,
					  fuStyle);

	switch (nState)
		{
		case TMB_ACTIVE:
			/*
			 * Everything is OK, no problem
			 */
			if (uTimer != 0)
				{
				KillTimer(NULL, uTimer);
				}
			break;
		case TMB_EXPIRED:
			/*
			 * Timer expired and killed MessageBox
			 */
			nRet = (-1);
			if (uTimer != 0)
				{
				KillTimer(NULL, uTimer);
				}
			break;
		case TMB_IDLE:
		default:
			if (uTimer != 0)
				{
				KillTimer(NULL, uTimer);
				}
			break;
		}

	nState = TMB_IDLE;

	return nRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\file_io.h ===
/*	File: D:\WACKER\tdll\file_io.h (Created: 26-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:40p $
 */

/*
 * This stuff is a replacement for some sort of buffered file I/O.
 *
 * It is directly modeled after (read lifted from) the "stdio.h" stuff.
 */

#if !defined(EOF)
#define	EOF	(-1)
#endif

#define	_FIO_IOEOF		0x0001
#define	_FIO_IOERR		0x0002

#define	_FIO_BSIZE		512

#define	_FIO_MAGIC		0x1234A587

struct _fileio_buf {
	long      _fio_magic;
	char     *_fio_ptr;
	int       _fio_cnt;
	char     *_fio_base;
	int       _fio_flag;
	int       _file;			/* Not used, replaced with the following */
	HANDLE    _fio_handle;
	int       _fio_mode;
	int       _fio_charbuf;
	int       _fio_bufsiz;
	char     *_fio_tmpfname;
	};

typedef struct _fileio_buf ST_IOBUF;

/* Macro definitions */

#define fio_feof(_stream)	  ((_stream)->_fio_flag & _FIO_IOEOF)

#define fio_ferror(_stream)   ((_stream)->_fio_flag & _FIO_IOERR)

#define	fio_errclr(_stream)	((_stream)->_fio_flag = 0)

#define _fileno(_stream)  ((_stream)->_file)

#define	fio_gethandle(_stream)	((_stream)->_fio_handle)

#define fio_getc(_s)	  (--(_s)->_fio_cnt >= 0 \
		? 0xff & *(_s)->_fio_ptr++ : _fio_fill_buf(_s))

/* TODO: make this work better */
#define	fio_ungetc(_c,_s)	(*(--(_s)->_fio_ptr) = (char)_c);((_s)->_fio_cnt++)

#define fio_putc(_c,_s)  (--(_s)->_fio_cnt >= 0 \
		? 0xff & (*(_s)->_fio_ptr++ = (char)(_c)) : _fio_flush_buf((_c),(_s)))

int _fio_fill_buf(ST_IOBUF *);

int _fio_flush_buf(int, ST_IOBUF *);

/* mode flags for fio_open, may be or'd together */

#define	FIO_CREATE	0x0001
#define	FIO_READ	0x0002
#define	FIO_WRITE	0x0004
/* append means just reposition at the end of the file after open */
#define	FIO_APPEND	0x0008

ST_IOBUF *fio_open(char *, int);

int fio_close(ST_IOBUF *);

#define	FIO_SEEK_CUR	0x0001
#define	FIO_SEEK_END	0x0002
#define	FIO_SEEK_SET	0x0003

int fio_seek(ST_IOBUF *, size_t, int);

int fio_read(void *buffer, size_t size, size_t count, ST_IOBUF *pF);

int fio_write(void *buffer, size_t size, size_t count, ST_IOBUF *pF);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\fusionsources.inc ===
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
<assemblyIdentity
    version=SXS_ASSEMBLY_VERSION
    processorArchitecture=SXS_PROCESSOR_ARCHITECTURE
    name=SXS_ASSEMBLY_NAME
    type="win32"
/>
<description>HyperTerminal</description>
<dependency>
    <dependentAssembly>
        <assemblyIdentity
            type="win32"
            name="Microsoft.Windows.Common-Controls"
            version="6.0.0.0"
            processorArchitecture=SXS_PROCESSOR_ARCHITECTURE
            publicKeyToken="6595b64144ccf1df"
            language="*"
        />
    </dependentAssembly>
</dependency>
</assembly>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\file_msc.hh ===
/*	File: D:\WACKER\tdll\file_msc.hh (Created: 26-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:38p $
 */

/*
 * This is where the hidden stuff for the files and directorys code gets
 * defined.  You shouldn't be looking at this.
 */

struct stFilesAndDirectorys
	{
	HSESSION hSession;

	LPTSTR pszInternalSendDirectory;	/* Used if not set by user */
	LPTSTR pszTransferSendDirectory;

	LPTSTR pszInternalRecvDirectory;	/* Used if not set by user */
	LPTSTR pszTransferRecvDirectory;
	};

typedef struct stFilesAndDirectorys FD_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\file_msc.h ===
/*	File: D:\WACKER\tdll\file_msc.h (Created: 26-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 5/21/02 8:40a $
 */

/*
 * Error codes
 */
#define	FM_ERR_BASE				0x400
#define	FM_ERR_NO_MEM			FM_ERR_BASE+1
#define	FM_ERR_BAD_HANDLE		FM_ERR_BASE+1

/*
 * Constants
 */
#define	FM_CHUNK_SIZE			64

extern HFILES CreateFilesDirsHdl(const HSESSION hSession);

extern INT InitializeFilesDirsHdl(const HSESSION hSession, HFILES hFile);

extern INT LoadFilesDirsHdl(HFILES hFile);

extern INT DestroyFilesDirsHdl(const HFILES hFile);

extern INT SaveFilesDirsHdl(const HFILES hFile);

extern LPCTSTR filesQuerySendDirectory(HFILES hFile);

extern LPCTSTR filesQueryRecvDirectory(HFILES hFile);

extern VOID filesSetRecvDirectory(HFILES hFile, LPCTSTR pszDir);

extern VOID filesSetSendDirectory(HFILES hFile, LPCTSTR pszDir);

extern HBITMAP fileReadBitmapFromFile(HDC hDC, LPTSTR pszName, int fCmp);

/*
 * The following function returns data in the following format:
 *
 * An array of pointers to strings is alocated. As file names are found, a
 * new string is allocated and the pointer to the string is put in the array.
 * The array is expanded as needed.  Freeing memory is the responsiblity of
 * the caller.
 */

extern int fileBuildFileList(void **pData,
							int *pCnt,
							LPCTSTR pszName,
							int nSubdir,
							LPCTSTR pszDirectory);


extern int fileFinalizeName(LPTSTR pszOldname,
					LPTSTR pszOlddir,
					LPTSTR pszNewname,
					const size_t cb);

extern int fileFinalizeDIR(HSESSION hSession,
							LPTSTR pszOldname,
							LPTSTR pszNewname);

/*
 * The following are generic functions that an operating system SHOULD have.
 */
extern int GetFileSizeFromName(TCHAR *pszName,
							unsigned long * const pulFileSize);
int SetFileSize(const TCHAR *pszName, unsigned long ulFileSize);

extern int IsValidDirectory(LPCTSTR pszName);

extern int ValidateFileName(LPSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\file_msc.c ===
/*	File: D:\WACKER\tdll\file_msc.c (Created: 26-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 11 $
 *	$Date: 7/08/02 6:41p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "mc.h"
#include "sf.h"
#include "tdll.h"
#include "sess_ids.h"
#include <tdll\assert.h>
#include "session.h"
#include "open_msc.h"
#include "htchar.h"

#include "file_msc.h"
#include "file_msc.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 *
 *                            F I L E _ M S C . C
 *
 * This file contains functions that are needed to deal with files, names of
 * files, lists of files and just about anything else about files.
 *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

STATIC_FUNC int fmBFLinternal(void **pData,
							int *pCnt,
							LPCTSTR pszName,
							int nSubdir,
							LPCTSTR pszDirectory);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CreateFilesDirsHdl
 *
 * DESCRIPTION:
 *	This function is called to create the files and directory handle.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	A pointer to the HFILES handle.
 */
HFILES CreateFilesDirsHdl(const HSESSION hSession)
	{
	FD_DATA *pFD;
	int nRet;

	pFD = (FD_DATA *)malloc(sizeof(FD_DATA));
	assert(pFD);

	if (pFD)
		{
		memset(pFD, 0, sizeof(FD_DATA));
		nRet = InitializeFilesDirsHdl(hSession, (HFILES)pFD);
		if (nRet)
			goto CFDHexit;
		}

	return (HFILES)pFD;

CFDHexit:
	if (pFD)
		{
		if (pFD->pszInternalSendDirectory)
			{
			free(pFD->pszInternalSendDirectory);
			pFD->pszInternalSendDirectory = NULL;
			}

		if (pFD->pszTransferSendDirectory)
			{
			free(pFD->pszTransferSendDirectory);
			pFD->pszTransferSendDirectory = NULL;
			}

		if (pFD->pszInternalRecvDirectory)
			{
			free(pFD->pszInternalRecvDirectory);
			pFD->pszInternalRecvDirectory = NULL;
			}

		if (pFD->pszTransferRecvDirectory)
			{
			free(pFD->pszTransferRecvDirectory);
			pFD->pszTransferRecvDirectory = NULL;
			}

		free(pFD);
		pFD = NULL;
		}
	return (HFILES)0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	InitializeFilesDirs
 *
 * DESCRIPTION:
 *	This function is called to put the files and directorys handle into a
 *	known and safe state.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	hFile    -- the files and directory handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
INT InitializeFilesDirsHdl(const HSESSION hSession, HFILES hFile)
	{
	FD_DATA *pFD;
	LPTSTR pszSname;
	LPTSTR pszRname;
	int nSize;
	TCHAR acDir[FNAME_LEN];

	pFD = (FD_DATA *)hFile;
	assert(pFD);

	pszSname = pszRname = (LPTSTR)0;

	if (pFD)
		{
		if (pFD->pszInternalSendDirectory)
			{
			free(pFD->pszInternalSendDirectory);
			pFD->pszInternalSendDirectory = NULL;
			}

		if (pFD->pszTransferSendDirectory)
            {
			free(pFD->pszTransferSendDirectory);
		    pFD->pszTransferSendDirectory = (LPTSTR)0;
            }

		if (pFD->pszInternalRecvDirectory)
			{
			free(pFD->pszInternalRecvDirectory);
			pFD->pszInternalRecvDirectory = NULL;
			}

		if (pFD->pszTransferRecvDirectory)
            {
			free(pFD->pszTransferRecvDirectory);
		    pFD->pszTransferRecvDirectory = (LPTSTR)0;
            }

	    memset(pFD, 0, sizeof(FD_DATA));

        pFD->hSession = hSession;

		//Changed to use working path rather than current path - mpt 8-18-99
		if ( !GetWorkingDirectory( acDir, FNAME_LEN ) )
			{
			GetCurrentDirectory(FNAME_LEN, acDir);
			}

		nSize = StrCharGetByteCount(acDir) + sizeof(TCHAR);

		pszSname = malloc(nSize);
		if (pszSname == (LPTSTR)0)
			goto IFDexit;
		pszRname = malloc(nSize);
		if (pszRname == (LPTSTR)0)
			goto IFDexit;

		if (pFD->pszInternalSendDirectory)
			{
			free(pFD->pszInternalSendDirectory);
			pFD->pszInternalSendDirectory = NULL;
			}
		pFD->pszInternalSendDirectory = pszSname;
		StrCharCopyN(pFD->pszInternalSendDirectory, acDir, nSize);

		if (pFD->pszTransferSendDirectory)
            {
			free(pFD->pszTransferSendDirectory);
		    pFD->pszTransferSendDirectory = (LPTSTR)0;
            }

		if (pFD->pszInternalRecvDirectory)
			{
			free(pFD->pszInternalRecvDirectory);
			pFD->pszInternalRecvDirectory = NULL;
			}
		pFD->pszInternalRecvDirectory = pszRname;
		StrCharCopyN(pFD->pszInternalRecvDirectory, acDir, nSize);

		if (pFD->pszTransferRecvDirectory)
            {
			free(pFD->pszTransferRecvDirectory);
		    pFD->pszTransferRecvDirectory = (LPTSTR)0;
            }
		}

	return 0;

IFDexit:
	if (pszSname)
		{
		free(pszSname);
		pszSname = NULL;
		}
	if (pszRname)
		{
		free(pszRname);
		pszRname = NULL;
		}

	return FM_ERR_NO_MEM;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	LoadFilesDirs
 *
 * DESCRIPTION:
 *	This function is called to read whatever values are in the session file
 *	into the files and directorys handle
 *
 * PARAMETERS:
 *	hFile -- the files and directory handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
INT LoadFilesDirsHdl(HFILES hFile)
	{
	INT nRet = 0;
	FD_DATA *pFD;
	long lSize;
	LPTSTR pszStr;

	pFD = (FD_DATA *)hFile;
	assert(pFD);
	if (pFD == (FD_DATA *)0)
		return FM_ERR_BAD_HANDLE;

	InitializeFilesDirsHdl(pFD->hSession, hFile);

	if (nRet == 0)
		{
		lSize = 0;
		sfGetSessionItem(sessQuerySysFileHdl(pFD->hSession),
						SFID_XFR_SEND_DIR,
						&lSize,
						NULL);
		if (lSize != 0)
			{
			pszStr = (LPTSTR)malloc(lSize);
			if (pszStr)
				{
				sfGetSessionItem(sessQuerySysFileHdl(pFD->hSession),
								SFID_XFR_SEND_DIR,
								&lSize,
								pszStr);
				if (pFD->pszTransferSendDirectory)
					{
					free(pFD->pszTransferSendDirectory);
					pFD->pszTransferSendDirectory = NULL;
					}
				pFD->pszTransferSendDirectory = pszStr;
				}
			else
				{
				nRet = FM_ERR_NO_MEM;
				}
			}
		}

	if (nRet == 0)
		{
		lSize = 0;
		sfGetSessionItem(sessQuerySysFileHdl(pFD->hSession),
						SFID_XFR_RECV_DIR,
						&lSize,
						NULL);
		if (lSize != 0)
			{
			pszStr = (LPTSTR)malloc(lSize);
			if (pszStr)
				{
				sfGetSessionItem(sessQuerySysFileHdl(pFD->hSession),
								SFID_XFR_RECV_DIR,
								&lSize,
								pszStr);
				if (pFD->pszTransferRecvDirectory)
					{
					free(pFD->pszTransferRecvDirectory);
					pFD->pszTransferRecvDirectory = NULL;
					}
				pFD->pszTransferRecvDirectory = pszStr;
				}
			else
				{
				nRet = FM_ERR_NO_MEM;
				}
			}
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	DestroyFilesDirsHdl
 *
 * DESCRIPTION:
 *	This function is called to free all the memory that is in a Files and
 *	Directorys handle.  Gone.  History.  Toast.
 *
 * PARAMETERS:
 *	hFile -- the files and directorys handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
INT DestroyFilesDirsHdl(const HFILES hFile)
	{
	INT nRet = 0;
	FD_DATA *pFD;

	pFD = (FD_DATA *)hFile;
	assert(pFD);
	if (pFD == (FD_DATA *)0)
		return FM_ERR_BAD_HANDLE;

	if (pFD->pszInternalSendDirectory)
		{
		free(pFD->pszInternalSendDirectory);
		pFD->pszInternalSendDirectory = NULL;
		}
	if (pFD->pszTransferSendDirectory)
		{
		free(pFD->pszTransferSendDirectory);
		pFD->pszTransferSendDirectory = NULL;
		}
	if (pFD->pszInternalRecvDirectory)
		{
		free(pFD->pszInternalRecvDirectory);
		pFD->pszInternalRecvDirectory = NULL;
		}
	if (pFD->pszTransferRecvDirectory)
		{
		free(pFD->pszTransferRecvDirectory);
		pFD->pszTransferRecvDirectory = NULL;
		}
	free(pFD);
	pFD = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SaveFilesDirsHdl
 *
 * DESCRIPTION:
 *	This function is called to save out to the session file all of the data
 *	that has changed in the Files and Directorys handle.
 *
 * PARAMETERS:
 *	hFile -- the files and directorys handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
INT SaveFilesDirsHdl(const HFILES hFile)
	{
	FD_DATA *pFD;
	long lSize;

	pFD = (FD_DATA *)hFile;
	assert(pFD);
	if (pFD == (FD_DATA *)0)
		return FM_ERR_BAD_HANDLE;

	if (pFD->pszTransferSendDirectory)
		{
		lSize = StrCharGetByteCount(pFD->pszTransferSendDirectory) + 1;
		sfPutSessionItem(sessQuerySysFileHdl(pFD->hSession),
						SFID_XFR_SEND_DIR,
						lSize,
						pFD->pszTransferSendDirectory);
		}

	if (pFD->pszTransferRecvDirectory)
		{
		lSize = StrCharGetByteCount(pFD->pszTransferRecvDirectory) + 1;
		sfPutSessionItem(sessQuerySysFileHdl(pFD->hSession),
						SFID_XFR_RECV_DIR,
						lSize,
						pFD->pszTransferRecvDirectory);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	filesQuerySendDirectory
 *
 * DESCRIPTION:
 *	This function returns a pointer to the current default transfer send
 *	directory.
 *
 * PARAMETERS:
 *	hFile -- the files and directorys handle
 *
 * RETURNS:
 *	A pointer to the current default transfer send directory
 *
 */
LPCTSTR filesQuerySendDirectory(HFILES hFile)
	{
	FD_DATA *pFD;

	pFD = (FD_DATA *)hFile;
	assert(pFD);
	assert(pFD->pszInternalSendDirectory);

	if (pFD->pszTransferSendDirectory == (LPTSTR)0)
		return (LPCTSTR)pFD->pszInternalSendDirectory;

	if (StrCharGetStrLength(pFD->pszTransferSendDirectory) == 0)
		return (LPCTSTR)pFD->pszInternalSendDirectory;

	return (LPCTSTR)pFD->pszTransferSendDirectory;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	filesQueryRecvDirectory
 *
 * DESCRIPTION:
 *	This function returns a pointer to the current default transfer recv
 *	directory.
 *
 * PARAMETERS:
 *	hFile -- the files and directorys handle
 *
 * RETURNS:
 *	A pointer to the current default recv directory
 *
 */
LPCTSTR filesQueryRecvDirectory(HFILES hFile)
	{
	FD_DATA *pFD;

	pFD = (FD_DATA *)hFile;
	assert(pFD);
	assert(pFD->pszInternalRecvDirectory);

	if (pFD->pszTransferRecvDirectory == (LPTSTR)0)
		return (LPCTSTR)pFD->pszInternalRecvDirectory;

	if (StrCharGetStrLength(pFD->pszTransferRecvDirectory) == 0)
		return (LPCTSTR)pFD->pszInternalRecvDirectory;

	return (LPCTSTR)pFD->pszTransferRecvDirectory;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	filesSetSendDirectory
 *
 * DESCRIPTION:
 *	This function is called to change (maybe) the current default sending
 *	directory.
 *
 * PARAMETERS:
 *	hFile       -- the files and directorys handle
 *	pszDir      -- pointer to the new directory path
 *
 * RETURNS:
 *	Nothing.
 *
 */
VOID filesSetSendDirectory(HFILES hFile, LPCTSTR pszDir)
	{
	LPTSTR		pszTmp;
	FD_DATA		*pFD;
	int			pszTmpLen;

	pFD = (FD_DATA *)hFile;
	assert(pFD);

	pszTmpLen = StrCharGetByteCount(pszDir) + 1;
	pszTmp = (LPTSTR)malloc(pszTmpLen);
	assert(pszTmp);
	if (pszTmp == NULL)
		return;
	StrCharCopyN(pszTmp, pszDir, pszTmpLen);
	if (pFD->pszTransferSendDirectory)
		{
		free(pFD->pszTransferSendDirectory);
		pFD->pszTransferSendDirectory = NULL;
		}
	pFD->pszTransferSendDirectory = pszTmp;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	filesSetRecvDirectory
 *
 * DESCRIPTION:
 *	This function is called to change (maybe) the current default receiving
 *	directory.
 *
 * PARAMETERS:
 *	hFile       -- the files and directorys handle
 *	pszDir      -- pointer to the new directory path
 *
 * RETURNS:
 *	Nothing.
 *
 */
VOID filesSetRecvDirectory(HFILES hFile, LPCTSTR pszDir)
	{
	LPTSTR		pszTmp;
	FD_DATA		*pFD;
	int			pszTmpLen;

	pFD = (FD_DATA *)hFile;
	assert(pFD);

	pszTmpLen = StrCharGetByteCount(pszDir) + 1;
	pszTmp = (LPTSTR)malloc(pszTmpLen);
	assert(pszTmp);
	if (pszTmp == NULL)
		return;
	StrCharCopyN(pszTmp, pszDir, pszTmpLen);
	if (pFD->pszTransferRecvDirectory)
		{
		free(pFD->pszTransferRecvDirectory);
		pFD->pszTransferRecvDirectory = NULL;
		}
	pFD->pszTransferRecvDirectory = pszTmp;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fileBuildFileList
 *
 * DESCRIPTION:
 *	This function is called to build a list of all the files that match
 *	a given mask.
 *
 * PARAMETERS:
 *	pData        -- pointer to where to store the pointer to the data block
 *	pCnt         -- pointer to where the item count is returned
 *	pszName      -- file name mask used to build list
 *	nSubdir      -- if TRUE, search subdirectorys
 *	pszDirectory -- directory to start search from
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code
 *
 */
int fileBuildFileList(void **pData,
					int *pCnt,
					LPCTSTR pszName,
					int nSubdir,
					LPCTSTR pszDirectory)
	{
	int nRet = 0;
	void *pLocalData = NULL;
	int nLocalCnt = 0;
	LPTSTR pszStr;
	LPTSTR *pszArray;
	TCHAR pszLocalDirectory[FNAME_LEN];

	/* Make sure the directory string terminates correctly */
	StrCharCopyN(pszLocalDirectory, pszDirectory, FNAME_LEN);

	pszStr = StrCharLast(pszLocalDirectory);
	if (*pszStr != TEXT('\\'))
		{
		/* Make sure the last character is a "\" */
		StrCharCat(pszStr, TEXT("\\"));
		}

	pLocalData = malloc(sizeof(LPTSTR) * FM_CHUNK_SIZE);
	if (pLocalData == NULL)
		nRet = FM_ERR_NO_MEM;

	if (nRet == 0)
		{
		nRet = fmBFLinternal(&pLocalData,
							&nLocalCnt,
							pszName,
							nSubdir,
							pszLocalDirectory);
		}

	if (nRet == 0)
		{
		/* OK, no problem */
		*pData = pLocalData;
		*pCnt = nLocalCnt;
		}
	else
		{
		/* Error, clean up first and then go away */
		if (pLocalData)
			{
			pszArray = (LPTSTR *)pLocalData;
			while (--nLocalCnt >= 0)
				{
				free(*pszArray++);
				*pszArray = NULL;
				}
			free(pLocalData);
			pLocalData = NULL;
			}
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fmBFLinternal
 *
 * DESCRIPTION:
 *	This is the internal function that the previous function calls to do the
 *	actual work.
 *
 * PARAMETERS:
 *	The same as above.
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code
 *
 */
STATIC_FUNC int fmBFLinternal(void **pData,
							int *pCnt,
							LPCTSTR pszName,
							int nSubdir,
							LPCTSTR pszDirectory)
	{
	int nRet = 0;
	int nSize;
	WIN32_FIND_DATA stF;
	HANDLE sH = INVALID_HANDLE_VALUE;
	LPTSTR pszBuildName;
	LPTSTR pszStr;
	LPTSTR *pszArray;

	pszBuildName = (LPTSTR)malloc(FNAME_LEN * sizeof(TCHAR));
	if (pszBuildName == NULL)
		{
		nRet = FM_ERR_NO_MEM;
		goto fmBFLexit;
		}

	StrCharCopyN(pszBuildName, pszDirectory, FNAME_LEN);
	StrCharCat(pszBuildName, pszName);

	sH = FindFirstFile(pszBuildName, &stF);
	if (sH != INVALID_HANDLE_VALUE)
		{
		/* Handle is OK, we have something to work on */
		do {
			/* Is it a directory ?  If it is, skip it until later */
			if (stF.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				continue;
			/* Must be a file. */
			if (stF.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
				continue;
			if (stF.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
				continue;
			/* Add the file to the list */
			if ((*pCnt > 0) && ((*pCnt % FM_CHUNK_SIZE) == 0))
				{
				TCHAR* pTemppData = *pData;

				/* realloc the chunk */
				nSize = *pCnt + FM_CHUNK_SIZE;
				pTemppData = (TCHAR*)realloc(*pData, nSize * sizeof(LPTSTR) );
				if (pTemppData == NULL)
					{
					nRet = FM_ERR_NO_MEM;
					goto fmBFLexit;
					}
				else
					{
					*pData = pTemppData;
					}
				}
			nSize = StrCharGetByteCount(pszDirectory) +
					StrCharGetByteCount(stF.cFileName);
			nSize += 1;
			nSize *= sizeof(TCHAR);
			pszStr = (LPTSTR)malloc(nSize);
			if (pszStr == (LPTSTR)0)
				{
				nRet = FM_ERR_NO_MEM;
				goto fmBFLexit;
				}
			StrCharCopyN(pszStr, pszDirectory, nSize);
			StrCharCat(pszStr, stF.cFileName);
			pszArray = (LPTSTR *)*pData;
			pszArray[*pCnt] = pszStr;
			*pCnt += 1;
		} while (FindNextFile(sH, &stF));
		FindClose(sH);
		sH = INVALID_HANDLE_VALUE;
		}
	else
		{
		nRet = FM_ERR_BAD_HANDLE;
		goto fmBFLexit;
		}

	if (nSubdir)
		{
		StrCharCopyN(pszBuildName, pszDirectory, FNAME_LEN);
		StrCharCat(pszBuildName, TEXT("*.*"));	/* This may need to change */
		sH = FindFirstFile(pszBuildName, &stF);
		if (sH != INVALID_HANDLE_VALUE)
			{
			/* Handle is OK, we have something to work on */
			do {
				/* Is it a directory ?  If it is, go recursive */
				if (stF.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					{
					if (StrCharCmp(stF.cFileName, TEXT(".")) == 0)
						continue;
					if (StrCharCmp(stF.cFileName, TEXT("..")) == 0)
						continue;
					StrCharCopyN(pszBuildName, pszDirectory, FNAME_LEN);
					StrCharCat(pszBuildName, stF.cFileName);
					StrCharCat(pszBuildName, TEXT("\\"));
					fmBFLinternal(pData,
								pCnt,
								pszName,
								nSubdir,
								pszBuildName);
					}
			} while (FindNextFile(sH, &stF));
			FindClose(sH);
			sH = INVALID_HANDLE_VALUE;
			}
		else
			{
			nRet = FM_ERR_BAD_HANDLE;
			goto fmBFLexit;
			}
		}

fmBFLexit:
	/* NOTE: all returns must come thru here */
	if (sH != INVALID_HANDLE_VALUE)
		FindClose(sH);

	if (pszBuildName)
		{
		free(pszBuildName);
		pszBuildName = NULL;
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fileFinalizeName
 *
 * DESCRIPTION:
 *	This function takes a possibly incomplete file name and trys to convert
 *	it to a fully qualified name, if possible, based upon the mode request.
 *
 * PARAMETERS:
 *	hSession	--	the almost universal session handle
 *	pszOldname	--	a pointer to the old name string
 *  pszOlddir	--	a pointer to an optional path
 *	pszNewname	--	a pointer to where the new string should go
 *	nMode		--	what should be done to the string, currently ignored
 *
 * RETURNS:
 *	TRUE if a conversion was completed and copied, FALSE if nothing was copied.
 */

int fileFinalizeName(LPTSTR pszOldname,
					LPTSTR pszOlddir,
					LPTSTR pszNewname,
					const size_t cb)
	{
	TCHAR *pachFile;
	TCHAR achCurDir[MAX_PATH];

	assert(cb);
	assert(pszNewname);
	assert(pszOldname);
	achCurDir[0] = TEXT('\0');

	// If we're given a directory, save the current directory and
	// set the current directory to the one given.
	//
	if (pszOlddir && *pszOlddir != TEXT('\0'))
		{
		if (GetCurrentDirectory(sizeof(achCurDir), achCurDir) == 0)
			{
			assert(0);
			return FALSE;
			}

		if (SetCurrentDirectory(pszOlddir) == FALSE)
			{
			assert(0);
			return FALSE;
			}
		}

	// This function does the correct job of building a full path
	// name and works with UNC names.
	//
	if (GetFullPathName(pszOldname, cb, pszNewname, &pachFile) == 0)
		{
		assert(0);
		return FALSE;
		}

	// Restore the current directory we saved above.
	//
	if (achCurDir[0] != TEXT('\0'))
		{
		if (SetCurrentDirectory(achCurDir) == FALSE)
			{
			assert (0);
			return FALSE;
			}
		}

	return TRUE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 * FUNCTION:
 *	mfFinalizeDIR
 *
 * DESCRIPTION:
 *	This function is called to clean up a directory name.  At the present time
 *	it doesn't do very much.
 *
 * PARAMETERS:
 *	hSession	--	the almost universal session handle
 *	pszOldname	--	a pointer to the old directory name
 *	pszNewname	--	a pointer to where the new string should go
 *
 * RETURNS:
 *	TRUE if a copy was completed, FALSE if nothing was copied.
 */
int fileFinalizeDIR(HSESSION hSession,
					LPTSTR pszOldname,
					LPTSTR pszNewname)
	{
	LPTSTR pszPtr;
	LPTSTR pszFoo;


	StrCharCopyN(pszNewname, pszOldname, FNAME_LEN);
	pszPtr = StrCharNext(pszNewname);
	pszFoo = StrCharNext(pszPtr);

	if ((StrCharGetStrLength(pszNewname) == 2) &&
		(*pszPtr == TEXT(':')))
		{
		StrCharCat(pszNewname, TEXT("\\"));
		}
	else if ((StrCharGetStrLength(pszNewname) == 3) &&
			(*pszPtr == TEXT(':')) &&
			(*pszFoo == TEXT('\\')))
		{
		/* Do nothing */
		}
	else
		{
		pszPtr = StrCharLast(pszNewname);
		if (*pszPtr == TEXT('\\'))
			*pszPtr = TEXT('\0');
		}

	return 1;
	}

#if defined(BMP_FROM_FILE)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	fileReadBitmapFromFile
 *
 * DESCRIPTION:
 *	This function takes a filename, opens the file and attempts to interpret
 *	the file as a bitmap file, turning it into a bitmap.
 *
 * PARAMETERS:
 *	hDC     -- device context used to create the bitmap
 *	pszName	-- the name of the file
 *
 * RETURNS:
 *	A bitmap handle or NULL.
 *
 */
HBITMAP fileReadBitmapFromFile(HDC hDC, LPTSTR pszName, int fCmp)
	{
	HBITMAP hBmp = (HBITMAP)0;
	DWORD dwRead;
	DWORD dwSize;
	HANDLE hfbm;
	int hcbm;
	OFSTRUCT stOF;
	BITMAPFILEHEADER bmfh;
	BITMAPINFOHEADER bmih;
	BITMAPINFO *lpbmi;
	VOID *lpvBits;

	lpbmi = NULL;
	lpvBits = NULL;

	if (fCmp)
		{
		memset(&stOF, 0, sizeof(OFSTRUCT));

		stOF.cBytes = sizeof(OFSTRUCT);

		hcbm = LZOpenFile(pszName,
						&stOF,
						OF_READ);
		if (hcbm < 0)
			return hBmp;
		}
	else
		{
		hfbm = CreateFile(pszName,
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						FILE_ATTRIBUTE_READONLY,
						NULL);
		if (hfbm == INVALID_HANDLE_VALUE)
			return hBmp;
		}

	/* Retrieve the BITMAPFILEHEADER structure */
	memset(&bmfh, 0, sizeof(BITMAPFILEHEADER));
	if (fCmp)
		{
		dwRead = 0;
		dwRead = LZRead(hcbm,
						(unsigned char *)&bmfh,
						sizeof(BITMAPFILEHEADER));
		/* this is necessary because of a garbage return value */
		dwRead = sizeof(BITMAPFILEHEADER);
		}
	else
		{
		ReadFile(hfbm,
				&bmfh,
				sizeof(BITMAPFILEHEADER),
				&dwRead,
				NULL);
		}
	if (dwRead != sizeof(BITMAPFILEHEADER))
		goto fError;

	/* Retrieve the BITMAPINFOHEADER structure */
	memset(&bmih, 0, sizeof(BITMAPINFOHEADER));
	if (fCmp)
		{
		dwRead = 0;
		dwRead = LZRead(hcbm,
						(unsigned char *)&bmih,
						sizeof(BITMAPINFOHEADER));
		/* this is necessary because of a garbage return value */
		dwRead = sizeof(BITMAPINFOHEADER);
		}
	else
		{
		ReadFile(hfbm,
				&bmih,
				sizeof(BITMAPINFOHEADER),
				&dwRead,
				NULL);
		}
	if (dwRead != sizeof(BITMAPINFOHEADER))
		goto fError;

	/* allocate space for the BITMAPINFO structure */
	dwSize = sizeof(BITMAPINFOHEADER) +
				((1 << bmih.biBitCount) * sizeof(RGBQUAD));

	lpbmi = malloc(dwSize);
	if (lpbmi == NULL)
		goto fError;

	/* load BITMAPINFOHEADER into the BITMAPINFO structure */
	lpbmi->bmiHeader.biSize = bmih.biSize;
	lpbmi->bmiHeader.biWidth = bmih.biWidth;
	lpbmi->bmiHeader.biHeight = bmih.biHeight;
	lpbmi->bmiHeader.biPlanes = bmih.biPlanes;
	lpbmi->bmiHeader.biBitCount = bmih.biBitCount;
	lpbmi->bmiHeader.biCompression = bmih.biCompression;
	lpbmi->bmiHeader.biSizeImage = bmih.biSizeImage;
	lpbmi->bmiHeader.biXPelsPerMeter = bmih.biXPelsPerMeter;
	lpbmi->bmiHeader.biYPelsPerMeter = bmih.biYPelsPerMeter;
	lpbmi->bmiHeader.biClrUsed = bmih.biClrUsed;
	lpbmi->bmiHeader.biClrImportant = bmih.biClrImportant;

	/* read the color table */
	dwSize = (1 << bmih.biBitCount) * sizeof(RGBQUAD);
	if (fCmp)
		{
		dwRead = 0;
		dwRead = LZRead(hcbm,
						(unsigned char *)lpbmi->bmiColors,
						dwSize);
		/* this is necessary because of a garbage return value */
		dwRead = dwSize;
		}
	else
		{
		ReadFile(hfbm,
				lpbmi->bmiColors,
				dwSize,
				&dwRead,
				NULL);
		}
	if (dwSize != dwRead)
		goto fError;

	/* allocate memory for the bitmap data */
	dwSize = bmfh.bfSize - bmfh.bfOffBits;
	lpvBits = malloc(dwSize);
	if (lpvBits == NULL)
		goto fError;

	/* read in the bitmap data */
	if (fCmp)
		{
		dwRead = 0;
		dwRead = LZRead(hcbm,
						lpvBits,
						dwSize);
		/* this is necessary because of a garbage return value */
		dwRead = dwSize;
		}
	else
		{
		ReadFile(hfbm,
				lpvBits,
				dwSize,
				&dwRead,
				NULL);
		}
	if (dwSize != dwRead)
		goto fError;

	/* create the bitmap handle */
	hBmp = CreateDIBitmap(hDC,
						&bmih,
						CBM_INIT,
						lpvBits,
						lpbmi,
						DIB_RGB_COLORS);

	/* either it worked or it didn't */

fError:
	/* Clean up everything here */

	if (lpbmi != NULL)
		{
		free(lpbmi);
		lpbmi = NULL;
		}

	if (lpvBits != NULL)
		{
		free(lpvBits);
		lpvBits = NULL;
		}

	if (fCmp)
		{
		LZClose(hcbm);
		}
	else
		{
		CloseHandle(hfbm);
		}

	return hBmp;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION: GetFileSizeFromName
 *
 * DESCRIPTION:
 *	Returns the size of a named file. (The GetFileSize Win32 API call
 *	requires the file to be open, this doesn't).
 *	Note: the WIN32 API is structured to support 64 bits file size values
 *		  so this may need to be updated at some point.
 *
 * PARAMETERS:
 *	pszName -- the name of the file.
 *	pulFileSize -- Pointer to the var. that receives the file size.
 *				   (If NULL, this function can be used to test for the
 *					existense of a file).
 *
 * RETURNS:
 *	TRUE if file is found, FALSE if not
 */
int GetFileSizeFromName(TCHAR *pszName, unsigned long * const pulFileSize)
	{
	WIN32_FIND_DATA stFData;
	HANDLE hFind;
	int fReturnValue = FALSE;

	hFind = FindFirstFile(pszName, &stFData);
	if (hFind != INVALID_HANDLE_VALUE)
		{
		DWORD dwMask;

		/* This is just a guess.  If you need to change it, do so. */
		dwMask = FILE_ATTRIBUTE_DIRECTORY |
				 FILE_ATTRIBUTE_HIDDEN |
				 FILE_ATTRIBUTE_SYSTEM;

		if ((stFData.dwFileAttributes & dwMask) == 0)
			{
			fReturnValue = TRUE;
			// Strictly speaking, file sizes can now be 64 bits.
			assert(stFData.nFileSizeHigh == 0);
			if (pulFileSize)
				*pulFileSize = (unsigned long)stFData.nFileSizeLow;
			}
		FindClose(hFind);
		}
	return fReturnValue;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SetFileSize
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int SetFileSize(const TCHAR *pszName, unsigned long ulFileSize)
    {
	HANDLE hFile;
    int     nRet = -1;

	/* Yes, we need to open the file */
	hFile = CreateFile(pszName,
						GENERIC_WRITE,
						FILE_SHARE_WRITE,
						0,
						OPEN_EXISTING,
						0,
						0);
	if (hFile == INVALID_HANDLE_VALUE)
		return -1;								/* No such file */

    if (SetFilePointer(hFile, ulFileSize, NULL, FILE_BEGIN) == ulFileSize)
        {
        if (SetEndOfFile(hFile))
            nRet = 0;
        }

    CloseHandle(hFile);

    return nRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 * ValidateFileName
 *
 * DESCRIPTION:
 * Determine whether a file pathname is valid by attempting to open it.
 *
 * PARAMETERS:
 * 
 *      LPSTR pszName   -  the name/pathname
 *
 * RETURNS:
 *
 *		0,  if a file with the specified name could not be opened/created,
 *      1,  if it could.
 *
 */
int  ValidateFileName(LPSTR pszName)
	{
	HANDLE  hfile = 0;


	if (GetFileSizeFromName(pszName, NULL))
		{
	    hfile = CreateFile(pszName,
							GENERIC_READ,
							FILE_SHARE_WRITE,
							NULL,
							OPEN_EXISTING,
							0,
							NULL);
		}
	else
		{
	    hfile = CreateFile(pszName,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							CREATE_NEW,
							FILE_FLAG_DELETE_ON_CLOSE,
							NULL);
		}

	if(hfile != INVALID_HANDLE_VALUE)
		{
		CloseHandle(hfile);
		return(1);
		}
	else
		{
		return(0);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\genrcdlg.c ===
/*	File: C:\WACKER\TDLL\genrcdlg.c (Created: 16-Dec-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 5/09/01 4:40p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "mc.h"

#include "misc.h"
#include "globals.h"
#include "hlptable.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	int	nDummyVariable;
	/*
	 * Put in whatever else you might need to access later
	 */
	};

typedef	struct stSaveDlgStuff SDS;

// Dialog control defines...
//
#define IDC_CB_
#define IDC_RB_
#define IDC_PB_

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	Generic Dialog
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
BOOL CALLBACK GenericDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;
	static  aHlpTable[] = {0,0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			break;
			}

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		break;

	case WM_DESTROY:
		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/*
			 * Do whatever saving is necessary
			 */

			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\globals.h ===
/*	File: D:\WACKER\tdll\globals.h (Created: 26-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:41p $
 */

#if !defined(INCL_GLOBALS)
#define INCL_GLOBALS

/* --- Functions to set and query global paramaters. --- */

LPTSTR    glblQueryHelpFileName(void);
void      glblSetHelpFileName(void);

HINSTANCE glblQueryHinst(void);
void	  glblSetHinst(const HINSTANCE hInst);

HINSTANCE glblQueryDllHinst(void);
void	  glblSetDllHinst(const HINSTANCE hInst);

void	  glblSetAccelHdl(const HACCEL hAccelerator);
HACCEL	  glblQueryAccelHdl(void);

void	  glblSetHwndFrame(const HWND hwnd);
HWND	  glblQueryHwndFrame(void);

int 	  glblAddModelessDlgHwnd(const HWND hwnd);
int 	  glblDeleteModelessDlgHwnd(const HWND hwnd);

int       glblQueryProgramStatus(void);
int       glblSetProgramStatus(int nStatus);

HWND	  glblQueryHwndBanner(void);
void	  glblSetHwndBanner(const HWND hwnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\fontdlg.c ===
/*	File: D:\WACKER\tdll\fontdlg.c (Created: 14-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/28/02 9:37a $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "globals.h"
#include "print.hh"
#include "session.h"
#include "misc.h"
#include "term.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DisplayFontDialog
 *
 * DESCRIPTION:
 *	Invokes the common dialog box for font selection.
 *
 * ARGUMENTS:
 *	HWND	hwnd	- handle to parent dialog window.
 *
 * RETURNS:
 *	void
 *
 */
void DisplayFontDialog(const HSESSION hSession, BOOL fPrinterFont )
	{
	LOGFONT 	lf, lfOld;

	CHOOSEFONT 	chf;
	BOOL 		fRet;

	const HWND 	hwnd     = sessQueryHwnd(hSession);
    HHPRINT     hhPrint  = (HHPRINT) sessQueryPrintHdl(hSession);

    //
    // setup font structure
    //
	ZeroMemory(&chf, sizeof(CHOOSEFONT));

	chf.lStructSize = sizeof(CHOOSEFONT);
	chf.hwndOwner   = hwnd;
	chf.lpLogFont   = &lf;
	chf.rgbColors   = RGB(0, 0, 0);
	chf.lCustData   = 0;
	chf.hInstance   = glblQueryHinst();
	chf.lpszStyle   = (LPTSTR)0;
	chf.nSizeMin    = 1;
	chf.nSizeMax    = 469; // Largest that will still display. REV: 3/28/2002
	chf.Flags       = CF_NOVERTFONTS | CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;

    //
    // set up for terminal font selection
    //

    if ( !fPrinterFont )
        {
	    SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_GETLOGFONT, 0,
                   (LPARAM)&lf);

		chf.nFontType   = SCREEN_FONTTYPE;
	    chf.hDC         = GetDC(hwnd);
        chf.Flags       |= CF_SCREENFONTS | CF_FIXEDPITCHONLY;

    	lfOld = lf;
	    fRet = ChooseFont(&chf);
    	ReleaseDC(hwnd, chf.hDC);
        }
    
    //
    // set up for printer font selection
    //

    else
        {
        hhPrint->hDC = printCtrlCreateDC((HPRINT)hhPrint);
        
        lf = hhPrint->lf;

		chf.nFontType   = PRINTER_FONTTYPE;
        chf.hDC         = hhPrint->hDC;
	    chf.Flags       |= CF_EFFECTS | CF_PRINTERFONTS;

    	lfOld = lf;
	    fRet = ChooseFont(&chf);
        }

    // 
    // Save any changes that were made
    //

	if (fRet && memcmp(&lf, &lfOld, sizeof(LOGFONT)) != 0)
		{
		const HWND hwndTerm = sessQueryHwndTerminal(hSession);

        if ( !fPrinterFont )
	        {
        	SendMessage(hwndTerm, WM_TERM_SETLOGFONT, 0, (LPARAM)&lf);
    		RefreshTermWindow(hwndTerm);
            }
        else
            {
            //
            // save the dialog returned log font in the print handle and also 
            // save the selected point size.  This is done since the font point
            // size returned by the dialog is is not correct when used for 
            // printing.  However the dialog settings must be saved for the 
            // next time the dialog is displayed.  The correct font is calculated
            // based on the save point size and face name before printing by the 
            // printCreatePointFont function.
            //

            hhPrint->iFontPointSize = chf.iPointSize;
            hhPrint->lf = lf; 
  
            lf.lfHeight = chf.iPointSize;

            //
            // if char set is ansi change to oem to get line draw characters
            //
        
            if ( lf.lfCharSet == ANSI_CHARSET )
                {
                lf.lfCharSet = OEM_CHARSET;
                }
            }

        //
        // get rid of the printer device context if one was created
        //

        if ( fPrinterFont )
            {
            printCtrlDeleteDC((HPRINT)hhPrint);
            }
		}
	
    return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\getchar.c ===
/*	File: D:\WACKER\tdll\getchar.c (Created: 30-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 3/14/02 3:45p $
 */

#include <windows.h>
#pragma hdrstop

//#define DEBUGSTR
#include <time.h>
#include <stdio.h>
#include "stdtyp.h"
#include "globals.h"
#include "session.h"
#include "term.h"
#include "chars.h"
#include "assert.h"
#include "statusbr.h"
#include "cloop.h"
#include "cnct.h"
#include "htchar.h"
#if defined(INCL_KEY_MACROS)
#include "keyutil.h"
#endif
#include <emu\emu.h>
#include <term\res.h>

static BOOL WackerKeys(const KEY_T Key);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TranslateToKey
 *
 * DESCRIPTION:
 *	Translates a key into our internal format.	Waits for the WM_CHAR if
 *	windows is going to translate the key by checking the message queue.
 *
 * ARGUMENTS:
 *	hSession	- external session handle
 *	pmsg		- pointer to message
 *
 * RETURNS:
 *	Internal key value if translated, otherwise 0.
 *
 */
KEY_T TranslateToKey(const LPMSG pmsg)
	{
	KEY_T	 Key = 0;

	switch (pmsg->message)
		{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		switch (pmsg->wParam)
			{
			case VK_SHIFT:
			case VK_CONTROL:
				return 0;

			case VK_MENU:
				return (KEY_T)-1;

			default:
				Key = (KEY_T)(VIRTUAL_KEY | pmsg->wParam);

				if (GetKeyState(VK_MENU) < 0)
					Key |= ALT_KEY;

				if (GetKeyState(VK_CONTROL) < 0)
					Key |= CTRL_KEY;

				if (GetKeyState(VK_SHIFT) < 0)
					Key |= SHIFT_KEY;

				if (pmsg->lParam & 0x01000000)	/* Extended, bit 24 */
					Key |= EXTENDED_KEY;

				break;
			}
		break;

	case WM_CHAR:
	case WM_SYSCHAR:
		Key = (KEY_T)pmsg->wParam;

		if (pmsg->lParam & 0x01000000)	/* Extended, bit 24 */
			Key |= EXTENDED_KEY;

		if (pmsg->lParam & 0x20000000)	/* Context, bit 29 */
			Key |= ALT_KEY;

		if (pmsg->wParam == VK_TAB)
			{
			if (GetKeyState(VK_SHIFT) < 0)
				{
				Key |= SHIFT_KEY;
				Key |= VIRTUAL_KEY;
				}
			}

		// Believe it or not CTRL+SHIFT+@ gets translated to a
		// char of 0 (zero).  So virtualize the key if it matches
		// the criteria. - mrw
		//
		if (pmsg->wParam == 0)
			{
			if (GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0)
				Key |= VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY;
			}

		break;

	default:
		break;
		}

	DbgOutStr("%x %x\r\n", Key, pmsg->message, 0, 0, 0);
	return Key;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WackerKeys
 *
 * DESCRIPTION:
 *	Handles our special global keys.
 *
 * ARGUMENTS:
 *	Key - key from TranslateToKey()
 *
 * RETURNS:
 *	TRUE if this routine acts on it, FALSE if not.
 *
 */
static BOOL WackerKeys(const KEY_T Key)
	{
	BYTE pbKeyState[256];

	switch (Key)
		{
	case VIRTUAL_KEY | VK_SCROLL:
	case VIRTUAL_KEY | SHIFT_KEY | VK_SCROLL:
	case VIRTUAL_KEY | ALT_KEY | VK_SCROLL:
	case VIRTUAL_KEY | ALT_KEY | SHIFT_KEY | VK_SCROLL:
		// In the case of scroll lock, we want to toggle to the
		// previous state.	Only when it is destined for the terminal
		// window is it processed meaning it doesn't get here.

		if(GetKeyboardState(pbKeyState))
			{
			if (GetKeyState(VK_SCROLL) & 1)
				{
				pbKeyState[VK_SCROLL] &= ~0x01;
				}
			else
				{
				pbKeyState[VK_SCROLL] |= 0x01;
				}

			SetKeyboardState(pbKeyState);
			}
		#if TODO // TODO:REV 3/1/2002 Set the ScrollLock key state when GetKeyboardState fails.
		else
			{
			SHORT lScrollKeyState = GetKeyState(VK_SCROLL);

			if (lScrollKeyState & 1)
				{
				lScrollKeyState &= ~0x01;
				}
			else
				{
				lScrollKeyState |= 0x01;
				}

			if (lScrollKeyState)
				{
				INPUT lInput;

				lInput.ki = 

				SendInput(1, lInput, sizeof(INPUT));
				}
			}
		#endif // TODO:REV 3/1/2002 
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

//******************************************************************************
// Method:
//    IsSessionMacroKey
//
// Description:
//    Determines if the specified key is a user defined macro key
//
// Arguments:
//    hSess - Session handle
//    Key   - The key to be tested
//
// Returns:
//    TRUE if the key is defined as a macro FALSE otherwise
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/10/1998
//
//

static BOOL IsSessionMacroKey(const HSESSION hSess, const KEY_T Key)
	{
#if defined INCL_KEY_MACROS
    keyMacro lKeyMacro;
    lKeyMacro.keyName = Key;

    return keysFindMacro( &lKeyMacro ) == -1 ? FALSE : TRUE;
#else
    return FALSE;
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ProcessMessage
 *
 * DESCRIPTION:
 *	Despite the apparent simplicity of this function it is any but simple.
 *	The entire functionality of the keyboard interface rests upon this
 *	function.  Handle with care!
 *
 * ARGUMENTS:
 *	pmsg	- pointer to message struct returned from GetMessage()
 *
 * RETURNS:
 *	void
 *
 */
void ProcessMessage(MSG *pmsg)
	{
	#if defined(FAR_EAST)
	static KEY_T keyLeadByte = 0;
	#endif
	KEY_T Key;

	HSESSION hSession;
	HCNCT hCnct;
	TCHAR achClassName[20];

	switch (pmsg->message)
		{
	case WM_CHAR:
		#if defined(FAR_EAST)
		hSession = (HSESSION)GetWindowLongPtr(pmsg->hwnd, 0);
		if ((IsDBCSLeadByte( (BYTE) pmsg->wParam)) && (keyLeadByte == 0))
			{
			keyLeadByte = (KEY_T)pmsg->wParam;
			return ;
			}
		else
			{
			if (keyLeadByte != 0)
				{
				Key = (KEY_T)pmsg->wParam;
				CLoopSend(sessQueryCLoopHdl(hSession), &keyLeadByte, 1, CLOOP_KEYS);
				CLoopSend(sessQueryCLoopHdl(hSession), &Key, 1, CLOOP_KEYS);
				keyLeadByte = 0;
				return ;
				}

			keyLeadByte = 0;
			}
		#endif
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_SYSCHAR:
		/* --- Translate the key to our format --- */

		Key = TranslateToKey(pmsg);

		// We need to decide if the window this message is going to is
		// a terminal window since that's the only place we do our
		// translations.  We check if the window class matches our
		// terminal class.	If so, the session handle is stored in the
		// 0 offset of the window's extra data.  This way multiple sessions
		// can be serviced from this one routine.

		if (GetClassName(pmsg->hwnd, achClassName, sizeof(achClassName)) == 0)
			break;

		if (StrCharCmp(achClassName, TERM_CLASS))
			break;

		hSession = (HSESSION)GetWindowLongPtr(pmsg->hwnd, 0);

		if (hSession == 0)
			{
			// There are certain keys we want to handle regardless of
			// their destination.

			if (WackerKeys(Key))
				return;

			break;
			}

		// We need to prevent an F1 key event from initiating
		// a connection when "emu keys" is turned on.
		//
		if (Key == (VIRTUAL_KEY | VK_F1))
			{
			hCnct = sessQueryCnctHdl(hSession);
			assert(hCnct);

			if((cnctQueryStatus(hCnct) == CNCT_STATUS_TRUE) &&
			    emuIsEmuKey(sessQueryEmuHdl(hSession), Key))
				{
				// do nothing - fall through
				}
			else
				{
				// eat it

				// We handle the F1 key event in the terminal proc
				//    (to bring up help), so we don't need to here.
				return;
				}
			}

		// The order of evaluation is important here.  Both IsMacroKey()
		// and emuIsEmuKey() know if that the message is bound for the
		// terminal.  Also emuIsEmuKey() checks if terminal keys are
		// enabled.  Evaluating messages in this order keeps us from
		// having to "disable" accelerators when the user defines macro
		// or terminal keys that conflict with accelerator keys.

		if ( IsSessionMacroKey(hSession, Key) ||
				emuIsEmuKey(sessQueryEmuHdl(hSession), Key))
			{
			// We need to modify this message to an internal message
			// for two reasons.
			//
			// 1. Menu accelerators get translated in DispatchMessage().
			//	  This seems a little strange but hey, that's windows
			//	  for ya.
			//
			// 2. It's important to know if the key was an emulator key.
			//	  The emulator's keys take precedence over window's
			//	  accelerators yet the emulator is the last guy to see
			//	  the key.	For instance, PageUp can pageup through the
			//	  backscroll execept when it is mapped to an emulator
			//	  key.	Unfortuanately, the PageUp key is interperted
			//	  by the client-terminal before being passed to the
			//	  emulator.  If we sent this as a WM_KEYDOWN or WM_CHAR
			//	  message, we would have to play it through the emulator
			//	  again to find out if it is an emulator key.

			pmsg->message = WM_TERM_KEY;
			pmsg->wParam = (WPARAM)Key;

			DbgOutStr("Session or Macro key\r\n", 0, 0, 0, 0, 0);
			DispatchMessage(pmsg);

			if (Key == (VK_NUMLOCK | VIRTUAL_KEY | EXTENDED_KEY))
				{
				static BYTE abKeyState[256];

				if (GetKeyboardState(abKeyState))
					{
					if ((GetKeyState(VK_NUMLOCK) & 1))
						{
						abKeyState[VK_NUMLOCK] &= 0xfe;
						}
					else
						{
						abKeyState[VK_NUMLOCK] |= 0x01;
						}
					SetKeyboardState(abKeyState);
					}
				#if TODO // TODO:REV 3/1/2002 Set the NumLock key state when GetKeyboardState fails.
				else
					{
					SHORT lNumLockKeyState = GetKeyState(VK_NUMLOCK);

					if (lNumLockKeyState & 1)
						{
						lNumLockKeyState &= 0xfe;
						}
					else
						{
						lNumLockKeyState |= 0x01;
						}

					if (lNumLockKeyState)
						{
						INPUT lInput;

						lInput.ki = 

						SendInput(1, lInput, sizeof(INPUT));
						}
					}
				#endif // TODO:REV 3/1/2002 
				}

			return;
			}

		else
			{
			// Win32 got this one right.  TranslateMesssage returns TRUE
			// only if it translates (ie. produces a WM_CHAR).	Win31
			// didn't do this.  If a WM_CHAR is generated, then we want
			// to eat the WM_KEYDOWN and wait for the WM_CHAR event.

			// Bug in TranslateMessage().  It returns TRUE on all
			// WM_KEYDOWN messages regardless of translation.  Reported
			// bug 1/5/93

			if (!TranslateAccelerator(glblQueryHwndFrame(),
					glblQueryAccelHdl(), pmsg))
				{
				MSG msg;

				TranslateMessage(pmsg);

				if (PeekMessage(&msg, pmsg->hwnd, WM_CHAR, WM_CHAR,
						PM_NOREMOVE) == FALSE)
					{
					DispatchMessage(pmsg);
					}
				}

			return;
			}

		default:
			break;
		}

	// Not for the terminal window? Do the normal thing...

	if (!TranslateAccelerator(glblQueryHwndFrame(), glblQueryAccelHdl(), pmsg))
		{
		TranslateMessage(pmsg);
		DispatchMessage(pmsg);
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\hlptable.c ===
/*	File: \WACKER\TDLL\hlptable.c (Created: 4-30-1998)
 *
 *	Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 5/25/99 8:55a $
 */

#include <windows.h>
#pragma hdrstop

#include "globals.h"
#include "hlptable.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	doContextHelp
 *
 * DESCRIPTION:
  *
 * ARGUMENTS:
 *
 * RETURNS:
 *	BOOL
 *
 */
void doContextHelp(const DWORD aHlpTable[], WPARAM wPar, LPARAM lPar, BOOL bContext, BOOL bForce)
    {

    if ( !bContext )
		{
		if ( isControlinHelpTable( aHlpTable, ((LPHELPINFO)lPar)->iCtrlId ) || bForce )
	        {
            if ( ((LPHELPINFO)lPar)->iCtrlId == IDOK || ((LPHELPINFO)lPar)->iCtrlId == IDCANCEL )
                {
			    WinHelp(((LPHELPINFO)lPar)->hItemHandle,
				    TEXT("windows.hlp"),
				    HELP_WM_HELP,
				    (DWORD_PTR)(LPTSTR)aHlpTable);
                }
            else
                {
			    WinHelp(((LPHELPINFO)lPar)->hItemHandle,
				    glblQueryHelpFileName(),
				    HELP_WM_HELP,
				    (DWORD_PTR)(LPTSTR)aHlpTable);
                }
			}
		}
	else
		{
		if ( isControlinHelpTable( aHlpTable, GetDlgCtrlID((HWND)wPar)) || bForce )
		    {
			if ( GetDlgCtrlID((HWND)wPar) == IDOK || GetDlgCtrlID((HWND)wPar) == IDCANCEL )
				{
				WinHelp((HWND)wPar,
					TEXT("windows.hlp"),
					HELP_CONTEXTMENU,
					(DWORD_PTR)(LPTSTR)aHlpTable);
				}
			else
				{
				if ( GetDlgCtrlID( (HWND)wPar ) )
					{
					WinHelp((HWND)wPar,
						glblQueryHelpFileName(),
						HELP_CONTEXTMENU,
						(DWORD_PTR)(LPTSTR)aHlpTable);
					}
				}
			}
		}
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	isControlinHelpTable
 *
 * DESCRIPTION:
  * Let's us decide whether or not to call WinHelp (HTMLHelp) based on
  * whether or not the specified control is matched to a help id.
  *
 * ARGUMENTS:
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL isControlinHelpTable(const DWORD aHlpTable[], const INT cntrlID)
	{
    INT nLoop;
    BOOL retval = FALSE;

    for(nLoop = 0; aHlpTable[nLoop] != (DWORD)0; nLoop++)
        {
        if ( aHlpTable[nLoop] == (DWORD)cntrlID )
            {
            retval = TRUE;
            break;
            }
        }

    return retval;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\globals.c ===
/*	File: D:\WACKER\tdll\globals.c (Created: 26-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 4/16/02 2:38p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "globals.h"
#include "assert.h"

#include <term\res.h>
#include "htchar.h"

static TCHAR szHelpFileName[FNAME_LEN];

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	glblQueryHelpFileName
 *
 * DESCRIPTION:
 *  Return the name of the help file.
 *
 * RETURNS:
 *	LPTSTR - pointer to the help file name.
 */
LPTSTR glblQueryHelpFileName(void)
	{
	return ((LPTSTR)szHelpFileName);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	glblSetHelpFileName
 *
 * DESCRIPTION:
 *  Load the help file name from the registry or resources.
 *
 * RETURNS:
 */
void glblSetHelpFileName(void)
	{
    DWORD dwSize = sizeof(szHelpFileName);
    HKEY  hKey;

	TCHAR_Fill(szHelpFileName, TEXT('\0'), dwSize/sizeof(TCHAR));

	if (LoadString(glblQueryDllHinst(), IDS_GNRL_HELPFILE, szHelpFileName,
                   dwSize / sizeof(TCHAR)) == 0)
		{
		StrCharCopyN(szHelpFileName, TEXT("HYPERTRM.HLP"),
			         dwSize / sizeof(TCHAR));
		}

    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\HyperTrm.exe"),
                       0,
                       KEY_QUERY_VALUE,
                       &hKey) == ERROR_SUCCESS)
        {
		TCHAR_Fill(szHelpFileName, TEXT('\0'), dwSize/sizeof(TCHAR));

        if (RegQueryValueEx(hKey, TEXT("HelpFileName"), 0, 0,
                            szHelpFileName, &dwSize) != ERROR_SUCCESS)
            {
			if (LoadString(glblQueryDllHinst(), IDS_GNRL_HELPFILE, szHelpFileName,
						   dwSize / sizeof(TCHAR)) == 0)
				{
				StrCharCopyN(szHelpFileName, TEXT("HYPERTRM.HLP"),
							 dwSize / sizeof(TCHAR));
				}
            }

        RegCloseKey(hKey);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * Set and Query the program's instance handle.  Only the Query function
 * is exported.
 */

static HINSTANCE hInstance;

HINSTANCE  glblQueryHinst(void)
	{
	return hInstance;
	}

void  glblSetHinst(const HINSTANCE hInst)
	{
	hInstance = hInst;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * Set and Query the DLL's instance handle.  Only the Query function is
 * exported.
 */

static HINSTANCE hDllInstance;

HINSTANCE glblQueryDllHinst(void)
	{
	return hDllInstance;
	}

void glblSetDllHinst(const HINSTANCE hInst)
	{
	hDllInstance = hInst;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * Set and Query the program's accelerator handle.
 */

static HACCEL hAccel;

void glblSetAccelHdl(const HACCEL hAccelerator)
	{
	hAccel = hAccelerator;
	}

HACCEL glblQueryAccelHdl(void)
	{
	return hAccel;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * Set and Query the program's frame window handle.  Currently the frame
 * window is also the session window, but don't count on it necessarily
 * staying that way.  Upper wacker may change.	I strongly discourge the
 * use of the glbl????HwndFrame functions.	Why are they here?	The message
 * loop (ie. TranslateAccelerator()) needs the handle of the window that
 * owns the menus in order to process accelerators. - mrw
 */

static HWND hwndFrame;

void glblSetHwndFrame(const HWND hwnd)
	{
	hwndFrame = hwnd;
	}

HWND glblQueryHwndFrame(void)
	{
	return hwndFrame;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * DESCRIPTION:
 *	This block of global data is used to manage modeless dialogs.  It consists
 *	of two items.  The first is a counter to determin how many modeless dialogs
 *	are currently registered.  The second is an array of window handles that
 *	are for the modeless dialogs.  At the present time the array is staticly
 *	allocated but could be made dynamic if it ever becomes a problem.
 *
 */
static int glblModelessDlgCount = 0;
static HWND glblModelessDlgArray[64];			/* Think that's enough ? */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	glblAddModelessDlgHwnd
 *
 * DESCRIPTION:
 *	This function adds a window handle to our list of modeless dialog windows.
 *
 * PARAMETERS:
 *	hwnd -- the window handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code of some sort.
 *
 */
int glblAddModelessDlgHwnd(const HWND hwnd)
	{
	int nIndx;

	if (!IsWindow(hwnd))
		{
		assert(FALSE);
		return 1;
		}

	if (glblModelessDlgCount >= 62)
		{
		assert(FALSE);
		return 2;
		}

	for (nIndx = 0; nIndx < glblModelessDlgCount; nIndx += 1)
		{
		if (hwnd == glblModelessDlgArray[nIndx])
			{
			assert(FALSE);
			return 3;
			}
		}

	/*
	 * "It must be safe", he said foolishly.
	 */
	glblModelessDlgArray[glblModelessDlgCount++] = hwnd;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	glblDeleteModelessDlgHwnd
 *
 * DESCRIPTION:
 *	This function takes a modeless dialog box window handle out of the list
 *	that the previous function put it into.
 *
 * PARAMETERS:
 *	hwnd -- the very window handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code of some sort.
 *
 */
int glblDeleteModelessDlgHwnd(const HWND hwnd)
	{
	int nIndx;

	if (glblModelessDlgCount == 0)
		{
		assert(FALSE);
		return 2;
		}

	for (nIndx = 0; nIndx < glblModelessDlgCount; nIndx += 1)
		{
		if (hwnd == glblModelessDlgArray[nIndx])
			{
			/* remove and adjust the array */
			while (nIndx < 62)
				{
				glblModelessDlgArray[nIndx] = glblModelessDlgArray[nIndx + 1];
				nIndx += 1;
				}

			glblModelessDlgCount -= 1;

			return 0;
			}
		}

	/* Never found the puppy */
	assert(FALSE);
	return 3;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CheckModelessMessage
 *
 * DESCRIPTION:
 *	This function is called to check and see if there are any modeless dialog
 *	boxes awaiting input and feeds them the messages.
 *
 * PARAMETERS:
 *	pmsg -- pointer to the message structure
 *
 * RETURNS:
 *	TRUE if it has already processed the message, otherwise FALSE
 *
 */
int CheckModelessMessage(MSG *pmsg)
	{
	int nIndx;

	/* Avoid unnecessary effort */
	if (glblModelessDlgCount == 0)
		return FALSE;

	for (nIndx = 0; nIndx < glblModelessDlgCount; nIndx += 1)
		{
#if 0
#if !defined(NDEBUG)
		assert(IsWindow(glblModelessDlgArray[nIndx]));
#endif
#endif
		if (IsDialogMessage(glblModelessDlgArray[nIndx], pmsg))
			return TRUE;
		}
	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * It is possible, under some conditions, that the program will shut down
 * because of an error.  Under some of these conditions, there may not be
 * a valid session handle, so it becomes necessary to store the status of
 * the shutdown as a static variable.
 */

static int nShutdownStatus;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	glblQueryProgramStatus
 *
 * DESCRIPTION:
 *	Returns the startup/shutdown status of the program.
 *
 * ARGUMENTS:
 *	None.
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise a shutdown status code.
 *
 */
int glblQueryProgramStatus()
	{
	return nShutdownStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	glblSetProgramStatus
 *
 * DESCRIPTION:
 *	Changes the startup/shutdown status of the program.
 *
 * ARGUMENTS:
 *	nStatus -- the new status.
 *
 * RETURNS:
 *	The previous status.
 *
 */
int glblSetProgramStatus(int nStatus)
	{
	int nRet;

	nRet = nShutdownStatus;
	nShutdownStatus = nStatus;

	return nShutdownStatus;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * Banner is displayed at program startup
 */

static HWND hwndBanner;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	glblQueryHwndBanner
 *
 * DESCRIPTION:
 *	Returns window handle of banner
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	HWND
 *
 */
HWND glblQueryHwndBanner(void)
	{
	return hwndBanner;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	glblSetHwndBanner
 *
 * DESCRIPTION:
 *	Sets the value of hwndBanner for later reference
 *
 * ARGUMENTS:
 *	hwnd	- window handle of banner
 *
 * RETURNS:
 *	void
 *
 */
void glblSetHwndBanner(const HWND hwnd)
	{
	hwndBanner = hwnd;
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\htchar.h ===
/*	File: D:\WACKER\tdll\htchar.h (Created: 22-Feb-1995)
 *
 *	Copyright 1994,1995 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 7/08/02 6:41p $
 */

TCHAR 	*TCHAR_Fill(TCHAR *dest, TCHAR c, size_t count);
TCHAR 	*TCHAR_Trim(TCHAR *pszStr);
LPTSTR 	StrCharNext(LPCTSTR pszStr);
LPTSTR 	StrCharPrev(LPCTSTR pszStart, LPCTSTR pszStr);
LPTSTR 	StrCharLast(LPCTSTR pszStr);
LPTSTR 	StrCharEnd(LPCTSTR pszStr);
LPTSTR 	StrCharFindFirst(LPCTSTR pszStr, int nChar);
LPTSTR 	StrCharFindLast(LPCTSTR pszStr, int nChar);
LPTSTR 	StrCharCopy(LPTSTR pszDst, LPCTSTR pszSrc);
LPTSTR 	StrCharCat(LPTSTR pszDst, LPCTSTR pszSrc);
LPTSTR 	StrCharStrStr(LPCTSTR pszA, LPCTSTR pszB);
LPTSTR 	StrCharCopyN(LPTSTR pszDst, LPCTSTR pszSrc, int iLen);
LPTSTR  StrCharPBrk(LPCTSTR pszStr, LPCTSTR pszSet);
int 	StrCharGetStrLength(LPCTSTR pszStr);
int 	StrCharGetByteCount(LPCTSTR pszStr);
int 	StrCharCmp(LPCTSTR pszA, LPCTSTR pszB);
int 	StrCharCmpi(LPCTSTR pszA, LPCTSTR pszB);
int     StrCharCmpN(LPCTSTR pszA, LPCTSTR pszB, size_t iLen);
int     StrCharCmpiN(LPCTSTR pszA, LPCTSTR pszB, size_t iLen);

ECHAR 	*ECHAR_Fill(ECHAR *dest, ECHAR c, size_t count);
int 	CnvrtMBCStoECHAR(ECHAR * echrDest, const unsigned long ulDestSize, 
			const TCHAR * const tchrSource, const unsigned long ulSourceSize);
int 	CnvrtECHARtoMBCS(TCHAR * tchrDest, const unsigned long ulDestSize, 
			const ECHAR * const echrSource, const unsigned long ulSourceSize);
int 	CnvrtECHARtoTCHAR(LPTSTR pszDest, int cchDest, ECHAR eChar);
int 	StrCharGetEcharLen(const ECHAR * const pszA);
int 	StrCharGetEcharByteCount(const ECHAR * const pszA);
int 	StrCharCmpEtoT(const ECHAR * const pszA, const TCHAR * const pszB);
int 	StrCharStripDBCSString(ECHAR *aechDest, const long lDestSize, 
            ECHAR *aechSource);
int 	isDBCSChar(unsigned int Char);

#if defined(DEADWOOD)
#if defined(INCL_VTUTF8)
BOOLEAN TranslateUTF8ToDBCS(UCHAR  IncomingByte,
                            UCHAR *pUTF8Buffer,
                            int    iUTF8BufferLength,
                            WCHAR *pUnicode8Buffer,
                            int    iUnicodeBufferLength,
                            TCHAR *pDBCSBuffer,
                            int    iDBCSBufferLength);
BOOLEAN TranslateDBCSToUTF8(const TCHAR *pDBCSBuffer,
                                  int    iDBCSBufferLength,
                                  WCHAR *pUnicode8Buffer,
                                  int    iUnicodeBufferLength,
                                  UCHAR *pUTF8Buffer,
                                  int    iUTF8BufferLength);

//
// The following functions are from code obtained directly from
// Microsoft for converting Unicode to UTF-8 and UTF-8 to unicode
// buffers. REV: 03/02/2001
//

BOOLEAN TranslateUnicodeToUtf8(PCWSTR SourceBuffer,
                               UCHAR  *DestinationBuffer);
BOOLEAN TranslateUtf8ToUnicode(UCHAR  IncomingByte,
                               UCHAR  *ExistingUtf8Buffer,
                               WCHAR  *DestinationUnicodeVal);
#endif //INCL_VTUTF8
#endif // defined(DEADWOOD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keyextrn.cpp ===
//******************************************************************************
// File: \wacker\tdll\Keyextrn.h  Created: 6/2/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This file provides some external C functions to allow the Emu_Key_Macro 
//    and Emu_Key_Macro_List classes to be accessed from the C world.
//
// $Revision: 2 $
// $Date: 11/07/00 11:54a $
// $Id: keyextrn.cpp 1.3 1998/09/10 16:10:17 bld Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"

#ifdef INCL_KEY_MACROS

#include "keymlist.h"
#include "keymacro.h"

extern "C"
    {
    #include "session.h"
    #include "assert.h"
    #include "keyutil.h"
    #include "mc.h"
    }

//
// make sure these functions have C linkage
//

extern "C"
    {
    int keysAddMacro( const keyMacro * pKeyMacro );
    int keysGetKeyCount( void );
    int keysGetMacro( int aIndex, keyMacro * pKeyMacro );
    int keysFindMacro( const keyMacro * pKeyMacro );
    int keysLoadMacroList( HSESSION hSession );
    int keysLoadSummaryList( HWND listBox );
    int keysRemoveMacro( keyMacro * pKeyMacro );
    int keysSaveMacroList( HSESSION hSession );
    int keysUpdateMacro( int aIndex, const keyMacro * pKeyMacro );
    }

//******************************************************************************
// Method:
//    keysAddMacro
//
// Description:
//    Adds the specified macro to the list of macros
//
// Arguments:
//    pmacro - The macro to be added
//
// Returns:
//    0 if all is ok, -1 if max macros exist, > 0 if duplicate found.
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/09/1998
//
//

int keysAddMacro( const keyMacro * pKeyMacro )
    {
    Emu_Key_Macro lKeyMacro;
    lKeyMacro = pKeyMacro;

    return gMacroManager.addMacro( lKeyMacro );
    }

//******************************************************************************
// Method:
//    keysGetKeyCount
//
// Description:
//    returns the number of macros in the list
//
// Arguments:
//    void
//
// Returns:
//    macro count 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysGetKeyCount( void )
    {
    return gMacroManager.numberOfMacros();
    }

//******************************************************************************
// Method:
//    keysGetMacro
//
// Description:
//    Gets the macro at the specified index and fills in the keyMacro struct
//
// Arguments:
//    aIndex - Index of key macro
//    pMacro - Key Macro structure to fill in
//
// Returns:
//    0 for failure, non zero success
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/5/98
//
//

int keysGetMacro( int aIndex, keyMacro * pKeyMacro )
    {
    Emu_Key_Macro lKeyMacro;
    lKeyMacro = gMacroManager[ aIndex ];

    pKeyMacro->keyName     = lKeyMacro.mKey;
    pKeyMacro->macroLen    = lKeyMacro.mMacroLen;
    pKeyMacro->editMode    = 0;               
    pKeyMacro->altKeyValue = 0;            
    pKeyMacro->altKeyCount = 0;            
    pKeyMacro->keyCount    = 0;               
    pKeyMacro->insertMode  = 0;             
    pKeyMacro->lpWndProc   = 0;              

    if (lKeyMacro.mMacroLen)
        MemCopy( pKeyMacro->keyMacro, lKeyMacro.mKeyMacro, 
            lKeyMacro.mMacroLen * sizeof(KEYDEF) );

    return 1;
    }

//******************************************************************************
// Method:
//    keysFindMacro
//
// Description:
//    Looks for the specified macro in the list and returns the index of the 
//    macro.
//
// Arguments:
//    pKeyMacro - The macro to find
//
// Returns:
//    -1 for failue or the index of the specified macro 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/09/1998
//
//

int keysFindMacro( const keyMacro * pKeyMacro )
    {
    return gMacroManager.find( pKeyMacro->keyName );
    }

//******************************************************************************
// Method:
//    keysLoadMacroList
//
// Description:
//    Loads the macro list from the session file
//
// Arguments:
//    hSession - Session handle
//
// Returns:
//    0 if all is ok, -1 for an error 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysLoadMacroList( HSESSION hSession )
    {
    int lResult = gMacroManager.load( hSession );

    return lResult;
    }


//******************************************************************************
// Method:
//    keysLoadSummaryList
//
// Description:
//    Loads the key summary list box with all key definitions
//
// Arguments:
//    listBox - List box handle of the list box to fill
//
// Returns:
//    0 if an error occurs
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysLoadSummaryList( HWND listBox )
    {
    Emu_Key_Macro lMacro;
    int listIndex;

    SendMessage( listBox, LB_RESETCONTENT, 0, 0 );

    for ( int i = 0; i < gMacroManager.numberOfMacros(); i++ )
        {
        lMacro = gMacroManager[i];

        TCHAR lKeyName[2048];
        TCHAR lBuffer[2048];
        memset( lBuffer, TEXT('\0'), sizeof(lBuffer)/sizeof(TCHAR) );

        keysGetDisplayString( &lMacro.mKey, 1, lKeyName, sizeof(lKeyName) );
        strcat( lBuffer, lKeyName );
        strcat( lBuffer, TEXT("\t") );

        keysGetDisplayString( lMacro.mKeyMacro, lMacro.mMacroLen, lKeyName, sizeof(lKeyName) );
        strcat( lBuffer, lKeyName );
        
        listIndex = SendMessage( listBox, LB_ADDSTRING, 0, (LPARAM)lBuffer );
        assert( listIndex != LB_ERR );
        
        SendMessage( listBox, LB_SETITEMDATA, listIndex, i );
        } 

    return 1;
    }

//******************************************************************************
// Method:
//    keysRemoveMacro
//
// Description:
//    Removes the specified macro from the macro list
//
// Arguments:
//    pMacro - Macro to be removed
//
// Returns:
//    0 if an error occurs, non zero if macro is removed.
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/5/98
//
//

int keysRemoveMacro( keyMacro * pMacro )
    {
    return gMacroManager.removeMacro( pMacro->keyName );
    }

//******************************************************************************
// Method:
//    keysSaveMacroList
//
// Description:
//    Saves the macro list to the session file
//
// Arguments:
//    hSession - Session handle
//
// Returns:
//    0 if all is ok, -1 for an error 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysSaveMacroList( HSESSION hSession )
    {
    return gMacroManager.save( hSession );
    }

//******************************************************************************
// Method:
//    keysUpdateMacro
//
// Description:
//    Updates the macro at the specified index and fills in the keyMacro struct
//
// Arguments:
//    aIndex - Index of key macro
//    pMacro - Key Macro structure to use to update
//
// Returns:
//    0 for failure, non zero success
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/5/98
//
//

int keysUpdateMacro( int aIndex, const keyMacro * pKeyMacro )
    {
    gMacroManager[aIndex] = pKeyMacro;

    return 1;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keymacro.cpp ===
//******************************************************************************
// File: \wacker\tdll\Keymacro.cpp  Created: 6/2/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//   This file represents a key macro.  It is a representation of a remapped key
//   and the key strokes it represents.
//
// $Revision: 1 $
// $Date: 10/05/98 12:34p $
// $Id: keymacro.cpp 1.4 1998/09/10 17:02:45 bld Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"
extern "C"
    {
    #include "mc.h"
    }

#ifdef INCL_KEY_MACROS

#include "keymacro.h"

INC_NV_COMPARE_IMPLEMENTATION( Emu_Key_Macro );

//******************************************************************************
// Method:
//    operator>>
//
// Description:
//    Iostream extractor
//
// Arguments:
//    theStream - The stream to extract from
//    aMacro    - The macro to stream into
//
// Returns:
//    istream & 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

istream & operator>>( istream & theStream, Emu_Key_Macro & aMacro )
    {
    aMacro.mKey      = 0;
    aMacro.mMacroLen = 0;

    theStream >> aMacro.mKey >> aMacro.mMacroLen;

    for ( int i = 0; i < aMacro.mMacroLen; i++ )
        {
        theStream >> aMacro.mKeyMacro[i];
        }

    return theStream;
    }

//******************************************************************************
// Method:
//    operator<<
//
// Description:
//    Iostream inserter
//
// Arguments:
//    theStream - The stream to insert into
//    aMacro    - The macro to stream out
//
// Returns:
//    istream & 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

ostream & operator<<( ostream & theStream, const Emu_Key_Macro & aMacro )
    {
    theStream << aMacro.mKey << " " <<  aMacro.mMacroLen << " ";

    for ( int i = 0; i < aMacro.mMacroLen; i++ )
        {
        theStream << aMacro.mKeyMacro[i] << " ";
        }
  
    return theStream;
    }

//******************************************************************************
// Method:
//    Emu_Key_Macro
//
// Description:
//     Constructor
//
// Arguments:
//    void
//
// Returns:
//    void
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro :: Emu_Key_Macro( void )
    :   mKey( 0 ),
        mMacroLen( 0 )
    {
    return;
    }

//******************************************************************************
// Method:
//    Emu_Key_Macro
//
// Description:
//    Copy Constructor
//
// Arguments:
//    aMacro - The macro to copy from
//
// Returns:
//    void
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro :: Emu_Key_Macro( const Emu_Key_Macro & aMacro )
    :   mKey( aMacro.mKey ),
        mMacroLen( aMacro.mMacroLen )
    {
    if (mMacroLen)
        MemCopy( mKeyMacro, aMacro.mKeyMacro, mMacroLen * sizeof(KEYDEF) );

    return;
    }

//******************************************************************************
// Method:
//    ~Emu_Key_Macro
//
// Description:
//    Destructor
//
// Arguments:
//    void
//
// Returns:
//    void
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro :: ~Emu_Key_Macro( void )
    {
    return;
    }

//******************************************************************************
// Method:
//    operator=
//
// Description:
//    Assignment operator
//
// Arguments:
//    aMacro - The key macro to assign from
//
// Returns:
//    Emu_Key_Macro &
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro & Emu_Key_Macro :: operator=( const Emu_Key_Macro & aMacro )
    {
    mKey      =  aMacro.mKey;
    mMacroLen =  aMacro.mMacroLen;

    if (mMacroLen)
        MemCopy( mKeyMacro, aMacro.mKeyMacro, mMacroLen * sizeof(KEYDEF) );

    return *this;
    }

//******************************************************************************
// Method:
//    operator=
//
// Description:
//    Assignment operator
//
// Arguments:
//    aMacro - The key macro structure to assign from
//
// Returns:
//    Emu_Key_Macro &
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro & Emu_Key_Macro :: operator=( const keyMacro * aMacro )
    {
    mKey      =  aMacro->keyName;
    mMacroLen =  aMacro->macroLen;

    if (mMacroLen)
        MemCopy( mKeyMacro, aMacro->keyMacro, mMacroLen * sizeof(KEYDEF) );

    return *this;
    }

//******************************************************************************
// Method:
//    compare
//
// Description:
//    Compares macro for equality returns 0 if equal < 0 if this is less
//    than or > 0 if this is greater than.  Note the equality is determined by
//    the actual key that is defined and not by its definition.    
//    
// Arguments:
//    aMacro - macro to compare against
//
// Returns:
//    0 = equal, < 0 this less than aMacro, > 0 this greater than aMacro
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

int Emu_Key_Macro :: compare( const Emu_Key_Macro & aMacro ) const
    {
    return mKey - aMacro.mKey;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\hlptable.h ===
/*	File: D:\WACKER\help\hlptable.h (Created: 7-Jan-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 3/04/02 11:58a $
 */

// NOTE:
// This file contains HELP CONTEXT Identifiers.
// This file is included internally and should be included by *.HPJ file
// when the .HLP file will be created.

// New Connection Description Dialog Box
//
#define IDH_TERM_NEWCONN_NAME			40960	// 0xA000
#define IDH_TERM_NEWCONN_ICON   		40961
#define IDH_BROWSE              		40962

//
// New Connection Phone Number Dialog Box.
//
#define IDH_TERM_NEWPHONE_CARRIERDETECT 40969	// New help identifier. REV: 12/11/2001
#define IDH_TERM_NEWPHONE_COUNTRY		40970
#define IDH_TERM_NEWPHONE_AREA      	40971
#define IDH_TERM_NEWPHONE_NUMBER    	40972
#define IDH_TERM_NEWPHONE_DEVICE    	40973
#define IDH_TERM_NEWPHONE_CONFIGURE		40974	// New help identifier
#define IDH_TERM_NEWPHONE_HOSTADDRESS   40975
#define IDH_TERM_NEWPHONE_PORTNUMBER    40976
#define IDH_TERM_NEWPHONE_REDIAL        40977   // New help identifier
#define IDH_TERM_NEWPHONE_USECCAC       40978
#define IDH_TERM_NEWPHONE_COUNTRY_AREA  40979
//
// Dial Or Open Confirmation Dialog Box.
//
#define IDH_TERM_DIAL_MODIFY			40980
#define IDH_TERM_DIAL_EDITNEW       	40981
#define IDH_TERM_DIAL_LOCATION      	40982
#define IDH_TERM_DIAL_DIAL          	40983
#define IDH_TERM_DIAL_OPEN          	40984
#define IDH_TERM_DIAL_CALLING_CARD		40985	// New help identifier
#define IDH_TERM_DIAL_PHONENUMBER		40986	// New help identifier

//
// Phone Number Properties Sheet
//
// Deleted IDH_TERM_PHONEPROP_... ids, not used
#define IDH_TERM_PHONEPROP_CHANGEICON	41001

//
// Terminal Properties Sheet
//                                      41010
#define IDH_TERM_SETTING_EMULATION      41011	// New id
#define IDH_TERM_SETTING_BACKSCROLL		41012	
#define IDH_TERM_SETTING_ASCIISET		41013	
#define IDH_TERM_SETTING_SOUND			41014	
#define IDH_TERM_SETTING_USEKEYS		41015	
#define IDH_TERM_SETTING_TERMSET		41016	
#define IDH_TERM_SETTING_BACKSPACE		41017
#define IDH_TERM_SETTING_CTRLH			41018
#define IDH_TERM_SETTING_DEL			41019
#define IDH_TERM_SETTING_CTRLH2			41020
#define IDH_TERM_SETTING_TELNETID		41021
#define IDH_TERM_SETTING_HIDE_CURSOR    41022
#define IDH_TERM_SETTING_ENTER          41023

//
// Receive File Dialog Box
//
#define IDH_TERM_RECEIVE_DIRECTORY      41030
#define IDH_TERM_RECEIVE_PROTOCOL		41031
#define IDH_TERM_RECEIVE_RECEIVE		41032

//
// Send Dialog Box
//
#define IDH_TERM_SEND_FILENAME			41040
#define IDH_TERM_SEND_PROTOCOL			41041
#define IDH_TERM_SEND_SEND				41042
#define IDH_TERM_SEND_FOLDER            41043

//
// General help for terminal window
//
//#define IDH_TERM_WINDOW				  41050

//
// Emulator Settings dialogs
//
#define IDH_TERM_EMUSET_MODES			41071	// New help identifier
#define IDH_TERM_EMUSET_CURSOR			41072
#define IDH_TERM_EMUSET_DESTRUCTIVE		41073
#define IDH_TERM_EMUSET_ALTMODE			41074
#define IDH_TERM_EMUSET_KEYPADMODE		41075
#define IDH_TERM_EMUSET_CURSORMODE		41076
#define IDH_TERM_EMUSET_132COLUMNS		41077
#define IDH_TERM_EMUSET_CHARSETS		41078
#define IDH_TERM_EMUSET_8BITCODES		41079	
#define IDH_TERM_EMUSET_USERDEFKEYS		41080
#define IDH_TERM_EMUSET_PRINTRAW		41081
#define IDH_TERM_SETTING_EXIT			41082
#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
#define IDH_TERM_EMUSET_ROWSANDCOLS		41083
#define IDH_TERM_EMUSET_COLORS			41084
#define IDH_TERM_SETTING_COLOR			41085
#define IDH_TERM_COLOR_PREVIEW			41086
#endif
#define IDH_TERM_SETTING_HOSTXFERS		41087
//
// ASCII dialog box
//
#define IDH_TERM_ASCII_SEND_LINE		41090
#define IDH_TERM_ASCII_SEND_ECHO		41091
#define IDH_TERM_ASCII_REC_APPEND		41092
#define IDH_TERM_ASCII_REC_FORCE		41093
#define IDH_TERM_ASCII_REC_WRAP			41094
#define IDH_TERM_ASCII_SENDING			41095 	// New help identifiers
#define IDH_TERM_ASCII_RECEIVING		41096	// New help identifiers
#define IDH_TERM_ASCII_LINE_DELAY		41097
#define IDH_TERM_ASCII_CHAR_DELAY		41098

//
// Capture dialog box
//
#define IDH_TERM_CAPT_FILENAME			41100
#define IDH_TERM_CAPT_DIRECTORY			41101
#define IDH_TERM_CAPT_START             41102

// What's This from the context menu
//
//#define IDH_TERM_CONTEXT_WHATS_THIS	  41110

//
// Used in receive and send dialogs.
//
#define IDH_CLOSE_DIALOG				41120

//
// JIS to Shift JIS translation Dialog
//
#define IDH_HTRN_DIALOG					41130
#define IDH_HTRN_SHIFTJIS				41131
#define IDH_HTRN_JIS					41132

//
// Default Telnet app dialog
//
#define IDH_TELNETCK_STOP_ASKING		41140
#define IDH_TELNETCK_YES				41141
#define IDH_TELNETCK_NO					41142

//
// key macros
//
#define IDH_LB_KEYS_KEYLIST        41150
#define IDH_PB_KEYS_MODIFY         41151
#define IDH_PB_KEYS_NEW            41152
#define IDH_PB_KEYS_DELETE         41153
#define IDH_EF_KEYS_KEYNAME        41154
#define IDH_ML_KEYS_MACRO          41155

BOOL isControlinHelpTable(const DWORD aHlpTable[], const INT cntrlID);
void doContextHelp(const DWORD aHlpTable[], WPARAM wPar, LPARAM lPar, BOOL bContext, BOOL bForce);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keyedit.c ===
//******************************************************************************
// File: \wacker\tdll\keyedit.c  Created: 6/5/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This file represents a window procedure for a key edit control.  This
//    catches key strokes and displays them as appropiate for defining key macros
//    This is used by the key dialog for the keyname and key macro edit boxes.
//
// $Revision: 4 $
// $Date: 8/15/01 4:56p $
// $Id: keyedit.c 1.2 1998/06/12 07:20:41 dmn Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"
#include "mc.h"

#ifdef INCL_KEY_MACROS

#include <term\res.h>
#include <tdll\assert.h>
#include "globals.h"
#include "keyutil.h"
#include "chars.h"
#include "htchar.h"

static void insertKeyAndDisplay( KEYDEF aKey, keyMacro * aKeyMacro, HWND aEditCtrl );
static int processKeyMsg( UINT aMsg, UINT aVirtKey, UINT aKeyData, HWND aEditCtrl );
static void removeKeyAndDisplay( keyMacro * aKeyMacro, HWND aEditCtrl );

//******************************************************************************
// Method:
//    keyEditWindowProc
//
// Description:
//    This is the window procedure for the key edit control
//
// Arguments:
//    hwnd    - Handle of window
//    uMsg    - Message to be processed
//    wParam  - First message parameter
//    lParam  - Second window parameter
//
// Returns:
//    The return value is the result of the message processing and depends on the
//    message sent
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/5/98
//
//

LRESULT CALLBACK keyEditWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
    BOOL lMessageProcessed = FALSE;
    BOOL lKeyProcessed     = FALSE;
    keyMacro * pKeyMacro = NULL;
    LRESULT lResult = 0;        
    KEYDEF lKey;
    MSG lMsg;

    switch ( uMsg )
        {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        {
        if ( processKeyMsg( uMsg, wParam, lParam, hwnd ) )
            {
            lMessageProcessed = TRUE;
            lKeyProcessed = TRUE;
            }

        break;
        }

    //
    // this command gets sent just after the wm_keydown for the F1 key.  I
    // could not find a manifest constant for this value anywhere.  I believe
    // it is sent as a result of CWinApp or CWinThread pre translate message in
    // the processing of accelerator keys.  Anyway, this fixes the problem of
    // help popping up after we do an insert of the F1 key into a key
    // definition.  DMN - 08/21/96
    //

    case 0x004d:
        {
        pKeyMacro = (keyMacro *)GetWindowLongPtr( hwnd, GWLP_USERDATA );
        assert( pKeyMacro );

        if ( pKeyMacro )
            {
            if( pKeyMacro->insertMode == TRUE)
                {
                pKeyMacro->insertMode = FALSE;
                lMessageProcessed = TRUE;
                }        
            }

        break;
        }

    //
    // handle the case of entering ALT key sequences such as ALT-128.  The keys
    // pressed while ALT is held down are captured and processed as a whole
    // here when the ALT key is released.  The keys are captured in such a
    // way as to allow up to 4 keys pressed and to not require leading zeros
    // for example ALT-27 ALT-0027 are treated the same.
    //

    case WM_KEYUP:
    case WM_SYSKEYUP:
        if ( wParam == VK_MENU )
            {
            pKeyMacro = (keyMacro *)GetWindowLongPtr( hwnd, GWLP_USERDATA );
            assert( pKeyMacro );

            if ( pKeyMacro )
                {
                if (( pKeyMacro->altKeyCount > 0 ) &&
                    ( pKeyMacro->altKeyValue >= 0 && 
                      pKeyMacro->altKeyValue <= 255 ))
                    {
                    KEYDEF lKey = pKeyMacro->altKeyValue;
                    insertKeyAndDisplay( lKey, pKeyMacro, hwnd );
                    pKeyMacro->insertMode = FALSE;
                    }
                }

            pKeyMacro->altKeyCount  = 0;
            pKeyMacro->altKeyValue = 0;

            lMessageProcessed = TRUE;
            lKeyProcessed     = TRUE;
            }

        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        pKeyMacro = (keyMacro *)GetWindowLongPtr( hwnd, GWLP_USERDATA );
        assert( pKeyMacro );

        if ( pKeyMacro )
            {
            lMsg.message = uMsg;
            lMsg.wParam  = wParam;
            lMsg.lParam  = lParam;

            lKey = TranslateToKey( &lMsg );

            if ( lKey != 0x000d && (TCHAR)lKey != 0x0009 )
                {
                insertKeyAndDisplay( lKey, pKeyMacro, hwnd );
                pKeyMacro->insertMode = FALSE;
                lMessageProcessed = TRUE;
                }
        
            return 0;
            }

        break;

    case WM_CONTEXTMENU:
        lMessageProcessed = TRUE;
        break;

    case WM_LBUTTONDOWN:
        SetFocus( hwnd );
        SendMessage( hwnd, EM_SETSEL, 32767, 32767 );
        lMessageProcessed = TRUE;
        break;

    default:
        break;
        }

    //  
    // if we did not process the key then let the edit control process it
    //

    if ( !lMessageProcessed )
        {
        pKeyMacro = (keyMacro *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        
        if ( pKeyMacro )
            {
            lResult = CallWindowProc( pKeyMacro->lpWndProc, hwnd, uMsg, wParam, lParam );
            }
        }
    else if( lKeyProcessed )
        {
        MSG msg;
		PeekMessage(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE);
        }
        
    return lResult;
    }

//******************************************************************************
// Method:
//    insertKeyAndDisplay
//
// Description:
//    Inserts the specified key into the keyMacro structure provided and displays
//    the new key definition(s) in the edit control provided.
//
// Arguments:
//    aKey       - The key to add
//    aKeyMacro  - The current macro definition being acted on
//    aEditCtrl  - The edit control to update
//
// Returns:
//    void 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/08/1998
//
//

void insertKeyAndDisplay( KEYDEF aKey, keyMacro * aKeyMacro, HWND aEditCtrl )
    {
    TCHAR keyString[2048];
    int   lStrLen;
    
    if ( aKeyMacro->keyCount == 1 )
        {
        aKeyMacro->keyName = aKey;
        keysGetDisplayString( &aKeyMacro->keyName, 1,  keyString, sizeof(keyString) );

        SetWindowText( aEditCtrl, keyString );
        lStrLen = StrCharGetStrLength( keyString );
        SendMessage( aEditCtrl, EM_SETSEL, lStrLen, lStrLen );
        }

    else
        {
         if ( aKeyMacro->macroLen == aKeyMacro->keyCount )
            {
            aKeyMacro->keyMacro[aKeyMacro->macroLen - 1] = aKey;
            }
        else
            {
            aKeyMacro->keyMacro[aKeyMacro->macroLen] = aKey;
            aKeyMacro->macroLen++;
            }

        keysGetDisplayString( aKeyMacro->keyMacro, aKeyMacro->macroLen,  
                                  keyString, sizeof(keyString) );
        SetWindowText( aEditCtrl, keyString );
        lStrLen = StrCharGetStrLength( keyString );
        SendMessage( aEditCtrl, EM_SETSEL, lStrLen, lStrLen );
        }

    return;
    }

//******************************************************************************
// Method:
//    processKeyMsg
//
// Description:
//    
// Arguments:
//    uMsg
//
// Returns:
//    int 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/5/98
//
//

int processKeyMsg( UINT aMsg, UINT aVirtKey, UINT aKeyData, HWND aEditCtrl )
    {
    KEYDEF  lKey;
    KEYDEF  lOrgKey;
    int     lReturn = FALSE;
    keyMacro * pKeyMacro = NULL;
    MSG lMsg;
    
    lMsg.message = aMsg;
    lMsg.wParam  = aVirtKey;
    lMsg.lParam  = aKeyData;

    lKey = TranslateToKey( &lMsg );

    if( lKey == 0 )
        {
        return FALSE;
        }

    if ( keysIsKeyHVK( lKey ) )
        {
        pKeyMacro = (keyMacro *)GetWindowLongPtr( aEditCtrl, GWLP_USERDATA );
        assert( pKeyMacro );

        if ( !pKeyMacro )
            {
            return FALSE;                    
            }

        lOrgKey = lKey;
        lKey = (TCHAR)lKey;

        switch( lKey )
            {
        case VK_INSERT:
        case VK_INSERT | EXTENDED_KEY:

            if( pKeyMacro->insertMode == TRUE)
                {
                insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
                pKeyMacro->insertMode = FALSE;
                lReturn = TRUE;
                }
            else
                {
                pKeyMacro->insertMode = TRUE;
                lReturn = TRUE;
                }
            break;

        //
        // all forms of pressing F1 send a help message after the keydown
        // message except for the alt f1 combination.  So if we are in
        // insert mode we insert the key pressed and leave the insert mode
        // on so when we catch the help message we know not to display help
        // and turn off insert mode.  If the key pressed is alt F1 we turn
        // insert mode off here as there is no help message generated.
        //

        case VK_F1:

            if( pKeyMacro->insertMode == TRUE)
                {
                insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
                lReturn = TRUE;
                }

            if ( lKey & ALT_KEY )
                {
                pKeyMacro->insertMode = FALSE;
                }

            break;

        case VK_BACK:

            if( pKeyMacro->insertMode == TRUE )
                {
                insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
                pKeyMacro->insertMode = FALSE;
                lReturn = TRUE;
                }
            else
                {
                removeKeyAndDisplay( pKeyMacro, aEditCtrl );
                lReturn = TRUE;
                }

            break;

        case VK_TAB:
        case VK_TAB | SHIFT_KEY | VIRTUAL_KEY:
        case VK_CANCEL:
        case VK_PAUSE:
        case VK_ESCAPE:
        case VK_SNAPSHOT:
        case VK_NUMLOCK:
        case VK_CAPITAL:
        case VK_SCROLL:
        case VK_RETURN:
        case VK_RETURN | EXTENDED_KEY:

            if(pKeyMacro->insertMode == TRUE)
                {
                insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
                pKeyMacro->insertMode = FALSE;
                lReturn = TRUE;
                }

            break;

        case VK_SPACE:

            lKey = ' ';
            insertKeyAndDisplay( lKey, pKeyMacro, aEditCtrl );
            pKeyMacro->insertMode = FALSE;
            lReturn = TRUE;

            break;

        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
        case VK_PRIOR  | EXTENDED_KEY:
        case VK_NEXT   | EXTENDED_KEY:
        case VK_HOME   | EXTENDED_KEY:
        case VK_END    | EXTENDED_KEY:
        case VK_UP:    
        case VK_DOWN:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP     | SHIFT_KEY:
        case VK_DOWN   | SHIFT_KEY:
        case VK_LEFT   | SHIFT_KEY:
        case VK_RIGHT  | SHIFT_KEY:
        case VK_UP     | EXTENDED_KEY:
        case VK_DOWN   | EXTENDED_KEY:
        case VK_LEFT   | EXTENDED_KEY:
        case VK_RIGHT  | EXTENDED_KEY:
        case VK_UP     | SHIFT_KEY | EXTENDED_KEY:
        case VK_DOWN   | SHIFT_KEY | EXTENDED_KEY:
        case VK_LEFT   | SHIFT_KEY | EXTENDED_KEY:
        case VK_RIGHT  | SHIFT_KEY | EXTENDED_KEY:
        case VK_DELETE:
        case VK_DELETE | EXTENDED_KEY:

            if(pKeyMacro->insertMode == TRUE)
                {
                insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
                pKeyMacro->insertMode = FALSE;
                }

            lReturn = TRUE;
            break;

        case VK_CLEAR:
        case VK_EREOF:
        case VK_PA1:
            break;

        case VK_NUMPAD0:
        case VK_NUMPAD1:
        case VK_NUMPAD2:
        case VK_NUMPAD3:
        case VK_NUMPAD4:
        case VK_NUMPAD5:
        case VK_NUMPAD6:
        case VK_NUMPAD7:
        case VK_NUMPAD8:
        case VK_NUMPAD9:
            //
            // if the ALT is down capture other key presses for later
            // processing on the ALT key up
            //
            if ( lOrgKey & ALT_KEY )
                {
                if ( pKeyMacro->altKeyCount <= 3 )
                    {
                    if ( pKeyMacro->altKeyCount == 0 )
                        {
                        pKeyMacro->altKeyValue = 0;
                        }

                    pKeyMacro->altKeyValue *= 10;
                    pKeyMacro->altKeyValue += aVirtKey - VK_NUMPAD0;
                    pKeyMacro->altKeyCount++;
                    }
                }
            else
                {
                insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
                pKeyMacro->insertMode = FALSE;
                lReturn = TRUE;
                }

            break;

        default:
            insertKeyAndDisplay( lOrgKey, pKeyMacro, aEditCtrl );
            lReturn = TRUE;
            pKeyMacro->insertMode = FALSE;
            break;
            }
        }

    return lReturn;
    }

//******************************************************************************
// Method:
//    removeKeyAndDisplay
//
// Description:
//    Removes the specified key into the keyMacro structure provided and displays
//    the new key definition(s) in the edit control provided.
//
// Arguments:
//    aKeyMacro  - The current macro definition being acted on
//    aEditCtrl  - The edit control to update
//
// Returns:
//    void 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/08/1998
//
//

void removeKeyAndDisplay( keyMacro * aKeyMacro, HWND aEditCtrl )
    {
    TCHAR keyString[2048];
    int   lStrLen;
    
    if ( aKeyMacro->keyCount == 1 )
        {
        aKeyMacro->keyName = 0;
		TCHAR_Fill(keyString, TEXT('\0'), sizeof(keyString) / sizeof(TCHAR));

        SetWindowText( aEditCtrl, keyString );
        lStrLen = strlen( keyString );
        SendMessage( aEditCtrl, EM_SETSEL, lStrLen, lStrLen );
        }

    else
        {
        if ( aKeyMacro->macroLen > 0 )
            {
            aKeyMacro->macroLen--;
            aKeyMacro->keyMacro[aKeyMacro->macroLen] = 0;

            keysGetDisplayString( aKeyMacro->keyMacro, aKeyMacro->macroLen,  
                                      keyString, sizeof(keyString) );
            SetWindowText( aEditCtrl, keyString );
            lStrLen = strlen( keyString );
            SendMessage( aEditCtrl, EM_SETSEL, lStrLen, lStrLen );
            }
        }

    return;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keymlist.cpp ===
//******************************************************************************
// File: \wacker\tdll\Keymlist.h  Created: 6/2/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This class manages the list of user defines key macros
// 
// $Revision: 1 $
// $Date: 10/05/98 1:12p $
// $Id: keymlist.cpp 1.1 1998/06/11 12:03:39 dmn Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"
#include "mc.h"

#ifdef INCL_KEY_MACROS

#include <strstrea.h>
#include "keymlist.h"

extern "C"
    {
    #include "sess_ids.h"
    #include "session.h"
    #include "sf.h"
    }

//******************************************************************************
// Method:
//    operator>>
//
// Description:
//    Iostream extractor
//
// Arguments:
//    theStream  - The stream to extract from
//    aMacroList - The macrolist to stream into
//
// Returns:
//    istream & 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

istream & operator>>( istream & theStream, Emu_Key_Macro_List & aMacroList )
    {
    aMacroList.mMacroCount = 0;

    theStream >> aMacroList.mMacroCount;

    for ( int i = 0; i < aMacroList.mMacroCount; i++ )
        {
        theStream >> aMacroList.mMacroList[i];
        }

    return theStream;
    }

//******************************************************************************
// Method:
//    operator<<
//
// Description:
//    Iostream inserter
//
// Arguments:
//    theStream  - The stream to insert into
//    aMacroList - The macrolist to stream out
//
// Returns:
//    istream & 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

ostream & operator<<( ostream & theStream, const Emu_Key_Macro_List & aMacroList )
    {
    theStream << aMacroList.mMacroCount << " ";

    for ( int i = 0; i < aMacroList.mMacroCount; i++ )
        {
        theStream << aMacroList.mMacroList[i] << " ";
        }
  
    return theStream;
    }

//******************************************************************************
// Method:
//    Emu_Key_Macro_List
//
// Description:
//    Constructor
//
// Arguments:
//    void
//
// Returns:
//    void
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro_List :: Emu_Key_Macro_List( void )
    :   mMacroCount( 0 )
    {
    return;
    }

//******************************************************************************
// Method:
//    ~Emu_Key_Macro_List
//
// Description:
//    Destructor
//
// Arguments:
//    void
//
// Returns:
//    void
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro_List :: ~Emu_Key_Macro_List( void )
    {
    return;
    }

//******************************************************************************
// Method:
//    operator[]
//
// Description:
//    Subscript operator
//
// Arguments:
//    aIndex - The index of the macro requested
//
// Returns:
//    Reference to the requested macro.
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

Emu_Key_Macro & Emu_Key_Macro_List :: operator[]( int aIndex )
    {
    if ( aIndex < 0 || aIndex >= mMacroCount )
        {
        return mMacroList[eMaxKeys];
        }

    return mMacroList[aIndex];
    }
        
//******************************************************************************
// Method:
//    addMacro
//
// Description:
//    Adds the specified macro to the list of macros
//
// Arguments:
//    aMacro - The macro to add
//
// Returns:
//    0 if all is ok, -1 if max macros exist, > 0 if duplicate found.
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

int Emu_Key_Macro_List :: addMacro( const Emu_Key_Macro & aMacro )
    {
    if ( mMacroCount == eMaxKeys )
        {
        return -1;
        }
        
    if ( int lIndex = find( aMacro ) >= 0 )
        {
        return lIndex;
        }
 
    mMacroList[ mMacroCount ] = aMacro;
    mMacroCount++;

    return 0;
    }

//******************************************************************************
// Method:
//    find
//
// Description:
//    Finds a macro in the list and retuens its index
//
// Arguments:
//    aKey   - The key to locate in the list
//    aMacro - The macro to find in the list   
//
// Returns:
//     -1 if the key or macro does not exist otherwise the index of the macro
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

int Emu_Key_Macro_List :: find( const Emu_Key_Macro & aMacro ) const
    {
    return find( aMacro.mKey );
    }
    
int Emu_Key_Macro_List :: find( const KEYDEF & aKey ) const
    {
    int lIndex = -1;

    for ( int i = 0; i < mMacroCount; i++ )
        {
        if ( mMacroList[i].mKey == aKey )
            {
            lIndex = i;
            break;
            }
        }
  
    return lIndex;
    }

//******************************************************************************
// Method:
//    load
//
// Description:
//    Loads the key list from the session file.
//    
// Arguments:
//    hSession - Session handle to use
//
// Returns:
//    0 if all is ok, -1 for an error 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

int Emu_Key_Macro_List :: load( const HSESSION hSession )
    {
    SF_HANDLE hSF   = sessQuerySysFileHdl( hSession );
    unsigned long lSize = 0;
    sfGetSessionItem( hSF, SFID_KEY_MACRO_LIST, &lSize, (void*)0 );
    
    int lReturnCode = 0;

    char * lBuffer = new char[lSize];

    if( sfGetSessionItem(hSF, SFID_KEY_MACRO_LIST, &lSize, lBuffer) == 0 )
        {
        istrstream lStream( lBuffer );
    
        lStream >> *this;
        }
    else
        {
        lReturnCode = -1;
        }

    delete[] lBuffer;

    return lReturnCode;
    }

//******************************************************************************
// Method:
//    numberOfMacros
//
// Description:
//    returns the number of macros in the list
//
// Arguments:
//    void
//
// Returns:
//    macro count 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int Emu_Key_Macro_List :: numberOfMacros( void ) const
    {
    return mMacroCount;
    }
        
//******************************************************************************
// Method:
//    removeMacro
//
// Description:
//     Removes the specified macro form the list
//
// Arguments:
//    aKey - The key to be removed
//
// Returns:
//     0 if error occured, non 0 if key was removed
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

int Emu_Key_Macro_List :: removeMacro( const KEYDEF & aKey )
    {
    int lIndex = find( aKey );

    if ( lIndex < 0 )
        {
        return 0;
        }

    for ( int i = lIndex; i < mMacroCount - lIndex + 1; i++ )
        {
        mMacroList[i] = mMacroList[i+1];
        }

    mMacroCount--;

    return 1;
    }

//******************************************************************************
// Method:
//    Save
//
// Description:
//    Saves the key list to the session file.
//    
// Arguments:
//    hSession - Session handle to use
//
// Returns:
//    0 if all is ok, -1 for an error 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/2/98
//
//

int Emu_Key_Macro_List :: save( const HSESSION hSession )
    {
    SF_HANDLE hSF   = sessQuerySysFileHdl( hSession );

    int lReturnCode = 0;

    strstream lStream;
    
    lStream << *this << ends << flush;

    if ( !lStream )
        {
        return -1;
        }

    char * lBuffer = lStream.str();

    if ( sfPutSessionItem( hSF, SFID_KEY_MACRO_LIST, strlen(lBuffer), lBuffer ) != 0 )
        {
        lReturnCode = -1;
        }

    lStream.rdbuf()->freeze(0);

    return lReturnCode;
    }

Emu_Key_Macro_List gMacroManager;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keymacro.h ===
#if defined INCL_KEY_MACROS
#if !defined EMU_KEY_MACRO_H
#define EMU_KEY_MACRO_H
#pragma once

//******************************************************************************
// File: \wacker\tdll\Keymacro.h  Created: 6/2/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//   This file represents a key macro.  It is a representation of a remapped key
//   and the key strokes it represents.
//
// $Revision: 4 $
// $Date: 12/27/01 2:15p $
// $Id: keymacro.h 1.2 1998/06/12 07:20:41 dmn Exp $
//
//******************************************************************************

#include <iostream.h>

#include "shared\classes\inc_cmp.h"

extern "C"
    {
    #include "keyutil.h"
    }

//
// Emu_Key_Macro
//
//------------------------------------------------------------------------------

class Emu_Key_Macro
    {
    INC_NV_COMPARE_DEFINITION( Emu_Key_Macro );

    friend istream & operator>>( istream & theStream, Emu_Key_Macro & aMacro );
    friend ostream & operator<<( ostream & theStream, const Emu_Key_Macro & aMacro );

public:

    enum 
        { 
        eMaxKeys = 100
        };

    //  
    // constructors and destructor
    //  
    //--------------------------------------------------------------------------    

    Emu_Key_Macro( void );                           
    Emu_Key_Macro( const Emu_Key_Macro & aMacro );

    ~Emu_Key_Macro( void );                  

    //  
    // assignment operator
    //
    //--------------------------------------------------------------------------

    Emu_Key_Macro & operator=( const Emu_Key_Macro & aMacro );
    Emu_Key_Macro & operator=( const keyMacro * aMacro );

public:

    KEYDEF  mKey;                 // Assigned key
    KEYDEF  mKeyMacro[eMaxKeys];  // Array to hold the macro KEYDEFs
    int     mMacroLen;            // # of hKeys in the macro
    };

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\key_sdlg.c ===
//******************************************************************************
// File: \wacker\TDLL\Key_sdlg.c  Created: 6/5/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This file is the key summary dialog procedure.  Its purpose is to display
//    a list of defined key macros and allow for the creation, modification and 
//    deletion of key macros.
//
// $Revision: 6 $
// $Date: 2/25/02 1:17p $
// $Id: key_sdlg.c 1.1 1998/06/11 12:03:53 dmn Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"
#include "mc.h"

#ifdef INCL_KEY_MACROS

#include <term\res.h>
#include "tdll.h"
#include "errorbox.h"
#include "globals.h"
#include "misc.h"
#include "hlptable.h"
#include "keyutil.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

#define IDC_LB_KEYS_KEYLIST 101
#define IDC_PB_KEYS_MODIFY  102
#define IDC_PB_KEYS_NEW     103
#define IDC_PB_KEYS_DELETE  104

//
// helper functions
//
    
static void setButtonState( HWND hDlg );
static int  getSelectedMacro( HWND hDlg, keyMacro * pMacro );

//******************************************************************************
// FUNCTION:
//  KeySummaryDlg
//
// DESCRIPTION:
//  This is the dialog proc for the key summary dialog. 
//
// ARGUMENTS:   Standard Windows dialog manager
//
// RETURNS:     Standard Windows dialog manager
//
//

BOOL CALLBACK KeySummaryDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
    {
    HWND    hwndChild;
    HWND    listBox;

    INT     nId;
    INT     nNtfy;
    INT     iTabStop;
    int     iRet = 0;
    int     lCurSelected;

    TCHAR   errorMsg[256];
    TCHAR   errorMsgFmt[256];
    TCHAR   msgTitle[100];

    TCHAR   keyName[35];

    keyMacro * pKeyMacro;

    static  DWORD aHlpTable[] = {IDC_LB_KEYS_KEYLIST , IDH_LB_KEYS_KEYLIST,
                                 IDC_PB_KEYS_MODIFY  , IDH_PB_KEYS_MODIFY,
                                 IDC_PB_KEYS_NEW     , IDH_PB_KEYS_NEW,   
                                 IDC_PB_KEYS_DELETE  , IDH_PB_KEYS_DELETE,
                                 IDCANCEL,                           IDH_CANCEL,
                                 IDOK,                               IDH_OK,
                                 0,                    0};                      

    //
    // process messages 
    //

    switch (wMsg)
        {
    case WM_INITDIALOG:
        {
        pKeyMacro = keysCreateKeyMacro();
        pKeyMacro->hSession = (HSESSION) lPar;

        if ( pKeyMacro == 0 )
            {
            EndDialog(hDlg, FALSE);
            }

        SetWindowLongPtr( hDlg, DWLP_USER, (LONG_PTR)pKeyMacro );

        mscCenterWindowOnWindow( hDlg, GetParent(hDlg) );

        iTabStop = 85;

        listBox = GetDlgItem( hDlg, IDC_LB_KEYS_KEYLIST );
        
        SendMessage( listBox, LB_SETTABSTOPS, (WPARAM)1, (LPARAM)&iTabStop );
        keysLoadSummaryList( listBox );
        SendMessage( listBox, LB_SETCURSEL, 0, 0 );
        setButtonState( hDlg );

        break;
        }

    case WM_DESTROY:
        pKeyMacro = (keyMacro *)GetWindowLongPtr(hDlg, DWLP_USER);
        free(pKeyMacro);
        pKeyMacro = 0;

        break;

    case WM_CONTEXTMENU:
        doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
        break;

    case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
        break;

    case WM_COMMAND:

        DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

        switch (nId)
            {
        case IDOK:
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case IDC_PB_KEYS_MODIFY:
            pKeyMacro = (keyMacro *)GetWindowLongPtr(hDlg, DWLP_USER);
            getSelectedMacro( hDlg, pKeyMacro );
            pKeyMacro->editMode = KEYS_EDIT_MODE_EDIT;

            if ( DoDialog(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_KEYDLG),
                          hDlg, KeyDlg, (LPARAM)pKeyMacro ))
                {
                listBox = GetDlgItem( hDlg, IDC_LB_KEYS_KEYLIST );
                keysLoadSummaryList( listBox );
                SendMessage( listBox, LB_SETCURSEL, 0, 0 );
                setButtonState( hDlg );
                }

            break;

        case IDC_PB_KEYS_NEW:
            pKeyMacro = (keyMacro *)GetWindowLongPtr(hDlg, DWLP_USER);
            keysResetKeyMacro( pKeyMacro );
            pKeyMacro->editMode = KEYS_EDIT_MODE_INSERT;

            if ( DoDialog(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_KEYDLG),
                          hDlg, KeyDlg, (LPARAM)pKeyMacro ))
                {
                listBox = GetDlgItem( hDlg, IDC_LB_KEYS_KEYLIST );
                keysLoadSummaryList( listBox );
                SendMessage( listBox, LB_SETCURSEL, 0, 0 );
                setButtonState( hDlg );
                }

            break;

        case IDC_PB_KEYS_DELETE:
            {
            LoadString(glblQueryDllHinst(), IDS_DELETE_KEY_MACRO,
                errorMsgFmt, sizeof(errorMsgFmt) / sizeof(TCHAR));

            LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, msgTitle,
                sizeof(msgTitle) / sizeof(TCHAR));

            pKeyMacro = (keyMacro *)GetWindowLongPtr(hDlg, DWLP_USER);
            listBox = GetDlgItem( hDlg, IDC_LB_KEYS_KEYLIST );
            lCurSelected = SendMessage( listBox, LB_GETCURSEL, 0, 0 );
            getSelectedMacro( hDlg, pKeyMacro );

            keysGetDisplayString( &pKeyMacro->keyName, 1,  keyName, sizeof(keyName) );
            wsprintf( errorMsg, errorMsgFmt, keyName );
 
            if ((iRet = TimedMessageBox(hDlg, errorMsg, msgTitle,
                MB_YESNO | MB_ICONEXCLAMATION, 0)) == IDYES)
                {
                keysRemoveMacro( pKeyMacro );
                keysLoadSummaryList( listBox );

                if ( lCurSelected > 0 )
                    {
                    lCurSelected--;
                    }

                SendMessage( listBox, LB_SETCURSEL, lCurSelected, 0 );
                setButtonState( hDlg );
                }
    
            break;
            }

        case IDC_LB_KEYS_KEYLIST:
            {
            switch ( nNtfy )
                {
            case LBN_SELCHANGE:
                setButtonState( hDlg );                    
                break;

            case LBN_DBLCLK:
                pKeyMacro = (keyMacro *)GetWindowLongPtr(hDlg, DWLP_USER);
                getSelectedMacro( hDlg, pKeyMacro );
                pKeyMacro->editMode = KEYS_EDIT_MODE_EDIT;
    
                DoDialog( glblQueryDllHinst(),
                        MAKEINTRESOURCE(IDD_KEYDLG),
                        hDlg,
                        KeyDlg,
                        (LPARAM)pKeyMacro );
                break;

            default:
                break;
                }
            }

        default:
            return FALSE;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }

//******************************************************************************
// Method:
//    getSelectedMacro
//
// Description:
//    Gets the definition of the selected macro from the macro summary list box.
//
// Arguments:
//    hDlg   - Handle to the key macro summary dialog
//    pMacro - Pointer to the keyMacro structure to fill
//
// Returns:
//    0 if an error occured, non zero if the key is retrieved.
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/5/98
//
//

int getSelectedMacro( HWND hDlg, keyMacro * pMacro )
    {
    HWND  listBox;
    int   lCurSelected;
    int   lSelectedMacro;

    listBox      = GetDlgItem( hDlg, IDC_LB_KEYS_KEYLIST );
    lCurSelected = SendMessage( listBox, LB_GETCURSEL, 0, 0 );

    if ( lCurSelected == LB_ERR )
        {
        return 0;
        }
    
    lSelectedMacro = SendMessage( listBox, LB_GETITEMDATA, lCurSelected, 0 );

    if ( lSelectedMacro == LB_ERR )
        {
        return 0;
        }

    return keysGetMacro( lSelectedMacro, pMacro );
    }

//******************************************************************************
// Method:
//    setButtonState
//
// Description:
//    Sets the states of the new, modify and delete buttons.
//
// Arguments:
//    HWND hDlg
//
// Returns:
//    void 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

void setButtonState( HWND hDlg )
    {
    BOOL fEnable = FALSE;
    int  nCount;
    HWND listBox;
    HWND modifyButton;
    HWND deleteButton;
    HWND newButton;

    listBox = GetDlgItem( hDlg, IDC_LB_KEYS_KEYLIST );
    nCount = SendMessage( listBox, LB_GETCOUNT, 0, 0 );

    if (nCount > 0)
        {
        EnableWindow(listBox, TRUE);
        fEnable = SendMessage( listBox, LB_GETCURSEL, 0, 0 ) != LB_ERR;

        //
        // do not allow more than keysMaxMacro keys macros to be defined
        //
    
        newButton = GetDlgItem( hDlg, IDC_PB_KEYS_NEW );

        if (nCount >= KEYS_MAX_MACROS)
            {
            EnableWindow( newButton, FALSE );
            }
        else
            {
            EnableWindow( newButton, TRUE );
            }
        }

    modifyButton = GetDlgItem( hDlg, IDC_PB_KEYS_MODIFY );
    deleteButton = GetDlgItem( hDlg, IDC_PB_KEYS_DELETE );

    EnableWindow( modifyButton, fEnable );
    EnableWindow( deleteButton, fEnable );

    if ( nCount <= 0 )
        {
        EnableWindow(listBox, FALSE);
        newButton = GetDlgItem( hDlg, IDC_PB_KEYS_NEW );
        SetFocus( newButton );
        }


    return;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keyutil.h ===
#if defined INCL_KEY_MACROS
#if !defined KEY_UTIL_H
#define KEY_UTIL_H
#pragma once 

//******************************************************************************
// File: \wacker\tdll\keyutilhc  Created: 6/4/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This file contains utility functions to handle keyboard macros and macro
//    GUI display.
// 
// $Revision: 1 $
// $Date: 10/05/98 12:37p $
// $Id: keyutil.h 1.1 1998/06/11 12:02:30 dmn Exp $
//
//******************************************************************************

#define KEYS_MAX_KEYS   100  // Max keydefs per macro
#define KEYS_MAX_MACROS 100  // Max macros for session

#define KEYS_EDIT_MODE_EDIT   0
#define KEYS_EDIT_MODE_INSERT 1

//
// keyMacro structure used in key dialogs and terminal key lookups
//

struct stKeyMacro
    {
    KEYDEF   keyName;                  // Assigned key
    KEYDEF   keyMacro[KEYS_MAX_KEYS];  // Array to hold the macro KEYDEFs
    int      macroLen;                 // # of hKeys in the macro
    int      editMode;                 // 0 = modify mode; 1 = insert mode
    int      altKeyValue;              // used to handle alt key sequences
    int      altKeyCount;              //    "    
    int      keyCount;                 // max keys allowed in edit control
    int      insertMode;               // flag for insert mode (special chars)
    HSESSION hSession;                 // Session handle
    WNDPROC  lpWndProc;                // old window procedure before key edit subclass
    };

typedef struct stKeyMacro keyMacro;

//
// these functions are declared external as they are used to interface
// to C++ classes.  These functions are declared extern "C" in the keyextrn file
// this has to be done in a CPP file.
//

extern int keysAddMacro( const keyMacro * pMarco );
extern int keysGetKeyCount( void );
extern int keysGetMacro( int aIndex, keyMacro * pMarco );
extern int keysFindMacro( const keyMacro * pMarco );
extern int keysLoadMacroList( HSESSION hSession );
extern int keysLoadSummaryList( HWND listBox );
extern int keysRemoveMacro( keyMacro * pMarco );
extern int keysSaveMacroList( HSESSION hSession );
extern int keysUpdateMacro( int aIndex, const keyMacro * pMarco );

//
// dialog and window procedure definitions for key macro dialogs and edit control
//

BOOL CALLBACK KeySummaryDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
BOOL CALLBACK KeyDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
LRESULT CALLBACK keyEditWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

//
// utility functions that do not need to access the C++ keymacro classes
//

keyMacro * keysCreateKeyMacro( void );
keyMacro * keysCloneKeyMacro( const keyMacro * aKeyMacro );
void keysResetKeyMacro( keyMacro * aKeyMacro );

int keysGetDisplayString( KEYDEF * pKeydef, int aNumKeys, LPTSTR aString, 
                          unsigned int aMaxLen );

int keysLookupKeyASCII( KEYDEF aKey, LPTSTR aKeyName, int aNameSize );
int keysLookupKeyHVK( KEYDEF aKey, LPTSTR aKeyName, int aNameSize );
int keysIsKeyHVK( KEYDEF aKey );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keyutil.c ===
//******************************************************************************
// File: \wacker\tdll\keyutil.c  Created: 6/4/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This file contains utility functions to handle keyboard macros and macro
//    GUI display.
// 
// $Revision: 7 $
// $Date: 3/26/02 8:32a $
// $Id: keyutil.c 1.4 1998/09/15 10:32:51 bld Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"
#include "mc.h"

#ifdef INCL_KEY_MACROS

#include "globals.h"
#include <term\res.h>
#include "keyutil.h"
#include "chars.h"
#include "htchar.h"

DWORD dwKeyLookup[] =
    {
    VK_LBUTTON,                    IDS_MACRO_BUTTON1,
    VK_MBUTTON,                    IDS_MACRO_BUTTON2,
    VK_RBUTTON,                    IDS_MACRO_BUTTON3,
    VK_CANCEL,                     IDS_MACRO_BREAK,
    VK_BACK,                       IDS_MACRO_BS,
    VK_TAB,                        IDS_MACRO_TAB,
    VK_PAUSE,                      IDS_MACRO_PAUSE,
    VK_PAUSE | ALT_KEY | EXTENDED_KEY, IDS_MACRO_INTERRUPT,
    VK_ESCAPE,                     IDS_MACRO_ESC,
    VK_PRIOR,                      IDS_MACRO_PAGEUP,
    VK_PRIOR | EXTENDED_KEY,       IDS_MACRO_PAGEUP,
    VK_NEXT,                       IDS_MACRO_PAGEDOWN,
    VK_NEXT | EXTENDED_KEY,        IDS_MACRO_PAGEDOWN,
    VK_END,                        IDS_MACRO_END,
    VK_END | EXTENDED_KEY,         IDS_MACRO_END,
    VK_HOME,                       IDS_MACRO_HOME,
    VK_HOME | EXTENDED_KEY,        IDS_MACRO_HOME,
    VK_LEFT,                       IDS_MACRO_LEFT,
    VK_LEFT | EXTENDED_KEY,        IDS_MACRO_LEFT,
    VK_UP,                         IDS_MACRO_UP,
    VK_UP | EXTENDED_KEY,          IDS_MACRO_UP,
    VK_RIGHT,                      IDS_MACRO_RIGHT,
    VK_RIGHT | EXTENDED_KEY,       IDS_MACRO_RIGHT,
    VK_DOWN,                       IDS_MACRO_DOWN,
    VK_DOWN | EXTENDED_KEY,        IDS_MACRO_DOWN,
    VK_CLEAR,                      IDS_MACRO_CENTER,
    VK_SNAPSHOT,                   IDS_MACRO_PRNTSCREEN,
    VK_INSERT,                     IDS_MACRO_INSERT,
    VK_INSERT | EXTENDED_KEY,      IDS_MACRO_INSERT,
    VK_DELETE,                     IDS_MACRO_DEL,
    VK_DELETE | EXTENDED_KEY,      IDS_MACRO_DEL,
    VK_RETURN,                     IDS_MACRO_ENTER,
    VK_RETURN | EXTENDED_KEY,      IDS_MACRO_NEWLINE,
    VK_F1,                         IDS_MACRO_F1,
    VK_F2,                         IDS_MACRO_F2,
    VK_F3,                         IDS_MACRO_F3,
    VK_F4,                         IDS_MACRO_F4,
    VK_F5,                         IDS_MACRO_F5,
    VK_F6,                         IDS_MACRO_F6,
    VK_F7,                         IDS_MACRO_F7,
    VK_F8,                         IDS_MACRO_F8,
    VK_F9,                         IDS_MACRO_F9,
    VK_F10,                        IDS_MACRO_F10,
    VK_F11,                        IDS_MACRO_F11,
    VK_F12,                        IDS_MACRO_F12,
    VK_F13,                        IDS_MACRO_F13,
    VK_F14,                        IDS_MACRO_F14,
    VK_F15,                        IDS_MACRO_F15,
    VK_F16,                        IDS_MACRO_F16,
    VK_F17,                        IDS_MACRO_F17,
    VK_F18,                        IDS_MACRO_F18,
    VK_F19,                        IDS_MACRO_F19,
    VK_F20,                        IDS_MACRO_F20,
    VK_F21,                        IDS_MACRO_F21,
    VK_F22,                        IDS_MACRO_F22,
    VK_F23,                        IDS_MACRO_F23,
    VK_F24,                        IDS_MACRO_F24,
    VK_EREOF,                      IDS_MACRO_EREOF,
    VK_PA1,                        IDS_MACRO_PA1,
    VK_ADD,                        IDS_MACRO_ADD,
    VK_ADD | EXTENDED_KEY,         IDS_MACRO_ADD,
    VK_SUBTRACT,                   IDS_MACRO_MINUS,
    VK_SUBTRACT | EXTENDED_KEY,    IDS_MACRO_MINUS,
    VK_DECIMAL,                    IDS_MACRO_NUMPADPERIOD,
    VK_NUMPAD0,                    IDS_MACRO_NUMPAD0,
    VK_NUMPAD1,                    IDS_MACRO_NUMPAD1,
    VK_NUMPAD2,                    IDS_MACRO_NUMPAD2,
    VK_NUMPAD3,                    IDS_MACRO_NUMPAD3,
    VK_NUMPAD4,                    IDS_MACRO_NUMPAD4,
    VK_NUMPAD5,                    IDS_MACRO_NUMPAD5,
    VK_NUMPAD6,                    IDS_MACRO_NUMPAD6,
    VK_NUMPAD7,                    IDS_MACRO_NUMPAD7,
    VK_NUMPAD8,                    IDS_MACRO_NUMPAD8,
    VK_NUMPAD9,                    IDS_MACRO_NUMPAD9,
    VK_DECIMAL,                    IDS_MACRO_DECIMAL,
    VK_RETURN,                     IDS_MACRO_ENTER,
    VK_DIVIDE,                     IDS_MACRO_FSLASH,
    VK_DIVIDE | EXTENDED_KEY,      IDS_MACRO_FSLASH,
    VK_MULTIPLY,                   IDS_MACRO_MULTIPLY,
    VK_MULTIPLY | EXTENDED_KEY,    IDS_MACRO_MULTIPLY,
    VK_NUMLOCK,                    IDS_MACRO_NUMLOCK,
    VK_SCROLL,                     IDS_MACRO_SCRLLOCK,
    VK_CAPITAL,                    IDS_MACRO_CAPSLOCK
    };

//******************************************************************************
// Method:
//    keysCreateKeyMacro
//
// Description:
//    Creates a blank key macro structure.  The caller is responsible for freeing
//    the memory
//
// Arguments:
//    void
//
// Returns:
//    keyMacro * 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/7/98
//
//

keyMacro * keysCreateKeyMacro( void )
    {
    keyMacro * pKeyMacro;
    pKeyMacro = (keyMacro *)malloc(sizeof(keyMacro));

    pKeyMacro->keyName     = 0;                
    pKeyMacro->macroLen    = 0;               
    pKeyMacro->editMode    = 0;               
    pKeyMacro->altKeyValue = 0;            
    pKeyMacro->altKeyCount = 0;            
    pKeyMacro->keyCount    = 0;               
    pKeyMacro->insertMode  = 0;             
    pKeyMacro->hSession    = 0;              
    pKeyMacro->lpWndProc   = 0;              

    memset( pKeyMacro->keyMacro, 0, KEYS_MAX_KEYS * sizeof(KEYDEF) );

    return pKeyMacro;
    }

//******************************************************************************
// Method:
//    keysCloneKeyMacro
//
// Description:
//    Creates an exact copy of the supplied key macro.  The caller is responsible
//    for freeing the allocated memory.
//
// Arguments:
//    aKeyMacro - The key macro to be cloned
//
// Returns:
//    keyMacro * 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/7/98
//
//

keyMacro * keysCloneKeyMacro( const keyMacro * aKeyMacro )
    {   
    keyMacro * pKeyMacro;
    pKeyMacro = (keyMacro *)malloc(sizeof(keyMacro));

    pKeyMacro->keyName     = aKeyMacro->keyName;                
    pKeyMacro->macroLen    = aKeyMacro->macroLen;               
    pKeyMacro->editMode    = aKeyMacro->editMode;               
    pKeyMacro->altKeyValue = aKeyMacro->altKeyValue;            
    pKeyMacro->altKeyCount = aKeyMacro->altKeyCount;            
    pKeyMacro->keyCount    = aKeyMacro->keyCount;               
    pKeyMacro->insertMode  = aKeyMacro->insertMode;             
    pKeyMacro->hSession    = aKeyMacro->hSession;              
    pKeyMacro->lpWndProc   = aKeyMacro->lpWndProc;              

    MemCopy( pKeyMacro->keyMacro, aKeyMacro->keyMacro, KEYS_MAX_KEYS );

    return pKeyMacro;
    }

//******************************************************************************
// Method:
//    keysGetDisplayString
//
// Description:
//    Formats a display string from the supplied keydefs
//
// Arguments:
//    pKeydef         - Pointer to keydefs
//    aNumKeys        - Number of keydefs to format
//    aDisplayString  - String to format into
//    aMaxLen         - Length of display string
//
// Returns:
//    0 for failure non zero for success 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysGetDisplayString( KEYDEF * pKeydef, int aNumKeys, LPTSTR aDisplayString,
                          unsigned int aMaxLen )
    {
    BOOL         fSpecial = FALSE;
    int          lIndex;
    KEYDEF       lKey;
    TCHAR        lKeyBuffer[35];
	unsigned int lMaxLen = aMaxLen / sizeof(TCHAR);

    TCHAR_Fill( aDisplayString, TEXT('\0'), lMaxLen );

    for ( lIndex = 0; lIndex < aNumKeys; lIndex++ )
        {
        lKey = pKeydef[lIndex];
        fSpecial = FALSE;

        //
        // Check for special character and add the necessary indicators
        //

        if ( lKey & CTRL_KEY || lKey & ALT_KEY || lKey & SHIFT_KEY ||
             lKey & VIRTUAL_KEY )
            {
            strcat( aDisplayString, TEXT("<") );
            fSpecial = TRUE;
            }

           if ( lKey & CTRL_KEY )
            {
            LoadString( glblQueryDllHinst(), IDS_MACRO_CTRL, lKeyBuffer,
                        sizeof(lKeyBuffer) / sizeof(TCHAR) );

            if ( (unsigned int)(StrCharGetStrLength( aDisplayString ) + StrCharGetStrLength( lKeyBuffer )) >= lMaxLen )
                {
                return 0;
                }

            strcat( aDisplayString, lKeyBuffer );
            }

        if ( lKey & ALT_KEY )
            {
            LoadString( glblQueryDllHinst(), IDS_MACRO_ALT, lKeyBuffer,
                        sizeof(lKeyBuffer) / sizeof(TCHAR) );

            if ( (unsigned int)(StrCharGetStrLength( aDisplayString ) + StrCharGetStrLength( lKeyBuffer )) >= lMaxLen )
                {
                return 0;
                }

            strcat( aDisplayString, lKeyBuffer );
            }

        if ( lKey & SHIFT_KEY )
            {
            LoadString( glblQueryDllHinst(), IDS_MACRO_SHIFT, lKeyBuffer,
                        sizeof(lKeyBuffer) / sizeof(TCHAR) );

            if ( (unsigned int)(StrCharGetStrLength( aDisplayString ) + StrCharGetStrLength( lKeyBuffer )) >= lMaxLen )                {
                return 0;
                }

            strcat( aDisplayString, lKeyBuffer );
            }

        //
        // Add on the actual key definition
        //

        if ( lKey & VIRTUAL_KEY )
            {
            if ( !keysLookupKeyHVK( lKey, lKeyBuffer, sizeof(lKeyBuffer) ) )
                {
                LoadString( glblQueryDllHinst(), IDS_MACRO_UNKNOWN, lKeyBuffer,
                            sizeof(lKeyBuffer) / sizeof(TCHAR) );
                }

            if ( (unsigned int)(StrCharGetStrLength( aDisplayString ) + StrCharGetStrLength( lKeyBuffer )) >= lMaxLen )
                {
                return 0;
                }

            strcat( aDisplayString, lKeyBuffer );
            }
        else
            {
            if ( !keysLookupKeyASCII( lKey, lKeyBuffer, sizeof(lKeyBuffer) / sizeof(TCHAR) ) )
                {
                LoadString( glblQueryDllHinst(), IDS_MACRO_UNKNOWN, lKeyBuffer,
                            sizeof(lKeyBuffer) / sizeof(TCHAR) );
                }

            if ( (unsigned int)(StrCharGetStrLength( aDisplayString ) + StrCharGetStrLength( lKeyBuffer )) >= lMaxLen )
                {
                return 0;
                }

            strcat( aDisplayString, lKeyBuffer );
            }

        //
        // if this is a special key add the trailing > character
        //

        if ( fSpecial )
            {
            strcat( aDisplayString, TEXT( ">" ) );
            }
        }

    return 1;
    }

//******************************************************************************
// Method:
//    keysIsKeyHVK
//
// Description:
//    Looks up a key definition and returns true if it is a virtual key
//
// Arguments:
//    aKey      - The key to lookup
//
// Returns:
//    0 if key was not found non zero if not
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysIsKeyHVK( KEYDEF aKey )
    {
    int nReturn = 0;
    int nIndex = 0;
    int nSizeLookup = sizeof(dwKeyLookup) / sizeof(dwKeyLookup[0]);

    aKey = (TCHAR)aKey;

    for (nIndex = 0; nIndex < nSizeLookup; nIndex += 2)
        {
        if ( (KEYDEF) dwKeyLookup[nIndex] == aKey )
            {
            nReturn = 1;
            break;
            }
        }

    return nReturn;
    }

//******************************************************************************
// Method:
//    keysLookupKeyHVK
//
// Description:
//    Looks up a key definition and returns a string representation
//
// Arguments:
//    aKey      - The key to lookup
//    aKeyName  - The string representation
//    aNameSize - Max length for returned name in bytes
//
// Returns:
//    0 if key was not found non zero if key name is filled in 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysLookupKeyHVK( KEYDEF aKey, LPTSTR aKeyName, int aNameSize )
    {
    int nReturn = 0;
    int nIndex = 0;
    int nSizeLookup = sizeof(dwKeyLookup) / sizeof(dwKeyLookup[0]);

    aKey = (TCHAR)aKey;

    for (nIndex = 0; nIndex < nSizeLookup; nIndex += 2)
        {
        if ( (KEYDEF) dwKeyLookup[nIndex] == aKey )
            {
            LoadString(glblQueryDllHinst(), dwKeyLookup[nIndex+1],
                aKeyName, aNameSize);
            nReturn = 1;
            break;
            }
        }

    return nReturn;
    }

//******************************************************************************
// Method:
//    keysLookupKeyASCII
//
// Description:
//    Looks up a key definition and returns a string representation
//    
// Arguments:
//    aKey      - The key to lookup
//    aKeyName  - The string representation
//    aNameSize - Max length for returned name in bytes
//
// Returns:
//    0 if key was not found non zero if key name is filled in 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/4/98
//
//

int keysLookupKeyASCII( KEYDEF aKey, LPTSTR aKeyName, int aNameSize )
    {
    int nReturn = 1;
    TCHAR lKey = (TCHAR)aKey;

    if ( lKey > 0xFF || lKey < 0 )
        {
        nReturn = 0;
        }
            
    //  
    // get non printable characters first
    //

    else if ( lKey < 0x20 || lKey > 0x7E )
        {
        switch( lKey )
            {
        case 0x00:
            StrCharCopyN( aKeyName, TEXT("<CTRL-@>"), aNameSize );
            break;

        case 0x01:
            StrCharCopyN( aKeyName, TEXT("<CTRL-A>"), aNameSize );
            break;

        case 0x02:
            StrCharCopyN( aKeyName, TEXT("<CTRL-B>"), aNameSize );
            break;

        case 0x03:
            StrCharCopyN( aKeyName, TEXT("<CTRL-C>"), aNameSize );
            break;

        case 0x04:
            StrCharCopyN( aKeyName, TEXT("<CTRL-D>"), aNameSize );
            break;

        case 0x05:
            StrCharCopyN( aKeyName, TEXT("<CTRL-E>"), aNameSize );
            break;

        case 0x06:
            StrCharCopyN( aKeyName, TEXT("<CTRL-F>"), aNameSize );
            break;

        case 0x07:
            StrCharCopyN( aKeyName, TEXT("<CTRL-G>"), aNameSize );
            break;

        case 0x08:
            StrCharCopyN( aKeyName, TEXT("<CTRL-H>"), aNameSize );
            break;

        case 0x09:
            StrCharCopyN( aKeyName, TEXT("<CTRL-I>"), aNameSize );
            break;

        case 0x0A:
            StrCharCopyN( aKeyName, TEXT("<CTRL-J>"), aNameSize );
            break;

        case 0x0B:
            StrCharCopyN( aKeyName, TEXT("<CTRL-K>"), aNameSize );
            break;

        case 0x0C:
            StrCharCopyN( aKeyName, TEXT("<CTRL-L>"), aNameSize );
            break;

        case 0x0D:
            StrCharCopyN( aKeyName, TEXT("<ENTER>"), aNameSize );
            break;

        case 0x0E:
            StrCharCopyN( aKeyName, TEXT("<CTRL-N>"), aNameSize );
            break;

        case 0x0F:
            StrCharCopyN( aKeyName, TEXT("<CTRL-O>"), aNameSize );
            break;

        case 0x10:
            StrCharCopyN( aKeyName, TEXT("<CTRL-P>"), aNameSize );
            break;

        case 0x11:
            StrCharCopyN( aKeyName, TEXT("<CTRL-Q>"), aNameSize );
            break;

        case 0x12:
            StrCharCopyN( aKeyName, TEXT("<CTRL-R>"), aNameSize );
            break;

        case 0x13:
            StrCharCopyN( aKeyName, TEXT("<CTRL-S>"), aNameSize );
            break;

        case 0x14:
            StrCharCopyN( aKeyName, TEXT("<CTRL-T>"), aNameSize );
            break;

        case 0x15:
            StrCharCopyN( aKeyName, TEXT("<CTRL-U>"), aNameSize );
            break;

        case 0x16:
            StrCharCopyN( aKeyName, TEXT("<CTRL-V>"), aNameSize );
            break;

        case 0x17:
            StrCharCopyN( aKeyName, TEXT("<CTRL-W>"), aNameSize );
            break;

        case 0x18:
            StrCharCopyN( aKeyName, TEXT("<CTRL-X>"), aNameSize );
            break;

        case 0x19:
            StrCharCopyN( aKeyName, TEXT("<CTRL-Y>"), aNameSize );
            break;

        case 0x1A:
            StrCharCopyN( aKeyName, TEXT("<CTRL-Z>"), aNameSize );
            break;

        case 0x1B:
            StrCharCopyN( aKeyName, TEXT("<ESC>"), aNameSize );
            break;

        case 0x1C:
            StrCharCopyN( aKeyName, TEXT("<CTRL-/>"), aNameSize );
            break;

        case 0x1D:
            StrCharCopyN( aKeyName, TEXT("<CTRL-]>"), aNameSize );
            break;

        case 0x1E:
            StrCharCopyN( aKeyName, TEXT("<CTRL-^>"), aNameSize );
            break;

        case 0x1F:
            StrCharCopyN( aKeyName, TEXT("<CTRL-_>"), aNameSize );
            break;

        case 0x7F:
            StrCharCopyN( aKeyName, TEXT("<ALT-127>"), aNameSize );
            break;

        case 0x80:
            StrCharCopyN( aKeyName, TEXT("<ALT-128>"), aNameSize );
            break;

        case 0x81:
            StrCharCopyN( aKeyName, TEXT("<ALT-129>"), aNameSize );
            break;

        case 0x82:
            StrCharCopyN( aKeyName, TEXT("<ALT-130>"), aNameSize );
            break;

        case 0x83:
            StrCharCopyN( aKeyName, TEXT("<ALT-131>"), aNameSize );
            break;

        case 0x84:
            StrCharCopyN( aKeyName, TEXT("<ALT-132>"), aNameSize );
            break;

        case 0x85:
            StrCharCopyN( aKeyName, TEXT("<ALT-133>"), aNameSize );
            break;

        case 0x86:
            StrCharCopyN( aKeyName, TEXT("<ALT-134>"), aNameSize );
            break;

        case 0x87:
            StrCharCopyN( aKeyName, TEXT("<ALT-135>"), aNameSize );
            break;

        case 0x88:
            StrCharCopyN( aKeyName, TEXT("<ALT-136>"), aNameSize );
            break;

        case 0x89:
            StrCharCopyN( aKeyName, TEXT("<ALT-137>"), aNameSize );
            break;

        case 0x8A:
            StrCharCopyN( aKeyName, TEXT("<ALT-138>"), aNameSize );
            break;

        case 0x8B:
            StrCharCopyN( aKeyName, TEXT("<ALT-139>"), aNameSize );
            break;

        case 0x8C:
            StrCharCopyN( aKeyName, TEXT("<ALT-140>"), aNameSize );
            break;

        case 0x8D:
            StrCharCopyN( aKeyName, TEXT("<ALT-141>"), aNameSize );
            break;

        case 0x8E:
            StrCharCopyN( aKeyName, TEXT("<ALT-142>"), aNameSize );
            break;

        case 0x8F:
            StrCharCopyN( aKeyName, TEXT("<ALT-143>"), aNameSize );
            break;

        case 0x90:
            StrCharCopyN( aKeyName, TEXT("<ALT-144>"), aNameSize );
            break;

        case 0x91:
            StrCharCopyN( aKeyName, TEXT("<ALT-145>"), aNameSize );
            break;

        case 0x92:
            StrCharCopyN( aKeyName, TEXT("<ALT-146>"), aNameSize );
            break;

        case 0x93:
            StrCharCopyN( aKeyName, TEXT("<ALT-147>"), aNameSize );
            break;

        case 0x94:
            StrCharCopyN( aKeyName, TEXT("<ALT-148>"), aNameSize );
            break;

        case 0x95:
            StrCharCopyN( aKeyName, TEXT("<ALT-149>"), aNameSize );
            break;

        case 0x96:
            StrCharCopyN( aKeyName, TEXT("<ALT-150>"), aNameSize );
            break;

        case 0x97:
            StrCharCopyN( aKeyName, TEXT("<ALT-151>"), aNameSize );
            break;

        case 0x98:
            StrCharCopyN( aKeyName, TEXT("<ALT-152>"), aNameSize );
            break;

        case 0x99:
            StrCharCopyN( aKeyName, TEXT("<ALT-153>"), aNameSize );
            break;

        case 0x9A:
            StrCharCopyN( aKeyName, TEXT("<ALT-154>"), aNameSize );
            break;

        case 0x9B:
            StrCharCopyN( aKeyName, TEXT("<ALT-155>"), aNameSize );
            break;

        case 0x9C:
            StrCharCopyN( aKeyName, TEXT("<ALT-156>"), aNameSize );
            break;

        case 0x9D:
            StrCharCopyN( aKeyName, TEXT("<ALT-157>"), aNameSize );
            break;

        case 0x9E:
            StrCharCopyN( aKeyName, TEXT("<ALT-158>"), aNameSize );
            break;

        case 0x9F:
            StrCharCopyN( aKeyName, TEXT("<ALT-159>"), aNameSize );
            break;

        case 0xA0:
            StrCharCopyN( aKeyName, TEXT("<ALT-160>"), aNameSize );
            break;

        case 0xA1:
            StrCharCopyN( aKeyName, TEXT("<ALT-161>"), aNameSize );
            break;

        case 0xA2:
            StrCharCopyN( aKeyName, TEXT("<ALT-162>"), aNameSize );
            break;

        case 0xA3:
            StrCharCopyN( aKeyName, TEXT("<ALT-163>"), aNameSize );
            break;

        case 0xA4:
            StrCharCopyN( aKeyName, TEXT("<ALT-164>"), aNameSize );
            break;

        case 0xA5:
            StrCharCopyN( aKeyName, TEXT("<ALT-165>"), aNameSize );
            break;

        case 0xA6:
            StrCharCopyN( aKeyName, TEXT("<ALT-166>"), aNameSize );
            break;

        case 0xA7:
            StrCharCopyN( aKeyName, TEXT("<ALT-167>"), aNameSize );
            break;

        case 0xA8:
            StrCharCopyN( aKeyName, TEXT("<ALT-168>"), aNameSize );
            break;

        case 0xA9:
            StrCharCopyN( aKeyName, TEXT("<ALT-169>"), aNameSize );
            break;

        case 0xAA:
            StrCharCopyN( aKeyName, TEXT("<ALT-170>"), aNameSize );
            break;

        case 0xAB:
            StrCharCopyN( aKeyName, TEXT("<ALT-171>"), aNameSize );
            break;

        case 0xAC:
            StrCharCopyN( aKeyName, TEXT("<ALT-172>"), aNameSize );
            break;

        case 0xAD:
            StrCharCopyN( aKeyName, TEXT("<ALT-173>"), aNameSize );
            break;

        case 0xAE:
            StrCharCopyN( aKeyName, TEXT("<ALT-174>"), aNameSize );
            break;

        case 0xAF:
            StrCharCopyN( aKeyName, TEXT("<ALT-175>"), aNameSize );
            break;

        case 0xB0:
            StrCharCopyN( aKeyName, TEXT("<ALT-176>"), aNameSize );
            break;

        case 0xB1:
            StrCharCopyN( aKeyName, TEXT("<ALT-177>"), aNameSize );
            break;

        case 0xB2:
            StrCharCopyN( aKeyName, TEXT("<ALT-178>"), aNameSize );
            break;

        case 0xB3:
            StrCharCopyN( aKeyName, TEXT("<ALT-179>"), aNameSize );
            break;

        case 0xB4:
            StrCharCopyN( aKeyName, TEXT("<ALT-180>"), aNameSize );
            break;

        case 0xB5:
            StrCharCopyN( aKeyName, TEXT("<ALT-181>"), aNameSize );
            break;

        case 0xB6:
            StrCharCopyN( aKeyName, TEXT("<ALT-182>"), aNameSize );
            break;

        case 0xB7:
            StrCharCopyN( aKeyName, TEXT("<ALT-183>"), aNameSize );
            break;

        case 0xB8:
            StrCharCopyN( aKeyName, TEXT("<ALT-184>"), aNameSize );
            break;

        case 0xB9:
            StrCharCopyN( aKeyName, TEXT("<ALT-185>"), aNameSize );
            break;

        case 0xBA:
            StrCharCopyN( aKeyName, TEXT("<ALT-186>"), aNameSize );
            break;

        case 0xBB:
            StrCharCopyN( aKeyName, TEXT("<ALT-187>"), aNameSize );
            break;

        case 0xBC:
            StrCharCopyN( aKeyName, TEXT("<ALT-188>"), aNameSize );
            break;

        case 0xBD:
            StrCharCopyN( aKeyName, TEXT("<ALT-189>"), aNameSize );
            break;

        case 0xBE:
            StrCharCopyN( aKeyName, TEXT("<ALT-190>"), aNameSize );
            break;

        case 0xBF:
            StrCharCopyN( aKeyName, TEXT("<ALT-191>"), aNameSize );
            break;

        case 0xC0:
            StrCharCopyN( aKeyName, TEXT("<ALT-192>"), aNameSize );
            break;

        case 0xC1:
            StrCharCopyN( aKeyName, TEXT("<ALT-193>"), aNameSize );
            break;

        case 0xC2:
            StrCharCopyN( aKeyName, TEXT("<ALT-194>"), aNameSize );
            break;

        case 0xC3:
            StrCharCopyN( aKeyName, TEXT("<ALT-195>"), aNameSize );
            break;

        case 0xC4:
            StrCharCopyN( aKeyName, TEXT("<ALT-196>"), aNameSize );
            break;

        case 0xC5:
            StrCharCopyN( aKeyName, TEXT("<ALT-197>"), aNameSize );
            break;

        case 0xC6:
            StrCharCopyN( aKeyName, TEXT("<ALT-198>"), aNameSize );
            break;

        case 0xC7:
            StrCharCopyN( aKeyName, TEXT("<ALT-199>"), aNameSize );
            break;

        case 0xC8:
            StrCharCopyN( aKeyName, TEXT("<ALT-200>"), aNameSize );
            break;

        case 0xC9:
            StrCharCopyN( aKeyName, TEXT("<ALT-201>"), aNameSize );
            break;

        case 0xCA:
            StrCharCopyN( aKeyName, TEXT("<ALT-202>"), aNameSize );
            break;

        case 0xCB:
            StrCharCopyN( aKeyName, TEXT("<ALT-203>"), aNameSize );
            break;

        case 0xCC:
            StrCharCopyN( aKeyName, TEXT("<ALT-204>"), aNameSize );
            break;

        case 0xCD:
            StrCharCopyN( aKeyName, TEXT("<ALT-205>"), aNameSize );
            break;

        case 0xCE:
            StrCharCopyN( aKeyName, TEXT("<ALT-206>"), aNameSize );
            break;

        case 0xCF:
            StrCharCopyN( aKeyName, TEXT("<ALT-207>"), aNameSize );
            break;

        case 0xD0:
            StrCharCopyN( aKeyName, TEXT("<ALT-208>"), aNameSize );
            break;

        case 0xD1:
            StrCharCopyN( aKeyName, TEXT("<ALT-209>"), aNameSize );
            break;

        case 0xD2:
            StrCharCopyN( aKeyName, TEXT("<ALT-210>"), aNameSize );
            break;

        case 0xD3:
            StrCharCopyN( aKeyName, TEXT("<ALT-211>"), aNameSize );
            break;

        case 0xD4:
            StrCharCopyN( aKeyName, TEXT("<ALT-212>"), aNameSize );
            break;

        case 0xD5:
            StrCharCopyN( aKeyName, TEXT("<ALT-213>"), aNameSize );
            break;

        case 0xD6:
            StrCharCopyN( aKeyName, TEXT("<ALT-214>"), aNameSize );
            break;

        case 0xD7:
            StrCharCopyN( aKeyName, TEXT("<ALT-215>"), aNameSize );
            break;

        case 0xD8:
            StrCharCopyN( aKeyName, TEXT("<ALT-216>"), aNameSize );
            break;

        case 0xD9:
            StrCharCopyN( aKeyName, TEXT("<ALT-217>"), aNameSize );
            break;

        case 0xDA:
            StrCharCopyN( aKeyName, TEXT("<ALT-218>"), aNameSize );
            break;

        case 0xDB:
            StrCharCopyN( aKeyName, TEXT("<ALT-219>"), aNameSize );
            break;

        case 0xDC:
            StrCharCopyN( aKeyName, TEXT("<ALT-220>"), aNameSize );
            break;

        case 0xDD:
            StrCharCopyN( aKeyName, TEXT("<ALT-221>"), aNameSize );
            break;

        case 0xDE:
            StrCharCopyN( aKeyName, TEXT("<ALT-222>"), aNameSize );
            break;

        case 0xDF:
            StrCharCopyN( aKeyName, TEXT("<ALT-223>"), aNameSize );
            break;

        case 0xE0:
            StrCharCopyN( aKeyName, TEXT("<ALT-224>"), aNameSize );
            break;

        case 0xE1:
            StrCharCopyN( aKeyName, TEXT("<ALT-225>"), aNameSize );
            break;

        case 0xE2:
            StrCharCopyN( aKeyName, TEXT("<ALT-226>"), aNameSize );
            break;

        case 0xE3:
            StrCharCopyN( aKeyName, TEXT("<ALT-227>"), aNameSize );
            break;

        case 0xE4:
            StrCharCopyN( aKeyName, TEXT("<ALT-228>"), aNameSize );
            break;

        case 0xE5:
            StrCharCopyN( aKeyName, TEXT("<ALT-229>"), aNameSize );
            break;

        case 0xE6:
            StrCharCopyN( aKeyName, TEXT("<ALT-230>"), aNameSize );
            break;

        case 0xE7:
            StrCharCopyN( aKeyName, TEXT("<ALT-231>"), aNameSize );
            break;

        case 0xE8:
            StrCharCopyN( aKeyName, TEXT("<ALT-232>"), aNameSize );
            break;

        case 0xE9:
            StrCharCopyN( aKeyName, TEXT("<ALT-233>"), aNameSize );
            break;

        case 0xEA:
            StrCharCopyN( aKeyName, TEXT("<ALT-234>"), aNameSize );
            break;

        case 0xEB:
            StrCharCopyN( aKeyName, TEXT("<ALT-235>"), aNameSize );
            break;

        case 0xEC:
            StrCharCopyN( aKeyName, TEXT("<ALT-236>"), aNameSize );
            break;

        case 0xED:
            StrCharCopyN( aKeyName, TEXT("<ALT-237>"), aNameSize );
            break;

        case 0xEE:
            StrCharCopyN( aKeyName, TEXT("<ALT-238>"), aNameSize );
            break;

        case 0xEF:
            StrCharCopyN( aKeyName, TEXT("<ALT-239>"), aNameSize );
            break;

        case 0xF0:
            StrCharCopyN( aKeyName, TEXT("<ALT-240>"), aNameSize );
            break;

        case 0xF1:
            StrCharCopyN( aKeyName, TEXT("<ALT-241>"), aNameSize );
            break;

        case 0xF2:
            StrCharCopyN( aKeyName, TEXT("<ALT-242>"), aNameSize );
            break;

        case 0xF3:
            StrCharCopyN( aKeyName, TEXT("<ALT-243>"), aNameSize );
            break;

        case 0xF4:
            StrCharCopyN( aKeyName, TEXT("<ALT-244>"), aNameSize );
            break;

        case 0xF5:
            StrCharCopyN( aKeyName, TEXT("<ALT-245>"), aNameSize );
            break;

        case 0xF6:
            StrCharCopyN( aKeyName, TEXT("<ALT-246>"), aNameSize );
            break;

        case 0xF7:
            StrCharCopyN( aKeyName, TEXT("<ALT-247>"), aNameSize );
            break;

        case 0xF8:
            StrCharCopyN( aKeyName, TEXT("<ALT-248>"), aNameSize );
            break;

        case 0xF9:
            StrCharCopyN( aKeyName, TEXT("<ALT-249>"), aNameSize );
            break;

        case 0xFA:
            StrCharCopyN( aKeyName, TEXT("<ALT-250>"), aNameSize );
            break;

        case 0xFB:
            StrCharCopyN( aKeyName, TEXT("<ALT-251>"), aNameSize );
            break;

        case 0xFC:
            StrCharCopyN( aKeyName, TEXT("<ALT-252>"), aNameSize );
            break;

        case 0xFD:
            StrCharCopyN( aKeyName, TEXT("<ALT-253>"), aNameSize );
            break;

        case 0xFE:
            StrCharCopyN( aKeyName, TEXT("<ALT-254>"), aNameSize );
            break;

        case 0xFF:
            StrCharCopyN( aKeyName, TEXT("<ALT-255>"), aNameSize );
            break;

        default:
            nReturn = 0;
            break;
            } // END OF SWITCH
        }

    else
        {
        TCHAR lBuffer[2];
        lBuffer[0] = lKey;
        lBuffer[1] = TEXT('\0');
        StrCharCopyN( aKeyName, lBuffer, aNameSize );
        }

    return nReturn;
    }

//******************************************************************************
// Method:
//    keysResetKeyMacro
//
// Description:
//    Clears a key macro structure.
//
// Arguments:
//    aKeyMacro - The key macro to be reset
//
// Returns:
//    keyMacro * 
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 6/7/98
//
//

void keysResetKeyMacro( keyMacro * aKeyMacro )
    {
    aKeyMacro->keyName     = 0;                
    aKeyMacro->macroLen    = 0;               
    aKeyMacro->editMode    = 0;               
    aKeyMacro->altKeyValue = 0;            
    aKeyMacro->altKeyCount = 0;            
    aKeyMacro->keyCount    = 0;               
    aKeyMacro->insertMode  = 0;             
    aKeyMacro->lpWndProc   = 0;              

    memset( aKeyMacro->keyMacro, 0, KEYS_MAX_KEYS * sizeof(KEYDEF) );

    return;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\key_dlg.c ===
//******************************************************************************
// File: \wacker\TDLL\KEY_DLG.C  Created: 6/5/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This file is the key dialog.  This allows for a key macro to be edited
//    or modified.
//
// $Revision: 6 $
// $Date: 8/15/01 4:50p $
// $Id: key_dlg.c 1.6 1998/09/10 16:10:17 bld Exp $
//
//******************************************************************************

#include <windows.h>
#pragma hdrstop
#include "stdtyp.h"
#include "mc.h"

#ifdef INCL_KEY_MACROS

#include <term\res.h>
#include "misc.h"
#include "hlptable.h"
#include "keyutil.h"
#include "errorbox.h"
#include <tdll\assert.h>
#include "globals.h"
#include <emu\emu.h>
#include "session.h"
#include "chars.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

#define IDC_EF_KEYS_KEYNAME        101
#define IDC_ML_KEYS_MACRO          105

BOOL isSystemKey( KEYDEF aKey );
BOOL isAcceleratorKey( KEYDEF aKey, UINT aTableId );
BOOL validateKey( keyMacro * pKeyMacro, HWND hDlg );

//******************************************************************************
// FUNCTION:
//  KeyDlg
//
// DESCRIPTION:
//  This is the dialog proc for the key macro dialog. 
//
// ARGUMENTS:   Standard Windows dialog manager
//
// RETURNS:     Standard Windows dialog manager
//
//

BOOL CALLBACK KeyDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
    {
    HWND    hwndChild;
    HWND    keyNameEdit;
    HWND    keyMacroEdit;

    INT     nId;
    INT     nNtfy;
    INT     keyIndex;

    TCHAR   keyName[35];
    TCHAR   keyList[2048];

    keyMacro * pKeyMacro;
    keyMacro * pKeyNameData;
    keyMacro * pKeyMacroData;

    static  DWORD aHlpTable[] = {IDC_EF_KEYS_KEYNAME      , IDH_EF_KEYS_KEYNAME,        
                                 IDC_ML_KEYS_MACRO        , IDH_ML_KEYS_MACRO,          
                                 IDCANCEL,                           IDH_CANCEL,
                                 IDOK,                               IDH_OK,
                                 0,                    0};                      

    //  
    // process messages
    //

    switch (wMsg)
        {
    case WM_INITDIALOG:
        pKeyMacro = (keyMacro *)lPar;

        if ( pKeyMacro == 0 )
            {
            EndDialog(hDlg, FALSE);
            }

        SetWindowLongPtr( hDlg, DWLP_USER, (LONG_PTR)pKeyMacro );

        //
        // set up the name edit field
        //

        keyNameEdit  = GetDlgItem( hDlg, IDC_EF_KEYS_KEYNAME );
        pKeyNameData = keysCloneKeyMacro( pKeyMacro );

        pKeyNameData->lpWndProc = (WNDPROC)GetWindowLongPtr( keyNameEdit, GWLP_WNDPROC );
        pKeyNameData->keyCount  = 1;

        SetWindowLongPtr( keyNameEdit, GWLP_WNDPROC,  (LONG_PTR)keyEditWindowProc );
        SetWindowLongPtr( keyNameEdit, GWLP_USERDATA, (LONG_PTR)pKeyNameData );

        //
        // set up the name edit field
        //
 
        keyMacroEdit  = GetDlgItem( hDlg, IDC_ML_KEYS_MACRO );
        pKeyMacroData = keysCloneKeyMacro( pKeyMacro );

        pKeyMacroData->lpWndProc = (WNDPROC)GetWindowLongPtr( keyMacroEdit, GWLP_WNDPROC );
        pKeyMacroData->keyCount  = KEYS_MAX_KEYS;

        SetWindowLongPtr( keyMacroEdit, GWLP_WNDPROC,  (LONG_PTR)keyEditWindowProc );
        SetWindowLongPtr( keyMacroEdit, GWLP_USERDATA, (LONG_PTR)pKeyMacroData );

        //
        // set up initial values if we are in edit mode
        //        

        if ( pKeyMacro->editMode == KEYS_EDIT_MODE_EDIT )
            {
            keysGetDisplayString( &pKeyMacro->keyName, 1,  keyName, sizeof(keyName) );
            SetDlgItemText( hDlg, IDC_EF_KEYS_KEYNAME, keyName );

            keysGetDisplayString( pKeyMacro->keyMacro, pKeyMacro->macroLen,  
                                  keyList, sizeof(keyList) );
            SetDlgItemText( hDlg, IDC_ML_KEYS_MACRO, keyList );
            }
                        
        mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

        break;

    case WM_DESTROY:
        keyNameEdit  = GetDlgItem( hDlg, IDC_EF_KEYS_KEYNAME );
        pKeyNameData = (keyMacro *) GetWindowLongPtr( keyNameEdit, GWLP_USERDATA );
        SetWindowLongPtr( keyNameEdit, GWLP_WNDPROC, (LONG_PTR)pKeyNameData->lpWndProc );
        free( pKeyNameData );
        pKeyNameData = 0;
 
        keyMacroEdit  = GetDlgItem( hDlg, IDC_ML_KEYS_MACRO );
        pKeyMacroData = (keyMacro *) GetWindowLongPtr( keyMacroEdit, GWLP_USERDATA );
        SetWindowLongPtr( keyMacroEdit, GWLP_WNDPROC, (LONG_PTR)pKeyMacroData->lpWndProc );
        free( pKeyMacroData );
        pKeyMacroData = 0;

        break;

    case WM_CONTEXTMENU:
        doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
        break;

    case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
        break;

    case WM_COMMAND:
        DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

        switch (nId)
            {
        case IDOK:
            keyNameEdit  = GetDlgItem( hDlg, IDC_EF_KEYS_KEYNAME );
            pKeyNameData = (keyMacro *) GetWindowLongPtr( keyNameEdit, GWLP_USERDATA );
 
            keyMacroEdit  = GetDlgItem( hDlg, IDC_ML_KEYS_MACRO );
            pKeyMacroData = (keyMacro *) GetWindowLongPtr( keyMacroEdit, GWLP_USERDATA );

            pKeyMacro = (keyMacro *)GetWindowLongPtr( hDlg, DWLP_USER );

            //
            // if we are in edit mode then update the previos macro with the 
            // edited macro
            //

            if ( pKeyMacro->editMode == KEYS_EDIT_MODE_EDIT )
                {
                keyIndex = keysFindMacro( pKeyMacro );
                assert( keyIndex >= 0 );

                if ( pKeyMacro->keyName != pKeyNameData->keyName &&
                     validateKey( pKeyNameData, hDlg ) == FALSE )
                    {
                    SetFocus( keyNameEdit );
                    break;
                    }

                //
                // combine the values from the name and macro edit controls
                // and update the previous macro with the new data
                //

                pKeyMacro->keyName = pKeyNameData->keyName;
                pKeyMacro->macroLen = pKeyMacroData->macroLen;
                if (pKeyMacroData->macroLen)
                    MemCopy( pKeyMacro->keyMacro, pKeyMacroData->keyMacro, 
                        pKeyMacroData->macroLen * sizeof(KEYDEF) );

                keysUpdateMacro( keyIndex, pKeyMacro );                
                }    

            else
                {
                if ( validateKey( pKeyNameData, hDlg ) == FALSE )
                    {
                    SetFocus( keyNameEdit );
                    break;
                    }

                //
                // combine the values from the name and macro edit controls
                // and add the new macro
                //

                pKeyMacro->keyName  = pKeyNameData->keyName;
                pKeyMacro->macroLen = pKeyMacroData->macroLen;
                if (pKeyMacroData->macroLen)
                    MemCopy( pKeyMacro->keyMacro, pKeyMacroData->keyMacro, 
                        pKeyMacroData->macroLen * sizeof(KEYDEF) );

                keysAddMacro( pKeyMacro );                
                }

            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }

//******************************************************************************
// Method:
//    isAcceleratorKey
//
// Description:
//    Checks if the key the user wants to define is already defined as a windows
//    accelerator key.
//    
// Arguments:
//    aKey     - The key to check
//    aTableId - The id of the accelerator table
//
// Returns:
//    True if the key is defined as an accelerator   
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/09/1998
//
//

BOOL isAcceleratorKey( KEYDEF aKey, UINT aTableId )
    {
    BOOL fIsAccelerator = FALSE;
    int iIndex; 
    int iAcceleratorEntries;
    KEYDEF lKeyDef;
    ACCEL * pAccelerators;

    HACCEL hAccel = LoadAccelerators( glblQueryDllHinst(),
                                      MAKEINTRESOURCE( aTableId ));

    if ( hAccel != NULL )
        {
        iAcceleratorEntries = CopyAcceleratorTable( hAccel, NULL, 0 );
        pAccelerators = (ACCEL*)malloc( sizeof(ACCEL) * iAcceleratorEntries);

        iAcceleratorEntries = CopyAcceleratorTable( hAccel, pAccelerators,
                                                    iAcceleratorEntries );

        for ( iIndex = 0; iIndex < iAcceleratorEntries; iIndex++ )
            {
            lKeyDef = pAccelerators[iIndex].key;

            if ( keysIsKeyHVK( lKeyDef ) )
                {
                lKeyDef |= VIRTUAL_KEY;
                }

            if ( pAccelerators[iIndex].fVirt & FALT )
                {
                lKeyDef |= ALT_KEY;
                }

            if ( pAccelerators[iIndex].fVirt & FCONTROL )
                {
                lKeyDef |= CTRL_KEY;
                }

            if ( pAccelerators[iIndex].fVirt & FSHIFT )
                {
                lKeyDef |= SHIFT_KEY;
                }

            if ( lKeyDef == aKey )
                {
                fIsAccelerator = TRUE;
                break;
                }
            }

        free( pAccelerators );
		pAccelerators = NULL;
        }

    return fIsAccelerator;
    }

//******************************************************************************
// Function:
//    isSystemKey
//
// Description:
//    Checks if the key the user wants to define is already defined as a windows
//    system key.  Note I could not find any way to get this information out of
//    the WIN32 API hence the hard coded table definition.
//
// Arguments:
//    aKeyDef - The key the user wants to define.
//
// Returns:
//    TRUE if the key is a windows system key.
//
// Author:  Dwayne Newsome 10/08/96
//

BOOL isSystemKey( KEYDEF aKeyDef )
    {
    int iIndex;

    KEYDEF aKeyDefList[2];
    BOOL fIsSystemKey = FALSE;

    aKeyDefList[0] = VK_F4 | VIRTUAL_KEY | ALT_KEY;
    aKeyDefList[1] = VK_F4 | VIRTUAL_KEY | CTRL_KEY;

    for ( iIndex = 0; iIndex < 2; iIndex++ )
        {
        if ( aKeyDefList[iIndex] == aKeyDef )
            {
            fIsSystemKey = TRUE;
            break;
            }
        }

    return fIsSystemKey;
    }

//******************************************************************************
// Method:
//    validateKey
//
// Description:
//    
// Arguments:
//    pKeyMacro - pointer to the key to be validated
//    hDlg      - Parent dialog used for error messages
//
// Returns:
//    True if the key is valid, false otherwise
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/09/1998
//
//

BOOL validateKey( keyMacro * pKeyMacro, HWND hDlg )
    {
    TCHAR   errorMsg[256];
    TCHAR   errorMsgFmt[256];
    TCHAR   msgTitle[100];
    TCHAR   keyName[35];

    int lNameLen = 0;

    KEYDEF aUserKey;

    HWND    keyNameEdit;

    HEMU hEmu;
    HSESSION hSession;

    //  
    // make sure a key has been entered
    //

    keyNameEdit  = GetDlgItem( hDlg, IDC_EF_KEYS_KEYNAME );
    lNameLen = SendMessage( keyNameEdit, EM_LINELENGTH, 0, 0 );
        
    if ( lNameLen == 0 )
        {
        LoadString(glblQueryDllHinst(), IDS_MISSING_KEY_MACRO,
            errorMsg, sizeof(errorMsg) / sizeof(TCHAR));
        
        LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, msgTitle,
            sizeof(msgTitle) / sizeof(TCHAR));

        TimedMessageBox(hDlg, errorMsg, msgTitle,
                        MB_OKCANCEL | MB_ICONEXCLAMATION, 0);

        return FALSE;
        }

    //  
    // make sure the key specified is not a duplicate
    //

    if ( keysFindMacro( pKeyMacro ) >= 0 )
        {
        LoadString(glblQueryDllHinst(), IDS_DUPLICATE_KEY_MACRO,
            errorMsgFmt, sizeof(errorMsgFmt) / sizeof(TCHAR));
        
        LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, msgTitle,
            sizeof(msgTitle) / sizeof(TCHAR));

        keysGetDisplayString( &pKeyMacro->keyName, 1,  keyName, 
                              sizeof(keyName) );
        wsprintf( errorMsg, errorMsgFmt, keyName );
 
        TimedMessageBox(hDlg, errorMsg, msgTitle,
                        MB_OK | MB_ICONEXCLAMATION, 0);

        return FALSE;
        }

    //  
    // warn user if the key specified is in use as a system key, emulator key or 
    // windows accelerator
    //

    hSession = pKeyMacro->hSession;
    assert(hSession);

    hEmu = sessQueryEmuHdl(hSession);
    assert(hEmu);

    aUserKey = pKeyMacro->keyName;

    if (( isAcceleratorKey( aUserKey, IDA_WACKER )) ||
        ( isSystemKey( aUserKey ))                  ||
        ( emuIsEmuKey( hEmu, aUserKey )))
        {
        LoadString(glblQueryDllHinst(), IDS_KEY_MACRO_REDEFINITION,
            errorMsgFmt, sizeof(errorMsgFmt) / sizeof(TCHAR));
        
        LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, msgTitle,
            sizeof(msgTitle) / sizeof(TCHAR));

        keysGetDisplayString( &aUserKey, 1,  keyName, sizeof(keyName) );
        wsprintf( errorMsg, errorMsgFmt, keyName );
 
        if ( TimedMessageBox(hDlg, errorMsg, msgTitle,
                             MB_YESNO | MB_ICONEXCLAMATION, 0) == IDNO )
            {
            return FALSE;
            }
        }

    return TRUE;
    }        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\keymlist.h ===
#ifdef INCL_KEY_MACROS
#if !defined (EMU_KEY_MACRO_LIST_H)
#define EMU_KEY_MACRO_LIST_H
#pragma once

//******************************************************************************
// File: \wacker\tdll\Keymlist.h  Created: 6/2/98 By: Dwayne M. Newsome
//
// Copyright 1998 by Hilgraeve Inc. --- Monroe, MI
// All rights reserved
// 
// Description:
//    This class manages the list of user defines key macros
// 
// $Revision: 1 $
// $Date: 10/05/98 12:42p $
// $Id: keymlist.h 1.1 1998/06/11 12:02:47 dmn Exp $
//
//******************************************************************************


#include <iostream.h>
#include "keymacro.h"

//
// Emu_Key_Macro_List
//
//------------------------------------------------------------------------------

class Emu_Key_Macro_List
    {

    friend istream & operator>>( istream & theStream, Emu_Key_Macro_List & aMacro );
    friend ostream & operator<<( ostream & theStream, const Emu_Key_Macro_List & aMacro );

public:

    enum 
        { 
        eMaxKeys = 100
        };

    //
    // constructor / destructor
    //
    //--------------------------------------------------------------------------

    Emu_Key_Macro_List( void );   
    ~Emu_Key_Macro_List( void ); 

    //
    // list managerment
    //
    // operator[]
    //    Returns the ith macro in the list
    //        
    // addMacro
    //    Adds new macro to the list.
    //
    // find
    //    Returns the index of the key or macro definition in the list.
    //
    // numberOfMacros
    //    returns the number of macros in the list
    //
    // removeMacro
    //    Removes the specified key from the macro list
    //
    //--------------------------------------------------------------------------

    Emu_Key_Macro & operator[]( int aIndex );

    int addMacro( const Emu_Key_Macro & aMacro );
    int find( const KEYDEF & aKey ) const;
    int find( const Emu_Key_Macro & aMacro ) const;
    int numberOfMacros( void ) const;
    int removeMacro( const KEYDEF & aKey );

    //
    // persistence methods
    //
    // load
    //    Loads the list from persistant storage
    //
    // save
    //    Saves the list to persistant storage
    //
    //--------------------------------------------------------------------------
    
    int load( const HSESSION hSession );
    int save( const HSESSION hSession );

private:

    int mMacroCount;

    Emu_Key_Macro mMacroList[eMaxKeys+1];

    Emu_Key_Macro_List( const Emu_Key_Macro_List & aMacroList );   
    Emu_Key_Macro_List & operator=( const Emu_Key_Macro_List & aMacroList );   
    };

extern Emu_Key_Macro_List gMacroManager;

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\load_res.c ===
/*	File: D:\WACKER\tdll\load_res.c (Created: 16-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 4/12/02 4:59p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "session.h"
#include "assert.h"

#include "tdll.h"
#include "htchar.h"
#include "load_res.h"

 #if defined(DEADWOOD)
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	resLoadDataBlock
 *
 * DESCRIPTION:
 *	This function is used to get a block of data stored in the resource file
 *	as an RCDATA item.	Note that in WIN32, it is not necessary to free the
 *	resource after it has been locked.
 *
 * PARAMETERS:
 *	hSession	-- the session handle
 *	pszName 	-- the id for the data block
 *	ppData		-- where to put the pointer to the data block
 *	pSize		-- addres of integer for size value
 *
 * RETURNS: 0 if successful, otherwise a defined error value.
 *
 *	The size of the resource that has been loaded (in bytes).
 *	NOTE:  The return value may be (and often is) larger than the actual
 *	size of the resource as it is defined in the rc file.  For resources
 *	of type RCDATA, the resource definition itself should include either a
 *	delimiter, or a count of the number of items included in that resource.
 *	See also RCDATA_TYPE in stdtype.h
 */
INT_PTR resLoadDataBlock(const HINSTANCE hInst,
						 const int id,
						 const void **ppData,
						 DWORD *pSize)
	{
	HGLOBAL hG = NULL;
	HRSRC hR = NULL;
	LPVOID pV = NULL;
	DWORD nSize = 0;

	if(pSize)
		{
		*pSize = nSize;
		}

	hR = FindResource(hInst, MAKEINTRESOURCE(id), (LPCTSTR)RT_RCDATA);
	if (hR == NULL)
		{
		assert(FALSE);
		return LDR_BAD_ID;
		}

	hG = LoadResource(hInst, hR);
	if (hG == NULL)
		{
		assert(FALSE);
		return LDR_NO_RES;
		}

	nSize = SizeofResource(hInst, hR);
	if (nSize == 0)
		{
		assert(FALSE);
		return LDR_NO_RES;
		}

	if(pSize)
		{
		*pSize = nSize;
		}

	pV = LockResource(hG);
	if (pV == 0)
		{
		assert(FALSE);
		return LDR_NO_RES;
		}

	if (ppData == NULL)
		{
		assert(FALSE);
		return LDR_BAD_PTR;
		}

	*ppData = pV;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	resFreeDataBlock
 *
 * DESCRIPTION:
 *	This function is not necessary for WIN32.
 *
 * PARAMETERS:
 *	hSession      -- the session handle
 *	pData         -- pointer to the data block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
INT_PTR resFreeDataBlock(const HSESSION hSession,
					 const void *pData)
	{
	return 0;
	}
#endif // defined(DEADWOOD)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	resLoadFileMask
 *
 * DESCRIPTION:
 *	This function is used to get around a problem that exists in loading
 *	strings into the common file dialogs.  The file name masks are two strings
 *	that are NULL separated.  This internal NULL is not treated with any
 *	respect by the resource functions, so we split them up and do a two part
 *	load to rebuild the string.
 *
 * PARAMETERS:
 *	hInst     -- the instance handle to use
 *	uId       -- the ID of the first resource to load
 *	nCount    -- the number of string PAIRS to load, starting a uId
 *	pszBuffer -- where to put the strings
 *	nSize     -- the size of the buffer in characters
 *
 * RETURNS:
 *	Zero if everything is OK, otherwise (-1)
 */
INT_PTR resLoadFileMask(HINSTANCE hInst,
					UINT uId,
					int nCount,
					LPTSTR pszBuffer,
					int nSize)
	{
	int i;
	LPTSTR pszEnd;
	LPTSTR pszPtr;

	if (pszBuffer == 0 || nSize == 0)
		{
		assert(0);
		return -1;
		}

	TCHAR_Fill(pszBuffer, TEXT('\0'), nSize);

	pszPtr = pszBuffer;
	pszEnd = pszBuffer + nSize;

	for (nCount *= 2 ; nCount > 0 ; --nCount)
		{
		i = LoadString(hInst, uId++, pszPtr, (int)(pszEnd - pszPtr - 1));
		pszPtr += (unsigned)i + sizeof(TCHAR);

		if (pszPtr >= pszEnd)
			{
			assert(0);
			return -1;
			}
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\makefile.inc ===
$(O)\ver_dll.i : ..\term\verdll.rc ..\term\version.h
    cl /nologo /D$(VERSION) /I$(SDK_INC_PATH) /Tc..\term\verdll.rc /E > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\load_res.h ===
/*	File: D:\WACKER\tdll\load_res.h (Created: 16-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 4/12/02 4:59p $
 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Error codes */
#define	LDR_ERR_BASE		0x300
#define	LDR_BAD_ID			LDR_ERR_BASE+1
#define	LDR_NO_RES			LDR_ERR_BASE+2
#define	LDR_BAD_PTR			LDR_ERR_BASE+3

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if defined(DEADWOOD)
extern INT_PTR resLoadDataBlock(const HINSTANCE hInst,
								const int id,
								const void **ppData,
								DWORD *pSize);

extern INT_PTR resFreeDataBlock(const HSESSION hSession,
								const void *pData);
#endif // defined(DEADWOOD)

extern INT_PTR resLoadFileMask(HINSTANCE hInst,
							   UINT uId,
							   int nCount,
							   LPTSTR pszBuffer,
							   int nSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\misc.h ===
/*	File: D:\WACKER\tdll\misc.h (Created: 27-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 4/16/02 2:40p $
 */

#if !defined(INCL_MISC)
#define INCL_MISC

BOOL 	mscCenterWindowOnWindow(const HWND hwndChild, const HWND hwndParent);

LPTSTR 	mscStripPath	(LPTSTR pszStr);
LPTSTR 	mscStripName	(LPTSTR pszStr);
LPTSTR 	mscStripExt		(LPTSTR pszStr);
LPTSTR	mscModifyToFit	(HWND hwnd, LPTSTR pszStr, DWORD style);

int 	mscCreatePath(const TCHAR *pszPath);
int 	mscIsDirectory(LPCTSTR pszName);
int 	mscAskWizardQuestionAgain(void);
void	mscUpdateRegistryValue(void);
void    mscResetComboBox(const HWND hwnd);

INT_PTR mscMessageBeep(UINT aBeep);
//
// The following function is from code mofified slightly
// from MSDN for determining if you are currently running as a
// remote session (Terminal Service). REV: 10/03/2001
//
INT_PTR IsTerminalServicesEnabled( VOID );
INT_PTR IsNT(void);
DWORD   GetWindowsMajorVersion(void);

#define PACKVERSION(major,minor) MAKELONG(minor,major)
DWORD   GetDllVersion(LPCTSTR lpszDllName);

HICON	extLoadIcon(LPCSTR);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\mc.h ===
/*      File: D:\WACKER\tdll\mc.h (Created: 30-Nov-1993)
 *
 *      Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *      All rights reserved
 *
 *      $Revision: 3 $
 *      $Date: 11/19/01 1:35p $
 */

#if !defined(INCL_MC)
#define INCL_MC

#include "assert.h"

// Use this file instead of malloc.  Makes include Smartheap easier.
//

#if defined(NDEBUG) || defined(NO_SMARTHEAP)
#include <malloc.h>
#else
#define MEM_DEBUG 1
//#include <nih\shmalloc.h>
#include <malloc.h>
#endif

#define MemCopy(_dst,_src,_cb)  { if ( (size_t)(_cb) == (size_t)0 || (_dst) == NULL || (_src) == NULL ) { assert(FALSE); } else { memcpy(_dst,_src,(size_t)(_cb)); } } 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\nagdlg.c ===
/*	File: D:\WACKER\tdll\telnetck.c (Created: 29-June-1998 by mpt)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description: Used to nag the user about purchasing HyperTerminal
 *               if they are in violation of the license agreement
 *
 *	$Revision: 11 $
 *	$Date: 5/17/02 11:33a $
 */

#include <windows.h>
#pragma hdrstop

#include "features.h"

#ifdef INCL_NAG_SCREEN

#include "assert.h"
#include "stdtyp.h"
#include "globals.h"
#include "htchar.h"
#include "registry.h"
#include "serialno.h"
#include <term\res.h>
#include "hlptable.h"
#include "tdll.h"
#include "nagdlg.h"
#include "errorbox.h"

#include <io.h>
//#include <time.h>

// Control IDs for the dialog:
//
#define IDC_PB_YES          IDOK
#define IDC_PB_NO           IDCANCEL
#define IDC_CK_STOP_ASKING  200
#define IDC_ST_QUESTION     201
#define IDC_IC_EXCLAMATION  202

// Registry key for HyperTerminal:
//
static const TCHAR g_achHyperTerminalRegKey[] =
    TEXT("SOFTWARE\\Hilgraeve Inc\\HyperTerminal PE\\3.0");

// Registry value for telnet checking:
//
static const TCHAR g_achInstallDate[] = TEXT("InstallDate");
static const TCHAR g_achIDate[] = TEXT("IDate");
static const TCHAR g_achLicense[] = TEXT("License");
static const TCHAR g_achSerial[] = TEXT("Registered");
INT elapsedTime = 0;
static const INT timeout = 15000;


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	IsEval
 *
 * DESCRIPTION:
 *  Determines whether the user should be nagged about purchasing HT
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
BOOL IsEval(void)
    {
    DWORD dwLicense = TRUE;
    DWORD dwSize = sizeof(dwLicense);

    // Get registry info
    //
    htRegQueryValue(HKEY_CURRENT_USER,
                    g_achHyperTerminalRegKey,
                    g_achLicense,
                    (LPBYTE) &dwLicense,
                    &dwSize);

    return (dwLicense == FALSE);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	IsTimeToNag
 *
 * DESCRIPTION:
 *  Base on the InstallDate, should we display a nag screen now?
 *  Every 5 times the app is run, the dialog is displayed
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
 BOOL IsTimeToNag(void)
    {
    DWORD dwNag   = TRUE;
    DWORD dwSize  = sizeof(dwNag);

    //check to see if we are past our 90 days
    if ( ExpDays() <= 0 ) 
        {
        return TRUE;
        }
    else
        {
        htRegQueryValue(HKEY_CURRENT_USER,
                        g_achHyperTerminalRegKey,
                        g_achInstallDate,
                        (LPBYTE) &dwNag,
                        &dwSize);

       regSetDwordValue(HKEY_CURRENT_USER, 
                        g_achHyperTerminalRegKey,
                        g_achInstallDate,
                        (dwNag == 0) ? (DWORD)4 : dwNag - (DWORD)1 );


        return dwNag == 0;
        }
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SetNagFlag
 *
 * DESCRIPTION:
 *	Sets the "nag" flag which will either turn off
 *  this feature the next time HyperTerminal starts.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
void SetNagFlag(TCHAR *serial)
    {

    //set the license flag to true
    regSetDwordValue( HKEY_CURRENT_USER, 
                    g_achHyperTerminalRegKey,
                    g_achLicense,
                    (DWORD)1 );

    //store the serial number
    regSetStringValue( HKEY_CURRENT_USER,
                    g_achHyperTerminalRegKey,
                    g_achSerial,
                    serial );

    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	ExpDays
 *
 * DESCRIPTION:
 *	Returns the number of days left in the evaluation period
 *
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR:  Mike Thompson 07-20-98
 */
int ExpDays(void)
    {
    time_t tToday, tSerial;
	int expDays = 15;
    
    tSerial = CalcExpirationDate();

    // Get the current time and then find elapsed time.
    time(&tToday);

    //return the number of days until expiration
	return (INT)(((tSerial - tToday + (expDays * 60 * 60 * 24) ) / (60 * 60 * 24)) + 1);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CalcExpirationDate
 *
 * DESCRIPTION:
 *	Returns the number of days left in the evaluation period
 *
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR:  Mike Thompson 07-20-98
 */
time_t CalcExpirationDate(void)
    {
    TCHAR atchSerialNumber[MAX_PATH * 2];
    DWORD dwSize = sizeof(atchSerialNumber);
    struct tm stSerial;
    time_t tSerial;
    TCHAR tday[2], tmonth[2], tyear[2];

    //get installation date from registry
    htRegQueryValue(HKEY_CURRENT_USER,
                    g_achHyperTerminalRegKey,
                    g_achIDate,
                    atchSerialNumber,
                    &dwSize);

    // Build a partial time structure.
    memset(&stSerial, 0, sizeof(struct tm));

    //set month
    strncpy(tmonth, &atchSerialNumber[0], 2);
    tmonth[2] = TEXT('\0');

    //set day
    strncpy(tday, &atchSerialNumber[3], 2);
    tday[2] = TEXT('\0');

    //set year
    strncpy(tyear, &atchSerialNumber[6], 2);
    tyear[2] = TEXT('\0');

    stSerial.tm_mday = atoi(tday);
    stSerial.tm_mon = atoi(tmonth) - 1; // tm counts from 0
    stSerial.tm_year = atoi(tyear); 

#if 0
    // Expiration date is 1st day of fourth calendar month from date
    // of issue.

    stSerial.tm_mon += 3;

    // Check for end of year wrap around.

    if (stSerial.tm_mon >= 12)
        {
        stSerial.tm_mon %= 12;
        stSerial.tm_year += 1;
        }
#endif

    // Convert into time_t time.

    if ((tSerial = mktime(&stSerial)) == -1)
        return 0;

    return tSerial;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	DoUpgradeDlg
 *
 * DESCRIPTION:
 *	Displays the upgrade dialog
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
 void DoUpgradeDlg(HWND hDlg)
    {
	int result;
	CHAR acExePath[MAX_PATH];
	CHAR acHTMFile[MAX_PATH];
 	LPTSTR pszPtr;
    TCHAR ErrorMsg[80];
 	struct _finddata_t c_file;
	long hFile;

    acExePath[0] = TEXT('\0');
	result = GetModuleFileName(glblQueryHinst(), acExePath, MAX_PATH);
	
    //strip off executable
	if (result != 0)
		{
		pszPtr = strrchr(acExePath, TEXT('\\'));
		*pszPtr = TEXT('\0');
		}
		
	//build path to htorder.exe
	acHTMFile[0] = TEXT('\0');
	strcat(acHTMFile, acExePath);
	strcat(acHTMFile, TEXT("\\"));
	strcat(acHTMFile, TEXT("Purchase Private Edition.exe"));

	//check if file exists

	hFile = _findfirst( acHTMFile, &c_file );
	if ( hFile != -1 )
		{
		ShellExecute(NULL, "open", acHTMFile, NULL, NULL, SW_SHOW);
		return;
		}
    else
        {
        wsprintf( ErrorMsg,
                  "Could not find %s.\n\nThis file is needed to display purchase information.",
                  acHTMFile );
        
        TimedMessageBox(hDlg, ErrorMsg,	NULL, MB_OK | MB_ICONEXCLAMATION, 0);
        }
    
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	DoRegisterDlg
 *
 * DESCRIPTION:
 *	Displays the register dialog
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
 void DoRegisterDlg(HWND hDlg)
    {
	DoDialog(glblQueryDllHinst(),
        MAKEINTRESOURCE(IDD_NAG_REGISTER),
        hDlg,
        NagRegisterDlgProc,
        0);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	DefaultNagDlgProc
 *
 * DESCRIPTION:
 *	The dialog procedure for the "Nag" dialog.
 *
 * PARAMETERS:
 *	hDlg - The dialog's window handle.
 *  wMsg - The message being sent to the window.
 *  wPar - The message's wParam.
 *  lPar - The message's lParam.
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
BOOL CALLBACK DefaultNagDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
    {
    TCHAR  expString[MAX_PATH];
    INT    exp;
	static DWORD aHlpTable[] = {IDCANCEL,          IDH_CANCEL,
                                 IDOK,              IDH_OK,
								 0, 				0};

	switch (wMsg)
		{
    case WM_INITDIALOG:
        //initialize text on this dialog
        exp = ExpDays();
        if ( exp <= 0 )
            {
            SetDlgItemText(hDlg, IDC_NAG_EXP_DAYS, TEXT("Your evaluation period has expired."));
            }
        else
            {
            GetDlgItemText(hDlg, IDC_NAG_EXP_DAYS, expString, MAX_PATH);
            wsprintf(expString, expString, exp); 
            SetDlgItemText(hDlg, IDC_NAG_EXP_DAYS, expString);
            }

        //set a timer to destroy the dialog after a while
        SetTimer(hDlg, 1, 1000, 0);
        break;

    case WM_TIMER:
        //Get rid of Window
        elapsedTime += 1000;

        if (elapsedTime >= timeout)
            {
            // Destroy the dialog
			EndDialog(hDlg, FALSE);
            }

        else
            {
            if (GetDlgItem(hDlg, IDC_NAG_TIME))
                {
                TCHAR temp[10];
                _itoa((timeout - elapsedTime + 500) / 1000, temp, 10);
                SetDlgItemText(hDlg, IDC_NAG_TIME, temp);
                }
            }
        break;

    case WM_DESTROY:
		EndDialog(hDlg, FALSE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
        case IDOK:
   			EndDialog(hDlg, FALSE);
            break;

        case IDC_NAG_CODE:
            DoRegisterDlg(hDlg);
			break;

		case IDC_NAG_PURCHASE:
            DoUpgradeDlg(hDlg);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	NagRegisterDlgProc
 *
 * DESCRIPTION:
 *	The dialog procedure for the "Nag Register" dialog.
 *
 * PARAMETERS:
 *	hDlg - The dialog's window handle.
 *  wMsg - The message being sent to the window.
 *  wPar - The message's wParam.
 *  lPar - The message's lParam.
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  Mike Thompson 06-29-98
 */
BOOL CALLBACK NagRegisterDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
    {
    TCHAR  buffer[MAX_USER_SERIAL_NUMBER + sizeof(TCHAR)];
	static DWORD aHlpTable[] = {IDCANCEL,          IDH_CANCEL,
                                 IDOK,              IDH_OK,
								 0, 				0};

	switch (wMsg)
		{
    case WM_INITDIALOG:
        break;

    case WM_SHOWWINDOW:
        SetFocus( GetDlgItem(hDlg, IDC_REGISTER_EDIT) );

		//
		// Limit the length of text a user can enter for a registeration
		// code to the maximum serial number length.  REV 8/27/98.
		//
		SendMessage(GetDlgItem(hDlg, IDC_REGISTER_EDIT), EM_LIMITTEXT,
			        MAX_USER_SERIAL_NUMBER, 0);
        break;

    case WM_DESTROY:
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
            GetDlgItemText(hDlg, IDC_REGISTER_EDIT, buffer,
				           sizeof(buffer)/sizeof(TCHAR));
            if ( IsValidSerialNumber(buffer) == TRUE ) 
                {
                SetNagFlag(buffer);
                elapsedTime = timeout;  //get rid of parent window
    			EndDialog(hDlg, FALSE);
                }
            else
                {
                TimedMessageBox(hDlg, "Invalid registration code.",
                                NULL, MB_OK | MB_ICONEXCLAMATION, 0);
                SetFocus( GetDlgItem(hDlg, IDC_REGISTER_EDIT) );
                }
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\nagdlg.h ===
#if !defined(INCL_NAG)
#define INCL_NAG

/*	File: D:\WACKER\tdll\nagdlg.h (Created: 29-June-1996 by mpt)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description:
 *  Description: Used to nag the user about purchasing HyperTerminal
 *               if they are in violation of the license agreement
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:34p $
 */

#include <time.h>

//	IsEval
//
//  Determines whether the user should be nagged about purchasing HT
//
BOOL IsEval(void);

//	IsTimeToNag
//
//  Base on the InstallDate, should we display a nag screen now?
//
BOOL IsTimeToNag(void);

//	SetNagFlag
//
//	Sets the "nag" flag which will either turn off
//  this feature the next time HyperTerminal starts.
//
void SetNagFlag(TCHAR *serial);

//	DoUpgradeDlg
//
//	Displays the upgrade dialog
// 
void DoUpgradeDlg(HWND hDlg);

//	ExpDays
//
//	Returns the number of days left in the evaluation period
// 
INT ExpDays(void);
time_t CalcExpirationDate(void);

//	DoRegisterDlg
//
//	Displays the register dialog
// 
void DoRegisterDlg(HWND hDlg);

// NagRegisterDlgProc
//
//	The dialog procedure for the "Nag Register" dialog.
//
BOOL CALLBACK NagRegisterDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

// DefaultNagDlgProc
//
//	The dialog procedure for the "Nag" dialog.
//
BOOL CALLBACK DefaultNagDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\misc.c ===
/*	File: D:\WACKER\tdll\misc.c (Created: 27-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 14 $
 *	$Date: 7/12/02 12:29p $
 */

#include <windows.h>
#pragma hdrstop
#include <Shlwapi.h>

#include "stdtyp.h"
#include "misc.h"
#include "tdll.h"
#include "htchar.h"
#include "globals.h"
#include "assert.h"
#include <term\res.h>

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	mscCenterWindowOnWindow
 *
 * DESCRIPTION:
 *	Center's first window on the second window.  Assumes hwndChild is
 *	a direct descendant of hwndParent
 *
 * ARGUMENTS:
 *	hwndChild	- window to center
 *	hwndParent	- window to center on
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL mscCenterWindowOnWindow(const HWND hwndChild, const HWND hwndParent)
	{
	RECT	rChild, rParent;
	int 	wChild, hChild, wParent, hParent;
	int 	xNew, yNew;
	int 	iMaxPos;

	if (!IsWindow(hwndParent))
		return FALSE;

	if (!IsWindow(hwndChild))
		return FALSE;

	/* --- Get the Height and Width of the child window --- */

	GetWindowRect(hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	/* --- Get the Height and Width of the parent window --- */

	GetWindowRect(hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	/* --- Calculate new X position, then adjust for screen --- */

	xNew = rParent.left + ((wParent - wChild) / 2);

	/* --- Calculate new Y position, then adjust for screen --- */

	// Let's display the dialog so that the title bar is visible.
	//
	iMaxPos = GetSystemMetrics(SM_CYSCREEN);
	yNew = min(iMaxPos, rParent.top + ((hParent - hChild) / 2));

	//mpt:3-13-98 Need to make sure dialog is not off the screen
    if (yNew < 0)
        {
        yNew = 0;
        }

    if (xNew < 0)
        {
        xNew = 0;
        }

    // Set it, and return
	//
	return SetWindowPos(hwndChild, 0, xNew, yNew, 0, 0,
		SWP_NOSIZE | SWP_NOZORDER);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  mscStripPath
 *
 * DESCRIPTION:
 *	Strip off the path from the file name.
 *
 * ARGUMENTS:
 * 	pszStr - pointer to a null terminated string.
 *
 * RETURNS:
 *  void.
 */
LPTSTR mscStripPath(LPTSTR pszStr)
	{
	LPTSTR pszStart, psz;

	if (pszStr == 0)
		{
		return 0;
		}

	for (psz = pszStart = pszStr; *psz ; psz = StrCharNext(psz))
		{
		if (*psz == TEXT('\\') || *psz == TEXT(':'))
			pszStart = StrCharNext(psz);
		}

	StrCharCopyN(pszStr, pszStart, StrCharGetStrLength(pszStr));
	return pszStr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  mscStripName
 *
 * DESCRIPTION:
 *	Strip off the name of the file, leave just the path.
 *
 * ARGUMENTS:
 * 	pszStr - pointer to a null terminated string.
 *
 * RETURNS:
 *  void.
 */
LPTSTR mscStripName(LPTSTR pszStr)
	{
	LPTSTR pszEnd, pszStart = pszStr;

	if (pszStr == 0)
		return 0;

	for (pszEnd = pszStr; *pszStr; pszStr = StrCharNext(pszStr))
		{
		if (*pszStr == TEXT('\\') || *pszStr == TEXT(':'))
			pszEnd = StrCharNext(pszStr);
		}

	*pszEnd = TEXT('\0');
	return (pszStart);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  mscStripExt
 *
 * DESCRIPTION:
 *	Strip off the file extension.  The parameter string can be a full-path
 *	or just a file name.
 *
 * ARGUMENTS:
 * 	pszStr - pointer to a null terminated string.
 *
 * RETURNS:
 *  void.
 */
LPTSTR mscStripExt(LPTSTR pszStr)
	{
	LPTSTR pszEnd, pszStart = pszStr;

	for (pszEnd = pszStr; *pszStr; pszStr = StrCharNext(pszStr))
		{
		// Need to check for both '.' and '\\' because directory names
		// can have extensions as well.
		//
		if (*pszStr == TEXT('.') || *pszStr == TEXT('\\'))
			pszEnd = pszStr;
		}

	if (*pszEnd == TEXT('.'))
		*pszEnd = TEXT('\0');

	return pszStart;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  mscModifyToFit
 *
 * DESCRIPTION:
 *  If a string won't fit in a given window then chop-off as much as possible
 *  to be able to display a part of the string with ellipsis concatanated to
 *  the end of it.
 *
 *  NOTE: I've attempted to make this code DBCS aware.
 *
 * ARGUMENTS:
 *  hwnd 	- control window, where the text is to be displayed.
 *  pszStr 	- pointer to the string to be displayed.
 *  style  - The control style for ellipsis.
 *
 * RETURNS:
 *  lpszStr - pointer to the modified string.
 *
 */
LPTSTR mscModifyToFit(HWND hwnd, LPTSTR pszStr, DWORD style)
	{
	if (!IsWindow(hwnd) || pszStr == NULL)
		{
		assert(FALSE);
		}
	else if (IsNT())
		{
		DWORD ExStyle;

		ExStyle = (DWORD)GetWindowLongPtr(hwnd, GWL_STYLE);

		if (!(ExStyle & style))
			{
			SetWindowLongPtr(hwnd, GWL_STYLE, (LONG_PTR)(ExStyle | style));
			}
		}
	else
		{
		HDC	 	hDC;
		SIZE	sz;
		HFONT	hFontSave, hFont;
		RECT	rc;
		int		nWidth = 0;

		memset(&hFont, 0, sizeof(HFONT));
		memset(&hFontSave, 0, sizeof(HFONT));
		memset(&rc, 0, sizeof(RECT));

		GetWindowRect(hwnd, &rc);
		nWidth = rc.right - rc.left;

		hDC = GetDC(hwnd);

		hFont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
		if (hFont)
			{
			hFontSave = SelectObject(hDC, hFont);
			}

		// TODO: I think here the string pszStr would have to be "deflated"
		// before we continue.  The rest of the code should stay the same.
		//
		GetTextExtentPoint(hDC, (LPCTSTR)pszStr, StrCharGetStrLength(pszStr), &sz);
		if (sz.cx > nWidth)
			{
			int   nEllipsisLength = 0;
			int   i = 0;
			TCHAR ach[512];
			TCHAR achEllipsis[10];

			TCHAR_Fill(ach, TEXT('\0'), 512);
			TCHAR_Fill(achEllipsis, TEXT('\0'), 10);

			LoadString(glblQueryDllHinst(), IDS_GNRL_ELLIPSIS,
				       achEllipsis, 10);

			nEllipsisLength = StrCharGetStrLength(achEllipsis);

			StrCharCopyN(ach, pszStr, (sizeof(ach) - nEllipsisLength) / sizeof(TCHAR));
			StrCharCat(ach, achEllipsis);

			i = StrCharGetStrLength(ach);

			while ((i > nEllipsisLength) && (sz.cx > nWidth))
				{
				GetTextExtentPoint(hDC, ach, i, &sz);
				i -= 1;
				ach[i - nEllipsisLength] = TEXT('\0');
				StrCharCat(ach, achEllipsis);
				}

			// Now copy the temporary string back into the original buffer.
			//
			StrCharCopyN(pszStr, ach, sizeof(ach) / sizeof(TCHAR));
			}

		// Select the previously selected font, release DC.
		//
		if (hFontSave)
			{
			SelectObject(hDC, hFontSave);
			}
		ReleaseDC(hwnd, hDC);
		}

	return pszStr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	mscResetComboBox
 *
 * DESCRIPTION:
 *	The modem combobox allocates memory to store info about each item.
 *	This routine will free those allocated chunks.
 *
 * ARGUMENTS:
 *	hwnd	- window handle to combobox
 *
 * RETURNS:
 *	void
 *
 */
void mscResetComboBox(const HWND hwnd)
	{
	void *pv = NULL;
	LRESULT lr, i;

	if (!IsWindow(hwnd))
		{
		return;
		}

	if ((lr = SendMessage(hwnd, CB_GETCOUNT, 0, 0)) != CB_ERR)
		{
		for (i = 0 ; i < lr ; ++i)
			{
			if (((LRESULT)pv = SendMessage(hwnd, CB_GETITEMDATA, (WPARAM)i, 0))
					!= CB_ERR)
				{
				if (pv)
					{
					free(pv);
					pv = NULL;
					}
				}
			}
		}

	SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	extLoadIcon
 *
 * DESCRIPTION:
 *	Gets the icon from the hticons.dll.  The extension handlers use
 *	this dll for icons and need to not link load anything more than
 *	absolutely necessary, otherwise, this function would go in the
 *	icon handler code.
 *
 * ARGUMENTS:
 *	id	- string id of resource (can be MAKEINTRESOURCE)
 *
 * RETURNS:
 *	HICON or zero on error.
 *
 */
HICON extLoadIcon(LPCSTR id)
	{
	static HINSTANCE hInstance;

	if (hInstance == 0)
		{
		if ((hInstance = LoadLibrary("hticons")) == 0)
			{
			assert(FALSE);
			return 0;
			}
		}

	return LoadIcon(hInstance, id);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	mscCreatePath
 *
 * DESCRIPTION:
 *	Creates the given path.  This function is somewhat tricky so study
 *	it carefully before modifying it.  Despite it's simplicity, it
 *	accounts for all boundary conditions. - mrw
 *
 * ARGUMENTS:
 *	pszPath - path to create
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int mscCreatePath(const TCHAR *pszPath)
	{
	TCHAR ach[512];
	TCHAR *pachTok;

	if (pszPath == 0)
		return -1;

	StrCharCopyN(ach, pszPath, sizeof(ach) / sizeof(TCHAR));
	pachTok = ach;

	// Basicly, we march along the string until we encounter a '\', flip
	// it to a NULL and try to create the path up to that point.
	// It would have been nice if CreateDirectory() could
	// create sub/sub directories, but it don't. - mrw
	//
	while (1)
		{
		if ((pachTok = StrCharFindFirst(pachTok, TEXT('\\'))) == 0)
			{
			if (!mscIsDirectory(ach) && !CreateDirectory(ach, 0))
				return -2;

			break;
			}

		if (pachTok != ach)
			{
			*pachTok = TEXT('\0');

			if (!mscIsDirectory(ach) && !CreateDirectory(ach, 0))
				return -3;

			*pachTok = TEXT('\\');
			}

		pachTok = StrCharNext(pachTok);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	mscIsDirectory
 *
 * DESCRIPTION:
 *	Checks to see if a string is a valid directory or not.
 *
 * PARAMETERS:
 *	pszName   -- the string to test
 *
 * RETURNS:
 *	TRUE if the string is a valid directory, otherwise FALSE.
 *
 */
int mscIsDirectory(LPCTSTR pszName)
	{
	DWORD dw;

	dw = GetFileAttributes(pszName);

	if ((dw != (DWORD)-1) && (dw & FILE_ATTRIBUTE_DIRECTORY))
		return TRUE;

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	mscAskWizardQuestionAgain
 *
 * DESCRIPTION:
 *	Reads a value from the Registry.  This value represents how many times
 *	the user responded "NO" to the question:  "Do you want to run the
 *	New Modem Wizard?".  We won't ask this question any more if the
 *	user responded no, twice.
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	TRUE if the modem wizard question should be asked again, otherwize
 *	FALSE.
 *
 */
int mscAskWizardQuestionAgain(void)
	{
	long	lResult;
	DWORD	dwKeyValue = 0;
	DWORD	dwSize;
	DWORD	dwType;
	TCHAR	*pszAppKey = "HYPERTERMINAL";

	dwSize = sizeof(DWORD);

	lResult = RegQueryValueEx(HKEY_CLASSES_ROOT, (LPTSTR)pszAppKey, 0,
		&dwType, (LPBYTE)&dwKeyValue, &dwSize);

	// If we are able to read a value from the registry and that value
	// is 1, there is no need to ask the question again, so return
	// a false value.
	//
	if ( (lResult == ERROR_SUCCESS) && (dwKeyValue >= 1) )
		return (FALSE);

	return (TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	mscUpdateRegistryValue
 *
 * DESCRIPTION:
 *	See mscAskWizardQuestionAgain.	If the user responds "NO" to this
 *	question, we update a counter in the registry.
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	void
 *
 */
void mscUpdateRegistryValue(void)
	{
	long	lResult;
	DWORD	dwKeyValue = 0;
	DWORD	dwSize;
	DWORD	dwType;
	TCHAR	*pszAppKey = "HYPERTERMINAL";

	dwSize = sizeof(DWORD);

	lResult = RegQueryValueEx(HKEY_CLASSES_ROOT, (LPTSTR)pszAppKey, 0,
		&dwType, (LPBYTE)&dwKeyValue, &dwSize);

	dwKeyValue += 1;

	lResult = RegSetValueEx(HKEY_CLASSES_ROOT, pszAppKey, 0,
		REG_BINARY, (LPBYTE)&dwKeyValue, dwSize);

	assert(lResult == ERROR_SUCCESS);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	mscMessageBeep
 *
 * DESCRIPTION:
 *	Play a MessageBeep
 *
 * ARGUMENTS:
 *	aBeep - the Beep sound to play
 *
 * RETURNS:
 *	return value from MessageBeep().
 *
 */
INT_PTR mscMessageBeep(UINT aBeep)
	{
	//
	// Play the system exclamation sound.  If this session is running
	// in a Terminal Service session (Remote Desktop Connection) then
	// issue MessageBeep((UINT)-1) so that the sound is transfered to
	// the remote machine. REV: 3/25/2002
	//
	return (MessageBeep((IsTerminalServicesEnabled() == TRUE) ?
			            (UINT)-1 :
		                aBeep));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  IsNT
 *
 * DESCRIPTION: Determines if we are running under Windows NT
 *
 * ARGUMENTS:
 *  None.
 *
 * RETURNS:
 *  True if NT
 *
 * Author:  MPT 7-31-97
 */
INT_PTR IsNT(void)
	{
	static BOOL bChecked = FALSE;	// We have not made this check yet.
    static BOOL bResult = FALSE;    // assume we are not NT/Win2K/XP

	if (bChecked == FALSE)
		{
		#if DEADWOOD
		OSVERSIONINFO stOsVersion;

		stOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

		if (GetVersionEx(&stOsVersion))
			{
			bResult = ( stOsVersion.dwPlatformId == VER_PLATFORM_WIN32_NT );
			}
		#else // DEADWOOD
		DWORD dwVersion = GetVersion();
		bResult = ( !( dwVersion & 0x80000000 ) );
		#endif // DEADWOOD

		bChecked = TRUE;
		}

	return bResult;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  GetWindowsMajorVersion
 *
 * DESCRIPTION: Returns the major version of Windows we are running.
 *
 * ARGUMENTS:
 *  None.
 *
 * RETURNS:
 *  True if NT
 *
 * Author:  MPT 7-31-97
 */
DWORD GetWindowsMajorVersion(void)
    {
	OSVERSIONINFO stOsVersion;

	stOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&stOsVersion))
		{
		return stOsVersion.dwMajorVersion;
		}

	return 0;
	}

//
// The following two functions are from code obtained directly
// from MSDN for determining if you are currently running as a
// remote session (Terminal Service). REV: 10/03/2001
//

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ValidateProductSuite
 *
 * DESCRIPTION:
 *	This function compares the passed in "suite name" string
 *  to the product suite information stored in the registry.
 *  This only works on the Terminal Server 4.0 platform.
 *
 * ARGUMENTS:
 *	SuiteName	- Suite name.
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL ValidateProductSuite ( LPSTR SuiteName )
	{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		                "System\\CurrentControlSet\\Control\\ProductOptions",
						0, KEY_READ,
                        &hKey );

    if ( Rslt != ERROR_SUCCESS )
		{
        goto exit;
		}

    Rslt = RegQueryValueEx( hKey, "ProductSuite", NULL, &Type, NULL, &Size );

    if ( Rslt != ERROR_SUCCESS || !Size )
		{
        goto exit;
		}

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );

    if ( !ProductSuite )
		{
        goto exit;
		}

    Rslt = RegQueryValueEx( hKey, "ProductSuite", NULL, &Type,
                             (LPBYTE) ProductSuite, &Size );
     if ( Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ )
		 {
        goto exit;
		 }

    p = ProductSuite;

    while ( *p )
		{
        if ( lstrcmp( p, SuiteName ) == 0 )
			{
            rVal = TRUE;
            break;
			}

        p += ( lstrlen( p ) + 1 );
		}

exit:
    if ( ProductSuite )
		{
        LocalFree( ProductSuite );
		}

    if ( hKey )
		{
        RegCloseKey( hKey );
		}

    return rVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	IsTerminalServicesEnabled
 *
 * DESCRIPTION:
 *  This function performs the basic check to see if
 *  the platform on which it is running is Terminal
 *  services enabled.  Note, this code is compatible on
 *  all Win32 platforms.  For the Windows 2000 platform
 *  we perform a "lazy" bind to the new product suite
 *  APIs that were first introduced on that platform.
 *
 * ARGUMENTS:
 *	VOID
 *
 * RETURNS:
 *	BOOL
 *
 */
INT_PTR IsTerminalServicesEnabled( void )
	{
	static BOOL checked = FALSE;	// We have not made this check yet.
    static BOOL bResult = FALSE;    // assume Terminal Services is not enabled

	if (!checked)
		{
		DWORD dwVersion = GetVersion();

		// are we running NT ?
		if ( !( dwVersion & 0x80000000 ) )
			{
			// Is it Windows 2000 (NT 5.0) or greater ?
			if ( LOBYTE( LOWORD( dwVersion ) ) > 4 )
				{
				#if(WINVER >= 0x0500)
				bResult = GetSystemMetrics( SM_REMOTESESSION );
				checked = TRUE;
				#else // (WINVER >= 0x0500)
				// In Windows 2000 we need to use the Product Suite APIs
				// Dont static link because it wont load on non-Win2000 systems

				OSVERSIONINFOEXA osVersionInfo;
				DWORDLONG        dwlConditionMask = 0;
				HMODULE          hmodK32 = NULL;
				HMODULE          hmodNtDll = NULL;
				typedef ULONGLONG (*PFnVerSetConditionMask)(ULONGLONG,ULONG,UCHAR);
				typedef BOOL (*PFnVerifyVersionInfoA) ( POSVERSIONINFOEXA, DWORD, DWORDLONG );
				PFnVerSetConditionMask pfnVerSetConditionMask;
				PFnVerifyVersionInfoA pfnVerifyVersionInfoA;

				hmodNtDll = GetModuleHandleA( "ntdll.dll" );
				if ( hmodNtDll != NULL )
					{
					pfnVerSetConditionMask =
							( PFnVerSetConditionMask )GetProcAddress( hmodNtDll, "VerSetConditionMask");
					if ( pfnVerSetConditionMask != NULL )
						{
						dwlConditionMask =
								(*pfnVerSetConditionMask)( dwlConditionMask, VER_SUITENAME, VER_AND );
						hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
						if ( hmodK32 != NULL )
							{
							pfnVerifyVersionInfoA =
									(PFnVerifyVersionInfoA)GetProcAddress( hmodK32, "VerifyVersionInfoA" ) ;
							if ( pfnVerifyVersionInfoA != NULL )
								{
								ZeroMemory( &osVersionInfo, sizeof(osVersionInfo) );
								osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
								osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
								bResult = (*pfnVerifyVersionInfoA)( &osVersionInfo,
																	VER_SUITENAME,
																	dwlConditionMask );
								checked = TRUE;
								}
							}
						}
					}
				#endif(WINVER >= 0x0500)
				}
			else
				{
				// This is NT 4.0 or older
				bResult = ValidateProductSuite( "Terminal Server" );
				checked = TRUE;

				}
			}
		}

    return bResult;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  GetDllVersion
 *
 * DESCRIPTION: Returns the version of a given DLL.
 *
 * ARGUMENTS:
 *  lpszDllName - Name of the DLL to check the version number of.
 *
 * RETURNS:
 *  The DLL's version number.
 *
 * Author:  REV 4-16-2002
 */
DWORD GetDllVersion(LPCTSTR lpszDllName)
	{
    HINSTANCE hinstDll;
    DWORD dwVersion = 0;

    hinstDll = LoadLibrary(lpszDllName);
	
    if(hinstDll)
		{
        DLLGETVERSIONPROC pDllGetVersion;

        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");

		/*Because some DLLs might not implement this function, you
		  must test for it explicitly. Depending on the particular 
		  DLL, the lack of a DllGetVersion function can be a useful
		  indicator of the version.
		*/
        if(pDllGetVersion)
			{
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
				{
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
				}
			}
        
        FreeLibrary(hinstDll);
		}

    return dwVersion;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\open_msc.h ===
/*
 * File:	open_msc.h - stuff for calling Common Open Dialog
 *
 * Copyright 1991 by Hilgraeve Inc. -- Monroe, MI
 * All rights reserved
 *
 * $Revision: 4 $
 * $Date: 3/26/02 8:54a $
 */

#if !defined(OPEN_MSC_H)
#define OPEN_MSC_H

// Typedef for open file name common dialog callback - mrw

typedef UINT (CALLBACK *OFNPROC)(HWND, UINT, WPARAM, LPARAM);

/* -------------- Function prototypes ------------- */

// extern VOID phbkCallOpenDialog(HWND hwnd);

// extern VOID phbkCallRemoveDialog(HWND hwnd);

// extern VOID phbkCallDuplicateDialog(HWND hwnd);

// extern VOID phbkCallConnectDialog(HWND hwnd);

// extern BOOL phbkCallConnectSpecialDialog(HWND hwnd);

// extern BOOL phbkConnectSpecialDlg(HWND hwnd);

// extern VOID gnrcCallRunScriptDialog(HWND hwnd, HSESSION hSession);

// extern VOID gnrcCallEditScriptDialog(HWND hwnd, HSESSION hSession);

// extern INT xferSendBrowseDialog(HWND hwnd, HSESSION hSession,
//								struct stSendDlgStuff FAR *pstSnd);

extern LPTSTR gnrcFindFileDialog(HWND hwnd,
								LPCTSTR pszTitle,
								LPCTSTR pszDirectory,
								LPCTSTR pszMasks);

extern LPTSTR gnrcSaveFileDialog(HWND hwnd,
								LPCTSTR pszTitle,
								LPCTSTR pszDirectory,
								LPCTSTR pszMasks,
								LPCTSTR pszInitName);

extern LPTSTR gnrcFindDirectoryDialog(HWND hwnd,
									HSESSION hSession,
									LPTSTR pszDirectory);


extern DWORD GetUserDirectory(LPTSTR pszUserDir, DWORD dwSize);
extern void  CreateUserDirectory(void);
extern DWORD GetWorkingDirectory(LPTSTR pszUserDir, DWORD dwSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\open_msc.c ===
/*
 * File:        open_msc.c - stuff for calling Common Open Dialog
 *
 * Copyright 1991 by Hilgraeve Inc. -- Monroe, MI
 * All rights reserved
 *
 * $Revision: 23 $
 * $Date: 7/08/02 6:44p $
 */

#include <windows.h>
#pragma hdrstop

// #define      DEBUGSTR        1
#include <commdlg.h>
#include <memory.h>
#include <stdlib.h>
#include <shlobj.h>
#include "stdtyp.h"
#include <term\res.h>
#include "mc.h"
#include "tdll.h"
#include "globals.h"
#include "file_msc.h"
#include "load_res.h"
#include "htchar.h"
#include <tdll\assert.h>
#include "misc.h"
#include "registry.h"
#include "open_msc.h"

static OPENFILENAME ofn;
static BROWSEINFO bi;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 */
// This function prototype changed from BOOL FAR PASCAL. -- REV 3-6-98.
UINT_PTR APIENTRY gnrcFindDirHookProc(HWND hdlg,
		    						  UINT msg,
			    					  WPARAM wPar,
				    				  LPARAM lPar)
	{
   	TCHAR   acMsg[64];
	WORD    windowID;

	windowID = LOWORD(wPar);

	switch (msg)
		{
		case WM_INITDIALOG:
			break;

		case WM_DESTROY:
			break;

		case WM_COMMAND:
			switch (windowID)
				{
				case IDOK:
            		LoadString(glblQueryDllHinst(),
			        	        40809,
				                acMsg,
				                sizeof(acMsg) / sizeof(TCHAR));
					SetDlgItemText(hdlg, edt1, acMsg);

					// EndDialog(hdlg, 1);
					break;

				case lst2:
					if (HIWORD(lPar) == LBN_DBLCLK)
						{
						SetFocus(GetDlgItem(hdlg, IDOK));
						PostMessage(hdlg,
									WM_COMMAND,
									IDOK,
									MAKELONG((INT_PTR)GetDlgItem(hdlg, IDOK),0));
						}
					break;

				default:
					break;
				}
			break;

		default:
			break;
		}

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 */
#if FALSE
BOOL FAR PASCAL gnrcFindFileHookProc(HWND hdlg,
									UINT msg,
									WPARAM wPar,
									LPARAM lPar)
	{
	WORD    windowID;

	windowID = LOWORD(wPar);

	switch (msg)
		{
		case WM_INITDIALOG:
			ofn.lCustData = 0;
			break;

		case WM_DESTROY:
			break;

		default:
			break;
		}

	return FALSE;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      gnrcFindFileDialog
 *
 * DESCRIPTION:
 *      This function makes the FindFile common dialog a little bit easier to
 *      call.
 *
 * ARGUEMENTS:
 *      hwnd            -- the window handle to use as the parent
 *      pszTitle        -- text to display as the title
 *      pszDirectory    -- path to use as default directory
 *      pszMasks        -- file name masks
 *
 * RETURNS:
 *      A pointer to a string that contains the file name.  This string is malloced
 *      and must be freed by the caller, or..
 *      NULL which indicates the user canceled the operation.
 */

LPTSTR gnrcFindFileDialogInternal(HWND hwnd,
								LPCTSTR pszTitle,
								LPCTSTR pszDirectory,
								LPCTSTR pszMasks,
								int nFindFlag,
								LPCTSTR pszInitName)
	{
	int index;
	LPTSTR  pszRet = NULL;
	LPTSTR  pszStr;
	LPCTSTR pszWrk;
	TCHAR   acMask[128];
	TCHAR   acTitle[64];
	TCHAR   szExt[4];
	TCHAR   szFile[FNAME_LEN + 1];
	TCHAR   szDir[FNAME_LEN + 1];
	int     iRet;
    int     iSize;
	int     iExtSize;
	//DWORD   dwMaxComponentLength;
	//DWORD   dwFileSystemFlags;

	memset((LPTSTR)&ofn, 0, sizeof(ofn));
	TCHAR_Fill(szFile, TEXT('\0'), sizeof(szFile)/sizeof(TCHAR));
	TCHAR_Fill(szExt, TEXT('\0'), sizeof(szExt)/sizeof(TCHAR));
	TCHAR_Fill(acMask, TEXT('\0'), sizeof(acMask)/sizeof(TCHAR));
	TCHAR_Fill(acTitle, TEXT('\0'), sizeof(acTitle)/sizeof(TCHAR));

    //
    // So we can use the same binaries on Win9.x/WinNT/Win2K, we need
    // to make sure the size of this structure is correct for those
    // platforms. If WINVER and _WIN32_WINNT >= 0x0500, the size is
    // OPENFILENAME_SIZE_VERSION_400 otherwise the size is OPENFILENAME.
    // See OPENFILENAME documentation for more info. REV: 05/24/2001
    //
    #if(WINVER >= 0x0500 && _WIN32_WINNT >= 0x0500)
    if (!IsNT() || (IsNT() && GetWindowsMajorVersion() < 5))
        {
        ofn.lStructSize = sizeof(OPENFILENAME_SIZE_VERSION_400);
        }
    else
        {
        ofn.lStructSize = sizeof(OPENFILENAME);
        }
    #else
    ofn.lStructSize = sizeof(OPENFILENAME);
    #endif
	ofn.hwndOwner = hwnd;
	ofn.hInstance = (HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);

	if ((pszMasks == NULL) || (StrCharGetStrLength(pszMasks) == 0))
		{
		resLoadFileMask(glblQueryDllHinst(),
						IDS_CMM_ALL_FILES1,
						1,
						acMask,
						sizeof(acMask) / sizeof(TCHAR));

		ofn.lpstrFilter = acMask;
		}
	else
		{
		ofn.lpstrFilter   = pszMasks;
		pszWrk = pszMasks;
		pszWrk = StrCharFindFirst(pszWrk, TEXT('.'));

		if (*pszWrk == '.')
			{
			pszWrk = StrCharNext(pszWrk);
			pszStr = (LPTSTR)pszWrk;
			index = 0;
			/* This works because we know how the mask are going to be formed */
			while ((index < 3) && (*pszWrk != ')'))
				{
				index += 1;
				pszWrk = StrCharNext(pszWrk);
				}
			if (pszWrk >= pszStr)
				MemCopy(szExt, pszStr, pszWrk - pszStr);
			}

		pszWrk = NULL;
		}

    iSize = StrCharGetByteCount(pszInitName);
    //MPT:10SEP98 if there is no name, just set the dest string to nothing
	if( iSize <= FNAME_LEN && pszInitName && iSize > 0)
		{
		MemCopy(szFile, pszInitName, iSize);
		}
    else
        {
        szFile[0] = TEXT('\0');
        }

	ofn.lpstrDefExt       = (LPTSTR)szExt;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
	ofn.nFilterIndex      = 0;
	ofn.lpstrFile         = (LPTSTR)szFile;
	ofn.nMaxFile          = FNAME_LEN;

	if ((pszDirectory == NULL) || (StrCharGetStrLength(pszDirectory) == 0))
		{
	
		#ifdef NT_EDITION
		// mpt:07-30-97
		if (IsNT())
		#endif
			GetUserDirectory(szDir, FNAME_LEN + 1);
		#ifdef NT_EDITION
		else
			{
			TCHAR acDirTmp[FNAME_LEN];
			GetModuleFileName(glblQueryHinst(), acDirTmp, FNAME_LEN);
			mscStripName(acDirTmp);
			}
		#endif
		}

	else
		{
		StrCharCopyN(szDir, pszDirectory, FNAME_LEN + 1);
		}

	pszStr = StrCharLast(szDir);
	if (*pszStr == TEXT('\\'))
		*pszStr = TEXT('\0');

	ofn.lpstrInitialDir   = szDir;
	ofn.lpstrFileTitle        = NULL;
	ofn.nMaxFileTitle         = 0;

	if ((pszTitle == NULL) || (StrCharGetByteCount(pszTitle) == 0))
		{
		// ofn.lpstrTitle         = "Select File";
		LoadString(glblQueryDllHinst(),
				IDS_CPF_SELECT_FILE,
				acTitle,
				sizeof(acTitle) / sizeof(TCHAR));

		ofn.lpstrTitle = acTitle;
		}

	else
		{
		ofn.lpstrTitle = pszTitle;
		}

	ofn.Flags = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_EXPLORER;

	if (nFindFlag)
		{
		ofn.Flags |= OFN_FILEMUSTEXIST;
		iRet = GetOpenFileName(&ofn);
		}

	else
		{
		ofn.Flags |= OFN_OVERWRITEPROMPT;
		#if 0
		// This was added so the common dialog for "Save As" applies
		// the same restrictions as the New Connect dialog when it
		// comes to saving session file names.
		//
		GetVolumeInformation(NULL, NULL, 0, NULL, &dwMaxComponentLength,
								 &dwFileSystemFlags, NULL, 0);

		if(dwMaxComponentLength == 255)
			{
			ofn.nMaxFile = dwMaxComponentLength - 1;
			}
		else
			{
			ofn.nMaxFile = 8;
			}
		#endif

		iRet = GetSaveFileName(&ofn);
		}


	if (iRet != 0)
		{
		iExtSize = StrCharGetStrLength(ofn.lpstrDefExt);
		iSize = min(StrCharGetStrLength(ofn.lpstrFile), (int)ofn.nMaxFile);

		if (iSize > 0)
			{
			pszRet = malloc(ofn.nMaxFile * sizeof(TCHAR));

			if (pszRet != NULL)
				{
				TCHAR_Fill(pszRet, TEXT('\0'), ofn.nMaxFile);

				// Due to a bug in GetSaveFileName(), it is possible
				// the file will not contain the default extension if
				// the filename is too long for the default extension
				// to be appended.  We need to make sure we have the
				// proper file extension type.  REV: 10/18/2000
				//
				if(iSize != (ofn.nFileExtension + iExtSize) &&
                    nFindFlag == FALSE)
					{
					StrCharCopyN(pszRet, ofn.lpstrFile, iSize - iExtSize - 1);
					StrCharCat(pszRet, TEXT("."));
					StrCharCat(pszRet, ofn.lpstrDefExt);
					}
				else
					{
					StrCharCopyN(pszRet, ofn.lpstrFile, ofn.nMaxFile);
					}

				// make sure this is a NULL terminated string.
				//
				pszRet[ofn.nMaxFile - 1] = TEXT( '\0');
				}

			return pszRet;
			}
		else
			{
			return(NULL);
			}
		}
	else
		{
        DWORD dwError = CommDlgExtendedError();
		return(NULL);
		}

	return(NULL);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
LPTSTR gnrcFindFileDialog(HWND hwnd,
						LPCTSTR pszTitle,
						LPCTSTR pszDirectory,
						LPCTSTR pszMasks)
	{
	return gnrcFindFileDialogInternal(hwnd,
									pszTitle,
									pszDirectory,
									pszMasks,
									TRUE,
									NULL);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
LPTSTR gnrcSaveFileDialog(HWND hwnd,
						LPCTSTR pszTitle,
						LPCTSTR pszDirectory,
						LPCTSTR pszMasks,
						LPCTSTR pszInitName)
	{
	return gnrcFindFileDialogInternal(hwnd,
									pszTitle,
									pszDirectory,
									pszMasks,
									FALSE,
									pszInitName);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  gnrcFindDirectoryDialog
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 */
LPTSTR gnrcFindDirectoryDialog(HWND hwnd, HSESSION hSession, LPTSTR pszDir)
	{
	#ifndef INCL_USE_NEWFOLDERDLG
    BOOL bRet;
	#else
	#if TODO
	LPMALLOC pMalloc = NULL;
	#endif // TODO
	HRESULT hResult = S_OK;
	#endif
	LPTSTR pszStr;
	TCHAR acTitle[64];
	TCHAR acList[64];
	TCHAR szDir[FNAME_LEN];
	TCHAR szFile[FNAME_LEN];
	int	  pszStrLen;

	LoadString(glblQueryDllHinst(),
			IDS_CMM_SEL_DIR,
			acTitle,
			sizeof(acTitle) / sizeof(TCHAR));

	resLoadFileMask(glblQueryDllHinst(),
				IDS_CMM_ALL_FILES1,
				1,
				acList,
				sizeof(acList) / sizeof(TCHAR));

	TCHAR_Fill(szFile, TEXT('\0'), sizeof(szFile) / sizeof(TCHAR));
	memset((LPTSTR)&ofn, 0, sizeof(ofn));

	if ((pszDir == NULL) || (StrCharGetStrLength(pszDir) == 0))
		{

		//changed to use working folder rather than current - mpt 8-18-99
		if ( !GetWorkingDirectory(szDir, FNAME_LEN) )
			{
			GetCurrentDirectory(FNAME_LEN, szDir);
			}
		}
	else
		{
		StrCharCopyN(szDir, pszDir, FNAME_LEN);
		}

	pszStr = StrCharLast(szDir);
	if (*pszStr == TEXT('\\'))
		*pszStr = TEXT('\0');

	#ifndef INCL_USE_NEWFOLDERDLG
    ofn.lCustData         = 0L;
    //
    // So we can use the same binaries on Win9.x/WinNT/Win2K, we need
    // to make sure the size of this structure is correct for those
    // platforms. If WINVER and _WIN32_WINNT >= 0x0500, the size is
    // OPENFILENAME_SIZE_VERSION_400 otherwise the size is OPENFILENAME.
    // See OPENFILENAME documentation for more info. REV: 05/24/2001
    //
    #if(WINVER >= 0x0500 && _WIN32_WINNT >= 0x0500)
    if (!IsNT() || (IsNT() && GetWindowsMajorVersion() < 5))
        {
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
        }
    else
        {
        ofn.lStructSize = sizeof(OPENFILENAME);
        }
    #else // (WINVER >= 0x0500 && _WIN32_WINNT >= 0x0500)
    ofn.lStructSize       = sizeof(OPENFILENAME);
    #endif //( WINVER >= 0x0500 && _WIN32_WINNT >= 0x0500)
	ofn.hwndOwner         = hwnd;
	ofn.hInstance         = (HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
	ofn.lpstrTitle        = acTitle;
	ofn.lpstrFilter       = acList;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
	ofn.nFilterIndex      = 0;
	ofn.lpstrFile         = szFile;
	ofn.nMaxFile          = sizeof(szFile);
	ofn.nFileOffset       = 0;
	ofn.nFileExtension    = 0;
	ofn.lpstrFileTitle    = acTitle;
	ofn.nMaxFileTitle     = sizeof(acTitle);
	ofn.lpstrDefExt       = NULL;
	// If OFN_ENABLEHOOK and/or OFN_ENABLETEMPLATE flags are set the call to
	// GetOpenFileName() will crash the application, then only a single drive
	// will appear in the "Drives:" dropdown list.  This is a bug in the 1691
	// build of Windows 98. -- REV 3-6-98.
	//
	ofn.Flags             = OFN_ENABLEHOOK | OFN_ENABLETEMPLATE |
							OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;

	ofn.lpfnHook          = gnrcFindDirHookProc;
	ofn.lpTemplateName    = MAKEINTRESOURCE(IDD_FINDDIRECTORY);

	ofn.lpstrInitialDir   = szDir;

	bRet = GetOpenFileName(&ofn);

    if (StrCharGetStrLength(szFile) == 0)
		{
		return NULL;
		}

	pszStr = StrCharFindLast(szFile, TEXT('\\'));
	if (*pszStr == TEXT('\\'))
		{
		pszStr = StrCharNext(pszStr);
		*pszStr = TEXT('\0');
		}
	#else //INCL_USE_NEWFOLDERDLG
    //TODO:MPT Finish up the new browse for folder mechanism
    //         - free pidl's when done

	//
	// CoInitialize and get the Shell allocator's IMalloc interface.
	//
    hResult = CoInitialize( NULL );

	if ( hResult != S_OK  && hResult != S_FALSE )
		{
		szFile[0] = TEXT('\0');
		}
	else
		{
		#if TODO
		if ( SHGetMalloc( &pMalloc ) != NOERROR || !pMalloc )
			{
			szFile[0] = TEXT('\0');
			}
		else if ( pMalloc )
			{
		#endif // TODO
			LPITEMIDLIST pidlSelected = NULL;

			//pidlSelected = (LPITEMIDLIST) CoTaskMemAlloc( sizeof(ITEMIDLIST) );

			bi.pidlRoot = NULL;
			bi.hwndOwner = hwnd;
			bi.pszDisplayName = szDir;
			bi.lpszTitle = acTitle;
			bi.ulFlags = BIF_RETURNONLYFSDIRS;
			//
			// Add the new dialog style flag to get all the new shell's
			// functionality (make resizable, etc.).
			//
			bi.ulFlags |= BIF_USENEWUI;
			bi.lpfn = NULL; //gnrcBrowseFolderHookProc;
			bi.lParam = 0;
    
			pidlSelected = SHBrowseForFolder( &bi );
			
			if ( pidlSelected )
				{
				SHGetPathFromIDList( pidlSelected, szFile );
				//
				// Free the memory and by the Shell allocator for this PIDL.
				//
				//pMalloc->Free( pidlSelected );
				pidlSelected = NULL;
				}

		#if TODO
			//
			// Release the Shell allocator's IMalloc interface.
			//
			//pMalloc->Release();
			pMalloc = NULL;
			}
		#endif // TODO

		CoUninitialize();
		}

    if (StrCharGetStrLength(szFile) == 0)
		{
		return NULL;
		}
	#endif //INCL_USE_NEWFOLDERDLG

	fileFinalizeDIR(hSession, szFile, szFile);

	pszStrLen = StrCharGetByteCount(szFile) + 1;

	pszStr = malloc(pszStrLen);
	StrCharCopyN(pszStr, szFile, pszStrLen);

	return pszStr;
	}

#ifdef INCL_USE_NEWFOLDERDLG
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  gnrcBrowseFolderHookProc
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 */
UINT_PTR CALLBACK gnrcBrowseFolderHookProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
    {
    return 0;
    }
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  GetUserDirectory
 *
 * DESCRIPTION:
 *  Returns the default HyperTerminal directory for the current user
 *
 * ARGUMENTS:
 *  pszUserDir  --  where to write the default directory
 *  dwSize      --  size, in characters, of the above buffer
 *
 * RETURNS:
 *  If the function succeeds, the return value is the number of characters
 *  stored into the buffer pointed to by pszDir, not including the
 *  terminating null character.
 *
 *  If the specified environment variable name was not found in the
 *  environment block for the current process, the return value is zero.
 *
 *  If the buffer pointed to by lpBuffer is not large enough, the return
 *  value is the buffer size, in characters, required to hold the value
 *  string and its terminating null character.
 *
 * Author:  JMH, 6-12-96
 */
DWORD GetUserDirectory(LPTSTR pszUserDir, DWORD dwSize)
    {
    DWORD   dwRet = MAX_PATH;
    TCHAR   szProfileDir[MAX_PATH];
    TCHAR   szProfileDir1[MAX_PATH];
    TCHAR   szProfileRoot[MAX_PATH];


    szProfileRoot[0] = TEXT('\0');
    if ( htRegQueryValue(HKEY_CURRENT_USER,
                       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
                       TEXT("Programs"),
                       szProfileRoot,
                       &dwRet) != 0 )
		{
		assert(0);
        return 0;
		}

    dwRet = MAX_PATH;
	szProfileDir[0] = TEXT('\0');
    if ( htRegQueryValue(HKEY_CURRENT_USER,
                         TEXT("SOFTWARE\\Hilgraeve Inc\\HyperTerminal PE\\3.0"),
                         TEXT("SessionsPath"),
                         szProfileDir,
                         &dwRet) != 0 )
		{
        LPTSTR pszStr = NULL;

		dwRet = MAX_PATH;
		szProfileDir[0] = TEXT('\0');
		if ( htRegQueryValue(HKEY_CURRENT_USER,
						     TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\GrpConv\\MapGroups"),
						     TEXT("Communications"),
						     szProfileDir,
						     &dwRet) != 0 )
			{
			//mpt:12-16-98 If HyperTerminal was never installed by the operating system, this
			//             key is not present so we need to fake one.
			LoadString(glblQueryDllHinst(), IDS_GNRL_PROFILE_DIR, szProfileDir, sizeof(szProfileDir)/sizeof(TCHAR) );
			}

		szProfileDir1[0] = TEXT('\0');
        LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, szProfileDir1, sizeof(szProfileDir)/sizeof(TCHAR) );

        pszStr = StrCharLast(szProfileDir);

        if (*szProfileDir && *pszStr != TEXT('\\'))
            {
            StrCharCat(szProfileDir, TEXT("\\"));
            }

        StrCharCat(szProfileDir, szProfileDir1);

		dwRet = StrCharGetStrLength(szProfileRoot) + StrCharGetStrLength(szProfileDir);
		assert(!(dwRet + sizeof(TCHAR) > dwSize));

		StrCharCopyN(pszUserDir, szProfileRoot, dwSize);

		if ((DWORD)(StrCharGetStrLength(pszUserDir) + 1) < dwSize)
			{
			StrCharCat(pszUserDir, TEXT("\\"));
			}

		if (dwRet + sizeof(TCHAR) < dwSize)
			{
			StrCharCat(pszUserDir, szProfileDir);
			}
		}
	else
		{
		dwRet = StrCharGetStrLength(szProfileDir);
		assert(dwRet + sizeof(TCHAR) > dwSize);

		StrCharCopyN(pszUserDir, szProfileDir, dwSize);
		}

    return dwRet;
    }


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  CreateUserDirectory (NT_EDITION only)
 *
 * DESCRIPTION:
 *  For NT, if HT is installed after the os update, no directory
 *  will exist for HT in the user profile. This function creates the
 *  directory if necessary, since the rest of the program assumes
 *  it exists.
 *
 * ARGUMENTS:
 *  None.
 *
 * RETURNS:
 *  Nothing.
 *
 * Author:  JMH, 6-13-96
 */
void CreateUserDirectory(void)
    {
    TCHAR   szUserDir[MAX_PATH];

    GetUserDirectory(szUserDir, MAX_PATH);
    mscCreatePath(szUserDir);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  GetWorkingDirectory
 *
 * DESCRIPTION: Determines if we are running under Windows NT
 *
 * ARGUMENTS:
 *  None.
 *
 * RETURNS:
 *  0 if user directory not specified
 *
 * Author:  MPT 8-18-99
 */
DWORD GetWorkingDirectory(LPTSTR pszUserDir, DWORD dwSize)
    {
    DWORD dwRet = MAX_PATH;
	DWORD lReturn = 1;

    pszUserDir[0] = TEXT('\0');

#if defined(NT_EDITION)
	lReturn = 0;
#else
    if ( htRegQueryValue(HKEY_CURRENT_USER,
                         TEXT("SOFTWARE\\Hilgraeve Inc\\HyperTerminal PE\\3.0"),
                         TEXT("WorkingPath"),
                         pszUserDir,
                         &dwRet) != 0 )
		{
        lReturn = 0;
		}
#endif

	return lReturn;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\print.c ===
/*	File: D:\WACKER\tdll\print.c (Created: 14-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 7/08/02 6:44p $
 */
#include <windows.h>
#pragma hdrstop

//#define DEBUGSTR
#include <term\res.h>

#include "stdtyp.h"
#include "mc.h"
#include "misc.h"
#include "assert.h"
#include "globals.h"
#include "session.h"
#include "print.h"
#include "print.hh"
#include "errorbox.h"
#include "tdll.h"
#include "term.h"
#include "htchar.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void printTellError(const HSESSION hSession, const HPRINT hPrint,
							const INT iStatus)
	{
	if (iStatus < 0)
		{
		if (iStatus & SP_NOTREPORTED)
			{
			TCHAR achBuf[256];
			TCHAR achTitle[256];

			achBuf[0] = TEXT('\0');
			achTitle[0] = TEXT('\0');

			LoadString(glblQueryDllHinst(),
						IDS_PRINT_TITLE,
						achTitle,
						sizeof(achTitle) / sizeof(TCHAR));

			switch (iStatus)
				{
			case SP_OUTOFDISK:
				LoadString(glblQueryDllHinst(),
							IDS_PRINT_NOMEM,
							achBuf,
							sizeof(achBuf) / sizeof(TCHAR));
				break;

			case SP_OUTOFMEMORY:
				LoadString(glblQueryDllHinst(),
							IDS_PRINT_CANCEL,
							achBuf,
							sizeof(achBuf) / sizeof(TCHAR));

				break;

			case SP_USERABORT:
				break;

			default:
				{
				const HHPRINT hhPrint = (HHPRINT)hPrint;

				if (hhPrint == 0 || !hhPrint->fUserAbort)
					{
					LoadString(glblQueryDllHinst(),
								IDS_PRINT_ERROR,
								achBuf,
								sizeof(achBuf) / sizeof(TCHAR));
					}
				}
				break;
				}

			if (achBuf[0] != TEXT('\0'))
				{
				TimedMessageBox(sessQueryHwnd(hSession),
									achBuf,
									achTitle,
									MB_ICONEXCLAMATION | MB_OK,
									0);
				}

			}
		}

	return;
	}

//*jcm
#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PrintKillJob
 *
 * DESCRIPTION:
 *	Kills a print job.	Called when session is closing and stuff is
 *	printing.
 *
 * ARGUMENTS:
 *	HSESSION	hSession	- external session handle.
 *
 * RETURNS:
 *	VOID
 *
 */
VOID PrintKillJob(HSESSION hSession)
	{
	HHPRINT hPr;
	INT 	iStatus = 0;
	HGLOBAL hMem;

	assert(hSession);

	// It is possible that the print job ended by the time we got
	// here so if the handle is 0, return quietly.

	hPr = (HHPRINT)mGetPrintHdl(hSession);

	if (hPr == (HHPRINT)0)
		return;

	/* -------------- Kill this print job ------------- */

	TimerDestroy(&hPr->hTimer);
	DbgOutStr("\r\nTimer Destroy in PrintKillJob\r\n", 0, 0, 0, 0, 0);

	if (hPr->hDC)
		{
		// Check if we issued an EndPage() for this page yet.

		if (hPr->nLines > 0)
			{
			if (HA5G.fIsWin30)
				iStatus = Escape(hPr->hDC, NEWFRAME, 0, NULL, NULL);

			else
				iStatus = EndPage(hPr->hDC);

			DbgOutStr("EndPage = %d\r\n", iStatus, 0, 0, 0, 0);
			PrintTellError(hSession, (HPRINT)hPr, iStatus);
			}

		if (iStatus >= 0)
			{
			if (HA5G.fIsWin30)
				iStatus = Escape(hPr->hDC, ENDDOC, 0, (LPTSTR)0, NULL);

			else
				iStatus = EndDoc(hPr->hDC);

			DbgOutStr("EndDoc = %d\r\n", iStatus, 0, 0, 0, 0);
			PrintTellError(hSession, (HPRINT)hPr, iStatus);
			}

		if (IsWindow(hPr->hwndPrintAbortDlg))
			DestroyWindow(hPr->hwndPrintAbortDlg);

		FreeProcInstance((FARPROC)hPr->lpfnPrintAbortDlg);
		FreeProcInstance((FARPROC)hPr->lpfnPrintAbortProc);
		DeleteDC(hPr->hDC);
		}

	else
		{
		nb_close(hPr->hPrn);
		}

	FreeProcInstance(hPr->lpfnTimerCallback);
	hMem = (HANDLE)GlobalHandle(HIWORD(hPr->pach));
	GlobalUnlock(hMem);
	GlobalFree(hMem);
	free(hPr);
	hPr = NULL;
	mSetPrintHdl(hSession, (HPRINT)0);
	return;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printAbortProc
 *
 * DESCRIPTION:
 *	Enables print-manager to unspool stuff when system is low on disk
 *	space.	Is also called whenever EndPage() is called.
 *
 * ARGUMENTS:
 *	HDC hdcPrn	- DC of printer
 *	INT 		- nCode
 *
 * RETURNS:
 *	Stuff
 *
 */
BOOL CALLBACK printAbortProc(HDC hDC, INT nCode)
	{
	MSG msg;
	//cost HHPRINT hhPrint = printCtrlLookupDC(hDC);

	//*HCLOOP hCLoop = sessQueryCLoopHdl(hhPrint->hSession);

	DbgOutStr("\r\nprintAbortProc : %d\r\n", nCode, 0, 0, 0, 0);

	//*if (hCLoop == 0)
	//*    {
	//*    assert(FALSE);
	//*    return FALSE;
	//*    }

	// Need to quit processing characters to the emulator at this
	// point or a recursion condition occurs which results in a
	// run-away condtion.

	//*CLoopRcvControl(hCLoop, CLOOP_SUSPEND, CLOOP_RB_PRINTING);
	//*CLoopSndControl(hCLoop, CLOOP_SUSPEND, CLOOP_SB_PRINTING);

	while (PeekMessage((LPMSG)&msg, (HWND)0, 0, 0, PM_REMOVE))
		{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
		}

	//*CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_PRINTING);
	//*CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_PRINTING);

	DbgOutStr("Exiting printAbortProc", 0, 0, 0, 0, 0);

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printString
 *
 * DESCRIPTION:
 *	Workhorse print-echo function.	Takes care of counting lines and
 *	paginating.  Also calls printOpenDC() if necessary to get a printer
 *	DC.
 *
 * ARGUMENTS:
 *	HHPRINT 	hhPrint 	- The Internal printer handle
 *	LPCTSTR 	pachStr 	- A pointer to the string to print.
 *	int 		iLen		- The length of the string to print.
 *
 * RETURNS:
 *	TRUE = OK, FALSE = error
 *
 */
int printString(const HHPRINT hhPrint, LPCTSTR pachStr, int iLen)
	{
	int 	nCharCount;
	int 	nIdx;
    int iPrintableWidth;

	SIZE	stStringSize;
	LPCTSTR pszTemp;
	TCHAR   achBuf[512];
    RECT stRect;

    //
    // get a device context if we do not already have one
    //

	if (hhPrint->hDC == 0)
		{
		if (printOpenDC(hhPrint) == FALSE)
			{
			printEchoClose((HPRINT)hhPrint);
			return FALSE;
			}
		}
 
  
	for (nCharCount = nIdx = 0, pszTemp = pachStr ;
			nIdx < iLen ;
				++nCharCount, ++nIdx, pszTemp = StrCharNext(pszTemp))
		{
		if (IsDBCSLeadByte((BYTE)*pszTemp))
			nCharCount++;

		switch (*pszTemp)
			{
		case TEXT('\r'):
            if ( nCharCount )
 			    MemCopy(achBuf, pachStr, nCharCount);
			achBuf[nCharCount] = TEXT('\0');

            GetTextExtentPoint(hhPrint->hDC, achBuf, 
                               StrCharGetByteCount(achBuf), &stStringSize);

		    if ( nCharCount > 1 )
                {
                //
                // calculate a print rect for the current margins
                //
    
                iPrintableWidth = GetDeviceCaps( hhPrint->hDC, HORZRES );
                iPrintableWidth -= hhPrint->marginsDC.right;

                stRect.left   = hhPrint->cx;
                stRect.right  = iPrintableWidth;
                stRect.top    = hhPrint->cy;
                stRect.bottom = hhPrint->cy + stStringSize.cy;

                ExtTextOut( hhPrint->hDC, hhPrint->cx, hhPrint->cy, 
                            ETO_CLIPPED, &stRect, achBuf, 
                            StrCharGetByteCount(achBuf), NULL );
                }

			TCHAR_Fill(achBuf, TEXT('\0'), sizeof(achBuf)/sizeof(TCHAR));
			hhPrint->cx = hhPrint->marginsDC.left;
			pachStr = StrCharNext(pszTemp);
			nCharCount = 0;

			break;

		case TEXT('\f'):
			hhPrint->nLinesPrinted = hhPrint->nLinesPerPage;

			/* --- Fall thru to case '\n' --- */

		case TEXT('\n'):
            if (nCharCount)
                MemCopy(achBuf, pachStr,nCharCount);
		    achBuf[nCharCount] = TEXT('\0');

   			GetTextExtentPoint(hhPrint->hDC,
   			                   achBuf,
                               StrCharGetByteCount(achBuf),
                               &stStringSize);

            if ( nCharCount > 1 )
                {
                iPrintableWidth = GetDeviceCaps( hhPrint->hDC, HORZRES );
                iPrintableWidth -= hhPrint->marginsDC.right;

                stRect.left   = hhPrint->cx;
                stRect.right  = iPrintableWidth;
                stRect.top    = hhPrint->cy;
                stRect.bottom = hhPrint->cy + stStringSize.cy;

                ExtTextOut( hhPrint->hDC, hhPrint->cx, hhPrint->cy, 
                            ETO_CLIPPED, &stRect, achBuf, 
                            StrCharGetByteCount(achBuf), NULL );
                }

			hhPrint->cy += stStringSize.cy;
			pachStr = StrCharNext(pszTemp);
			nCharCount = 0;

            //
            // check if we need a new page
            //
            
			hhPrint->nLinesPrinted += 1;

			if (hhPrint->nLinesPrinted > hhPrint->nLinesPerPage)
				{
				if (hhPrint->nFlags & PRNECHO_BY_PAGE)
					{
					printEchoClose((HPRINT)hhPrint);
					hhPrint->nFlags |= PRNECHO_IS_ON;
					return TRUE;
					}

					hhPrint->nStatus = EndPage(hhPrint->hDC);

					if (hhPrint->nStatus < 0)
						{
						printEchoClose((HPRINT)hhPrint);
						return FALSE;
						}

					hhPrint->nStatus = StartPage(hhPrint->hDC);
                    printSetFont( hhPrint );

					if (hhPrint->nStatus <= 0)
						{
						printEchoClose((HPRINT)hhPrint);
						return FALSE;
						}

					hhPrint->nLinesPrinted = 0;
					hhPrint->cx = hhPrint->marginsDC.left;
                    hhPrint->cy = hhPrint->marginsDC.top;
				}
			break;

		default:
			break;
			}
		}

	/* -------------- Left over portion of a line? ------------- */

	if ((nCharCount > 0) && (*pachStr != TEXT('\0')))
		{
		DbgOutStr("o", 0, 0, 0, 0, 0);

		MemCopy(achBuf, pachStr,nCharCount);
		achBuf[nCharCount] = TEXT('\0');

		GetTextExtentPoint(hhPrint->hDC,
							achBuf,
							StrCharGetByteCount(achBuf),
							&stStringSize);

        iPrintableWidth = GetDeviceCaps( hhPrint->hDC, HORZRES );
        iPrintableWidth -= hhPrint->marginsDC.right;

        stRect.left   = hhPrint->cx;
        stRect.right  = iPrintableWidth;
        stRect.top    = hhPrint->cy;
        stRect.bottom = hhPrint->cy + stStringSize.cy;

        ExtTextOut( hhPrint->hDC, hhPrint->cx, hhPrint->cy, 
                    ETO_CLIPPED, &stRect, achBuf, 
                    StrCharGetByteCount(achBuf), NULL );

//		TextOut(hhPrint->hDC,
//					hhPrint->cx,
//					hhPrint->cy,
//					achBuf, StrCharGetByteCount(achBuf));

		TCHAR_Fill(achBuf, TEXT('\0'), sizeof(achBuf)/sizeof(TCHAR));
		hhPrint->cx += stStringSize.cx;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printQueryStatus
 *
 * DESCRIPTION: This function is used to determine if printing has been
 *				turned on for the supplied print handle.
 *
 * ARGUMENTS:	hPrint	- The external printer handle.
 *
 * RETURNS: 	TRUE	- If printing is on.
 *				FALSE	- If printing is off.
 *
 */
int printQueryStatus(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;

	if (hPrint == 0)
		assert(FALSE);

	return (bittest(hhPrint->nFlags, PRNECHO_IS_ON));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printStatusToggle
 *
 * DESCRIPTION:
 *	Toggles the status (on/off) of the supplied print handle.
 *
 * ARGUMENTS:	hPrint	- The external printer handle.
 *
 * RETURNS: 	nothing
 *
 */
void printStatusToggle(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;

	if (hPrint == 0)
		assert(FALSE);

	if (bittest(hhPrint->nFlags, PRNECHO_IS_ON))
        {
		bitclear(hhPrint->nFlags, PRNECHO_IS_ON);
        }
	else
		{
		bitset(hhPrint->nFlags, PRNECHO_IS_ON);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printSetStatus
 *
 * DESCRIPTION:
 *	Turns priniting on or off for the supplied handle.
 *
 * ARGUMENTS:	hPrint		- The external printer handle.
 *				fSetting	- True or False to turn printing on/off.
 *
 * RETURNS: 	nothing
 *
 *
 */
void printSetStatus(const HPRINT hPrint, const int fSetting)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;

	if (hPrint == 0)
		assert(FALSE);

	if (fSetting)
		bitset(hhPrint->nFlags, PRNECHO_IS_ON);
	else
		bitclear(hhPrint->nFlags, PRNECHO_IS_ON);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printQueryPrinterInfo
 *
 * DESCRIPTION:
 *	This function copies five pieces of information (pszPrinter, pDevNames,
 *	pDevMode, lf, and margins ) from the Session HHPRINT handle, to the supplied
 *	HHPRINT handle.  The objective is to copy the contents of the Session's 
 *  HPRINT handle to another HPRINT handle (from the emulators).  Remember that
 *  the Session's HPRINT handle is the one that contains the stored printer name and
 *	setup information.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void printQueryPrinterInfo( const HHPRINT hhSessPrint, HHPRINT hhPrint )
	{
	TCHAR *pTemp;
	DWORD dwSize;

    if (hhPrint == NULL || hhSessPrint == NULL)
        {
        return;
        }

	// Copy the printer name.
	//
	StrCharCopyN(hhPrint->achPrinterName, hhSessPrint->achPrinterName, PRINTER_NAME_LEN);

	// Copy the DEVNAMES structure.
	//
	if (hhSessPrint->pstDevNames)
		{
		if (hhPrint->pstDevNames)
			{
			free(hhPrint->pstDevNames);
			hhPrint->pstDevNames = NULL;
			}

		pTemp = (TCHAR *)hhSessPrint->pstDevNames;
		pTemp += hhSessPrint->pstDevNames->wOutputOffset;
		pTemp += StrCharGetByteCount(pTemp) + 1;

		dwSize = (DWORD)(pTemp - (TCHAR*)hhSessPrint->pstDevNames);

		hhPrint->pstDevNames = malloc(dwSize);
		if (hhPrint->pstDevNames == 0)
			{
			assert(FALSE);
			return;
			}

        if (dwSize)
            MemCopy(hhPrint->pstDevNames, hhSessPrint->pstDevNames, dwSize);
		}

	// Copy the DEVMODE structure.
	//
	if (hhSessPrint->pstDevMode)
		{
		if (hhPrint->pstDevMode)
			{
			free(hhPrint->pstDevMode);
			hhPrint->pstDevMode = NULL;
			}

		dwSize = hhSessPrint->pstDevMode->dmSize +
					hhSessPrint->pstDevMode->dmDriverExtra;

		hhPrint->pstDevMode = malloc(dwSize);
		if (hhPrint->pstDevMode == 0)
			{
			assert(FALSE);
			return;
			}

        if (dwSize)
		    MemCopy(hhPrint->pstDevMode, hhSessPrint->pstDevMode, dwSize);
		}


	// Copy the font and margin information
	//
	
    MemCopy( &hhPrint->margins, &hhSessPrint->margins, sizeof(RECT) );
    MemCopy( &hhPrint->lf, &hhSessPrint->lf, sizeof(LOGFONT) );
    hhPrint->iFontPointSize = hhSessPrint->iFontPointSize;

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printVerifyPrinter
 *
 * DESCRIPTION:
 *	This routine is used to determine if a printer (any printer) is
 *	installed.
 *
 * ARGUMENTS:
 *	hPrint	-	An external print handle.
 *
 * RETURNS:
 * 0 if successful, otherwise -1.
 *
 */
int printVerifyPrinter(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR achTitle[256];
	TCHAR achBuf[256];
	TCHAR *pszString;
	HANDLE	hPrinter = NULL;
	BOOL	fRet;

    if (hhPrint == NULL)
        {
        return(-1);
        }

	// Check to see if the printer that has been saved with the
	// session information is still available.	If it is, simply
	// return a zero, indicating everything is OK.
	//
	fRet = OpenPrinter((LPTSTR)hhPrint->achPrinterName, &hPrinter, NULL);

	if (fRet)
		{
		ClosePrinter(hPrinter);
		return(0);
		}

	// If we're here, it's time to locate the default printer, whatever
	// it is.  If the default printer is selected here, the print handle's
	// name is initialized to that value.
	//
	if (GetProfileString("Windows", "Device", ",,,", achBuf,
					sizeof(achBuf)) && (pszString = strtok(achBuf, ",")))
		{
		StrCharCopyN(hhPrint->achPrinterName, pszString, PRINTER_NAME_LEN);
		return (0);
		}

	// A printer is NOT available.	Display the text for telling the
	// user how to install one.  It should be the same as the text that
	// appears in the printDlg call when this happens.
	//
	LoadString(glblQueryDllHinst(),
				IDS_PRINT_NO_PRINTER,
				achBuf,
				sizeof(achBuf) / sizeof(TCHAR));

	mscMessageBeep(MB_ICONEXCLAMATION);

	achTitle[0] = TEXT('\0');

	LoadString(glblQueryDllHinst(),
				IDS_PRINT_TITLE,
				achTitle,
				sizeof(achTitle) / sizeof(TCHAR));

	TimedMessageBox(sessQueryHwnd(hhPrint->hSession), achBuf,
		            achTitle, MB_ICONEXCLAMATION | MB_OK, 0);
	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printSetFont
 *
 * DESCRIPTION:
 *	Sets the terminal font to the given font.  If hFont is zero,
 *	termSetFont() trys to create a default font.
 *
 * ARGUMENTS:
 *	hhTerm	- internal term handle.
 *	plf 	- pointer to logfont
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL printSetFont(const HHPRINT hhPrint)
	{
    LOGFONT lf;

    lf = hhPrint->lf;
    lf.lfHeight = hhPrint->iFontPointSize;

    printCreatePointFont( &lf, hhPrint );

    SelectObject( hhPrint->hDC, hhPrint->hFont ); 
	
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printCreatePointFont
 *
 * DESCRIPTION:
 *	Creates a hFont based on the log font structure given.  This function assumes
 *  the height member of the log font structure to be in 1/10 of a point 
 *  increments.  A 12 point font would be represented as 120.  The hFont is stored
 *  in the print handle provided.
 *
 * ARGUMENTS:
 *	pLogFont   - A pointer to a log font structure.
 *  hhPrint    - A print handle to store the HFONT into.
 *
 * RETURNS:
 *	void
 *
 */

void printCreatePointFont( LOGFONT * pLogFont, HHPRINT hhPrint )
    {
    POINT pt;
    POINT ptOrg = { 0, 0 };

    if (hhPrint->hFont)
        {
    	DeleteObject(hhPrint->hFont);
        }

    pt.y = GetDeviceCaps(hhPrint->hDC, LOGPIXELSY) * pLogFont->lfHeight;
    pt.y /= 720; 
    
    DPtoLP(hhPrint->hDC, &pt, 1);
    DPtoLP(hhPrint->hDC, &ptOrg, 1);
    
    pLogFont->lfHeight = -abs(pt.y - ptOrg.y);
    
    hhPrint->hFont = CreateFontIndirect( pLogFont );

    return;
    }

/*******************************************************************************
 * FUNCTION:
 *    printSetMargins
 *
 * DESCRIPTION:
 *    Sets the margins for the print handle, by converting from the values 
 *    returned by the page setup dialog.
 *
 * ARGUMENTS:
 *    aMargins - A RECT structure that contains the margins in inches.
 *
 * Return:
 *    void
 *
 *  Author: dmn:02/19/97
 *
 */

void printSetMargins( HHPRINT hhPrint )
    {
    int iPixelsPerInchX;  
    int iPixelsPerInchY;  
    int iPhysicalOffsetX; 
    int iPhysicalOffsetY; 

    if ( hhPrint->hDC )
        {
        hhPrint->marginsDC = hhPrint->margins;

        //
        // convert the margins to pixels
        //

        iPixelsPerInchX = GetDeviceCaps( hhPrint->hDC, LOGPIXELSX );
        iPixelsPerInchY = GetDeviceCaps( hhPrint->hDC, LOGPIXELSY );

        hhPrint->marginsDC.left   = ( hhPrint->marginsDC.left   * iPixelsPerInchX ) / 1000;
        hhPrint->marginsDC.right  = ( hhPrint->margins.right  * iPixelsPerInchX ) / 1000;
        hhPrint->marginsDC.top    = ( hhPrint->marginsDC.top    * iPixelsPerInchY ) / 1000;
        hhPrint->marginsDC.bottom = ( hhPrint->marginsDC.bottom * iPixelsPerInchY ) / 1000;

        iPhysicalOffsetX = GetDeviceCaps( hhPrint->hDC ,PHYSICALOFFSETX );
        iPhysicalOffsetY = GetDeviceCaps( hhPrint->hDC, PHYSICALOFFSETY );

        hhPrint->marginsDC.left   = max( 0, hhPrint->marginsDC.left   - iPhysicalOffsetX );
        hhPrint->marginsDC.right  = max( 0, hhPrint->marginsDC.right  - iPhysicalOffsetX );
        hhPrint->marginsDC.top    = max( 0, hhPrint->marginsDC.top    - iPhysicalOffsetY );
        hhPrint->marginsDC.bottom = max( 0, hhPrint->marginsDC.bottom - iPhysicalOffsetY );
        }

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\new_cnct.c ===
/*	File: \WACKER\TDLL\new_cnct.c (Created: 2-Feb-1994)
 *
 *	Copyright 1990,1995 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 11 $
 *	$Date: 5/15/02 4:31p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>

extern BOOL WINAPI SetWindowStyle(HWND hwnd, DWORD style, BOOL fExtended);
int gnrlPickIconDlg(HWND hDlg);

#include <term\res.h>

#include "stdtyp.h"
#include "session.h"
#include "mc.h"
#include "globals.h"
#include "misc.h"
#include "tdll.h"
#include "htchar.h"
#include "errorbox.h"
#include "assert.h"
#include "hlptable.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	HSESSION hSession;

	TCHAR	 achSessName[FNAME_LEN];
	};

typedef	struct stSaveDlgStuff SDS;

#define	IDC_IC_ICON		101
#define IDC_TF_NAME 	102
#define IDC_LB_NAME     105
#define	IDC_EF_NAME		106
#define IDC_TF_ICON		107
#define	IDC_LB_LIST		108
#define	IDC_PB_BROWSE	109

#define	NC_CUT1		103
#define	NC_CUT2		110

// Design change - 4/14/94: Don't show Wackers New Connection icon
// in selection list. - mrw
//
#define ICON_COUNT	16

BOOL NCD_WM_DRAWITEM(LPDRAWITEMSTRUCT pD);
BOOL NCD_WM_COMPAREITEM(LPCOMPAREITEMSTRUCT pC);
BOOL NCD_WM_DELETEITEM(LPDELETEITEMSTRUCT pD);
BOOL NCD_WM_MEASUREITEM(LPMEASUREITEMSTRUCT pM);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	NewConnectionDlg
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK NewConnectionDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
    {
	HWND	hwndChild;
	INT		nId;
	INT 	nNtfy, fBad;
	SDS    *pS;
	int 	nLoop;
	HWND	hwnd;
	BOOL	fRc;
	DWORD	dwMaxComponentLength;
	DWORD	dwFileSystemFlags;
	HICON	hIcon;
	int 	nSelected;
	int 	cy;
	RECT	rc;

    static  fLongNamesSupported;
	static	DWORD aHlpTable[] = {	IDC_EF_NAME,   IDH_TERM_NEWCONN_NAME,
									IDC_LB_NAME,    IDH_TERM_NEWCONN_NAME,
									//IDC_TF_NAME,   IDH_TERM_NEWCONN_NAME,
                                    IDC_TF_ICON,   IDH_TERM_NEWCONN_ICON,
									IDC_LB_LIST,   IDH_TERM_NEWCONN_ICON,
									//IDC_IC_ICON,   IDH_TERM_NEWCONN_ICON,
                                    IDCANCEL,                           IDH_CANCEL,
                                    IDOK,                               IDH_OK,
									0,				0};

	//
	// MSDN docs state these are all reserved device names. REV: 5/14/2002
	//
	static const TCHAR *apszBadNames[] =
		{
		"LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9",
		"COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
		"EPT", "NUL", "PRN", "CLOCK$", "CON", "AUX", NULL
		};
	static const TCHAR *apszBadNTNames[] =
		{
		"MAILSLOT", "PIPE", "UNC", NULL
		};

	TCHAR	ach[FNAME_LEN];

	switch (wMsg)
		{
	    case WM_INITDIALOG:
		    pS = (SDS *)malloc(sizeof(SDS));

		    // Set no matter what so we can always free
		    //
		    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		    if (pS == (SDS *)0)
			    {
	   		    /* TODO: decide if we need to display an error here */
			    EndDialog(hDlg, FALSE);
			    break;
			    }

		    pS->hSession = (HSESSION)lPar;
		    mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		    // Determine whether long filenames are supported.  JRJ	12/94
		    fRc = GetVolumeInformation(NULL,  // pointer to root dir path buffer
								     NULL,	  // pointer to volume name buffer
								     0,		  // length of volume name buffer
								     NULL,    // pointer to volume serial number buffer
								     &dwMaxComponentLength,	// the prize - what I'm after
								     &dwFileSystemFlags,  // ptr to file system flag DWORD
								     NULL,	  // pointer to file system name buffer
								     0);	  // length of file system name buffer

		    if(dwMaxComponentLength == 255)
			    {
			    // There is support for long file names.

			    // Allow a max name lenght of 249.	That's 255 minus the
			    // extension length (3), minus the smallest path length,
			    // (i.e. C:\) also (3).
			    //
			    SendDlgItemMessage(hDlg, IDC_EF_NAME, EM_SETLIMITTEXT, 249, 0);
			    fLongNamesSupported = TRUE;
			    }
		    else
			    {
			    // There IS NOT support for long file names. Limit to eight.
			    SendDlgItemMessage(hDlg, IDC_EF_NAME, EM_SETLIMITTEXT, 8, 0);
			    fLongNamesSupported = FALSE;
			    }

		    // This dialog may also be called to change the session icon,
		    // so display the name and icon if we already have one.
		    //
		    sessQueryName(pS->hSession, ach, sizeof(ach)/sizeof(TCHAR));
		    StrCharCopyN(pS->achSessName, ach, sizeof(pS->achSessName)/sizeof(TCHAR));
		    if (!sessIsSessNameDefault(ach))
			    {
			    SetDlgItemText(hDlg, IDC_EF_NAME, ach);
			    mscModifyToFit(GetDlgItem(hDlg, IDC_TF_NAME), ach, SS_WORDELLIPSIS);
			    SetDlgItemText(hDlg, IDC_TF_NAME, ach);
			    }
		    else if (ach[0] != TEXT('\0'))
			    {
			    SetDlgItemText(hDlg, IDC_TF_NAME, ach);

			    // Set the new connection icon ID, if it's a new connection.
			    // --jcm 2/23/95.
			    //
			    sessSetIconID(pS->hSession, IDI_PROG);
			    }

		    hIcon = sessQueryIcon(pS->hSession);

		    if (hIcon != (HICON)0)
			    SendDlgItemMessage(hDlg, IDC_IC_ICON, STM_SETICON,
				    (WPARAM)hIcon, 0);

		    /* Fiddle with the list box */
		    hwnd = GetDlgItem(hDlg, IDC_LB_LIST);

		    SendMessage(hwnd,
                        LB_SETCOLUMNWIDTH,
					    GetSystemMetrics(SM_CXICON) + 12,
                        0L);

    	    /* compute the height of the listbox based on icon dimensions */
		    GetClientRect(hwnd, &rc);
		    cy = GetSystemMetrics(SM_CYICON);
		    cy += GetSystemMetrics(SM_CYHSCROLL);
		    cy += GetSystemMetrics(SM_CYEDGE) * 3;
		    SetWindowPos(hwnd,
                         NULL,
                         0, 0,
                         rc.right, cy,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

		    /* It's an owner drawn list box, just set the ICON ids for later */
		    nSelected = FALSE;
		    for (nLoop = 0; nLoop < ICON_COUNT; nLoop += 1)
			    {
			    SendMessage(hwnd,
                            LB_INSERTSTRING,
                            nLoop,
						    (LPARAM)"Hilgraeve is Great !!!");

			    // Design change - 4/14/94: Don't show Wackers New Connection
			    // icon in selection list. - mrw
			    //
			    SendMessage(hwnd,
						    LB_SETITEMDATA,
						    nLoop,
						    nLoop + IDI_PROG1);

			    if (sessQueryIconID(pS->hSession) == (IDI_PROG1 + nLoop))
				    {
				    SendMessage(hwnd,
							    LB_SETCURSEL,
							    nLoop, 0L);
				    nSelected = TRUE;
				    }
			    }

		    if (!nSelected)
			    {
			    SendMessage(hwnd,
                            LB_SETCURSEL,
                            0, 0L);
			    }
		    break;

	    case WM_DRAWITEM:
		    if (wPar == IDC_LB_LIST)
			    return NCD_WM_DRAWITEM((LPDRAWITEMSTRUCT)lPar);
		    break;

	    case WM_COMPAREITEM:
		    if (wPar == IDC_LB_LIST)
			    return NCD_WM_COMPAREITEM((LPCOMPAREITEMSTRUCT)lPar);
		    break;

	    case WM_DELETEITEM:
		    if (wPar == IDC_LB_LIST)
			    return NCD_WM_DELETEITEM((LPDELETEITEMSTRUCT)lPar);
		    break;

	    case WM_MEASUREITEM:
		    if (wPar == IDC_LB_LIST)
			    return NCD_WM_MEASUREITEM((LPMEASUREITEMSTRUCT)lPar);
		    break;

	    case WM_CONTEXTMENU:
            doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		    break;

	    case WM_HELP:
            doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		    break;

	    case WM_DESTROY:
		    pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

		    if (pS)
			    {
			    free(pS);
			    pS = NULL;
			    }

		    break;

        case WM_COMMAND:
            /*
            * Did we plan to put a macro in here to do the parsing ?
            */
            DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

            switch (nId)
                {
                case IDOK:
                    pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
                    fBad = FALSE;

                    // Set session name and icon.
                    //
                    ach[0] = TEXT('\0');
                    nSelected = GetDlgItemText(hDlg, IDC_EF_NAME, ach, sizeof(ach) / sizeof(TCHAR));

                    if (ach[0] == TEXT('\0'))
                        {
						TCHAR msg[MAX_PATH];

						LoadString(glblQueryDllHinst(), 
									IDS_GNRL_NEED_SESSION_NAME, msg,
									sizeof(msg)/sizeof(TCHAR));
						TimedMessageBox(hDlg, msg, NULL,
										MB_OK | MB_ICONHAND, 0);

                        SetFocus(GetDlgItem(hDlg, IDC_EF_NAME));
                        fBad = TRUE;
                        }
                    else
                        {
						TCHAR ach2[MAX_PATH];
						TCHAR invalid_chars[MAX_PATH];
						LoadString(glblQueryDllHinst(), 
									IDS_GNRL_INVALID_FILE_CHARS, invalid_chars,
									sizeof(invalid_chars)/sizeof(TCHAR));

						if (StrCharPBrk(ach, invalid_chars) != NULL)
							{
							TCHAR msg[MAX_PATH];

							LoadString(glblQueryDllHinst(), 
										IDS_GNRL_INVALID_CHARS, ach2,
										sizeof(ach2)/sizeof(TCHAR));
							wsprintf(msg, ach2, invalid_chars);

							TimedMessageBox(hDlg, msg, NULL,
											MB_OK | MB_ICONHAND, 0);

							SetFocus(GetDlgItem(hDlg, IDC_EF_NAME));
							fBad = TRUE;
							}

                        if (fBad)
                            break;

                        TCHAR_Trim(ach);

                        // Check the name against known device names.
                        //
                        fBad = FALSE;

                        for(nLoop = 0; apszBadNames[nLoop] != NULL; nLoop++)
                            {
                            if (StrCharCmpi(apszBadNames[nLoop], ach) == 0)
                                {
                                LoadString(glblQueryDllHinst(),IDS_GNRL_INVALID_NAME,
                                           ach2, sizeof(ach2) / sizeof(TCHAR));
								wsprintf(ach, ach2, invalid_chars);

                                TimedMessageBox(hDlg, ach, NULL,
                                                MB_OK | MB_ICONHAND, 0);

                                SetFocus(GetDlgItem(hDlg, IDC_EF_NAME));
                                fBad = TRUE;
                                break;
                                }
                            } //for(nLoop = 0; apszBadNames[nLoop] != NULL; nLoop++)

						if (!fBad && IsNT())
							{
							for(nLoop = 0; apszBadNTNames[nLoop] != NULL; nLoop++)
								{
								if (StrCharCmpi(apszBadNTNames[nLoop], ach) == 0)
									{
									LoadString(glblQueryDllHinst(),IDS_GNRL_INVALID_NAME,
											   ach2, sizeof(ach2) / sizeof(TCHAR));
									wsprintf(ach, ach2, invalid_chars);

									TimedMessageBox(hDlg, ach, NULL,
													MB_OK | MB_ICONHAND, 0);

									SetFocus(GetDlgItem(hDlg, IDC_EF_NAME));
									fBad = TRUE;
									break;
									}
								} //for(nLoop = 0; apszBadNTNames[nLoop] != NULL; nLoop++)
							}

                        if (fBad)
							{
                            break;
							}

                        sessSetName(pS->hSession, ach);
                        sessUpdateAppTitle(pS->hSession);

                        /*
                        * Check and see if a new Icon has been selected
                        */
                        hwnd = GetDlgItem(hDlg, IDC_LB_LIST);
                        assert(hwnd);

                        if (hwnd)
                            {
                            /* Get the ICON from the list box */
                            nLoop = (int)SendMessage(hwnd, LB_GETCURSEL, 0, 0L);

                            if (nLoop == LB_ERR)
                                nLoop = 0;

                            nLoop = (int)SendMessage(hwnd, LB_GETITEMDATA, nLoop, 0);
                            sessSetIconID(pS->hSession, nLoop);

                            PostMessage(sessQueryHwnd(pS->hSession), WM_SETICON,
                                        (WPARAM)TRUE, (LPARAM)sessQueryIcon(pS->hSession));
                            } // (hwnd)

                        EndDialog(hDlg, TRUE);
                        break;

                    case IDCANCEL:
                        pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

                        sessQueryName(pS->hSession, ach, sizeof(ach)/sizeof(TCHAR));
                        if (!sessIsSessNameDefault(ach))
                            {
                            sessSetName(pS->hSession, pS->achSessName);
                            }

                        EndDialog(hDlg, FALSE);
                        break;

                    default:
                        return FALSE;
                    } // if (ach[0] == TEXT('\0'))
                } // switch(nId)

            break; // WM_COMMAND

	    default:
		    return FALSE;
        } //switch (wMsg)

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NCD_WM_DRAWITEM
 *
 * DESCRIPTION:
 *	This function is called when the owner drawn list box used to display
 *	ICONs sends its parent a WM_DRAWITEM message.
 *
 * ARGUMENTS:
 *	pD -- pointer to the draw structure
 *
 * RETURNS:
 *
 */
BOOL NCD_WM_DRAWITEM(LPDRAWITEMSTRUCT pD)
	{
	int x, y;
	HICON hicon;
#if(WINVER >= 0x0500)
	DWORD dwOldLayout;
#endif

	//hicon = LoadIcon(glblQueryDllHinst(), MAKEINTRESOURCE(pD->itemData));
	hicon = extLoadIcon(MAKEINTRESOURCE(pD->itemData));

	if (hicon == (HICON)0)
		return FALSE;

	if (pD->itemState & ODS_SELECTED)
		SetBkColor(pD->hDC, GetSysColor(COLOR_HIGHLIGHT));
	else
		SetBkColor(pD->hDC, GetSysColor(COLOR_WINDOW));
	/* repaint the selection state */
	ExtTextOut(pD->hDC, 0, 0, ETO_OPAQUE, &pD->rcItem, NULL, 0, NULL);

	x = (pD->rcItem.left + pD->rcItem.right - GetSystemMetrics(SM_CXICON)) / 2;
	y = (pD->rcItem.top + pD->rcItem.bottom - GetSystemMetrics(SM_CYICON)) / 2;

#if(WINVER >= 0x0500)
	/* Bug #345406 : Don't mirror the icon. */
	dwOldLayout = GetLayout(pD->hDC);
	if (dwOldLayout && dwOldLayout != GDI_ERROR)
		{
		SetLayout(pD->hDC, dwOldLayout | LAYOUT_BITMAPORIENTATIONPRESERVED);
		}
#endif
	DrawIcon(pD->hDC, x, y, hicon);

#if(WINVER >= 0x0500)
	if (dwOldLayout && dwOldLayout != GDI_ERROR)
		{
		SetLayout(pD->hDC, dwOldLayout);
		}
#endif

	/* if it has the focus, draw the focus */
	if (pD->itemState & ODS_FOCUS)
	    DrawFocusRect(pD->hDC, &pD->rcItem);

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NCD_WM_COMPAREITEM
 *
 * DESCRIPTION:
 *	This function is called when the owner drawn list box used to display
 *	ICONs sends its parent a WM_COMPAREITEM message.
 *
 * ARGUMENTS:
 *	pC -- pointer to the structure to fill in.
 *
 * RETURNS:
 *	ZERO -- they all compare the same.
 *
 */
BOOL NCD_WM_COMPAREITEM(LPCOMPAREITEMSTRUCT pC)
	{
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NCD_WM_DELETEITEM
 *
 * DESCRIPTION:
 *	This function is called when the owner drawn list box used to display
 *	ICONs sends its parent a WM_DELETEITEM message.
 *
 * ARGUMENTS:
 *	pD -- pointer to the structure to fill in.
 *
 * RETURNS:
 *	TRUE;
 *
 */
BOOL NCD_WM_DELETEITEM(LPDELETEITEMSTRUCT pD)
	{

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NCD_WM_MEASUREITEM
 *
 * DESCRIPTION:
 *	This function is called when the owner drawn list box used to display
 *	ICONs sends its parent a WM_MEASUREITEM message.  It fills in the
 *	structure and returns.
 *
 * ARGUMENTS:
 *	pM -- pointer to the structure to fill in.
 *
 * RETURNS:
 *	TRUE.
 *
 */
BOOL NCD_WM_MEASUREITEM(LPMEASUREITEMSTRUCT pM)
	{

	pM->itemWidth = GetSystemMetrics(SM_CXICON);
	pM->itemWidth += 12;

	pM->itemHeight = GetSystemMetrics(SM_CYICON);
	pM->itemHeight += 4;

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DisplayError
 *
 * DESCRIPTION:
 *	Displays and error message.
 *
 * ARGUMENTS:
 *	hwnd	- dialog box handle
 *	idText	- id of text
 *	idTitle - id of title
 *
 * RETURNS:
 *
 * AUTHOR: Mike Ward, 19-Jan-1995
 */
static void DisplayError(const HWND hwnd, const int idText, const int idTitle)
	{

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\pre_dlg.c ===
/*	File: C:\WACKER\TDLL\PRE_DLG.C (Created: 12-Jan-1994)
 *	created from:
 *	File: C:\WACKER\TDLL\genrcdlg.c (Created: 16-Dec-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1993,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 7/12/02 8:03a $
 */

#include <windows.h>
#include "stdtyp.h"
#include "mc.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	int nOldHelpId;
	/*
	 * Put in whatever else you might need to access later
	 */
	};

typedef	struct stSaveDlgStuff SDS;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PrintEchoDlg
 *
 * DESCRIPTION:
 *	This function is the dialog proc for the Print Echo dialog box.  No real
 *	suprises here.
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
BOOL CALLBACK PrintEchoDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;


	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			}
		else
			{
			pS->nOldHelpId = 0;
			}

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);
		break;

	case WM_DESTROY:
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDHELP:
			break;

		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/*
			 * Do whatever saving is necessary
			 */

			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\print.h ===
/*	File: D:\WACKER\tdll\print.h (Created: 14-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 3/01/02 3:37p $
 */
#define WM_PRINT_NEWPAGE		WM_USER+0x100

#define PRNECHO_BY_JOB			0x0001	 // Don't print until session closes.
#define PRNECHO_BY_PAGE 		0x0002	 // Print each page separately.
#define PRNECHO_CHARS			0x0010
#define PRNECHO_LINES			0x0020
#define PRNECHO_SCREENS 		0x0040
#define PRNECHO_IS_ON			0x0100	 /* capture is currently on */
#define PRNECHO_PAUSE			0x0200	 /* capture is paused */

// From printhdl.c
HPRINT	printCreateHdl(const HSESSION hSession);
void	printDestroyHdl(const HPRINT hPrint);
void	printSaveHdl(const HPRINT hPrint);
int 	printInitializeHdl(const HPRINT hPrint);

// From print.c
void	printTellError(const HSESSION hSession, const HPRINT hPrint, const int iStatus);
int 	printQueryStatus(const HPRINT hPrint);
void	printSetStatus(const HPRINT hPrint, const int fSetting);
void	printStatusToggle(const HPRINT hPrint);
int 	printVerifyPrinter(const HPRINT hPrint);


// From prnecho.c
int 	printEchoChar(const HPRINT hPrint, const ECHAR tChar);
void	printEchoLine(const HPRINT hPrint, ECHAR *achLine, int iLen);
int 	printEchoClose(HPRINT hPrint);
int 	printEchoStart(HPRINT hPrint);
int 	printEchoString(HPRINT hPrint, ECHAR *achStr, int iLen);
int 	printEchoScreen(HPRINT hPrint, ECHAR *achStr, int iLen);
int     printEchoRaw(HPRINT hPrint, ECHAR *pszPrintStr, int nLen);

// From printset.c
void	printsetSetup(const HPRINT hPrint, const HWND hwnd);
int 	printPageSetup(const HPRINT hPrint, const HWND hwnd);
void	printsetPrint(const HPRINT hPrint);
BOOL	CALLBACK printsetAbortProc(HDC hdcPrn, INT nCode);
LRESULT CALLBACK printsetDlgProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\print.hh ===
/*	File: D:\WACKER\tdll\print.hh (Created: 19-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 7/08/02 6:45p $
 */

#define PRINTSET_LOCAL		0x0001	// The printer is attached locally.
#define PRINTSET_SHARED 	0x0002	// The printer is shared (networked).

#define MAX_NUM_PRINT_DC	5		// Max number of slots in print 
									// control table.

typedef struct stPrintPrivate *HHPRINT;

struct stPrintPrivate
	{
	HSESSION	hSession;

	CRITICAL_SECTION	csPrint;		// For snychronizing access.

	PDEVMODE	pstDevMode; 			// Information from setup dialogs.
										// The printer name is contained
										// within the DEVMODE information.

	LPDEVNAMES	pstDevNames;			// Information from setup dialogs.
										// See printsetSetup for details
										// on usage of DEVNAMES.

	TCHAR		*pszPrinterPortName,	// The name of the printer port.
				*pszPrinterDriver,
				achDoc[80],
				achPrintToFileName[FNAME_LEN],
				achPrinterName[PRINTER_NAME_LEN];

	ECHAR 		achPrnEchoLine[256];	// For session file use only.

	DWORD		nSelectionFlags,
				fLocation;

	HDC 		hDC;
	DOCINFO 	di;
	HFONT		hFont;
	LOGFONT 	lf;
	TEXTMETRIC	tm;
    RECT        margins;                // Margins in inches for the page setup dialog
    RECT        marginsDC;              // Margins in pixels for the current printer
    int         iFontPointSize;

	long		tmHeight;

	int 		nLinesPrinted,		// running count of lines printed (per page)
				nPage,				// current page number being printed
				nLinesPerPage,		// calculated in PrintMemoryBlock
				nLnIdx,
				nFlags,
				nStatus,
				cx, cy, 			// position to print from.
				fUserAbort,
				fError,
				nPrnMethod, // PRNECHO_BY_PAGE || PRNECHO_BY_JOB
				nPrnMode;	// PRNECHO_CHARS || PRNECHO_LINES || PRNECHO_SCREENS

	DLGPROC 	lpfnPrintDlgProc;
	ABORTPROC	lpfnPrintAbortProc;
	HWND		hwndPrintDlg;

	};

// From print.c

int 	printString(const HHPRINT hhPrint, LPCTSTR pachStr, int iLen);
BOOL	CALLBACK printAbortProc(HDC hDC, int nCode);
BOOL 	printSetFont(const HHPRINT hhPrint);
void	printQueryPrinterInfo(const HHPRINT hhSessPrint, HHPRINT hhPrint );
void 	printCreatePointFont(LOGFONT * pLogFont, HHPRINT hhPrint);
void    printSetMargins( HHPRINT hhPrint );

// From printdc.c

HDC 	printCtrlCreateDC(const HPRINT hPrint);
void	printCtrlDeleteDC(const HPRINT hPrint);
HPRINT	printCtrlLookupDC(const HDC hDC);
int 	printOpenDC(const HHPRINT hhPrint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\printdc.c ===
/*	File: D:\WACKER\tdll\printdc.c (Created: 26-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 7/08/02 6:45p $
 */

#include <windows.h>
#pragma hdrstop

#include <term\res.h>
#include "stdtyp.h"
#include "assert.h"
#include "print.h"
#include "print.hh"
#include "session.h"
#include "tdll.h"
#include "htchar.h"
#include "globals.h"

#define MAX_NUM_PRINT_DC	5

struct stPrintTable
	{
	HPRINT	hPrintHdl;
	HDC 	hDCPrint;
	};

static struct stPrintTable stPrintCtrlTbl[MAX_NUM_PRINT_DC];

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printCtrlCreateDC
 *
 * DESCRIPTION:
 *	This function is used to create the Printer DC for the supplied Print
 *	handle.  It is done in this function so a table that contains both the
 *	DC and the Print Handle can be maintained.	This is necessary so the
 *	PrintAbortProc function (which receives an HDC only) can determine
 *	which Print Handle is associated with the HDC.
 *
 *	The DC created by this function uses the Printer Name in the supplied
 *	Printer Handle.  If this name is not supplied, the function returns 0;
 *
 * ARGUMENTS:
 *	HPRINT	-	The External Print handle.
 *
 * RETURNS:
 *	HDC 	-	A device context if successful, otherwise 0.
 *
 */
HDC printCtrlCreateDC(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR	szPrinter[256];
	TCHAR  *szDriver, *szOutput;
	int 	nIdx,
			iSize;
	HDC 	hDC;

	if (hPrint == 0)
		{
		assert(FALSE);
		return 0;
		}

	if (hhPrint->achPrinterName[0] == 0)
		{
		assert(FALSE);
		return 0;
		}

	for (nIdx = 0; nIdx < MAX_NUM_PRINT_DC; nIdx++)
		{
		if (stPrintCtrlTbl[nIdx].hPrintHdl == 0)
			{
			GetProfileString("Devices", hhPrint->achPrinterName, "",
				szPrinter, sizeof(szPrinter));

			hDC = 0;

			if ((szDriver = strtok(szPrinter, ",")) &&
				(szOutput = strtok(NULL,	  ",")))
				{
				hDC = CreateDC(szDriver, hhPrint->achPrinterName, szOutput,
						hhPrint->pstDevMode);
				}

			if (hDC == 0)
				{
				assert(FALSE);
				return 0;
				}

			if (hhPrint->pszPrinterPortName != 0)
				{
				free(hhPrint->pszPrinterPortName);
				hhPrint->pszPrinterPortName = NULL;
				}

			iSize = StrCharGetByteCount(szOutput) + 1;

			hhPrint->pszPrinterPortName = malloc((unsigned int)iSize);

			StrCharCopyN(hhPrint->pszPrinterPortName, szOutput, iSize);

			stPrintCtrlTbl[nIdx].hDCPrint = hDC;
			stPrintCtrlTbl[nIdx].hPrintHdl = hPrint;
			return (hDC);
			}
		}

	assert(FALSE);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printCtrlDeleteDC
 *
 * DESCRIPTION:
 *	This function will destroy the print HDC accociated with the
 *	Printer Handle passed as the argument.	See printCtrlCreateDC for
 *	more information.
 *
 * ARGUMENTS:
 *	HPRINT	-	The External Printer Handle.
 *
 * RETURNS:
 *	void
 *
 */
void printCtrlDeleteDC(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;
	int   nIdx;

	if (hPrint == 0)
		assert(FALSE);

	if (hhPrint->hDC == 0)
		assert(FALSE);

	for (nIdx = 0; nIdx < MAX_NUM_PRINT_DC; nIdx++)
		{
		if (stPrintCtrlTbl[nIdx].hPrintHdl == hPrint)
			{
			if (DeleteDC(hhPrint->hDC) == TRUE)
				{
				stPrintCtrlTbl[nIdx].hPrintHdl = 0;
				stPrintCtrlTbl[nIdx].hDCPrint = 0;
				hhPrint->hDC = 0;
				return;
				}
			else
				{
				assert(FALSE);
				}
			}
		}

	assert(FALSE);
	return;

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printCtrlLookupDC
 *
 * DESCRIPTION:
 *	This function returns the External Print Handle that includes the
 *	supplied HDC.  This function was designed to be called by the
 *	PrintAbortProc routine.  See printCtrlCreateDC for more info.
 *
 * ARGUMENTS:
 *	HDC 	hDC -	A (printer) device context.
 *
 * RETURNS:
 *	HPRINT		-	An External print handle.
 *
 */
HPRINT printCtrlLookupDC(const HDC hDC)
	{
	int nIdx;

	for (nIdx = 0; nIdx < MAX_NUM_PRINT_DC; nIdx++)
		{
		if (stPrintCtrlTbl[nIdx].hDCPrint == hDC)
			return stPrintCtrlTbl[nIdx].hPrintHdl;
		}

	assert(FALSE);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printOpenDC
 *
 * DESCRIPTION:
 *	Does the nasty work of opening a printer DC and initializing it.
 *
 * ARGUMENTS:
 *	HHPRINT hhPrint - Internal print handle.
 *
 * RETURNS:
 *	TRUE on success.
 *
 */
int printOpenDC(const HHPRINT hhPrint)
	{
    HHPRINT hhSessPrint;
    int iLineHeight;
    int iVertRes;
    TCHAR achDocTitle[80];
     	
    if (hhPrint == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhPrint->hDC)
		return TRUE;

	// Get the printer information from the session print handle.  This
	// includes the printer name and other attributes that may have been
	// setup by the common print dialogs.
	//

    hhSessPrint = (HHPRINT) sessQueryPrintHdl(hhPrint->hSession);
    printQueryPrinterInfo( hhSessPrint, hhPrint );

	// Create the DC.
	//
	hhPrint->hDC = printCtrlCreateDC((HPRINT)hhPrint);
	if (hhPrint->hDC == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	printSetFont(hhPrint);
	printSetMargins(hhPrint);

	hhPrint->cx = hhPrint->marginsDC.left;							 
	hhPrint->cy = hhPrint->marginsDC.top;


	/* -------------- Figure out how many lines per page ------------- */

	GetTextMetrics(hhPrint->hDC, &hhPrint->tm);
	hhPrint->tmHeight = hhPrint->tm.tmHeight;

    iLineHeight = hhPrint->tm.tmHeight + hhPrint->tm.tmExternalLeading;
    iVertRes = GetDeviceCaps(hhPrint->hDC, VERTRES);
    iVertRes -= (hhPrint->marginsDC.top + hhPrint->marginsDC.bottom);

	if (iLineHeight == 0) //need to prevent a divide by zero error
		iLineHeight = 1;

   	hhPrint->nLinesPerPage = max( iVertRes / iLineHeight, 1);
	hhPrint->nLinesPrinted = 0;

    if (LoadString(glblQueryDllHinst(), IDS_PRINT_CAPTURE_DOC, 
	    achDocTitle, sizeof(achDocTitle)/sizeof(TCHAR)))
        {
    	lstrcpy(hhPrint->achDoc, achDocTitle);
        }

	/* -------------- Setup the Print Abort Proc ------------- */

	hhPrint->nStatus = SetAbortProc(hhPrint->hDC, (ABORTPROC)printAbortProc);

	/* -------------- Open printer ------------- */

	hhPrint->di.cbSize = sizeof(DOCINFO);
	hhPrint->di.lpszDocName = hhPrint->achDoc;
	hhPrint->di.lpszOutput = (LPTSTR)NULL;

	// StartDoc.
	//
	hhPrint->nStatus = StartDoc(hhPrint->hDC, &hhPrint->di);
	DbgOutStr("\r\nStartDoc: %d", hhPrint->nStatus, 0, 0, 0, 0);

	// StartPage.
	//
	if (hhPrint->nStatus > 0)
		{
		hhPrint->nStatus = StartPage(hhPrint->hDC);
        printSetFont( hhPrint );
		DbgOutStr("\r\nStartPage: %d", hhPrint->nStatus, 0, 0, 0, 0);
		}
	else
		{
		return FALSE;
		}

	if (hhPrint->nStatus <= 0)
		return FALSE;

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\printset.h ===
/*	File: D:\WACKER\tdll\printset.h (Created: 02-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:38p $
 */
File no longer used.

--jcm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\printset.c ===
/*	File: D:\WACKER\tdll\printset.c (Created: 02-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 11 $
 *	$Date: 7/08/02 6:46p $
 */
#include <windows.h>
#pragma hdrstop

#include <stdio.h>
#include <limits.h>
#include <term\res.h>

#include "stdtyp.h"
#include "mc.h"
#include "misc.h"
#include "assert.h"
#include "print.h"
#include "print.hh"
#include "globals.h"
#include "session.h"
#include "term.h"
#include "tdll.h"
#include "htchar.h"
#include "load_res.h"
#include "open_msc.h"
#include "open_msc.h"
#include "sf.h"
#include "file_msc.h"

static int printsetPrintToFile(const HPRINT hPrint);
static UINT_PTR APIENTRY printPageSetupHook( HWND hdlg, UINT uiMsg, WPARAM wParam,
                                         LPARAM lParam );

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printsetSetup
 *
 * DESCRIPTION:
 *	This function is used to display the common print dialogs.
 *
 * ARGUMENTS:
 *	hPrint	-	An external print handle.
 *	hwnd	-	owner window handle
 *
 * RETURNS:
 *	void
 *
 */
void printsetSetup(const HPRINT hPrint, const HWND hwnd)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;
#ifdef INCL_USE_NEWPRINTDLG
    PRINTDLGEX pd;
    HRESULT hResult;
#else
    PRINTDLG pd;
#endif
	LPDEVNAMES	pstDevNames;
	PDEVMODE	pstDevMode;

	TCHAR	*pszPrinterName;
	TCHAR	*pTemp;
	DWORD	dwSize;
	DWORD	dwError;

	#if defined(_DEBUG)
	TCHAR ach[100];
	#endif

	if (hhPrint == 0)
		{
		assert(FALSE);
		return;
		}

	// Initialize basic structure elements.
	//
#ifdef INCL_USE_NEWPRINTDLG
	memset (&pd, 0, sizeof(PRINTDLGEX));
	pd.lStructSize = sizeof(PRINTDLGEX);
    pd.Flags2 = 0;
    pd.nStartPage = START_PAGE_GENERAL;
    pd.dwResultAction = 0;
#else
    memset (&pd, 0, sizeof(PRINTDLG));
	pd.lStructSize = sizeof(PRINTDLG);
#endif
	pd.Flags = PD_NOWARNING | PD_NOPAGENUMS;
	pd.hwndOwner = hwnd;

	if (SendMessage(sessQueryHwndTerminal(hhPrint->hSession),
						WM_TERM_Q_MARKED, 0, 0))
		{
		pd.Flags |= PD_SELECTION;
		}

	// Use the previously stored information to initialize the print
	// common dialogs.	printGetDefaults initializes this information
	// when a print handle is created.
	//
	if (hhPrint->pstDevMode)
		{
		// Allocate memory for the DEVMODE information and then
		// initialize it with the stored values from the Print Handle.
		//
		dwSize = hhPrint->pstDevMode->dmSize +
					hhPrint->pstDevMode->dmDriverExtra;

		if ((pd.hDevMode = GlobalAlloc(GMEM_MOVEABLE, dwSize)))
			{
			if ((pstDevMode = GlobalLock(pd.hDevMode)))
				{
                if (dwSize)
				    MemCopy(pstDevMode, hhPrint->pstDevMode, dwSize);
				GlobalUnlock(pd.hDevMode);
				}
			}
		}

	if (hhPrint->pstDevNames)
		{
		// Allocate memory for the DEVNAMES structure in pd, then
		// initialize it with the stored values from the Print Handle.
		// This sequence determines the variable structure size of
		// DEVNAMES.
		//
		pTemp = (TCHAR *)hhPrint->pstDevNames;
		pTemp += hhPrint->pstDevNames->wOutputOffset;
		pTemp += StrCharGetByteCount(pTemp) + sizeof(TCHAR);

		dwSize = (DWORD)(pTemp - (TCHAR*)hhPrint->pstDevNames);

		if ((pd.hDevNames = GlobalAlloc(GMEM_MOVEABLE, dwSize)))
			{
			if ((pstDevNames = GlobalLock(pd.hDevNames)))
				{
                if (dwSize)
				    MemCopy(pstDevNames, hhPrint->pstDevNames, dwSize);
				GlobalUnlock(pd.hDevNames);
				}
			}
		}

	// Initialize the PrintToFilename array every time before we go
	// into the dialog.
	//
	TCHAR_Fill(hhPrint->achPrintToFileName,
				TEXT('\0'),
				sizeof(hhPrint->achPrintToFileName) / sizeof(TCHAR));

	// Display the dialog.
	//
#ifdef INCL_USE_NEWPRINTDLG
    pd.Flags2 = 0;
    hResult = PrintDlgEx( &pd );
    if ( hResult != S_OK)
#else
    if (!PrintDlg(&pd))
#endif
        {
		dwError = CommDlgExtendedError();

		#if defined(_DEBUG)
		if (dwError != 0)
			{
			wsprintf(ach, "PrintDlg error 0x%x", dwError);
			MessageBox(hwnd, ach, "Debug", MB_ICONINFORMATION | MB_OK);
			}
		#endif


		// If user canceled, we're done
		//
		if (dwError == 0)
			goto Cleanup;

		// Some error occured, try to bring-up dialog with default
		// data.
		//
		if (pd.hDevNames)
			{
			GlobalFree(pd.hDevNames);
			pd.hDevNames = 0;
			}

		if (pd.hDevMode)
			{
			GlobalFree(pd.hDevMode);
			pd.hDevMode = 0;
			}

		pd.Flags &= ~PD_NOWARNING;

#ifdef INCL_USE_NEWPRINTDLG
        hResult = PrintDlgEx(&pd);
        if ( hResult != S_OK)
#else
        if (!PrintDlg(&pd))
#endif
			{
			#if defined(_DEBUG)
			dwError = CommDlgExtendedError();

			if (dwError != 0)
				{
				wsprintf(ach, "PrintDlg error 0x%x", dwError);
				MessageBox(hwnd, ach, "Debug", MB_ICONINFORMATION | MB_OK);
				}
			#endif

			goto Cleanup;
			}
		}

#ifdef INCL_USE_NEWPRINTDLG
    // in the NT 5 print dialog, if the user cancels, the print dialog returns S_OK. 
    // So we need to check the result code to see if we should save the settings.
    if ( pd.dwResultAction == PD_RESULT_CANCEL )
        goto Cleanup;
#endif

    // Store the flags returned from the dialog in the Print Handle.
	// This has several pieces of info that will be used by the actual
	// printing  routines (i.e. print all, print selected).
	//
	hhPrint->nSelectionFlags = pd.Flags;

	// Store the printer name and location in the Print Handle
	// every time.
	//
	pstDevNames = GlobalLock(pd.hDevNames);
	if (!pstDevNames)
		{
		assert(FALSE);
		GlobalUnlock(pd.hDevMode);
		goto Cleanup;
		}
	pszPrinterName = (TCHAR *)pstDevNames;
	pszPrinterName += pstDevNames->wDeviceOffset;
	StrCharCopyN(hhPrint->achPrinterName, pszPrinterName, PRINTER_NAME_LEN);
	GlobalUnlock(pd.hDevNames);

	// Save the DEVMODE information in the Print Handle.  This memory
	// must be freed and allocated every time as the size of the
	// DEVMODE structure changes.
	//
	pstDevMode = GlobalLock(pd.hDevMode);
	dwSize = pstDevMode->dmSize + pstDevMode->dmDriverExtra;

	if (hhPrint->pstDevMode)
		free(hhPrint->pstDevMode);

	hhPrint->pstDevMode = (LPDEVMODE)malloc(dwSize);

	if (hhPrint->pstDevMode == 0)
		{
		assert(FALSE);
		GlobalUnlock(pd.hDevMode);
		goto Cleanup;
		}

    if (dwSize)
        MemCopy(hhPrint->pstDevMode, pstDevMode, dwSize);
	GlobalUnlock(pd.hDevMode);

	// Save the DEVNAMES information in the Print Handle.  Because the
	// size of the information in this structure varies, it is freed and
	// allocated each time it is saved.
	//
	pstDevNames = GlobalLock(pd.hDevNames);

	// Determine the size of the structure.
	//
	pTemp = (TCHAR *)pstDevNames;
	pTemp += pstDevNames->wOutputOffset;
	pTemp += StrCharGetByteCount(pTemp) + sizeof(TCHAR);

	dwSize = (DWORD)(pTemp - (TCHAR*)pstDevNames);

	if (hhPrint->pstDevNames)
		{
		free(hhPrint->pstDevNames);
		hhPrint->pstDevNames = NULL;
		}

	hhPrint->pstDevNames = (LPDEVNAMES)malloc(dwSize);

	if (hhPrint->pstDevNames == 0)
		{
		assert(0);
		GlobalUnlock(pd.hDevNames);
		goto Cleanup;
		}

    if (dwSize)
        MemCopy(hhPrint->pstDevNames, pstDevNames, dwSize);
	GlobalUnlock(pd.hDevNames);

	// Has the user selected Print To File?  Yes, you do need to look
	// for the string "FILE:" to determinae this!  If so, we will put
	// up our own common dialog to get the save as file name.
	//
	pTemp = (CHAR *)hhPrint->pstDevNames +
				hhPrint->pstDevNames->wOutputOffset;

	if (StrCharCmp("FILE:", pTemp) == 0)
		{
		if (printsetPrintToFile(hPrint) != 0)
			{
			goto Cleanup;
			}
		}

#ifdef INCL_USE_NEWPRINTDLG
    // in the NT 5 print dialog, if the user cancels or click 'apply', the print dialog returns S_OK. 
    // So we need to check the result code to see if we should now print 
    if ( pd.dwResultAction != PD_RESULT_PRINT )
        goto Cleanup;
#endif

    // Print the selected text.
	//
	printsetPrint(hPrint);

	// Cleanup any memory that may have been allocated.
	//
	Cleanup:

	if (pd.hDevNames)
		GlobalFree(pd.hDevNames);

	if (pd.hDevMode)
		GlobalFree(pd.hDevMode);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printsetPrint
 *
 * DESCRIPTION:
 *	This function prints the selected text from then terninal and/or the
 *	backscroll buffer.
 *
 * ARGUMENTS:
 *	hPrint	-	An external Print handle.
 *
 * RETURNS:
 *	void
 *
 */
void printsetPrint(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;
    int iLineHeight;
    int iVertRes;
	int 	iStatus,
			nRet;
    int iPrintableWidth;

    RECT stRect;

	DWORD	dwCnt, dwTime1, dwTime2;
	POINT	pX, pY;

	ECHAR *pechBuf;
	TCHAR	*pV,
			*pLS,
			*pLE,
			*pEnd,
			*pNext;

	if (hPrint == 0)
		{
		assert(FALSE);
		return;
		}

	// Get the text to print for selected text.
	//
	if (hhPrint->nSelectionFlags & PD_SELECTION)
		{
		if (!CopyMarkedTextFromTerminal(hhPrint->hSession,
											&pV,
											&dwCnt,
											FALSE))
			{
			if (pV)
				{
				free(pV);
				pV = NULL;
				}
			assert(FALSE);
			return;
			}

		if (dwCnt == 0)
			{
			if (pV)
				{
				free(pV);
				pV = NULL;
				}
			assert(FALSE);
			return;
			}
		}

	// Get the text to print into a buffer for an ALL selection.
	//
	else
		{
		pX.x = 0;
		pX.y = INT_MIN;

		pY.x = INT_MAX;
		pY.y = INT_MAX;

		nRet = CopyTextFromTerminal(hhPrint->hSession,
								&pX,
								&pY,
								&pechBuf,
								&dwCnt,
								FALSE);
		if (nRet == FALSE)
			{
			if (pechBuf)
				{
				free(pechBuf);
				pechBuf = NULL;
				}

			assert(FALSE);
			return;
			}

		// Strip Out Any repeated Characters in the string
		StrCharStripDBCSString(pechBuf,
		    (long)StrCharGetEcharByteCount(pechBuf), pechBuf);

		// hMem currently points to an array of ECHAR's, convert this to
		// TCHARS before giving the results to the caller.
		pV = malloc((ULONG)StrCharGetEcharByteCount(pechBuf) + 1);

		CnvrtECHARtoMBCS(pV, (ULONG)StrCharGetEcharByteCount(pechBuf) + 1,
				pechBuf,StrCharGetEcharByteCount(pechBuf)+1); // mrw:5/17/95

		free(pechBuf);
		pechBuf = NULL;
		dwCnt = (ULONG)StrCharGetByteCount(pV);
		}

	// Create the DC.
	//
	hhPrint->hDC = printCtrlCreateDC(hPrint);

	if (hhPrint->hDC == 0)
		{
		if (pV)
			{
			free(pV);
			pV = NULL;
			}

		assert(FALSE);
		return;
		}

    printSetFont( hhPrint );
    printSetMargins( hhPrint );

	// Initialize the DC.  Set the abort flag, determine the number
	// of lines per page, get the title of the window which will be used
	// as the name of the document to print.
	//
	hhPrint->fError = FALSE;
	hhPrint->fUserAbort = FALSE;
	hhPrint->nLinesPrinted = 0;
	hhPrint->nPage = 1;
	EnableWindow(sessQueryHwnd(hhPrint->hSession), FALSE);

	GetTextMetrics(hhPrint->hDC, &hhPrint->tm);

    iLineHeight = hhPrint->tm.tmHeight + hhPrint->tm.tmExternalLeading;
    iVertRes = GetDeviceCaps(hhPrint->hDC, VERTRES);
    iVertRes -= (hhPrint->marginsDC.top + hhPrint->marginsDC.bottom);

	if (iLineHeight == 0) //need to prevent a divide by zero error
		iLineHeight = 1;

	hhPrint->nLinesPerPage = max( iVertRes / iLineHeight, 1);

	GetWindowText(sessQueryHwnd(hhPrint->hSession),
					hhPrint->achDoc,
					sizeof(hhPrint->achDoc));

	// Create the Print Abort Dialog.
	//
	hhPrint->lpfnPrintDlgProc = printsetDlgProc;

	hhPrint->hwndPrintDlg = DoModelessDialog(glblQueryDllHinst(),
								MAKEINTRESOURCE(IDD_PRINTABORT),
								sessQueryHwnd(hhPrint->hSession),
								hhPrint->lpfnPrintDlgProc,
								(LPARAM)hhPrint);

	// Setup the Print Abort Procedure.
	//
	hhPrint->lpfnPrintAbortProc = printsetAbortProc;

	nRet = SetAbortProc(hhPrint->hDC,
					(ABORTPROC)hhPrint->lpfnPrintAbortProc);

	// Initialize and start the document.
	//
	hhPrint->di.cbSize = sizeof(DOCINFO);
	hhPrint->di.lpszDocName = hhPrint->achDoc;
	hhPrint->di.lpszDatatype = NULL;
	hhPrint->di.fwType = 0;

	// Initialize di.lpszOutput for either printing to a file,
	// or to a printer.
	//
	if (hhPrint->achPrintToFileName[0] == TEXT('\0'))
		{
		hhPrint->di.lpszOutput = (LPTSTR)NULL;
		}
	else
		{
		hhPrint->di.lpszOutput = (LPTSTR)hhPrint->achPrintToFileName;
		}

	// StartDoc.
	//
	iStatus = StartDoc(hhPrint->hDC, &hhPrint->di);
	DbgOutStr("\r\nStartDoc: %d", iStatus, 0, 0, 0, 0);
	if (iStatus == SP_ERROR)
		{
		printCtrlDeleteDC(hPrint);

		if (IsWindow(hhPrint->hwndPrintDlg))
				DestroyWindow(hhPrint->hwndPrintDlg);

		printTellError(hhPrint->hSession, hPrint, iStatus);

		assert(FALSE);
		return;
		}

	// StartPage.
	// Get more info on this.
	//
	iStatus = StartPage(hhPrint->hDC);
	DbgOutStr("\r\nStartPage: %d", iStatus, 0, 0, 0, 0);
    printSetFont( hhPrint );

	if (iStatus == SP_ERROR)
		{
		assert(FALSE);
		}

	// Move through the buffer that contins the text to print, and
	// get it done.
	//
	// pLS	= pointerLineStart
	// pLE	= pointerLineEnd
	// pEnd = pointerEndOfBuffer
	//
	pLS = pV;
	pLE = pV;
	pEnd = pV + (dwCnt - 1);

	while ((pLE <= pEnd) && !hhPrint->fError && !hhPrint->fUserAbort)
		{
		if (*pLE == TEXT('\r') || *pLE == TEXT('\0'))
			{
			pNext = pLE;

			// Remove trailing CR\LF\NULL as these mean nothing to
			// a Windows DC.
			//
			while (pLE >= pLS)
				{
				if (*pLE == TEXT('\r') || *pLE == TEXT('\n') ||
						*pLE == TEXT('\0'))
					{
					pLE--;
					continue;
					}

				break;
				}

			// Send the text out to the printer, bump the line count.
			//

            hhPrint->cx = hhPrint->marginsDC.left;
            hhPrint->cy = hhPrint->nLinesPrinted * hhPrint->tm.tmHeight +
                          hhPrint->marginsDC.top;

            iPrintableWidth = GetDeviceCaps( hhPrint->hDC, HORZRES );
            iPrintableWidth -= hhPrint->marginsDC.right;

            stRect.left   = hhPrint->cx;
            stRect.right  = iPrintableWidth;
            stRect.top    = hhPrint->cy;
            stRect.bottom = hhPrint->cy + hhPrint->tm.tmHeight;

            ExtTextOut( hhPrint->hDC, hhPrint->cx, hhPrint->cy, ETO_CLIPPED,
                        &stRect, pLS, (UINT)((pLE - pLS) + 1), NULL );

			hhPrint->nLinesPrinted += 1;

			if (hhPrint->nLinesPrinted == 1)
				{
				DbgOutStr("\r\nPost WM_PRINT_NEWPAGE", 0, 0, 0, 0, 0);
				PostMessage(hhPrint->hwndPrintDlg,
								WM_PRINT_NEWPAGE,
								0,
								(LPARAM)hhPrint);
				}

			// Check for a new page condition.
			//
			if ((hhPrint->nLinesPrinted >= hhPrint->nLinesPerPage))
				{
				hhPrint->nLinesPrinted = 0;
				hhPrint->nPage++;

				iStatus = EndPage(hhPrint->hDC);
				if (iStatus < 0)
					{
					hhPrint->fError = TRUE;
					printTellError(hhPrint->hSession, hPrint, iStatus);
					}
				else
					{
					iStatus = StartPage(hhPrint->hDC);
					DbgOutStr("\r\nStartPage: %d", iStatus, 0, 0, 0, 0);
                    printSetFont( hhPrint );

					if (iStatus <= 0)
						{
						DbgShowLastError();
						printTellError(hhPrint->hSession, hPrint, iStatus);
						}
					}
				}

			pLS = pLE = (pNext + 1);
			continue;
			}

		pLE++;
		}

	// Did we issue an EndPage for this page yet?
	//
	if (hhPrint->nLinesPrinted > 0)
		{
		iStatus = EndPage(hhPrint->hDC);
		DbgOutStr("\r\nEndPage: %d", iStatus, 0, 0, 0, 0);
		if (iStatus <= 0)
			{
			DbgShowLastError();
			printTellError(hhPrint->hSession, hPrint, iStatus);
			}
		}

	// Call EndDoc.
	//
	iStatus = EndDoc(hhPrint->hDC);
    if (iStatus <= 0)
			{
	    DbgShowLastError();
	    DbgOutStr("\r\nEndDoc: %d", iStatus, 0, 0, 0, 0);
	    printTellError(hhPrint->hSession, hPrint, iStatus);
        }

	// Final cleanup before exit.
	//
	if (!hhPrint->fUserAbort)
		{
		dwTime1 = (DWORD)GetWindowLongPtr(hhPrint->hwndPrintDlg, GWLP_USERDATA);
		dwTime2 = GetTickCount();
		if (dwTime2 - dwTime1 < 3000)
			Sleep( 3000 - (dwTime2 - dwTime1));

		EnableWindow(sessQueryHwnd(hhPrint->hSession), TRUE);
		DestroyWindow(hhPrint->hwndPrintDlg);
		}

	printCtrlDeleteDC(hPrint);

	if (pV)
		{
		free(pV);
		pV = NULL;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printsetAbortProc
 *
 * DESCRIPTION:
 *	This is the print abort procedure used when printing selected text.
 *	Note that this abort proc is not used for print echo, or for host
 *	directed printing.
 *
 * ARGUMENTS:
 *	HDC 	-	A printer DC.
 *	nCode	-	The status of the call.
 *
 * RETURNS:
 *	The abort status.
 *
 */
BOOL CALLBACK printsetAbortProc(HDC hdcPrn, INT nCode)
	{
	MSG msg;

	HHPRINT hhPrint = (HHPRINT)printCtrlLookupDC(hdcPrn);

	DbgOutStr("\r\nprintsetAbortProc Code: %d", nCode, 0, 0, 0, 0);

	while (!hhPrint->fUserAbort &&
				PeekMessage((LPMSG)&msg, (HWND)0, 0, 0, PM_REMOVE))
		{
		if (!hhPrint->hwndPrintDlg ||
				!IsDialogMessage(hhPrint->hwndPrintDlg, &msg))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}
		}

	return !hhPrint->fUserAbort;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printsetDlgProc
 *
 * DESCRIPTION:
 *	This is the dialog procedure for printing selected text.  It contains
 *	a CANCEL button that may be used to abort the printing process.
 *
 * ARGUMENTS:
 *	Note that a print handle is passed into this procedure in the lPar
 *	variable.
 *
 * RETURNS:
 *
 */
LRESULT CALLBACK printsetDlgProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	TCHAR achBuf[80];
	TCHAR achMessage[80];
	DWORD dwTime;
	HHPRINT hhPrint;
	LPTSTR	acPtrs[3];

	switch (uMsg)
		{
		case WM_INITDIALOG:
			DbgOutStr("\r\nprintsetDlgProc", 0, 0, 0, 0, 0);
			hhPrint = (HHPRINT)lPar;
			SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lPar);

			mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhPrint->hSession));
			LoadString(glblQueryDllHinst(),
						IDS_PRINT_NOW_PRINTING,
						achBuf,
						sizeof(achBuf) / sizeof(TCHAR));
			wsprintf(achMessage, achBuf, 1);
			SetDlgItemText(hwnd, 101, achMessage);
			LoadString(glblQueryDllHinst(),
							IDS_PRINT_OF_DOC,
							achBuf,
							sizeof(achBuf) / sizeof(TCHAR));
			wsprintf(achMessage, achBuf, hhPrint->achDoc);
			SetDlgItemText(hwnd, 102, achMessage);
			LoadString(glblQueryDllHinst(),
							IDS_PRINT_ON_DEV,
							achBuf,
							sizeof(achBuf) / sizeof(TCHAR));

			acPtrs[0] = hhPrint->achPrinterName;
			acPtrs[1] = (TCHAR *)hhPrint->pstDevNames +
						hhPrint->pstDevNames->wOutputOffset;

			FormatMessage(
				FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
				achBuf,
				0,				  /* Message ID, ignored */
				0,				  /* also ignored */
				achMessage, 	  /* result */
				sizeof(achMessage) / sizeof(TCHAR),
				(va_list *)&acPtrs[0]);

			SetDlgItemText(hwnd, 103, achMessage);

			dwTime = GetTickCount();
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)dwTime);
			return TRUE;

		case WM_COMMAND:
			DbgOutStr("\r\nprintsetDlgProc - CANCEL", 0, 0, 0, 0, 0);
			hhPrint = (HHPRINT)GetWindowLongPtr(hwnd, DWLP_USER);
			hhPrint->fUserAbort = TRUE;
			EnableWindow(sessQueryHwnd(hhPrint->hSession), TRUE);
			DestroyWindow(hwnd);
			hhPrint->hwndPrintDlg = 0;
			return TRUE;

		case WM_PRINT_NEWPAGE:
			DbgOutStr("\r\nprintsetDlgProc", 0, 0, 0, 0, 0);
			hhPrint = (HHPRINT)GetWindowLongPtr(hwnd, DWLP_USER);
			LoadString(glblQueryDllHinst(),
						IDS_PRINT_NOW_PRINTING,
						achBuf,
						sizeof(achBuf) / sizeof(TCHAR));
			wsprintf(achMessage, achBuf, hhPrint->nPage);
			SetDlgItemText(hwnd, 101, achMessage);
			return TRUE;

		default:
			break;
		}

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printPageSetup
 *
 * DESCRIPTION:
 *	Invokes the common page-setup dialog
 *
 * ARGUMENTS:
 *	HPRINT	hPrint	- public print handle
 *	HWND	hwnd	- window handle used for parent
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int printPageSetup(const HPRINT hPrint, const HWND hwnd)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;
	PAGESETUPDLG psd;
	LPDEVNAMES	pstDevNames;
	PDEVMODE	pstDevMode;

	TCHAR	*pszPrinterName;
	TCHAR	*pTemp;
	DWORD	dwSize;
    RECT    stMinMargins = {0,0,0,0};

	if (hPrint == 0)
		return -1;

	memset(&psd, 0, sizeof(psd));

	psd.lStructSize = sizeof(psd);
	psd.hwndOwner   = hwnd;
    psd.hInstance   = glblQueryDllHinst();

    psd.Flags       = PSD_ENABLEPAGESETUPTEMPLATE | PSD_ENABLEPAGESETUPHOOK |
                       PSD_MINMARGINS | PSD_MARGINS;

    psd.rtMargin    = hhPrint->margins;
    psd.rtMinMargin = stMinMargins;
    psd.lCustData   = (LPARAM)hhPrint;

    psd.lpPageSetupTemplateName = MAKEINTRESOURCE(IDD_CUSTOM_PAGE_SETUP);
    psd.lpfnPageSetupHook       = printPageSetupHook;

	// Use the previously stored information to initialize the print
	// common dialogs.	printGetDefaults initializes this information
	// when a print handle is created.
	//
	if (hhPrint->pstDevMode)
		{
		// Allocate memory for the DEVMODE information and then
		// initialize it with the stored values from the Print Handle.
		//
		dwSize = hhPrint->pstDevMode->dmSize +
					hhPrint->pstDevMode->dmDriverExtra;

		if ((psd.hDevMode = GlobalAlloc(GMEM_MOVEABLE, dwSize)))
			{
			if ((pstDevMode = GlobalLock(psd.hDevMode)))
				{
                if (dwSize)
				    MemCopy(pstDevMode, hhPrint->pstDevMode, dwSize);
				GlobalUnlock(psd.hDevMode);
				}
			}
		}

	if (hhPrint->pstDevNames)
		{
		// Allocate memory for the DEVNAMES structure in pd, then
		// initialize it with the stored values from the Print Handle.
		// This sequence determines the variable structure size of
		// DEVNAMES.
		//
		pTemp = (TCHAR *)hhPrint->pstDevNames;
		pTemp += hhPrint->pstDevNames->wOutputOffset;
		pTemp += StrCharGetByteCount(pTemp) + sizeof(TCHAR);

		dwSize = (DWORD)(pTemp - (TCHAR*)hhPrint->pstDevNames);

		if ((psd.hDevNames = GlobalAlloc(GMEM_MOVEABLE, dwSize)))
			{
			if ((pstDevNames = GlobalLock(psd.hDevNames)))
				{
                if (dwSize)
				    MemCopy(pstDevNames, hhPrint->pstDevNames, dwSize);
				GlobalUnlock(psd.hDevNames);
				}
			}
		}

	if (!PageSetupDlg(&psd))
		{
		#if defined(_DEBUG)
	    TCHAR ach[100];
		DWORD dwError = CommDlgExtendedError();

		if (dwError != 0)
			{
			wsprintf(ach, "PrintDlg error 0x%x", dwError);
			MessageBox(hwnd, ach, "Debug", MB_ICONINFORMATION | MB_OK);
			}
		#endif

		return -2;
		}

    // store the margin settings in the print handle.
    //
    hhPrint->margins = psd.rtMargin;

	// Store the printer name and location in the Print Handle
	// every time.
	//
	pstDevNames = GlobalLock(psd.hDevNames);
	pszPrinterName = (TCHAR *)pstDevNames;
	pszPrinterName += pstDevNames->wDeviceOffset;
	StrCharCopyN(hhPrint->achPrinterName, pszPrinterName, PRINTER_NAME_LEN);
	GlobalUnlock(psd.hDevNames);

	// Save the DEVMODE information in the Print Handle.  This memory
	// must be freed and allocated every time as the size of the
	// DEVMODE structure changes.
	//
	pstDevMode = GlobalLock(psd.hDevMode);
	dwSize = pstDevMode->dmSize + pstDevMode->dmDriverExtra;

	if (hhPrint->pstDevMode)
		{
		free(hhPrint->pstDevMode);
		hhPrint->pstDevMode = NULL;
		}

	hhPrint->pstDevMode = (LPDEVMODE)malloc(dwSize);

	if (hhPrint->pstDevMode == 0)
		{
		assert(FALSE);
		GlobalUnlock(psd.hDevMode);
		goto Cleanup;
		}

    if (dwSize)
        MemCopy(hhPrint->pstDevMode, pstDevMode, dwSize);
	GlobalUnlock(psd.hDevMode);

	// Save the DEVNAMES information in the Print Handle.  Because the
	// size of the information in this structure varies, it is freed and
	// allocated each time it is saved.
	//
	pstDevNames = GlobalLock(psd.hDevNames);

	// Determine the size of the structure.
	//
	pTemp = (TCHAR *)pstDevNames;
	pTemp += pstDevNames->wOutputOffset;
	pTemp += StrCharGetByteCount(pTemp) + sizeof(TCHAR);

	dwSize = (DWORD)(pTemp - (TCHAR*)pstDevNames);

	if (hhPrint->pstDevNames)
		{
		free(hhPrint->pstDevNames);
		hhPrint->pstDevNames = NULL;
		}

	hhPrint->pstDevNames = (LPDEVNAMES)malloc(dwSize);

	if (hhPrint->pstDevNames == 0)
		{
		assert(0);
		GlobalUnlock(psd.hDevNames);
		goto Cleanup;
		}
    if (dwSize)
	    MemCopy(hhPrint->pstDevNames, pstDevNames, dwSize);
	GlobalUnlock(psd.hDevNames);


	// Cleanup any memory that may have been allocated.
	//
    Cleanup:

	if (psd.hDevNames)
		GlobalFree(psd.hDevNames);

	if (psd.hDevMode)
		GlobalFree(psd.hDevMode);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	  printPageSetupHook
 *
 * DESCRIPTION:
 *    A hook function to process the font button on the page setup dialog
 *
 * ARGUMENTS:
 *   hdlg   - handle to the dialog box window
 *   uiMsg  - message identifier
 *   wParam - message parameter
 *   lParam - message parameter
 *	
 * RETURNS:
 *	0 = message not processed 1 = message processeed
 *
 * Author:
 *  Dwayne Newsome 02/19/97
 *
 */

static UINT_PTR APIENTRY printPageSetupHook( HWND hdlg, UINT uiMsg, WPARAM wParam,
                                         LPARAM lParam )
    {
    static HHPRINT  hhPrint;
    static PAGESETUPDLG * pPageSetup;

    UINT processed = 0;

	LPDEVNAMES	pstDevNames;
	TCHAR *     pszPrinterName;

    //
    // on the init dialog message save a pointer to the pagesetup dialog and
    // save the print handle
    //

    if ( uiMsg == WM_INITDIALOG )
        {
        pPageSetup = ( PAGESETUPDLG *) lParam;
        hhPrint = (HHPRINT) pPageSetup->lCustData;
        }

    //
    // Looking for the font button click here, if we get it set the currently
    // selected printers name in the saved print handle and display the font
    // dialog.  We save the printer name so the font dialog can show the
    // correct fonts for the currently selected printer.
    //

    else if ( uiMsg == WM_COMMAND )
        {
        if ( HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == 1027 )
            {
            processed = 1;
        	pstDevNames = GlobalLock(pPageSetup->hDevNames);
        	pszPrinterName = (TCHAR *)pstDevNames;
        	pszPrinterName += pstDevNames->wDeviceOffset;
        	StrCharCopyN(hhPrint->achPrinterName, pszPrinterName, PRINTER_NAME_LEN);
        	GlobalUnlock(pPageSetup->hDevNames);

            DisplayFontDialog( hhPrint->hSession, TRUE );
            }
        }

    return processed;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printsetPrintToFile
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *	HPRINT	hPrint	- public print handle
 *
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int printsetPrintToFile(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;

	TCHAR		acTitle[64],
				acMask[128],
				acDir[256],
				acFile[256];

	LPTSTR		pszPrintFile;

	HWND		hWnd;
	HINSTANCE	hInst;

	LPTSTR		pszStr;

	TCHAR_Fill(acTitle, 	TEXT('\0'), sizeof(acTitle) / sizeof(TCHAR));
	TCHAR_Fill(acMask,		TEXT('\0'), sizeof(acMask) / sizeof(TCHAR));
	TCHAR_Fill(acDir,		TEXT('\0'), sizeof(acDir) / sizeof(TCHAR));
	TCHAR_Fill(acFile,		TEXT('\0'), sizeof(acFile) / sizeof(TCHAR));

	hWnd = glblQueryHwndFrame();
	hInst = glblQueryDllHinst();

	LoadString(hInst,
				IDS_PRINT_TOFILE,
				acTitle,
				sizeof(acTitle) / sizeof(TCHAR));

	LoadString(hInst,
				IDS_PRINT_FILENAME,
				acFile,
				sizeof(acFile) / sizeof(TCHAR));

	resLoadFileMask(hInst,
						IDS_PRINT_FILTER_1,
						2,
						acMask,
						sizeof(acMask) / sizeof(TCHAR));

	// Figure out which directory to propose to the user for the 'print to'
	// file.  If we have a session file, use that session files directory,
	// otherwise use the current directory.
	//
	if (sfGetSessionFileName(sessQuerySysFileHdl(hhPrint->hSession),
								sizeof(acDir) / sizeof(TCHAR),
								acDir) == SF_OK)
		{
		mscStripName(acDir);
		}
	else
		{
		//Changed to use working folder rather than current folder - mpt 8-18-99
		if ( !GetWorkingDirectory( acDir, sizeof(acDir) / sizeof(TCHAR)) )
			{
			GetCurrentDirectory(sizeof(acDir) / sizeof(TCHAR), acDir);
			}
		}

	pszStr = StrCharLast(acDir);

	// Remove trailing backslash from the directory name if there is one.
	//
	if (pszStr && *pszStr == TEXT('\\'))
		*pszStr = TEXT('\0');

	pszPrintFile = gnrcSaveFileDialog(hWnd,
										(LPCTSTR)acTitle,
										(LPCTSTR)acDir,
										(LPCTSTR)acMask ,
										(LPCTSTR)acFile);

	if (pszPrintFile == NULL)
		{
		return(1);
		}

	// pszPrintFile gets allocated in gnrcSaveFileDlg.
	//
	StrCharCopyN(hhPrint->achPrintToFileName, pszPrintFile, PRINTER_NAME_LEN);
	free(pszPrintFile);
	pszPrintFile = NULL;

	return(0);

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\printhdl.c ===
/*      File: D:\WACKER\tdll\printhdl.c (Created: 10-Dec-1993)
 *
 *      Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *      All rights reserved
 *
 *      $Revision: 5 $
 *      $Date: 6/13/01 4:12p $
 */

#include <windows.h>
#pragma hdrstop

#include <term\res.h>

#include "stdtyp.h"
#include "mc.h"
#include "assert.h"
#include "print.h"
#include "print.hh"
#include "sf.h"
#include "tdll.h"
#include "htchar.h"
#include "term.h"
#include "session.h"
#include "sess_ids.h"
#include "statusbr.h"
#include "globals.h"
#include "errorbox.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      printCreateHdl
 *
 * DESCRIPTION:
 *      Creates a print handle.
 *
 *
 * ARGUMENTS:
 *      hSession        - Exteranl session handle
 *
 * RETURNS:
 *      Returns an External Print Handle, or 0 if an error.
 *
 */
HPRINT printCreateHdl(const HSESSION hSession)
	{
	HHPRINT hhPrint = 0;

	hhPrint = malloc(sizeof(*hhPrint));

	if (hhPrint == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hhPrint, 0, sizeof(*hhPrint));

	hhPrint->hSession = hSession;

	InitializeCriticalSection(&hhPrint->csPrint);

	if (printInitializeHdl((HPRINT)hhPrint) != 0)
		{
		printDestroyHdl((HPRINT)hhPrint);
		hhPrint = NULL;
		return 0;
		}

	return (HPRINT)hhPrint;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      printInitializeHdl
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *      hPrint - External print handle.
 *
 * RETURNS:
 *      0 if successful, otherwise -1
 *
 */
int printInitializeHdl(const HPRINT hPrint)
	{
	unsigned long  lSize;
	const HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR *tmp = 0;
	TCHAR achBuf[256];
	TCHAR *pszString;
	int		nCharSet;

	if (hhPrint == 0)
		return -1;

	hhPrint->nLnIdx = 0;

	// Initialize the printer name to the default.
	//
	if (GetProfileString("Windows", "Device", ",,,", achBuf,
					sizeof(achBuf)) && (pszString = strtok(achBuf, ",")))
		{
		StrCharCopyN(hhPrint->achPrinterName, pszString, sizeof(hhPrint->achPrinterName) / sizeof(TCHAR));
		}
	else
		{
		// Just to let you know, there is no printer.
		//
		assert(FALSE);
		hhPrint->achPrinterName[0] = TEXT('\0');
		}

	if (hhPrint->pstDevMode != NULL)
		{
		free(hhPrint->pstDevMode);
		hhPrint->pstDevMode = NULL;
		}

	if (hhPrint->pstDevNames != NULL)
		{
		free(hhPrint->pstDevNames);
		hhPrint->pstDevNames = NULL;
		}

	lSize = sizeof(hhPrint->achPrinterName);

	sfGetSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_NAME,
						&lSize,
						hhPrint->achPrinterName);


	lSize = 0;
	if (sfGetSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_DEVMODE,
						&lSize,
						0) == 0 && lSize)
		{
		if ((hhPrint->pstDevMode = malloc(lSize)))
			{
			sfGetSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_DEVMODE,
						&lSize,
						hhPrint->pstDevMode);
			}
		}

	lSize = 0;
	if (sfGetSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_DEVNAMES,
						&lSize,
						0) == 0 && lSize)
		{
		if ((hhPrint->pstDevNames = malloc(lSize)))
			{
			sfGetSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_DEVNAMES,
						&lSize,
						hhPrint->pstDevNames);
			}
		}

    //
    // get the font and margin settings
    //

    memset(&hhPrint->lf, 0, sizeof(LOGFONT));
    memset(&hhPrint->margins, 0, sizeof(RECT));
    hhPrint->hFont = NULL;

	lSize = sizeof(hhPrint->margins);
	sfGetSessionItem( sessQuerySysFileHdl(hhPrint->hSession),
		      SFID_PRINTSET_MARGINS,
					  &lSize, &hhPrint->margins );

	lSize = sizeof(hhPrint->lf);
	sfGetSessionItem( sessQuerySysFileHdl(hhPrint->hSession),
		      SFID_PRINTSET_FONT,
					  &lSize, &hhPrint->lf );

	lSize = sizeof(hhPrint->iFontPointSize);
	sfGetSessionItem( sessQuerySysFileHdl(hhPrint->hSession),
		      SFID_PRINTSET_FONT_HEIGHT,
					  &lSize, &hhPrint->iFontPointSize );


    //
    // use default if we have no value stored
    //

    if (hhPrint->lf.lfHeight == 0)
		{
		TCHAR faceName[100];

		if ( LoadString(glblQueryDllHinst(), IDS_PRINT_DEF_FONT,
			faceName, sizeof (hhPrint->lf.lfFaceName) / sizeof(TCHAR)) )
			{
			StrCharCopyN( hhPrint->lf.lfFaceName, faceName, sizeof (faceName) / sizeof(TCHAR) );
			hhPrint->lf.lfFaceName[sizeof(hhPrint->lf.lfFaceName)/sizeof(TCHAR)-1] = TEXT('\0');
			}

		hhPrint->lf.lfHeight    = -17;
		hhPrint->iFontPointSize = 100;
		
		//mpt:2-4-98 changed to use resources so that dbcs fonts print correctly
		if (LoadString(glblQueryDllHinst(), IDS_PRINT_DEF_CHARSET,
			achBuf, sizeof(achBuf) / sizeof(TCHAR)))
			{
			nCharSet = atoi(achBuf);
			hhPrint->lf.lfCharSet = (BYTE)nCharSet;
			}
		
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      printSaveHdl
 *
 * DESCRIPTION:
 *      Saves the name of the selected printer in the session file.
 *
 * ARGUMENTS:
 *      hPrint   -       The external printer handle.
 *
 * RETURNS:
 *      void
 *
 */
void printSaveHdl(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;
	unsigned long ulSize;
	TCHAR *sz;

	sfPutSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_NAME,
						StrCharGetByteCount(hhPrint->achPrinterName) +
							sizeof(TCHAR),
						hhPrint->achPrinterName);

	if (hhPrint->pstDevMode)
		{
		ulSize = hhPrint->pstDevMode->dmSize +
			hhPrint->pstDevMode->dmDriverExtra;

		sfPutSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_DEVMODE,
						ulSize,
						hhPrint->pstDevMode);
		}

	if (hhPrint->pstDevNames)
		{
		// Getting the size of a DEVNAMES structure is harder.
		//
		sz = (TCHAR *)hhPrint->pstDevNames +
			hhPrint->pstDevNames->wOutputOffset;

		sz += StrCharGetByteCount((LPCSTR)sz) + sizeof(TCHAR);
		ulSize = (unsigned long)(sz - (TCHAR *)hhPrint->pstDevNames);

		sfPutSessionItem(sessQuerySysFileHdl(hhPrint->hSession),
						SFID_PRINTSET_DEVNAMES,
						ulSize,
						hhPrint->pstDevNames);
		}

    //
    // save the font and margin settings
    //

	sfPutSessionItem( sessQuerySysFileHdl(hhPrint->hSession),
		      SFID_PRINTSET_MARGINS,
					  sizeof(hhPrint->margins), &hhPrint->margins );

	sfPutSessionItem( sessQuerySysFileHdl(hhPrint->hSession),
		      SFID_PRINTSET_FONT,
					  sizeof(hhPrint->lf), &hhPrint->lf );

	sfPutSessionItem( sessQuerySysFileHdl(hhPrint->hSession),
		      SFID_PRINTSET_FONT_HEIGHT,
					  sizeof(hhPrint->iFontPointSize),
		      &hhPrint->iFontPointSize );


	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      printDestroyHdl
 *
 * DESCRIPTION:
 *      Destroys a valid print handle.
 *
 * ARGUMENTS:
 *      hPrint   - AN External Print Handle.
 *
 * RETURNS:
 *      void
 *
 */
void printDestroyHdl(const HPRINT hPrint)
	{
	const HHPRINT hhPrint = (HHPRINT)hPrint;

	if (hhPrint == 0)
		return;

	if (hhPrint->hFont)
	    {
		DeleteObject(hhPrint->hFont);
	    }

	printEchoClose(hPrint);

	DeleteCriticalSection(&hhPrint->csPrint);

    //
    // Don't forget to free the Printer Device and Printer Name,
    // or else there will be a memory leak. REV: 06/13/2001.
    //
	if (hhPrint->pstDevMode != NULL)
		{
		free(hhPrint->pstDevMode);
		hhPrint->pstDevMode = NULL;
		}

	if (hhPrint->pstDevNames != NULL)
		{
		free(hhPrint->pstDevNames);
		hhPrint->pstDevNames = NULL;
		}

	free(hhPrint);
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\property.h ===
/*	File: D:\WACKER\tdll\property.h (Created: 19-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:21p $
 */

extern void 	DoInternalProperties(HSESSION hSession, HWND hwnd);
INT_PTR CALLBACK GeneralTabDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
INT_PTR CALLBACK TerminalTabDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
void 			propLoadEmulationCombo(const HWND hDlg, const HSESSION hSession);
int  			propGetEmuIdfromEmuCombo(HWND hDlg, HSESSION hSession);
void 			propUpdateTitle(HSESSION hSession, HWND hDlg, LPTSTR pachOldName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\printset.hh ===
/*	File: D:\WACKER\tdll\printset.hh (Created: 02-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:36p $
 */
This file no longer used!
--jcm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\property.c ===
/*	File: D:\WACKER\tdll\property.c (Created: 19-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 7/08/02 6:46p $
 */

#include <windows.h>
#pragma hdrstop

#include <prsht.h>
#include <commctrl.h>
#include <time.h>

#include <tdll\assert.h>
#include "stdtyp.h"
#include "mc.h"
#include "misc.h"
#include "globals.h"
#include "session.h"
#include "load_res.h"
#include "htchar.h"
#include <emu\emuid.h>
#include <emu\emu.h>
#include <emu\emudlgs.h>
#include "cnct.h"
#include <cncttapi\cncttapi.h>
#include <term\res.h>

#include "property.h"
#include "statusbr.h"
#include "tdll.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  DoInternalProperties
 *
 * DESCRIPTION:
 *  Display the property sheet as seen from within an open session, i.e., the
 *	general tab is not a part of it.
 *
 * PARAMETERS:
 *  hSession - the session handle.
 *	hwnd	 - window handle.
  *
 * RETURNS:
 *	Nothing.
 */
void DoInternalProperties(HSESSION hSession, HWND hwnd)
	{
	TCHAR			achName[256];
	PROPSHEETHEADER stH;
	HPROPSHEETPAGE  hP[2];
    PROPSHEETPAGE	stP;

    hP[0] = hP[1] = (HPROPSHEETPAGE)0;

	memset(&stP, 0, sizeof(stP));

	stP.dwSize		 = sizeof(PROPSHEETPAGE);
	stP.dwFlags 	 = 0;
	stP.hInstance	 = glblQueryDllHinst();
	stP.pszTemplate  = MAKEINTRESOURCE(IDD_TAB_PHONENUMBER);
	stP.pfnDlgProc	 = NewPhoneDlg;
	stP.lParam		 = (LPARAM)hSession;
	stP.pfnCallback  = 0;

	hP[0] = CreatePropertySheetPage(&stP);

	stP.dwSize		 = sizeof(PROPSHEETPAGE);
	stP.dwFlags 	 = 0;
	stP.hInstance	 = glblQueryDllHinst();
	stP.pszTemplate  = MAKEINTRESOURCE(IDD_TAB_TERMINAL);
	stP.pfnDlgProc	 = TerminalTabDlg;
	stP.lParam		 = (LPARAM)hSession;
	stP.pfnCallback  = 0;

	hP[1] = CreatePropertySheetPage(&stP);

    sessQueryName(hSession, achName, sizeof(achName));
	memset(&stH, 0, sizeof(stH));

	stH.dwSize 			= sizeof(PROPSHEETHEADER);
	stH.hwndParent 		= hwnd;
	stH.hInstance 		= glblQueryDllHinst();
	stH.pszCaption		= achName;
    stH.nPages			= 2;
	stH.nStartPage 		= 0;
	stH.phpage 			= hP;
	stH.dwFlags 		= PSH_PROPTITLE | PSH_NOAPPLYNOW;

	PropertySheet(&stH);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  propUpdateTitle
 *
 * DESCRIPTION:
 *  When the user changes the name of the session we need to reflect the change
 *	in the property sheet title.  Right now it uses "Property sheet for <lpszStr>".
 *  in the english version. Since there appears to be no way to dynamically
 *  change property sheet's title, we implemented this function.  We avoid
 *  placing any part of the title in the resource file to prevent problems with
 *  international versions, order of words, etc. and most importantly possible
 *	discrepancy	with the title string used by Microsoft in the property sheet.
 *	Instead we read the current title, match on the old session name and replace
 *	it with the new session name.
 *
 * PARAMETERS:
 *  hSession 	- the session handle.
 *  hDlg 		- handle of the property sheet tab dialog.
 *  pachOldName - pointer to the old session name.
 *
 * RETURNS:
 *	Nothing.
 */
void propUpdateTitle(HSESSION hSession, HWND hDlg, LPTSTR pachOldName)
	{
	HWND	hwnd = GetParent(hDlg);
	TCHAR	acTitle[256], acName[256], acNewTitle[256];
	LPTSTR	pszStr, pszStr2;

	GetWindowText(hwnd, acTitle, sizeof(acTitle));
	sessQueryName(hSession, acName, sizeof(acName));
	if (acName[0] != TEXT('\0'))
		{
		TCHAR_Fill(acNewTitle, TEXT('\0'), sizeof(acNewTitle) / sizeof(TCHAR));

		// TODO: What if the session name matches title text, eg.
		// "Properties for properties"?
		// Also, looks like I will have to write my own strstr() but
		// let's wait and see what Mircorsoft will tell us...
		//
		// if ((pszStr = (LPTSTR)strstr(acTitle, pachOldName)) != NULL)
		if ((pszStr = StrCharStrStr(acTitle, pachOldName)) != NULL)
			{
			for (pszStr2 = pszStr;
				 *pszStr2 || *pachOldName != TEXT('\0');
				 pszStr2 = StrCharNext(pszStr2),
				 pachOldName = StrCharNext(pachOldName))
				 {
				 continue;
				 }

			*pszStr = TEXT('\0');

			StrCharCopyN(acNewTitle, acTitle, sizeof(acNewTitle) / sizeof(TCHAR) );
			StrCharCat(acNewTitle, acName);
			StrCharCat(acNewTitle, pszStr2);
			}

		SetWindowText(hwnd, acNewTitle);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\prnecho.c ===
/*	File: D:\wacker\tdll\prnecho.c (Created: 24-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 3/15/02 12:16p $
 */
//#define DEBUGSTR 1

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "session.h"
#include "assert.h"
#include "print.h"
#include "print.hh"
#include "tdll.h"
#include "htchar.h"
#include "mc.h"

//#define DEBUGSTR

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printEchoChar
 *
 * DESCRIPTION:
 *	Prints a single character by formating it for printString().
 *
 * ARGUMENTS:
 *	HPRINT		hPrint	- The external print handle.
 *	ECHAR		tChar	- The character to print.
 *
 * RETURNS:
 *	TRUE = OK, FALSE = error
 *
 */
int printEchoChar(const HPRINT hPrint, const ECHAR tChar)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR *pszTemp;
	int	nByteCnt;

	if ((hhPrint->nFlags & PRNECHO_IS_ON) == 0 ||
			(hhPrint->nFlags & PRNECHO_PAUSE))
		return FALSE;

/*
	if ((hhPrint->nFlags & PRNECHO_CHARS) == 0)
		return FALSE;
*/

	// A bit of history.  Originally I just sent the character along
	// to the PrintString function.  However, this generated a large
	// metafile that caused Windows to crash and burn.	Microsoft
	// suggested banding but that was more work than I wanted.	So the
	// kludge fix is to gather them-there characters into an array and
	// flush-um out when the time comes.

	hhPrint->achPrnEchoLine[hhPrint->nLnIdx++] = tChar;

	if (tChar == ETEXT('\n') ||
		hhPrint->nLnIdx >= (int)((sizeof(hhPrint->achPrnEchoLine) / sizeof(ECHAR)) - 1))
		{
		// Force LF.
		//
		hhPrint->achPrnEchoLine[hhPrint->nLnIdx-1] = ETEXT('\n');

		// Convert over to a MBCS string for printing
		pszTemp = malloc(sizeof(hhPrint->achPrnEchoLine)+sizeof(ECHAR));

		nByteCnt = CnvrtECHARtoMBCS(pszTemp, sizeof(hhPrint->achPrnEchoLine),
									hhPrint->achPrnEchoLine,
									hhPrint->nLnIdx * sizeof(ECHAR));

		// Make sure that the string is NULL terminated.
		pszTemp[nByteCnt] = TEXT('\0');
		DbgOutStr("%s",pszTemp,0,0,0,0);
		printString(hhPrint, pszTemp, StrCharGetByteCount(pszTemp));
		free(pszTemp);
		pszTemp = NULL;

		hhPrint->nLnIdx = 0;									

		ECHAR_Fill(hhPrint->achPrnEchoLine,
					ETEXT('\0'),
					sizeof(hhPrint->achPrnEchoLine)/sizeof(ECHAR));
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printEchoString
 *
 * DESCRIPTION:
 *	External interface to print a string.
 *
 * ARGUMENTS:
 *	HPRINT		hPrint		- The external print handle.
 *	ECHAR 	   *achPrintStr - A pointer to an array of characters string.
 *							  Include "\r\n" to finish a line.
 *	int 		iLen		- The number of characters to print.
 *
 * RETURNS:
 *	TRUE on success.
 *
 */
int printEchoString(HPRINT hPrint, ECHAR *achPrintStr, int iLen)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR *pszTemp;
	int nByteCnt;
	int nRet = 0;

	if ((hhPrint->nFlags & PRNECHO_IS_ON) == 0 ||
			(hhPrint->nFlags & PRNECHO_PAUSE))
		return FALSE;

	if ((hhPrint->nFlags & PRNECHO_LINES) == 0)
		return FALSE;

	pszTemp = malloc((unsigned int)iLen * sizeof(ECHAR));
	nByteCnt = CnvrtECHARtoMBCS(pszTemp, (unsigned int)iLen * sizeof(ECHAR),
						achPrintStr, (unsigned int)iLen * sizeof(ECHAR));

	// Make sure that the string is NULL terminated.
	pszTemp[nByteCnt] = ETEXT('\0');
	DbgOutStr("%s",pszTemp,0,0,0,0);
	nRet = printString(hhPrint, pszTemp, nByteCnt);
	free(pszTemp);
	pszTemp = NULL;

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printEchoScreen
 *
 * DESCRIPTION:
 *	Really the same func as printEchoString but checks if we are
 *	in screen mode.  This keeps the PrintEchoString from intermixing
 *	lines in the output.
 *
 * ARGUMENTS:
 *
 *	HPRINT		hPrint		- The external print handle.
 *	ECHAR 	   *pszPrintStr - A pointer to NULL terminated string.
 *							  Include "\r\n" to finish a line.
 * RETURNS:
 *	TRUE = OK, FALSE = error.
 *
 */
int printEchoScreen(HPRINT hPrint, ECHAR *achPrintStr, int iLen)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR *pszTemp;
	int nByteCnt;
	int nRet;

	if ((hhPrint->nFlags & PRNECHO_IS_ON) == 0 ||
			(hhPrint->nFlags & PRNECHO_PAUSE))
		return FALSE;

	if ((hhPrint->nFlags & PRNECHO_SCREENS) == 0)
		return FALSE;

	pszTemp = malloc((unsigned int)iLen * sizeof(ECHAR));
	nByteCnt = CnvrtECHARtoMBCS(pszTemp, (unsigned int)iLen * sizeof(ECHAR),
					achPrintStr, (unsigned int)iLen * sizeof(ECHAR));

	// Make sure that the string is NULL terminated.
	pszTemp[nByteCnt] = ETEXT('\0');
	DbgOutStr("%s",pszTemp,0,0,0,0);
	nRet = printString(hhPrint, pszTemp, (unsigned int)nByteCnt);
	free(pszTemp);
	pszTemp = NULL;

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printEchoStart
 *
 * DESCRIPTION:
 *	The print echo functions are general purpose and not limited to the
 *	print echo function.  However, we still need to set flags so that
 *	printing takes place.  This function was added so that host directed
 *	printing which uses the print echo functions could get started.
 *
 * ARGUMENTS:
 *	HPRINT		hPrint	- The external Print handle.
 *
 * RETURNS:
 *	TRUE		If successful,
 *	FALSE		If the external print handle is bad.
 *
 */
int printEchoStart(HPRINT hPrint)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;

	if (hPrint == 0)
		return FALSE;

	hhPrint->nFlags |= PRNECHO_IS_ON;
	hhPrint->nFlags &= ~PRNECHO_PAUSE;

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	printEchoClose
 *
 * DESCRIPTION:
 *	This function cleans up a print operation by closing the printer DC
 *	and forcing the remaining pages out to the print spooler.
 *
 * ARGUMENTS:
 *	HPRINT		hPrint	- The external Print handle.
 *
 * RETURNS:
 *	TRUE
 *
 */
int printEchoClose(HPRINT hPrint)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR *pszTemp;
	int	nByteCnt;

    //
    // if there are chars in the buffer that have never been sent to the printer
    // flush them now.
    //

	if (hhPrint->nLnIdx > 0)
		{
		// Convert over to a MBCS string for printing
		pszTemp = malloc(sizeof(hhPrint->achPrnEchoLine)+sizeof(ECHAR));

		nByteCnt = CnvrtECHARtoMBCS(pszTemp, sizeof(hhPrint->achPrnEchoLine),
									hhPrint->achPrnEchoLine,
									hhPrint->nLnIdx * sizeof(ECHAR));

		// Make sure that the string is NULL terminated.
		pszTemp[nByteCnt] = ETEXT('\0');
		DbgOutStr("%s",pszTemp,0,0,0,0);
		printString(hhPrint, pszTemp, StrCharGetByteCount(pszTemp));
		free(pszTemp);
		pszTemp = NULL;

		hhPrint->nLnIdx = 0;									

		ECHAR_Fill(hhPrint->achPrnEchoLine,
					ETEXT('\0'),
					sizeof(hhPrint->achPrnEchoLine)/sizeof(ECHAR));
		}

	if (hhPrint->hDC)
		{
		if (hhPrint->nStatus >= 0)
			{
			hhPrint->nStatus = EndPage(hhPrint->hDC);

			if (hhPrint->nStatus >= 0)
				hhPrint->nStatus = EndDoc(hhPrint->hDC);

			DbgOutStr("EndPage/EndDoc\r\n", 0, 0, 0, 0, 0);
			}

		printCtrlDeleteDC(hPrint);
		}

//	  hhPrint->nFlags &= ~(PRNECHO_IS_ON | PRNECHO_PAUSE);

	if (hhPrint->nStatus < 0)
		NotifyClient(hhPrint->hSession,
						EVENT_PRINT_ERROR,
						(WORD)hhPrint->nStatus);

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PrintEchoRaw
 *
 * DESCRIPTION:
 *	Fires data directly at the printing avoiding the print driver.
 *	Certain modes of the DEC emulators use this.
 *
 * ARGUMENTS:
 *	HPRINT		hPrint		- The external print handle.
 *	ECHAR 		*pszPrintStr - The null terminated string to print.
 *
 * RETURNS:
 *	TRUE		if the string was printed successfully, otherwise
 *	FALSE
 *
 */
int printEchoRaw(HPRINT hPrint, ECHAR *pszPrintStr, int nLen)
	{
	HHPRINT hhPrint = (HHPRINT)hPrint;
	TCHAR   ach[1024];
    assert( nLen <= 1024 );

	if (hhPrint->hDC == 0)
		{
		if (printOpenDC(hhPrint) == FALSE)
			{
			printEchoClose((HPRINT)hhPrint);
			return FALSE;
			}
		}

	if (hhPrint->nStatus > 0)
		{
        char * pBuffer;
        short sLength;

		CnvrtECHARtoMBCS(ach, sizeof(ach), pszPrintStr, (unsigned int)nLen);

        pBuffer = (char*) malloc( nLen + sizeof(short) + 1);
        sLength = (short)nLen;

        MemCopy( pBuffer, &sLength, sizeof( short ));
        if (nLen)
            MemCopy( pBuffer + sizeof(short), &ach, nLen );
        pBuffer[nLen + sizeof( short )] = '\0';

        hhPrint->nStatus = Escape( hhPrint->hDC, PASSTHROUGH, 0, pBuffer, NULL );
        free( pBuffer );
		pBuffer = NULL;

        //
        // if pasthrough fails then send the data through the print driver
        //

        if ( hhPrint->nStatus < 0 )
            {
            printEchoString(hPrint, pszPrintStr, nLen);
            }
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * printEchoLine
 *
 * DESCRIPTION:
 *	Adds CR LF to specified line of text and prints the line.
 *
 *
 * ARGUMENTS:
 *	hPrint		-	The external print handle.
 *	pachLine	-	A pointer to the text to print.
 *	iLen		-	The number of characters pointed to by pachLine.
 *
 * RETURNS:
 *	nothing
 */
void printEchoLine(const HPRINT hPrint, ECHAR *pachLine, int iLen)
	{
	ECHAR aech[256];
	printEchoString(hPrint, pachLine, iLen);

 	CnvrtMBCStoECHAR(aech, sizeof(aech), TEXT("\r\n"),
 		             StrCharGetByteCount(TEXT("\r\n")));

	printEchoString(hPrint, aech, sizeof(ECHAR) * 2);
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\property.hh ===
/*	File: D:\WACKER\tdll\property.hh (Created: 28-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:40p $
 */

// Let's keep all of the ASCII settings in one place...
//
typedef struct STASCIISET
	{

	int fsetSendCRLF;
	int fsetLocalEcho;
	int fsetAddLF;
	int fsetASCII7;
	int fsetWrapLines;
	int iLineDelay;
	int iCharDelay;

	} STASCIISET, *pSTASCIISET;

// Local structure...
// Put in whatever else you might need to access later
//
typedef struct SDS
	{

	STEMUSET	stEmuSettings;		// Emulator settings

	STASCIISET	stAsciiSettings;	// Ascii settings

	HSESSION 	hSession;

	} SDS, *pSDS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\registry.c ===
/*	File: D:\WACKER\tdll\registry.c (Created: 26-Nov-1996 by cab)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description:
 *      Declares the functions used for manipulating the Windows 95
 *      system registry.
 *
 *      An explanation of registry terms:
 *
 *          The Windows 95 registry uses the terms "keys", "values",
 *          and "data". The way the registry stores information can
 *          best be described as a folder analogy.
 *
 *          Keys are the equivalent of folders. The can contain other
 *          keys (subkeys) or values.
 *
 *          Values are the equivalent of documents. They contain data.
 *
 *          The data is the actual contents of the document, i.e. it
 *          is the information we are interested in.
 *
 *      An example:
 *
 *          HyperTerminal uses the registry to store the value of the
 *          "Don't ask me this question" check box of the "Default Telnet
 *          App" dialog.
 *
 *          The key for this is "HKEY_LOCAL_MACHINE\SOFTWARE\Hilgraeve\
 *          HyperTerminal PE\3.0".
 *
 *          The value for this is "Telnet Check".
 *
 *          The data for this will be either 0 or 1 depending on if the
 *          user wants HT to check if it is the default telnet app.
 *
 *	$Revision: 3 $
 *	$Date: 3/26/02 8:59a $
 */

#include <windows.h>
#pragma hdrstop

#include "assert.h"
#include "stdtyp.h"
#include "htchar.h"


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	htRegOpenKey
 *
 * DESCRIPTION:
 *	Opens the specified key. If the key does not exist, it will be
 *  created.
 *
 * PARAMETERS:
 *	hKey      - A pointer to an opened key.
 *  pszSubKey - The name of the subkey to open.
 *  samAccess - The type of access desired for the key.
 *  phOpenKey - Pointer to the opened key.
 *
 * RETURNS:
 *	ERROR_SUCCESS if successful, otherwise an error value.
 *
 * AUTHOR:  C. Baumgartner, 12/06/96
 */
long htRegOpenKey(HKEY hKey, LPCTSTR pszSubKey, REGSAM samAccess, HKEY* phOpenKey)
    {
    DWORD dwDisposition = 0;

    // Instead of calling RegOpenKeyEx, call RegCreateKeyEx which will return
    // an open in key, but will also create a key that does not exist.
    //
    return RegCreateKeyEx(hKey, pszSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
        samAccess, NULL, phOpenKey, &dwDisposition);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	htRegQueryValue
 *
 * DESCRIPTION:
 *	A generic function to get a value from the registry.
 *
 * PARAMETERS:
 *	hKey        - A pointer to an opened key.
 *  pszSubKey   - The name of the subkey to open.
 *  pszValue    - The name of the value to query.
 *  pData       - The value's data.
 *  pdwDataSize - Upon input this must be the size of pData,
 *                on exit this will be the size of the data
 *                read.
 *
 * RETURNS:
 *	0 if successful, -1 if error.
 *
 * AUTHOR:  C. Baumgartner, 11/26/96
 */
 INT_PTR htRegQueryValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                         LPBYTE pData, LPDWORD pdwDataSize)
    {
    long lResult = ERROR_SUCCESS;
    HKEY hSubKey = 0;
    
    // Open the sub key with the given name.
    //
    lResult = htRegOpenKey(hKey, pszSubKey, KEY_READ, &hSubKey);

    if ( lResult == ERROR_SUCCESS )
        {
        // Get value of that subkey.
        //
        lResult = RegQueryValueEx(hSubKey, pszValue, NULL, NULL,
                pData, pdwDataSize);
        }

    if (hSubKey != 0)
        {
        RegCloseKey(hSubKey);
        }

    return lResult == ERROR_SUCCESS ? 0 : -1;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	regSetStringValue
 *
 * DESCRIPTION:
 *	A generic function to set the value of a registry entry. This value
 *  is a null-terminated string.
 *
 * PARAMETERS:
 *	hKey        - A pointer to an opened key.
 *  pszSubKey   - The name of the subkey to open.
 *  pszValue    - The name of the value to query.
 *  pszData     - The value's *string* data.
 *
 * RETURNS:
 *	0 if successful, -1 if error.
 *
 * AUTHOR:  C. Baumgartner, 11/27/96
 */
INT_PTR regSetStringValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                          LPCTSTR pszData)
    {
    long  lResult = ERROR_SUCCESS;
    DWORD dwSize = 0;
    HKEY  hSubKey = 0;
    
    // Open the sub key with the given name.
    //
    lResult = htRegOpenKey(hKey, pszSubKey, KEY_WRITE, &hSubKey);

    if ( lResult == ERROR_SUCCESS )
        {
        // The size of the string must include the null terminator.
        //
        dwSize = StrCharGetByteCount(pszData) + sizeof(TCHAR);

        // Set value of that subkey.
        //
        lResult = RegSetValueEx(hSubKey, pszValue, 0, REG_SZ,
                pszData, dwSize);
        }

    if (hSubKey != 0)
        {
        RegCloseKey(hSubKey);
        }

    return lResult == ERROR_SUCCESS ? 0 : -1;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	regSetDwordValue
 *
 * DESCRIPTION:
 *	A generic function to set the value of a registry entry. This value
 *  is a doubleword (32 bits).
 *
 * PARAMETERS:
 *	hKey        - A pointer to an opened key.
 *  pszSubKey   - The name of the subkey to open.
 *  pszValue    - The name of the value to query.
 *  dwData      - The value's *doubleword* data.
 *
 * RETURNS:
 *	0 if successful, -1 if error.
 *
 * AUTHOR:  C. Baumgartner, 11/27/96
 */
INT_PTR regSetDwordValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                         DWORD dwData)
    {
    long  lResult = ERROR_SUCCESS;
    HKEY  hSubKey = 0;
    
    // Open the sub key with the given name.
    //
    lResult = htRegOpenKey(hKey, pszSubKey, KEY_WRITE, &hSubKey);

    if ( lResult == ERROR_SUCCESS )
        {
        // Set value of that subkey.
        //
        lResult = RegSetValueEx(hSubKey, pszValue, 0, REG_DWORD,
                (LPBYTE)&dwData, sizeof(dwData));
        }

    if (hSubKey != 0)
        {
        RegCloseKey(hSubKey);
        }

    return lResult == ERROR_SUCCESS ? 0 : -1;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\registry.h ===
#if !defined(INCL_REGISTRY)
#define INCL_REGISTRY

/*	File: D:\WACKER\tdll\registry.h (Created: 27-Nov-1996 by cab)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description:
 *      Declares the functions used for manipulating the Windows 95
 *      system registry.
 *
 *      An explanation of registry terms:
 *
 *          The Windows 95 registry uses the terms "keys", "values",
 *          and "data". The way the registry stores information can
 *          best be described as a folder analogy.
 *
 *          Keys are the equivalent of folders. The can contain other
 *          keys (subkeys) or values.
 *
 *          Values are the equivalent of documents. They contain data.
 *
 *          The data is the actual contents of the document, i.e. it
 *          is the information we are interested in.
 *
 *      An example:
 *
 *          HyperTerminal uses the registry to store the value of the
 *          "Don't ask me this question" check box of the "Default Telnet
 *          App" dialog.
 *
 *          The key for this is "HKEY_LOCAL_MACHINE\SOFTWARE\Hilgraeve\
 *          HyperTerminal PE\3.0".
 *
 *          The value for this is "Telnet Check".
 *
 *          The data for this will be either 0 or 1 depending on if the
 *          user wants HT to check if it is the default telnet app.
 *
 *	$Revision: 2 $
 *	$Date: 3/26/02 8:59a $
 */

// htRegQueryValue
//
// A generic function to get a value from the registry.
// Returns 0 if successful, -1 if error.
//
INT_PTR htRegQueryValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                        LPBYTE pData, LPDWORD pdwDataSize);

// regSetStringValue
//
// A generic function to set the value of a registry entry. This value
// is a null-terminated string. Returns 0 if successful, -1 if error.
//
INT_PTR regSetStringValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                          LPCTSTR pszData);

// regSetDwordValue
//
// A generic function to set the value of a registry entry. This value
// is a doubleword (32 bits). Returns 0 if successful, -1 if error.
//
INT_PTR regSetDwordValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszValue,
                         DWORD dwData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\send_dlg.c ===
/*	File: C:\WACKER\TDLL\send_dlg.c (Created: 22-Dec-1993)
 *	created from:
 *	File: C:\WACKER\TDLL\genrcdlg.c (Created: 16-Ded-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 18 $
 *	$Date: 7/08/02 6:46p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>
#include "stdtyp.h"
#include "mc.h"
#include "tdll.h"
#include "misc.h"
#include <tdll\assert.h>
#include <term\res.h>
#include "session.h"
#include "file_msc.h"
#include "load_res.h"
#include "open_msc.h"
#include "errorbox.h"
#include "globals.h"
#include "cnct.h"
#include "htchar.h"

#include "xfer_msc.h"
#include "xfer_msc.hh"
#include <xfer\xfer.h>

#include "hlptable.h"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	HSESSION hSession;
	TCHAR acDirectory[FNAME_LEN];
	};

typedef	struct stSaveDlgStuff SDS;

#define IDC_TF_FILENAME 100
#define	FNAME_EDIT	    101
#define	BROWSE_BTN	    102
#define IDC_TF_PROTOCOL	103
#define	PROTO_COMBO	    104
#define IDC_PB_CLOSE	105
#define FOLDER_LABEL    106
#define FOLDER_NAME     107
#define IDC_PB_SEND		108

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	TransferSendDlg
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK TransferSendDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	INT           nReturn = TRUE;
	HWND	      hwndChild;
	INT		      nId;
	INT		      nNtfy;
	SDS          *pS;
	int 	      nIndex;
	int 	      nState;
	int 	      nProto;
    int           nChars = 0;
    int           nXferSendReturn = 0;
	TCHAR	      acBuffer[FNAME_LEN];
	TCHAR	      acTitle[64];
	TCHAR	      acList[64];
	LPTSTR        pszStr;
	LPTSTR       *pszArray;
	LPTSTR	      pszRet;
	HCURSOR       hCursor;
	XFR_PARAMS   *pP;
	XFR_PROTOCOL *pX;
	HSESSION      hSession;
    HXFER         hXfer = NULL;
	XD_TYPE      *pT = NULL;

	static	DWORD aHlpTable[] = {FNAME_EDIT,		IDH_TERM_SEND_FILENAME,
								 IDC_TF_FILENAME,	IDH_TERM_SEND_FILENAME,
								 BROWSE_BTN,		IDH_BROWSE,
								 IDC_TF_PROTOCOL,	IDH_TERM_SEND_PROTOCOL,
								 PROTO_COMBO,		IDH_TERM_SEND_PROTOCOL,
								 IDC_PB_SEND,		IDH_TERM_SEND_SEND,
								 IDC_PB_CLOSE,		IDH_OK,
                                 IDOK,              IDH_OK,
                                 IDCANCEL,          IDH_CANCEL,
								 0, 				0};


	switch (wMsg)
		{
	case WM_INITDIALOG:
		{
		TCHAR achDirectory[MAX_PATH];
		DWORD dwStyle = SS_WORDELLIPSIS;

		hSession = (HSESSION)lPar;

		pS = (SDS *)malloc(sizeof(SDS));
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			break;
			}

		SendMessage(GetDlgItem(hDlg, FNAME_EDIT),
					EM_SETLIMITTEXT,
					FNAME_LEN, 0);

		pS->hSession = hSession;
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		pP = (XFR_PARAMS *)0;
		xfrQueryParameters(sessQueryXferHdl(hSession), (VOID **)&pP);
		assert(pP);

		/*
		 * Load selections into the PROTOCOL COMBO box
		 */

		nState = pP->nSndProtocol;

		nProto = 0;

		mscResetComboBox(GetDlgItem(hDlg, PROTO_COMBO));

		pX = (XFR_PROTOCOL *)0;
		xfrGetProtocols(hSession, &pX);
		assert(pX);
		if (pX != (XFR_PROTOCOL *)0)
			{
			for (nIndex = 0; pX[nIndex].nProtocol != 0; nIndex += 1)
				{
				if (nState == pX[nIndex].nProtocol)
					nProto = nIndex;

                //jmh 02-13-96 Use CB_ADDSTRING to sort entries as
                // they are added. CB_INSERTSTRING doesn't do this,
                // even if the combo-box has the CBS_SORT style.
				SendMessage(GetDlgItem(hDlg, PROTO_COMBO),
							CB_ADDSTRING,
							0,
							(LPARAM)&pX[nIndex].acName[0]);
				}

            SendMessage(GetDlgItem(hDlg, PROTO_COMBO),
                        CB_SELECTSTRING,
                        0,
                        (LPARAM) &pX[nProto].acName[0]);

			free(pX);
			pX = NULL;
			}

		PostMessage(hDlg, WM_COMMAND,
					PROTO_COMBO,
					MAKELONG(GetDlgItem(hDlg, PROTO_COMBO),CBN_SELCHANGE));

		StrCharCopyN(pS->acDirectory,
				filesQuerySendDirectory(sessQueryFilesDirsHdl(hSession)), FNAME_LEN);

        // The send button should always be disabled when we start. It
        // will be enabled when the user types in a file name. - cab:12/06/96
        //
		EnableWindow(GetDlgItem(hDlg, IDC_PB_SEND), FALSE);

		// Initialize the folder name field.
		//
		if (GetWindowsMajorVersion() >  4)
			{
			dwStyle = SS_PATHELLIPSIS;
			}

		TCHAR_Fill(achDirectory, TEXT('\0'), MAX_PATH);

		StrCharCopyN(achDirectory, pS->acDirectory, MAX_PATH);

		mscModifyToFit(GetDlgItem(hDlg, FOLDER_NAME), achDirectory, dwStyle);

		SetDlgItemText(hDlg, FOLDER_NAME, achDirectory);

		/* Set the focus to the file name */
		SetFocus(GetDlgItem(hDlg, FNAME_EDIT));
		nReturn = FALSE;
		}
		break;

	case WM_DESTROY:
		mscResetComboBox(GetDlgItem(hDlg, PROTO_COMBO));
		pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDC_PB_SEND:
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
            assert(pS);
            if (pS == NULL)
                {
                break;
                }

			hSession = pS->hSession;
            assert(hSession);

            if (hSession == NULL)
                {
                break;
                }

            hXfer = sessQueryXferHdl(hSession);
            assert(hXfer);

            if (hXfer == NULL)
                {
                break;
                }

            //
            // See if a file transfer is currently in progress.
            //
	        pT = (XD_TYPE *)hXfer;
            assert(pT);

            if (pT == (XD_TYPE *)0)
                {
                break;
                }
            else if (pT->nDirection != XFER_NONE)
                {
                nXferSendReturn = XFR_IN_PROGRESS;
                }
			else if(cnctQueryStatus(sessQueryCnctHdl(hSession))
                        != CNCT_STATUS_TRUE && nId == IDC_PB_SEND)
				{
				//
				// We are currently not connected (loss of carrier),
				// so disable the Recieve button. REV: 9/7/2001
				//
				nXferSendReturn = XFR_NO_CARRIER;
				mscMessageBeep(MB_ICONHAND);
				EnableWindow(GetDlgItem(hDlg, IDC_PB_SEND), FALSE);
				}
            else
				{
			    pP = (XFR_PARAMS *)0;
			    xfrQueryParameters(hXfer, (VOID **)&pP);
			    assert(pP);

			    /*
			     * Save selection from the PROTOCOL COMBO box
			     */
			    pX = (XFR_PROTOCOL *)0;
			    xfrGetProtocols(hSession, &pX);
			    assert(pX);

			    if (pX != (XFR_PROTOCOL *)0)
				    {
				    GetDlgItemText(hDlg, PROTO_COMBO, acBuffer, FNAME_LEN);

				    for (nIndex = 0; pX[nIndex].nProtocol != 0; nIndex += 1)
					    {
					    if (StrCharCmp(acBuffer, pX[nIndex].acName) == 0)
						    {
						    pP->nSndProtocol = pX[nIndex].nProtocol;
						    break;
						    }
					    }
				    free(pX);
				    pX = NULL;
				    }

                GetDlgItemText(hDlg, FNAME_EDIT, acBuffer, FNAME_LEN);

				fileFinalizeName(
							acBuffer,
							pS->acDirectory,
							acBuffer,
							FNAME_LEN);

				/* Split the name and the directory */
				pszStr = StrCharFindLast(acBuffer, TEXT('\\'));
				if (pszStr)
					{
					*pszStr++ = TEXT('\0');
					}
				
				if (nId == IDC_PB_SEND)
                    {
					int nIdx = 0;

					hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

				    nIndex = 0;
				    pszArray = NULL;

				    fileBuildFileList((void **)&pszArray,
							    &nIndex,
							    pszStr,
							    FALSE,
							    acBuffer);

					nIdx = nIndex;

				    if (nIndex == 0)
					    {
					    if (sessQuerySound(hSession))
							{
						    mscMessageBeep(MB_ICONHAND);
							}

					    LoadString(glblQueryDllHinst(),
							    IDS_ER_XFER_NO_FILE,
							    acBuffer,
							    FNAME_LEN);

					    TimedMessageBox(hDlg,
									    acBuffer,
									    NULL,
									    MB_OK | MB_ICONEXCLAMATION,
									    sessQueryTimeout(hSession)
									    );

					    if (pszArray)
						    {
						    free(pszArray);
						    pszArray = NULL;
						    }
					    break;
					    }

				    while (nIndex-- > 0)
					    {
					    nXferSendReturn = xfrSendAddToList(hXfer, pszArray[nIndex]);
					    free(pszArray[nIndex]);
					    pszArray[nIndex] = NULL;

						if (nXferSendReturn == XFR_NO_MEMORY)
							{
							//
							// Make sure to free the rest of the file
							// list when a memory error is returned
							// from xfrSendAddToList(). REV: 2/4/2002
							//
							while (--nIndex >= 0)
								{
								if (pszArray[nIndex])
									{
									free(pszArray[nIndex]);
									pszArray[nIndex] = NULL;
									}
								}
							break;
							}
					    }

				    if (pszArray)
					    {
						while (--nIdx >= 0)
							{
							if (pszArray[nIdx])
								{
								free(pszArray[nIdx]);
								pszArray[nIdx] = NULL;
								}
							}

						free(pszArray);
						pszArray = NULL;
						}

				    if (nXferSendReturn == XFR_NO_MEMORY)
						{
						//
						// There was a memory error, so free the
						// file list and exit here.
						//
						XD_TYPE *pXD_Type;

						// pXD_Type = (XD_TYPE *)sessQueryXferHdl(hSession);
						pXD_Type = (XD_TYPE *)hXfer;

						if (pXD_Type != (XD_TYPE *)0)
							{
							/* Clear list */
							for (nIndex = pXD_Type->nSendListCount - 1; nIndex >=0; nIndex--)
								{
								if (pXD_Type->acSendNames[nIndex])
									{
									free(pXD_Type->acSendNames[nIndex]);
									pXD_Type->acSendNames[nIndex] = NULL;
									}
								pXD_Type->nSendListCount = nIndex;
								}

							free(pXD_Type->acSendNames);
							pXD_Type->acSendNames = NULL;
							pXD_Type->nSendListCount = 0;
							}

						break;
						}

				    SetCursor(hCursor);

				    nXferSendReturn = xfrSendListSend(hXfer);
				    }
                }

            //
            // Don't save the settings if a file transfer is in
            // progress otherwise the current file transfer could
            // get corrupted.  REV: 08/06/2001.
            //
            if (nXferSendReturn == XFR_IN_PROGRESS)
                {
                TCHAR acMessage[256];

			    if (sessQuerySound(hSession))
                    {
				    mscMessageBeep(MB_ICONHAND);
                    }

			    LoadString(glblQueryDllHinst(),
					    IDS_ER_XFER_SEND_IN_PROCESS,
					    acMessage,
					    sizeof(acMessage) / sizeof(TCHAR));

			    TimedMessageBox(sessQueryHwnd(hSession),
							    acMessage,
							    NULL,
							    MB_OK | MB_ICONEXCLAMATION,
							    sessQueryTimeout(hSession));
                }
			else if(nXferSendReturn == XFR_NO_CARRIER)
				{
				//
				// We are currently not connected (loss of carrier),
				// so disable the Send button.
				//
				mscMessageBeep(MB_ICONHAND);
				EnableWindow(GetDlgItem(hDlg, IDC_PB_SEND), FALSE);
				}
            else
                {
			    /*
			     * Do whatever saving is necessary
			     */
			    xfrSetParameters(hXfer, (VOID *)pP);
			    
			    if (mscIsDirectory(acBuffer))
				    {
				    filesSetSendDirectory(sessQueryFilesDirsHdl(hSession),
										    acBuffer);
				    }

                /* Free the storeage */
			    EndDialog(hDlg, TRUE);
                }

			break;

		case XFER_CNCT:
			if(nXferSendReturn == XFR_NO_CARRIER)
				{
				//
				// We are currently not connected (loss of carrier),
				// so disable the Send button.
				//
				mscMessageBeep(MB_ICONHAND);
				EnableWindow(GetDlgItem(hDlg, IDC_PB_SEND), FALSE);
				}
			else
				{
				EnableWindow(GetDlgItem(hDlg, IDC_PB_SEND), TRUE);
				}
			break;

        case FNAME_EDIT:
            // This dialog would crash if the user pressed 'Send' and no
            // filename was specified. Ideally, the 'Send' button should
            // be disabled until we have a filename. - cab:12/06/96
            //
            if ( nNtfy == EN_UPDATE )
                {
			    pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			    hSession = pS->hSession;

                // Are we connected? If not, leave the send button disabled.
		        //
		        if ( cnctQueryStatus(sessQueryCnctHdl(hSession))
                        == CNCT_STATUS_TRUE )
                    {
                    // Get the number of characters in the edit box.
                    //
	                nChars = (int)SendMessage(GetDlgItem(hDlg, FNAME_EDIT),
				                EM_LINELENGTH, 0, 0);

                    EnableWindow(GetDlgItem(hDlg, IDC_PB_SEND), nChars != 0);
                    }
                }
            break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		case BROWSE_BTN:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

			LoadString(glblQueryDllHinst(),
						IDS_SND_DLG_FILE,
						acTitle,
						sizeof(acTitle) / sizeof(TCHAR));

			resLoadFileMask(glblQueryDllHinst(),
						IDS_CMM_ALL_FILES1,
						1,
						acList,
						sizeof(acList) / sizeof(TCHAR));

			pszRet = gnrcFindFileDialog(hDlg,
						acTitle,
						pS->acDirectory,
						acList);

			if (pszRet != NULL)
				{
				DWORD dwStyle = SS_WORDELLIPSIS;
				TCHAR achDirectory[MAX_PATH];

				TCHAR_Fill(achDirectory, TEXT('\0'), MAX_PATH);

				SetDlgItemText(hDlg, FNAME_EDIT, pszRet);

				mscStripName(pszRet);

				pszStr = StrCharLast(pszRet);

				// Remove the trailing backslash from the name
				// returned from mscStripName.	Leave it on
				// in the case of a root directory specification.
				//
				if (pszStr > pszRet + (3 * sizeof(TCHAR)) )
					{
					if (pszStr &&  ( *pszStr == TEXT('\\') || *pszStr == TEXT('/')))
						*pszStr = TEXT('\0');
					}

				if (GetWindowsMajorVersion() >  4)
					{
					dwStyle = SS_PATHELLIPSIS;
					}

				mscModifyToFit(GetDlgItem(hDlg, FOLDER_NAME), pszRet, dwStyle);
				SetDlgItemText(hDlg, FOLDER_NAME, pszRet);

				free(pszRet);
				pszRet = NULL;
				}
			break;

			default:
				nReturn = FALSE;
				break;
			}
		break;

	default:
		nReturn = FALSE;
		break;
		}

	return nReturn;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\recv_dlg.c ===
/*	File: C:\WACKER\TDLL\recv_dlg.c (Created: 27-Dec-1993)
 *
 *	Copyright 1990,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 16 $
 *	$Date: 4/17/02 5:16p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>
#include "stdtyp.h"
#include "mc.h"
#include "hlptable.h"

#include "tdll.h"
#include "misc.h"
#include <tdll\assert.h>
#include <term\res.h>
#include "session.h"
#include "globals.h"
#include "file_msc.h"
#include "load_res.h"
#include "open_msc.h"
#include "errorbox.h"
#include "cnct.h"
#include "htchar.h"
#include "errorbox.h"

#include "xfer_msc.h"
#include "xfer_msc.hh"
#include <xfer\xfer.h>

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	HSESSION hSession;
	};

typedef	struct stSaveDlgStuff SDS;

#define IDC_TF_FILENAME 100
#define	IDC_EB_DIR 		101
#define	IDC_PB_BROWSE	102
#define IDC_TF_PROTOCOL 103
#define IDC_CB_PROTOCOL 104
#define IDC_PB_CLOSE	105
#define IDC_PB_RECEIVE  106

INT_PTR CALLBACK TransferReceiveFilenameDlg(HWND hDlg,
	         								UINT wMsg,
			            					WPARAM wPar,
						    				LPARAM lPar);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	TransferReceiveDlg
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK TransferReceiveDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	HWND          hwndChild;
	INT           nId;
	INT           nNtfy;
	SDS          *pS;
	int           nProto;
	int           nIndex;
	int           nState;
	int           nProtocol;
    int           nXferRecvReturn = 0;
	TCHAR         acBuffer[FNAME_LEN];
	TCHAR         acName[FNAME_LEN];
	LPCTSTR       pszDir;
	LPTSTR	      pszPtr;
	LPTSTR	      pszStr;
	XFR_PARAMS   *pP;
	XFR_PROTOCOL *pX;
	HSESSION      hSession;
    HXFER         hXfer = NULL;
	XD_TYPE       *pT = NULL;

	static	DWORD aHlpTable[] = {IDC_EB_DIR,		IDH_TERM_RECEIVE_DIRECTORY,
								 IDC_TF_FILENAME,	IDH_TERM_RECEIVE_DIRECTORY,
								 IDC_PB_BROWSE, 	IDH_BROWSE,
								 IDC_TF_PROTOCOL,	IDH_TERM_RECEIVE_PROTOCOL,
								 IDC_CB_PROTOCOL,	IDH_TERM_RECEIVE_PROTOCOL,
                                 IDC_PB_RECEIVE,    IDH_TERM_RECEIVE_RECEIVE,
								 IDC_PB_CLOSE,		IDH_CLOSE_DIALOG,
                                 IDCANCEL,          IDH_CANCEL,
                                 IDOK,              IDH_OK,
								 0, 				0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		if (pS == 0)
			{
			EndDialog(hDlg, FALSE);
			break;
			}

		SendMessage(GetDlgItem(hDlg, IDC_EB_DIR),
					EM_SETLIMITTEXT,
					FNAME_LEN, 0);

		hSession = (HSESSION)lPar;
		pS->hSession = hSession;

		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		pP = (XFR_PARAMS *)0;
		xfrQueryParameters(sessQueryXferHdl(hSession), (VOID **)&pP);
		assert(pP);

		nState = pP->nRecProtocol;

		/*
		 * Load selections into the PROTOCOL COMBO box
		 */
		nProto = 0;

		mscResetComboBox(GetDlgItem(hDlg, IDC_CB_PROTOCOL));

		pX = (XFR_PROTOCOL *)0;
		xfrGetProtocols(hSession, &pX);
		assert(pX);

		if (pX != (XFR_PROTOCOL *)0)
			{
			for (nIndex = 0; pX[nIndex].nProtocol != 0; nIndex += 1)
				{
				if (nState == pX[nIndex].nProtocol)
					nProto = nIndex;

                //jmh 02-13-96 Use CB_ADDSTRING to sort entries as
                // they are added. CB_INSERTSTRING doesn't do this,
                // even if the combo-box has the CBS_SORT style.
				SendMessage(GetDlgItem(hDlg, IDC_CB_PROTOCOL),
							CB_ADDSTRING,
							0,  //(UINT) -1
							(LPARAM)&pX[nIndex].acName[0]);
				}

            SendMessage(GetDlgItem(hDlg, IDC_CB_PROTOCOL),
                        CB_SELECTSTRING,
                        0,
                        (LPARAM) &pX[nProto].acName[0]);

			free(pX);
			pX = NULL;
			}

		PostMessage(hDlg, WM_COMMAND,
					IDC_CB_PROTOCOL,
					MAKELONG(GetDlgItem(hDlg, IDC_CB_PROTOCOL),CBN_SELCHANGE));
		/*
		 * Set the current directory
		 */
		pszDir = filesQueryRecvDirectory(sessQueryFilesDirsHdl(hSession));
		SetDlgItemText(hDlg, IDC_EB_DIR, pszDir);

		// Check if we're connected.  If not, disable Send button.
		//
		if (cnctQueryStatus(sessQueryCnctHdl(hSession)) != CNCT_STATUS_TRUE)
			EnableWindow(GetDlgItem(hDlg, IDC_PB_RECEIVE), FALSE);

		/*
		 * Set the focus on this control
		 */
		SetFocus(GetDlgItem(hDlg, IDC_EB_DIR));
		return 0;

	case WM_DESTROY:
		mscResetComboBox(GetDlgItem(hDlg, IDC_CB_PROTOCOL));
		pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDC_PB_RECEIVE:
		case IDC_PB_CLOSE:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			hSession = pS->hSession;
            assert(hSession);

            if (hSession == NULL)
                {
                break;
                }

            hXfer = sessQueryXferHdl(hSession);
            assert(hXfer);

            if (hXfer == NULL)
                {
                break;
                }

            //
            // See if a file transfer is currently in progress.
            //
	        pT = (XD_TYPE *)hXfer;
            assert(pT);

            if (pT == (XD_TYPE *)0)
                {
                break;
                }
            else if (pT->nDirection != XFER_NONE)
                {
                nXferRecvReturn = XFR_IN_PROGRESS;
                }
			else if(cnctQueryStatus(sessQueryCnctHdl(hSession))
                        != CNCT_STATUS_TRUE && nId == IDC_PB_RECEIVE)
				{
				//
				// We are currently not connected (loss of carrier),
				// so disable the Recieve button. REV: 9/7/2001
				//
				nXferRecvReturn = XFR_NO_CARRIER;
				mscMessageBeep(MB_ICONHAND);
				EnableWindow(GetDlgItem(hDlg, IDC_PB_RECEIVE), FALSE);
				}
            else
                {
			    /*
			     * Do whatever saving is necessary
			     */
			    pP = (XFR_PARAMS *)0;
			    xfrQueryParameters(hXfer, (VOID **)&pP);
			    assert(pP);

			    /*
			     * Save selection from the PROTOCOL COMBO box
			     */
			    pX = (XFR_PROTOCOL *)0;
			    xfrGetProtocols(hSession, &pX);
			    assert(pX);

			    nProtocol = 0;

			    if (pX != (XFR_PROTOCOL *)0)
				    {
				    GetDlgItemText(hDlg,
								    IDC_CB_PROTOCOL,
								    acBuffer,
								    (sizeof(acBuffer) / sizeof(TCHAR)));
				    for (nIndex = 0; pX[nIndex].nProtocol != 0; nIndex += 1)
					    {
					    if (StrCharCmp(acBuffer, pX[nIndex].acName) == 0)
						    {
						    nProtocol = pX[nIndex].nProtocol;
						    break;
						    }
					    }
				    free(pX);
				    pX = NULL;
				    }

			    /*
			     * Save the current directory
			     */
			    GetDlgItemText(hDlg, IDC_EB_DIR,
							    acBuffer,
							    sizeof(acBuffer) / sizeof(TCHAR));

			    // xfer_makepaths checks for the validity of the path and
			    // prompts to create it if not there.
			    //
			    if (xfer_makepaths(hSession, acBuffer) != 0)
					{
				    break;
					}

			    if (nId == IDC_PB_RECEIVE)
				    {
				    acName[0] = TEXT('\0');

				    switch (nProtocol)
					    {
					    case XF_XMODEM:
					    case XF_XMODEM_1K:
						    pszPtr = (LPTSTR)DoDialog(glblQueryDllHinst(),
										    MAKEINTRESOURCE(IDD_RECEIVEFILENAME),
										    hDlg,
										    TransferReceiveFilenameDlg,
										    (LPARAM)hSession);

						    if (pszPtr == NULL)
								{
								//
								// Don't close the recieve dialog here, so state we
								// have handled the message. REV: 3/27/2002
								//
							    return TRUE;
								}

							//
							// If we want to allow the user to fully path the Xmodem
							// filename, we will have to split the directory and filename
							// apart here and set asBuffer with the receive directory.
							// We will also have to make sure we call xfer_makepaths()
							// so that we are in the directory is correct for the file
							// transfer. REV: 3/27/2002
							//

						    StrCharCopyN(acName, pszPtr, FNAME_LEN);
						    free(pszPtr);
						    pszPtr = NULL;
						    break;

					    default:
						    break;
					    }
				    }

			    /*
			     * Save anything that needs to be saved
			     */
			    pP->nRecProtocol = nProtocol;
			    xfrSetParameters(hXfer, (VOID *)pP);
			    filesSetRecvDirectory(sessQueryFilesDirsHdl(hSession), acBuffer);

			    if (nId == IDC_PB_RECEIVE)
				    {
				    /*
				     * The directory to use should be in "acBuffer", and the
				     * file name (if any) should be in acName.
				     */
				    nXferRecvReturn = xfrRecvStart(hXfer, acBuffer, acName);
                    //break;	// If the dlg isn't closed here, keyboard msgs
								// intended for the rcv progress dlg are 
								// intercepted by this dlg. rde 31 Oct 01
				    }
                }

            //
            // Don't save the settings if a file transfer is in
            // progress otherwise the current file transfer could
            // get corrupted.  REV: 08/06/2001.
            //
            if (nXferRecvReturn == XFR_IN_PROGRESS)
                {
                TCHAR acMessage[256];

			    if (sessQuerySound(hSession))
                    {
				    mscMessageBeep(MB_ICONHAND);
                    }

			    LoadString(glblQueryDllHinst(),
					    IDS_ER_XFER_RECV_IN_PROCESS,
					    acMessage,
					    sizeof(acMessage) / sizeof(TCHAR));

			    TimedMessageBox(sessQueryHwnd(hSession),
							    acMessage,
							    NULL,
							    MB_OK | MB_ICONEXCLAMATION,
							    sessQueryTimeout(hSession));
                }
			else if(nXferRecvReturn == XFR_NO_CARRIER)
				{
				//
				// We are currently not connected (loss of carrier),
				// so disable the Recieve button. REV: 9/7/2001
				//
				mscMessageBeep(MB_ICONHAND);
				EnableWindow(GetDlgItem(hDlg, IDC_PB_RECEIVE), FALSE);
				}
            else
                {
        		EndDialog(hDlg, TRUE);
                }

			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		case IDC_PB_BROWSE:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			if (pS)
				{
				GetDlgItemText(hDlg,
								IDC_EB_DIR,
								acBuffer,
								sizeof(acBuffer) / sizeof(TCHAR));

				pszStr = gnrcFindDirectoryDialog(hDlg, pS->hSession, acBuffer);
				if (pszStr)
					{
					SetDlgItemText(hDlg, IDC_EB_DIR, pszStr);
					free(pszStr);
					pszStr = NULL;
					}
				}

			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	TransferReceiveFilenameDlg
 *
 * DESCRIPTION:
 *	This function is called to prompt the user to enter a filename.  This is
 *	necessary for some protocols like XMODEM, which does not send a filename,
 *	and for other protocols when the user has not checked the option to use
 *	the received file name.
 *
 * PARAMETERS:
 *	Standard dialog box parameters.
 *
 * RETURNS:
 *	Indirectly, a pointer to a string (that must be freed by the caller) that
 *	contains the name, or a NULL if the user canceled.
 *
 */

#define FOLDER		101
#define	DIR_TEXT	102
#define FNAME_LABEL 103
#define	FNAME_EDIT	104

#define	FILL_TEXT	105

INT_PTR CALLBACK TransferReceiveFilenameDlg(HWND hDlg,
	         								UINT wMsg,
			    							WPARAM wPar,
				    						LPARAM lPar)
	{
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;
	HWND	hwndParent;
	TCHAR	acDir[FNAME_LEN];
	TCHAR	acBuffer[FNAME_LEN];


	static	DWORD aHlpTable[] = {FOLDER,			IDH_TERM_RECEIVE_DIRECTORY,
								 FNAME_LABEL,		IDH_TERM_RECEIVE_PROTOCOL,
								 FNAME_EDIT,        IDH_TERM_RECEIVE_PROTOCOL,
								 IDCANCEL,          IDH_CANCEL,
                                 IDOK,              IDH_OK,
								 0, 				0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		if (pS == (SDS *)0)
			{
			EndDialog(hDlg, FALSE);
			break;
			}

		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		SendMessage(GetDlgItem(hDlg, FNAME_EDIT),
					EM_SETLIMITTEXT,
					FNAME_LEN, 0);

		hwndParent = GetParent(hDlg);
		if (IsWindow(hwndParent))
			{
			acDir[0] = TEXT('\0');
			GetDlgItemText(hwndParent,
							IDC_EB_DIR,
							acDir,
							sizeof(acDir) / sizeof(TCHAR));
			if (StrCharGetStrLength(acDir) > 0)
				{
				SetDlgItemText(hDlg,
								DIR_TEXT,
								acDir);
				}
			}
		break;

	case WM_DESTROY:
		pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

			/*
			 * Do whatever saving is necessary
			 */
			acBuffer[0] = TEXT('\0');
			GetDlgItemText(hDlg, FNAME_EDIT,
							acBuffer,
							sizeof(acBuffer) / sizeof(TCHAR));

			if (StrCharGetStrLength(acBuffer) == 0)
				{
				TCHAR ach[256];

				LoadString(glblQueryDllHinst(), IDS_GNRL_NEED_FNAME, ach,
						   sizeof(ach)/sizeof(TCHAR));

				TimedMessageBox(hDlg, ach, NULL, MB_OK | MB_ICONHAND, 0);
				}
			else
				{
				LPTSTR pszStr = NULL;
				TCHAR  invalid_chars[MAX_PATH];
				LPTSTR lpFilePart = NULL;
				int    numchar = GetFullPathName(acBuffer, 0, pszStr, &lpFilePart);
				UINT   ErrorId = 0;

				LoadString(glblQueryDllHinst(), IDS_GNRL_INVALID_FILE_CHARS,
					       invalid_chars, MAX_PATH);

				if (numchar == 0)
					{
					ErrorId = IDS_GNRL_NEED_FNAME;
					}
				else if ((pszStr = (LPTSTR)malloc(numchar * sizeof(TCHAR))) == NULL)
					{
					ErrorId = IDS_TM_XFER_TWELVE;
					}
				else if (GetFullPathName(acBuffer, numchar, pszStr, &lpFilePart) == 0)
					{
					ErrorId = IDS_GNRL_NEED_FNAME;
					}
				else if (lpFilePart == NULL ||
					     StrCharPBrk(lpFilePart, invalid_chars) != NULL ||
					     StrCharPBrk(acBuffer, invalid_chars) != NULL)
					{
					ErrorId = IDS_GNRL_INVALID_FNAME_CHARS;
					}

				if (ErrorId == 0)
					{
					StrCharCopyN(pszStr, lpFilePart, numchar);
					EndDialog(hDlg, (INT_PTR)pszStr);
					}
				else
					{
					TCHAR ach[256];
					TCHAR ach2[256];

					if (LoadString(glblQueryDllHinst(), ErrorId, ach, 256) == 0)
						{
						TCHAR_Fill(ach, TEXT('\0'), 256);
						}

					if (ErrorId == IDS_GNRL_INVALID_FNAME_CHARS)
						{
						if (LoadString(glblQueryDllHinst(), ErrorId, ach2, 256))
							{
							wsprintf(ach, ach2, invalid_chars);
							}
						}
					else
						{
						LoadString(glblQueryDllHinst(), ErrorId, ach, 256);
						}

					TimedMessageBox(hDlg, ach, NULL, MB_OK | MB_ICONSTOP,
							        sessQueryTimeout(pS->hSession));

					if (pszStr)
						{
						free(pszStr);
						pszStr = NULL;
						}
					}
				}
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\propterm.c ===
/*	File: D:\WACKER\tdll\propterm.c (Created: 22-Feb-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 27 $
 *	$Date: 7/08/02 6:46p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <tchar.h>

#include "assert.h"
#include "stdtyp.h"
#include "misc.h"
#include "mc.h"
#include "globals.h"
#include "session.h"
#include "load_res.h"
#include "statusbr.h"
#include "tdll.h"
#include "hlptable.h"
#include "backscrl.h"
#include "cloop.h"
#include "htchar.h"
#include "errorbox.h"

#include <emu\emuid.h>
#include <emu\emu.h>
#include "com.h"
#include "COMDEV.H"
#include "com.hh"
#include <emu\emudlgs.h>
#include <term\res.h>
#if defined(CHARACTER_TRANSLATION)
#include <tdll\translat.hh>
#include <tdll\translat.h>
#if defined(INCL_VTUTF8)
#include <htrn_jis\htrn_jis.hh>
#endif // INCL_VTUTF8
#endif // CHARACTER_TRANSLATION

#include "property.h"
#include "property.hh"

// Function prototypes...
//
STATIC_FUNC void 	prop_WM_INITDIALOG_Terminal(HWND hDlg);
STATIC_FUNC int  	prop_SAVE_Terminal(HWND hDlg);
STATIC_FUNC void 	propCreateUpDownControl(HWND hDlg);
STATIC_FUNC LRESULT prop_WM_NOTIFY(const HWND hwnd, const int nId);
//STATIC_FUNC int	  propGetIdFromEmuName(LPTSTR pacEmuName);
STATIC_FUNC LRESULT prop_WM_CMD(const HWND hwnd,
								const int nId,
						        const int nNotify,
								const HWND hwndCtrl);
STATIC_FUNC int     propValidateBackscrlSize(HWND hDlg);
STATIC_FUNC BOOL    propHasValidBackscrlSize(HWND hDlg, int * pBackScrlSize);
STATIC_FUNC int     propValidateTelnetId(HWND hDlg, TCHAR * pszTelnetId,
                                         int iMaxChars);


// Defines for the TERMINAL TAB of the Property Sheet.
//
#define IDC_TERMINAL_CK_SOUND       304
#define IDC_TERMINAL_CB_EMULATION	322
#define IDC_TERMINAL_TF_EMULATION   321
#define IDC_TERMINAL_PB_TERMINAL	326
#define IDC_TERMINAL_PB_ASCII		327
#define IDC_TERMINAL_RB_TERMKEYS	324
#define IDC_TERMINAL_RB_WINDKEYS	325
#define IDC_TERMINAL_GR_USEKEYS     323
#define IDC_TERMINAL_EF_BACKSCRL	328
#define IDC_TERMINAL_TF_BACKSCRL	308
#define IDC_TERMINAL_EF_BACKSCRLTAB	329

#define	IDC_TERMINAL_PB_TRANSLATE	330

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
// IDs for new controls. - cab:11/14/96
//
#define IDC_TERMINAL_GR_BACKSPACE   331
#define IDC_TERMINAL_RB_CTRLH       332
#define IDC_TERMINAL_RB_DEL         333
#define IDC_TERMINAL_RB_CTRLHSPACE  334
#define IDC_TERMINAL_TF_TELNETID    335
#define IDC_TERMINAL_EF_TELNETID    336
#endif

#define IDC_TERMINAL_CK_EXIT		337
#define IDC_TERMINAL_CK_HOSTXFERS   338

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	Terminal Dialog
 *
 * DESCRIPTION:
 *	Dialog manager stub
 *
 * ARGUMENTS:
 *	Standard Windows dialog manager
 *
 * RETURNS:
 *	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK TerminalTabDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	pSDS 		 pS;
    // TODO:cab,11/14/96 - add help for new controls.
    //
	static DWORD aHlpTable[] =
		{
		IDC_TERMINAL_CK_SOUND,		IDH_TERM_SETTING_SOUND,
		IDC_TERMINAL_CB_EMULATION,	IDH_TERM_SETTING_EMULATION,
		IDC_TERMINAL_TF_EMULATION,	IDH_TERM_SETTING_EMULATION,
		IDC_TERMINAL_PB_TERMINAL,	IDH_TERM_SETTING_TERMSET,
		IDC_TERMINAL_PB_ASCII,		IDH_TERM_SETTING_ASCIISET,
		IDC_TERMINAL_RB_TERMKEYS,	IDH_TERM_SETTING_USEKEYS,
		IDC_TERMINAL_RB_WINDKEYS,	IDH_TERM_SETTING_USEKEYS,
		IDC_TERMINAL_GR_USEKEYS,	IDH_TERM_SETTING_USEKEYS,
		IDC_TERMINAL_TF_BACKSCRL,	IDH_TERM_SETTING_BACKSCROLL,
		IDC_TERMINAL_EF_BACKSCRL,	IDH_TERM_SETTING_BACKSCROLL,
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
		IDC_TERMINAL_GR_BACKSPACE,	IDH_TERM_SETTING_BACKSPACE,
		IDC_TERMINAL_RB_CTRLH,		IDH_TERM_SETTING_CTRLH,
		IDC_TERMINAL_RB_DEL,        IDH_TERM_SETTING_DEL,
		IDC_TERMINAL_RB_CTRLHSPACE, IDH_TERM_SETTING_CTRLH2,
        IDC_TERMINAL_TF_TELNETID,   IDH_TERM_SETTING_TELNETID,
		IDC_TERMINAL_EF_TELNETID,   IDH_TERM_SETTING_TELNETID,
#endif
#ifdef INCL_EXIT_ON_DISCONNECT
		IDC_TERMINAL_CK_EXIT,		IDH_TERM_SETTING_EXIT,
#endif
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
        IDC_TERMINAL_SIZE_AND_COLORS, IDH_TERM_SETTING_COLOR,
#endif
		IDC_TERMINAL_CK_HOSTXFERS,   IDH_TERM_SETTING_HOSTXFERS,
		IDC_TERMINAL_PB_TRANSLATE,   IDH_HTRN_DIALOG,
        IDCANCEL,                           IDH_CANCEL,
        IDOK,                               IDH_OK,
		0,							0,
		};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));

		if (pS == (SDS *)0)
			{
			/* TODO: decide if we need to display an error here */
			assert(FALSE);
			EndDialog(hDlg, FALSE);
			break;
			}

		pS->hSession = (HSESSION)(((LPPROPSHEETPAGE)lPar)->lParam);

		// Don't center any except first tabbed dialog in the property sheet.
		// Otherwise if a user moves the property sheet it will be forced back
		// to the centered position.
		//
		// mscCenterWindowOnWindow(GetParent(hDlg), sessQueryHwnd(pS->hSession));

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);
		prop_WM_INITDIALOG_Terminal(hDlg);
		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_DESTROY:
		// OK, now we know that we are actually leaving the dialog for good, so
		// free the storage...
		//
		pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);
		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		break;

	case WM_NOTIFY:
		return prop_WM_NOTIFY(hDlg, (int)((NMHDR *)lPar)->code);

	case WM_COMMAND:
		return prop_WM_CMD(hDlg, LOWORD(wPar), HIWORD(wPar), (HWND)lPar);

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  prop_WM_NOTIFY
 *
 * DESCRIPTION:
 *  Process Property Sheet Notification messages.
 *
 * ARGUMENTS:
 *  hDlg - dialog window handle.
 *	nId  - (NMHDR *)lPar->code
 *
 * RETURNS:
 *  LRESULT
 */
STATIC_FUNC LRESULT prop_WM_NOTIFY(const HWND hDlg, const int nId)
	{
	switch (nId)
		{
		default:
			break;

		#if 0
		case PSN_SETACTIVE:
			break;
		#endif

		case PSN_KILLACTIVE:
            {
            int nBackscrlSize = 0;

            if (propHasValidBackscrlSize(hDlg, &nBackscrlSize) == FALSE)
                {
                //
                // Invalid backscroll buffer size.
                //
                TCHAR acFormat[256];
                TCHAR acBuffer[256];

	            TCHAR_Fill(acFormat, TEXT('\0'), sizeof(acFormat)/sizeof(TCHAR));
	            TCHAR_Fill(acBuffer, TEXT('\0'), sizeof(acBuffer)/sizeof(TCHAR));
                //

                // Display an error message.
                //
                LoadString(glblQueryDllHinst(), IDS_ER_BACKSCROLL_SIZE,
                           acFormat, sizeof(acFormat)/sizeof(TCHAR));
                wsprintf(acBuffer, acFormat,
                         BKSCRL_USERLINES_DEFAULT_MIN,
                         BKSCRL_USERLINES_DEFAULT_MAX,
                         nBackscrlSize);

                TimedMessageBox(hDlg, acBuffer, NULL, MB_OK | MB_ICONEXCLAMATION, 0);

                //
                // Set the backscroll size to the value returned in
                // propHasValidBackscrlSize().
                //
                SetDlgItemInt(hDlg, IDC_TERMINAL_EF_BACKSCRL, nBackscrlSize, FALSE);

                //
                // Do not exit the property page!
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)PSNRET_INVALID_NOCHANGEPAGE);

                return TRUE;
                }
            }
			break;

		case PSN_APPLY:
			//
			// Do whatever saving is necessary
			//
			if ( prop_SAVE_Terminal(hDlg) == 0 )
                {
                // Okay to exit the dialog.
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)PSNRET_NOERROR);
                }
            else
                {
                // Do not exit the dialog!
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)PSNRET_INVALID_NOCHANGEPAGE);
                }
            return TRUE;

		#if 0
		case PSN_RESET:
			// Cancel has been selected... good place to confirm.
			//
			break;
		#endif
		}
	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  prop_WM_CMD
 *
 * DESCRIPTION:
 *  Process WM_COMMAND messages.
 *
 * ARGUMENTS:
 *  hDlg 		- dialog window handle.
 *  nId  		- LOWORD(wPar)
 *  nNotify 	- HIWORD(wPar)
 *  hwndCtrl 	- (HWND)lPar
 *
 * RETURNS:
 *  LRESULT
 *
 */
STATIC_FUNC LRESULT prop_WM_CMD(const HWND hDlg, const int nId,
						        const int nNotify,  const HWND hwndCtrl)
	{
	pSDS		pS;
	int 		iId;
	STEMUSET	stEmuSettingsCopy;
	STASCIISET	stAsciiSettingsCopy;
	BOOL		fResult;
	#if defined(INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID)
    TCHAR       achTempTelnetId[EMU_MAX_TELNETID];
	#endif // defined(INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID)

	switch(nId)
		{
   	case IDC_TERMINAL_CB_EMULATION:
		//
		// TODO: Possibly a new emulator was selected. If so then load the
		// stEmuSettings with the default values for that emulator.
		// See what we decide to do here...

		if ((pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER)) == 0)
			{
			assert(FALSE);
			break;
			}

		iId = propGetEmuIdfromEmuCombo(hDlg, pS->hSession);

	    // Dim the emulator settings push button if the current emulator is
	    // "Auto detect".
	    //
		EnableWindow(GetDlgItem(hDlg, IDC_TERMINAL_PB_TERMINAL),
					(iId == EMU_AUTO ) ? FALSE : TRUE);

		#if defined(INCL_VTUTF8)
        // Hide the "Input Translation..." button if the curent emulator is
        // "VT-UTF8". REV: 05/21/2001.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_TERMINAL_PB_TRANSLATE),
                  (iId == EMU_VTUTF8) ? FALSE : TRUE);
		#endif // INCL_VTUTF8

		#if defined(INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID)
        // Load the default telnet terminal id when a
        // new emulator is selected. - cab:11/15/96
        //
        if ( nNotify == CBN_SELCHANGE )
            {
            achTempTelnetId[0] = TEXT('\0');
            emuQueryDefaultTelnetId(iId, achTempTelnetId, EMU_MAX_TELNETID);
            if ( achTempTelnetId[0] != TEXT('\0') )
                {
                SendDlgItemMessage(hDlg, IDC_TERMINAL_EF_TELNETID, WM_SETTEXT,
                    0, (LPARAM)(LPTSTR)achTempTelnetId);
                }
            }
		#endif //defined(INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID)
		break;

   	case IDC_TERMINAL_PB_TERMINAL:
		if ((pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER)) == 0)
			{
			assert(FALSE);
			break;
			}

		MemCopy(&stEmuSettingsCopy, &(pS->stEmuSettings), sizeof(STEMUSET));

   		if (emuSettingsDlg(pS->hSession, hDlg, propGetEmuIdfromEmuCombo(hDlg, pS->hSession), &(pS->stEmuSettings)) == IDCANCEL)
			MemCopy(&(pS->stEmuSettings), &stEmuSettingsCopy, sizeof(STEMUSET));
		break;

	case IDC_TERMINAL_PB_ASCII:
		if ((pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER)) == 0)
			{
			assert(FALSE);
			break;
			}

		MemCopy(&stEmuSettingsCopy, &(pS->stEmuSettings), sizeof(STEMUSET));

        //
        // Make sure to set the correct terminal id so the controls
        // can be initialized correctly in the terminal ASCII Settings
        // dialog.  NOTE:  This is done after copying the settings in
        // case of a cancel from the ASCII Settings dialog so that the
        // terminal id is not saved. REV: 07/25/2001
        //
	    pS->stEmuSettings.nEmuId = propGetEmuIdfromEmuCombo(hDlg, pS->hSession);

		MemCopy(&stAsciiSettingsCopy, &(pS->stAsciiSettings), sizeof(STASCIISET));

		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
							 MAKEINTRESOURCE(IDD_ASCII_SETUP),
							 hDlg,
							 asciiSetupDlgProc,
							 (LPARAM)pS);

		if (fResult == IDCANCEL)
			{
			MemCopy(&(pS->stEmuSettings), &stEmuSettingsCopy, sizeof(STEMUSET));
			MemCopy(&(pS->stAsciiSettings), &stAsciiSettingsCopy, sizeof(STASCIISET));
			}
        else if (pS->stEmuSettings.nEmuId == EMU_VTUTF8)
            {
            //
            // Reset the sending and receiving CR with LF and forcing
            // 7-bit ASCII when the emulator is VT-UTF8 (these setting
            // will always be set to FALSE for the VT-UTF8 emulator.
            // We don't want to save these settings when the emulator
            // is VT-UTF8 since the user may select another emulator
            // prior to saving the properties or may switch to another
            // property page. REV: 07/25/2001
            //
			pS->stAsciiSettings.fsetSendCRLF = stAsciiSettingsCopy.fsetSendCRLF;
			pS->stAsciiSettings.fsetAddLF    = stAsciiSettingsCopy.fsetAddLF;
			pS->stAsciiSettings.fsetASCII7   = stAsciiSettingsCopy.fsetASCII7;
            }

		break;

	#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
    case IDC_TERMINAL_SIZE_AND_COLORS:

        if ((pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER)) == 0)
			{
			assert(FALSE);
			break;
			}

   		fResult = emuColorSettingsDlg(pS->hSession, hDlg, &(pS->stEmuSettings));

        break;
	#endif

	#if defined(CHARACTER_TRANSLATION)
	case IDC_TERMINAL_PB_TRANSLATE:
		{
		HHTRANSLATE hTrans = NULL;

		if ((pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER)) == 0)
			{
			assert(FALSE);
			break;
			}

		hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pS->hSession);
		if (hTrans)
			{
			if ((*hTrans->pfnIsDeviceLoaded)(hTrans->pDllHandle))
				{
				(*hTrans->pfnDoDialog)(hDlg, hTrans->pDllHandle);
				}
			}
		}
		break;
	#endif // defined(CHARACTER_TRANSLATION)

	default:
		break;
		}

	return (LRESULT) 0; // REV 8/17/98
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propLoadEmulationCombo
 *
 * DESCRIPTION:
 *  Fill in the emulator combo box with the emulators that we support and
 *	select the current one.
 *
 * ARGUMENTS:
 *  hDlg 		- dialog handle.
 *	hSession 	- the session handle.
 *
 * RETURNS:
 *  void.
 *
 */
void propLoadEmulationCombo(const HWND hDlg, const HSESSION hSession)
	{
	BYTE 	*pv;
	int	 	i;
	DWORD	nLen;
	int		nEmuCount;
	HEMU 	hEmulator;
	TCHAR	acEmuName[256];

	// Get the emulator name...
	// We have to select the emulator in the combo box by name because the
	// combo is sorted, which makes sense, and in translated versions
	// the index to the emulator name in the combo box won't correspond
	// to the emulator id.
	//
	hEmulator = (HEMU)sessQueryEmuHdl(hSession);
	TCHAR_Fill(acEmuName, TEXT('\0'), sizeof(acEmuName) / sizeof(TCHAR));
	emuQueryName(hEmulator, acEmuName, sizeof(acEmuName) / sizeof(TCHAR));

	// Load the emulator name table from the resources
	//
	if (resLoadDataBlock(glblQueryDllHinst(), IDT_EMU_NAMES, (LPVOID *)&pv, &nLen))
		{
		assert(FALSE);
		return;
		}

	// Load the combo box with the table items.
	//
	nEmuCount = *(RCDATA_TYPE *)pv;
	pv += sizeof(RCDATA_TYPE);

	for (i = 0 ; i < nEmuCount; i++)
		{
		nLen = (DWORD)StrCharGetByteCount((LPTSTR)pv) + (DWORD)sizeof(BYTE);

		SendDlgItemMessage(hDlg, IDC_TERMINAL_CB_EMULATION, CB_ADDSTRING, 0,
				(LPARAM)(LPTSTR)pv);

		pv += (nLen + (DWORD)sizeof(RCDATA_TYPE));
		}

	SendDlgItemMessage(hDlg, IDC_TERMINAL_CB_EMULATION, CB_SELECTSTRING,
		(WPARAM)-1, (LPARAM)(LPTSTR)acEmuName);
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propLoadEmulationCombo
 *
 * DESCRIPTION:
 *  Fill in the emulator combo box with the emulators that we support and
 *	select the current one.
 *
 * ARGUMENTS:
 *  hDlg 		- dialog handle.
 *	hSession 	- the session handle.
 *
 * RETURNS:
 *  void.
 *
 */
void propLoadEmulationCombo(const HWND hDlg, const HSESSION hSession)
	{
	int 	i;
	HEMU 	hEmulator;
	TCHAR	acEmuName[256],
			achText[EMU_MAX_NAMELEN];

	// Get the emulator name...
	// We have to select the emulator in the combo box by name because the
	// combo is sorted, which makes sense, and in translated versions
	// the index to the emulator name in the combo box won't correspond
	// to the emulator id.
	//
	hEmulator = (HEMU)sessQueryEmuHdl(hSession);
	TCHAR_Fill(acEmuName, TEXT('\0'), sizeof(acEmuName) / sizeof(TCHAR));
	emuQueryName(hEmulator, acEmuName, sizeof(acEmuName) / sizeof(TCHAR));

	for (i = IDS_EMUNAME_BASE ; i < IDS_EMUNAME_BASE + NBR_EMULATORS; i++)
		{

		#if !defined(INCL_VT100J)
		if (i == IDS_EMUNAME_VT100J)
			continue;
		#endif
		#if !defined(INCL_ANSIW)
		if (i == IDS_EMUNAME_ANSIW)
			continue;
		#endif
		#if !defined(INCL_VT220)
		if (i == IDS_EMUNAME_VT220)
			continue;
		#endif
		#if !defined(INCL_VT320)
		if (i == IDS_EMUNAME_VT320)
			continue;
		#endif
		#if !defined(INCL_VT100PLUS)
		if (i == IDS_EMUNAME_VT100PLUS)
			continue;
		#endif
		#if !defined(INCL_VTUTF8)
		if (i == IDS_EMUNAME_VTUTF8)
			continue;
		#endif

		LoadString(glblQueryDllHinst(), (unsigned int)i, achText, sizeof(achText) / sizeof(TCHAR));

		SendDlgItemMessage(hDlg, IDC_TERMINAL_CB_EMULATION, CB_ADDSTRING, 0,
				(LPARAM)(LPTSTR)achText);
		}

	SendDlgItemMessage(hDlg, IDC_TERMINAL_CB_EMULATION, CB_SELECTSTRING,
		(WPARAM)-1, (LPARAM)(LPTSTR)acEmuName);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propGetEmuIdfromEmuCombo
 *
 * DESCRIPTION:
 *	Return the emulator id for the emulator selected in the emulator combo
 *	box or if none selected, return current emulator id.
 *
 * ARGUMENTS:
 *  hDlg - dialog handle.
 *
 * RETURNS:
 *  nEmuId - the emulator id.
 */
int propGetEmuIdfromEmuCombo(HWND hDlg, HSESSION hSession)
	{
	int     nEmuId;
    INT_PTR nRet;
	TCHAR	acEmulator[256];

	if ((nRet = SendDlgItemMessage(hDlg, IDC_TERMINAL_CB_EMULATION, CB_GETCURSEL, 0, 0)) == CB_ERR)
		{
		nEmuId = emuQueryEmulatorId(sessQueryEmuHdl(hSession));
		}
	else
		{
		TCHAR_Fill(acEmulator, TEXT('\0'), sizeof(acEmulator) / sizeof(TCHAR));

		SendDlgItemMessage(hDlg, IDC_TERMINAL_CB_EMULATION, CB_GETLBTEXT,
			(WPARAM)nRet, (LPARAM)(LPTSTR)acEmulator);

		//nEmuId = propGetIdFromEmuName(acEmulator);

		nEmuId = emuGetIdFromName(sessQueryEmuHdl(hSession), acEmulator);

		}
//	DbgOutStr("nEmuId = %d\r\n", nEmuId, 0, 0, 0, 0);
	return (nEmuId);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  prop_WM_INITDIALOG_Terminal
 *
 * DESCRIPTION:
 *  This function processes the WM_INIDIALOG message for the "Settings" tab
 *  of the property sheet.
 *
 * ARGUMENTS:
 *	hDlg - dialog window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void prop_WM_INITDIALOG_Terminal(HWND hDlg)
	{
	HWND	hTmp;
	HEMU	hEmulator;
	pSDS	pS;
	TCHAR	ach[100], acBuffer[100];
	int		nEmuId;
	HCLOOP	hCLoop = (HCLOOP)0;

	pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);

	hTmp = GetDlgItem(hDlg, IDC_TERMINAL_PB_TRANSLATE);
	if (IsWindow(hTmp))
		{
#if defined(CHARACTER_TRANSLATION)
		HHTRANSLATE hTrans = NULL;

		hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pS->hSession);
		if (!hTrans || !(*hTrans->pfnIsDeviceLoaded)(hTrans->pDllHandle))
			{
			ShowWindow(hTmp, SW_HIDE);
			}
#else
		ShowWindow(hTmp, SW_HIDE);
#endif
		}

	hCLoop = sessQueryCLoopHdl(pS->hSession);
	if (hCLoop == (HCLOOP)0)
		assert(FALSE);

	// Set ASCII Settings to the currently used valudes...
	//
	memset(&(pS->stAsciiSettings), 0, sizeof(STASCIISET));

	pS->stAsciiSettings.fsetSendCRLF = CLoopGetSendCRLF(hCLoop);
	pS->stAsciiSettings.fsetLocalEcho = CLoopGetLocalEcho(hCLoop);
	pS->stAsciiSettings.fsetAddLF = CLoopGetAddLF(hCLoop);
	pS->stAsciiSettings.fsetASCII7 = CLoopGetASCII7(hCLoop);
	pS->stAsciiSettings.iLineDelay = CLoopGetLineDelay(hCLoop);
	pS->stAsciiSettings.iCharDelay = CLoopGetCharDelay(hCLoop);

	// Set emulator settings structures do default values...
	//
	hEmulator = (HEMU)sessQueryEmuHdl(pS->hSession);
	emuQuerySettings(hEmulator, &(pS->stEmuSettings));

	// Set the backscroll buffer edit box...
	//

	//
	// Since the backscroll buffer can only be numeric and has a
	// size between BKSCRL_USERLINES_DEFAULT_MIN(0) and
	// BKSCRL_USERLINES_DEFAULT_MAX(500), limit to 3 characters.
	//
	SendDlgItemMessage(hDlg, IDC_TERMINAL_EF_BACKSCRL, EM_LIMITTEXT, 3, 0);
	propCreateUpDownControl(hDlg);
	LoadString(glblQueryDllHinst(), IDS_XD_INT, ach, sizeof(ach) / sizeof(TCHAR));
	TCHAR_Fill(acBuffer, TEXT('\0'), sizeof(acBuffer) / sizeof(TCHAR));
	wsprintf(acBuffer, ach, backscrlGetUNumLines(sessQueryBackscrlHdl(pS->hSession)));
	SendDlgItemMessage(hDlg, IDC_TERMINAL_EF_BACKSCRL, WM_SETTEXT, 0, (LPARAM)(LPTSTR)acBuffer);

	// Set sound checkbox...
	//
	SendDlgItemMessage(hDlg, IDC_TERMINAL_CK_SOUND, BM_SETCHECK,
		(unsigned int)sessQuerySound(pS->hSession), 0);

	// Set exit checkbox...
	//mpt:10-28-97
	SendDlgItemMessage(hDlg, IDC_TERMINAL_CK_EXIT, BM_SETCHECK,
		(unsigned int)sessQueryExit(pS->hSession), 0);

	// Set 'Allow host initiated file transfer' feature
	//
	SendDlgItemMessage(hDlg, IDC_TERMINAL_CK_HOSTXFERS, BM_SETCHECK,
		(BOOL)sessQueryAllowHostXfers(pS->hSession), 0);

	// Set keys radio buttons...
	//
	SendDlgItemMessage(hDlg, (pS->stEmuSettings.nTermKeys) ?
		IDC_TERMINAL_RB_TERMKEYS : IDC_TERMINAL_RB_WINDKEYS, BM_SETCHECK, 1, 0);

	//
	// Load Emulation combo box
	//
	propLoadEmulationCombo(hDlg, pS->hSession);

	// Dim the emulator settings push button if the current emulator is
	// "Auto detect".
	//
	hEmulator = (HEMU)sessQueryEmuHdl(pS->hSession);
	nEmuId = emuQueryEmulatorId(hEmulator);
	EnableWindow(GetDlgItem(hDlg, IDC_TERMINAL_PB_TERMINAL),
		        (nEmuId == EMU_AUTO) ? FALSE : TRUE);

#if defined(INCL_VTUTF8) && defined(CHARACTER_TRANSLATION)
    // Hide the "Input Translation..." button if the curent emulator is
    // "VT-UTF8". REV: 05/21/2001.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_TERMINAL_PB_TRANSLATE),
              (nEmuId == EMU_VTUTF8) ? FALSE : TRUE);
#endif // INCL_VTUTF8 && CHARACTER_TRANSLATION

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
    // Set the backspace radio buttons - cab:11/14/96
    //
    switch(pS->stEmuSettings.nBackspaceKeys)
        {
    default:
    case EMU_BKSPKEYS_CTRLH:
	    SendDlgItemMessage(hDlg, IDC_TERMINAL_RB_CTRLH, BM_SETCHECK, 1, 0);
        break;

    case EMU_BKSPKEYS_DEL:
	    SendDlgItemMessage(hDlg, IDC_TERMINAL_RB_DEL, BM_SETCHECK, 1, 0);
        break;

    case EMU_BKSPKEYS_CTRLHSPACE:
	    SendDlgItemMessage(hDlg, IDC_TERMINAL_RB_CTRLHSPACE, BM_SETCHECK, 1, 0);
        break;
        }


    // Set the telnet terminal id text - cab:11/15/96
    //
	SendDlgItemMessage(hDlg, IDC_TERMINAL_EF_TELNETID, EM_SETLIMITTEXT,
		EMU_MAX_TELNETID - 1, 0);

    SendDlgItemMessage(hDlg, IDC_TERMINAL_EF_TELNETID, WM_SETTEXT, 0,
        (LPARAM)(LPTSTR)pS->stEmuSettings.acTelnetId);

    // TODO: cab,11/18/96 Disable window if the connection is not WinSock.
    //
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	prop_SAVE_Terminal
 *
 * DESCRIPTION:
 *  We are either applying the changes or closing the property sheet, so
 *  commit all of the changes.
 *
 * ARGUMENTS:
 *  hDlg - dialog handle.
 *
 * RETURNS:
 *  Returns 0 if data was valid, -1 otherwise.
 *
 */
STATIC_FUNC int prop_SAVE_Terminal(HWND hDlg)
	{
    int     iRet = 0;
	pSDS	pS;
	HEMU	hEmulator;
	HCLOOP	hCLoop = (HCLOOP)0;
    HCOM    hCom = NULL;
    #if defined(INCL_MINITEL)
    BOOL    fAutoDetect = FALSE;
    #endif // INCL_MINITEL

	pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);

	if (pS == 0)
		{
		assert(FALSE);
		return -1;
		}

	hCLoop = sessQueryCLoopHdl(pS->hSession);
	// Convey the ascii settings to cloop...
	//
	CLoopSetSendCRLF(hCLoop, pS->stAsciiSettings.fsetSendCRLF);
	CLoopSetLocalEcho(hCLoop, pS->stAsciiSettings.fsetLocalEcho);
	CLoopSetAddLF(hCLoop, pS->stAsciiSettings.fsetAddLF);
	CLoopSetASCII7(hCLoop, pS->stAsciiSettings.fsetASCII7);
	CLoopSetLineDelay(hCLoop, pS->stAsciiSettings.iLineDelay);
	CLoopSetCharDelay(hCLoop, pS->stAsciiSettings.iCharDelay);

	// Record the change of emulator, if any.
	//
	pS->stEmuSettings.nEmuId = propGetEmuIdfromEmuCombo(hDlg, pS->hSession);

	// Record the terminal keys change, if any.
	//
	pS->stEmuSettings.nTermKeys =
		(int)(IsDlgButtonChecked(hDlg, IDC_TERMINAL_RB_TERMKEYS) == BST_CHECKED);


	// Record the sound change, if any.
	//
	sessSetSound(pS->hSession,
				(int)(IsDlgButtonChecked(hDlg, IDC_TERMINAL_CK_SOUND) == BST_CHECKED));

	// Record the exit change, if any.
	//mpt:10-28-97 added 'exit on disconnect' feature
	sessSetExit(pS->hSession,
				(int)(IsDlgButtonChecked(hDlg, IDC_TERMINAL_CK_EXIT) == BST_CHECKED));

	//
	// Record 'Allow host initiated file transfer' feature
	//
	sessSetAllowHostXfers(pS->hSession,
	                     (IsDlgButtonChecked(hDlg, IDC_TERMINAL_CK_HOSTXFERS) == BST_CHECKED));


	// Record the value of the backscroll buffer.
	//
	backscrlSetUNumLines(sessQueryBackscrlHdl(pS->hSession),
        propValidateBackscrlSize(hDlg));

	hEmulator = (HEMU)sessQueryEmuHdl(pS->hSession);

    #if defined(INCL_MINITEL)
    hCom = sessQueryComHdl(pS->hSession);

    if (hCom && ComValidHandle(hCom) &&
        pS->stEmuSettings.nEmuId == EMU_MINI &&
        hEmulator && emuQueryEmulatorId(hEmulator) != EMU_MINI)
        {
        int iDataBits = 8;
        int iParity = NOPARITY;
        int iStopBits = ONESTOPBIT;
        ComGetDataBits(hCom, &iDataBits);
        ComGetParity(hCom, &iParity);
        ComGetStopBits(hCom, &iStopBits);

        //
        // Turn on AutoDetect so that the Dial dialog will
        if (iDataBits != 7 || iParity != EVENPARITY || iStopBits != ONESTOPBIT)
            {
            ComSetDataBits(hCom, 7);
            ComSetParity(hCom, EVENPARITY);
            ComSetStopBits(hCom, ONESTOPBIT);
            ComSetAutoDetect(hCom, FALSE);
            }

        //
        // Force the incoming ASCII data to 7 bit.
        //
        pS->stAsciiSettings.fsetASCII7 = TRUE;
        CLoopSetASCII7(hCLoop, pS->stAsciiSettings.fsetASCII7);
        }
    #endif //INCL_MINITEL

    #if defined(INCL_VTUTF8)
    hCom = sessQueryComHdl(pS->hSession);

    if (hCom && ComValidHandle(hCom) &&
        pS->stEmuSettings.nEmuId == EMU_VTUTF8 &&
        hEmulator && emuQueryEmulatorId(hEmulator) != EMU_VTUTF8)
        {
        //
        // Force the appending carriage returns to line ends when
        // sending ASCII data to FALSE.
        //
        pS->stAsciiSettings.fsetAddLF = FALSE;
        CLoopSetSendCRLF(hCLoop, pS->stAsciiSettings.fsetSendCRLF);

        //
        // Force the appending carriage returns to line ends when
        // receiving ASCII data to FALSE.
        //
        pS->stAsciiSettings.fsetAddLF = FALSE;
        CLoopSetAddLF(hCLoop, pS->stAsciiSettings.fsetAddLF);

        //
        // Force the incoming ASCII data to 8 bit.
        //
        pS->stAsciiSettings.fsetASCII7 = FALSE;
        CLoopSetASCII7(hCLoop, pS->stAsciiSettings.fsetASCII7);
        }
    #endif // INCL_VTUTF8

    #ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
    // Record the backspace key change, if any. - cab:11/14/96
    //
    if ( IsDlgButtonChecked(hDlg, IDC_TERMINAL_RB_DEL) == BST_CHECKED )
        {
        pS->stEmuSettings.nBackspaceKeys = EMU_BKSPKEYS_DEL;
        }
    else if ( IsDlgButtonChecked(hDlg, IDC_TERMINAL_RB_CTRLHSPACE) == BST_CHECKED )
        {
        pS->stEmuSettings.nBackspaceKeys = EMU_BKSPKEYS_CTRLHSPACE;
        }
    else
        {
        // Default to CTRL-H if none are selected.
        //
        pS->stEmuSettings.nBackspaceKeys = EMU_BKSPKEYS_CTRLH;
        }

    // Record the new telnet terminal id - cab:11/15/96
    //
    if ( propValidateTelnetId(hDlg, pS->stEmuSettings.acTelnetId,
            sizeof(pS->stEmuSettings.acTelnetId)) != 0 )
        {
        iRet = -1;
        }
    #endif // INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID

#if defined(INCL_VTUTF8)
#if defined(CHARACTER_TRANSLATION)
    //
    // If this is the VT_UTF8 terminal emulator, then set the translation
    // to passthrough mode so no translations get executed. REV: 05/21/2001
    //
    if (pS->stEmuSettings.nEmuId == EMU_VTUTF8)
        {
	    HHTRANSLATE hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pS->hSession);

	    if (hTrans)
            {
	        pstICT pstI = (pstICT)hTrans->pDllHandle;

            if (pstI)
                {
		        pstI->nInputMode  = PASS_THRU_MODE;
		        pstI->nOutputMode = PASS_THRU_MODE;
                }
            }
        }
#endif // CHARACTER_TRANSLATION
#endif // INCL_VTUTF8

	// Commit the emulator settings changes
	//
	if (emuSetSettings(hEmulator, &(pS->stEmuSettings)) != 0)
		assert(FALSE);

	if (emuLoad(sessQueryEmuHdl(pS->hSession), pS->stEmuSettings.nEmuId) != 0)
		assert(0);

	PostMessage(sessQueryHwndStatusbar(pS->hSession), SBR_NTFY_REFRESH,
		(WPARAM)SBR_MAX_PARTS, 0);

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propCreateUpDownControl
 *
 * DESCRIPTION:
 *  This function puts an up-down control on the edit field for the backscroll
 *  buffer.  This gives us bounds checking for free... just set the appro-
 *  priate parameters in the CreateUpDownControl call.
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void propCreateUpDownControl(HWND hDlg)
	{
	RECT	rc;
	int		nHeight, nWidth;
	DWORD	dwFlags;
	HWND	hwndChild;

	GetClientRect(GetDlgItem(hDlg, IDC_TERMINAL_EF_BACKSCRL), &rc);
	nHeight = rc.top - rc.bottom;
	nWidth = (nHeight / 3) * 2;

	dwFlags = WS_CHILD       | WS_VISIBLE |
			  UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_SETBUDDYINT;

	hwndChild = CreateUpDownControl(
					dwFlags,			// create window flags
					rc.right,			// left edge
					rc.top,				// top edge
					nWidth,				// width
					nHeight,			// height
					hDlg,				// parent window
					IDC_TERMINAL_EF_BACKSCRLTAB,
					(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
					GetDlgItem(hDlg, IDC_TERMINAL_EF_BACKSCRL),
					BKSCRL_USERLINES_DEFAULT_MAX,
					BKSCRL_USERLINES_DEFAULT_MIN,
					111);    			// starting position - picked a weird
										// value so that we can tell that is
										// is the default
	assert(hwndChild);
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propGetIdFromEmuName
 *
 * DESCRIPTION:
 *  Return the emulator id given the emulator name. I couldn't decide if this
 *  functin should go with the emulator code, or here.  Since it doesn't need
 *	to access the internal emulator handle I decided to put it here.
 *
 * ARGUMENTS:
 * 	pacEmuName - the name of an emulator.
 *
 * RETURNS:
 *  int nEmuId - return the id number for that emulator.
 */
STATIC_FUNC int propGetIdFromEmuName(LPTSTR pacEmuName)
	{
	BYTE	*pv;
	BYTE	*temp;
	DWORD 	nLen;
	int		i;
	int		nEmuCount;

	if (resLoadDataBlock(glblQueryDllHinst(), IDT_EMU_NAMES, (LPVOID *)&pv, &nLen))
		{
		assert(FALSE);
		return 0;
		}

	nEmuCount = *(RCDATA_TYPE *)pv;
	pv += sizeof(RCDATA_TYPE);

	for (i = 0 ; i < nEmuCount ; i++)
		{
		nLen = (DWORD)StrCharGetByteCount((LPTSTR)pv) + (DWORD)sizeof(BYTE);
		if (nLen == 0)
			{
			assert(FALSE);
			return 0;
			}

		temp = pv + nLen;

		// Match on the name...
		//
		if (StrCharCmp(pacEmuName, pv) == 0)
			return (*(RCDATA_TYPE *)temp);

		pv += (nLen + (DWORD)sizeof(RCDATA_TYPE));
		}
	return 0;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propValidateBackscrlSize
 *
 * DESCRIPTION:
 *  If the user entered a value outside of the range we support force the
 *	value into the range.
 *
 * ARGUMENTS:
 *  hDlg - dialog window handle.
 *
 * RETURNS:
 *  nNewValue - number of lines to keep in the backscrol buffer.
 *
 */
STATIC_FUNC int propValidateBackscrlSize(HWND hDlg)
	{
	TCHAR ach[256], acBuffer[256];
	int nNewValue = 0;

	if (propHasValidBackscrlSize(hDlg, &nNewValue) == FALSE)
		{
		LoadString(glblQueryDllHinst(), IDS_XD_INT, ach, sizeof(ach) / sizeof(TCHAR));
		TCHAR_Fill(acBuffer, TEXT('\0'), sizeof(acBuffer) / sizeof(TCHAR));
		wsprintf(acBuffer, ach, nNewValue);
		SendDlgItemMessage(hDlg, IDC_TERMINAL_EF_BACKSCRL, WM_SETTEXT, 0, (LPARAM)(LPTSTR)acBuffer);
		}
	return (nNewValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propHasValidBackscrlSize
 *
 * DESCRIPTION:
 *  If the user entered a value outside of the range we support force the
 *	value into the range.
 *
 * ARGUMENTS:
 *  hDlg - dialog window handle.
 *  pBackScrlSize - a valid size for the backscroll.
 *
 * RETURNS:
 *  TRUE if the backscroll size is set to a valid range.
 *
 */
STATIC_FUNC int propHasValidBackscrlSize(HWND hDlg, int * pBackScrlSize)
	{
	BOOL fTranslated;
    BOOL fReturn = FALSE;
	int  nValue = GetDlgItemInt(hDlg, IDC_TERMINAL_EF_BACKSCRL, &fTranslated, FALSE);

	if (fTranslated)
		{
		if (nValue > BKSCRL_USERLINES_DEFAULT_MAX)
			{
			if (pBackScrlSize != NULL)
				{
				*pBackScrlSize = BKSCRL_USERLINES_DEFAULT_MAX;
				}
			}
		else if (nValue < BKSCRL_USERLINES_DEFAULT_MIN)
			{
			if (pBackScrlSize != NULL)
				{
				*pBackScrlSize = BKSCRL_USERLINES_DEFAULT_MIN;
				}
			}
		else if (pBackScrlSize != NULL)
			{
			*pBackScrlSize = nValue;
			fReturn = TRUE;
			}
		}

	return (fReturn);
	}

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  propValidateTelnetId
 *
 * DESCRIPTION:
 *  Validates the telnet terminal id. If there is no telnet id, an
 *  error message is displayed.
 *
 * ARGUMENTS:
 *  hDlg        - dialog window handle.
 *  pszTelnetId - buffer for the telnet id.
 *  iMaxChars   - size of the telnet id buffer (in characters)
 *
 * RETURNS:
 *  Returns 0 if the id was valid, -1 otherwise.
 *
 * AUTHOR:  C. Baumgartner, 11/15/96
 */
STATIC_FUNC int propValidateTelnetId(HWND hDlg, TCHAR * pszTelnetId,
        int iMaxChars)
    {
    int     iRet = 0;
    TCHAR * pszTempCopy;

    // First create a temporary copy to get the unvalidated value,
    // because we don't want to trash pszTelnetId if the value is
    // invalid.
    //
    pszTempCopy = malloc(iMaxChars * sizeof(TCHAR));
    if (pszTempCopy == NULL)
        {
        return -1;
        }
	TCHAR_Fill(pszTempCopy, TEXT('\0'), iMaxChars);

    // Get the edit box text.
    //
    GetDlgItemText(hDlg, IDC_TERMINAL_EF_TELNETID, pszTempCopy, iMaxChars);

    // We must have a value in the string.
    //
    if ( StrCharGetStrLength(pszTempCopy) )
        {
        StrCharCopyN(pszTelnetId, pszTempCopy, iMaxChars);
        iRet = 0;
        }
    else
        {
		LoadString(glblQueryDllHinst(), IDS_ER_INVALID_TELNETID, pszTempCopy,
            iMaxChars);
        TimedMessageBox(hDlg, pszTempCopy, NULL, MB_OK | MB_ICONEXCLAMATION, 0);
        iRet = -1;
        }

    free(pszTempCopy);
	pszTempCopy = NULL;
    return iRet;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\serialno.h ===
/*  File: D:\NPORT\TDLL\serialno.h (Created: 10-May-1995)
 *
 *  Copyright 1995 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 1 $
 *  $Date: 10/05/98 12:40p $
 *
 */

#define SERIALNO_EXPIRED		-1
#define MAX_USER_SERIAL_NUMBER	20
#define APP_SERIALNO_MIN		6

int IsValidSerialNumber(TCHAR *pachSerialNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sessfile.c ===
/*	File: D:\WACKER\tdll\sessfile.c (Created: 30-Apr-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 18 $
 *	$Date: 7/12/02 12:31p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>

#include "features.h"

#include "stdtyp.h"
#include "sf.h"
#include "mc.h"
#include "term.h"
#include "cnct.h"
#include "print.h"
#include "assert.h"
#include "capture.h"
#include "globals.h"
#include "sess_ids.h"
#include "load_res.h"
#include "open_msc.h"
#include "xfer_msc.h"
#include "file_msc.h"
#include "backscrl.h"
#include "cloop.h"
#include "com.h"
#include <term\res.h>
#include "session.h"
#include "session.hh"
#include "errorbox.h"
#include <emu\emu.h>
#include "tdll.h"
#include "htchar.h"
#include "translat.h"
#include "misc.h"
#if defined(INCL_KEY_MACROS)
#include "keyutil.h"
#endif

STATIC_FUNC void sessSaveHdl(HSESSION hSession);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessLoadSessionStuff
 *
 * DESCRIPTION:
 *	This function gets called whenever the user wants to read in the data
 *	from a session file.  If there is a currently opened session file, it
 *	is open, otherwise we prompt for one.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	BOOL
 */
BOOL sessLoadSessionStuff(const HSESSION hSession)
	{
	BOOL			bRet = TRUE;
	BOOL			fBool = TRUE;
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	unsigned long  	lSize;

	sessLoadIcons(hSession);

	if (bRet)
		{
		if (hhSess->hXferHdl)
			bRet = (LoadXferHdl((HXFER)hhSess->hXferHdl) == 0);
		assert(bRet);
		}

	if (bRet)
		{
		if (hhSess->hFilesHdl != (HFILES)0)
			bRet = (LoadFilesDirsHdl(sessQueryFilesDirsHdl(hSession))==0);
		assert(bRet);
		}

	if (bRet)
		{
		if (hhSess->hCaptFile)
			bRet = (LoadCaptureFileHandle(hhSess->hCaptFile) == 0);
		assert(bRet);
		}

	// Moved to before emulator load.  Some emulators like the Minitel
	// load fonts if the correct one is not loaded so we need to let
	// the terminal load its fonts before loading the emulator so there
	// is no conflict. mrw,3/2/95
	//
	if (bRet)
    	{
    	if (SendMessage(hhSess->hwndTerm, WM_TERM_LOAD_SETTINGS, 0, 0))
    		{
    		assert(FALSE);
    		bRet = FALSE;
    		}
    	}

	if (bRet)
		{
		if (hhSess->hEmu)
			bRet = (emuInitializeHdl(hhSess->hEmu) == 0);
		assert(bRet);
		}

	if (bRet)
		{
		if (hhSess->hPrint)
			bRet = (printInitializeHdl(hhSess->hPrint) == 0);
		assert(bRet);
		}

#if defined(CHARACTER_TRANSLATION)
	if (bRet)
		{
		if (hhSess->hTranslate)
			bRet = (LoadTranslateHandle(hhSess->hTranslate) == 0);
		assert(bRet);
		}
#endif

	if (bRet)
		{
		if (hhSess->hCLoop)
			bRet = (CLoopLoadHdl(hhSess->hCLoop) == 0);
		assert(bRet);
		}

	if (bRet)
		{
		if (hhSess->hCom)
			bRet = (ComLoadHdl(hhSess->hCom) == 0);
		assert(bRet);
		}

	if (bRet)
		{
		if (hhSess->hCnct)
			{
			if (cnctLoad(hhSess->hCnct))
				{
				assert(FALSE);
				bRet = FALSE;
                }
			}
		}

	if (bRet)
		{
		lSize = sizeof(hhSess->fSound);

		// Initialize... i.e., sound ON.
		//
		hhSess->fSound = TRUE;

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_SOUND,
						 &lSize,
						 &hhSess->fSound);
		}

	if (bRet)
		{
		lSize = sizeof(hhSess->fExit);

		// Initialize... i.e., exit OFF.
		//
		hhSess->fExit = FALSE;

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_EXIT,
						 &lSize,
						 &hhSess->fExit);
		}

	if (bRet)
		{
		lSize = sizeof(hhSess->fAllowHostXfers);

		// Initialize... i.e., exit OFF.
		//
		hhSess->fAllowHostXfers = FALSE;

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_ALLOW_HOST_TRANSFER,
						 &lSize,
						 &hhSess->fAllowHostXfers);
		}

	if (bRet)
		{
		lSize = sizeof(BOOL);
		fBool = TRUE;

		sfGetSessionItem(hhSess->hSysFile,
								SFID_TLBR_VISIBLE,
								&lSize,
								&fBool);

		sessSetToolbarVisible(hSession, fBool);
		}

	if (bRet)
		{
		lSize = sizeof(BOOL);
		fBool = TRUE;

		sfGetSessionItem(hhSess->hSysFile,
								SFID_STBR_VISIBLE,
								&lSize,
								&fBool);

		sessSetStatusbarVisible(hSession, fBool);
		}

	if (bRet)
		{
		lSize = sizeof(hhSess->achSessName);

		// Initialize...
		//
		TCHAR_Fill(hhSess->achSessName, TEXT('\0'),
			sizeof(hhSess->achSessName) / sizeof(TCHAR));
		
		sfGetSessionFileName(hhSess->hSysFile, 	
			sizeof(hhSess->achSessName) / sizeof(TCHAR), hhSess->achSessName);

	    // Hold on to just the session name, no path, no extension.  It is
		// usefull to keep it around.
		//
		mscStripPath(hhSess->achSessName);
		mscStripExt(hhSess->achSessName);

//      We should never be storing this internal string in the session file!
//		- jac. 10-06-94 03:44pm
//		sfGetSessionItem(hhSess->hSysFile,
//						 SFID_SESS_NAME,
//						 &lSize,
//						 hhSess->achSessName);

		/* This next line protects against trash in the session file */
		hhSess->achSessName[sizeof(hhSess->achSessName)-1] = TEXT('\0');

		StrCharCopyN(hhSess->achOldSessName, hhSess->achSessName, FNAME_LEN + 1);
		}

	if (bRet)
		{
		if (sessQueryBackscrlHdl(hSession))
			{
			backscrlRead(sessQueryBackscrlHdl(hSession));
			/* Don't check this for now */
			sessRestoreBackScroll(hSession);
			}
		}

	if (bRet)
		{
		lSize = sizeof(LONG);

		memset(&hhSess->rcSess, 0, sizeof(RECT));

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_LEFT,
						 &lSize,
						 &hhSess->rcSess.left);

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_TOP,
						 &lSize,
						 &hhSess->rcSess.top);

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_RIGHT,
						 &lSize,
						 &hhSess->rcSess.right);

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_BOTTOM,
						 &lSize,
						 &hhSess->rcSess.bottom);
		}

	if (bRet)
		{
		lSize = sizeof(UINT);

		hhSess->iShowCmd = SW_SHOWNORMAL;

		sfGetSessionItem(hhSess->hSysFile,
						 SFID_SESS_SHOWCMD,
						 &lSize,
						 &hhSess->iShowCmd);
		}

    //
    // load the key macros
    //

#ifdef INCL_KEY_MACROS
	if (bRet)
		{
        keysLoadMacroList( hSession );
        }
#endif

	// Note: if you need to do any resizing, you must POST a message
	// to do so.  The emulator may have changed size and that won't
	// reflected until it processes the pending notification - mrw
	//
	if (hhSess->achSessCmdLn[0] == TEXT('\0') && IsWindow(hhSess->hwndSess))
		{
		PostMessage(hhSess->hwndSess, WM_COMMAND,
			MAKEWPARAM(IDM_CONTEXT_SNAP, 0), 0);
		}

	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSaveSessionStuff
 *
 * DESCRIPTION:
 *	This function is called to call all the functions that save things in
 *	the session file.  If you have stuff to write into the session file, it
 *	should get called from here.  This function also makes sure that the
 *	user has a chance to specify the name of the session file if there is
 *	not one currently.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	Nothing.
 */
void sessSaveSessionStuff(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	/*
	 * Put in code to make sure we have an open session file handle
	 */
	assert(hhSess->hSysFile);	// any suggestions ?

	/* This doesn't have a handle since it isn't every used but once */
	sessSaveBackScroll(hSession);

	// Call this function if you've got to save settings that are stored
	// in the session handle itself.
	//
	sessSaveHdl(hSession);

	if (hhSess->hXferHdl != (HXFER)0)
		SaveXferHdl((HXFER)hhSess->hXferHdl);

	if (hhSess->hFilesHdl != (HFILES)0)
		SaveFilesDirsHdl(sessQueryFilesDirsHdl(hSession));

	if (hhSess->hCaptFile != (HCAPTUREFILE)0)
		SaveCaptureFileHandle(hhSess->hCaptFile);

	if (hhSess->hEmu != 0)
		emuSaveHdl(hhSess->hEmu);

	if (hhSess->hPrint != 0)
		printSaveHdl(hhSess->hPrint);

#if	defined(CHARACTER_TRANSLATION)
	if (hhSess->hTranslate)
		SaveTranslateHandle(hhSess->hTranslate);
#endif

	if (hhSess->hCLoop)
		CLoopSaveHdl(hhSess->hCLoop);

	if (hhSess->hCom)
		ComSaveHdl(hhSess->hCom);

	if (hhSess->hCnct)
		cnctSave(hhSess->hCnct);

	if (hhSess->hBackscrl)
		backscrlSave(hhSess->hBackscrl);

	if (hhSess->hwndTerm)
		SendMessage(hhSess->hwndTerm, WM_TERM_SAVE_SETTINGS, 0, 0);

#ifdef INCL_KEY_MACROS
    keysSaveMacroList(hSession );
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSaveHdl
 *
 * DESCRIPTION:
 *  Save items stored in the session handle.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	BOOL
 */
STATIC_FUNC void sessSaveHdl(HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	WINDOWPLACEMENT stWP;

	sessSaveIcons(hSession);

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_SOUND,
					 sizeof(BOOL),
					 &hhSess->fSound);

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_EXIT,
					 sizeof(BOOL),
					 &hhSess->fExit);

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_ALLOW_HOST_TRANSFER,
					 sizeof(BOOL),
					 &hhSess->fAllowHostXfers);

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_TLBR_VISIBLE,
					 sizeof(BOOL),
					 &hhSess->fToolbarVisible);

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_STBR_VISIBLE,
					 sizeof(BOOL),
					 &hhSess->fStatusbarVisible);

//  We should NEVER put this name into the session file!!!
//  -jac. 10-06-94 03:45pm
//	sfPutSessionItem(hhSess->hSysFile,
//				 SFID_SESS_NAME,
//				 (StrCharGetByteCount(hhSess->achSessName) + 1) * sizeof(TCHAR),
//				 hhSess->achSessName);

	memset(&stWP, 0, sizeof(WINDOWPLACEMENT));
	stWP.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(hhSess->hwndSess, &stWP);

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_LEFT,
					 sizeof(LONG),
					 &(stWP.rcNormalPosition.left));

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_TOP,
					 sizeof(LONG),
					 &(stWP.rcNormalPosition.top));

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_RIGHT,
					 sizeof(LONG),
					 &(stWP.rcNormalPosition.right));

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_BOTTOM,
					 sizeof(LONG),
					 &(stWP.rcNormalPosition.bottom));

	// mrw:4/21/95
	//
	if (stWP.showCmd == SW_SHOWMINIMIZED || stWP.showCmd == SW_MINIMIZE ||
		stWP.showCmd == SW_SHOWMINNOACTIVE)
		{
		stWP.showCmd = SW_SHOWNORMAL;
		}

	sfPutSessionItem(hhSess->hSysFile,
					 SFID_SESS_SHOWCMD,
					 sizeof(UINT),
					 &(stWP.showCmd));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSaveBackScroll
 *
 * DESCRIPTION:
 *	This function is called to take the stuff that is in the backscroll and
 *	on the screen and save it away in the session file.
 *
 *	The first attempt to do this will be simply a brute force attack.  No
 *	real attempt to be tricky or cute.  Just slam it through.  Maybe it will
 *	need to be changed later.  But that is later.
 *
 * ARGUMENTS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	TRUE if everything is OK, otherwise FALSE
 *
 */
BOOL sessSaveBackScroll(const HSESSION hSession)
	{
	BOOL bRet = TRUE;
	int nRet;
	POINT pBeg;
	POINT pEnd;
	ECHAR *pszData;
	ECHAR *pszPtr;
	ECHAR *pszEnd;
	DWORD dwSize;

	/* --- Don't bother with this if nothing has changed --- */

	if (backscrlChanged(sessQueryBackscrlHdl(hSession)) == FALSE)
		return TRUE;

	// Also, if there is no session window, don't bother since there
	// won't be any terminal window and CopyTextFromTerminal() will
	// fault. - mrw

	if (!IsWindow(sessQueryHwnd(hSession)))
		return TRUE;


	pBeg.x = 0;
	pBeg.y = -backscrlGetUNumLines(sessQueryBackscrlHdl(hSession)); //-BKSCRL_USERLINES_DEFAULT_MAX;
	pEnd.x = 132;
	pEnd.y = 50;

	pszData = (ECHAR *)0;
	dwSize = 0;

	CopyTextFromTerminal(hSession,
						&pBeg, &pEnd,
						(void **)&pszData,
						&dwSize,
						FALSE);

	assert(pszData);

	if (pszData != (ECHAR *)0)
		{
		assert(dwSize);
		/*
		 * We need to do a little work here to make sure that whatever
		 * trailing blank lines there are don't get put into the saved
		 * text.
		 */
		pszPtr = pszData;
		pszEnd = pszPtr;
		while (*pszPtr != ETEXT('\0'))
			{
			if (*pszPtr != ETEXT('\r'))
				pszEnd = pszPtr;
			pszPtr = pszPtr++;
			}
		pszEnd = pszPtr++;
		dwSize = (DWORD)((pszEnd - pszData) * sizeof(ECHAR));

		nRet = sfPutSessionItem(sessQuerySysFileHdl(hSession),
								SFID_BKSC_TEXT,
								dwSize,
								pszData);
		free(pszData);
		pszData = NULL;
		}

	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessRestoreBackScroll
 *
 * DESCRIPTION:
 *	This function is called to read a bunch of stuff (text) from the session
 *	file and cram it into the backscroll.
 *
 *	The first attempt to do this will be simply a brute force attack.  No
 *	real attempt to be tricky or cute.  Just slam it through.  Maybe it will
 *	need to be changed later.  But that is later.
 *
 * ARGUMENTS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	TRUE if everything is OK, otherwise FALSE
 *
 */
BOOL sessRestoreBackScroll(const HSESSION hSession)
	{

	BOOL          bRet = TRUE;
	unsigned long lSize;
	ECHAR *       pszData = NULL;
	ECHAR *       pszPtr = NULL;
	ECHAR *       pszEnd = NULL;
	HBACKSCRL     hBS = NULL;

	hBS = sessQueryBackscrlHdl(hSession);
	assert(hBS);

	/* Whenever we load in new session file, get rid of the old BS */
	backscrlFlush(hBS);

	lSize = 0;
	sfGetSessionItem(sessQuerySysFileHdl(hSession), SFID_BKSC_TEXT, &lSize, NULL);

	if (lSize > 0)
		{
		pszData = (ECHAR*)malloc(lSize * sizeof(ECHAR));
		if (pszData == NULL)
			{
			assert(pszData);
			return FALSE;
			}

		ECHAR_Fill(pszData, ETEXT('\0'), lSize);

		sfGetSessionItem(sessQuerySysFileHdl(hSession),
						SFID_BKSC_TEXT,
						&lSize,
						pszData);
		pszPtr = pszData;
		while ((*pszPtr != ETEXT('\0')) && (pszPtr <= (pszData + lSize)))
			{
			pszEnd = pszPtr;
			while ((*pszEnd != ETEXT('\0')) && (*pszEnd != ETEXT('\r')) &&
					(pszEnd <= (pszData + lSize)))
				pszEnd = pszEnd++;

			/* Stuff the line into the backscroll */
			backscrlAdd(hBS, pszPtr, (int)(pszEnd - pszPtr));

			/* Bump pointer to the beginning of the next line */
			pszPtr = pszEnd;
			if (*pszPtr == ETEXT('\r'))
				pszPtr = pszPtr++;
			}

		if (pszData)
			{
			free(pszData);
			pszData = NULL;
			}
		}

	backscrlResetChangedFlag(hBS);
	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessCheckAndLoadCmdLn
 *
 * DESCRIPTION:
 *	When the programs starts up, we save the command line.  If there is
 *	something on the command line, we check and see if maybe it is the name
 *	of a session file.	If it is, we open the session file. Other command
 *	line switches are processed here as well.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	0=OK, else error.
 */
int sessCheckAndLoadCmdLn(const HSESSION hSession)
	{
	int 				nIdx;
	int 				iRet = -1;
	LPTSTR 				pszStr;
    LPTSTR              pszTmp;
#if defined(INCL_WINSOCK)
	TCHAR*              pszTelnet = TEXT("telnet:");
	TCHAR*              pszPort = NULL;
#endif
	TCHAR				acPath[FNAME_LEN], acName[FNAME_LEN];
	const HHSESSION 	hhSess = VerifySessionHandle(hSession);

	if (hhSess->achSessCmdLn[0] == TEXT('\0'))
		return -1;

	// Null out the arrays for the path and name. REV: 10/26/2000 
	//
	TCHAR_Fill(acPath, TEXT('\0'), FNAME_LEN);
	TCHAR_Fill(acName, TEXT('\0'), FNAME_LEN);

    // Assume there's the name of a session file we want to open on the
    // command line. We'll accept a prepended /D as well.
    //
	// We should really only Open the entry here since the dial (/D)
	// switch was not passed on the command line.  I will leave it like
	// this for now, but it should be changed in the future to just
	// open the entry since you are not able to just open an entry
	// without attempting to dial. REV: 10/26/2000
	//
	hhSess->iCmdLnDial = CMDLN_DIAL_DIAL;
	nIdx = 0;

	for (pszStr = hhSess->achSessCmdLn;
		(*pszStr != TEXT('\0') && nIdx < FNAME_LEN);
		pszStr = StrCharNext(pszStr))
		{
		/*
		 * This works because we only allow certain characters as switches
		 */
		if (*pszStr == TEXT('/'))
			{
			/* Process as a switch */
			pszStr = StrCharNext(pszStr);
            //jmh 3/24/97 Check for end of string here...
            if (*pszStr == TEXT('\0'))
                {
                break;
                }

			if ((*pszStr == TEXT('D')) || (*pszStr == TEXT('d')))
                {
                // The name that follows is a session file
                pszTmp = StrCharNext(pszStr);
                if (*pszTmp == TEXT('\0'))
                    {
                    break;
                    }
                else
					{
					if (*pszTmp == TEXT(' '))
						{
						pszStr = pszTmp;
						hhSess->iCmdLnDial = CMDLN_DIAL_DIAL;
						}
					}
                }

#if defined(INCL_WINSOCK)
            if ((*pszStr == TEXT('T')) || (*pszStr == TEXT('t')))
                {
                pszTmp = StrCharNext(pszStr);
                //jmh 3/24/97 Check for end of string here...
                if (*pszTmp == TEXT('\0'))
                    {
                    break;
                    }
                else if (*pszTmp == TEXT(' '))
                    {
					pszStr = pszTmp;
                    // The name that follows is a telnet address
                    hhSess->iCmdLnDial = CMDLN_DIAL_WINSOCK;
                    }
                }
#endif
			}
		else
			{
			/* Copy all non switch stuff to the buffer */
			if (IsDBCSLeadByte(*pszStr))
				{
				MemCopy(&acPath[nIdx], pszStr, (size_t)2 * sizeof(TCHAR));
				nIdx += 2;
				}
            //
            // Make sure to strip off the " characters from the
            // session filename. REV: 06/13/2001
            //
			else if (*pszStr != TEXT('\"'))
				{
				acPath[nIdx++] = *pszStr;
				}
			}
		}

	// Removed old logic here and call GetFileNameFromCmdLine() which
	// does something similar to this function.  On return, we should
	// have a fully qualified path name. - mrw,3/2/95
	//
	acPath[nIdx] = TEXT('\0');
    TCHAR_Trim(acPath);     // Strip leading spaces

#if defined(INCL_WINSOCK)
	// If this is a telnet address from the browser, it will usually be preceeded
	// by the string telnet:  If so, we must remove it or it will confuse some of
	// the code to follow  jkh, 03/22/1997
	if (*acPath && hhSess->iCmdLnDial == CMDLN_DIAL_WINSOCK)
		{
		nIdx = StrCharGetStrLength(pszTelnet);
        if (StrCharCmpiN(acPath, pszTelnet, nIdx) == 0)
			{
			// Remove the telnet string from the front of acPath
			memmove(acPath, &acPath[nIdx],
				    (StrCharGetStrLength(acPath) - nIdx) + 1);
			}
		}

	// See if URL contains a port number. This will take the form of
    // addr:nnn where nnn is the port number i.e. culine.colorado.edu:860
    // or there might be the name of an assigned port like hilgraeve.com:finger.
    // We support numeric port right now, may add port names later. jkh, 3/22/1997
    pszPort = StrCharFindFirst(acPath, TEXT(':'));
    if (pszPort && isdigit(pszPort[1]))
        {
		hhSess->iTelnetPort = atoi(StrCharNext(pszPort));
        }

#endif
	GetFileNameFromCmdLine(acPath, acName, FNAME_LEN);

    if (acName[0] == TEXT('\0'))
        {
        // Nothing on the command line
        hhSess->iCmdLnDial = CMDLN_DIAL_NEW;
        iRet = 0;
        }
    else
        {
        // Look for a pre-existing session file. First, the old TRM format
        //
        if (fTestOpenOldTrmFile(hhSess, acName) != 0)
            {
            // Next, try the more common HyperTerminal file format
            //
            if (sfOpenSessionFile(hhSess->hSysFile, acName) < SF_OK)
                {
                // Command-line argument is not an existing file. Decide
                // how to act based on command-line switches.
                //
                if (hhSess->iCmdLnDial == CMDLN_DIAL_DIAL)
                    {
                    // We were asked to open and dial a pre-existing session
                    // file, and failed.
                    //
    			    TCHAR acFormat[64];
	    		    TCHAR ach[FNAME_LEN];
		    	    LoadString(glblQueryDllHinst(),
			    			    IDS_ER_BAD_SESSION,
				    		    acFormat,
					    	    sizeof(acFormat) / sizeof(TCHAR));
			        wsprintf(ach, acFormat, acName);

			        TimedMessageBox(sessQueryHwnd(hSession),
							        ach,
							        NULL,
							        MB_OK | MB_ICONEXCLAMATION,
							        sessQueryTimeout(hSession));

			        sfSetSessionFileName(hhSess->hSysFile, TEXT(""));

                    // Go to the Open dialog
			        hhSess->iCmdLnDial = CMDLN_DIAL_OPEN;
                    }
#if defined(INCL_WINSOCK)
                else if (hhSess->iCmdLnDial == CMDLN_DIAL_WINSOCK)
                    {
                    //jmh 3/24/97 For future maintainers: there's some
                    // skulduggery going on here that's worth explaining. When
                    // you try to open a non-existent file, the name is still
                    // stored. The code to do a telnet command-line dial
                    // depends on this. Honest! I didn't write this...
                    //
                    //jmh 3/24/97 Mark this as a new session, so user will be
                    // prompted to save on exit.
                    hhSess->fIsNewSession = TRUE;
                    iRet = 0;
                    }
#endif
                }
            else
                {
                // Command-line argument is an existing HyperTerminal file
                //
                hhSess->iCmdLnDial = CMDLN_DIAL_DIAL;
                iRet = 0;
                }
            }
        else
            {
            // Command-line argument is an existing TRM file
            //
            hhSess->iCmdLnDial = CMDLN_DIAL_DIAL;
            iRet = 0;
            }
        }

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fTestOpenOldTrmFile
 *
 * DESCRIPTION:
 *	Tests if its an old trm file. If so, it opens it and reads the
 *	data out.
 *
 * ARGUMENTS:
 *	hSession	- our friend the public session handle
 *	ach 		- name of file.
 *
 * RETURNS:
 *	0=OK, else not trm file
 *
 */
int fTestOpenOldTrmFile(const HHSESSION hhSess, TCHAR *pachName)
	{
	int iRet = -1;
	HANDLE hFile;
	DWORD  dw;
	LPTSTR pszPtr;
	TCHAR  ach[80];
	TCHAR  achName[FNAME_LEN];

	StrCharCopyN(achName, pachName, sizeof(achName) / sizeof(TCHAR));
	pszPtr = StrCharFindLast(achName, TEXT('.'));

	if (pszPtr && (StrCharCmpi(pszPtr, TEXT(".TRM")) == 0))
		{
		/* Old .TRM files case */
		hFile = CreateFile(achName, GENERIC_READ, FILE_SHARE_READ, 0,
				OPEN_EXISTING, 0, 0);

		if (hFile != INVALID_HANDLE_VALUE)
			{
			// Phone number is always at offset 0x282 for old .trm files.
			//
			if (SetFilePointer(hFile, 0x282, 0, FILE_BEGIN) != (DWORD)-1)
				{
				if (ReadFile(hFile, ach, sizeof(ach), &dw, 0) == TRUE)
					{
					CloseHandle(hFile);
					ach[sizeof(ach)/sizeof(TCHAR)-1] = TEXT('\0');

					cnctSetDestination(hhSess->hCnct, ach,
						StrCharGetByteCount(ach));

					*pszPtr = TEXT('\0');
					mscStripExt(mscStripPath(achName));
					sessSetName((HSESSION)hhSess, achName);
					hhSess->iCmdLnDial = CMDLN_DIAL_OPEN;
					hhSess->fIsNewSession = TRUE;	// so it asks to save
					hhSess->nIconId = IDI_PROG1;
					hhSess->hIcon = extLoadIcon(MAKEINTRESOURCE(IDI_PROG1));
					iRet = 0;
					}

				else
					{
					DbgShowLastError();
					CloseHandle(hFile);
					}
				}

			else
				{
				DbgShowLastError();
				CloseHandle(hFile);
				}
			}

		else
			{
			DbgShowLastError();
			}
		}

	return iRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\serialno.c ===
/*  File: \wacker\tdll\serialno.c
 *
 *  Copyright 1995 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 8 $
 *  $Date: 7/12/02 12:18p $
 *
 */

#include <windows.h>
#pragma hdrstop

#include "features.h"

#ifdef INCL_NAG_SCREEN

#define INCL_WIN
#define INCL_DOS

#include <stdlib.h>

#include <string.h>
#include <ctype.h>
#include <time.h>

#include "stdtyp.h"
#include "htchar.h"
#include "serialno.h"

// Function prototypes...
//
//static time_t CalcExpirationTime(const char * pszSerial);
static unsigned AsciiHEXToInt(TCHAR *sz);
static unsigned calc_crc(register unsigned crc,  TCHAR *data, int cnt);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  IsValidSerialNumber
 *
 * DESCRIPTION:
 *  Perform a crc test on the serial number passed in as a parameter
 *  to decide whether it is a valid serial number.
 *
 * ARGUMENTS:
 *  TCHAR *acSerialNo - pointer to a string conatining a serial number.
 *
 * RETURNS:
 *  TRUE if valid, FALSE otherwise, SERIALNO_EXPIRED if expired.
 *
 * AUTHOR:  Jadwiga A. Carlson, 10:03:16am 05-10-95
 *
 */
int IsValidSerialNumber(TCHAR *acSerialNo)
	{
	TCHAR	 acCRCPart[3];
	TCHAR	 acBuffer[MAX_USER_SERIAL_NUMBER + sizeof(TCHAR)];
	int	 len;
	register unsigned crc1;
	unsigned crc2;

	TCHAR_Fill(acBuffer, TEXT('\0'), sizeof(acBuffer)/sizeof(TCHAR));
	StrCharCopyN((TCHAR *)acBuffer, acSerialNo, sizeof(acBuffer)/sizeof(TCHAR));

	// If the product code doesn't match, we're outta here!  Note that
	// the first character should be an "H".
	//
	if (acBuffer[0] != 'H')
    {
		return FALSE;
    }

	len = StrCharGetStrLength(acBuffer);	// whole serial number
	if (len < APP_SERIALNO_MIN)
		{
		return FALSE;
		}

	acCRCPart[0] = acBuffer[len-2];			// everything but CRC
	acCRCPart[1] = acBuffer[len-1];
	acCRCPart[2] = '\0';
	acBuffer[len-2] = '\0';

	// Initialize these different so test will fail. mrw:8/25/95
	//
	crc1 = 1234;
	crc2 = 0;

	crc1 = calc_crc(0, acBuffer, (int)strlen(acBuffer));
	crc2 = AsciiHEXToInt(acCRCPart);

	if (crc2 != crc1)
		return(FALSE);


	return TRUE;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  calc_crc
 *
 * DESCRIPTION:
 *  Calucate crc check.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static unsigned calc_crc(register unsigned crc,  TCHAR *data, int cnt)
	{
	unsigned int c;
	register unsigned q;

	while (cnt--)
		{
		c = *data++;
		q = (crc ^ c) & 0x0f;
		crc = (crc >> 4) ^ (q * 0x1081);
		q = (crc ^ (c >> 4)) & 0x0f;
		crc = (crc >> 4) ^ (q * 0x1081);
		}

	crc = crc & 0x0ff;
	return (crc);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AsciiHEXToInt
 *
 * DESCRIPTION:
 *  Convert Ascii representation of a HEX number into integer.
 *
 * ARGUMENTS:
 *  sz - character string.
 *
 * RETURNS:
 *  unsigned - the number.
 *
 * AUTHOR:  Jadwiga A. Carlson, 11:34:32am 05-10-95
 *			(This function taken form HA/Win).
 */
static unsigned AsciiHEXToInt(TCHAR *sz)
	{
	unsigned i = 0;

	while (*sz == ' ' || *sz == '\t')
		sz++;

	while (isdigit(*sz) || isxdigit(*sz))
		{
		if (isdigit(*sz))
			i = (i * 16) + *sz++ - '0';
		else
			i = (i * 16) + (*sz++ - '0')-7;
		}

	return (i);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  CalcExpirationTime
 *
 * DESCRIPTION:
 *  Simple little function that calculates the expiration time based
 *  on the given serial number.  Currently, we expire a program on the
 *  1st day of the 4 calendar month.  Using the C time functions made
 *  this easy.
 *
 *  For simplicity and to re-use the KopyKat code, the serial numbers
 *  may NOT use double-byte characters !
 *
 * ARGUMENTS:
 *  LPSTR acSerial
 *
 * RETURNS:
 *  time_t time which is defined by ANSI as the number of seconds from
 *  Jan 1, 1970 GMT.  I suppose a correction for local time could be added
 *  but it just clutters up things when you think about it.
 *
 *  Will return 0 if the serial number is not in valid format
 *
 */
time_t CalcExpirationTime(const char *acSerial)
	{
	struct tm stSerial;
	time_t tSerial;
	int	   month;

	// Beta serial number format is SDymxxxx
	// where y = year since 1990, m = month (see below), and xxx = anything

	// Validate the year -- it must be a digit
	if ( ! isdigit(acSerial[3] ))
		return 0;

	// Month is represented by a single digit from 1 to 9 and A,B,C for
	// Oct, Nov, Dec.   If not a valid month, returns 0
	switch (acSerial[4])
		{
	case 'A':   month = 10;
		break;
	case 'B':   month = 11;
		break;
	case 'C':   month = 12;
		break;
	default:
		if (isdigit(acSerial[4]))
			month = acSerial[4] - '0';
		else
			return 0;
		break;
		}


	// Build a partial time structure.
	memset(&stSerial, 0, sizeof(struct tm));
	stSerial.tm_mday = 1;
	stSerial.tm_mon = month - 1;   // tm counts from 0
	stSerial.tm_year = 90 + (int)(acSerial[3] - '0'); // years since 1990

	// Expiration date is 1st day of fourth calendar month from date
	// of issue.

	stSerial.tm_mon += 3;

	// Check for end of year wrap around.

	if (stSerial.tm_mon >= 12)
		{
		stSerial.tm_mon %= 12;
		stSerial.tm_year += 1;
		}

	// Convert into time_t time.

	if ((tSerial = mktime(&stSerial)) == -1)
		return 0;

	return tSerial;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sessmenu.c ===
/*	File: D:\WACKER\tdll\sessmenu.c (Created: 30-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 4/22/02 1:26p $
 */
// #define	DEBUGSTR	1

#include <windows.h>
#pragma hdrstop

#include <time.h>		// goes with cnct.h

#include "stdtyp.h"
#include "session.h"
#include "emu\emu.h"
#include "term.h"
#include "print.h"
#include <term\res.h>
#include <tdll\assert.h>
#include "capture.h"
#include "globals.h"
#include "xfer_msc.h"
#include "cnct.h"
#if defined(INCL_NAG_SCREEN)
    #include "nagdlg.h"
    #include "register.h"
#endif

static void MenuItemCheck(const HMENU hMenu, const UINT uID, BOOL fChecked);
static void MenuItemEnable(const HMENU hMenu, const UINT uID, BOOL fEnable);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessInitMenuPopupEdit
 *
 * DESCRIPTION:
 *	Initializes edit menu just before display.
 *
 * ARGUMENTS:
 *	hSession	- external session handle
 *	hMenu		- edit popup menu handle
 *
 * RETURNS:
 *	void
 *
 */
void sessInitMenuPopupCall(const HSESSION hSession, const HMENU hMenu)
	{
	BOOL	fCheck = FALSE;
	HCNCT	hCnct = (HCNCT)0;
	int		iRet = CNCT_STATUS_FALSE;

	// Enable disconnect option only if we are connected.
	//
	hCnct = sessQueryCnctHdl(hSession);

	if (hCnct)
		iRet = cnctQueryStatus(hCnct);

    //
    // Check to see if we are currently connected or connecting.
    // Added the check for connecting status. REV: 03/23/2001
    //
	fCheck = (iRet == CNCT_STATUS_TRUE ||
              iRet == CNCT_STATUS_CONNECTING);

	MenuItemEnable(hMenu, IDM_ACTIONS_HANGUP, fCheck);

#ifdef INCL_CALL_ANSWERING
    // Enable "Wait for a Call" if we are not connected and not waiting.
    // Added check for "Connecting" and "Disconnecting" states as well.
    // REV: 03/23/2001
    //
    fCheck = (iRet != CNCT_STATUS_TRUE &&
              iRet != CNCT_STATUS_CONNECTING &&
              iRet != CNCT_STATUS_DISCONNECTING &&
              iRet != CNCT_STATUS_ANSWERING);
    MenuItemEnable(hMenu, IDM_ACTIONS_WAIT_FOR_CALL, fCheck);

    // Enable "Stop Waiting" if we are waiting for a call.
    //
    fCheck = (iRet == CNCT_STATUS_ANSWERING);
    MenuItemEnable(hMenu, IDM_ACTIONS_STOP_WAITING, fCheck);
    //Disable "Call" if we are waiting for a call - mpt 09-08-99
    //
	fCheck = (iRet == CNCT_STATUS_TRUE ||
              iRet == CNCT_STATUS_CONNECTING ||
              iRet == CNCT_STATUS_ANSWERING);
#endif

    //
    // Moved enabling/disabling the "Call" button after the check
    // for Waiting for calls so that we set the correct state when
    // we are waiting for calls. REV: 08/16/2001
    //
     MenuItemEnable(hMenu, IDM_ACTIONS_DIAL, !fCheck);
	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessInitMenuPopupEdit
 *
 * DESCRIPTION:
 *	Initializes edit menu just before display.
 *
 * ARGUMENTS:
 *	hSession	- external session handle
 *	hMenu		- edit popup menu handle
 *
 * RETURNS:
 *	void
 *
 */
void sessInitMenuPopupEdit(const HSESSION hSession, const HMENU hMenu)
	{
	BOOL	fCheck = FALSE, f;
	HCNCT	hCnct = (HCNCT)0;
	int		iRet = 0;

	// Don't enable the copy menu item unless we have something to copy.
	//
	if (SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_Q_MARKED, 0, 0))
		fCheck = TRUE;

	MenuItemEnable(hMenu, IDM_COPY, fCheck);

	// Enable Paste to Host if there is something on the clipboard and
	// we are connected.
	//
	hCnct = sessQueryCnctHdl(hSession);

	if (hCnct)
		iRet = cnctQueryStatus(hCnct);

	fCheck = IsClipboardFormatAvailable(CF_TEXT);

	f = fCheck && (iRet == CNCT_STATUS_TRUE);
    MenuItemEnable(hMenu, IDM_PASTE, f);
	DbgOutStr("Enable IDM_PASTE %d %d %d\r\n", f, fCheck, iRet == CNCT_STATUS_TRUE, 0,0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessInitMenuPopupView
 *
 * DESCRIPTION:
 *	Initializes view menu just before display.
 *
 * ARGUMENTS:
 *	hSession	- external session handle
 *	hMenu		- view popup menu handle
 *
 * RETURNS:
 *	void
 *
 */
void sessInitMenuPopupView(const HSESSION hSession, const HMENU hMenu)
	{
	BOOL f;
#if defined(TESTMENU) && !defined(NDEBUG)
	const HWND hwndTerm = sessQueryHwndTerminal(hSession);
#endif
	const HWND hwndToolbar = sessQueryHwndToolbar(hSession);
	const HWND hwndStatusbar = sessQueryHwndStatusbar(hSession);

#if defined(TESTMENU) && !defined(NDEBUG)
	f = (BOOL)SendMessage(hwndTerm, WM_TERM_Q_BEZEL, 0, 0);
	MenuItemCheck(hMenu, IDM_TEST_BEZEL, f);
#endif

	f = IsWindow(hwndToolbar) && sessQueryToolbarVisible(hSession);
	MenuItemCheck(hMenu, IDM_VIEW_TOOLBAR, f);

	f = IsWindow(hwndStatusbar) && sessQueryStatusbarVisible(hSession);
	MenuItemCheck(hMenu, IDM_VIEW_STATUS, f);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	sessInitMenuPopupActions
 *
 * DESCRIPTION:
 *	This function gets called when the Actions menu is about to be displayed
 *	so that any last minute changes can be made.
 *
 * PARAMETERS:
 *	hSession	- external session handle
 *	hMenu		- view popup menu handle
 *
 * RETURNS:
 *	void
 *
 */

#define TRANSFER_CAPTURE_OFFSET 2

void sessInitMenuPopupTransfer(const HSESSION hSession, const HMENU hMenu)
	{
	int nMode;
	BOOL f;
	VOID *pData;
	MENUITEMINFO stM;
	TCHAR acMessage[64];
	HMENU hSubMenu;


	pData = (VOID *)0;
	xfrQueryDataPointer(sessQueryXferHdl(hSession), &pData);

	/*
	 * A NULL pointer means no transfer in progress, a non-NULL pointer
	 * means that someone is transferring.
	 */
	f = (pData == (VOID *)0);

	MenuItemEnable(hMenu, IDM_ACTIONS_SEND, f);
	MenuItemEnable(hMenu, IDM_ACTIONS_RCV, f);

	/*
	 * This section is for the Capture Menu.  It is more of a pain.
	 */
	nMode = cpfGetCaptureState(sessQueryCaptureFileHdl(hSession));
	if (nMode == CPF_CAPTURE_OFF)
		{
		/* Set things so that they can get to the dialog box */
		LoadString(glblQueryDllHinst(),
					IDS_CPF_CAP_OFF,
					acMessage,
					sizeof(acMessage) / sizeof(TCHAR));

		memset(&stM, 0, sizeof(MENUITEMINFO));

		stM.cbSize = sizeof(MENUITEMINFO);
		stM.fMask = MIIM_ID | MIIM_TYPE | MIIM_SUBMENU;
		stM.wID = IDM_ACTIONS_CAP;
		stM.fType = MFT_STRING;
		stM.hSubMenu = (HMENU)0;
		stM.dwTypeData = (LPTSTR)acMessage;

		DbgOutStr("Setting Capture to start dialog\r\n", 0,0,0,0,0);

		SetMenuItemInfo(hMenu,
						TRANSFER_CAPTURE_OFFSET,
						TRUE,			/* By Position */
						&stM);
		}
	else
		{
		LoadString(glblQueryDllHinst(),
					IDS_CPF_CAP_ON,
					acMessage,
					sizeof(acMessage) / sizeof(TCHAR));

		hSubMenu = cpfGetCaptureMenu(sessQueryCaptureFileHdl(hSession));

		memset(&stM, 0, sizeof(MENUITEMINFO));
		stM.cbSize = sizeof(MENUITEMINFO);
		stM.fMask = MIIM_TYPE | MIIM_SUBMENU;
		stM.hSubMenu = hSubMenu;
		stM.dwTypeData = (LPTSTR)acMessage;

		/* Set up the cascade for the alternative choices */
		switch (nMode)
			{
			default:
			case CPF_CAPTURE_ON:
				/* Disable RESUME, enable PAUSE */
				MenuItemEnable(hSubMenu, IDM_CAPTURE_RESUME, FALSE);
				MenuItemEnable(hSubMenu, IDM_CAPTURE_PAUSE,  TRUE);
				break;
			case CPF_CAPTURE_PAUSE:
				/* Disable PAUSE, enable RESUME */
				MenuItemEnable(hSubMenu, IDM_CAPTURE_RESUME, TRUE);
				MenuItemEnable(hSubMenu, IDM_CAPTURE_PAUSE,  FALSE);
				break;
			}

		DbgOutStr("Setting Capture to cascade menu\r\n", 0,0,0,0,0);

		SetMenuItemInfo(hMenu,
						TRANSFER_CAPTURE_OFFSET,
						TRUE,			/* By Position */
						&stM);
		}

	// Display setup for Printer Echo option.

	MenuItemEnable(hMenu, IDM_ACTIONS_PRINT,  TRUE);
	f = printQueryStatus(emuQueryPrintEchoHdl(sessQueryEmuHdl(hSession)));
	MenuItemCheck(hMenu, IDM_ACTIONS_PRINT, f);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessInitMenuPopupView
 *
 * DESCRIPTION:
 *	Initializes view menu just before display.
 *
 * ARGUMENTS:
 *	hSession	- external session handle
 *	hMenu		- view popup menu handle
 *
 * RETURNS:
 *	void
 *
 */
void sessInitMenuPopupHelp(const HSESSION hSession, const HMENU hMenu)
	{
#if defined(INCL_NAG_SCREEN)
    if ( !IsEval() )
        {
        MenuItemEnable(hMenu, IDM_PURCHASE_INFO, FALSE);
        MenuItemEnable(hMenu, IDM_REG_CODE, FALSE);
        }

    // If they are already registered take this menu item off
    //
#ifndef NT_VERSION
    if (IsRegisteredUser())
        {
        DeleteMenu(hMenu, IDM_REGISTER, MF_BYCOMMAND);
        }
#endif
#endif  

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MenuItemCheck
 *
 * DESCRIPTION:
 *	Once again the menu functions have changed.  Checking and unchecking
 *	menu items is a bit more complicated so I wrote a function to handle
 *	it.  Other common menu operations should be handled this way. - mrw
 *
 * ARGUMENTS:
 *	hMenu	- handle of menu
 *	uID 	- id of menu item (position not supported)
 *	fChecked- TRUE if item is to be checked
 *
 * RETURNS:
 *	void
 *
 */
static void MenuItemCheck(const HMENU hMenu, const UINT uID, BOOL fChecked)
	{
	MENUITEMINFO mii;

	memset(&mii, 0, sizeof(MENUITEMINFO));
	mii.cbSize = sizeof(MENUITEMINFO);
	mii.fMask = MIIM_STATE;
	mii.fState = (fChecked) ? MFS_CHECKED : MFS_UNCHECKED;
	mii.wID = uID;

	SetMenuItemInfo(hMenu, uID, FALSE, &mii);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *	Please see the previous function.
 *
 * ARGUEMENTS:
 *	Please see the previous function.
 *
 * RETURNS:
 *	Nothing.
 */

static void MenuItemEnable(const HMENU hMenu, const UINT uID, BOOL fEnable)
	{
	MENUITEMINFO mii;

	memset(&mii, 0, sizeof(MENUITEMINFO));
	mii.cbSize = sizeof(MENUITEMINFO);
	mii.fMask = MIIM_STATE;
	mii.fState = (fEnable) ? (MFS_ENABLED) : (MFS_DISABLED | MFS_GRAYED);
	mii.wID = uID;

	SetMenuItemInfo(hMenu, uID, FALSE, &mii);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	HandleContextMenu
 *
 * DESCRIPTION:
 *	Load and display the context menu.
 *
 * ARGUMENTS:
 *	hwnd	- session window handle.
 *	point 	- where the user clicked.
 *
 * RETURNS:
 *	void.
 *
 */
void HandleContextMenu(HWND hwnd, POINT point)
	{
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	HMENU hMenu;
	HMENU hMenuTrackPopup;
	BOOL  fCheck = FALSE, f;
	HCNCT hCnct = (HCNCT)0;
	int   iRet = 0;

	hMenu = LoadMenu(glblQueryDllHinst() , "SessionContextMenu");
	if (!hMenu)
		return;

	// Don't enable the copy menu item unless we have something to copy.
	//
	if (SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_Q_MARKED, 0, 0))
		fCheck = TRUE;

	// Enable - 'Copy' menu item
	//
	MenuItemEnable(hMenu, IDM_CONTEXT_COPY, fCheck);

	// Enable - 'Paste to Host' menu item
	//
	hCnct = sessQueryCnctHdl(hSession);
	if (hCnct)
		iRet = cnctQueryStatus(hCnct);

	fCheck = IsClipboardFormatAvailable(CF_TEXT);

	f = fCheck && (iRet == CNCT_STATUS_TRUE);
    MenuItemEnable(hMenu, IDM_CONTEXT_PASTE, f);

	/* --- Snap doesn't make sense when we're maximized - mrw --- */

	if (IsZoomed(hwnd))
		MenuItemEnable(hMenu, IDM_CONTEXT_SNAP, FALSE);

	/* --- Normal context menu stuff --- */

	hMenuTrackPopup = GetSubMenu(hMenu, 0);

	ClientToScreen(hwnd, (LPPOINT)&point);

	TrackPopupMenu(hMenuTrackPopup, 0, point.x, point.y, 0, hwnd, NULL);

	DestroyMenu(hMenu);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\session.h ===
/*	File: D:\WACKER\tdll\session.h (Created: 01-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 5/29/02 2:17p $
 */

/* --- Child window identifiers --- */

#define IDC_STATUS_WIN	 1	// ID of status window
#define IDC_TOOLBAR_WIN  2	// ID of toolbar window
#define IDC_TERMINAL_WIN 3	// ID of terminal window
#define IDC_SIDEBAR_WIN  4	// ID of sidebar window

/* --- Suspend identifiers --- */

#define SUSPEND_SCRLCK				1
#define SUSPEND_TERMINAL_MARKING	2
#define SUSPEND_TERMINAL_LBTNDN 	3
#define SUSPEND_TERMINAL_COPY		4

/* --- Command line connection flags --- */

#define CMDLN_DIAL_NEW		  0
#define CMDLN_DIAL_DIAL		  1
#define CMDLN_DIAL_OPEN 	  2 	// don't attempt connection
#define CMDLN_DIAL_WINSOCK    3		// try the command line as an IP address

/* --- Notification event IDs used with NotifyClient --- */

#define WM_SESS_NOTIFY		WM_USER+0x100
#define WM_SESS_ENDDLG		WM_USER+0x101
#define WM_FAKE_TIMER		WM_USER+0x102	// Used in timers.c
#define WM_CMDLN_DIAL		WM_USER+0x103
#define WM_SESS_SIZE_SHOW	WM_USER+0x104	// wPar=nCmdShow from WinMain()
#define WM_CNCT_DIALNOW 	WM_USER+0x105	// wPar=connection flags.
#define WM_DISCONNECT		WM_USER+0x106	// wPar=disconnect flags.
#define WM_HT_QUERYOPENFILE WM_USER+0x107	// lPar=global atom
#define WM_SESS_SHOW_SIDEBAR WM_USER+0x108	// mrw,4/13/95
#define WM_ERROR_MSG        WM_USER+0x109   // jmh,3/25/96

enum _emuNotify
	{
	EVENT_TERM_UPDATE,				// Server has updated terminal buffer.
	EVENT_TERM_TRACK,				// pause in data flow, can track cursor.
	EVENT_EMU_CLRATTR,				// Clear attribute has changed.
	EVENT_EMU_SETTINGS, 			// Emulator settings changed.
	EVENT_FATALMEM_ERROR,			// Unrecoverable memory error.
	EVENT_LOGFILE_ENTRY,			// Server has a waiting log file item
	EVENT_BYTESRCH_END, 			// Script Byte search operation ended
	EVENT_USER_XFER_END,			// User transfer ended
	EVENT_SCRIPT_XFER_END,			// Script transfer ended
	EVENT_PORTONLY_OPEN,			// similar to connection made
	EVENT_CONNECTION_OPENED,		// connection driver made connection.
	EVENT_CONNECTION_CLOSED,		// disconnect completed.
	EVENT_CONNECTION_INPROGRESS,	// connection in progress
	EVENT_GETSTRING_END,			// Get String operation ended
	EVENT_HOST_XFER_REQ,			// host transfer request made.
	EVENT_HOST_XFER_ENQ,			// host transfer enquiry make.
	EVENT_CLOOP_SEND,				// CLoop send called.
	EVENT_SCR_FUNC_END, 			// A script function ended
	EVENT_CLOSE_SESSION,			// Instructs to close the session.
	EVENT_ERROR_MSG, 				// argument has string to load.
	EVENT_LEARN_SOMETHING,			// learning has something to do
	EVENT_DDE_GOT_DATA, 			// dde has something to return
	EVENT_WAIT_FOR_CALLBACK,		// system should wait for callback.
	EVENT_KILL_CALLBACK_DLG,		// dismisses callback dialog
	EVENT_COM_DEACTIVATED,			// com driver deactivated port
	EVENT_CNCT_DLG, 				// cnct driver connection dialog message
	EVENT_PRINT_ERROR,				// printecho error.
	EVENT_LED_AA_ON,				// obvious...
	EVENT_LED_CD_ON,
	EVENT_LED_OH_ON,
	EVENT_LED_RD_ON,
	EVENT_LED_SD_ON,
	EVENT_LED_TR_ON,
	EVENT_LED_MR_ON,
	EVENT_LED_AA_OFF,
	EVENT_LED_CD_OFF,
	EVENT_LED_OH_OFF,
	EVENT_LED_RD_OFF,
	EVENT_LED_SD_OFF,
	EVENT_LED_TR_OFF,
	EVENT_LED_MR_OFF,
    EVENT_LOST_CONNECTION
	};

typedef enum _emuNotify NOTIFICATION;

void NotifyClient(const HSESSION hSession, const NOTIFICATION nEvent,
				  const long lExtra);

void DecodeNotification(const HWND hwndSession, WPARAM wPar, LPARAM lPar);

void DecodeSessionNotification(const HWND hwndSession,
							const NOTIFICATION nEvent,
							const LPARAM lExtra);

/* --- Create and Destroy Functions --- */

HSESSION CreateSessionHandle(const HWND hwndSession);

BOOL InitializeSessionHandle(const HSESSION hSession, const HWND hwnd,
							 const CREATESTRUCT *pcs);

BOOL ReinitializeSessionHandle(const HSESSION hSession, const int fUpdateTitle);

void DestroySessionHandle(const HSESSION hSession);

HWND CreateSessionToolbar(const HSESSION hSession, const HWND hwndSession);
HWND CreateTerminalWindow(const HWND hwndSession);

int  CreateEngineThread(const HSESSION hSession);
void DestroyEngineThread(const HSESSION hSession);

/* ---	Set and Query functions --- */

HWND sessQueryHwnd(const HSESSION hSession);
HWND sessQueryHwndStatusbar(const HSESSION hSession);
HWND sessQueryHwndToolbar(const HSESSION hSession);
HUPDATE sessQueryUpdateHdl(const HSESSION hSession);

void sessSetEngineThreadHdl(const HSESSION hSession, const HANDLE hThread);
HANDLE sessQueryEngineThreadHdl(const HSESSION hSession);

HWND sessQueryHwndTerminal(const HSESSION hSession);
HTIMERMUX sessQueryTimerMux(const HSESSION hSession);
VOID sessReleaseTimerMux(const HSESSION hSession);
HEMU sessQueryEmuHdl(const HSESSION hSession);
HCLOOP sessQueryCLoopHdl(const HSESSION hSession);
HCOM sessQueryComHdl(const HSESSION hSession);
HTRANSLATE sessQueryTranslateHdl(const HSESSION hSession);

void sessSetSysFileHdl(const HSESSION hSession, const SF_HANDLE hSF);
SF_HANDLE sessQuerySysFileHdl(const HSESSION hSession);

HBACKSCRL sessQueryBackscrlHdl(const HSESSION hSession);
HXFER sessQueryXferHdl(const HSESSION hSession);
HFILES sessQueryFilesDirsHdl(const HSESSION hSession);
HCAPTUREFILE sessQueryCaptureFileHdl(const HSESSION hSession);
HPRINT sessQueryPrintHdl(const HSESSION hSession);
void sessQueryCmdLn(const HSESSION hSession, LPTSTR pach, const int len);
HCNCT sessQueryCnctHdl(const HSESSION hSession);
#if defined(INCL_WINSOCK)
int sessQueryTelnetPort(const HSESSION hSession);
#endif

void sessSetTimeout(const HSESSION hSession, int nTimeout);
int sessQueryTimeout(const HSESSION hSession);
void  sessInitializeIcons(HSESSION hSession);
void  sessLoadIcons(HSESSION hSession);
void  sessSaveIcons(HSESSION hSession);

void  sessSetIconID(const HSESSION hSession, const int nID);
int   sessQueryIconID(const HSESSION hSession);

HICON sessQueryIcon(const HSESSION hSession);
HICON sessQueryLittleIcon(const HSESSION hSession);

void sessSetName(const HSESSION hSession, const LPTSTR pach);
void sessQueryName(const HSESSION hSession, const LPTSTR pach, unsigned uSize);
int sessQuerySound(const HSESSION hSession);
void sessSetSound(const HSESSION hSession, int fSound);

//mpt:10-28-97 added 'exit on disconnect' feature
int sessQueryExit(const HSESSION hSession);
void sessSetExit(const HSESSION hSession, int fExit);

int sessQueryIsNewSession(const HSESSION hSession);
void sessSetIsNewSession(const HSESSION hSession, int fIsNewSession);
void sessQueryOldName(const HSESSION hSession, const LPTSTR pach, unsigned uSize);
BOOL sessIsSessNameDefault(LPTSTR pacName);

void sessQueryWindowRect(const HSESSION hSession, RECT *rec);
int	 sessQueryWindowShowCmd(const HSESSION hSession);

HWND sessQuerySidebarHwnd(const HSESSION hSession);
HWND CreateSidebar(const HWND hwndSession, const HSESSION hSession);

// REV: 2/28/2002 added 'Allow host initiated file transfers' feature
BOOL sessQueryAllowHostXfers(const HSESSION hSession);
void sessSetAllowHostXfers(const HSESSION hSession, BOOL fAllowHostXfers);

/* --- sessmenu.c --- */

void sessInitMenuPopupCall(const HSESSION hSession, const HMENU hMenu);
void sessInitMenuPopupEdit(const HSESSION hSession, const HMENU hMenu);
void sessInitMenuPopupView(const HSESSION hSession, const HMENU hMenu);
void sessInitMenuPopupTransfer(const HSESSION hSession, const HMENU hMenu);
void sessInitMenuPopupHelp(const HSESSION hSession, const HMENU hMenu);
void HandleContextMenu(HWND hwnd, POINT point);

/* --- sessutil.c --- */

void sessSnapToTermWindow(const HWND hwnd);
BOOL sessComputeSnapSize(const HSESSION hSession, const LPRECT prc);
void sessSetMinMaxInfo(const HSESSION hSession, const PMINMAXINFO pmmi);

int  OpenSession(const HSESSION hSession, HWND hwnd);
BOOL SaveSession(const HSESSION hSession, HWND hwnd);
void SilentSaveSession(const HSESSION hSession, HWND hwnd, BOOL fExplicit);
void SaveAsSession(const HSESSION hSession, HWND hwnd);

void sessSaveSessionStuff(const HSESSION hSession);
BOOL sessLoadSessionStuff(const HSESSION hSession);

void sessSetSuspend(const HSESSION hSession, const int iReason);
void sessClearSuspend(const HSESSION hSession, const int iReason);
BOOL IsSessionSuspended(const HSESSION hSession);

BOOL sessSaveBackScroll(const HSESSION hSession);
BOOL sessRestoreBackScroll(const HSESSION hSession);

BOOL sessQueryToolbarVisible(const HSESSION hSession);
BOOL sessSetToolbarVisible(const HSESSION hSession, const BOOL fVisible);

BOOL sessQueryStatusbarVisible(const HSESSION hSession);
BOOL sessSetStatusbarVisible(const HSESSION hSession, const BOOL fVisible);

void sessCmdLnDial(const HSESSION hSession);

void sessUpdateAppTitle(const HSESSION hSession);

BOOL sessDisconnectToContinue(const HSESSION hSession, HWND hwnd);

void sessSizeAndShow(const HWND hwnd, const int nCmdShow);

void sessBeeper(const HSESSION hSession);

/* --- fontdlg.c --- */

void DisplayFontDialog(const HSESSION hSession, BOOL fPrinterFont);

/* --- termcpy.c --- */

BOOL CopyMarkedTextFromTerminal(const HSESSION hSession, void **ppv,
								DWORD *pdwCnt, const BOOL fIncludeLF);

BOOL CopyTextFromTerminal(const HSESSION hSession,
						  const PPOINT pptBeg,
						  const PPOINT pptEnd,
						  void **ppv,
						  DWORD *dwCnt,
						  const BOOL fIncludeLF);
/* --- clipbrd.c --- */

BOOL PasteFromClipboardToHost(const HWND hwnd, const HSESSION hSession);

/* --- toolbar.c --- */

VOID ToolbarNeedsText(HSESSION hSession, LPARAM lPar);

LRESULT ToolbarNotification(const HWND hwnd,
						const int nId,
						const int nNotify,
						const HWND hwndCtrl);

void ToolbarEnableMinitelButtons(const HWND hwndToolbar, const int fEnable);

void ToolbarEnableButton(const HWND hwndToolbar, const int uID, BOOL fEnable);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sesshdl.c ===
/*	File: D:\WACKER\tdll\sesshdl.c (Created: 01-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 12 $
 *	$Date: 7/08/02 6:47p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>

#include "features.h"

#include "stdtyp.h"
#include "mc.h"
#include "assert.h"
#include "session.h"
#include "session.hh"
#include "sf.h"
#include "backscrl.h"
#include "globals.h"
#include "xfer_msc.h"
#include "file_msc.h"
#include "print.h"
#include "capture.h"
#include "timers.h"
#include "com.h"
#include "cloop.h"
#include "errorbox.h"
#include "tdll.h"
#include "htchar.h"
#include <term\res.h>
#include <emu\emu.h>
#include "update.h"
#include "cnct.h"
#include "statusbr.h"
#include "sess_ids.h"
#include "misc.h"
#include "translat.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateSessionHandle
 *
 * DESCRIPTION:
 *	Creates a session handle.  Note, hwndSession can be 0 if you need
 *	to create a stand alone session handle.
 *
 * ARGUMENTS:
 *	hwndSession - session window handle (can be 0)
 *
 * RETURNS:
 *	Session handle or 0.
 *
 */
HSESSION CreateSessionHandle(const HWND hwndSession)
	{
	HHSESSION hhSess;

	hhSess = (HHSESSION)malloc(sizeof(*hhSess));

	if (hhSess == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hhSess, 0, sizeof(*hhSess));

	hhSess->lPrefix = PRE_MAGIC;
	hhSess->lPostfix = POST_MAGIC;

	InitializeCriticalSection(&hhSess->csSess);
	InitializeCriticalSection(&hhSess->csTimerMux);
	hhSess->hwndSess = hwndSession;

	return (HSESSION)hhSess;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	InitializeSessionHandle
 *
 * DESCRIPTION:
 *	Does all the dirty work of initilizing the session handle
 *
 *	A special case for this code is when it gets called by the stuff in the
 *	shell extensions for property sheets.  This case can be recognised by the
 *	fact that the session window handle is NULL, as is the pointer to the
 *	CREATESTRUCT.
 *
 * ARGUMENTS:
 *	hSession	- session handle
 *	hwnd		- session window handle
 *  *pcs		- pointer to CREATESTRUCT, passed along from CreateWindowEx().
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL InitializeSessionHandle(const HSESSION hSession, const HWND hwnd,
							 const CREATESTRUCT *pcs)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	TCHAR 	ach[256], achTitle[100], achFormat[100];

	/* --- Any session command data is saved for later --- */

	if (pcs)
		{
		if (pcs->lpCreateParams)
			{
            // Make sure we don't overrun the buffer. REV: 11/10/2000
            //
			StrCharCopyN(hhSess->achSessCmdLn, (TCHAR*)pcs->lpCreateParams,
                sizeof(hhSess->achSessCmdLn)/sizeof(TCHAR) - 1);

            // Make sure the array is NULL terminated. REV: 11/10/2000
            //
            hhSess->achSessCmdLn[sizeof(hhSess->achSessCmdLn)/sizeof(TCHAR) - 1] = TEXT('\0');
			}
		}

	/* --- Create multiplexed timer --- */

	if (hwnd)
		{
		if (TimerMuxCreate(hwnd, 0, &hhSess->hTimerMux, hSession) != TIMER_OK)
			{
			assert(FALSE);
			return FALSE;
			}

	    /* --- Create status window using a common control --- */

		hhSess->hwndStatusbar = sbrCreateSessionStatusbar(hSession);

		if (!hhSess->hwndStatusbar)
			{
			assert(FALSE);
			return FALSE;
			}

		sessSetStatusbarVisible(hSession, TRUE);

	    /* --- Create a session toolbar --- */

		hhSess->hwndToolbar = CreateSessionToolbar(hSession, hwnd);

		if (!hhSess->hwndToolbar)
			{
			assert(FALSE);
			return FALSE;
			}

		sessSetToolbarVisible(hSession, TRUE);

        hhSess->hwndSidebar = CreateSidebar(hwnd, hSession);

		if (!hhSess->hwndSidebar)
			{
			assert(FALSE);
			return FALSE;
			}
		}

	/* --- Create a Backscroll handle --- */

	hhSess->hBackscrl = backscrlCreate(hSession, 250*132);

	if (!hhSess->hBackscrl)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create an Update handle --- */

	hhSess->hUpdate = updateCreate(hSession);

	if (!hhSess->hUpdate)
		{
		assert(FALSE);
		return FALSE;
		}

	/* -- Create a CLoop handle --- */
	hhSess->hCLoop = CLoopCreateHandle(hSession);

	if (!hhSess->hCLoop)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create an Emulator handle --- */

	hhSess->hEmu = emuCreateHdl(hSession);

	if (!hhSess->hEmu)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create a terminal window --- */

	if (hwnd)
		{
		hhSess->hwndTerm = CreateTerminalWindow(hwnd);

		if (!hhSess->hwndTerm)
			{
			assert(FALSE);
			return FALSE;
			}
		}

	/* -- Create a Com handle --- */
	if (ComCreateHandle(hSession, &hhSess->hCom) != COM_OK)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create a transfer handle --- */
    if (hwnd)
		{
		hhSess->hXferHdl = CreateXferHdl(hSession);
		if (!hhSess->hXferHdl)
			{
			assert(FALSE);
			return FALSE;
			}

	    /* --- Create a Files and Directorys handle --- */
		hhSess->hFilesHdl = CreateFilesDirsHdl(hSession);
		if (!hhSess->hFilesHdl)
			{
			assert(FALSE);
			return FALSE;
			}
		}

	/* --- Create a session data file handle --- */

	hhSess->hSysFile = CreateSysFileHdl();
	if (hhSess->hSysFile == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create a connection handle --- */

	hhSess->hCnct = cnctCreateHdl(hSession);

	if (hhSess->hCnct == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create a capture file handle --- */

	hhSess->hCaptFile = CreateCaptureFileHandle(hSession);
	if (hhSess->hCaptFile == 0)
		{
		assert(FALSE);
		return FALSE;
		}

    /* --- Create a print handle --- */

	hhSess->hPrint = printCreateHdl(hSession);
	if (hhSess->hPrint == 0)
		{
		assert(FALSE);
		return FALSE;
		}

#if	defined(CHARACTER_TRANSLATION)
	hhSess->hTranslate = CreateTranslateHandle(hSession);
	if (hhSess->hTranslate == NULL)
		{
		assert(FALSE);
		return FALSE;
		}
#endif

	/* --- Initialize the error message timeout value --- */

	hhSess->nTimeout = 0;

	/* --  Start the engine  --- */

	if (hwnd && hhSess->hCLoop)
		CLoopActivate(hhSess->hCLoop);

	// Set default sound setting...
	//
	hhSess->fSound = FALSE;

	// Set default exit setting...
	//
	hhSess->fExit = FALSE;

	// Set the 'Allow host initiated file transfers' feature
	//
	hhSess->fAllowHostXfers = FALSE;

	// Store some default values in the rcSess...
	//
	hhSess->rcSess.top = hhSess->rcSess.bottom = 0;
	hhSess->rcSess.right = hhSess->rcSess.left = 0;

	// Load program icon as session icon, load routine can overwrite this
	// to user defined icon.
	//
	sessInitializeIcons((HSESSION)hhSess);

	/* --- Process the command line stuff, if any --- */

	// Is this a new connection... i.e., hasn't been saved before.
	//
	hhSess->fIsNewSession = FALSE;

	if (hwnd)
		{
		// if (StrCharGetStrLength(hhSess->achSessCmdLn) > 0)
		if (sessCheckAndLoadCmdLn(hSession) == 0)
			{
			if (sessLoadSessionStuff(hSession) == FALSE)
                {
                LoadString(glblQueryDllHinst(), IDS_ER_BAD_SESSION,
                    achFormat, sizeof(achFormat)/sizeof(TCHAR));

                // mrw:10/7/96
                //
			    wsprintf(ach, achFormat, "");   // get rid of %s

                LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN,
                    achTitle, sizeof(achTitle)/sizeof(TCHAR));

                TimedMessageBox(hwnd, ach, achTitle, 
                    MB_OK | MB_ICONEXCLAMATION, hhSess->nTimeout);

                if (ReinitializeSessionHandle(hSession, TRUE) == FALSE)
                    {
                    LoadString(glblQueryDllHinst(), IDS_ER_REINIT,
                        ach, sizeof(ach)/sizeof(TCHAR));

                    LoadString(glblQueryDllHinst(), IDS_MB_TITLE_ERR,
                        achTitle, sizeof(achTitle)/sizeof(TCHAR));

                    TimedMessageBox(hwnd, ach, achTitle, 
                        MB_OK | MB_ICONSTOP, hhSess->nTimeout);

                    PostQuitMessage(1);
                    return FALSE;
                    }
				}

			emuHomeHostCursor(hhSess->hEmu);
			emuEraseTerminalScreen(hhSess->hEmu);
			}

        if (hhSess->achSessName[0] == TEXT('\0'))
			{
			ach[0] = TEXT('\0');

  			LoadString(glblQueryDllHinst(), IDS_GNRL_NEW_CNCT, ach,
				sizeof(ach) / sizeof(TCHAR));

			StrCharCopyN(hhSess->achSessName, ach, FNAME_LEN + 1);
			StrCharCopyN(hhSess->achOldSessName, ach, FNAME_LEN + 1);
			hhSess->fIsNewSession = TRUE;
			}

		sessUpdateAppTitle(hSession);
		PostMessage(hwnd, WM_SETICON, (WPARAM)TRUE, (LPARAM)hhSess->hIcon);

	/* --- Force status line to update --- */

		SendMessage(hhSess->hwndStatusbar, SBR_NTFY_INITIALIZE, 0, 0);
        }

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ReinitializeSessionHandle
 *
 * DESCRIPTION:
 *	Calls a bunch of functions to set the session handle back to a known,
 *	blank state, without having to destroy it.
 *
 * ARGUMENTS:
 *	hSession	- external session handle.
 *  fUpdateTitle- reset the app window title if this is TRUE
 *
 * RETURNS:
 */
BOOL ReinitializeSessionHandle(const HSESSION hSession, const int fUpdateTitle)
	{
    int iRet = 0;

	const HHSESSION hhSess = VerifySessionHandle(hSession);

	/* --- Reinitialize the X(trans)fer handle --- */
	if (InitializeXferHdl(hSession,
							sessQueryXferHdl(hSession)) != 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Reinitialize the Files and Directorys handle --- */
	if (InitializeFilesDirsHdl(hSession,
								sessQueryFilesDirsHdl(hSession)) != 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Reinitialize the Capture File handle --- */
	if (InitializeCaptureFileHandle(hSession,
							   sessQueryCaptureFileHdl(hSession)) != 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Init the connection handle --- */
    // NOTE: cnctInit() will return -4 if no modem has ever been installed
    // (lineInitialize() returns LINEERR_OPERATIONUNAVAIL) rev:08/05/99.
    //
    iRet = cnctInit(sessQueryCnctHdl(hSession));
	if (iRet != 0 && iRet != -4)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Init the com handle	--- */
	if (ComInitHdl(sessQueryComHdl(hSession)) != COM_OK)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Create a session data file handle --- */
	sfReleaseSessionFile(hhSess->hSysFile);
	hhSess->hSysFile = CreateSysFileHdl();

	if (hhSess->hSysFile == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Init the cloop handle --- */
	if (CLoopInitHdl(sessQueryCLoopHdl(hSession)) != 0)
		{
		assert(FALSE);
		return FALSE;
		}

	/* --- Reinitialize the Emulator handle --- */
	if (emuInitializeHdl(sessQueryEmuHdl(hSession)) != 0)
		{
		assert(FALSE);
		return FALSE;
		}

	// Home the cursor (different than doing set_curpos(0,0) and
	// erase the terminal screen.
	//
	emuHomeHostCursor(hhSess->hEmu);
	emuEraseTerminalScreen(hhSess->hEmu);

	/* --- Reinitialize the Print handle --- */
	if (printInitializeHdl(sessQueryPrintHdl(hSession)) != 0)
		{
		assert(FALSE);
		return FALSE;
		}

#if	defined(CHARACTER_TRANSLATION)
	if (InitTranslateHandle(sessQueryTranslateHdl(hSession), TRUE) != 0)
		{
		assert(FALSE);
		return FALSE;
		}
#endif

	/* --- Re-Create a Backscroll handle --- */

	// No backscrlInitialize() was written so for now do this...
	//
	backscrlFlush(hhSess->hBackscrl);

	/* --- Initialize the error message timeout value --- */

	// hhSess->nTimeout = 30;		// initialize to 30 seconds
	hhSess->nTimeout = 0;			// disable in Lower Wacker


	// Set default sound setting...
	//
	hhSess->fSound	  = FALSE;

	// Set default exit setting...
	//
	hhSess->fExit	  = FALSE;

	// Set the 'Allow remote initiated file transfers' feature
	//
	hhSess->fAllowHostXfers = FALSE;
	
	// Load program icon as session icon, load routine can overwrite this
	// to user defined icon.
	//
	sessInitializeIcons((HSESSION)hhSess);

	// Zap the command line
	//
	TCHAR_Fill(hhSess->achSessCmdLn,
				TEXT('\0'),
				sizeof(hhSess->achSessCmdLn) / sizeof(TCHAR));

	// Make this a new connection
	//
	hhSess->fIsNewSession = TRUE;

	TCHAR_Fill(hhSess->achSessName,
				TEXT('\0'),
				sizeof(hhSess->achSessName) / sizeof(TCHAR));
	TCHAR_Fill(hhSess->achOldSessName,
				TEXT('\0'),
				sizeof(hhSess->achOldSessName) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(),
				IDS_GNRL_NEW_CNCT,
				hhSess->achSessName,
				sizeof(hhSess->achSessName) / sizeof(TCHAR));

	StrCharCopyN(hhSess->achOldSessName, hhSess->achSessName, FNAME_LEN + 1);

	// Update the title - mrw:6/16/95
	//
    if (fUpdateTitle)
	    sessUpdateAppTitle(hSession);

	/* --- Force status line to update --- */

	PostMessage(hhSess->hwndStatusbar, SBR_NTFY_REFRESH,
		(WPARAM)SBR_MAX_PARTS, 0);

	// Refresh the terminal window - necessary - mrw:6/16/95
	//
	SendMessage(hhSess->hwndTerm, WM_SIZE, 0, 0);
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DestroySessionHandle
 *
 * DESCRIPTION:
 *	Destroys the session handle created by CreateSessionHandle.
 *
 * ARGUMENTS:
 *	hSession	- external session handle.
 *
 * RETURNS:
 *	void
 *
 */
void DestroySessionHandle(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	if (hhSess == 0)
		return;

	if (hhSess->hCLoop)
		CLoopDestroyHandle(&hhSess->hCLoop);

	if (hhSess->hUpdate)
		{
		updateDestroy(hhSess->hUpdate);
		hhSess->hUpdate = NULL; // REV 8/27/98
		}

	if (hhSess->hEmu)
		{
		emuDestroyHdl(hhSess->hEmu);
		hhSess->hEmu = NULL;
		}

	if (hhSess->hBackscrl)
		{
		backscrlDestroy(hhSess->hBackscrl);
		hhSess->hBackscrl = NULL;
		}

	if (hhSess->hXferHdl)
		{
		DestroyXferHdl((HXFER)hhSess->hXferHdl);
		hhSess->hXferHdl = NULL; // REV 8/27/98
		}

	if (hhSess->hFilesHdl)
		{
		DestroyFilesDirsHdl(sessQueryFilesDirsHdl(hSession));
		hhSess->hFilesHdl = NULL; // REV 8/27/98
		}

	if (hhSess->hSysFile)
		{
		sfCloseSessionFile(hhSess->hSysFile);
		hhSess->hSysFile = 0;
		}

	if (hhSess->hCnct)
		{
		cnctDestroyHdl(hhSess->hCnct);
		hhSess->hCnct = NULL;
		}

	// ComDestroy must follow cnctDestroy since cnctDestroy does
	// a port deactivate. - mrw
	//
	if (hhSess->hCom)
		ComDestroyHandle(&hhSess->hCom);

	if (hhSess->hCaptFile)
		{
		DestroyCaptureFileHandle(hhSess->hCaptFile);
		hhSess->hCaptFile = NULL;
		}

	if (hhSess->hPrint)
		{
		printDestroyHdl(hhSess->hPrint);
		hhSess->hPrint = NULL;
		}

#if	defined(CHARACTER_TRANSLATION)
	if (hhSess->hTranslate)
		{
		DestroyTranslateHandle(hhSess->hTranslate);
		hhSess->hTranslate = NULL;
		}
#endif

    //
    // Make sure to get rid of the TimerMux, otherwise
    // there is a memory leak. REV: 12/20/2000
    //
    if (hhSess->hTimerMux)
        {
        TimerMuxDestroy(&hhSess->hTimerMux, hSession);
        hhSess->hTimerMux = NULL;
        }

    //
    // Set the handle to the statusbar to NULL so we don't
    // access the destroyed status bar. REV: 12/20/2000
    //
    if (hhSess->hwndStatusbar)
        {
        hhSess->hwndStatusbar = NULL;
        }

	DeleteCriticalSection(&hhSess->csSess);
	DeleteCriticalSection(&hhSess->csTimerMux);
	free(hhSess);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	VerifySessionHandle
 *
 * DESCRIPTION:
 *	Every session function calls here to verify and get the internal handle.
 *	Saves having to type this chunk of code and takes less space than
 *	a macro.  We may want to add further checks to verify the handle.
 *
 *
 * ARGUMENTS:
 *	hSession		- external session handle
 *	fSynchronize	- if TRUE, we wait for mutex
 *
 * RETURNS:
 *	Internal session handle or zero.
 *
 */
HHSESSION VerifySessionHandle(const HSESSION hSession)
	{
	const HHSESSION hhSess = (HHSESSION)hSession;

	if (hSession == 0)
		{
		assert(FALSE);
		ExitProcess(1);
		}

	/* Above mentioned further checks, added by DLW */
	assert(hhSess->lPrefix == PRE_MAGIC);
	assert(hhSess->lPostfix == POST_MAGIC);

	return hhSess;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	hLock
 *
 * DESCRIPTION:
 *	Use the function to get ownership of the mutex semaphore for
 *	synchronized access.
 *
 * ARGUMENTS:
 *	hhSess	- internal session handle.
 *
 * RETURNS:
 *	void
 *
 */
void hLock(const HHSESSION hhSess)
	{
	if (hhSess == 0)
		{
		assert(FALSE);
		ExitProcess(1);
		}

	EnterCriticalSection(&hhSess->csSess);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	hUnlock
 *
 * DESCRIPTION:
 *	Releases the mutex semaphore
 *
 * ARGUMENTS:
 *	hhSess	- internal session handle
 *
 * RETURNS:
 *	void
 *
 */
void hUnlock(const HHSESSION hhSess)
	{
	if (hhSess == 0)
		{
		assert(FALSE);
		ExitProcess(1);
		}

	LeaveCriticalSection(&hhSess->csSess);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	hLockTimerMux
 *
 * DESCRIPTION:
 *	Use the function to get ownership of the mutex semaphore for
 *	synchronized access.
 *
 * ARGUMENTS:
 *	hhSess	- internal session handle.
 *
 * RETURNS:
 *	void
 *
 */
static void hLockTimerMux(const HHSESSION hhSess)
	{
	if (hhSess == 0)
		{
		assert(FALSE);
		ExitProcess(1);
		}

	EnterCriticalSection(&hhSess->csTimerMux);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	hUnlockTimerMux
 *
 * DESCRIPTION:
 *	Releases the mutex semaphore
 *
 * ARGUMENTS:
 *	hhSess	- internal session handle
 *
 * RETURNS:
 *	void
 *
 */
static void hUnlockTimerMux(const HHSESSION hhSess)
	{
	if (hhSess == 0)
		{
		assert(FALSE);
		ExitProcess(1);
		}

	LeaveCriticalSection(&hhSess->csTimerMux);
	return;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HWND sessQueryHwnd(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

    return hhSess->hwndSess;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HWND sessQueryHwndStatusbar(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hwndStatusbar;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HWND sessQueryHwndToolbar(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hwndToolbar;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HWND sessQueryHwndTerminal(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hwndTerm;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HUPDATE sessQueryUpdateHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hUpdate;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HTIMERMUX sessQueryTimerMux(const HSESSION hSession)
	{
	HTIMERMUX hTimerMux;
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hLockTimerMux(hhSess);
	hTimerMux = hhSess->hTimerMux;

    return hTimerMux;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

VOID sessReleaseTimerMux(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	hUnlockTimerMux(hhSess);

    return;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HCLOOP sessQueryCLoopHdl(const HSESSION hSession)
	{
	HCLOOP hCLoop;
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hLock(hhSess);
	hCLoop = hhSess->hCLoop;
	hUnlock(hhSess);

 	return hCLoop;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HCOM sessQueryComHdl(const HSESSION hSession)
	{
	HCOM hCom;
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hLock(hhSess);
	hCom = hhSess->hCom;
	hUnlock(hhSess);
    return hCom;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HEMU sessQueryEmuHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	return hhSess->hEmu;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HPRINT sessQueryPrintHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hPrint;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

void sessSetSysFileHdl(const HSESSION hSession, const SF_HANDLE hSF)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hLock(hhSess);
	hhSess->hSysFile = hSF;
	hUnlock(hhSess);
    return;
	}

SF_HANDLE sessQuerySysFileHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hSysFile;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HBACKSCRL sessQueryBackscrlHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hBackscrl;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HXFER sessQueryXferHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hXferHdl;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HFILES sessQueryFilesDirsHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hFilesHdl;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HCAPTUREFILE sessQueryCaptureFileHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hCaptFile;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

void sessQueryCmdLn(const HSESSION hSession, LPTSTR pach, const int len)
	{
	int i;
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	TCHAR *pachCmdLn = hhSess->achSessCmdLn;

	for (i = 0 ; i < len ; ++i)
		{
		if (*pachCmdLn == (TCHAR)0)
			break;

		// *pach++ = *pachCmdLn++;
		if (IsDBCSLeadByte(*pachCmdLn))
			{
			*(WORD *)pach = *(WORD *)pachCmdLn;
			}
		else
			{
			*pach = *pachCmdLn;
			}
		pach = StrCharNext(pach);
		pachCmdLn = StrCharNext(pachCmdLn);
		}

	return;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

int sessQueryTimeout(const HSESSION hSession)
	{
	int nTimeout;
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hLock(hhSess);
	nTimeout = hhSess->nTimeout;
	hUnlock(hhSess);

    return nTimeout;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

void sessSetTimeout(const HSESSION hSession, int nTimeout)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hLock(hhSess);
	hhSess->nTimeout = nTimeout;
	hUnlock(hhSess);
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

HCNCT sessQueryCnctHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hCnct;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

#if defined(INCL_WINSOCK)
int sessQueryTelnetPort(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->iTelnetPort;
	}
#endif


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

void sessQueryOldName(const HSESSION hSession, const LPTSTR pach, unsigned uSize)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	if (pach == 0)
		return;

	pach[0] = TEXT('\0');

	/* --- uSize is the number of BYTES in the buffer! ---- */

	uSize = min(uSize, sizeof(hhSess->achOldSessName));
    if (uSize)
        MemCopy(pach, hhSess->achOldSessName, uSize);
	pach[uSize-1] = TEXT('\0');
	return;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

void sessSetIconID(const HSESSION hSession, const int nID)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	if (hhSess->nIconId != nID)
		{
		hhSess->nIconId = nID;
		hhSess->hIcon = extLoadIcon(MAKEINTRESOURCE(nID));
		//hhSess->hIcon = LoadIcon(glblQueryDllHinst(), MAKEINTRESOURCE(nID));
		//hhSess->hLittleIcon = LoadIcon(glblQueryDllHinst(),
		//						  MAKEINTRESOURCE(nID + IDI_PROG_ICON_CNT));
		}
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
int sessQueryIconID(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->nIconId;
	}

HICON sessQueryIcon(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hIcon;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

void sessSetName(const HSESSION hSession, const LPTSTR pach)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	/* This is here to catch an overrun I can't reproduce. DLW */
#if !defined(NDEBUG)
	if (StrCharGetStrLength(pach) > 255)
		assert(FALSE);
#endif
	StrCharCopyN(hhSess->achSessName, pach, FNAME_LEN + 1);
	return;
	}


void sessQueryName(const HSESSION hSession, const LPTSTR pach, unsigned uSize)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	if (pach == 0 || uSize == 0)
		return;

	pach[0] = TEXT('\0');

	/* --- uSize is the number of BYTES in the buffer! ---- */

	uSize = min(uSize, sizeof(hhSess->achSessName));
    if (uSize)
        MemCopy(pach, hhSess->achSessName, uSize);
	pach[uSize-1] = TEXT('\0');
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

HTRANSLATE sessQueryTranslateHdl(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	
	if (hhSess)
		{
		return hhSess->hTranslate;
		}
	else
		{
		return NULL;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessQuerySound
 *
 * DESCRIPTION:
 *	Return the sound setting for the session.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *
 * RETURNS:
 *	fSound - the sound setting.
 */
int sessQuerySound(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return ((int)hhSess->fSound);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessSetSound
 *
 * DESCRIPTION:
 *	Set the sound setting for the session.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *
 * RETURNS:
 */
void sessSetSound(const HSESSION hSession, int fSound)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	hhSess->fSound = fSound;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessQueryExit
 *
 * DESCRIPTION:
 *	Return the exit setting for the session.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *
 * RETURNS:
 *	fExit - the exit setting.
 */
int sessQueryExit(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return ((int)hhSess->fExit);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessSetExit
 *
 * DESCRIPTION:
 *	Set the exit setting for the session.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *
 * RETURNS:
 */
void sessSetExit(const HSESSION hSession, int fExit)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	hhSess->fExit = fExit;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessSetIsNewSession
 *
 * DESCRIPTION:
 *  Set the fIsNewSession flag.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *  fIsNewSession - set appropriate session structure item to this value.
 *
 * RETURNS:
 */
void sessSetIsNewSession(const HSESSION hSession, int fIsNewSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	hhSess->fIsNewSession = fIsNewSession;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessQueryIsNewSession
 *
 * DESCRIPTION:
 *  Query the setting of fIsNewSession flag.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *
 * RETURNS:
 */
int sessQueryIsNewSession(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return ((int)hhSess->fIsNewSession);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessIsSessNameDefault
 *
 * DESCRIPTION:
 *  Checks to see if the session name is still the default session name
 *  or has the user provided us with a custom session name.
 *
 * ARGUMENTS:
 *  pacName - session file name.
 *
 * RETURNS:
 *
 */
BOOL sessIsSessNameDefault(LPTSTR pacName)
	{
	TCHAR ach[FNAME_LEN];

	if (pacName[0] == TEXT('\0'))
		return TRUE;

	TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
  	LoadString(glblQueryDllHinst(), IDS_GNRL_NEW_CNCT, ach,
		sizeof(ach) / sizeof(TCHAR));

	if (StrCharCmp(ach, pacName) == 0)
		return TRUE;

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessQueryWindowRect
 *
 * DESCRIPTION:
 *  Query the setting of the session window RECT.
 *
 * ARGUMENTS:
 *	hSession 	- the session handle.
 *  prc         - pointer to RECT.
 *
 * RETURNS:
 *	void.
 */
void sessQueryWindowRect(const HSESSION hSession, RECT *prc)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    *prc = hhSess->rcSess; // mrw:3/10/95

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessQueryWindowShowCmd
 *
 * DESCRIPTION:
 *  Query the setting of the session window show state.
 *
 * ARGUMENTS:
 *	hSession 	- the session handle.
 *
 * RETURNS:
 *	void.
 */
int sessQueryWindowShowCmd(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return ((int)hhSess->iShowCmd);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessQuerySidebarHwnd
 *
 * DESCRIPTION:
 *	Returns the sidebar window handle
 *
 * ARGUMENTS:
 *	hSession	- public session handle.
 *
 * RETURNS:
 *	Sidebar window handle.
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
HWND sessQuerySidebarHwnd(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return hhSess->hwndSidebar;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessQueryAllowHostXfers
 *
 * DESCRIPTION:
 *	Return the exit setting for the session.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *
 * RETURNS:
 *	fAllowHostXfers - the exit setting.
 */
BOOL sessQueryAllowHostXfers(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
    return ((BOOL)hhSess->fAllowHostXfers);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessSetAllowHostXfers
 *
 * DESCRIPTION:
 *	Set the exit setting for the session.
 *
 * ARGUMENTS:
 *	hSession        - the session handle.
 *  fAllowHostXfers - the Allow Host Transfer flag.
 *
 * RETURNS:
 */
void sessSetAllowHostXfers(const HSESSION hSession, BOOL fAllowHostXfers)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	hhSess->fAllowHostXfers = fAllowHostXfers;
	return;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sessutil.c ===
/*	File: D:\WACKER\tdll\sessutil.c (Created: 30-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 7/08/02 6:48p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>

#include "features.h"

#include "stdtyp.h"
#include "sf.h"
#include "mc.h"
#include "term.h"
#include "cnct.h"
#include "print.h"
#include "assert.h"
#include "capture.h"
#include "globals.h"
#include "sess_ids.h"
#include "load_res.h"
#include "open_msc.h"
#include "xfer_msc.h"
#include "file_msc.h"
#include "backscrl.h"
#include "cloop.h"
#include "com.h"
#include <term\res.h>
#include "session.h"
#include "session.hh"
#include "errorbox.h"
#include <emu\emu.h>
#include "tdll.h"
#include "htchar.h"
#include "misc.h"
#ifdef INCL_NAG_SCREEN
#include "nagdlg.h"
#endif

STATIC_FUNC void sessPreventOverlap(const HSESSION hSession, BOOL fIsToolbar);
STATIC_FUNC int sessCountMenuLines(HWND hwnd);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSnapToTermWindow
 *
 * DESCRIPTION:
 *	Sizes the session window so that the terminal is full size (usually
 *	80 x 24).
 *
 * ARGUMENTS:
 *	hwnd	- session window handle
 *
 * RETURNS:
 *	void
 *
 */
void sessSnapToTermWindow(const HWND hwnd)
	{
	RECT rc;
	RECT rc2;
	LONG lw;
	LONG lh;
	LONG l2w;
	LONG l2h;
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	/* --- Doesn't make much sense to snap when we're maximized - mrw --- */

	if (IsZoomed(hwnd))
		return;

	if (sessComputeSnapSize(hSession, &rc))
		{
		// Make sure we don't go beyond size of screen
		// mrw,1/20/95
		//
		if (SystemParametersInfo(SPI_GETWORKAREA, sizeof(LPRECT), &rc2, 0))
			{
			lw = rc.right - rc.left;
			lh = rc.bottom - rc.top;

			l2w = rc2.right - rc2.left;
			l2h = rc2.bottom - rc2.top;

			GetWindowRect(hwnd, &rc);

			// When we first start-up we move the window off screen.
			// If we're off screen, we don't do any screen bounds
			// checking.
			//
			if (rc.top > rc2.bottom)
				{
				SetWindowPos(hwnd, 0, 0, 0, lw, lh, SWP_NOMOVE);
				}

			else
				{
				// Calculate new size in desktop coordinates.
				//
				rc.right = rc.left + lw;
				rc.bottom = rc.top + lh;

				// Check if too wide
				//
				if (lw > l2w)
					{
					rc.left = rc2.left;
					rc.right = rc2.right;
					}

				// Check if to high
				//
				if (lh > l2h)
					{
					rc.top = rc2.top;
					rc.bottom = rc2.bottom;
					}

				// Check if we're off to the right
				//
				if (rc.right > rc2.right)
					{
					lw = rc.right - rc2.right;
					rc.right -= lw;
					rc.left  -= lw;
					}

				// Check if we're off the bottom
				//
				if (rc.bottom > rc2.bottom)
					{
					lh = rc.bottom - rc2.bottom;
					rc.bottom -= lh;
					rc.top -= lh;
					}

				SetWindowPos(hwnd, 0, rc.left, rc.top,
					 rc.right-rc.left, rc.bottom-rc.top, 0);
				}
			}
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSetMinMaxInfo
 *
 * DESCRIPTION:
 *	Calculates the max horizontal size for the session and sets that
 *	value in the mmi structure.  If the window is being maximized, then
 *	we just return.  Later, we'll have flags to control autosnapping so
 *	this function will change.	Also some minimum tracking size is set.
 *
 * ARGUMENTS:
 *	hSession	- public session handle.
 *	pmmi		- pointer to MINMAXINFO structure
 *
 * RETURNS:
 *	void
 *
 */
void sessSetMinMaxInfo(const HSESSION hSession, const PMINMAXINFO pmmi)
	{
	RECT 				rc;
	HWND 				hwndStatusbar, hwndToolbar,  hwndSess;
	NONCLIENTMETRICS 	stNCM;
	int					i, iLineCnt = 0;

	/* --- Believe it or not, this gets called before WM_CREATE --- */

	if (hSession == (HSESSION)0)
		return;

	hwndSess = sessQueryHwnd(hSession);

	if (IsZoomed(hwndSess))
		return;

	#if 0	// removed on a trial basis - mrw
	if (sessComputeSnapSize(hSession, &rc))
		pmmi->ptMaxTrackSize.x = (rc.right - rc.left);
	#endif

	/* --- Set the minimum height for the session --- */

	memset(&rc, 0, sizeof(RECT));
	hwndStatusbar = sessQueryHwndStatusbar(hSession);

	if (IsWindow(hwndStatusbar) && IsWindowVisible(hwndStatusbar))
		{
		GetWindowRect(hwndStatusbar, &rc);
		pmmi->ptMinTrackSize.y += (rc.bottom - rc.top);
		}

	memset(&rc, 0, sizeof(RECT));
	hwndToolbar = sessQueryHwndToolbar(hSession);

	if (IsWindow(hwndToolbar) && IsWindowVisible(hwndToolbar))
		{
		GetWindowRect(hwndToolbar, &rc);
		pmmi->ptMinTrackSize.y += (rc.bottom - rc.top);
		}

	// Menus take up at least one iMenuHeight...
	//
	stNCM.cbSize = sizeof(NONCLIENTMETRICS);

	if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS,
			sizeof(NONCLIENTMETRICS), &stNCM, 0) == TRUE)
		{
		pmmi->ptMinTrackSize.y += (stNCM.iMenuHeight - 1);

		// And if they take up more than that then adjust for it.
		//
		iLineCnt = sessCountMenuLines(hwndSess);

		for (i = 1; i < iLineCnt; i++)
			pmmi->ptMinTrackSize.y += (stNCM.iMenuHeight);

		DbgOutStr("%i, %i ", stNCM.iMenuHeight, iLineCnt, 0, 0, 0);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessCountMenuLines
 *
 * DESCRIPTION:
 *	Counts the lines a menu associated with a window is taking up.
 *
 * ARGUMENTS:
 *  hwnd - the window handle.
 *
 * RETURNS:
 *	How many lines a menu is taking up.
 *
 */
STATIC_FUNC int sessCountMenuLines(HWND hwnd)
	{
	int 	i, iLineCnt = 0, iRemembered = 0;
	HMENU 	hMenu;
	RECT	rc;

	hMenu = GetMenu(hwnd);
	memset(&rc, 0, sizeof(RECT));

	for (i = 0; i < GetMenuItemCount(hMenu); i++)
		{
		GetMenuItemRect(hwnd, hMenu, (UINT)i, &rc);
		if ((int)rc.bottom > iRemembered)
			{
			iRemembered = (int)rc.bottom;
			iLineCnt++;
			}
		}
	return (iLineCnt);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessComputeSnapSize
 *
 * DESCRIPTION:
 *	Computes the minimum size of the session window that will display
 *	the entire terminal screen.
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *	prc 		- pointer to rectangle that contains minimum size
 *
 * RETURNS:
 *	TRUE if success, FALSE contains worthless data
 *
 */
BOOL sessComputeSnapSize(const HSESSION hSession, const LPRECT prc)
	{
	RECT rcTmp;
	const HWND hwndTerm = sessQueryHwndTerminal(hSession);
	const HWND hwndToolbar = sessQueryHwndToolbar(hSession);
	const HWND hwndStatusbar = sessQueryHwndStatusbar(hSession);
	const HWND hwndSidebar = sessQuerySidebarHwnd(hSession);

	if (IsWindow(hwndTerm) == FALSE)
		return FALSE;

	/* --- Ask terminal for it's snapped size --- */

	SendMessage(hwndTerm, WM_TERM_Q_SNAP, 0, (LPARAM)prc);

	/* --- Compute the client window height --- */

	if (IsWindow(hwndToolbar) && sessQueryToolbarVisible(hSession))
		{
		GetWindowRect(hwndToolbar, &rcTmp);
		prc->top -= (rcTmp.bottom - rcTmp.top);
		}

	if (IsWindow(hwndStatusbar) && sessQueryStatusbarVisible(hSession))
		{
		GetWindowRect(hwndStatusbar, &rcTmp);
		prc->bottom += (rcTmp.bottom - rcTmp.top);
		}

	if (IsWindow(hwndSidebar) && IsWindowVisible(hwndSidebar))
		{
		GetWindowRect(hwndSidebar, &rcTmp);
		prc->right += (rcTmp.right - rcTmp.left);
		}

	/* --- Compute the necessary frame size --- */

	if (AdjustWindowRectEx(prc, WS_OVERLAPPEDWINDOW, TRUE, WS_EX_WINDOWEDGE))
		return TRUE;

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NotifyClient
 *
 * DESCRIPTION:
 *	Called from the engine thread primarily, this function notifies the
 *	main thread of some event in the engine, such as new data for the
 *	terminal to display.
 *
 * ARGUMENTS:
 *	hSession	- external session handle
 *	nEvent		- event that occured
 *	lExtra		- extra data to pass
 *
 * RETURNS:
 *	void
 *
 */
void NotifyClient(const HSESSION hSession, const NOTIFICATION nEvent,
				  const long lExtra)
	{
	const HHSESSION hhSess = (HHSESSION)hSession;
	PostMessage(hhSess->hwndSess, WM_SESS_NOTIFY, (WPARAM)nEvent, lExtra);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void  sessInitializeIcons(HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	hhSess->nIconId = IDI_PROG;
	hhSess->hIcon = extLoadIcon(MAKEINTRESOURCE(IDI_PROG));
	//hhSess->hIcon = LoadIcon(glblQueryDllHinst(),
	//						  MAKEINTRESOURCE(IDI_PROG));
	//hhSess->hLittleIcon = LoadIcon(glblQueryDllHinst(),
	//						  MAKEINTRESOURCE(IDI_PROG + IDI_PROG_ICON_CNT));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void  sessLoadIcons(HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	long lSize;

	lSize = sizeof(hhSess->nIconId);

	sfGetSessionItem(hhSess->hSysFile, SFID_ICON_DEFAULT, &lSize,
		&hhSess->nIconId);

	hhSess->hIcon = extLoadIcon(MAKEINTRESOURCE(hhSess->nIconId));
	//hhSess->hIcon = LoadIcon(glblQueryDllHinst(),
	//						  MAKEINTRESOURCE(hhSess->nIconId));
	//hhSess->hLittleIcon = LoadIcon(glblQueryDllHinst(),
	//						  MAKEINTRESOURCE(hhSess->nIconId+IDI_PROG_ICON_CNT));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void  sessSaveIcons(HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	sfPutSessionItem(hhSess->hSysFile, SFID_ICON_DEFAULT,
		sizeof(hhSess->nIconId), &hhSess->nIconId);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSetSuspend
 *
 * DESCRIPTION:
 *	We need to block the flow of data going into the emulators which is
 *	done by suspending the CLoop.  Suspending is done for several reasons.
 *	User presses the scroll lock key.  User has pressed left mouse button
 *	down in preparation for marking (note: user could just let up mouse
 *	without marking so its a separate reason).	User is marking or has
 *	marked text.
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *	iReason 	- which event has called this routine
 *
 * RETURNS:
 *	void
 *
 */
void sessSetSuspend(const HSESSION hSession, const int iReason)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);

	switch (iReason)
		{
	case SUSPEND_SCRLCK:
		hhSession->fSuspendScrlLck = TRUE;
		break;

	case SUSPEND_TERMINAL_MARKING:
		hhSession->fSuspendTermMarking = TRUE;
		break;

	case SUSPEND_TERMINAL_LBTNDN:
		hhSession->fSuspendTermLBtnDn = TRUE;
		break;

	case SUSPEND_TERMINAL_COPY:
		hhSession->fSuspendTermCopy = TRUE;
		break;

	default:
		assert(FALSE);
		return;
		}

	CLoopRcvControl(sessQueryCLoopHdl(hSession), CLOOP_SUSPEND,
		CLOOP_RB_SCRLOCK);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessClearSuspend
 *
 * DESCRIPTION:
 *	Clearing suspends is essentially the opposite of setting execept that
 *	we do not resume cloop processing until all flags are FALSE.  Sets
 *	and clears are not cumulative which is what I first wanted to do but
 *	particularly in the area's of scroll lock keys and text marking the
 *	events are not always toggled (ie. might get many marks but only one
 *	unmark).  Also, event can be easily added although none come to mind.
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *	iReason 	- which event has called this routine
 *
 * RETURNS:
 *	void
 *
 */
void sessClearSuspend(const HSESSION hSession, const int iReason)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);

	switch (iReason)
		{
	case SUSPEND_SCRLCK:
		hhSession->fSuspendScrlLck = FALSE;
		break;

	case SUSPEND_TERMINAL_MARKING:
		hhSession->fSuspendTermMarking = FALSE;
		break;

	case SUSPEND_TERMINAL_LBTNDN:
		hhSession->fSuspendTermLBtnDn = FALSE;
		break;

	case SUSPEND_TERMINAL_COPY:
		hhSession->fSuspendTermCopy = FALSE;
		break;

	default:
		assert(FALSE);
		return;
		}

	if (!hhSession->fSuspendScrlLck && !hhSession->fSuspendTermMarking
			&& !hhSession->fSuspendTermLBtnDn && !hhSession->fSuspendTermCopy)
		{
		CLoopRcvControl(sessQueryCLoopHdl(hSession), CLOOP_RESUME,
			CLOOP_RB_SCRLOCK);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	IsSessionSuspended
 *
 * DESCRIPTION:
 *	Checks if the session is suspended.  Suspends occur
 *	whenever the user is marking text, holds the mouse button down, or
 *	presses the scroll lock key.
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *
 * RETURNS:
 *	TRUE if were suspended.
 *
 */
BOOL IsSessionSuspended(const HSESSION hSession)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	return (hhSess->fSuspendScrlLck || hhSess->fSuspendTermMarking ||
			hhSess->fSuspendTermLBtnDn || hhSess->fSuspendTermCopy);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessQueryToolbarVisible
 *
 * DESCRIPTION:
 *	This function returns the expected visibility state of the Toolbar.
 *
 * ARGUMENTS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	The expected visibility state of the Toolbar.
 *
 */
BOOL sessQueryToolbarVisible(const HSESSION hSession)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);
	return hhSession->fToolbarVisible;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSetToolbarVisible
 *
 * DESCRIPTION:
 *	This function changes the expected visibility state of the Toolbar.
 *	It does not change the actual visibility of the Toolbar.
 *
 * ARGUMENTS:
 *	hSession -- the session handle
 *	fVisible -- indicates visibility as TRUE or FALSE
 *
 * RETURNS:
 *	The previous visibility state of the Toolbar.
 *
 */
BOOL sessSetToolbarVisible(const HSESSION hSession, const BOOL fVisible)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);
	BOOL 			bRet = TRUE;

	bRet = hhSession->fToolbarVisible;
	hhSession->fToolbarVisible = (fVisible != FALSE);

	if (fVisible)
		sessPreventOverlap(hSession, TRUE);

	ShowWindow(hhSession->hwndToolbar, (fVisible) ? SW_SHOW : SW_HIDE);
	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessQueryStatusbarVisible
 *
 * DESCRIPTION:
 *	This function returns the expected visibility state of the Statusbar.
 *
 * ARGUMENTS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	The expected visibility state of the Statusbar.
 *
 */
BOOL sessQueryStatusbarVisible(const HSESSION hSession)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);
	return hhSession->fStatusbarVisible;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSetStatusbarVisible
 *
 * DESCRIPTION:
 *	This function changes the expected visibility state of the Statusbar.
 *	It does not change the actual visibility of the Statusbar.
 *
 * ARGUMENTS:
 *	hSession -- the session handle
 *	fVisible -- indicates visibility as TRUE or FALSE
 *
 * RETURNS:
 *	The previous visibility state of the Statusbar.
 *
 */
BOOL sessSetStatusbarVisible(const HSESSION hSession, const BOOL fVisible)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);
	BOOL 			bRet = TRUE;

	bRet = hhSession->fStatusbarVisible;
	hhSession->fStatusbarVisible = (fVisible != FALSE);

	if (fVisible)
		sessPreventOverlap(hSession, FALSE);

	ShowWindow(hhSession->hwndStatusbar, (fVisible) ? SW_SHOW : SW_HIDE);
	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessCmdLnDial
 *
 * DESCRIPTION:
 *	Everytime we open a session, we call this function to attempt to
 *	dial.
 *
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *
 * RETURNS:
 *	void
 *
 */
void sessCmdLnDial(const HSESSION hSession)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);

	switch (hhSession->iCmdLnDial)
		{
	case CMDLN_DIAL_DIAL:
		cnctConnect(sessQueryCnctHdl(hSession), 0);
		break;

	case CMDLN_DIAL_NEW:
		cnctConnect(sessQueryCnctHdl(hSession), CNCT_NEW);
		break;

	case CMDLN_DIAL_WINSOCK:
		cnctConnect(sessQueryCnctHdl(hSession), CNCT_WINSOCK);
		break;

	case CMDLN_DIAL_OPEN:
	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessUpdateAppTitle
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *  hwnd - app window.
 *
 * RETURNS:
 *  void.
 *
 */
void sessUpdateAppTitle(const HSESSION hSession)
	{
	HWND	hwnd = sessQueryHwnd(hSession);
	TCHAR	acTitle[256], acName[256], acNewTitle[256];
#ifdef INCL_NAG_SCREEN
	TCHAR   acUnregistered[256];
#endif
	LPTSTR	pNewTitle;
	int 	iSize;
	TCHAR	*pszSeperator = TEXT(" - ");
    BOOL    bEval = FALSE;

	TCHAR_Fill(acNewTitle, TEXT('\0'), sizeof(acNewTitle) / sizeof(TCHAR));
	TCHAR_Fill(acTitle, TEXT('\0'), sizeof(acTitle) / sizeof(TCHAR));

	sessQueryName(hSession, acName, sizeof(acName));
	if (sessIsSessNameDefault(acName))
		{
		LoadString(glblQueryDllHinst(), IDS_GNRL_NEW_CNCT, acName,
			sizeof(acName) / sizeof(TCHAR));
		}
 	StrCharCopyN(acNewTitle, acName, sizeof(acTitle) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, acTitle,
		sizeof(acTitle) / sizeof(TCHAR));

#ifdef INCL_NAG_SCREEN
    if ( IsEval() )
        {
        bEval = TRUE;
        LoadString(glblQueryDllHinst(), IDS_GNRL_UNREGISTERED, acUnregistered,
		    sizeof(acUnregistered) / sizeof(TCHAR));
        }
#endif

    iSize =  StrCharGetByteCount(acNewTitle);
	iSize += StrCharGetByteCount(pszSeperator);
	iSize += StrCharGetByteCount(acTitle);
#ifdef INCL_NAG_SCREEN
    if ( bEval )
        {
        iSize += StrCharGetByteCount(acUnregistered);
        }
#endif
	iSize += sizeof(TCHAR);

	pNewTitle = malloc(iSize);

	if (pNewTitle)
		{
		StrCharCopyN(pNewTitle, acNewTitle, iSize);
		StrCharCat(pNewTitle, pszSeperator);
		StrCharCat(pNewTitle, acTitle);
#ifdef INCL_NAG_SCREEN
        if ( bEval )
            {
            StrCharCat(pNewTitle, acUnregistered);
            }
#endif
		SetWindowText(hwnd, pNewTitle);

		free(pNewTitle);
		pNewTitle = NULL;
		}
	else
		{
		SetWindowText(hwnd, acNewTitle);
		}

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessDisconnectToContinue
 *
 * DESCRIPTION:
 *	If connecterd, ask the user if he wants to disconnect and continue with
 *  whatever he set out to perform, such as close the app, open a new session,
 *	create a new connection, etc.
 *
 * ARGUMENTS:
 *  hSession 	- the Session handle.
 *  hwnd		- the session window.
 *
 * RETURNS:
 *  TRUE 	- if the user wants to disconnect and go on with his request.
 *	FALSE 	- if he changes his mind.
 *
 */
BOOL sessDisconnectToContinue(const HSESSION hSession, HWND hwnd)
	{
	HCNCT	hCnct = (HCNCT)0;
	int		iRet = 0;
	TCHAR	ach[256], achTitle[100];

	hCnct = sessQueryCnctHdl(hSession);
	if (hCnct)
		iRet = cnctQueryStatus(hCnct);

	if (iRet == CNCT_STATUS_TRUE)
		{
		LoadString(glblQueryDllHinst(), IDS_GNRL_CNFRM_DCNCT,
			ach, sizeof(ach) / sizeof(TCHAR));

		LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, achTitle,
			sizeof(achTitle) / sizeof(TCHAR));

		if ((iRet = TimedMessageBox(hwnd, ach, achTitle,
			MB_YESNO | MB_ICONEXCLAMATION, 0)) == IDYES)
			{
            if (SendMessageTimeout(hwnd, WM_COMMAND, IDM_ACTIONS_HANGUP, 0L,
                                   SMTO_ABORTIFHUNG, 1000, NULL) == 0)
                {
                PostMessage(hwnd, WM_COMMAND, IDM_ACTIONS_HANGUP, 0L);
                }
			}
		else
			return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessSizeAndShow
 *
 * DESCRIPTION:
 *	Called only once from the InitInstance() this function will size
 *	the window via snap and insure it lands on the desktop.  This
 *	function is called via a posted message because it was found that
 *	the session was not fully initialized after returning from the
 *	CreateWindow call.
 *
 * ARGUMENTS:
 *  hwnd		- session window.
 *	nCmdShow	- Show command passed from WinMain()
 *
 * RETURNS:
 *	void
 *
 */
void sessSizeAndShow(const HWND hwnd, const int nCmdShow)
	{
	HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	const HWND hwndBanner = glblQueryHwndBanner();
	WINDOWPLACEMENT stWP;
	RECT	 rc, rc2, rc3;
	int 	 cx, cy;
	int 	 xWA, yWA, cxWA, cyWA;
	int		 iWidth = 0, iHeight = 0;

	// Size session window...
	//
	if (!sessQueryIsNewSession(hSession))
		{
		// Size and position the session window according to the
		// remembered values, if no values were remembered, i.e., an old
		// session, then treat it as a default session.
		//
		memset(&rc, 0, sizeof(RECT));
		sessQueryWindowRect(hSession, &rc);

		iWidth  = rc.right - rc.left;
		iHeight = rc.bottom - rc.top;

		if (iWidth != 0 && iHeight != 0)
			{
			stWP.length  = sizeof(WINDOWPLACEMENT);
			stWP.flags	 = 0;
			stWP.showCmd = (UINT)sessQueryWindowShowCmd(hSession);
			memmove(&stWP.rcNormalPosition, &rc, sizeof(RECT));

			SetWindowPlacement(hwnd, &stWP);
			UpdateWindow(hwnd);

			if (IsWindow(hwndBanner))
				PostMessage(hwndBanner, WM_CLOSE, 0, 0);

			return;
			}
		}

	// Well, were back to our windows tricks.  The toolbar height
	// has changed with the introduction of the larger bitmaps (from
	// 16x16 to 22x24).  On program startup, the toolbar window reports
	// a default size which is not the correct size since the new bitmaps
	// will force it to be larger.	This doesn't happen however, until
	// the window is displayed.  So we display the window off screen,
	// do the resizing, then move it back on screen.

	GetWindowRect(hwnd, &rc);
	SetWindowPos(hwnd, 0, 20000, 20000, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);

	// Size to terminal window for a default session, i.e., the user
	// did not specify a session name on the command line.
	//
	sessSnapToTermWindow(hwnd);

	// Get new window size but keep original origin
	//
	GetWindowRect(hwnd, &rc2);
	rc.right = rc.left + (rc2.right - rc2.left);
	rc.bottom = rc.top + (rc2.bottom - rc2.top);

	// Until the SPI parameters are defined
	//
	if (SystemParametersInfo(SPI_GETWORKAREA, sizeof(LPRECT), &rc3, 0) == TRUE)
		{
		xWA = rc3.left;
		yWA = rc3.top;
		cxWA = rc3.right - rc3.left;
		cyWA = rc3.bottom - rc3.top;
		}

	else
		{
		xWA = 0;
		yWA = 0;
		cxWA = GetSystemMetrics(SM_CXSCREEN);
		cyWA = GetSystemMetrics(SM_CYSCREEN);
		}

	cx = rc.left;
	cy = rc.top;

	if (rc.right > (xWA + cxWA))
		cx = max(xWA, rc.left - (rc.right - (xWA + cxWA)));

	if (rc.bottom > (yWA + cyWA))
		cy = max(yWA, rc.top - (rc.bottom - (yWA + cyWA)));

	// Move window back to either its original or adjusted position.
	//
	SetWindowPos(hwnd, 0, cx, cy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	UpdateWindow(hwnd);

	if (IsWindow(hwndBanner))
		PostMessage(hwndBanner, WM_CLOSE, 0, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sessPreventOverlap
 *
 * DESCRIPTION:
 *	The main purpose for existance of this function is to prevent the toolbar
 *	window and the status window overlapping each other.  That is accomplished
 *	by sizing the session window to be big enough to display both of the
 *	windows comfortably.
 *
 * ARGUMENTS:
 *  hSession 	- the session handle.
 *	fIsToolbar 	- TRUE if we showing the toolbar window, FALSE otherwise.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sessPreventOverlap(const HSESSION hSession, BOOL fIsToolbar)
	{
	const HHSESSION hhSession = VerifySessionHandle(hSession);
	RECT			rcSess, rcTool, rcStat;

	if ((fIsToolbar) ? hhSession->fStatusbarVisible :
					   hhSession->fToolbarVisible)
		{
		GetWindowRect(hhSession->hwndSess, &rcSess);
		GetWindowRect(hhSession->hwndToolbar, &rcTool);
		GetWindowRect(hhSession->hwndStatusbar, &rcStat);

		if (rcTool.bottom > rcStat.top)
			{
			SetWindowPos(hhSession->hwndSess, 0,
				0, 0, rcSess.right - rcSess.left,
				(rcSess.bottom - rcSess.top) + (rcTool.bottom - rcStat.top),
				SWP_NOMOVE | SWP_NOZORDER);
			}
		}
	}

#if defined(DEADWOOD)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoBeeper
 *
 * DESCRIPTION:
 *	Produces three audible beeps in sequence
 *
 * ARGUMENTS:
 *	dw	- required by CreateThread()
 *
 * RETURNS:
 *	DWORD	- required by CreateThread
 *
 */
DWORD WINAPI DoBeeper(DWORD dw)
 	{
    //mpt:06-04-98 changed to use windows sounds
    MessageBeep(MB_ICONEXCLAMATION);
#if 0
    int i;

	for (i = 0 ; i < 3 ; ++i)
		{
		MessageBeep((unsigned)-1);
		Sleep(300);
		}
#endif
	return 0;
	}
#endif // defined(DEADWOOD)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sessBeeper
 *
 * DESCRIPTION:
 *	Launches thread to do beeps if session setting is on.  Seems silly
 *	to launch a thread to do something like this but it really is the
 *	simplist and most direct way. - mrw
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *
 * RETURNS:
 *	void
 *
 */
void sessBeeper(const HSESSION hSession)
	{
	if (sessQuerySound(hSession))
		{
		#if defined(DEADWOOD)
		DWORD dwID;

		if (CreateThread(0, 100, (LPTHREAD_START_ROUTINE)DoBeeper, 0, 0,
				&dwID) == 0)
		#else // defined(DEADWOOD)
		if(mscMessageBeep(MB_ICONEXCLAMATION) == FALSE)
		#endif // defined(DEADWOOD)
			{
			DbgShowLastError();
			}
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\session.hh ===
/*	File: D:\WACKER\tdll\session.hh (Created: 01-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 5/29/02 2:17p $
 */

#if !defined(FEATURES_H_INCLUDED)
You really need to include the "features.h" file before "session.hh"
#endif

typedef struct stSessionData *HHSESSION;

/* --- Data Structures --- */

struct stSessionData
	{
	long				lPrefix;			// used to verify session handle

	HWND				hwndSess;			// handle of session window
	HWND				hwndStatusbar;		// handle of statusbar window
	HWND				hwndToolbar;		// handle of toolbar window
	HWND				hwndTerm;			// handle of terminal window
	HWND				hwndSidebar;		// handle of sidebar window

	CRITICAL_SECTION	csSess;				// for snychronizing access
	CRITICAL_SECTION    csTimerMux;         // for synchronizing access to the Timer Mux

	HTIMERMUX			hTimerMux;			// handle to multiplexed timers
	HUPDATE 			hUpdate;			// update info from emulator.
	HEMU				hEmu;				// emulator handle.
	HCOM				hCom;				// handle to internal com driver
	HCLOOP				hCLoop; 			// handle to com loop
	HCNCT				hCnct;				// handle to connection driver
	SF_HANDLE			hSysFile;			// system file handle
	HXFER				hXferHdl;			// transfer parameters
	HFILES				hFilesHdl;			// files and directory stuff
	HBACKSCRL			hBackscrl;			// backscroll handle
	HCAPTUREFILE		hCaptFile; 			// capture file handle
	HPRINT				hPrint; 			// print handle
	HTRANSLATE			hTranslate; 		// character translation handle, mrw,3/1/95

	int 				nTimeout;			// timeout value for error messages

	TCHAR				achSessCmdLn[FNAME_LEN + 1];	// passed in last parameter of CreateWindow()

	BOOL				fToolbarVisible;	// is the toolbar visible ?
	BOOL				fStatusbarVisible;	// is the statusbar visible ?

	// Suspend variables used to "scroll lock" sessions
	//
	BOOL				fSuspendScrlLck,
						fSuspendTermMarking,
						fSuspendTermLBtnDn,
						fSuspendTermCopy;

	BOOL				fSound;				// Turn on/off annoying sounds
	BOOL				fExit;				// Turn on/off exit upon disconnecting

	int					nIconId;			// resource ID for selected ICON, if any.
	HICON				hIcon;				// session icon, defaults to program icon.
  //HICON				hLittleIcon;		// small copy of previous icon, if available

	// Yes, we do need to keep the session name shadow!
	//
	TCHAR				achSessName[FNAME_LEN + 1];		// name of session.
	TCHAR				achOldSessName[FNAME_LEN + 1];	// shadow of the session name.

	BOOL				fIsNewSession;		// TRUE if new session being created.

	int 				iCmdLnDial; 		// Used to see how to dial
#if defined(INCL_WINSOCK)
	int					iTelnetPort;		// To pass value entered as cmd ln URL
#endif

	long				lPostfix;			// used to verify session handle
											// keep this the last item, please

	RECT				rcSess;				// Session window's rect.
	int					iShowCmd;			// Session window's show state.
	BOOL				fAllowHostXfers;	// Turn on/off the 'Allow host initiated file transfers' feature
	};

#define	PRE_MAGIC		0x12345678
#define	POST_MAGIC		0x09ABCDEF

/* --- Function Prototypes --- */

HHSESSION VerifySessionHandle(const HSESSION hSession);
void hLock(const HHSESSION hhSess);
void hUnLock(const HHSESSION hhSess);
static void hLockTimerMux(const HHSESSION hhSess);
static void hUnlockTimerMux(const HHSESSION hhSess);
int sessInitializePrinterName(const HSESSION hSession);
int sessCheckAndLoadCmdLn(const HSESSION hSession);
int fTestOpenOldTrmFile(const HHSESSION hhSess, TCHAR *achName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sessproc.c ===
/*
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 24 $
 *	$Date: 7/12/02 12:42p $
 */
// #define	DEBUGSTR	1

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <time.h>

#include "stdtyp.h"
#include "assert.h"
#include "globals.h"
#include "session.h"
#include "session.hh"
#include "term.h"
#include "print.h"
#include "cnct.h"
#include "misc.h"
#include "banner.h"
#include "file_msc.h"
#include "errorbox.h"
#include "load_res.h"
#include "sf.h"

#include "cloop.h"
#include "com.h"
#include "timers.h"
#include "capture.h"
#include "xfer_msc.h"
#include <xfer\xfer.h>
#include <term\res.h>
#include <emu\emu.h>
#include <emu\emudlgs.h>
#include "property.h"
#include "htchar.h"
#include "backscrl.h"
//mpt:08-22-97 added HTML help
#if defined(INCL_USE_HTML_HELP)
#include <htmlhelp.h>
#endif

#include "tdll.h"
#include "hlptable.h"
#include "statusbr.h"
//*jcm
#include "open_msc.h"
#include "mc.h"
//*end of jcm

#if defined(TESTMENU) && !defined(NDEBUG)
#include <cncttapi\cncttapi.h>
#endif

#ifdef INCL_KEY_MACROS
    #include "keyutil.h"
#endif

#ifdef INCL_NAG_SCREEN
    #include "nagdlg.h"
    #include "register.h"
#endif

STATIC_FUNC void 	SP_WM_SIZE(const HWND hwnd, const unsigned fwSizeType,
					       	   const int iWidth, const int iHite);

STATIC_FUNC void 	SP_WM_CREATE(const HWND hwnd, const CREATESTRUCT *pcs);
STATIC_FUNC void 	SP_WM_DESTROY(const HWND hwnd);

STATIC_FUNC LRESULT SP_WM_CMD(const HWND hwnd, const int nId,
							  const int nNotify, const HWND hwndCtrl);

STATIC_FUNC void 	SP_WM_INITMENUPOPUP(const HWND hwnd, const HMENU hMenu,
										const UINT uPos, const BOOL fSysMenu);

STATIC_FUNC void 	SP_WM_CONTEXTMENU(const HWND hwnd);
STATIC_FUNC BOOL 	SP_WM_CLOSE(const HWND hwnd);
STATIC_FUNC int 	CheckOpenFile(const HSESSION hSession, ATOM aFile);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SessProc
 *
 * DESCRIPTION:
 *	Main window proc for term
 *
 */
LRESULT CALLBACK SessProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	HSESSION hSession;
#if defined(INCL_USE_HTML_HELP)
	TCHAR achHtmlFilename[100];
#endif

	switch (uMsg)
		{
		// User pressed F1 key over the session window.
		// We also get this message from child windows if they do not process
		// it themselves.
		//
		case WM_HELP:
//#if 0 //mpt:3-10-98 for some reason, using this call causes an access violation
	    //            in HyperTrm.dll. Using the winhelp call gives us the same results.
        //mpt:4-30-98 Re-enabled for the NT folks - go figure
#if defined(INCL_USE_HTML_HELP)
		  	LoadString(glblQueryDllHinst(), IDS_HTML_HELPFILE, achHtmlFilename,
				sizeof(achHtmlFilename) / sizeof(TCHAR));

			HtmlHelp(0, achHtmlFilename, HH_HELP_FINDER, 0); //formely owned by hwnd - mpt
#else
			WinHelp(hwnd,
					glblQueryHelpFileName(),
					HELP_FINDER, // mrw:3/10/95
					(DWORD)(LPTSTR)"");
#endif
			return 0;

		case WM_CREATE:
			SP_WM_CREATE(hwnd, (CREATESTRUCT *)lPar);
			return 0;

		case WM_SIZE:
			SP_WM_SIZE(hwnd, (unsigned)wPar, LOWORD(lPar), HIWORD(lPar));
			return 0;

		case WM_COMMAND:
			return SP_WM_CMD(hwnd, LOWORD(wPar), HIWORD(wPar), (HWND)lPar);

		case WM_TIMER:
		case WM_FAKE_TIMER:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			TimerMuxProc(hSession);

            return 0;

		case WM_SETFOCUS:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			SetFocus(sessQueryHwndTerminal(hSession));
			return 0;

		case WM_SYSCOLORCHANGE:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			SendDlgItemMessage(hwnd, IDC_TERMINAL_WIN, uMsg, wPar, lPar);
			return 0;

		case WM_GETMINMAXINFO:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			sessSetMinMaxInfo(hSession, (PMINMAXINFO)lPar);
			return 0;

		case WM_CONTEXTMENU:
			SP_WM_CONTEXTMENU(hwnd);
			return 0;

		case WM_INITMENUPOPUP:
			SP_WM_INITMENUPOPUP(hwnd, (HMENU)wPar, LOWORD(lPar), HIWORD(lPar));
			return 0;

		case WM_EXITMENULOOP:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_MAX_PARTS, 0);
			break;

		case WM_MENUSELECT:
			{
			TCHAR ach[128];

			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			if (HIWORD(wPar) & MF_POPUP)
				{
				SendMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_NOPARTS, 0, (LPARAM)(LPTSTR)"");
				return 0;
				}
			if (LOWORD(wPar))
				{
				LoadString(glblQueryDllHinst(),
							IDM_MENU_BASE+LOWORD(wPar),
							ach,
							sizeof(ach) / sizeof(TCHAR));
				SendMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_NOPARTS, 0, (LPARAM)(LPTSTR)ach);
				}
			}
			return 0;

		case WM_PASTE:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			PasteFromClipboardToHost(hwnd, hSession);
			return 0;

		case WM_DRAWITEM:
			if (wPar == IDC_STATUS_WIN)
				{
				hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

				sbr_WM_DRAWITEM(sessQueryHwndStatusbar(hSession),
					(LPDRAWITEMSTRUCT)lPar);

				return 1;
				}
			return 0;

		case WM_QUERYENDSESSION:
		case WM_CLOSE:
			if (!SP_WM_CLOSE(hwnd))
				return 0;
			break;

		case WM_DESTROY:
			SP_WM_DESTROY(hwnd);
			return 0;

		/* --- Public Session Messages --- */

		case WM_NOTIFY:
			DecodeNotification(hwnd, wPar, lPar);
			return 1;

		case WM_SESS_NOTIFY:
			DecodeSessionNotification(hwnd, (NOTIFICATION)wPar, lPar);
			return 1;

		case WM_SESS_ENDDLG:
			if (IsWindow((HWND)lPar))
				{
				// I think that this needs to be done in this order.
				// Think about it.

				DestroyWindow((HWND)lPar);
				glblDeleteModelessDlgHwnd((HWND)lPar);
				}
			return 0;

		case WM_CMDLN_DIAL:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

			// mrw:4/21/95 by microsoft's request
			//if (sessQueryWindowShowCmd(hSession) != SW_SHOWMINIMIZED)

			sessCmdLnDial(hSession);
			return 0;

		case WM_SESS_SIZE_SHOW:
			sessSizeAndShow(hwnd, (int)wPar);
			return 0;
  		
		case WM_CNCT_DIALNOW:
			// wPar contains connection flags
			//
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			cnctConnect(sessQueryCnctHdl(hSession), (unsigned int)wPar);
			return 0;

		case WM_DISCONNECT:
			// wPar contains disconnection flags
			//
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			cnctDisconnect(sessQueryCnctHdl(hSession), (unsigned int)wPar);
			return 0;

		case WM_HT_QUERYOPENFILE:
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			return CheckOpenFile(hSession, (ATOM)lPar);

		case WM_SESS_SHOW_SIDEBAR:
			// Autoloads can't do this directly or they hang hypertrm.
			//
			hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			ShowWindow(sessQuerySidebarHwnd(hSession), SW_SHOW);

			// Force terminal window to fit
			//
			SendDlgItemMessage(hwnd, IDC_TERMINAL_WIN, WM_SIZE, 0, 0);
			return 0;

        case WM_ERROR_MSG:
            {
            TCHAR   ach[128];

			LoadString(glblQueryDllHinst(),
                (UINT)wPar,
                ach,
                sizeof(ach)/sizeof(TCHAR));

			TimedMessageBox(hwnd, ach, "Message", MB_OK, 0);
            }

            return 0;

		default:
			break;
		}

	return DefWindowProc(hwnd, uMsg, wPar, lPar);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SP_WM_CMD
 *
 * DESCRIPTION:
 *	WM_COMMAND processor for SessProc()
 *
 * ARGUMENTS:
 *	hwnd		- session window handle
 *	nId 		- item, control, or accelerator identifier
 *	nNotify 	- notification code
 *	hwndCtrl	- handle of control
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC LRESULT SP_WM_CMD(const HWND hwnd, const int nId, const int nNotify,
					  const HWND hwndCtrl)
	{
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	DWORD 		   dwCnt;
	void		   *pv;
	LPTSTR		   pszFileName;
    TCHAR          ach[100], achList[100], achDir[MAX_PATH];
#if defined(INCL_USE_HTML_HELP)
    TCHAR          achHtmlFilename[100];
#endif

	switch (nId)
		{
		case IDC_TOOLBAR_WIN:
			/* Got a notification from the toolbar */
			return ToolbarNotification(hwnd, nId, nNotify, hwndCtrl);

		/* --- File Menu --- */

		case IDM_NEW:
			if (!sessDisconnectToContinue(hSession, hwnd))
				break;

			if (SaveSession(hSession, hwnd))
				{
				if (ReinitializeSessionHandle(hSession, TRUE) == FALSE)
					break;

				cnctConnect(sessQueryCnctHdl(hSession), CNCT_NEW);
				}

			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_KEY_PARTS, 0);
			break;

		case IDM_OPEN:
			if (!sessDisconnectToContinue(hSession, hwnd))
				break;

			// In the OpenSession() we will ask if the user wants to save
			// existing opened new session, or save silently, only after the
			// user has commited to opening a new one by pressing the OK button.
			// -jac. 10-06-94 03:56pm
			if (OpenSession(hSession, hwnd) >= 0)
				{
				PostMessage(sessQueryHwndStatusbar(hSession),
					SBR_NTFY_REFRESH, (WPARAM)SBR_MAX_PARTS, 0);

				// Run through the connection procedure. This message is
				// Posted instead of calling cnctConnect directly to avoid
				// a focus problem on the connection dialog.  Calling
				// cnctConnect from here leaves focus on the terminal screen,
				// instead of on the connection dialog, which is where we want it.
				//
				PostMessage(hwnd, WM_COMMAND, IDM_ACTIONS_DIAL, 0);
				}

			break;

		case IDM_SAVE:
			SilentSaveSession(hSession, hwnd, TRUE);
			break;

		case IDM_SAVE_AS:
			SaveAsSession(hSession, hwnd);

			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_KEY_PARTS, 0);
			break;

		case IDA_CONTEXT_MENU:		// SHIFT+F10
			SP_WM_CONTEXTMENU(hwnd);
			return 0;

		case IDM_PAGESETUP:
		case IDM_CHOOSEPRINT:
 			printPageSetup(sessQueryPrintHdl(hSession), hwnd);
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_KEY_PARTS, 0);
			break;

		case IDM_PRINT:
		case IDM_CONTEXT_PRINT:
			printsetSetup(sessQueryPrintHdl(hSession), hwnd);
			break;

		case IDM_PROPERTIES:
			DoInternalProperties(hSession, hwnd);

			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_ALL_PARTS, 0);
			break;

		case IDM_EXIT:
			PostMessage(hwnd, WM_CLOSE, 0, 0);
			break;

		/* --- Edit Menu --- */

		case IDM_SELECT_ALL:
		case IDM_CONTEXT_SELECT_ALL:
			SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_MARK_ALL, 0, 0);
			break;

		case IDM_PASTE:
		case IDM_CONTEXT_PASTE:
			SendMessage(hwnd, WM_PASTE, 0, 0L);
			break;

		case IDM_COPY:
		case IDM_CONTEXT_COPY:
			if (CopyMarkedTextFromTerminal(hSession, &pv, &dwCnt, TRUE))
				{
				CopyBufferToClipBoard(hwnd, dwCnt, pv);
				SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_UNMARK, 0, 0);
				free(pv);	// free allocated buffer from terminal
				pv = NULL;
				}
			break;

		case IDM_CLEAR_BACKSCROLL:
        #if defined(INCL_TERMINAL_CLEAR)
		case IDM_CONTEXT_CLEAR_BACKSCROLL:
        #endif
			backscrlFlush(sessQueryBackscrlHdl(hSession));
			break;

        #if defined(INCL_TERMINAL_CLEAR)
		case IDM_CLEAR_SCREEN:
		case IDM_CONTEXT_CLEAR_SCREEN:
            emuEraseTerminalScreen(sessQueryEmuHdl(hSession));
            emuHomeHostCursor(sessQueryEmuHdl(hSession));
        	NotifyClient(hSession, EVENT_TERM_UPDATE, 0);
	        RefreshTermWindow(sessQueryHwndTerminal(hSession));
           	break;
        #endif

		/* --- View Menu --- */

		case IDM_VIEW_TOOLBAR:
			sessSetToolbarVisible(hSession,
				!sessQueryToolbarVisible(hSession));

			SP_WM_SIZE(hwnd, (unsigned)(-1), 0, 0);

			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_MAX_PARTS, 0);
			break;

		case IDM_VIEW_STATUS:
			sessSetStatusbarVisible(hSession,
				!sessQueryStatusbarVisible(hSession));

			SP_WM_SIZE(hwnd, (unsigned)(-1), 0, 0);

			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_MAX_PARTS, 0);
			break;

		case IDM_VIEW_FONTS:
			DisplayFontDialog(hSession, FALSE);

			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_KEY_PARTS, 0);
			break;

        case IDM_VIEW_SNAP:
		case IDM_CONTEXT_SNAP:
			sessSnapToTermWindow(hwnd);
			break;

#ifdef INCL_KEY_MACROS
		case IDM_KEY_MACROS:
			DoDialog(glblQueryDllHinst(),
					MAKEINTRESOURCE(IDD_KEYSUMMARYDLG),
					hwnd,
					KeySummaryDlg,
					(LPARAM)hSession);
            break;
#endif

		/* --- Actions Menu --- */

		case IDM_ACTIONS_DIAL:
			{
			HWND hWnd = sessQueryHwnd(hSession);

 			cnctConnect(sessQueryCnctHdl(hSession), 0);
			
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_KEY_PARTS, 0);

			if (hWnd != NULL)
				{
				PostMessage(hWnd, WM_COMMAND, XFER_CNCT, 0);
				}
			}
			break;

		case IDM_ACTIONS_HANGUP:
			{
			HWND hWnd = sessQueryHwnd(hSession);

			//mpt:10-28-97 added exit upon disconnect feature
            // REV: 02/16/2001 Added support for canceling file transfers.
			int iDisconnectStatus =
				cnctDisconnect(sessQueryCnctHdl(hSession),
				               sessQueryExit(hSession) ? DISCNCT_EXIT | CNCT_XFERABORTCONFIRM : CNCT_XFERABORTCONFIRM);

			if (hWnd != NULL && iDisconnectStatus != CNCT_IN_DISCONNECT)
				{
				PostMessage(hWnd, WM_COMMAND, XFER_CNCT, 0);
				}
			}
			break;

		case IDM_ACTIONS_SEND:
		case IDM_CONTEXT_SEND:
			DoDialog(glblQueryDllHinst(),
					MAKEINTRESOURCE(IDD_TRANSFERSEND),
					hwnd,				/* parent window */
					TransferSendDlg,
					(LPARAM)hSession);
			break;

		case IDM_ACTIONS_RCV:
		case IDM_CONTEXT_RECEIVE:
			/*
			 * This will probably need to be modeless later.
			 * Maybe only for Upper Wacker.
			 */
			DoDialog(glblQueryDllHinst(),
					MAKEINTRESOURCE(IDD_TRANSFERRECEIVE),
					hwnd,
					TransferReceiveDlg,
					(LPARAM)hSession);
			break;

		case IDM_ACTIONS_CAP:
			DoDialog(glblQueryDllHinst(),
					MAKEINTRESOURCE(IDD_CAPTURE),
					hwnd,
					CaptureFileDlg,
					(LPARAM)hSession);
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_CAPT_PART_NO, 0);
			break;

		case IDM_CAPTURE_STOP:
			cpfSetCaptureState(sessQueryCaptureFileHdl(hSession),
								CPF_CAPTURE_OFF);
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_CAPT_PART_NO, 0);
			break;

		case IDM_CAPTURE_PAUSE:
			cpfSetCaptureState(sessQueryCaptureFileHdl(hSession),
								CPF_CAPTURE_PAUSE);
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_CAPT_PART_NO, 0);
			break;

		case IDM_CAPTURE_RESUME:
			cpfSetCaptureState(sessQueryCaptureFileHdl(hSession),
								CPF_CAPTURE_ON);
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_CAPT_PART_NO, 0);
			break;

		case IDM_ACTIONS_SEND_TEXT:
			LoadString(glblQueryDllHinst(), IDS_SND_TXT_FILE, ach,
				sizeof(ach)/sizeof(TCHAR));

			resLoadFileMask(glblQueryDllHinst(), IDS_CPF_FILES1, 2, achList,
				sizeof(achList) / sizeof(TCHAR));

			//Changed to use working folder rather than current folder - mpt 8-18-99
            if ( !GetWorkingDirectory( achDir, sizeof(achDir) / sizeof(TCHAR)) )
				{
				GetCurrentDirectory(sizeof(achDir) / sizeof(TCHAR), achDir);
				}

			pszFileName = gnrcFindFileDialog(hwnd, ach, achDir, achList);

			if (pszFileName)
				{
				CLoopSendTextFile(sessQueryCLoopHdl(hSession), pszFileName);
				free(pszFileName);
				pszFileName = NULL;
				}
			break;

		case IDM_ACTIONS_PRINT:
			if (!printQueryStatus(emuQueryPrintEchoHdl(sessQueryEmuHdl(hSession))))
				{
				if (printVerifyPrinter(sessQueryPrintHdl(hSession)) == -1)
					break;
				}
			else
				{
				printEchoClose(emuQueryPrintEchoHdl(sessQueryEmuHdl(hSession)));
				}

			printStatusToggle(emuQueryPrintEchoHdl(sessQueryEmuHdl(hSession)));
			PostMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_PRNE_PART_NO, 0);
			break;

        case IDM_ACTIONS_WAIT_FOR_CALL:
 			cnctConnect(sessQueryCnctHdl(hSession), CNCT_ANSWER);
            break;

        case IDM_ACTIONS_STOP_WAITING:
            cnctDisconnect(sessQueryCnctHdl(hSession), DISCNCT_NOBEEP);
            break;

		/* --- Help Menu --- */

		case IDM_HELPTOPICS:
//#if 0 //mpt:3-10-98 for some reason, using this call causes an access violation
	  //            in HyperTrm.dll. Using the winhelp call gives us the same results.
        //mpt:4-30-98 Re-enabled for the NT folks - go figure
#if defined(INCL_USE_HTML_HELP)
		  	LoadString(glblQueryDllHinst(), IDS_HTML_HELPFILE, achHtmlFilename,
				sizeof(achHtmlFilename) / sizeof(TCHAR));

			HtmlHelp(0, achHtmlFilename, HH_HELP_FINDER, 0);
#else
			WinHelp(hwnd,
					glblQueryHelpFileName(),
					HELP_FINDER,	// mrw:3/10/95
					(DWORD)(LPTSTR)"");
#endif
			break;

#if defined(INCL_NAG_SCREEN)
        case IDM_PURCHASE_INFO:
            DoUpgradeDlg(hwnd);
            break;

        case IDM_REG_CODE:
            DoRegisterDlg(hwnd);
            break;

        case IDM_REGISTER:
            DoRegister();
            break;

        case IDM_DISCUSSION:
            ShellExecute(NULL, "open", TEXT("http://www.hilgraeve.com/discuss"), NULL, NULL, SW_SHOW);
            break;
#endif

        case IDM_ABOUT:
			AboutDlg(hwnd);
			break;

		/* --- Session Context Menu --- */

		// Other context menu items are placed with their main menu
		// equivalents.

		#if 0 // mrw, 1/27/95
		case IDM_CONTEXT_WHATS_THIS:
			WinHelp(hwnd, glblQueryHelpFileName(), HELP_CONTEXTPOPUP,
				(DWORD)(LPTSTR)IDH_TERM_CONTEXT_WHATS_THIS);
			break;
		#endif

		#if defined(TESTMENU) && !defined(NDEBUG)
		/* --- Test Menu --- */

		case IDM_TEST_SAVEAS:
			SaveAsSession(hSession, hwnd);
			break;

		case IDM_TEST_CLEARTERM:
			break;

		case IDM_TEST_CLEARBACK:
			break;

		case IDM_TEST_SELECTTERM:
			break;

		case IDM_TEST_SELECTBACK:
			break;

		case IDM_TEST_TESTFILE:
			{
			pszFileName = 0;

			pszFileName = gnrcFindFileDialog(hwnd,
							"Emulator test file",
							"D:\\WACKER",
							"Text files\0*.TXT\0Ansi files\0*.ans\0VT100 files\0*.100");

			if (pszFileName)
				{
				CLoopSendTextFile(sessQueryCLoopHdl(hSession), pszFileName);

				free(pszFileName);
				pszFileName = NULL;
				}
			}
			break;

		case IDM_TEST_BEZEL:
			SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_BEZEL, 0, 0);
			break;

		case IDM_TEST_SNAP:
			sessSnapToTermWindow(hwnd);
			break;

		case IDM_TEST_NEW_CONNECTION:
			DoDialog(glblQueryDllHinst(),
					MAKEINTRESOURCE(IDD_NEWCONNECTION),
					hwnd,
					NewConnectionDlg,
					(LPARAM)hSession);
			break;

		case IDM_TEST_FLUSH_BACKSCRL:
			backscrlFlush(sessQueryBackscrlHdl(hSession));
			break;

		case IDM_TEST_LOAD_ANSI:
			emuLoad(sessQueryEmuHdl(hSession), EMU_ANSI);
			break;

		case IDM_TEST_LOAD_MINITEL:
			emuLoad(sessQueryEmuHdl(hSession), EMU_MINI);
			break;

		case IDM_TEST_LOAD_VIEWDATA:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VIEW);
			break;

		case IDM_TEST_LOAD_AUTO:
			emuLoad(sessQueryEmuHdl(hSession), EMU_AUTO);
			break;

		case IDM_TEST_LOAD_TTY:
			emuLoad(sessQueryEmuHdl(hSession), EMU_TTY);
			break;

		case IDM_TEST_LOAD_VT52:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VT52);
			break;

		case IDM_TEST_LOAD_VT100:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VT100);
			break;

#if defined(INCL_VT220)
		case IDM_TEST_LOAD_VT220:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VT220);
			break;
#endif

#if defined(INCL_VT320)
		case IDM_TEST_LOAD_VT320:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VT320);
			break;
#endif

#if defined(INCL_VT100PLUS)
		case IDM_TEST_LOAD_VT100PLUS:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VT100PLUS);
			break;
#endif

#if defined(INCL_VTUTF8)
		case IDM_TEST_LOAD_VTUTF8:
			emuLoad(sessQueryEmuHdl(hSession), EMU_VTUTF8);
			break;
#endif

		case IDM_TEST_SESSNAME:
			{
			TCHAR ach[FNAME_LEN];
			sessQueryName(hSession, ach, FNAME_LEN);
			TimedMessageBox(hwnd, ach, "Message", MB_OK, 0);
			}
			break;

		#endif

		default:
			break;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SP_WM_CREATE
 *
 * DESCRIPTION:
 *	Does the WM_CREATE stuff for the frameproc window.
 *
 * ARGUMENTS:
 *	hwnd	- frame window handle.
 *  *pcs    - pointer to CREATESTRUCT, structure passed from CreateWindowEx().
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void SP_WM_CREATE(const HWND hwnd, const CREATESTRUCT *pcs)
	{
	HSESSION  hSession;

	hSession = CreateSessionHandle(hwnd);

	// Need to set even if hSession is zero so the destroy handle routine
	// does not try to destroy a non-handle.

	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)hSession);

	if (hSession == 0)
		{
		assert(FALSE);
		PostMessage(hwnd, WM_CLOSE, 0, 0);
		return;
		}

	if (InitializeSessionHandle(hSession, hwnd, pcs) == FALSE)
		{
		assert(FALSE);
		PostMessage(hwnd, WM_CLOSE, 0, 0);
		return;
		}

	if (glblQueryProgramStatus())
		{
		/* Something has shut use down, don't continue */
		return;
		}

	// mrw, 1/27/95 SetWindowContextHelpId(hwnd, IDH_TERM_WINDOW);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SP_WM_DESTROY
 *
 * DESCRIPTION:
 *	WM_DESTROY message processor for session window.
 *
 * ARGUMENTS:
 *	hwnd	- session window handle.
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void SP_WM_DESTROY(const HWND hwnd)
	{
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (GetFileSizeFromName(glblQueryHelpFileName(), NULL))
		WinHelp(hwnd, glblQueryHelpFileName(), HELP_QUIT, 0L);

	// It appears that our subclassed statusbar window doesn't get the
	// WM_DESTROY message when its parent, the session window, is getting
	// destroyed, so we force it...
	//
	DestroyWindow(sessQueryHwndStatusbar(hSession));

	if (hSession)
		DestroySessionHandle(hSession);

	PostQuitMessage(0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SP_WM_SIZE
 *
 * DESCRIPTION:
 *	WM_SIZE message processor for sessproc.
 *
 * ARGUMENTS:
 *	hwnd		- session window
 *	fwSizeType	- from WM_SIZE
 *	iWidth		- width of window
 *	iHige		- hite of window
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void SP_WM_SIZE(const HWND hwnd,
					   const unsigned fwSizeType,
					   const int iWidth,
					   const int iHite)
	{
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	HWND hwndDisplay;

	// DbgOutStr("WM_SIZE %d (%d x %d)\r\n", fwSizeType, iWidth, iHite, 0,0);

	/*
	 * We need a bunch of fiddling around for the transfer display
	 */
	if (hSession)
		{
		hwndDisplay = xfrGetDisplayWindow(sessQueryXferHdl(hSession));
		if (IsWindow(hwndDisplay))
			{
			switch (fwSizeType)
				{
				case SIZE_MINIMIZED:
				case SIZE_MAXHIDE:
					// DbgOutStr("Iconic\r\n", 0,0,0,0,0);
					if (IsWindowVisible(hwndDisplay))
						ShowWindow(hwndDisplay, SW_HIDE);
					break;
				case SIZE_MAXIMIZED:
				case SIZE_RESTORED:
				case SIZE_MAXSHOW:
					if (!IsWindowVisible(hwndDisplay))
						ShowWindow(hwndDisplay, SW_SHOWDEFAULT);
					break;
				default:
					break;
				}
			}
		}

	SendDlgItemMessage(hwnd, IDC_STATUS_WIN, WM_SIZE, 0, 0);
	SendDlgItemMessage(hwnd, IDC_TOOLBAR_WIN, WM_SIZE, 0, 0);
	SendDlgItemMessage(hwnd, IDC_TERMINAL_WIN, WM_SIZE, 0, 0);
	SendDlgItemMessage(hwnd, IDC_SIDEBAR_WIN, WM_SIZE, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SP_WM_INITMENUPOPUP
 *
 * DESCRIPTION:
 *	WM_INITMENUPOPUP message handler for session window.
 *
 * ARGUMENTS:
 *	hwnd	- session window handle
 *	hMenu	- menu handle of popup
 *	uPos	- position of menu item that invoked popup
 *	fSysMenu- TRUE if system menu popup
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void SP_WM_INITMENUPOPUP(const HWND hwnd, const HMENU hMenu,
								const UINT uPos, const BOOL fSysMenu)
	{
	HMENU 	hWinMenu;
	int 	nOK, nIdx;
	TCHAR 	ach[50];

	// Popup menus are referenced by position since id's can't be assigned
	// (grrrrr!).  Actual menu init functions are in sessmenu.c

	#define MENU_FILE_POS		0
	#define MENU_EDIT_POS		1
	#define MENU_VIEW_POS		2
	#define MENU_CALL_POS		3
	#define MENU_TRANSFER_POS	4
	#define MENU_HELP_POS		5

	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	// Display help for top menu item.
	// I suppose we will have to be read from the resource file once we know
	// what the strings and their ids are.
	//
	LoadString(glblQueryDllHinst(),
				IDM_MENU_BASE+uPos,
				ach,
				sizeof(ach) / sizeof(TCHAR));
	//wsprintf(ach, "Help for menu item %d\0", uPos);
	SendMessage(sessQueryHwndStatusbar(hSession), SBR_NTFY_NOPARTS, 0, (LPARAM)(LPTSTR)ach);

	if (fSysMenu)
		return;

	/*
	 * This makes sure we only handle top level menu items here.
	 *
	 * The problem is that secondary popup menus also cause a WM_INITPOPUP
	 * message to get sent.  The only way to tell one of these messages from
	 * another is to check the menu handle.  As MRW alluded to above, this
	 * would be less of a problem if they did this stuff with IDs instead of
	 * offsets.
	 */

	hWinMenu = GetMenu(hwnd);
	nOK = FALSE;

	for (nIdx = 0; nIdx <= MENU_HELP_POS; nIdx += 1)
		{
		if (hMenu == GetSubMenu(hWinMenu, nIdx))
			nOK = TRUE;
		}

	if (!nOK)
		return;

	/* --- Ok, its a top-level menu, let's have at it --- */

	switch (uPos)
		{
	case MENU_FILE_POS:
		break;

	case MENU_EDIT_POS:
		sessInitMenuPopupEdit(hSession, hMenu);
		break;

	case MENU_VIEW_POS:
		sessInitMenuPopupView(hSession, hMenu);
		break;

	case MENU_CALL_POS:
		sessInitMenuPopupCall(hSession, hMenu);
		break;

	case MENU_TRANSFER_POS:
		sessInitMenuPopupTransfer(hSession, hMenu);
		break;

	case MENU_HELP_POS:
		sessInitMenuPopupHelp(hSession, hMenu);
        break;

	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DecodeSessionNotification
 *
 * DESCRIPTION:
 *	Receives a NotifyClient event and routes the notification.
 *
 * ARGUMENTS:
 *	hwndSession - session window handle
 *	nEvent		- notification event
 *	lExtra		- additional data to pass
 *
 * RETURNS:
 *	void
 *
 */
void DecodeSessionNotification(const HWND hwndSession,
								const NOTIFICATION nEvent,
								const LPARAM lExtra)
	{
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwndSession,
															GWLP_USERDATA);

	switch (nEvent) /*lint -e787 -e788 */
		{
	case EVENT_TERM_UPDATE:
		// This message must be sent, not posted so initialization
		// at program startup works - mrw
		SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_GETUPDATE, 0, 0);
		break;

	case EVENT_TERM_TRACK:
		PostMessage(sessQueryHwndTerminal(hSession), WM_TERM_TRACK, 0, 0);
		break;

	case EVENT_EMU_CLRATTR:
		// This message must be sent, not posted so initialization
		// at program startup works - mrw
		SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_CLRATTR, 0, 0);
		break;

	case EVENT_EMU_SETTINGS:
		// This message must be sent, not posted so initialization
		// at program startup works - mrw
		SendMessage(sessQueryHwndTerminal(hSession), WM_TERM_EMU_SETTINGS, 0, 0);
		break;

	case EVENT_CONNECTION_OPENED:
		//cnctMessage(sessQueryCnctHdl(hSession), IDS_CNCT_OPEN);
		emuNotify(sessQueryEmuHdl(hSession), EMU_EVENT_CONNECTED);
		cnctSetStartTime(sessQueryCnctHdl(hSession));
		CLoopControl(sessQueryCLoopHdl(hSession), CLOOP_SET, CLOOP_CONNECTED);
		break;

	case EVENT_CONNECTION_INPROGRESS:
		emuNotify(sessQueryEmuHdl(hSession), EMU_EVENT_CONNECTING);
		break;

	case EVENT_CONNECTION_CLOSED:
		//cnctMessage(sessQueryCnctHdl(hSession), IDS_CNCT_CLOSE);
		emuNotify(sessQueryEmuHdl(hSession), EMU_EVENT_DISCONNECTED);
		CLoopControl(sessQueryCLoopHdl(hSession), CLOOP_CLEAR, CLOOP_CONNECTED);
		break;

	case EVENT_HOST_XFER_REQ:
		xfrDoAutostart(sessQueryXferHdl(hSession), (long)lExtra);
		break;

	case EVENT_CLOOP_SEND:
		PostMessage(sessQueryHwndTerminal(hSession), WM_TERM_TRACK,
			(WPARAM)1, 0);
		break;

	case EVENT_PORTONLY_OPEN:
		cnctConnect(sessQueryCnctHdl(hSession), CNCT_PORTONLY);
		break;

    case EVENT_LOST_CONNECTION:
        cnctDisconnect(sessQueryCnctHdl(hSession),
		               (unsigned int)(lExtra) | CNCT_LOSTCARRIER);
        break;

	default:
		break;
		} /*lint +e787 +e788 */

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DecodeNotification
 *
 * DESCRIPTION:
 *	Receives a NotifyClient event and routes the notification.
 *
 * ARGUMENTS:
 *	hwndSession - session window handle
 *	wPar        - standard wPar to window proc
 *	lPar        - standard lPar to window proc, points to NMHDR structure for
 *	              details of notification.  See WM_NOTIFY.
 *
 * RETURNS:
 *	void
 *
 */
void DecodeNotification(const HWND hwndSession, WPARAM wPar, LPARAM lPar)
	{
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwndSession, GWLP_USERDATA);
	NMHDR *pN = (NMHDR *)lPar;

	switch (pN->code) /*lint -e787 -e788 */
		{
	case TTN_NEEDTEXT:
		ToolbarNeedsText(hSession, lPar);
		break;

	default:
		break;
		} /*lint +e787 +e788 */

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SP_WM_CONTEXTMENU
 *
 * DESCRIPTION:
 *	WM_CONTEXTMENU message handler for session window.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 */
STATIC_FUNC void SP_WM_CONTEXTMENU(const HWND hwnd)
	{
	RECT  rc;
	POINT pt;
	HWND  hwndToolbar, hwndStatus;
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	GetCursorPos((LPPOINT)&pt);
	hwndToolbar = sessQueryHwndToolbar(hSession);
	if (IsWindowVisible(hwndToolbar))
		{
		GetClientRect(hwndToolbar, (LPRECT)&rc);
		ScreenToClient(hwndToolbar, (LPPOINT)&pt);
		if (PtInRect((LPRECT)&rc, pt))
			return;
		}

	GetCursorPos((LPPOINT)&pt);
	hwndStatus = sessQueryHwndStatusbar(hSession);
	if (IsWindowVisible(hwndStatus))
		{
		GetClientRect(hwndStatus, (LPRECT)&rc);
		ScreenToClient(hwndStatus, (LPPOINT)&pt);
		if (PtInRect((LPRECT)&rc, pt))
			return;
		}
	GetCursorPos((LPPOINT)&pt);
	GetClientRect(hwnd, (LPRECT)&rc);
	ScreenToClient(hwnd, (LPPOINT)&pt);

	if (PtInRect((LPRECT)&rc, pt))
		HandleContextMenu(hwnd, pt);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  SP_WM_CLOSE
 *
 * DESCRIPTION:
 *  WM_CLOSE message processing.
 *
 * ARGUMENTS:
 *  hwnd - session window.
 *
 * RETURNS:
 *  TRUE if all OK, FALSE otherwise.
 *
 */
STATIC_FUNC BOOL SP_WM_CLOSE(const HWND hwnd)
	{
	HSESSION hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (!sessDisconnectToContinue(hSession, hwnd))
		return FALSE;

	if (!SaveSession(hSession, hwnd))
		return FALSE;

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CheckOpenFile
 *
 * DESCRIPTION:
 *	Checks if given atom matches current system file name
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *	aFile		- atom of session file
 *
 * RETURNS:
 *	TRUE if current system file matches the one in the atom
 *
 * AUTHOR: Mike Ward, 27-Jan-1995
 */
static int CheckOpenFile(const HSESSION hSession, ATOM aFile)
	{
	TCHAR ach[FNAME_LEN];
	TCHAR achSessFile[FNAME_LEN];

	ach[0] = TEXT('\0');

	if (GlobalGetAtomName(aFile, ach, FNAME_LEN))
		{
		achSessFile[0] = TEXT('\0');

		sfGetSessionFileName(sessQuerySysFileHdl(hSession),
			FNAME_LEN, achSessFile);

		return !StrCharCmpi(achSessFile, ach);
		}

	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sess_ids.h ===
/*	File: D:\WACKER\tdll\sess_ids.h (Created: 30-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 3/04/02 11:58a $
 */

/*
 *	This file contains the IDs for items that are in the session file.
 *
 *	The following guidelines are suggested for using this list:
 *
 *	1.  New guidelines may be added as necessary.  It is the responsibility
 *		of the person adding the new guideline to make sure that old entries
 *		conform to the new guideline.
 *
 *	2.	All IDs should be prefixed with SFID_ to indicate what they are.
 *
 *	3.	All IDs should be entered in HEX and in increasing numerical order.
 *
 *	4.	If a block of IDs are needed, the first and last ID in the block
 *		should be entered in the file and a comment added to indicate that
 *		the values in between should not be used for other reasons.
 *
 *	Thank you for your support.
 */

#define SFID_ICON_DEFAULT			  0x00000001
#define SFID_ICON_EXTERN			  0x00000002

#define SFID_INTERNAL_TAG			  0x00000005

#define SFID_PRINTSET_NAME			  0x00000010
#define SFID_EMU_SETTINGS			  0x00000011
#define SFID_EMU_TEXTCOLOR_SETTING	  0x00000013
#define SFID_EMU_BKGRNDCOLOR_SETTING  0x00000014
#define SFID_EMU_SCRNROWS_SETTING	  0x00000015
#define SFID_EMU_SCRNCOLS_SETTING	  0x00000016
#define SFID_EMU_PRINT_RAW			  0x00000017

#define SFID_PRINTSET_DEVMODE		  0x00000020
#define SFID_PRINTSET_DEVNAMES		  0x00000021
#define SFID_PRINTSET_FONT  		  0x00000022
#define SFID_PRINTSET_MARGINS		  0x00000023
#define SFID_PRINTSET_FONT_HEIGHT	  0x00000024
#define SFID_KEY_MACRO_LIST           0x00000025

#define SFID_CNCT					  0x00000040
#define SFID_CNCT_CC				  0x00000041
#define SFID_CNCT_AREA				  0x00000042
#define SFID_CNCT_DEST				  0x00000043
#define SFID_CNCT_LINE				  0x00000044
#define SFID_CNCT_TAPICONFIG		  0x00000045
#define SFID_CNCT_USECCAC			  0x00000046
#define SFID_CNCT_REDIAL              0x00000047
#define SFID_CNCT_COMDEVICE           0x00000048
#define SFID_CNCT_END				  0x00000050

#define SFID_CNCT_IPDEST			  0x00000051
#define SFID_CNCT_IPPORT			  0x00000052

#define SFID_XFER_PARAMS			  0x00000100

#define	SFID_PROTO_PARAMS			  0x00000101
/* This block is used for SFID_PROTO_PARAMS */
#define	SFID_PROTO_PARAMS_END		  0x00000111

#define	SFID_XFR_RECV_DIR			  0x00000120
#define	SFID_XFR_SEND_DIR			  0x00000121
#define	SFID_XFR_USE_BPS			  0x00000122

#define	SFID_CPF_FILENAME			  0x00000128
#define	SFID_CPF_MODE				  0x00000129
#define	SFID_CPF_FILE				  0x0000012A

#define	SFID_PRE_MODE				  0x0000012C
#define	SFID_PRE_METHOD				  0x0000012D

/* Backscroll region size and saved data (text) */
#define SFID_BKSC					  0x00000130
#define	SFID_BKSC_SIZE				  0x00000131
#define	SFID_BKSC_TEXT				  0x00000132
#define SFID_BKSC_ULINES			  0x00000133
#define SFID_BKSC_END				  0x00000134

#define	SFID_TLBR_VISIBLE			  0x00000135
#define	SFID_STBR_VISIBLE			  0x00000136

#define SFID_CLOOP					  0x0000200
/* This block is used for SFID_CLOOP values */
#define SFID_CLOOP_END				  0x000021F

#define SFID_STDCOM 				  0x00001011
/* This block is used for SFID_STDCOM values */
#define SFID_STDCOM_END 			  0x0000101F

#define SFID_SESS_SOUND				  0x00001020
#define SFID_SESS_NAME				  0x00001021
#define SFID_SESS_LEFT				  0x00001022
#define SFID_SESS_TOP				  0x00001023
#define SFID_SESS_RIGHT				  0x00001024
#define SFID_SESS_BOTTOM			  0x00001025
#define SFID_SESS_SHOWCMD			  0x00001026
#define SFID_SESS_EXIT				  0x00001027

#define SFID_TERM_LOGFONT			  0x00001030
/* Another block, please don't use these values */
#define SFID_TERM_END				  0x0000103F

#define	SFID_TRANS_FIRST			  0x00001040
/* This block is used for CHARACTER_TRANSLATION features */
#define	SFID_TRANS_END				  0x0000107F

/* This is used for LOSS OF CARRIER detection feature */
#define SFID_CNCT_CARRIERDETECT       0x00001080

/* this is used for 'Allow remote initiated file transfers' feature */
#define SFID_SESS_ALLOW_HOST_TRANSFER 0x00001081
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sf.c ===
/*      File: D:\WACKER\tdll\sf.c (Created: 27-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 16 $
 *	$Date: 3/15/02 12:27p $
 */

#include <windows.h>
#include <shlobj.h>
#pragma hdrstop

#include <stdio.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "stdtyp.h"
#include "tdll.h"
#include "htchar.h"
#include "sf.h"
#include "mc.h"

typedef int int32;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 * DATA SECTION
 *
 * This section contains all of the static data that the DLL uses.  Once this
 * data is exhausted, the DLL can do no more.  It just returns errors.  This
 * means that it is important to close or release any and all session files
 * that get opened.
 *
 */

struct stDllSessionFileIndexItem
	{
	int32       uIndex; 		/* Index of the item */
	int32		dwSize; 		/* Size of the item */
	int32		dwOffset;		/* Offset into data block of the item */
	};

typedef	struct stDllSessionFileIndexItem stDSII;
typedef stDSII *pstDSII;

struct stDllSessionFilePointer
	{
	int	uBusy;			            /* TRUE means item is in use */
	int	fOpen;			            /* TRUE means open session file */
	int	uChanged;		            /* TRUE means something is different */

	TCHAR *hFilename;		        /* Memory containing the file name */

	/* These make up the index */
	int	uItemCount; 	            /* Current items in the index */
	int	uItemsAlloc;	            /* Max items in current space */
	pstDSII	hIndex; 		        /* Memory allocated for index */

	/* This is the data segment */
	int  dwDataUsed; 	/* Amount used in data block */
	int	 dwDataSize; 	/* Current sizeof the data block  */
	BYTE *hData;		/* Memory allocated for file data */
	};

typedef	struct stDllSessionFilePointer stDSFP;
typedef stDSFP *pstDSFP;

#define ROUND_UP(x) 	((x+0xFFFL)&(~0x0FFFL))

// used for testing #define	ROUND_UP(x)		((x+0x3F)&(~0x03F))

#define	SESS_FILE_MAX	64

static stDSFP asSessionFiles[SESS_FILE_MAX];

#define HDR_SIZE	256

TCHAR pszHdr[HDR_SIZE] =
	{
	TEXT("HyperTerminal 1.0 -- HyperTerminal data file\r\n")
	TEXT("Please do not attempt to modify this file directly.\r\n")
	TEXT("\r\n\r\n")
	TEXT("\x1A")
	};

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfAddToIndex
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 *	The offset of the item in the index array, or -1.
 */
int32 sfAddToIndex(const int uNdx,
				 const int32 sID,
				 const int32 dwSZ,
				 const int32 dwOffset)
	{
	int nRv = -1;
	int nCnt;
	int low, mid, high;
	int found;
	pstDSFP pD;
	pstDSII	pI;
	pstDSII pIx;
	pstDSII pIy;

	pD = &asSessionFiles[uNdx];

	if (pD->uItemCount >= pD->uItemsAlloc)
		{
#if defined(DEBUG_OUTPUT)
		OutputDebugString("Index expanded\r\n");
#endif
		/*
		 * We need to get a bigger chunk of memory
		 */
		if (pD->hIndex == 0)
			{
			pD->uItemsAlloc = 64;
			pD->hIndex = (pstDSII)malloc(sizeof(stDSII) * 64);
			}
		else
			{
			int      newSize = pD->uItemsAlloc * 2;
			stDSII * pTemphIndex = (pstDSII)
				realloc(pD->hIndex, (size_t)newSize * sizeof(stDSII));

			if (pTemphIndex == NULL)
				{
				return SF_ERR_MEMORY_ERROR;
				}
			else
				{
				pD->uItemsAlloc = newSize;
				pD->hIndex = pTemphIndex;
				}
			}
		}

	if (pD->hData == 0)
		{
		pD->hData = (BYTE *)malloc(ROUND_UP(4096));
		memset(pD->hData, 0, HDR_SIZE);
		pD->dwDataSize = ROUND_UP(4096);
		pD->dwDataUsed = HDR_SIZE;
		}

	/*
	 * Find where the item goes
	 */
	pI = pD->hIndex;

	found = FALSE;
    pIx = 0;
	low = 0;
	high = pD->uItemCount - 1;
    mid = high/2;

	if (pD->uItemCount > 0)
		{
		while (low <= high)
			{
			mid = (low + high) / 2;
			pIx = pI + mid;

			if (sID < pIx->uIndex)
				{
				high = mid - 1;
				}
			else if (sID > pIx->uIndex)
				{
				low = mid + 1;
				}
			else
				{
				/* found a match */
				found = TRUE;
				break;
				}
			}
		}

	if (found)
		{
		if (dwSZ != 0)
			{
			/*
			 * Special case.  Preserve the old values so that we can
			 * adjust the data section for the replacement value.
			 */
			pIx->dwSize = dwSZ;
			pIx->dwOffset = dwOffset;
			}
		nRv = mid;
		}
	else
		{
		/*
		 * The problem with a binary search is that it is unclear where
		 * you are if no match occurs.  So we do it the old way.
		 */
		pIx = pI;
		nCnt = 0;
		for (;;)
			{
			/* TODO: switch to binary search */
			if (nCnt >= pD->uItemCount)
				{
				/*
				 * We have gone past the end of the list
				 */
				pIx->uIndex = sID;
				pIx->dwSize = dwSZ;
				pIx->dwOffset = dwOffset;
				nRv = nCnt;
				break;
				}
			else if (pIx->uIndex >= sID)
				{
				if (pIx->uIndex > sID)
					{
					/*
					 * Slide the remaining items down by one
					 */

					pIy = pI + pD->uItemCount;
					while (pIy > pIx)
						{
						*pIy = *(pIy - 1);
						pIy -= 1;
						}

				#if 0
					/* Don, would this work better? */

					_fmemmove(pIx+1, pIx,
						(pD->uItemCount - nCnt) * sizeof(stDSII));

				#endif

					pIx->uIndex = sID;
					pIx->dwSize = dwSZ;
					pIx->dwOffset = dwOffset;
					}
				else		/* == */
					{
					if (dwSZ != 0)
						{
						/*
						 * Special case.  Preserve the old values so that we can
						 * adjust the data section for the replacement value.
						 */
						pIx->dwSize = dwSZ;
						pIx->dwOffset = dwOffset;
						}
					pD->uItemCount -= 1;
					}

				nRv = (int)(pIx - pI);
				break;
				}
			pIx += 1;
			nCnt += 1;
			}
		pD->uItemCount += 1;
		}

	return nRv;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateSysFileHdl
 *
 * DESCRIPTION:
 *	Creates a session file handle
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	SF_HANDLE or < 0 for error
 *
 */
SF_HANDLE CreateSysFileHdl(void)
	{
	int uNdx;

	for (uNdx = 0; uNdx < SESS_FILE_MAX; uNdx += 1)
		{
		/*
		 * See if an unused slot is available
		 */
		if (asSessionFiles[uNdx].uBusy == 0)
			{
			memset(&asSessionFiles[uNdx], 0, sizeof(stDSFP));
			asSessionFiles[uNdx].uBusy = TRUE;
			return (uNdx + 1);
			}
		}

	return SF_ERR_BAD_PARAMETER;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfOpenSessionFile
 *
 * DESCRIPTION:
 *	This function is called to build an in memory data structure that
 *	represents the data currently in a session file.  If the file specified
 *	is not a valid session file, an error is returned.
 *
 * ARGUEMENTS:
 *	TCHAR *pszName	 --  the name of the session file.
 *
 * RETURNS:
 *	0 or an error code < 0;
 */
int sfOpenSessionFile(const SF_HANDLE sF, const TCHAR *pszName)
	{
	int uRv = 0;
	int uNdx = sF - 1;
	unsigned long uSize, uSize1;
	TCHAR *pszStr = NULL;
	TCHAR *pszPtr = NULL;
	HANDLE hFile;
	int sID, sOldID;
	int32 dwSZ;
	int nOrderOK;
	DWORD dw;

	if (uNdx >= SESS_FILE_MAX)
		{
		uRv = SF_ERR_BAD_PARAMETER;
		goto OSFexit;
		}

	if (asSessionFiles[uNdx].uBusy == 0)
		{
		uRv = SF_ERR_BAD_PARAMETER;
		goto OSFexit;
		}

	if (asSessionFiles[uNdx].fOpen)
		{
		uRv = SF_ERR_FILE_ACCESS;
		goto OSFexit;
		}

	if (pszName && (StrCharGetStrLength(pszName) > 0))
		{
		int nRv = -1;
		pstDSFP pD;
		pstDSII pI;
		pstDSII pIx;

		/*
		 * Do everything that can be done with a name
		 */
		asSessionFiles[uNdx].hFilename = (TCHAR *)malloc(FNAME_LEN * sizeof(TCHAR));

		if (asSessionFiles[uNdx].hFilename == NULL)
			goto OSFexit;

 		pszStr = asSessionFiles[uNdx].hFilename;

        TCHAR_Fill(pszStr, TEXT('\0'), FNAME_LEN);
        StrCharCopyN(pszStr, (LPTSTR)pszName, FNAME_LEN);
        pszStr = NULL;

		/*
		 * Try to open file.  If we can then proceed
		 */
		hFile = CreateFile(pszName, GENERIC_READ, 0, NULL,
						   OPEN_EXISTING, 0, NULL);

		/*
		 * Get the size of the file
		 */
		if (hFile == INVALID_HANDLE_VALUE)
			{
			asSessionFiles[uNdx].fOpen = TRUE;
			uRv = SF_ERR_FILE_ACCESS;
			return uRv;
			}
		else
			{
			/*
			 * Allocate a data block
			 */
			asSessionFiles[uNdx].fOpen = TRUE;

			uSize = GetFileSize(hFile, &dw);
			uSize = ROUND_UP(uSize);
			asSessionFiles[uNdx].dwDataSize = (int)uSize;
			asSessionFiles[uNdx].dwDataUsed = 0;
			asSessionFiles[uNdx].hData = (BYTE *)malloc(uSize);

			if (asSessionFiles[uNdx].hData == 0)
				{
				uRv = SF_ERR_MEMORY_ERROR;
				goto OSFexit;
				}

			pszStr = (TCHAR *)asSessionFiles[uNdx].hData;
			pszPtr = pszStr;
			memset(pszStr, 0, uSize * sizeof(TCHAR));

			/*
			 * Read in the header and check it
			 */
			//fread(pszPtr, 1, HDR_SIZE, f);
			if(HDR_SIZE > uSize)
				{
				CloseHandle(hFile);
				uRv = SF_ERR_FILE_FORMAT;
				goto OSFexit;
				}
			if (ReadFile(hFile, pszPtr, HDR_SIZE * sizeof(TCHAR), &dw, 0) == FALSE)
				{
				CloseHandle(hFile);
				uRv = SF_ERR_FILE_ACCESS;
				goto OSFexit;
				}

			if (memcmp(pszPtr, pszHdr, 10 * sizeof(TCHAR)) != 0)
				{
				CloseHandle(hFile);
				uRv = SF_ERR_FILE_FORMAT;
				goto OSFexit;
				}

			pszPtr += HDR_SIZE;
			asSessionFiles[uNdx].dwDataUsed += HDR_SIZE;

			/*
			 * Initialize the index
			 */
			asSessionFiles[uNdx].uItemCount = 0;
			asSessionFiles[uNdx].uItemsAlloc = 64;
			uSize1 = sizeof(stDSII) * 64;
			asSessionFiles[uNdx].hIndex = (pstDSII)malloc(uSize1);

			if (asSessionFiles[uNdx].hIndex == (pstDSII)0)
				{
				CloseHandle(hFile);
				uRv = SF_ERR_MEMORY_ERROR;
				goto OSFexit;
				}

			/*
			 * Read in the data items and add them to to structure
			 * The file is in the format:
			 *
			 *	USHORT	index
			 *	DWORD	dwSize
			 *	CHAR * size
			 */

			pD = &asSessionFiles[uNdx];

			pI = pD->hIndex;

			nOrderOK = TRUE;
			sOldID = 0;

			for (;;)
				{
				sID = 0;
				dwSZ = -1;

				if (ReadFile(hFile, &sID, sizeof(SHORT), &dw, 0) == FALSE)
					{
					CloseHandle(hFile);
					uRv = SF_ERR_FILE_ACCESS;
					goto OSFexit;
					}
				if (ReadFile(hFile, &dwSZ, sizeof(DWORD), &dw, 0) == FALSE)
					{
					CloseHandle(hFile);
					uRv = SF_ERR_FILE_ACCESS;
					goto OSFexit;
					}

				if ((sID == 0) && (dwSZ == -1))
					break;

				if ((sID == 0) && (dwSZ == 0))
					continue;

				if (sOldID > sID)
					{
					nOrderOK = FALSE;
					pI = (pstDSII)0;
					pszStr = NULL;
					}

				sOldID = sID;			/* For next time around */

				#if defined(DEBUG_OUTPUT)
				wsprintf(acBuffer,
						"r %c %d(0x%x) %d\r\n",
						nOrderOK ? 'a' : 'i',
						sID, sID, dwSZ);
				OutputDebugString(acBuffer);
				#endif

				if (nOrderOK)
					{
					// Do it inline

					if (pD->uItemCount >= pD->uItemsAlloc)
						{
						#if defined(DEBUG_OUTPUT)
						OutputDebugString("Index expanded\r\n");
						#endif
						/*
						 * We need to get a bigger chunk of memory
						 */
						if (pD->hIndex == (pstDSII)0)
							{
							pD->uItemsAlloc = 64;
							pD->hIndex = (pstDSII)malloc(sizeof(stDSII) * 64);
							}
						else
							{
							int      newSize = pD->uItemsAlloc * 2;
							stDSII * pTemphIndex = NULL;

							pTemphIndex = (pstDSII)
								realloc(pD->hIndex, (size_t)newSize * sizeof(stDSII));

							if (pTemphIndex == NULL)
								{
								uRv = SF_ERR_MEMORY_ERROR;
								goto OSFexit;
								}
							else
								{
								pD->uItemsAlloc = newSize;
								pD->hIndex = pTemphIndex;
								}
							}
						}

					if (pD->hData == 0)
						{
						pD->hData = (BYTE *)malloc(ROUND_UP(4096));
						pD->dwDataSize = ROUND_UP(4096);
						pD->dwDataUsed = 0;
						}

					/*
					 * Add the item at the end of the list
					 */
					nRv = pD->uItemCount;

					pIx = pI;
					pIx += nRv;

					pIx->uIndex = sID;
					pIx->dwSize = dwSZ;
					pIx->dwOffset = (DWORD)(pszPtr - pszStr);

					pD->uItemCount += 1;

					//fread(pszPtr, sSZ, 1, f);
					if( (DWORD)dwSZ > uSize )
						{
						CloseHandle(hFile);
						uRv = SF_ERR_FILE_FORMAT;
						goto OSFexit;
						}
					if (ReadFile(hFile, pszPtr, (DWORD)dwSZ, &dw, 0) == FALSE)
						{
						CloseHandle(hFile);
						uRv = SF_ERR_FILE_ACCESS;
						goto OSFexit;
						}

					pszPtr += dwSZ;
					asSessionFiles[uNdx].dwDataUsed += dwSZ;
					}
				else
					{
					TCHAR acBuffer[FNAME_LEN];

					//fread(acBuffer, dwSZ, 1, f);
					if( (DWORD)dwSZ > sizeof(acBuffer) )
						{
						CloseHandle(hFile);
						uRv = SF_ERR_FILE_FORMAT;
						goto OSFexit;
						}

					if (ReadFile(hFile, acBuffer, (DWORD)dwSZ, &dw, 0) == FALSE)
						{
						CloseHandle(hFile);
						uRv = SF_ERR_FILE_ACCESS;
						goto OSFexit;
						}
					sfPutSessionItem(uNdx + 1, (unsigned int)sID,
					    (unsigned long)dwSZ, acBuffer);
					}

				}

			/*
			 * Free things up
			 */

			CloseHandle(hFile);
			}

		return SF_OK;
		}

OSFexit:
	if (uNdx != SESS_FILE_MAX)
		{
		/*
		 * General cleanup
		 */
		if (asSessionFiles[uNdx].hFilename)
			{
			free(asSessionFiles[uNdx].hFilename);
			asSessionFiles[uNdx].hFilename = NULL;
			}

		if (asSessionFiles[uNdx].hData)
			{
			free(asSessionFiles[uNdx].hData);
			asSessionFiles[uNdx].hData = NULL;
			}

		if (asSessionFiles[uNdx].hIndex)
			{
			free(asSessionFiles[uNdx].hIndex);
			asSessionFiles[uNdx].hIndex = NULL;
			}

		memset(&asSessionFiles[uNdx], 0, sizeof(stDSFP));
		}

	return uRv;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfFlushSessionFile
 *
 * DESCRIPTION:
 *	This function is called to write all of the data in a session file out to
 *	disk and release any and all memory associated with the session file handle.
 *	It will not do anything if the session file does not have a file name
 *	associated with it.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	--	the session file handle
 *
 * RETURNS:
 *	ZERO if the file is written, an error code < 0 if there is and error.
 */
int sfFlushSessionFile(const SF_HANDLE sF)
	{
	int nRv = 0;
	int uNdx = sF - 1;
	int x;
	USHORT usIndex;
	TCHAR *pszName;
	TCHAR *pszPtr;
	pstDSII pI;
	HANDLE hFile;
	DWORD dw;

	if (uNdx >= SESS_FILE_MAX)
		{
		nRv = SF_ERR_BAD_PARAMETER;
		goto CSFexit;
		}

	if (asSessionFiles[uNdx].uBusy == 0)
		{
		nRv = SF_ERR_BAD_PARAMETER;
		goto CSFexit;
		}

	if (asSessionFiles[uNdx].fOpen == 0)
		{
		nRv = SF_ERR_FILE_ACCESS;
		goto CSFexit;
		}

	if (asSessionFiles[uNdx].uChanged != 0)
		{
		if (asSessionFiles[uNdx].hFilename == NULL)
			{
			nRv = SF_ERR_FILE_ACCESS;
			goto CSFexit;
			}

		pszName = asSessionFiles[uNdx].hFilename;

		/* TODO: put in code to create directorys as necessary */

		//f = fopen(pszName, "wb");

		hFile = CreateFile(pszName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);

		if (hFile == INVALID_HANDLE_VALUE)
			{
			nRv = SF_ERR_FILE_ACCESS;
			goto CSFexit;
			}

		pszPtr = (TCHAR *)asSessionFiles[uNdx].hData;

		/*
		 * Write out the header first
		 */
		if (StrCharGetStrLength(pszPtr) == 0)
			{
			/*
			 * Write out an empty header
			 */
			WriteFile(hFile, pszHdr, HDR_SIZE * sizeof(TCHAR), &dw, 0);
			}
		else
			{
			/*
			 * Write out the current header
			 */
			WriteFile(hFile, pszPtr, HDR_SIZE * sizeof(TCHAR), &dw, 0);
			}

		pszPtr += HDR_SIZE;


		pI = asSessionFiles[uNdx].hIndex;

		/*
		 * We loop thru the index and write out all of the stuff
		 */
		for (x = 0; x < asSessionFiles[uNdx].uItemCount; x += 1)
			{
			if (pI->dwSize != 0)
				{
				#if defined(DEBUG_OUTPUT)
				unsigned char acBuffer[64];

				wsprintf(acBuffer,
						"w %d(0x%x) %d\r\n",
						pI->uIndex, pI->uIndex, pI->dwSize);
				OutputDebugString(acBuffer);
				#endif

				usIndex = (USHORT)pI->uIndex;
				WriteFile(hFile, &usIndex, sizeof(USHORT), &dw, 0);
				WriteFile(hFile, &pI->dwSize, sizeof(DWORD), &dw, 0);

				WriteFile(hFile, pszPtr, (size_t)pI->dwSize * sizeof(TCHAR),
				    &dw, 0);

				pszPtr += pI->dwSize;
				}
		  	pI += 1;
			}

		CloseHandle(hFile);
		asSessionFiles[uNdx].uChanged = 0;

		// Finally, notify the shell so it can update the icon.
		//
		SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH,
			asSessionFiles[uNdx].hFilename, 0);
		}

CSFexit:

	return nRv;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfReleaseSessionFile
 *
 * DESCRIPTION:
 *	This function is called to release any and all memory associated with the
 *	session file handle.  This function by itself DOES NOT write any data out
 *	to the file.  That must be done elsewhere.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code < 0.
 */
int sfReleaseSessionFile(const SF_HANDLE sF)
	{
	unsigned int uNdx = (unsigned int)sF - 1;

	if (uNdx > SESS_FILE_MAX)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].uBusy == 0)
		return SF_ERR_BAD_PARAMETER;

	asSessionFiles[uNdx].uBusy = 0;

	if (asSessionFiles[uNdx].hFilename)
		{
		free(asSessionFiles[uNdx].hFilename);
		asSessionFiles[uNdx].hFilename = NULL;
		}

	if (asSessionFiles[uNdx].hData)
		{
		free(asSessionFiles[uNdx].hData);
		asSessionFiles[uNdx].hData = NULL;
		}

	if (asSessionFiles[uNdx].hIndex)
		{
		free(asSessionFiles[uNdx].hIndex);
		asSessionFiles[uNdx].hIndex = NULL;
		}

	memset(&asSessionFiles[uNdx], 0, sizeof(stDSFP));
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfCloseSessionFile
 *
 * DESCRIPTION:
 *	This function is called to release any and all memory associated with the
 *	session file handle.  This function by itself DOES NOT write any data out
 *	to the file.  That must be done elsewhere.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code < 0.
 */
int sfCloseSessionFile(const SF_HANDLE sF)
	{
	int rV1, rV2;

	rV1 = sfFlushSessionFile(sF);
	rV2 = sfReleaseSessionFile(sF);

	if (rV1 != 0)
		return rV1;

	return rV2;
	}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfGetSessionFileName
 *
 * DESCRIPTION:
 *	This function is called to return the file name currently associated with
 *	the session file handle.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *	INT nSize		-- the size of the following buffer
 *	PCHAR pszName	-- the address of the buffer to copy the name to
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code < 0;
 */
int sfGetSessionFileName(const SF_HANDLE sF, const int nSize, TCHAR *pszName)
	{
	int uNdx = sF - 1;
#if DEADWOOD
    TCHAR *pszStr = NULL;
    int len;
#endif

	if (uNdx > SESS_FILE_MAX)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].uBusy == 0)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].hFilename == NULL)
		return SF_ERR_BAD_PARAMETER;

    //
    // Use StrCharCopyN() to copy the filename into the buffer passed.
    // This will localize our revisions to the string manipulation
    // functions if needed at a later date. REV: 03/01/2001
    //
#if DEADWOOD
    pszStr = asSessionFiles[uNdx].hFilename;

	//strncpy(pszName, pszStr, nSize);


    // JYF 03-Dec-1998 we don't want to read more than strlen
    //  of pszStr and nSize so not to read from inaccessible
    //  memory when running with debug heap.

    len = min (nSize, lstrlen (pszStr)+1);
    MemCopy(pszName, pszStr, (size_t)len * sizeof(TCHAR));
    pszName[nSize-1] = TEXT('\0');
#else
    StrCharCopyN(pszName, asSessionFiles[uNdx].hFilename, nSize);
#endif

	return SF_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfSetSessionFileName
 *
 * DESCRIPTION:
 *	This function is called to change the name currently associated with the
 *	session file handle.  It does not cause the session file handle to reload
 *	any data or access the disk at all.  Data files are read when the session
 *	file is opened and written when the session file is closed.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *	PCHAR pszName	-- the address of the new file name
 *
 * RETURNS:
 *	ZERO if  everything is OK, otherwise and error code < 0;
 */
int sfSetSessionFileName(const SF_HANDLE sF, const TCHAR *pszName)
	{
	unsigned int uNdx = (unsigned int)sF - 1;
	TCHAR *pszStr = NULL;

    if (uNdx > SESS_FILE_MAX)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].uBusy == 0)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].fOpen == 0)
		return SF_ERR_FILE_ACCESS;

	if (asSessionFiles[uNdx].hFilename == NULL)
		{
		asSessionFiles[uNdx].hFilename = (TCHAR *)malloc(FNAME_LEN * sizeof(TCHAR));

		if (asSessionFiles[uNdx].hFilename == NULL)
			return SF_ERR_MEMORY_ERROR;
		}

	pszStr = asSessionFiles[uNdx].hFilename;

	TCHAR_Fill(pszStr, TEXT('\0'), FNAME_LEN);
	StrCharCopyN(pszStr, (LPTSTR)pszName, FNAME_LEN);
    pszStr = NULL;

	asSessionFiles[uNdx].uChanged = 1;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfGetSessionItem
 *
 * DESCRIPTION:
 *	This function is called to get data from the session file handle.  It can
 *	also be used to get the size of a data item.
 *
 *	If the last arguement, pvData, is NULL, then the size of the item is
 *	returned in *pulSize.  If pvData is not NULL, up to *pulSize bytes are
 *	returned at pvData.  If the number of bytes returned is less than *pulData,
 *	the new size is set in *pulSize.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *	uId				-- ID if the item
 *	pulSize			-- where the size is found or returned
 *	pvData			-- where the data is to be placed
 *
 * RETURNS:
 *	ZERO if  everything is OK, otherwise and error code < 0;
 */
int sfGetSessionItem(const SF_HANDLE sF,
					 const unsigned int uId,
					 unsigned long *pulSize,
					 void *pvData)
	{
	int     lReturn = SF_ERR_BAD_PARAMETER;
	int     uNdx = sF - 1;
	int     dwMinSize;
	int     low;
	int     mid;
	int     high;
	pstDSII pI;
	pstDSII pIx;
	BYTE *  pszData;

	if (uNdx > SESS_FILE_MAX)
		{
		lReturn = SF_ERR_BAD_PARAMETER;
		}
	else if (uNdx < 0)
		{
		lReturn = SF_ERR_BAD_PARAMETER;
		}
	else if (asSessionFiles[uNdx].uBusy == 0)
		{
		lReturn = SF_ERR_BAD_PARAMETER;
		}
	else if (asSessionFiles[uNdx].fOpen == 0)
		{
		lReturn = SF_ERR_FILE_ACCESS;
		}
	else if (asSessionFiles[uNdx].uItemCount == 0)
		{
		lReturn = SF_ERR_BAD_PARAMETER;
		}
	else if ((uId < 1) || (uId > 0x7FFF))
		{
		lReturn = SF_ERR_BAD_PARAMETER;
		}
	/*
	 * See if the item is in the index
	 */
	else if (asSessionFiles[uNdx].hIndex == (pstDSII)0)
		{
		lReturn = SF_ERR_BAD_PARAMETER;
		}
	else
		{
		pI = asSessionFiles[uNdx].hIndex;

		low = 0;
		high = asSessionFiles[uNdx].uItemCount - 1;

		while (low <= high)
			{
			mid = (low + high) / 2;
			pIx = pI + mid;

			if ((int)uId < pIx->uIndex)
				{
				high = mid - 1;
				}
			else if ((int)uId > pIx->uIndex)
				{
				low = mid + 1;
				}
			else
				{
				/*
				 * Found the item, see what they want to know
				 */
				if (pvData == NULL)
					{
					*pulSize = (unsigned long)pIx->dwSize;
					}
				else
					{
					pszData = asSessionFiles[uNdx].hData;
					dwMinSize = (int)*pulSize;

					if (dwMinSize > pIx->dwSize)
						{
						dwMinSize = pIx->dwSize;
						}

					if (dwMinSize)
						{
						MemCopy(pvData, pszData + pIx->dwOffset, (size_t)dwMinSize);
						}
					}

				lReturn = SF_OK;
				break;
				}
			}
		}

	return lReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfCompareSessionItem
 *
 * DESCRIPTION:
 *	This function is called to check and see if an item exists in the data
 *	and if it is the same as the passed in item.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *	uId				-- the ID of the item
 *	ulSize			-- the size of the item
 *	pvData			-- address of the data
 *
 * RETURNS:
 *	TRUE if the two items are the same, otherwise false.
 */
int sfCompareSessionItem(const SF_HANDLE sF,
						 const unsigned int uId,
						 const unsigned long ulSize,
						 const void *pvData)
	{
	int uNdx = sF - 1;
	int low, mid, high;
	pstDSII pI;
	pstDSII pIx;
	BYTE *pszData;

	/*
	 * See if the item is in the index
	 */
	if (asSessionFiles[uNdx].hIndex == (pstDSII)0)
		return FALSE;

	pI = asSessionFiles[uNdx].hIndex;

	low = 0;
	high = asSessionFiles[uNdx].uItemCount - 1;

	while (low <= high)
		{
		mid = (low + high) / 2;
		pIx = pI + mid;

		if ((int)uId < pIx->uIndex)
			high = mid - 1;

		else if ((int)uId > pIx->uIndex)
			low = mid + 1;

		else
			{
			/*
			 * Check and see if the sizes are the same
			 */
			if (ulSize != (unsigned long)pIx->dwSize)
				return FALSE;

			/*
			 * Check and see if the data is the same
			 */
			pszData = asSessionFiles[uNdx].hData + pIx->dwOffset;

			if (memcmp((BYTE *)pvData, pszData, ulSize) == 0)
				return TRUE;
			return FALSE;
			}
		}
	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sfPutSessionItem
 *
 * DESCRIPTION:
 *	This function is called to add or modify an entry in the session file data
 *	associated with the current session file handle.  It does not cause the
 *	actual session file itself to be written.  That is done only when the
 *	session file handle is closed.
 *
 * ARGUEMENTS:
 *	SF_HANDLE sF	-- the session file handle
 *	uId				-- the ID of the item
 *	ulSize			-- the size of the item
 *	pvData			-- address of the data
 *
 * RETURNS:
 *	ZERO if  everything is OK, otherwise and error code < 0;
 */
int sfPutSessionItem(const SF_HANDLE sF,
					 const unsigned int uId,
					 const unsigned long ulSize,
					 const void *pvData)
	{
	int uNdx = sF - 1;
	int x, y;
	int32 dwSlide;
	int32 dwOffset;
	int32 dwNewSize;
	pstDSII pI;
	pstDSII pIx, pIy;
	BYTE *pszData;

#if defined(DEBUG_OUTPUT)
	unsigned char acBuffer[80];
#endif

	if (uNdx > SESS_FILE_MAX)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].uBusy == 0)
		return SF_ERR_BAD_PARAMETER;

	if (asSessionFiles[uNdx].fOpen == 0)
		return SF_ERR_FILE_ACCESS;

	if ((uId < 1) || (uId > 0x7FFF))
		return SF_ERR_BAD_PARAMETER;

	if (sfCompareSessionItem(sF, uId, ulSize, pvData))
		return SF_OK;

	x = sfAddToIndex(uNdx, (unsigned short)uId, 0, 0);

	pI = asSessionFiles[uNdx].hIndex;

	if (x != (-1))
		{
		pIx = pI + x;
		if (pIx->dwSize == 0)
			{
			/*
			 * Its a new item
			 */
			dwSlide = (int32)ulSize;
			if (x == 0)
				dwOffset = HDR_SIZE;
			else
				dwOffset = (pI+x-1)->dwOffset + (pI+x-1)->dwSize;

			#if defined(DEBUG_OUTPUT)
			wsprintf(acBuffer,
					"New 0x%x slide %d offset 0x%x",
					uId, dwSlide, dwOffset);
			OutputDebugString(acBuffer);
			#endif
			}
		else
			{
			/*
			 * Its a replacement item
			 */
			dwSlide = (int)ulSize - (int)pIx->dwSize;
			dwOffset = pIx->dwOffset;

			#if defined(DEBUG_OUTPUT)
			wsprintf(acBuffer,
					"Rep 0x%x slide %d offset 0x%x",
					uId, dwSlide, dwOffset);
			OutputDebugString(acBuffer);
			#endif
			}

		/*
		 * Check the memory requirements
		 */
		dwNewSize = asSessionFiles[uNdx].dwDataUsed + dwSlide;

		if (dwNewSize > asSessionFiles[uNdx].dwDataSize)
			{
			/*
			 * Need to allocate a new chunk of memory
			 */
			BYTE *hG =(BYTE *)
				realloc(asSessionFiles[uNdx].hData, ROUND_UP(dwNewSize));

			if (hG == NULL)
				{
				return SF_ERR_MEMORY_ERROR;
				}
			else
				{
				asSessionFiles[uNdx].hData = hG;
				asSessionFiles[uNdx].dwDataSize = ROUND_UP(dwNewSize);
				}
			}

		/*
		 * Move the old data to the point necessary
		 */
		pszData = asSessionFiles[uNdx].hData;
		asSessionFiles[uNdx].dwDataUsed = dwNewSize;

		if (dwSlide < 0)
			{
			/* shrink the current space */
			dwNewSize = asSessionFiles[uNdx].dwDataSize;
			dwNewSize -= dwOffset;
			dwNewSize += dwSlide;

			memmove(pszData + dwOffset, 			 /* destination */
					pszData + dwOffset - dwSlide,	 /* source */
					(size_t)(dwNewSize - 1));		 /* count */

			#if defined(DEBUG_OUTPUT)
			wsprintf(acBuffer,
					" shrink from 0x%lx to 0x%lx size 0x%x\r\n",
					(long)(pszData + dwOffset - dwSlide),
					(long)(pszData + dwOffset),
					dwNewSize -1);
			OutputDebugString(acBuffer);
			#endif
			}
		else
			{
			/* expand the current space */
			dwNewSize = asSessionFiles[uNdx].dwDataSize;
			dwNewSize -= dwOffset;
			dwNewSize -= dwSlide;

			memmove(pszData + dwOffset + dwSlide,	 /* destination */
					pszData + dwOffset, 			 /* source */
					(size_t)(dwNewSize - 1)); 		 /* count */

			#if defined(DEBUG_OUTPUT)
			wsprintf(acBuffer,
					" expand from 0x%lx to 0x%lx size 0x%x\r\n",
					(long)(pszData + dwOffset),
					(long)(pszData + dwOffset + dwSlide),
					dwNewSize - 1);
			OutputDebugString(acBuffer);
			#endif
			}

		/*
		 * Copy in the new data
		 */
		memmove(pszData + dwOffset, 				/* destination */
				pvData, 							/* source */
				(unsigned int)ulSize);				/* count */


		/*
		 * Update the item in the index for the current item
		 */
		pIx->dwSize = (int32)ulSize;
		pIx->dwOffset = dwOffset;

		/*
		 * Adjust all the following items in the index
		 */
		for (y = x + 1; y < (int)asSessionFiles[uNdx].uItemCount; y += 1)
			{
			pIy = pI + y;
			pIy->dwOffset += dwSlide;
			}

		asSessionFiles[uNdx].uChanged = 1;
		return 0;
		}

	return SF_ERR_BAD_PARAMETER;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sf_data.h ===
/*	File: D:\WACKER\tdll\sf_data.h (Created: 16-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:37p $
 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Error codes */
#define	SFD_ERR_BASE		0x200
#define	SFD_NO_MEMORY		SFD_ERR_BASE+1
#define	SFD_BAD_POINTER		SFD_ERR_BASE+2
#define	SFD_SIZE_ERROR		SFD_ERR_BASE+3

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Generic data structure */

struct stDataPointer
	{
	int nSize;
	};

typedef struct stDataPointer SF_DATA;

#define	SFD_MAX		(32*1024)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

extern int sfdGetDataBlock(const HSESSION hSession,
							const int nId,
							const void **ppData);

extern int sfdPutDataBlock(const HSESSION hSession,
							const int nId,
							const void *pData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\stdtyp.h ===
/*	File: D:\WACKER\tdll\stdtyp.h (Created: 30-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 7/08/02 6:49p $
 */

/* This needs to be here because it can change the way ECHAR is defined. */
#include "features.h"

#if !defined(INCL_STDTYP)
#define INCL_STDTYP

/* --- Define all handles here --- */

typedef struct stSessionExt 		 *HSESSION;
typedef struct stLayoutExt			 *HLAYOUT;
typedef struct stUpdateExt			 *HUPDATE;
typedef struct stEmulExt			 *HEMU;
typedef struct stCnctExt			 *HCNCT;
typedef struct s_com				 *HCOM;
typedef struct stCLoopExt			 *HCLOOP;
typedef struct stXferExt			 *HXFER;
typedef struct stBckScrlExt 		 *HBACKSCRL;
typedef struct stPrintExt			 *HPRINT;
typedef struct stTimerMuxExt		 *HTIMERMUX;
typedef struct stTimerExt			 *HTIMER;
typedef struct stFilesDirs			 *HFILES;
typedef struct stCaptureFile         *HCAPTUREFILE;
typedef struct stTranslateExt		 *HTRANSLATE;

/* --- This one is a little different --- */
#define	SF_HANDLE	int


/* --- Other HA specific types --- */
typedef unsigned KEY_T; 			// for internal key representation
typedef unsigned KEYDEF; 			// for internal key representation
typedef unsigned short RCDATA_TYPE; // for reading resources of type RCDATA

// Character type used by Emulator and Terminal display routines
// 
#if defined(CHAR_NARROW)
    typedef char ECHAR;
	#define ETEXT(x) (ECHAR)x
#else
	typedef unsigned short ECHAR;
	#define ETEXT(x) (ECHAR)x
#endif

/* --- TRUE/FALSE macros --- */

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE 1
#endif


/* --- HA5 code references this stuff alot --- */

#define DIM(a) (sizeof(a) / sizeof(a[0]))
#define IN_RANGE(n, lo, hi) ((lo) <= (n) && (n) <= (hi))
#define bitset(t, b) ((t) |= (b))
#define bitclear(t, b) ((t) &= (~(b)))
#define bittest(t, b) ((t) & (b))

#define startinterval() 	GetTickCount()
#define interval(X) 		((GetTickCount()-(DWORD)X)/100L)

#define WINDOWSBORDERWIDTH max(GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CXEDGE))
#define WINDOWSBORDERHEIGHT max(GetSystemMetrics(SM_CYBORDER), GetSystemMetrics(SM_CYEDGE))

/* --- Just for now --- */

#define STATIC_FUNC	static
#define	FNAME_LEN	MAX_PATH
#define	PRINTER_NAME_LEN	80

#endif	/* --- end stdtyp.h --- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\statusbr.h ===
/*	File: D:\WACKER\tdll\statusbr.h (Created: 08-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:41p $
 */

//
// Defines...
//
#define EXTRASPACE	(UINT)8

#define SBR_NTFY_REFRESH	(WM_USER+0x400)	// Update the statusbar display
#define SBR_NTFY_TIMER		(WM_USER+0x401) // Update time connected display
#define SBR_NTFY_NOPARTS	(WM_USER+0x402)	// Set status bar to show no parts
#define SBR_NTFY_INITIALIZE (WM_USER+0x403) // Calculate part sizes... once
#define SBR_NTFY_DRAWITEM	(WM_USER+0x404)	// DrawItem

#define SBR_ATOM_NAME		"PROP_SBRDATA"

#define YEAR(t)		(t << 9)
#define MONTH(t)	(t << 5)
#define HOUR(t)		(t << 11)
#define MINUTE(t)	(t << 5)
#define SECOND(t)	(t >> 1)

#define SBR_MAX_PARTS		8				// Maximum number of parts
#define SBR_CNCT_PART_NO	0				// connection status
#define SBR_EMU_PART_NO 	1				// emulator
#define SBR_COM_PART_NO 	2				// Com part
#define SBR_SCRL_PART_NO	3				// scroll lock
#define SBR_CAPL_PART_NO	4				// caps lock
#define SBR_NUML_PART_NO	5				// num lock
#define SBR_CAPT_PART_NO	6				// capture
#define SBR_PRNE_PART_NO	7				// print echo
#define SBR_ALL_PARTS		98
#define SBR_KEY_PARTS		99				// All key parts, SCRL, NUML, CAPL

typedef struct SBR
	{
	WNDPROC 	wpOrigStatusbarWndProc;		// Original Statusbar window proc
	HWND		hwnd;						// Statusbar window

	HSESSION	hSession;                   // Session handle
	HTIMER		hTimer;						// Timer used to update clocks
	int			iLastCnctStatus;			// Last connection status
	int			aWidths[SBR_MAX_PARTS];		// Statusbar part widths

	// Since we look at all string ahead of time to determine their length
	// and adjust the statusbar parts accordingly, we migth as well remember
	// the strings we read from the resource file. This saves us alot of
	// LoadString() calls.
	//
	LPTSTR		pachCNCT;					// Connected + time...
	LPTSTR		pachCAPL;					// CAP Lock label
	LPTSTR		pachNUML;					// NUM Lock label
	LPTSTR		pachSCRL;					// SCR Lock label
	LPTSTR		pachPECHO;					// Print Echo label
	LPTSTR		pachCAPT;					// Capture label
	LPTSTR		pachCOM;					// Com label

	} SBR, *pSBR;


//
// Function prototypes...
//
HWND sbrCreateSessionStatusbar(HSESSION hSession);

LRESULT APIENTRY sbrWndProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
void CALLBACK sbrTimerProc(void *pvData, long uTime);
void sbr_WM_DRAWITEM(HWND hwnd, LPDRAWITEMSTRUCT lpdis);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sidebar.c ===
/*	File: D:\WACKER\tdll\sidebar.c (Created: 10-Mar-1995)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 12 $
 *	$Date: 4/16/02 2:41p $
 */

#include <windows.h>
#include "stdtyp.h"
#include "globals.h"
#include "assert.h"
#include "session.h"
#include <term\res.h>
#include <emu\emu.h>
#include "htchar.h"

#define INDENT 3
#define SIDEBAR_CLASS	"sidebar class"
#define LOSHORT(x)	((short)LOWORD(x))
#define HISHORT(x)	((short)HIWORD(x))

static void SB_WM_SIZE(const HWND hwnd, const int cx, const int cy);
LRESULT CALLBACK SidebarButtonProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);

// I know, a static.  Bad news but not really.	Since this is just for
// the minitel I didn't want to screw around with local atoms.  If we
// ever decide that this stuff will be used for more general purposes,
// we can put in the atoms
//
static WNDPROC fpSidebarButtonProc;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateSidebar
 *
 * DESCRIPTION:
 *	Creates a sidebar.	What's a sidebar you say?  Its a bar with buttons
 *	on it running down the left side of the session window.  It is used
 *	only for the minitel emulator and displays buttons specific to that
 *	emulator.
 *
 * ARGUMENTS:
 *	hwndSession - session window handle.
 *
 * RETURNS:
 *	sidebar window handle.
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
HWND CreateSidebar(const HWND hwndSession, const HSESSION hSession)
	{
	UINT i;
	TCHAR ach[100];
	HWND hwnd;
	HWND hwndSideBar;
	SIZE sz;
	LONG cx = 0;
	LONG cy = 0;
	HDC  hdc;
	HGDIOBJ hFont;

	// Figure out the longest string to size things by
	//
	hdc = GetDC(hwndSession);
	hFont = GetStockObject(DEFAULT_GUI_FONT);
	SelectObject(hdc, hFont);

	for (i = 0 ; i < 9 ; ++i)
		{
		LoadString(glblQueryDllHinst(), IDS_SIDEBAR_INDEX+i, ach,
			sizeof(ach) / sizeof(TCHAR));

		GetTextExtentPoint32(hdc, ach, StrCharGetStrLength(ach), &sz);
		cx = max(sz.cx, cx);
		cy = max(sz.cy, cy);
		}

	ReleaseDC(hwndSession, hdc);

	// Good button size is 1.5 times text height.  Also add padding
	// for horizontal diretion.
	//
	cx += WINDOWSBORDERWIDTH * 10;
	cy = (LONG)(cy * 1.5);

	// Create sidebar window with proper x dimension
	//
	hwndSideBar = CreateWindowEx(WS_EX_CLIENTEDGE, SIDEBAR_CLASS, 0,
		WS_CHILD, 0, 0, cx+2+(2*INDENT), 100, hwndSession,
		(HMENU)IDC_SIDEBAR_WIN, glblQueryDllHinst(), hSession);

	// Important: Set fpSidebarButtonProc to zero here.  It may have
	// been initialized by an earlier instance.  We could set it to
	// zero in the WM_DESTROY but then I'ld have to keep a list of
	// button window handles which I don't want to do here.
	//
	fpSidebarButtonProc = 0;

	// Create buttons for sidebar and postion with text
	//
	for (i = 0 ; i < 9 ; ++i)
		{
		LoadString(glblQueryDllHinst(), IDS_SIDEBAR_INDEX+i, ach, sizeof(ach) / sizeof(TCHAR));

		hwnd = CreateWindowEx(0, "BUTTON", ach,
			WS_CHILD | WS_VISIBLE | BS_LEFT | BS_PUSHBUTTON,
			0, 0, cx, cy, hwndSideBar,
			(HMENU)IntToPtr(IDM_MINITEL_INDEX+i), glblQueryDllHinst(), 0);

        if ( hwnd == NULL )
            {
            assert( hwnd );
            return 0;
            }

		SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, 0);
		MoveWindow(hwnd, INDENT, ((int)i*(cy+INDENT))+INDENT, cx, cy, FALSE);

		// Need to subclass the buttons so that they don't get the focus
		// rectangle left on them.	This will require an atom to so that
		// we can get the original button proc.
		//
		if (fpSidebarButtonProc == 0)
			fpSidebarButtonProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);

		if (fpSidebarButtonProc)
			SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)SidebarButtonProc);
		}

	return hwndSideBar;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SidebarProc
 *
 * DESCRIPTION:
 *	Sidebar window proc.
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
LRESULT CALLBACK SidebarProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	HSESSION hSession;

	switch (uMsg)
		{
	case WM_CREATE:
		// Save session handle for later
		//
		SetWindowLongPtr(hwnd, GWLP_USERDATA,
			(LONG_PTR)((LPCREATESTRUCT)lPar)->lpCreateParams);

		return 0;

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
			case IDM_MINITEL_INDEX:
			case IDM_MINITEL_CANCEL:
			case IDM_MINITEL_PREVIOUS:
			case IDM_MINITEL_REPEAT:
			case IDM_MINITEL_GUIDE:
			case IDM_MINITEL_CORRECT:
			case IDM_MINITEL_NEXT:
			case IDM_MINITEL_SEND:
			case IDM_MINITEL_CONFIN:
				if (HIWORD(wPar) == BN_CLICKED)
					{
					hSession = (HSESSION)GetWindowLongPtr(hwnd, GWLP_USERDATA);

					emuMinitelSendKey(sessQueryEmuHdl(hSession),
						LOWORD(wPar));

					SetFocus(sessQueryHwnd(hSession));
					}

				break;

			default:
				break;
			}
		break;

	case WM_SIZE:
		SB_WM_SIZE(hwnd, LOSHORT(lPar), HISHORT(lPar));
		return 0;

	default:
		break;
		}

	return DefWindowProc(hwnd, uMsg, wPar, lPar);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SB_WM_SIZE
 *
 * DESCRIPTION:
 *	Sizing logic for sidebar.  This routine sizes the sidebar vertically
 *	to the session window.
 *
 * ARGUMENTS:
 *	hwnd		- sidebar window handle
 *	cx			- x size of window
 *	cy			- y size of window
 *
 * RETURNS:
 *	void
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
static void SB_WM_SIZE(const HWND hwnd, const int cx, const int cy)
	{
	RECT rc;
	RECT rcSB;
	RECT rcTmp;
	const HSESSION hSession = (HSESSION)GetWindowLongPtr(GetParent(hwnd),
							  GWLP_USERDATA);
	const HWND hwndToolbar = sessQueryHwndToolbar(hSession);
	const HWND hwndStatusbar = sessQueryHwndStatusbar(hSession);

	if (cx != 0 || cy != 0)
		return;

	GetWindowRect(hwnd, &rcSB);
	GetClientRect(GetParent(hwnd), &rc);

	if (IsWindow(hwndToolbar) && IsWindowVisible(hwndToolbar))
		{
		GetWindowRect(hwndToolbar, &rcTmp);
		rc.top += (rcTmp.bottom - rcTmp.top);
		}

	if (IsWindow(hwndStatusbar) && IsWindowVisible(hwndStatusbar))
		{
		GetWindowRect(hwndStatusbar, &rcTmp);
		rc.bottom -= (rcTmp.bottom - rcTmp.top);
		rc.bottom += 2 * WINDOWSBORDERHEIGHT;
		}

	MoveWindow(hwnd, rc.left, rc.top, rcSB.right-rcSB.left, rc.bottom-rc.top,
		TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	RegisterSidebarClass
 *
 * DESCRIPTION:
 *	Registers the sidebar window class used for Minitel.
 *
 * ARGUMENTS:
 *	hInstance	- instance handle of program.
 *
 * RETURNS:
 *	TRUE/FALSE
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
BOOL RegisterSidebarClass(const HINSTANCE hInstance)
	{
	WNDCLASSEX  wc;

	memset(&wc, 0, sizeof(WNDCLASSEX));
	wc.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hInstance, SIDEBAR_CLASS, &wc) == FALSE)
		{
		wc.style		 = CS_HREDRAW | CS_VREDRAW;
		wc.lpfnWndProc	 = SidebarProc;
		wc.cbClsExtra	 = 0;
		wc.cbWndExtra	 = sizeof(LONG_PTR);
		wc.hInstance	 = hInstance;
		wc.hIcon		 = NULL;
		wc.hCursor		 = LoadCursor(0, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
		wc.lpszMenuName  = NULL;
		wc.lpszClassName = SIDEBAR_CLASS;
		wc.hIconSm       = NULL;


		if (RegisterClassEx(&wc) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SidebarButtonProc
 *
 * DESCRIPTION:
 *	Don't you just love windows.  I don't want the focus to ever remain
 *	on the Sidebar but to do this with standard buttons I have to subclass
 *	them.
 *
 * AUTHOR: Mike Ward, 13-Mar-1995
 */
LRESULT CALLBACK SidebarButtonProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	HSESSION hSession;
	POINT pt;
	RECT  rc;

	switch (uMsg)
		{
	case WM_LBUTTONUP:
		hSession = (HSESSION)GetWindowLongPtr(GetParent(hwnd), GWLP_USERDATA);

		// Well, its never simple.  If the user clicks on the button, we don't
		// reset focus else our sidebar never receives the notification.  If
		// the user holds the button down however and drags off the button
		// and then lets up (button up not on the button) then we need to
		// set focus. - mrw.
		//
		pt.x = LOWORD(lPar);
		pt.y = HIWORD(lPar);
		GetClientRect(hwnd, &rc);

		if (!PtInRect(&rc, pt))
			SetFocus(sessQueryHwnd(hSession));

		break;

	default:
		break;
		}

	return CallWindowProc(fpSidebarButtonProc, hwnd, uMsg, wPar, lPar);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	UnregisterSidebarClass
 *
 * DESCRIPTION:
 *	Registers the sidebar window class used for Minitel.
 *
 * ARGUMENTS:
 *	hInstance	- instance handle of program.
 *
 * RETURNS:
 *	TRUE/FALSE
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
BOOL UnregisterSidebarClass(const HINSTANCE hInstance)
	{
	return UnregisterClass(SIDEBAR_CLASS, hInstance);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\sf.h ===
/*	File: D:\WACKER\tdll\sf.h (Created: 27-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:38p $
 */

#if !defined(INCL_SF)
#define INCL_SF

#if !defined(SF_HANDLE)
#define SF_HANDLE int
#endif

/*
 * Function prototypes
 */

SF_HANDLE CreateSysFileHdl(void);

int sfOpenSessionFile(const SF_HANDLE, const TCHAR *);

int sfCloseSessionFile(const SF_HANDLE);

int sfFlushSessionFile(const SF_HANDLE);

int sfReleaseSessionFile(const SF_HANDLE);

int sfGetSessionFileName(const SF_HANDLE, const int, TCHAR *);

int sfSetSessionFileName(const SF_HANDLE, const TCHAR *);

int sfGetSessionItem(const SF_HANDLE,
					 const unsigned int,
					 unsigned long *,
					 void *);

int sfPutSessionItem(const SF_HANDLE,
					 const unsigned int,
					 const unsigned long,
					 const void *);

/*
 * Error codes
 */

#define SF_OK					 0
#define SF_ERR_FILE_FORMAT		-1
#define SF_ERR_MEMORY_ERROR		-2
#define SF_ERR_BAD_PARAMETER	-3
#define SF_ERR_FILE_TOO_LARGE	-4
#define SF_ERR_FILE_ACCESS		-5

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\tchar.c ===
/*	File: D:\WACKER\tdll\tchar.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 19 $
 *	$Date: 7/08/02 6:49p $
 */

#include <windows.h>
#pragma hdrstop

#include <tchar.h>

#include "stdtyp.h"
#include "tdll.h"
#include "assert.h"
#include "htchar.h"
#include "mc.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TCHAR_Fill
 *
 * DESCRIPTION:
 *	Fills a TCHAR string with the specified TCHAR.
 *
 * ARGUMENTS:
 *	dest	- string to fill.
 *	c		- character to fill string with.
 *	size_t	- number of TCHAR units to copy.
 *
 * RETURNS:
 *	pointer to string.
 *
 */
TCHAR *TCHAR_Fill(TCHAR *dest, TCHAR c, size_t count)
	{
#if defined(UNICODE)
	int i;

	for (i = 0 ; i < count ; ++i)
		dest[i] = c;

	return dest;

#else

	return (TCHAR *)memset(dest, c, count);

#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TCHAR_Trim
 *
 * DESCRIPTION:
 *	This function is called to clean up user input.  It strips all white
 *	space from the front and rear of a string.  Sometimes nothing is left.
 *
 *	NOTE: This won't work on strings > 512 bytes
 *
 * ARGUEMENTS:
 *	pszStr     -- the string to trim
 *
 * RETURNS:
 *	pointer to the string
 */
TCHAR *TCHAR_Trim(TCHAR *pszStr)
	{
	int nExit;
	TCHAR *pszPtr;
	TCHAR *pszLast;
	TCHAR acBuf[512];

	/* Skip the leading white space */
	for (nExit = FALSE, pszPtr = pszStr; nExit == FALSE; )
		{
		switch (*pszPtr)
			{
			/* Anything here is considered white space */
			case 0x20:
			case 0x9:
			case 0xA:
			case 0xB:
			case 0xC:
			case 0xD:
				pszPtr += 1;		/* Skip the white space */
				break;
			default:
				nExit = TRUE;
				break;
			}
		}

	if ((unsigned int)lstrlen(pszPtr) > sizeof(acBuf))
		{
		return NULL;
		}

	lstrcpy(acBuf, pszPtr);

	/* Find the last non white space character */
	pszPtr = pszLast = acBuf;
	while (*pszPtr != TEXT('\0'))
		{
		switch (*pszPtr)
			{
			/* Anything here is considered white space */
			case 0x20:
			case 0x9:
			case 0xA:
			case 0xB:
			case 0xC:
			case 0xD:
				break;
			default:
				pszLast = pszPtr;
				break;
			}
		pszPtr += 1;
		}
	pszLast += 1;
	*pszLast = TEXT('\0');

	lstrcpy(pszStr, acBuf);

	return pszStr;
	}

#if 0 // Thought I needed this but I didn't.  May be useful someday however.
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TCHAR_Trunc
 *
 * DESCRIPTION:
 *	Removes trailing space from a character array.	Does not assume
 *
 * ARGUMENTS:
 *	psz - string of characters (null terminated).
 *
 * RETURNS:
 *	Length of truncated string
 *
 */
int TCHAR_Trunc(const LPTSTR psz)
	{
	int i;

	for (i = lstrlen(psz) - 1 ; i > 0 ; --i)
		{
		switch (psz[i])
			{
		/* Whitespace characters */
		case TEXT(' '):
		case TEXT('\t'):
		case TEXT('\n'):
		case TEXT('\v'):
		case TEXT('\f'):
		case TEXT('\r'):
			break;

		default:
			psz[i+1] = TEXT('\0');
			return i;
			}
		}

	return i;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharNext
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharNext(LPCTSTR pszStr)
	{
	LPTSTR pszRet = (LPTSTR)NULL;

	if (pszStr != (LPTSTR)NULL)
		{
#if defined(CHAR_MIXED)
		/* Could be done with 'IsDBCSLeadByte' etc. */
		pszRet = CharNextExA(0, pszStr, 0);
#else
		pszRet = (LPTSTR)pszStr + 1;
#endif
		}
	return pszRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharPrev
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharPrev(LPCTSTR pszStart, LPCTSTR pszStr)
	{
	LPTSTR pszRet = (LPTSTR)NULL;

	if ((pszStart != (LPTSTR)NULL) && (pszStr != (LPTSTR)NULL))
		{
#if defined(CHAR_MIXED)
		pszRet = CharPrev(pszStart, pszStr);
#else
		if (pszStr > pszStart)
			pszRet = (LPTSTR)pszStr - 1;
		else
			pszRet = (LPTSTR)pszStart;
#endif
		}

	return pszRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharLast
 *
 * DESCRIPTION:
 *	Returns a pointer to the last character in a string
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharLast(LPCTSTR pszStr)
	{
	LPTSTR pszRet = (LPTSTR)NULL;

	if (pszStr != (LPTSTR)NULL)
		{
#if defined(CHAR_MIXED)
		while (*pszStr != TEXT('\0'))
			{
			pszRet = (LPTSTR)pszStr;
			pszStr = CharNextExA(0, pszStr, 0);
			}
#else
		/* It might be possible to use 'strlen' here. Then again... */
		// pszRet = pszStr + StrCharGetByteCount(pszStr) - 1;
		pszRet = (LPTSTR)pszStr + lstrlen(pszStr) - 1;
#endif
		}
	return pszRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharEnd
 *
 * DESCRIPTION:
 *	Returns a pointer to the NULL terminating a string
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharEnd(LPCTSTR pszStr)
	{

	if (pszStr != (LPTSTR)NULL)
		{
#if defined(CHAR_MIXED)
		while (*pszStr != TEXT('\0'))
			{
			pszStr = StrCharNext(pszStr);
			pszStr += 1;
			}
#else
		pszStr = pszStr + lstrlen(pszStr);
#endif
		}
	return (LPTSTR)pszStr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharFindFirst
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharFindFirst(LPCTSTR pszStr, int nChar)
	{
#if defined(CHAR_MIXED)
	WORD *pszW;
#endif

	if (pszStr != (LPTSTR)NULL)
		{
#if defined(CHAR_MIXED)
		while (*pszStr != TEXT('\0'))
			{
			/*
			 * NOTE: this may not work for UNICODE
			 */
			if (nChar > 0xFF)
				{
				/* Two byte character */
				if (IsDBCSLeadByte(*pszStr))
					{
					pszW = (WORD *)pszStr;
					if (*pszW == (WORD)nChar)
						return (LPTSTR)pszStr;
					}
				}
			else
				{
				/* Single byte character */
				if (*pszStr == (TCHAR)nChar)
					return (LPTSTR)pszStr;
				}
			pszStr = CharNextExA(0, pszStr, 0);
			}
#else
		while (pszStr && (*pszStr != TEXT('\0')) )
			{
			if (*pszStr == (TCHAR)nChar)
				return (LPTSTR)pszStr;

			pszStr = StrCharNext(pszStr);
			}
#endif
		}
	return (LPTSTR)NULL;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharFindLast
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharFindLast(LPCTSTR pszStr, int nChar)
	{
	LPTSTR pszRet = (LPTSTR)NULL;
#if defined(CHAR_MIXED)
	WORD *pszW;
#else
	LPTSTR pszEnd;
#endif

	if (pszStr != (LPTSTR)NULL)
		{
#if defined(CHAR_MIXED)
		while (*pszStr != TEXT('\0'))
			{
			/*
			 * NOTE: this may not work for UNICODE
			 */
			if (nChar > 0xFF)
				{
				/* Two byte character */
				if (IsDBCSLeadByte(*pszStr))
					{
					pszW = (WORD *)pszStr;
					if (*pszW == (WORD)nChar)
						pszRet = (LPTSTR)pszStr;
					}
				}
			else
				{
				/* Single byte character */
				if (*pszStr == (TCHAR)nChar)
					pszRet = (LPTSTR)pszStr;
				}
			pszStr = CharNextExA(0, pszStr, 0);
			}
#else
		pszEnd = StrCharLast(pszStr);
		while (pszEnd && (pszEnd > pszStr) )
			{
			if (*pszEnd == (TCHAR)nChar)
				{
				pszRet = (LPTSTR)pszEnd;
				break;
				}
			pszEnd = StrCharPrev(pszStr, pszEnd);
			}
#endif
		}
	return pszRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharGetStrLength
 *
 * DESCRIPTION:
 *	This function returns the number of characters in a string.  A two byte
 *	character counts as one.
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharGetStrLength(LPCTSTR pszStr)
	{
	int nRet = 0;

#if DEADWOOD
#if defined(CHAR_MIXED)
	if (pszStr != (LPTSTR)NULL)
		{
		while (*pszStr != TEXT('\0'))
			{
			nRet++;
			pszStr = CharNextExA(0, pszStr, 0);
			}
		}
#else
	if (pszStr != (LPTSTR)NULL)
		{
		nRet = lstrlen(pszStr);
		}
#endif
#else // DEADWOOD
	if (pszStr != (LPTSTR)NULL)
		{
		nRet = lstrlen(pszStr);
		}
#endif // DEADWOOD
	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharGetByteCount
 *
 * DESCRIPTION:
 *	This function returns the number of bytes in a string.  A two byte char
 *	counts as two.
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharGetByteCount(LPCTSTR pszStr)
	{
	int nRet = 0;
#if defined(CHAR_MIXED)
	LPCTSTR pszFoo;

	if (pszStr != (LPTSTR)NULL)
		{
		pszFoo = pszStr;
		while (*pszFoo != TEXT('\0'))
			{
			pszFoo = CharNextExA(0, pszFoo, 0);
			}
		nRet = (int)(pszFoo - pszStr);
		}
#else
	if (pszStr != (LPTSTR)NULL)
		{
		nRet = lstrlen(pszStr);
		}
#endif
	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharCopy
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharCopy(LPTSTR pszDst, LPCTSTR pszSrc)
	{
	return lstrcpy(pszDst, pszSrc);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharCat
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharCat(LPTSTR pszDst, LPCTSTR pszSrc)
	{
	return lstrcat(pszDst, pszSrc);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharCmp
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharCmp(LPCTSTR pszA, LPCTSTR pszB)
	{
	return lstrcmp(pszA, pszB);
	}
int StrCharCmpi(LPCTSTR pszA, LPCTSTR pszB)
	{
	return lstrcmpi(pszA, pszB);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharCmpN
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharCmpN(LPCTSTR pszA, LPCTSTR pszB, size_t iLen)
	{
	return _tcsncmp(pszA, pszB, iLen);
	}
int StrCharCmpiN(LPCTSTR pszA, LPCTSTR pszB, size_t iLen)
	{
	return _tcsnicmp(pszA, pszB, iLen);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharStrStr
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
LPTSTR StrCharStrStr(LPCTSTR pszA, LPCTSTR pszB)
	{
	LPTSTR pszRet = (LPTSTR)NULL;
	int nSize;
	int nRemaining;
	LPTSTR pszPtr;

	/*
	 * We need to write a version of 'strstr' that will work.
	 * Do we really know what the problems are ?
	 */
	nSize = StrCharGetByteCount(pszB);

	pszPtr = (LPTSTR)pszA;
	while ((nRemaining = StrCharGetByteCount(pszPtr)) >= nSize)
		{
		if (memcmp(pszPtr, pszB, (size_t)nSize) == 0)
			return pszPtr;
		pszPtr = StrCharNext(pszPtr);
		}
	return pszRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	StrCharCopyN
 *
 * DESCRIPTION:
 *  Basically do a lstrcpy of n bytes, with one exception, we make sure that
 *	the copied string does not end in a lead-byte of a double-byte character.
 *
 * ARGUMENTS:
 *  pszDst - pointer to the copy target string.
 *	pszSrc - pointer to the copy source string.
 *	iLen   - the maximum number of TCHARs to copy.  Like strcpyn, the
			 string may not be null terminated if the buffer is exceeded.
 *
 * RETURNS:
 *	0=error, else pszDst
 *
 */
LPTSTR StrCharCopyN(LPTSTR pszDst, LPCTSTR pszSrc, int iLen)
	{
	int    i = 0;
    int    iCounter = iLen * sizeof(TCHAR);    // Use a temporary character counter.
	LPCTSTR psz = pszSrc;

	if (pszDst == 0 || pszSrc == 0 || iLen == 0 || iCounter == 0)
		return 0;

	while (1)
		{
		i = (int)(StrCharNext(psz) - psz);
		iCounter -= i;

		if (iCounter <= 0)
			break;

		if (*psz == TEXT('\0'))
			{
            //
            // Since StrCharNext() will return the pointer to the
            // terminating null character if at the end of the string,
            // so just increment to the next address location so we
            // have the correct number of bytes to copy (excluding
            // the terminating NULL character).  We NULL terminate
            // the string at the end of this function, so we don't
            // have to copy the NULL character. REV: 12/28/2000.
            //
			psz += 1;	// still need to increment
			break;
			}

		psz += i;
		}

    //
    // Make sure we don't overwrite memory. REV: 12/28/2000.
    //
    i = min((LONG)((psz - pszSrc) + sizeof(TCHAR)), iLen * (int)sizeof(TCHAR));

	MemCopy(pszDst, pszSrc, i);

    //
    // Make sure the string is null terminated. REV: 12/28/2000.
    //
    pszDst[(i / sizeof(TCHAR)) - 1] = TEXT('\0');

	return pszDst;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharPBrk
 *
 * DESCRIPTION:
 *	Searches a string for the first occurrence of a character contained in a
 *	specified buffer. This search does not include the null terminator. 
 *
 * PARAMETERS:
 *	pszStr - Address of the string to be searched. 
 *	pszSet - Address of a null-terminated character buffer that contains the 
 *		characters for which to search. 
 *
 * RETURNS:
 *	Returns the address in psz of the first occurrence of a character 
 *	contained in the buffer at pszSet, or NULL if no match is found. 
 */
LPTSTR StrCharPBrk(LPCTSTR pszStr, LPCTSTR pszSet)
	{
	LPCTSTR psz = pszSet;
	LPTSTR pszRetVal = NULL;
	
	while (*psz != TEXT('\0'))
		{
		if ((pszRetVal = StrCharFindFirst(pszStr, (int)(*psz))) != NULL)
			break;
		psz++;
		}

	return pszRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CnvrtMBCStoECHAR
 *
 * DESCRIPTION:
 *	Converts a DBCS (mixed byte) string into an ECHAR (double byte) string.
 *
 * PARAMETERS:
 *	tchrSource   - Source String
 *  ulDestSize   - Length of Destination String in Bytes
 *  echrDest     - Destination String
 *  ulSourceSize - Length of Destination String in Bytes
 *
 * RETURNS:
 *	0 - Success
 *  1 - Error
 */
int CnvrtMBCStoECHAR(ECHAR * echrDest, const unsigned long ulDestSize, const TCHAR * const tchrSource, const unsigned long ulSourceSize)
	{
	ULONG ulLoop      = 0;
	ULONG ulDestCount = 0;
	ULONG ulDestEChars = ulDestSize / sizeof(ECHAR);
	BOOL fLeadByteFound = FALSE;

	if ((echrDest == NULL) || (tchrSource == NULL))
		{
		assert(FALSE);
		return TRUE;					
		}

	// Make sure that the destination string is big enough to handle to source string
	if (ulDestEChars < ulSourceSize)
		{
		assert(FALSE);
		return 1;
		}


#if defined(CHAR_MIXED)
	// because we do a strcpy in the NARROW version of this function,
	// and we want the behavior to be the save between the two.  We
	// clear out the string, just like strcpy does
    memset(echrDest, 0, ulDestSize);

	for (ulLoop = 0; ulLoop < ulSourceSize; ulLoop++)
		{
		if ((IsDBCSLeadByte(tchrSource[ulLoop])) && (!fLeadByteFound))
			// If we found a lead byte, and the last one was not a lead
			// byte.  We load the byte into the top half of the ECHAR
			{
			echrDest[ulDestCount] = (tchrSource[ulLoop] & 0x00FF);
			echrDest[ulDestCount] = (ECHAR)(echrDest[ulDestCount] << 8);
			fLeadByteFound = TRUE;
			}
		else if (fLeadByteFound)
			{
			// If the last byte was a lead byte, we or it into the
			// bottom half of the ECHAR
			echrDest[ulDestCount] |= (tchrSource[ulLoop] & 0x00FF);
			fLeadByteFound = FALSE;
			ulDestCount++;
			}
		else
			{
			// Otherwise we load the byte into the bottom half of the
			// ECHAR and clear the top half.
			echrDest[ulDestCount] = (tchrSource[ulLoop] & 0x00FF);
			ulDestCount++;
			}
		}
#else
	// ECHAR is only a byte, so do a straight string copy.
    if (ulSourceSize)
        MemCopy(echrDest, tchrSource, ulSourceSize);
#endif
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CnvrtECHARtoMBCS
 *
 * DESCRIPTION:
 *	Converts an ECHAR (double byte) string into a DBCS (mixed byte) string.
 *
 * PARAMETERS:
 *	echrSource   - Source String
 *  ulDestSize   - Length of Destination String in Bytes
 *  tchrDest     - Destination String
 *
 * RETURNS:
 *	Number of bytes in the converted string
 *  1 - Error
 */
int CnvrtECHARtoMBCS(TCHAR * tchrDest, const unsigned long ulDestSize, const ECHAR * const echrSource, const unsigned long ulSourceSize)
	{
	ULONG ulLoop      = 0;
	ULONG ulDestCount = 0;
	ULONG ulSourceEChars = ulSourceSize / sizeof(ECHAR);
    #if defined(INCL_VTUTF8)
    extern BOOL DoUTF8;
    #endif

	if ((tchrDest == NULL) || (echrSource == NULL))
		{
		assert(FALSE);
		return TRUE;
		}

    #if defined(CHAR_MIXED)
	// because we do a strcpy in the NARROW version of this function,
	// and we want the behavior to be the save between the two.  We
	// clear out the string, just like strcpy does
    memset(tchrDest, 0, ulDestSize);

	// We can't do a strlen of an ECHAR string, so we loop
	// until we hit NULL or we are over the size of the destination.
	while ((ulLoop < ulSourceEChars) && (ulDestCount <= ulDestSize))
		{
		if (echrSource[ulLoop] & 0xFF00)
			// Lead byte in this character, load the lead byte into one
			// TCHAR and the lower byte into a second TCHAR.
			{
			tchrDest[ulDestCount] = (TCHAR)((echrSource[ulLoop] & 0xFF00) >> 8);
			ulDestCount++;
			tchrDest[ulDestCount] = (TCHAR)(echrSource[ulLoop] & 0x00FF);
			}
		else
			// No lead byte in this ECHAR, just load the lower half into
			// the TCHAR.
			{
			tchrDest[ulDestCount] = (TCHAR)(echrSource[ulLoop] & 0x00FF);
			}
		ulDestCount++;
		ulLoop++;
		if(ulDestCount > ulDestSize)
			assert(FALSE);
		}

	return ulDestCount;
    #else
	// ECHAR is only a byte, so do a straight string copy.
    if (ulSourceSize)
	    MemCopy(tchrDest, echrSource, ulSourceSize);
	return ulSourceSize;
    #endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharGetEcharLen
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharGetEcharLen(const ECHAR * const pszA)
	{
	int nReturn = 0;

	if (pszA == NULL)
		{
		assert(FALSE);
		return nReturn;
		}

#if defined(CHAR_MIXED)
	while (pszA[nReturn] != ETEXT('\0'))
		{
		nReturn++;
		}

#else
	nReturn = strlen(pszA);
#endif

    return nReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharGetEcharByteCount
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharGetEcharByteCount(const ECHAR * const pszA)
	{
#if defined(CHAR_MIXED)
	int nLoop = 0;
#endif
	if (pszA == NULL)
		{
		assert(FALSE);
		return 0;
		}

#if defined(CHAR_MIXED)
	while (pszA[nLoop] != 0)
		{
		nLoop++;
		}

	nLoop *= (int)sizeof(ECHAR);
	return nLoop;
#else
	return (int)strlen(pszA);
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	StrCharCmpEtoT
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
int StrCharCmpEtoT(const ECHAR * const pszA, const TCHAR * const pszB)
	{

#if defined(CHAR_MIXED)

	TCHAR *tpszA = NULL;
	int    nLenA = StrCharGetEcharLen(pszA);

	tpszA = (TCHAR *)malloc((unsigned int)nLenA * sizeof(ECHAR));
	if (tpszA == NULL)
		{
		assert(FALSE);
		return 0;
		}

	CnvrtECHARtoMBCS(tpszA, (unsigned long)(nLenA * (int)sizeof(ECHAR)), pszA, StrCharGetEcharByteCount(pszA));

	return StrCharCmp(tpszA, pszB);
#else
	return strcmp(pszA, pszB);
#endif
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ECHAR_Fill
 *
 * DESCRIPTION:
 *	Fills a ECHAR string with the specified ECHAR.
 *
 * ARGUMENTS:
 *	dest	- string to fill.
 *	c		- character to fill string with.
 *	size_t	- number of ECHAR units to copy.
 *
 * RETURNS:
 *	pointer to string.
 *
 */
ECHAR *ECHAR_Fill(ECHAR *dest, ECHAR c, size_t count)
	{
#if defined(CHAR_NARROW)

	return (TCHAR *)memset(dest, c, count);

#else
	unsigned int i;

	if (dest == NULL)
		{
		assert(FALSE);
		return 0;
		}

	for (i = 0 ; i < count ; ++i)
		dest[i] = c;

	return dest;
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ECHAR_Fill
 *
 * DESCRIPTION:
 *	
 *
 * ARGUMENTS:
 *	pszDest	- string to fill.
 *	cchDest	- number of TCHAR units to copy.
 *	eChar	- character to fill string with.
 *
 * RETURNS:
 *	pointer to string.
 *
 */
int CnvrtECHARtoTCHAR(LPTSTR pszDest, int cchDest, ECHAR eChar)
	{
    #if defined(CHAR_NARROW)
	pszDest[0] = eChar;
	pszDest[1] = ETEXT('\0');
	
    #else
	memset(pszDest, 0, cchDest*sizeof(*pszDest));
	// This is the only place where we convert a single ECHAR to TCHAR's
	// so as of right now we will not make this into a function.
	if (eChar & 0xFF00)
		// Lead byte in this character, load the lead byte into one
		// TCHAR and the lower byte into a second TCHAR.
		{
		if (cchDest >= 2)
			{
			pszDest[0] = (TCHAR)((eChar & 0xFF00) >> 8);
			pszDest[1] = (TCHAR)(eChar & 0x00FF);
			}
		else
			{
			return 1;
			}
		}
	else
		// No lead byte in this ECHAR, just load the lower half into
		// the TCHAR.
		{
		pszDest[0] = (TCHAR)(eChar & 0x00FF);
		}
    #endif

	return 0;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	isDBCSChar
 *
 * DESCRIPTION:
 *	Determines if the Character is Double Byte or not
 *	
 *
 * ARGUMENTS:
 *	c		- character to test.
 *
 * RETURNS:
 *	int 	TRUE  - if DBCS
 *			FALSE - if SBCS
 *
 */
int isDBCSChar(unsigned int Char)
	{
	int rtn = 0;
#if defined(CHAR_NARROW)
	rtn = 0;

#else
	ECHAR ech = 0;
	char ch;

	if (Char == 0)
		{
		// assert(FALSE);
		return FALSE;
		}

	ech = ETEXT(Char);

	if (ech & 0xFF00)
		{
		ch = (char)(ech >> 8);
		if (IsDBCSLeadByte(ch))
			{
			rtn = 1;
			}

		}
#endif
	return rtn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	StrCharStripDBCSString
 *
 * DESCRIPTION:
 *	Strips out Left/Right pairs of wide characters and leaves a single wide character
 *	in it's place
 *	
 *
 * ARGUMENTS:
 *	aech		- String to be stripped
 *
 * RETURNS:
 *	int - number of characters striped out of string
 *
 */
int StrCharStripDBCSString(ECHAR *aechDest, const long lDestSize,
    ECHAR *aechSource)
	{
	int nCount = 0;
#if !defined(CHAR_NARROW)
	ECHAR *pechTmpS;
	ECHAR *pechTmpD;
	long j;
	long lDLen = lDestSize / sizeof(ECHAR);;

	if ((aechSource == NULL) || (aechDest == NULL))
		{
		assert(FALSE);
		return nCount;
		}

        pechTmpS = aechSource;
        pechTmpD = aechDest;

	for (j = 0; (*pechTmpS != '\0') && (j < lDLen); j++)
		{
		*pechTmpD = *pechTmpS;

		if ((isDBCSChar(*pechTmpS)) && (*(pechTmpS + 1) != '\0'))
			{
			if (*pechTmpS == *(pechTmpS + 1))
				{
				pechTmpS++;
				nCount++;
				}
			}
		pechTmpS++;
                pechTmpD++;
		}

	*pechTmpD = ETEXT('\0');
#endif
	return nCount;
	}

#if defined(DEADWOOD)
#if defined(INCL_VTUTF8)
//******************************************************************************
// Function:	TranslateUTF8ToDBCS
//
// Description: 
//    This function will convert a UTF-8 character to a DBCS character.  If the
//    character passed is not a full description of a UTF-8 character, then the
//    character is appended to the UNICODE buffer.
// Arguments: 
//    IncomingByte
//    pUTF8Buffer
//    iUTF8BufferLength
//    pUNICODEBuffer
//    iUNICODEBufferLength
//    pDBCSBuffer
//    iDBCSBufferLength
//
// Returns: 
//	
// Throws:
//	
// Author: Ron E. Vorndam,  03/06/2001
//

BOOLEAN TranslateUTF8ToDBCS(UCHAR  IncomingByte,
                            UCHAR *pUTF8Buffer,
                            int    iUTF8BufferLength,
                            WCHAR *pUNICODEBuffer,
                            int    iUNICODEBufferLength,
                            TCHAR *pDBCSBuffer,
                            int    iDBCSBufferLength)
    {
    BOOLEAN bReturn = FALSE;
    int     iLength = 0;

    if (pUTF8Buffer != NULL && iUTF8BufferLength > 0 &&
        pUNICODEBuffer != NULL && iUNICODEBufferLength > 0 &&
        pDBCSBuffer != NULL && iDBCSBufferLength > 0)
        {
        //
        // Translate from UTF8 to UNICODE.
        //
        if (TranslateUtf8ToUnicode(IncomingByte,
                                   pUTF8Buffer,
                                   pUNICODEBuffer) == TRUE)
            {
            //
            // Now Translate the UNICODE to DBCS characters.
            //
            iLength = WideCharToMultiByte(CP_OEMCP,
            //iLength = WideCharToMultiByte(CP_ACP,
                                          0, //WC_COMPOSITECHECK | WC_SEPCHARS,
                                          pUNICODEBuffer, -1, 
                                          NULL, 0, NULL, NULL );

            if (iLength > 0 && iDBCSBufferLength >= iLength)
                {
                WideCharToMultiByte(CP_OEMCP,
                //WideCharToMultiByte(CP_ACP,
                                    0, //WC_COMPOSITECHECK | WC_SEPCHARS,
                                    pUNICODEBuffer, -1,
                                    pDBCSBuffer, iLength, NULL, NULL); 

                if (iLength > 0)
                    {
                    bReturn = TRUE;
                    }
                }
            else
                {
                //
                // Return an error and report the number of bytes required to
                // make the data conversion.
                //
                iDBCSBufferLength = iLength * -1;
                }
            }
        }

    return bReturn;
    }

BOOLEAN TranslateDBCSToUTF8(const TCHAR *pDBCSBuffer,
                                  int    iDBCSBufferLength,
                                  WCHAR *pUNICODEBuffer,
                                  int    iUNICODEBufferLength,
                                  UCHAR *pUTF8Buffer,
                                  int    iUTF8BufferLength)
    {
    BOOLEAN   bReturn = FALSE;
    int       iLength = 0;

    //iLength = WideCharToMultiByte(CP_OEMCP,
    iLength = MultiByteToWideChar(CP_ACP,
                                  0, //WC_COMPOSITECHECK | WC_SEPCHARS,
                                  pDBCSBuffer, -1, 
                                  pUNICODEBuffer, iLength);

    if (iLength > 0 && iDBCSBufferLength > 0)
        {
        if (pUNICODEBuffer != NULL && iUNICODEBufferLength >= iLength)
            {
            //
            // Translate the DBCS to UNICODE characters.
            //
            //WideCharToMultiByte(CP_OEMCP,
            MultiByteToWideChar(CP_ACP,
                                0, //MB_COMPOSITE,
                                pDBCSBuffer, -1,
                                pUNICODEBuffer, iLength);

            if (iLength > 0 && iLength <= iUTF8BufferLength)
                {
                //
                // Translate from UNICODE to UTF8.
                //
                bReturn = TranslateUnicodeToUtf8(pUNICODEBuffer,
                                                 pUTF8Buffer);
                }
            }
        }

    return bReturn;
    }

//
// The following functions are from code obtained directly from
// Microsoft for converting Unicode to UTF-8 and UTF-8 to unicode
// buffers. REV: 03/02/2001
//

BOOLEAN TranslateUnicodeToUtf8(PCWSTR SourceBuffer,
                               UCHAR  *DestinationBuffer) 
/*++

Routine Description:

    translates a unicode buffer into a UTF8 version.

Arguments:

    SourceBuffer - unicode buffer to be translated.
    DestinationBuffer - receives UTF8 version of same buffer.

Return Value:

    TRUE - We successfully translated the Unicode value into its
           corresponding UTF8 encoding.
   
    FALSE - The translation failed.


--*/

{
    ULONG Count = 0;

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    DestinationBuffer[Count] = (UCHAR)'\0';
    while (*SourceBuffer) {

        if( (*SourceBuffer & 0xFF80) == 0 ) {
            //
            // if the top 9 bits are zero, then just
            // encode as 1 byte.  (ASCII passes through unchanged).
            //
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0x7F);
        } else if( (*SourceBuffer & 0xF800) == 0 ) {
            //
            // if the top 5 bits are zero, then encode as 2 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 6) & 0x1F) | 0xC0;
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        } else {
            //
            // encode as 3 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 12) & 0xF) | 0xE0;
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 6) & 0x3F) | 0x80;
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        }
        SourceBuffer += 1;
    }

    DestinationBuffer[Count] = (UCHAR)'\0';

    return(TRUE);

}



BOOLEAN TranslateUtf8ToUnicode(UCHAR  IncomingByte,
                               UCHAR  *ExistingUtf8Buffer,
                               WCHAR  *DestinationUnicodeVal) 
/*++

Routine Description:

    Takes IncomingByte and concatenates it onto ExistingUtf8Buffer.
    Then attempts to decode the new contents of ExistingUtf8Buffer.

Arguments:

    IncomingByte -          New character to be appended onto 
                            ExistingUtf8Buffer.
    
    
    ExistingUtf8Buffer -    running buffer containing incomplete UTF8
                            encoded unicode value.  When it gets full,
                            we'll decode the value and return the
                            corresponding Unicode value.
                            
                            Note that if we *do* detect a completed UTF8
                            buffer and actually do a decode and return a
                            Unicode value, then we will zero-fill the
                            contents of ExistingUtf8Buffer.
    
    
    DestinationUnicodeVal - receives Unicode version of the UTF8 buffer.

                            Note that if we do *not* detect a completed
                            UTF8 buffer and thus can not return any data
                            in DestinationUnicodeValue, then we will
                            zero-fill the contents of DestinationUnicodeVal.


Return Value:

    TRUE - We received a terminating character for our UTF8 buffer and will
           return a decoded Unicode value in DestinationUnicode.
   
    FALSE - We haven't yet received a terminating character for our UTF8
            buffer.

--*/

{
//    ULONG Count = 0;
    ULONG i = 0;
    BOOLEAN ReturnValue = FALSE;


    
    //
    // Insert our byte into ExistingUtf8Buffer.
    //
    i = 0;
    do {
        if( ExistingUtf8Buffer[i] == 0 ) {
            ExistingUtf8Buffer[i] = IncomingByte;
            break;
        }

        i++;
    } while( i < 3 );

    //
    // If we didn't get to actually insert our IncomingByte,
    // then someone sent us a fully-qualified UTF8 buffer.
    // This means we're about to drop IncomingByte.
    //
    // Drop the zero-th byte, shift everything over by one
    // and insert our new character.
    //
    // This implies that we should *never* need to zero out
    // the contents of ExistingUtf8Buffer unless we detect
    // a completed UTF8 packet.  Otherwise, assume one of
    // these cases:
    // 1. We started listening mid-stream, so we caught the
    //    last half of a UTF8 packet.  In this case, we'll
    //    end up shifting the contents of ExistingUtf8Buffer
    //    until we detect a proper UTF8 start byte in the zero-th
    //    position.
    // 2. We got some garbage character, which would invalidate
    //    a UTF8 packet.  By using the logic below, we would
    //    end up disregarding that packet and waiting for
    //    the next UTF8 packet to come in.
    if( i >= 3 ) {
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = IncomingByte;
    }





    //
    // Attempt to convert the UTF8 buffer 
    //
    // UTF8 decodes to Unicode in the following fashion:
    // If the high-order bit is 0 in the first byte:
    //      0xxxxxxx yyyyyyyy zzzzzzzz decodes to a Unicode value of 00000000 0xxxxxxx
    //
    // If the high-order 3 bits in the first byte == 6:
    //      110xxxxx 10yyyyyy zzzzzzzz decodes to a Unicode value of 00000xxx xxyyyyyy
    //
    // If the high-order 3 bits in the first byte == 7:
    //      1110xxxx 10yyyyyy 10zzzzzz decodes to a Unicode value of xxxxyyyy yyzzzzzz
    // 
    
    if( (ExistingUtf8Buffer[0] & 0x80) == 0 ) {        

        //
        // First case described above.  Just return the first byte
        // of our UTF8 buffer.
        //
        *DestinationUnicodeVal = (WCHAR)(ExistingUtf8Buffer[0]);

        
        //
        // We used 1 byte.  Discard that byte and shift everything
        // in our buffer over by 1.
        //
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = 0;

        ReturnValue = TRUE;

    } else if( (ExistingUtf8Buffer[0] & 0xE0) == 0xC0 ) {

        
        //
        // Second case described above.  Decode the first 2 bytes of
        // of our UTF8 buffer.
        //
        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            // upper byte: 00000xxx
            *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] >> 2) & 0x07);
            *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

            // high bits of lower byte: xx000000
            *DestinationUnicodeVal |= ((ExistingUtf8Buffer[0] & 0x03) << 6);

            // low bits of lower byte: 00yyyyyy
            *DestinationUnicodeVal |= (ExistingUtf8Buffer[1] & 0x3F);
                                     

            //
            // We used 2 bytes.  Discard those bytes and shift everything
            // in our buffer over by 2.
            //
            ExistingUtf8Buffer[0] = ExistingUtf8Buffer[2];
            ExistingUtf8Buffer[1] = 0;
            ExistingUtf8Buffer[2] = 0;
        
            ReturnValue = TRUE;

        }
    } else if( (ExistingUtf8Buffer[0] & 0xF0) == 0xE0 ) {
        
        //
        // Third case described above.  Decode the all 3 bytes of
        // of our UTF8 buffer.
        //

        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {
            
            if( (ExistingUtf8Buffer[2] & 0xC0) == 0x80 ) {
                
                // upper byte: xxxx0000
                *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] << 4) & 0xF0);

                // upper byte: 0000yyyy
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] >> 2) & 0x0F);

                *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

                // lower byte: yy000000
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] << 6) & 0xC0);

                // lower byte: 00zzzzzz
                *DestinationUnicodeVal |= (ExistingUtf8Buffer[2] & 0x3F);
            
                //
                // We used all 3 bytes.  Zero out the buffer.
                //
                ExistingUtf8Buffer[0] = 0;
                ExistingUtf8Buffer[1] = 0;
                ExistingUtf8Buffer[2] = 0;
            
                ReturnValue = TRUE;

            }
        }
    }

    return ReturnValue;
}
#endif //INCL_VTUTF8
#endif // defined(DEADWOOD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\statusbr.c ===
/*	File: D:\WACKER\tdll\statusbr.c (Created: 02-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 7/08/02 6:48p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <time.h>

#include <term\res.h>

#include "assert.h"
#include "stdtyp.h"
#include "session.h"
#include "globals.h"
#include "statusbr.h"
#include "cnct.h"
#include "capture.h"
#include "print.h"
#include "tdll.h"
#include "htchar.h"
#include "mc.h"
#include "load_res.h"
#include "timers.h"
#include "com.h"

#include <emu\emuid.h>
#include <emu\emu.h>
#include <emu\emudlgs.h>
#include <xfer\itime.h>

// Static function prototypes...
//
STATIC_FUNC void sbrSubclassStatusbarWindow(HWND hwnd, HSESSION hSession);
STATIC_FUNC void sbrCnctStatus		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrSetToNoParts	(const HWND hwnd, LPTSTR pszStr);
STATIC_FUNC void sbrRefresh 		(const HWND hwnd, const int iPart, const pSBR pSBRData);
STATIC_FUNC BOOL sbrNeedToSetParts	(const HWND hwnd);
STATIC_FUNC void sbrSetParts		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrTimerRefresh	(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrDrawCnctPart	(const HWND hwnd, const int iCnctStatus,
									 LPTSTR pszStr);
STATIC_FUNC void sbrSetPartsOnce	(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC int  sbrGetSizeInPixels (const HWND hwnd, LPTSTR pszStr);
STATIC_FUNC int  sbrCalcPartSize	(const HWND hwnd, const int iId);
STATIC_FUNC void sbrCachString		(pSBR pSBRData,
									 unsigned int iPart,
									 LPTSTR pach);
STATIC_FUNC BOOL sbrCnctTimeToSystemTime(const HWND hwnd,
									 LPSYSTEMTIME lpSysTime,
									 const pSBR pSBRData);

STATIC_FUNC void sbrEmulatorName	(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrScrolLock		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrCapsLock		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrNumLock 		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrCapture 		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrPrintEcho		(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC BOOL sbrCreateTimer 	(const HWND hwnd, const pSBR pSBRData);
STATIC_FUNC void sbrCom 			(const HWND hwnd, const pSBR pSBRData);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrCreateSessionStatusbar
 *
 * DESCRIPTION:
 *	Not much now but will get more complicated later.
 *
 * ARGUMENTS:
 *	hwndSession - session window handle
 *
 * RETURNS:
 *	Handle to status window or zero on error.
 *
 */
HWND sbrCreateSessionStatusbar(HSESSION hSession)
	{
	HWND 		hwnd = (HWND)0;
	//int		  aBorders[3];
	HDC  		hDC;
	TEXTMETRIC 	tm;
	HWND		hwndSession = (HWND)0;

	hwndSession = sessQueryHwnd(hSession);
	if (!IsWindow(hwndSession))
		return (HWND)0;

	hwnd = CreateStatusWindow(WS_CHILD | WS_CLIPSIBLINGS | SBARS_SIZEGRIP,
							  0,
							  hwndSession,
							  IDC_STATUS_WIN);

	if (IsWindow(hwnd))
		{
		#if 0
		aBorders[0] = WINDOWSBORDERWIDTH;
		aBorders[1] = WINDOWSBORDERHEIGHT;
		aBorders[2] = WINDOWSBORDERWIDTH;

		SendMessage(hwnd, SB_SETBORDERS, 0, (LPARAM)aBorders);
		#endif

		hDC = GetDC(hwnd);
		GetTextMetrics(hDC, &tm);
		ReleaseDC(hwnd, hDC);

		SendMessage(hwnd, SB_SETMINHEIGHT, (WPARAM)tm.tmHeight, 0);
		ShowWindow(hwnd, SW_SHOWNA);

		sbrSubclassStatusbarWindow(hwnd, hSession);
		}
	return hwnd;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrSubclassStatusbarWindow
 *
 * DESCRIPTION:
 *	Subclass the Status Bar and init the data structure.
 *
 * ARGUMENTS:
 * 	hwnd 		- window handle.
 *	hSession 	- the session handle.
 *
 * RETURNS:
 *
 */
STATIC_FUNC void sbrSubclassStatusbarWindow(HWND hwnd, HSESSION hSession)
	{
	ATOM atom = (ATOM)0;
	pSBR pSBRData;

	atom = AddAtom((LPCTSTR)SBR_ATOM_NAME);

	if (atom == 0)
		{
		assert(FALSE);
		return;
		}

	pSBRData = (pSBR)LocalAlloc(LPTR, sizeof(SBR));

	if (pSBRData == NULL)
		{
		assert(FALSE);
		return;
		}

	// Initialize statusbar data structure...
	//
	pSBRData->hSession = hSession;
	pSBRData->hwnd     = hwnd;
	pSBRData->hTimer   = (HTIMER)0;

	pSBRData->pachCNCT = (LPTSTR)0;
	pSBRData->pachCAPL = (LPTSTR)0;
	pSBRData->pachNUML = (LPTSTR)0;
	pSBRData->pachSCRL = (LPTSTR)0;
	pSBRData->pachCAPT = (LPTSTR)0;
	pSBRData->pachPECHO = (LPTSTR)0;

	// Do the subclass...
	//
	pSBRData->wpOrigStatusbarWndProc =
		(WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)sbrWndProc);

	SetProp(hwnd, (LPCTSTR)atom, (HANDLE)pSBRData);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrWndProc
 *
 * DESCRIPTION:
 *	Our own statusbar window proc.
 *
 * ARGUMENTS:
 *  Standard window proc parameters.
 *
 * RETURNS:
 *  Standard return value.
 *
 */
LRESULT APIENTRY sbrWndProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	ATOM	atom = (ATOM)0;
	pSBR	pSBRData;
	int		nRet;
    LRESULT lpResult = 0;

	atom = FindAtom((LPCTSTR)SBR_ATOM_NAME);
	pSBRData = (pSBR)GetProp(hwnd, (LPCTSTR)atom);

    if (pSBRData != NULL && IsWindow(hwnd))
        {
	    switch (uMsg)
		    {
		    case SBR_NTFY_INITIALIZE:
			    sbrCreateTimer(hwnd, pSBRData);
			    sbrSetPartsOnce(hwnd, pSBRData);
			    sbrRefresh(hwnd, SBR_MAX_PARTS, pSBRData);
			    break;

		    case SBR_NTFY_REFRESH:
			    if (IsWindowVisible(hwnd))
				    sbrRefresh(hwnd, LOWORD(wPar), pSBRData);

			    /* Fall through */

		    case SBR_NTFY_TIMER:
			    if (IsWindowVisible(hwnd) && !sbrNeedToSetParts(hwnd))
				    sbrTimerRefresh(hwnd, pSBRData);
			    return 0;

		    case SBR_NTFY_NOPARTS:
			    if (IsWindowVisible(hwnd))
				    sbrSetToNoParts(hwnd, (LPTSTR)lPar);
			    return 0;

		    case WM_DESTROY:
			    if (atom)
				    {
				    RemoveProp(hwnd, (LPCTSTR)atom);
				    DeleteAtom(atom);
                    atom = (ATOM)0;
				    }

			    // Remove subclass from the statusbar window
			    //
			    SetWindowLongPtr(hwnd,	GWLP_WNDPROC, (LONG_PTR)pSBRData->wpOrigStatusbarWndProc);

			    // Destroy the timer...
			    //
			    if (pSBRData->hTimer)
				    {
				    nRet = TimerDestroy(&pSBRData->hTimer);
				    assert(nRet == TIMER_OK);
				    }

			    if (pSBRData->pachCNCT)
				    {
				    free(pSBRData->pachCNCT);
				    pSBRData->pachCNCT = NULL;
				    }
			    if (pSBRData->pachCAPL)
				    {
				    free(pSBRData->pachCAPL);
				    pSBRData->pachCAPL = NULL;
				    }
			    if (pSBRData->pachNUML)
				    {
				    free(pSBRData->pachNUML);
				    pSBRData->pachNUML = NULL;
				    }
			    if (pSBRData->pachSCRL)
				    {
				    free(pSBRData->pachSCRL);
				    pSBRData->pachSCRL = NULL;
				    }
			    if (pSBRData->pachCAPT)
				    {
				    free(pSBRData->pachCAPT);
				    pSBRData->pachCAPT = NULL;
				    }
			    if (pSBRData->pachPECHO)
				    {
				    free(pSBRData->pachPECHO);
				    pSBRData->pachPECHO = NULL;
				    }

			    LocalFree(pSBRData);
			    pSBRData = NULL;

		    default:
			    break;
		    }
        }

    if (pSBRData != NULL)
        {
        lpResult = CallWindowProc(pSBRData->wpOrigStatusbarWndProc,
                                  hwnd, uMsg, wPar, lPar);
        }

	return lpResult;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrSetToNoParts
 *
 * DESCRIPTION:
 * 	Show status bar with no parts. This is usefull in showing help for
 *	menu items on the statusbar.
 *
 * ARGUMENTS:
 *  hwnd 	- window handle.
 *	pszStr 	- text to display on the status bar.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrSetToNoParts(const HWND hwnd, LPTSTR pszStr)
	{
	if (IsWindow(hwnd))
		{
	    int  aWidths[1];

		aWidths[0] = -1;
		SendMessage(hwnd, SB_SETPARTS, (WPARAM)1, (LPARAM)aWidths);
		SendMessage(hwnd, SB_SETTEXT, 0, (LPARAM)pszStr);
		ShowWindow(hwnd, SW_SHOWNA);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrRefresh
 *
 * DESCRIPTION:
 *	Figure out what has changed and display status info appropriately.
 *
 * ARGUMENTS:
 *  hwnd  - window handle.
 *  iPart - a part number for a part we want to explicitly refresh.
 *			It can be SBR_MAX_PARTS, in which case all parts are refreshed and
 *			it can be SBR_KEY_PARTS, in which case all KEY parts are refreshed.
 *			In some cases it makes sense to just refresh only one part instead
 *			of refreshing all of them.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrRefresh(const HWND hwnd, const int iPart, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    // Make sure we are displaying the correct # of parts
	    //
	    if (sbrNeedToSetParts(hwnd))
		    sbrSetParts(hwnd, pSBRData);

	    switch (iPart)
		    {
		    case SBR_KEY_PARTS:
			    sbrScrolLock(hwnd, pSBRData);
			    sbrCapsLock(hwnd, pSBRData);
			    sbrNumLock(hwnd, pSBRData);
			    break;

		    case SBR_CNCT_PART_NO:
			    sbrCnctStatus(hwnd, pSBRData);
			    break;

		    case SBR_EMU_PART_NO:
			    sbrEmulatorName(hwnd, pSBRData);
			    break;

		    case SBR_COM_PART_NO:
			    sbrCom(hwnd, pSBRData);
			    break;

		    case SBR_SCRL_PART_NO:
			    sbrScrolLock(hwnd, pSBRData);
			    break;

		    case SBR_CAPL_PART_NO:
			    sbrCapsLock(hwnd, pSBRData);
			    break;

		    case SBR_NUML_PART_NO:
			    sbrNumLock(hwnd, pSBRData);
			    break;

		    case SBR_CAPT_PART_NO:
			    sbrCapture(hwnd, pSBRData);
			    break;

		    case SBR_PRNE_PART_NO:
			    sbrPrintEcho(hwnd, pSBRData);
			    break;

		    default:
			    sbrCnctStatus(hwnd, pSBRData);
			    sbrEmulatorName(hwnd, pSBRData);
			    sbrCom(hwnd, pSBRData);
			    sbrScrolLock(hwnd, pSBRData);
			    sbrCapsLock(hwnd, pSBRData);
			    sbrNumLock(hwnd, pSBRData);
			    sbrCapture(hwnd, pSBRData);
			    sbrPrintEcho(hwnd, pSBRData);
			    break;
		    }
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrNeedToSetParts
 *
 * DESCRIPTION:
 *  Check the number of parts shown in the status bar.  If it is less then
 *	expected, i.e., the maximum parts we usually show, then we need to reset
 *	the status bar parts.  This happens, for example, when help text is
 * 	displayed for menu items, i.e., parts are set to 0.
 *
 * ARGUMENTS:
 * 	hwnd - window handle.
 *
 * RETURNS:
 *  TRUE if parts need to be set/re-set.
 *	FALSE otherwise.
 *
 */
STATIC_FUNC BOOL sbrNeedToSetParts(const HWND hwnd)
	{
    BOOL bRet = FALSE;

	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && IsWindow(hwnd))
        {
	    int nParts = 0;
	    int aWidths[SBR_MAX_PARTS+1];

	    memset(aWidths, 0, (SBR_MAX_PARTS+1) * sizeof(int));

	    nParts = (int)SendMessage(hwnd, SB_GETPARTS, (WPARAM)SBR_MAX_PARTS+1,
		    (LPARAM)aWidths);

	    if (nParts != SBR_MAX_PARTS)
            {
		    bRet = TRUE;
            }
        }

	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrSetParts
 *
 * DESCRIPTION:
 *	Set parts in the statusbar.
 *
 * ARGUMENTS:
 * 	hwnd - window handle.
 *
 * RETURNS:
 *	void.
 *
 */
STATIC_FUNC void sbrSetParts(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    SendMessage(hwnd, SB_SETPARTS, (WPARAM)SBR_MAX_PARTS,
		            (LPARAM)pSBRData->aWidths);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrSetPartsOnce
 *
 * DESCRIPTION:
 *	Set parts in the statusbar according to the length of strings to be
 *	displayed in the appropriate parts.  This function should be called only
 *	once to figure out the part lengths, from then on the part rigth edges are
 *  stored in the statusbar data structure.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 * 	void
 */
STATIC_FUNC void sbrSetPartsOnce(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    int 		 aWidths[SBR_MAX_PARTS] = {1, 1, 1, 1, 1, 1, 1, 1};
	    int			 iNewWidth = 0, i;
	    TCHAR		 ach[256];
	    unsigned int iPart = 0;
	    int aiBorders[3];

	    // To make sure that we always have enough space to display the text
	    // in the appropriate statusbar part read the text corresponding to each
	    // part and check its length, adjust the size of the part if needed.
	    //
	    for (i = 0; i < SBR_MAX_PARTS; i++)
		    {
		    switch (i)
			    {
			    default:
			    case SBR_CNCT_PART_NO:
			    case SBR_EMU_PART_NO:
				    iNewWidth = sbrCalcPartSize(hwnd, i);
				    break;

			    case SBR_COM_PART_NO:	iPart = IDS_STATUSBR_COM;	break;
			    case SBR_SCRL_PART_NO:	iPart = IDS_STATUSBR_SCRL;	break;
			    case SBR_CAPL_PART_NO:	iPart = IDS_STATUSBR_CAPL;	break;
			    case SBR_NUML_PART_NO:	iPart = IDS_STATUSBR_NUML;	break;
			    case SBR_CAPT_PART_NO:	iPart = IDS_STATUSBR_CAPTUREON; break;
			    case SBR_PRNE_PART_NO:	iPart = IDS_STATUSBR_PRINTECHOON; break;
			    }

		    if (i != SBR_CNCT_PART_NO && i != SBR_EMU_PART_NO)
			    {
			    // Get the width for the current part string...
			    //
			    iNewWidth = 0;

			    LoadString(glblQueryDllHinst(), iPart, ach,
				    sizeof(ach) / sizeof(TCHAR));

			    sbrCachString(pSBRData, iPart, ach);
			    iNewWidth = (int)sbrGetSizeInPixels(hwnd, ach);
			    }

		    aWidths[i] = iNewWidth;
		    }

	    // When computing widths, we need to take the borders into account.
	    //
	    memset(aiBorders, 0, sizeof(aiBorders));
	    SendMessage(hwnd, SB_GETBORDERS, 0, (LPARAM)aiBorders);

	    // Calculate right edges of the statusbar parts...
	    // put them back into aWidths.
	    //
	    aWidths[0] += aiBorders[1];

	    for (i = 1; i < SBR_MAX_PARTS; i++)
		    aWidths[i] += aWidths[i-1] + aiBorders[2];

	    MemCopy(pSBRData->aWidths, aWidths, SBR_MAX_PARTS * sizeof(int));

	    SendMessage(hwnd, SB_SETPARTS, (WPARAM)SBR_MAX_PARTS,
		    (LPARAM)pSBRData->aWidths);
        }
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrCachString
 *
 * DESCRIPTION:
 *	Save the string we've just loaded from the resource file in our internal
 *  statusbar structure for future use.  This way we minimize the
 *	LoadStirng() calls.
 *
 * ARGUMENTS:
 *  pSBRData - handle to internal structure.
 *	iPart	 - part identifier.
 *	pach	 - label for that part.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrCachString(pSBR pSBRData, unsigned int iPart, LPTSTR pach)
	{
	unsigned int pachSize;

	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL)
        {
		pachSize = (StrCharGetByteCount(pach) + 1) * sizeof(TCHAR);
	    switch (iPart)
		    {
	    case IDS_STATUSBR_CONNECT_FORMAT:
		    if (pSBRData->pachCNCT)
			    {
			    free(pSBRData->pachCNCT);
			    pSBRData->pachCNCT = NULL;
			    }
		    pSBRData->pachCNCT = malloc(pachSize);
		    StrCharCopyN(pSBRData->pachCNCT, pach, pachSize);
		    break;

	    case IDS_STATUSBR_SCRL:
		    if (pSBRData->pachSCRL)
			    {
			    free(pSBRData->pachSCRL);
			    pSBRData->pachSCRL = NULL;
			    }
		    pSBRData->pachSCRL = malloc(pachSize);
		    StrCharCopyN(pSBRData->pachSCRL, pach, pachSize);
		    break;

	    case IDS_STATUSBR_CAPL:
		    if (pSBRData->pachCAPL)
			    {
			    free(pSBRData->pachCAPL);
			    pSBRData->pachCAPL = NULL;
			    }
		    pSBRData->pachCAPL = malloc(pachSize);
		    StrCharCopyN(pSBRData->pachCAPL, pach, pachSize);
		    break;

	    case IDS_STATUSBR_NUML:
		    if (pSBRData->pachNUML)
			    {
			    free(pSBRData->pachNUML);
			    pSBRData->pachNUML = NULL;
			    }
		    pSBRData->pachNUML = malloc(pachSize);
		    StrCharCopyN(pSBRData->pachNUML, pach, pachSize);
		    break;

	    case IDS_STATUSBR_CAPTUREON:
		    if (pSBRData->pachCAPT)
			    {
			    free(pSBRData->pachCAPT);
			    pSBRData->pachCAPT = NULL;
			    }
		    pSBRData->pachCAPT = malloc(pachSize);
		    StrCharCopyN(pSBRData->pachCAPT, pach, pachSize);
		    break;

	    case IDS_STATUSBR_PRINTECHOON:
		    if (pSBRData->pachPECHO)
			    {
			    free(pSBRData->pachPECHO);
			    pSBRData->pachPECHO = NULL;
			    }
		    pSBRData->pachPECHO = malloc(pachSize);
		    StrCharCopyN(pSBRData->pachPECHO, pach, pachSize);
		    break;

	    default:
		    break;
		    }
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrGetSizeInPixels
 *
 * DESCRIPTION:
 *  Caluclate the length of the string in pixels.  Adjust the
 *	length by some extra space to appear on the right of the string in the
 *	statusbar part.
 *
 * ARGUMENTS:
 *  hwnd 	- window handle.
 *	pszStr 	- pointer to a string.
 *
 * RETURNS:
 *  sz.cx 	- the size of the strings in pixels.
 *
 */
STATIC_FUNC int sbrGetSizeInPixels(const HWND hwnd, LPTSTR pszStr)
	{
    if (IsWindow(hwnd))
        {
	    HDC	  hDC;
	    SIZE  sz;

	    // Select the font of the statusbar...
	    //
	    hDC = GetDC(hwnd);

	    GetTextExtentPoint32(hDC,
						    (LPCTSTR)pszStr,
						    StrCharGetStrLength(pszStr),
						    &sz);
	    sz.cx += (EXTRASPACE * WINDOWSBORDERWIDTH);

	    ReleaseDC(hwnd, hDC);
	    return (sz.cx);
        }
    else
        {
        return 0;
        }

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrCalcPartSize
 *
 * DESCRIPTION:
 *	Calculate the largest string that may be displayed in a given
 *	statusbar part.  This function is called to calculate the length of the
 * 	emulator part and the connection status part.  Depending on the translation
 *	of the strings in the resources these parts will have to be of different
 *	length.
 *
 * ARGUMENTS:
 *	hwnd 	- window handle
 *	iId	 	- part identifier
 *
 * RETURNS:
 *	iLongest - the maximum size, in pixels, for the given part
 */
STATIC_FUNC int sbrCalcPartSize(const HWND hwnd, const int iId)
	{
	int 	iLongest = 0;
    if (IsWindow(hwnd))
        {
	    unsigned int aCnctTable[]= {IDS_STATUSBR_CONNECT,
								    IDS_STATUSBR_CONNECT_FORMAT,
								    IDS_STATUSBR_CONNECT_FORMAT_X,
								    IDS_STATUSBR_DISCONNECT,
								    IDS_STATUSBR_CONNECTING,
								    IDS_STATUSBR_DISCONNECTING};
	    TCHAR	ach[100],
			    achText[100];
	    int 	i;
		int		iRet = 0;
		int		nLimit;

	    if (iId == SBR_CNCT_PART_NO)
		    {
		    TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
		    nLimit = sizeof(aCnctTable) / sizeof(int);

		    for (i = 0; i < nLimit; i++)
			    {
			    LoadString(glblQueryDllHinst(), aCnctTable[i], ach, sizeof(ach) / sizeof(TCHAR));
			    if ((iRet = sbrGetSizeInPixels(hwnd, ach)) > iLongest)
				    iLongest = iRet;
			    }
		    }
	    else
		    {
		    #if 0
			DWORD nLen;
			BYTE  *pv;

		    if (resLoadDataBlock(glblQueryDllHinst(), IDT_EMU_NAMES,
				    (LPVOID *)&pv, &nLen))
			    {
			    return 0;
			    }

		    nEmuCount = *(RCDATA_TYPE *)pv;
		    pv += sizeof(RCDATA_TYPE);

		    for (i = 0 ; i < nEmuCount ; i++)
			    {
			    if ((nLen = (DWORD)StrCharGetByteCount((LPTSTR)pv) + (DWORD)sizeof(BYTE)) == 0)
					{
				    return 0;
					}

			    if ((iRet = sbrGetSizeInPixels(hwnd, pv)) > iLongest)
				    iLongest = iRet;

			    pv += (nLen + (DWORD)sizeof(RCDATA_TYPE));
			    }
		    #else 0
			int nLen;

		    for (i = IDS_EMUNAME_BASE ; i < IDS_EMUNAME_BASE + NBR_EMULATORS; i++)
			    {
			    nLen = LoadString(glblQueryDllHinst(), (unsigned int)i, achText, sizeof(achText) / sizeof(TCHAR));

			    if (nLen == 0)
					{
				    return (0);
					}

			    if ((iRet = sbrGetSizeInPixels(hwnd, achText)) > iLongest)
				    iLongest = iRet;
			    }
		    #endif // 0
		    }
        }

	return (iLongest);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrTimerRefresh
 *
 * DESCRIPTION:
 *	Refresh the timer display if we are connected.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *	void.
 *
 */
STATIC_FUNC void sbrTimerRefresh(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    TCHAR		ach[256], achFormat[256];
	    TCHAR		achTime[256];
	    int			iRet = -1;
	    HCNCT		hCnct = (HCNCT)0;
	    SYSTEMTIME	stSystem;

	    hCnct = sessQueryCnctHdl(pSBRData->hSession);

	    if (hCnct)
            {
		    iRet = cnctQueryStatus(hCnct);
            }

	    if (iRet == CNCT_STATUS_TRUE)
		    {
		    pSBRData->iLastCnctStatus = iRet;
		    sbrCnctTimeToSystemTime(hwnd, &stSystem, pSBRData);
		    achTime[0] = TEXT('\0');

		    if (GetTimeFormat(LOCALE_SYSTEM_DEFAULT,	
				    TIME_NOTIMEMARKER | TIME_FORCE24HOURFORMAT,
				    &stSystem, NULL, achTime, sizeof(achTime)) == 0)
			    {
			    DbgShowLastError();
			    sbrDrawCnctPart(hwnd, iRet, 0);
			    return;
			    }

		    // Load the "Connected %s" format string...
		    // Since this operation is costly, cach the connected format
		    // string...
		    //
		    if (pSBRData->pachCNCT)
			    {
			    wsprintf(ach, pSBRData->pachCNCT, achTime);
			    }

		    else
			    {
			    LoadString(glblQueryDllHinst(), IDS_STATUSBR_CONNECT_FORMAT,
				    achFormat, sizeof(achFormat) / sizeof(TCHAR));

			    sbrCachString(pSBRData, IDS_STATUSBR_CONNECT_FORMAT, achFormat);
			    wsprintf(ach, achFormat, achTime);
			    }

		    sbrDrawCnctPart(hwnd, -1, (LPTSTR)ach);
		    }
	    else
            {
		    if (iRet != pSBRData->iLastCnctStatus)
			    {
			    pSBRData->iLastCnctStatus = iRet;
			    sbrDrawCnctPart(hwnd, iRet, 0);
			    }
            }
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrCnctTimeToSystemTime
 *
 * DESCRIPTION:
 *  Get the connection elapsed time and express it in the SYSTEMTIME structure.
 *
 * ARGUMENTS:
 *  hwnd 		- statusbar window handle.
 *	lpSysTime 	- pointer to the SYSTEMTIME structure to fill.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC BOOL sbrCnctTimeToSystemTime(const HWND hwnd,
					LPSYSTEMTIME lpSysTime, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    HCNCT		hCnct = (HCNCT)0;
	    time_t 		tElapsed_time = (time_t)0;
	    WORD		wElapsed;

	    hCnct = sessQueryCnctHdl(pSBRData->hSession);

	    if (hCnct == (HCNCT)0)
		    return FALSE;

	    // Get the elapsed time from the connection driver...
	    //
	    if (cnctQueryElapsedTime(hCnct, &tElapsed_time) != 0)
		    {
		    assert(FALSE);
		    return FALSE;
		    }

	    // Do the neccessary conversion to get SYSTEMTIME from the elapsed time.
	    //
	    wElapsed = (WORD)tElapsed_time;
	    memset(lpSysTime, 0, sizeof(SYSTEMTIME));

	    lpSysTime->wMonth = 1;	// Jan=1 so it can't be zero.
	    lpSysTime->wHour = wElapsed/3600;
	    lpSysTime->wMinute = (wElapsed%3600)/60;
	    lpSysTime->wSecond = (wElapsed%3600)%60;

	    return TRUE;
        }
    else
        {
        return FALSE;
        }
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrCnctStatus
 *
 * DESCRIPTION:
 *	Refresh the contents of the connection part.
 *	Query the connection status and display appropriate text in the connection
 *	part.
 *
 * ARGUMENTS:
 * 	hwnd - window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrCnctStatus(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
        int		iRet = -1;
	    HCNCT	hCnct = (HCNCT)0;

        hCnct = sessQueryCnctHdl(pSBRData->hSession);

	    if (hCnct)
		    iRet = cnctQueryStatus(hCnct);

	    sbrDrawCnctPart(hwnd, iRet, (LPTSTR)0);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrDrawCnctPart
 *
 * DESCRIPTION:
 *	Draw a string in the connection part.
 *
 * ARGUMENTS:
 *  hwnd 		- window handle.
 *	iCnctStatus - connection status.
 *	pszStr		- if this string exists, then display it in the connection part,
 *			  otherwise read the string from the resource file according to
 *			  the value of the iCnctStatus parameter.
 *
 * RETURNS:
 *
 */
STATIC_FUNC void sbrDrawCnctPart(const HWND hwnd, const int iCnctStatus,
									LPTSTR pszStr)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && IsWindow(hwnd))
        {
	    TCHAR	ach[100];
	    UINT	iResId;

	    if (pszStr)
		    {
		    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_CNCT_PART_NO, (LPARAM)pszStr);
		    return;
		    }

	    switch (iCnctStatus)
		    {
	    case CNCT_STATUS_TRUE:
		    iResId = IDS_STATUSBR_CONNECT;
		    break;

	    case CNCT_STATUS_CONNECTING:
		    iResId = IDS_STATUSBR_CONNECTING;
		    break;

	    case CNCT_STATUS_DISCONNECTING:
		    iResId = IDS_STATUSBR_DISCONNECTING;
		    break;

        case CNCT_STATUS_ANSWERING:
            iResId = IDS_STATUSBR_ANSWERING;
            break;

	    default:
		    iResId = IDS_STATUSBR_DISCONNECT;
		    break;
		    }

	    // For Far-East version nothing would have to be done here since we are
	    // just reading a string from the resource and sending it to the common
	    // control which should be able to display a string containing DB chars.
	    //
	    LoadString(glblQueryDllHinst(),
				    iResId,
				    ach,
				    sizeof(ach) / sizeof(TCHAR));

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_CNCT_PART_NO, (LPARAM)(LPCTSTR)ach);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrEmulatorName
 *
 * DESCRIPTION:
 *	Refresh the contents of the emulator part.
 *	Get the emulator name and display it in the emulator part.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrEmulatorName(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    TCHAR	ach[100];
	    HEMU	hEmu = (HEMU)0;

	    hEmu = sessQueryEmuHdl(pSBRData->hSession);
	    ach[0] = TEXT('\0');

	    if (hEmu)
		    emuQueryName(hEmu, ach, sizeof(ach));

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_EMU_PART_NO,
		    (LPARAM)(LPCTSTR)ach);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrCom
 *
 * DESCRIPTION:
 *	Handles the Com portion of the status bar
 *
 * ARGUMENTS:
 *	hwnd	 - statusbar window handle
 *	pSBRData - data for this instance
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void sbrCom(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    TCHAR ach[100];

	    if (cnctGetComSettingsString(sessQueryCnctHdl(pSBRData->hSession), ach,
			    sizeof(ach) / sizeof(TCHAR)) == 0)
		    {
		    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_COM_PART_NO, (LPARAM)ach);
		    }
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrScrolLock
 *
 * DESCRIPTION:
 *	Display the status of the scroll lock key in the status bar.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *	void.
 *
 */
STATIC_FUNC void sbrScrolLock(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    int		iScrl = 0, nFlag = 0;

        iScrl = (GetKeyState(VK_SCROLL) & 1);
	    nFlag = (iScrl == 0) ? SBT_OWNERDRAW : 0;

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_SCRL_PART_NO | nFlag,
		    (LPARAM)(LPCTSTR)pSBRData->pachSCRL);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrCapsLock
 *
 * DESCRIPTION:
 *	Refresh the display of the scroll lock key state in the status bar.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrCapsLock(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    int		iCap = 0, nFlag = 0;

	    iCap = (GetKeyState(VK_CAPITAL) & 1);
	    nFlag = (iCap == 0) ? SBT_OWNERDRAW : 0;

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_CAPL_PART_NO | nFlag,
		    (LPARAM)(LPCTSTR)pSBRData->pachCAPL);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrNumLock
 *
 * DESCRIPTION:
 *	Display the current status for the Num Lock key on the status bar.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrNumLock(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    int		iNum = 0, nFlag = 0;

	    iNum  = (GetKeyState(VK_NUMLOCK) & 1);
	    nFlag = (iNum == 0) ? SBT_OWNERDRAW : 0;

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_NUML_PART_NO | nFlag,
		    (LPARAM)(LPCTSTR)pSBRData->pachNUML);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrCapture
 *
 * DESCRIPTION:
 *	Refresh Caputre part on the status bar.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrCapture(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    HCAPTUREFILE	hCapt;
	    int		nCapState = 0, nFlag = 0;

	    hCapt = sessQueryCaptureFileHdl(pSBRData->hSession);

	    if (hCapt != (HCAPTUREFILE)0)
		    nCapState = cpfGetCaptureState(hCapt);

	    nFlag = (nCapState & CPF_CAPTURE_ON) ? 0 : SBT_OWNERDRAW;

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_CAPT_PART_NO | nFlag,
		    (LPARAM)(LPCTSTR)pSBRData->pachCAPT);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbrPrintEcho
 *
 * DESCRIPTION:
 *	Display the status of the print echo in the status bar.
 *
 * ARGUMENTS:
 *  hwnd - window handle.
 *
 * RETURNS:
 *  void.
 *
 */
STATIC_FUNC void sbrPrintEcho(const HWND hwnd, const pSBR pSBRData)
	{
	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    TCHAR	ach[50];
	    HEMU	hEmu;
	    int		nPrneStatus = 0, nFlag = 0;

	    hEmu = sessQueryEmuHdl(pSBRData->hSession);
	    ach[0] = TEXT('\0');

	    if (hEmu != 0)
		    nPrneStatus = printQueryStatus(emuQueryPrintEchoHdl(hEmu));

	    nFlag = (nPrneStatus) ? 0 : SBT_OWNERDRAW;

	    SendMessage(hwnd, SB_SETTEXT, (WPARAM)SBR_PRNE_PART_NO | nFlag,
		    (LPARAM)(LPCTSTR)pSBRData->pachPECHO);
        }

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrCreateTimer
 *
 * DESCRIPTION:
 *  Create timer in order to show the connected time on the statusbar.
 *
 * ARGUMENTS:
 *  HWND	hwnd - statusbar window handle.
 *
 * RETURNS:
 *	TRUE - is success, FALSE - if failure
 *
 */
STATIC_FUNC BOOL sbrCreateTimer(const HWND hwnd, const pSBR pSBRData)
	{
	int  nRet;
    BOOL bRet = FALSE;

	if (FindAtom((LPCTSTR)SBR_ATOM_NAME) != 0 && pSBRData != NULL &&
        IsWindow(hwnd))
        {
	    nRet = TimerCreate(pSBRData->hSession,
					       &pSBRData->hTimer,
					       1000,
					       sbrTimerProc,
					       (void *)pSBRData);

        if (nRet == TIMER_OK)
            {
		    bRet =TRUE;
            }
        }

	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	sbrTimerProc
 *
 * DESCRIPTION:
 *	Timer callback that simply notifies the status line to check its
 *	display components.
 *
 * ARGUMENTS:
 *	DWORD	dwhWnd	-	window handle of status line.
 *  long    uTime	-   not used.
 *
 * RETURNS:
 *	void.
 *
 */
void CALLBACK sbrTimerProc(void *pvData, long uTime)
	{
	pSBR pSBRData = (SBR *)pvData;
    if (pSBRData != NULL && IsWindow(pSBRData->hwnd))
        {
	    SendMessage((HWND)pSBRData->hwnd, SBR_NTFY_TIMER, 0, 0L);
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  sbr_WM_DRAWITEM
 *
 * DESCRIPTION:
 *  When SB_SETTEXT message is sent to the statusbar with SBT_OWNERDRAW flag
 *	set a WM_DRAWITEM is posted to the parent window, in our case the session
 *	window.  This function is called from there with the data needed to draw,
 *	i.e., the pointer to DRAWITEMSTRUCT structure.
 *
 * ARGUMENTS:
 *  hwnd  - statusbar window handle.
 *	lpdis - pointer to a DRAWITEMSTRUCT structure filled with useful
 *			information needed to draw the item.
 *
 * RETURNS:
 *	void.
 *
 */
void sbr_WM_DRAWITEM(HWND hwnd, LPDRAWITEMSTRUCT lpdis)
	{
	COLORREF crSave;
	int		 nBkMode;

    if (IsWindow(hwnd))
        {

	    // Save and set text color, mode, etc...
	    //
	    crSave = GetTextColor(lpdis->hDC);
	    SetTextColor(lpdis->hDC, GetSysColor(COLOR_3DSHADOW));

	    nBkMode = GetBkMode(lpdis->hDC);
	    SetBkMode(lpdis->hDC, TRANSPARENT);

	    //
	    // OK, draw the text...
	    //
	    TextOut(lpdis->hDC, lpdis->rcItem.left + 2 * WINDOWSBORDERWIDTH,
		    lpdis->rcItem.top, (LPTSTR)lpdis->itemData,
			    StrCharGetStrLength((LPTSTR)lpdis->itemData));

	    SetTextColor(lpdis->hDC, crSave);
	    SetBkMode(lpdis->hDC, nBkMode);
        }

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\tdll.c ===
/*      File: D:\WACKER\tdll\tdll.c (Created: 26-Nov-1993)
 *
 *      Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *      All rights reserved
 *
 *      $Revision: 22 $
 *      $Date: 4/23/02 8:31a $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>

#include "stdtyp.h"
#include <term\res.h>
#include "globals.h"
#include "session.h"
#include "assert.h"
#include "misc.h"
#include "tdll.h"
#include "tdll\htchar.h"
#include "vu_meter.h"
#include "banner.h"
#include "mc.h"
#include "open_msc.h"
#ifdef INCL_DEFAULT_TELNET_APP
#include "telnetck.h"
#endif
#ifdef INCL_NAG_SCREEN
#include "nagdlg.h"
#include "register.h"
#endif
#include "term.h"

#define SESSION_CLASS TEXT("SESSION_WINDOW")


static BOOL InitDll(const HINSTANCE hInstance);
static BOOL DetachDll(const HINSTANCE hInstance);
static int  HTCheckInstance(TCHAR *pachCmdLine);
BOOL WINAPI TDllEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#if defined(INCL_PRIVATE_EDITION_BANNER)
static HINSTANCE gRTFInstanceHandle = NULL;

#if !defined(NT_EDITION)
BOOL RegisterBannerAboutClass(HANDLE hInstance); // see aboutdlg.c
BOOL UnregisterBannerAboutClass(HANDLE hInstance); // see aboutdlg.c
#endif

#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      TDllEntry
 *
 * DESCRIPTION:
 *      Currently, just initializes the C-Runtime library but may be used
 *      for other things later.
 *
 * ARGUMENTS:
 *      hInstDll        - Instance of this DLL
 *      fdwReason       - Why this entry point is called
 *      lpReserved      - reserved
 *
 * RETURNS:
 *      BOOL
 *
 */
BOOL WINAPI TDllEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	/* --- Docs say to call _CRT_INIT before any of our code - mrw --- */

	if (_CRT_INIT(hInstDll, fdwReason, lpReserved) == FALSE)
		return FALSE;

	switch (fdwReason)
		{
		case DLL_PROCESS_ATTACH:
			if (!InitDll(hInstDll))
				{
				return FALSE;
				}
			break;

		case DLL_PROCESS_DETACH:
			if (!DetachDll(hInstDll))
				{
				return FALSE;
				}
			break;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		default:
			break;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      InitDll
 *
 * DESCRIPTION:
 *      Intializes the application.  Done only for the first instance.
 *
 */
static BOOL InitDll(const HINSTANCE hInstance)
	{
	WNDCLASSEX  wc;

	// Documentation says this should be called once per application
	// If we use any of the common controls which we do.

	if(GetDllVersion(TEXT("comctl32.dll")) >= PACKVERSION(4,70))
		{
		INITCOMMONCONTROLSEX sInit;
		sInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
		sInit.dwICC = ICC_BAR_CLASSES | ICC_USEREX_CLASSES  | ICC_WIN95_CLASSES;

		InitCommonControlsEx(&sInit);
		}
		else
		{
		InitCommonControls();
		}

	memset(&wc, 0, sizeof(WNDCLASSEX));
	wc.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hInstance, SESSION_CLASS, &wc) == FALSE)
		{
		glblSetDllHinst(hInstance);

		// Read program's help file name from the resource file.
		// REV: 3/26/2002 Moved here so the shell extension
		// could use its context help.
		//
		glblSetHelpFileName();

		// Session Class
		wc.style         = CS_HREDRAW | CS_VREDRAW;
		wc.lpfnWndProc   = SessProc;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = 0;
		wc.hInstance     = hInstance;
		wc.hIcon         = extLoadIcon(MAKEINTRESOURCE(IDI_PROG));
		wc.hCursor       = LoadCursor(0, IDC_ARROW);
		wc.hbrBackground = NULL;
		wc.lpszMenuName  = TEXT("MainMenu");
		wc.lpszClassName = SESSION_CLASS;
		wc.hIconSm       = extLoadIcon(MAKEINTRESOURCE(IDI_PROG));

		if (RegisterClassEx(&wc) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}

		if (RegisterTerminalClass(hInstance) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}

		if (RegisterVuMeterClass(hInstance) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}

		if (RegisterSidebarClass(hInstance) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}

		#if !defined(NT_EDITION)
		#if defined(INCL_PRIVATE_EDITION_BANNER)
		if (RegisterBannerAboutClass(hInstance) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}
		#endif
		#endif
		}

    #if defined(INCL_PRIVATE_EDITION_BANNER)
    gRTFInstanceHandle = LoadLibrary("RICHED32");
    #endif

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      InitInstance
 *
 * DESCRIPTION:
 *      Creates the session window.  Does instance specific stuff.
 *
 * ARGUMENTS:
 *      HINSTANCE       hInstance       - apps instance handle.
 *      LPTSTR          lpCmdLine       - copy of the command line.
 *      int             nCmdShow        - passed from WinMain arg list.
 *
 */
BOOL InitInstance(const HINSTANCE hInstance,
					const LPTSTR lpCmdLine,
					const int nCmdShow)
	{
	HWND    hwnd;
	TCHAR   ach[100];
	HACCEL  hAccel;
	#if !defined(NT_EDITION)
	HWND    hwndBanner;
	DWORD   dwStart, dwNow;
	#endif

	#if !defined(NDEBUG)
    #if !defined(NO_SMARTHEAP)
	MemRegisterTask();
    #endif
	#endif

	// Save program's instance handle

	glblSetHinst(hInstance);

	if (HTCheckInstance(lpCmdLine) == TRUE)
		return FALSE;

	// Get program title

	LoadString(glblQueryDllHinst(),
				IDS_GNRL_APPNAME,
				ach,
				sizeof(ach) / sizeof(TCHAR));

	// Read program's help file name from the resource file.
	// JMH 12/12/96 Moved up here so the default telnet dialog
	// could use its context help.
	//
	// Now done in InitDLL() so that the help file is available
	// to the shell extension.  REV: 3/26/2002
	//
	// glblSetHelpFileName();

#ifdef INCL_NAG_SCREEN
    // Do the nag screen stuff
    //
    if ( IsEval() && IsTimeToNag() )
        {
        DoDialog(glblQueryDllHinst(),
                MAKEINTRESOURCE(IDD_NAG_SCREEN),
                0,
                DefaultNagDlgProc,
                0);
        }

#ifdef NDEBUG
    // Display the registration reminder dialog if needed...
    //
    if (!IsRegisteredUser())
        {
        if (IsInitialRun())
            {
            DoRegister();
            SetLastReminderDate();
            }

        else if (IsWillingToBeReminded())
            {
            if (IsTimeToRemind())
                DoRegistrationReminderDlg(0);
            }
        }

#endif // NDEBUG
#endif // INCL_NAG_SCREEN

#ifdef INCL_DEFAULT_TELNET_APP
    // Do the default telnet app stuff
    //
    if ( !IsHyperTerminalDefaultTelnetApp() && QueryTelnetCheckFlag() )
        {
#ifndef NT_EDITION
		//ask the user if they want HT to be the default telnet app
        DoDialog(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_DEFAULT_TELNET),
            0, DefaultTelnetAppDlgProc, 0);
#else
        //
        // Change back to always prompt per MS request. REV: 12/04/2000.
        //

        #if 0
        //mpt:8-9-97 MS asked us to make HT the default telnet app without asking - yippee!
		SetTelnetCheckFlag(FALSE);	//so we don't check again
		SetDefaultTelnetApp();		//just do it without asking
        #endif

        //ask the user if they want HT to be the default telnet app
        DoDialog(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_DEFAULT_TELNET),
            0, DefaultTelnetAppDlgProc, 0);
#endif // NT_EDITION
        }
#endif // INCL_DEFAULT_TELNET_APP

    // Setup and display the banner

#if !defined(NT_EDITION)
	bannerRegisterClass(glblQueryDllHinst());
		hwndBanner = bannerCreateBanner(glblQueryDllHinst(), ach);

	UpdateWindow(hwndBanner);
	glblSetHwndBanner(hwndBanner);

	dwStart = GetTickCount();
#endif // !NT_EDITION

	// Load accerator table for program.

	hAccel = LoadAccelerators(glblQueryDllHinst(), MAKEINTRESOURCE(IDA_WACKER));

	if (hAccel == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	glblSetAccelHdl(hAccel);

	// mpt:07-30-97
	if ( IsNT() )
		CreateUserDirectory();

	// Create a main window for this application instance.  Pass command
	// line string as user data to be stored and acted on later.

	hwnd = CreateWindowEx(
	  WS_EX_WINDOWEDGE,
	  SESSION_CLASS,
	  ach,
	  WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
	  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
	  0,
	  0,
	  glblQueryDllHinst(),
	  lpCmdLine
      );

	if (!IsWindow(hwnd))
		{
		assert(FALSE);
		return FALSE;
		}

	// Needed in the message loop unfortunately
	//
	glblSetHwndFrame(hwnd);

#if !defined(NT_EDITION)
	// Leave banner up at least BANNER_TIME
	//
	if (!glblQueryProgramStatus())
		{
		dwNow = GetTickCount();

		if ( (dwNow - dwStart) < BANNER_TIME)
            {
        #ifdef USE_PRIVATE_EDITION_3_BANNER
            // The HTPE 3.0 banner has a button on it. If we just sleep,
            // no Windows messages will be processed, so you can't push
            // the button. We need to sleep, but we also need to pump
            // messages as well. - cab:11/29/96
            //
            Rest(BANNER_TIME - (dwNow - dwStart));
        #else
			Sleep(BANNER_TIME - (dwNow - dwStart));
        #endif
            }
		}
#endif // !NT_EDITION

	// Post a message to size and show the window.
	//
	PostMessage(hwnd, WM_SESS_SIZE_SHOW, (WPARAM)nCmdShow, 0);

	// Posting this next messages kicks off the connection stuff
	//
	PostMessage(hwnd, WM_CMDLN_DIAL, (WPARAM)nCmdShow, 0);

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  MessageLoop
 *
 * DESCRIPTION:
 *  Wackers main message loop
 *
 * ARGUMENTS:
 *  void
 *
 * RETURNS:
 *  void
 *
 */
int MessageLoop(void)
    {
	MSG msg;

	while (GetMessage(&msg, 0, 0, 0))
		{
		if (!CheckModelessMessage(&msg))
			ProcessMessage(&msg);
		}

    return (int)msg.wParam;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      GetFileNameFromCmdLine
 *
 * DESCRIPTION:
 *      Extracts the file name, if any, from the command line and fully
 *      qualifies it.
 *
 * ARGUMENTS:
 *      pachCmdLine   Copy of command line
 *      pachFileName  Place to put the result
 *      nSize             Size of buffer pointed to by pachFileName (in TCHARs)
 *
 * RETURNS:
 *
 *
 */
int GetFileNameFromCmdLine(TCHAR *pachCmdLine, TCHAR *pachFileName, int nSize)
	{
	int                 nIdx = 0;
	TCHAR *             pszStr;
	TCHAR               acName[FNAME_LEN];
	TCHAR               acPath[FNAME_LEN];
	TCHAR               ach[_MAX_EXT];
	TCHAR *             pachFile;
	TCHAR *             pszTelnet = TEXT("telnet:"); //jmh 3/24/97
    int                 fTelnetCmdLnDial = FALSE;
	DWORD               dwFile;

    // Make sure all the filename buffers are nulled out.  REV: 11/14/2000.
    //
    TCHAR_Fill(pachFileName, TEXT('\0'), nSize);
    TCHAR_Fill(acName, TEXT('\0'), FNAME_LEN);
    TCHAR_Fill(acPath, TEXT('\0'), FNAME_LEN);

	nIdx = 0;

    //Just in case there is no command line. This happened when one specified '/t' 
    //with no hostname on the command line - mpt 05/28/99
    if ( pachCmdLine[0] == TEXT('\0') )
        {
        return 0;
        }
    
    for (pszStr = pachCmdLine;
			*pszStr != TEXT('\0') && nIdx < nSize;
			pszStr = StrCharNext(pszStr))
		{
		/*
		 * This works because we only allow certain characters as switches
		 */
		if (*pszStr == TEXT('/'))
			{
			/* Process as a switch */
			pszStr = StrCharNext(pszStr); // skip the switch char
            //JMH 03-24-97 Test for special case here...
            if (*pszStr == TEXT('\0'))
                {
                break;
                }
            else if (*pszStr == TEXT('T') || *pszStr == TEXT('t'))
                {
                fTelnetCmdLnDial = TRUE;
                }
			}
		else
			{
			/* Copy all non switch stuff to the buffer */
			if (nIdx < (FNAME_LEN - 1))
				{
				// JFH:6/9/95 acName[nIdx++] = *pszStr;
				if (IsDBCSLeadByte(*pszStr))
					{
					MemCopy(&acName[nIdx], pszStr, (size_t)2 * sizeof(TCHAR));
					nIdx += 2;
					}
				else
					{
					acName[nIdx++] = *pszStr;
					}
				}
			}
		}
    if (nIdx == nSize)
        {
	    acName[nIdx - 1] = TEXT('\0');
        }
    else
        {
	    acName[nIdx] = TEXT('\0');
        }

	/* Trim leading and trailing spaces */
	pszStr = TCHAR_Trim(acName);

	//jmh 3/24/97 Needed to copy this from sessCheckAndLoadCmdLn(), and modify it
	// slightly. This needs to be here because it affects the filename, and we want
	// to make sure we're comparing the same name as in other instances.
	#if defined(INCL_WINSOCK)
	// If this is a telnet address from the browser, it will usually be preceeded
	// by the string telnet:  If so, we must remove it or it will confuse some of
	// the code to follow  jkh, 03/22/1997
    if (fTelnetCmdLnDial)
        {
		nIdx = StrCharGetStrLength(pszTelnet);
        if (StrCharCmpiN(acName, pszTelnet, nIdx) == 0)
			{
			// Remove the telnet string from the front of acName
			memmove(acName, &acName[nIdx], (StrCharGetStrLength(acName) - nIdx) + 1);
			}
		}

	// See if URL contains a port number. This will take the form of
    // addr:nnn where nnn is the port number i.e. culine.colorado.edu:860
    // or there might be the name of an assigned port like hilgraeve.com:finger.
    // We support numeric port right now, may add port names later. jkh, 3/22/1997
    pszStr = StrCharFindFirst(acName, TEXT(':'));
    if (pszStr && isdigit(pszStr[1]))
        {
        *pszStr = TEXT('\0');
        }
	#endif // defined(INCL_WINSOCK)

	// Now that the parsing is done, open the session file if one
	// was supplied.  A session name that is not fully qualified may have
	// been passed in on the command line.  Fully qulaify that name, then
	// carry on.
	//
	dwFile = GetFullPathName(acName, FNAME_LEN, acPath, &pachFile);

	if (dwFile > 0 && dwFile <= FNAME_LEN)
		{
		StrCharCopyN(acName, acPath, FNAME_LEN);
		}
	#if !defined(NDEBUG)
	else
		{
		DWORD dwLastError = GetLastError();
		assert(FALSE);
		}
	#endif //!defined(NDEBUG)

	// Get hypertrm extension
	//
    TCHAR_Fill(ach, TEXT('\0'), _MAX_EXT);

	LoadString(glblQueryDllHinst(), IDS_GNRL_HAS, ach, _MAX_EXT);

	// For now, lets assume all session files end in HT.  If it
	// doesn't append the .HT.  John Hile and I have discussed
	// this and feel it should be otherwise but don't want to
	// make a change this late in the ball game. - mrw,3/2/95
	//
	if ((pszStr = StrCharFindLast(acName, '.')))
		{
        if (StrCharCmpi(pszStr, ach) != 0 && StrCharCmpi(pszStr, ".TRM") != 0)
            {
            nIdx = StrCharGetStrLength(acName) + StrCharGetStrLength(ach);

            if(nIdx > nSize)
                {
                ach[nSize - StrCharGetStrLength(ach) - 1] = TEXT('\0');
                }

			StrCharCat(acName, ach);
            }
		}
	else
		{
        nIdx = StrCharGetStrLength(acName) + StrCharGetStrLength(ach);

        if(nIdx > nSize)
            {
            acName[nSize - StrCharGetStrLength(ach) - 1] = TEXT('\0');
            }

		StrCharCat(acName, ach);
		}

	if (acName[0] != TEXT('\0'))
		{
		// Convert the possible short file name (i.e., the 8.3 format)
		// to the long file name and save it.
		//
		dwFile = GetFullPathName(acName, FNAME_LEN, acPath, &pachFile);

		if (dwFile > 0 && dwFile <= FNAME_LEN)
			{
			StrCharCopyN(acName, acPath, FNAME_LEN);
			}
		#if !defined(NDEBUG)
		else
			{
			DWORD dwLastError = GetLastError();
			assert(FALSE);
			}
		#endif //!defined(NDEBUG)
		}

	StrCharCopyN(pachFileName, acName, nSize);
    pachFileName[nSize - 1] = TEXT('\0');

	return 0;
	}

// Used for CheckInstCallback and HTCheckInstance
//
static int fKillTheApp;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      CheckInstCallback
 *
 * DESCRIPTION:
 *      Callback for EnumWindows
 *
 * ARGUMENTS:
 *      hwnd    - window handle from EmuWindows
 *      lPar    - optional data parameter (file name in this case)
 *
 * RETURNS:
 *      FALSE if it finds another instance using the same file name.
 *      TRUE if is doesn't
 *
 * AUTHOR: Mike Ward, 27-Jan-1995
 */
BOOL CALLBACK CheckInstCallback(HWND hwnd, LPARAM lPar)
	{
	BOOL  fRet = TRUE;
	TCHAR szClass[256];
	GetClassName(hwnd, szClass, sizeof(szClass));

	if (StrCharCmpi(szClass, SESSION_CLASS) == 0) // mrw, 2/12/95
		{
		ATOM aFile = GlobalAddAtom((TCHAR *)lPar);

		if (SendMessage(hwnd, WM_HT_QUERYOPENFILE, 0, (LPARAM)aFile))
			{
			if (!IsZoomed(hwnd))
				ShowWindow(hwnd, SW_RESTORE);

			SetForegroundWindow(hwnd);
			fKillTheApp = TRUE;
			fRet = FALSE;
			}

		GlobalDeleteAtom(aFile);
		}

	return fRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      CheckInstance
 *
 * DESCRIPTION:
 *      Checks if another instance of HyperTerminal is using this file.
 *
 * ARGUMENTS:
 *      pachFile        - filename this guy is trying to open
 *
 * RETURNS:
 *      TRUE=yes, another HT using it.
 *      FALSE=nope
 *
 * AUTHOR: Mike Ward, 27-Jan-1995
 */
static int HTCheckInstance(TCHAR *pachCmdLine)
	{
	TCHAR achPath[FNAME_LEN];

    // Make sure the filename buffer is nulled out.  REV: 11/14/2000.
    //
    TCHAR_Fill(achPath, TEXT('\0'), FNAME_LEN);

	// Get the filename
	//
	GetFileNameFromCmdLine(pachCmdLine, achPath, FNAME_LEN);

	// If EnumWindows callback (CheckInstCallback) matches the given
	// path, it will set the fKillApp guy to TRUE
	//
	fKillTheApp = FALSE;

	// EnumWindows will give our callback toplevel windows one at a time
	//
	EnumWindows(CheckInstCallback, (LPARAM)achPath);
	return fKillTheApp;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  Rest
 *
 * DESCRIPTION:
 *  This function causes the current thread to sleep for the given
 *  number of milliseconds. However, it will still process Windows
 *  messages.
 *
 * ARGUMENTS:
 *  dwMilliSecs - Number of milliseconds to sleep for.
 *
 * AUTHOR:  C. Baumgartner, 11/29/96
 */
void Rest(DWORD dwMilliSecs)
    {

    MSG   msg;
    DWORD dwStart = GetTickCount();
    DWORD dwStop = dwStart + dwMilliSecs;

    while( dwStop > GetTickCount() )
        {
        if ( GetMessage(&msg, NULL, 0, 0) )
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }
        }
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      DetachDll
 *
 * DESCRIPTION:
 *      Intializes the application.  Done only for the first instance.
 *
 */
static BOOL DetachDll(const HINSTANCE hInstance)
	{
	BOOL      lReturn = TRUE;
	#if !defined(NDEBUG)
	TCHAR     acError[80];
	#endif // !defined(NDEBUG)

    // Release the RICHED32 library if it was loaded. REV: 11/09/2000.
    //
    #if defined(INCL_PRIVATE_EDITION_BANNER)
    if (gRTFInstanceHandle)
        {
        FreeLibrary(gRTFInstanceHandle);
        gRTFInstanceHandle = NULL;
        }
    #endif

	if (UnregisterClass(SESSION_CLASS, hInstance) == FALSE)
		{
		assert(FALSE);
		lReturn = FALSE;
		#if !defined(NDEBUG)
		wsprintf(acError, TEXT("UnregisterClass returned error %d"),
				GetLastError());
		MessageBox(NULL, acError, NULL, MB_OK);
		#endif // !defined(NDEBUG)
		}

	if (UnregisterTerminalClass(hInstance) == FALSE)
		{
		assert(FALSE);
		lReturn = FALSE;
		#if !defined(NDEBUG)
		wsprintf(acError, TEXT("UnregisterTerminalClass returned error %d"),
				GetLastError());
		MessageBox(NULL, acError, NULL, MB_OK);
		#endif // !defined(NDEBUG)
		}

	if (UnregisterVuMeterClass(hInstance) == FALSE)
		{
		assert(FALSE);
		lReturn = FALSE;
		#if !defined(NDEBUG)
		wsprintf(acError, TEXT("UnregisterVuMeterClass returned error %d"),
				GetLastError());
		MessageBox(NULL, acError, NULL, MB_OK);
		#endif // !defined(NDEBUG)
		}

	if (UnregisterSidebarClass(hInstance) == FALSE)
		{
		assert(FALSE);
		lReturn = FALSE;
		#if !defined(NDEBUG)
		wsprintf(acError, TEXT("UnregisterSidebarClass returned error %d"),
				GetLastError());
		MessageBox(NULL, acError, NULL, MB_OK);
		#endif // !defined(NDEBUG)
		}

	#if !defined(NT_EDITION)
	#if defined(INCL_PRIVATE_EDITION_BANNER)
	if (UnregisterBannerAboutClass(hInstance) == FALSE)
		{
		assert(FALSE);
		lReturn = FALSE;
		#if !defined(NDEBUG)
		wsprintf(acError, TEXT("UnregisterBannerAboutClass returned error %d"),
				GetLastError());
		MessageBox(NULL, acError, NULL, MB_OK);
		#endif // !defined(NDEBUG)
		}
	#endif
	#endif

	return lReturn;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\tdll.h ===
/*	File: D:\WACKER\tdll\tdll.h (Created: 26-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 4/05/02 4:32p $
 */

#if !defined(INCL_TDLL)
#define INCL_TDLL

BOOL TerminateApplication(const HINSTANCE hInstance);

BOOL InitInstance(const HINSTANCE hInstance,
					const LPTSTR lpCmdLine,
					const int nCmdShow);

int MessageLoop(void);
INT ExitMessage(const int nMessageNumber);

int GetFileNameFromCmdLine(TCHAR *pachCmdLine, TCHAR *pachFileName, int nSize);

LRESULT CALLBACK SessProc(HWND hwnd, UINT msg, WPARAM uPar, LPARAM lPar);

INT_PTR DoDialog(HINSTANCE hInst, LPCTSTR lpTemplateName, HWND hwndParent,
			 DLGPROC lpProc, LPARAM lPar);

HWND DoModelessDialog(HINSTANCE hInst, LPCTSTR lpTemplateName, HWND hwndParent,
			 DLGPROC lpProc, LPARAM lPar);

INT EndModelessDialog(HWND hDlg);

INT_PTR CALLBACK TransferSendDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
INT_PTR CALLBACK TransferReceiveDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

INT_PTR CALLBACK CaptureFileDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
INT_PTR CALLBACK PrintEchoDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

INT_PTR CALLBACK NewConnectionDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

INT_PTR CALLBACK asciiSetupDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

void AboutDlg(HWND hwndSession);
BOOL RegisterTerminalClass(const HINSTANCE hInstance);
BOOL UnregisterTerminalClass(const HINSTANCE hInstance);

void ProcessMessage(MSG *pmsg);
int  CheckModelessMessage(MSG *pmsg);

int RegisterSidebarClass(const HINSTANCE hInstance);
int UnregisterSidebarClass(const HINSTANCE hInstance);

void Rest(DWORD dwMilliSecs);

// from clipbrd.c

BOOL CopyBufferToClipBoard(const HWND hwnd, const DWORD dwCnt, const void *pvBuf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\term.h ===
/*	File: D:\WACKER\tdll\term.h (Created: 29-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:35p $
 */

#if !defined(INCL_EXT_TERM)
#define INCL_EXT_TERM

/* --- Class name needed in ProcessMessage() --- */

#define TERM_CLASS		"Term Class"

// Some conventions:
//	Q = Query
//	S = Set

#define WM_TERM_GETUPDATE		WM_USER+0x100	// read update records
												// wPar=0, lPar=0
#define WM_TERM_BEZEL			WM_USER+0x101	// toggle bezel on/off
												// wPar=0, lPar=0
#define WM_TERM_Q_BEZEL 		WM_USER+0x102	// query bezel status (on/off)
												// wPar=0, lPar=0
#define WM_TERM_Q_SNAP			WM_USER+0x103	// calculate snapped size
												// wPar=0, lPar=LPRECT
#define WM_TERM_KEY 			WM_USER+0x104	// terminal key pressed
												// wPar=key, lPar=0
#define WM_TERM_CLRATTR 		WM_USER+0x105	// Emulator's clear attr changed
												// wPar=0, lPar=0
#define WM_TERM_GETLOGFONT		WM_USER+0x106	// Query terminal's logfont
												// wPar=0, lPar=&lf
#define WM_TERM_SETLOGFONT		WM_USER+0x107	// Set terminal's logfont
												// wPar=0, lPar=&lf
#define WM_TERM_Q_MARKED		WM_USER+0x108	// Is text marked
												// wPar=0, lPar=0
#define WM_TERM_UNMARK			WM_USER+0x109	// Unmarks any text
												// wPar=0, lPar=0
#define WM_TERM_TRACK			WM_USER+0x10A	// shift terminal to show cursor
												// wPar=0, lPar=0
#define WM_TERM_EMU_SETTINGS	WM_USER+0x10B	// emulator settings have changed
												// wPar=0, lPar=0
#define WM_TERM_Q_MARKED_RANGE 	WM_USER+0x10C	// query marked text range
												// wPar=PPOINT, lPar=PPOINT
#define WM_TERM_LOAD_SETTINGS 	WM_USER+0x10D	// Read terminal settings
												// wPar=0, lPar=0
#define WM_TERM_SAVE_SETTINGS	WM_USER+0x10E	// Save terminal settings
                                                // wPar=0, lPar=0
#define WM_TERM_MARK_ALL	    WM_USER+0x10F	// Mark all terminal text
												// wPar=0, lPar=0
#define WM_TERM_FORCE_WMSIZE	WM_USER+0x110	// Calls wm_size code
												// wPar=0, lPar=0
#define WM_TERM_CLEAR_BACKSCROLL WM_USER+0x111  // Clear backscroll area

#define WM_TERM_CLEAR_SCREEN    WM_USER+0x112   // Clear terminal screen

// Button 1 Double-click settings.

#define B1_SELECTWORD		0	// Selects a word
#define B1_COPYWORD 		1	// Copies word or selected text to host
#define B1_COPYWORDENTER	2	// Same but adds <ENTER> at end

// Button 2 click settings.

#define B2_CONTEXTMENU		0	// Popup context menu
#define B2_HOSTCURSOR		1	// Positions host cursor
#define B2_SINGLELETTER 	2	// Copies single letter to host
#define B2_DONOTHING		3	// disables button 2 clicks.

/* --- Color table lives in terminal files --- */

int GetNearestColorIndex(COLORREF cr);
void RefreshTermWindow(const HWND hwndTerm);

int termSetLogFont(const HWND hwndTerm, LPLOGFONT plf);
int termGetLogFont(const HWND hwndTerm, LPLOGFONT plf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\telnetck.c ===
/*	File: D:\WACKER\tdll\telnetck.c (Created: 26-Nov-1996 by cab)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description:
 *      Implements the functions used to implement "telnet checking".
 *      This is HyperTerminal's way of assuring that it is the
 *      default telnet app for Internet Explorer and Netscape Navigator.
 *
 *	$Revision: 5 $
 *	$Date: 5/15/02 4:37p $
 */

#include <windows.h>
#pragma hdrstop

#include "features.h"

#ifdef INCL_DEFAULT_TELNET_APP

#include "assert.h"
#include "stdtyp.h"
#include "globals.h"
#include "htchar.h"
#include "registry.h"

#include "hlptable.h"

// Control IDs for the dialog:
//
#define IDC_PB_YES          IDOK
#define IDC_PB_NO           IDCANCEL
#define IDC_CK_STOP_ASKING  200
#define IDC_ST_QUESTION     201
#define IDC_IC_EXCLAMATION  202

// Registry key for HyperTerminal:
//
#ifndef NT_EDITION
static const TCHAR g_achHyperTerminalRegKey[] =
    TEXT("SOFTWARE\\Hilgraeve Inc\\HyperTerminal PE\\3.0");
#else
static const TCHAR g_achHyperTerminalRegKey[] =
    TEXT("SOFTWARE\\Microsoft\\HyperTerminal");
#endif

// Registry value for telnet checking:
//
static const TCHAR g_achTelnetCheck[] = TEXT("Telnet Check");

// Registry keys for the web browsers:
//
static const TCHAR g_achIERegKey[] =
    TEXT("SOFTWARE\\Classes\\telnet\\shell\\open\\command");

static const TCHAR g_achNetscapeRegKey[] =
    TEXT("SOFTWARE\\Netscape\\Netscape Navigator\\Viewers");

// Registry values for the browser telnet apps:
//
static const TCHAR g_achIERegValue[] = TEXT("");

static const TCHAR g_achNetscapeRegValue[] = TEXT("telnet");

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	IsHyperTerminalDefaultTelnetApp
 *
 * DESCRIPTION:
 *	Determines if HyperTerminal is the default telnet app for Internet
 *  Explorer and Netscape Navigator.
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  C. Baumgartner, 11/26/96
 */
BOOL IsHyperTerminalDefaultTelnetApp(void)
    {
    TCHAR acExePath[MAX_PATH];
    TCHAR acRegistryData[MAX_PATH * 2];
    long  lRet = 0;
    DWORD dwSize = sizeof(acRegistryData);

    // Get the path name of HyperTerminal.
    //
    acExePath[0] = TEXT('\0');
    GetModuleFileName(glblQueryHinst(), acExePath, MAX_PATH);

    // Get IE's default telnet app.
    //
    acRegistryData[0] = TEXT('\0');
    if ( htRegQueryValue(HKEY_LOCAL_MACHINE, g_achIERegKey,
                         g_achIERegValue, acRegistryData, &dwSize) == 0 )
        {
        if ( StrCharStrStr(acRegistryData, acExePath) == NULL )
            {
            return FALSE;
            }
        }
        
    // Get Netscape's default telnet app.
    //
    acRegistryData[0] = TEXT('\0');
    if ( htRegQueryValue(HKEY_CURRENT_USER, g_achNetscapeRegKey,
                         g_achNetscapeRegValue, acRegistryData, &dwSize) == 0 )
        {
        if ( StrCharStrStr(acRegistryData, acExePath) == NULL )
            {
            return FALSE;
            }
        }

    return TRUE;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	QueryTelnetCheckFlag
 *
 * DESCRIPTION:
 *	Returns the value of the "telnet checking" flag. If this is TRUE,
 *  the app should check whether it is the default telnet app for IE
 *  and Netscape. If it isn't the default telnet app, then display
 *  the "Default Telnet App" dialog. The user can disable "telnet
 *  checking" by checking the "Stop asking me this question" box.
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  C. Baumgartner, 11/26/96
 */
 BOOL QueryTelnetCheckFlag(void)
    {
    DWORD dwTelnetCheck = TRUE;
    DWORD dwSize = sizeof(dwTelnetCheck);

    if ( htRegQueryValue(HKEY_CURRENT_USER, g_achHyperTerminalRegKey,
                         g_achTelnetCheck, (LPBYTE) &dwTelnetCheck, &dwSize) == 0 )
        {
        return dwTelnetCheck;
        }

    return TRUE;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SetTelnetCheckFlag
 *
 * DESCRIPTION:
 *	Sets the "telnet checking" flag which will either turn on or off
 *  this feature the next time HyperTerminal starts.
 *
 * PARAMETERS:
 *	fCheck - Check if HyperTerminal is the default telnet app?
 *
 * RETURNS:
 *	0 if successful, -1 if error
 *
 * AUTHOR:  C. Baumgartner, 11/27/96
 */
int SetTelnetCheckFlag(BOOL fCheck)
    {
    int iRet = 0;

    if ( regSetDwordValue(HKEY_CURRENT_USER, g_achHyperTerminalRegKey,
            g_achTelnetCheck, (DWORD)fCheck) != 0 )
        {
        iRet = -1;
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SetDefaultTelnetApp
 *
 * DESCRIPTION:
 *	Sets the default telnet application for IE and Netscape to HyperTerminal.
 *
 * PARAMETERS:
 *	None
 *
 * RETURNS:
 *	0 if successful, -1 if error
 *
 * AUTHOR:  C. Baumgartner, 11/27/96
 */
 int SetDefaultTelnetApp(void)
    {
    int   iRet = 0;
    TCHAR acExePath[MAX_PATH];
    TCHAR acRegistryData[MAX_PATH * 2];

    // Get the path name of HyperTerminal.
    //
    acExePath[0] = TEXT('\0');
    GetModuleFileName(glblQueryHinst(), acExePath, MAX_PATH);

    // Create the Netscape telnet command string.
    //
    acRegistryData[0] = TEXT('\0');
    wsprintf(acRegistryData, "%s /t", acExePath);

    // Write it to the registry.
    //
    if ( regSetStringValue(HKEY_CURRENT_USER, g_achNetscapeRegKey,
            g_achNetscapeRegValue, acRegistryData) != 0 )
        {
        // Just set the return flag to mark that we failed.
        //
        iRet = -1;
        }

    // Create the IE telnet command string.
    //
    acRegistryData[0] = TEXT('\0');
    wsprintf(acRegistryData, "%s /t %%1", acExePath);

    // Write it to the registry.
    //
    if ( regSetStringValue(HKEY_LOCAL_MACHINE, g_achIERegKey, g_achIERegValue,
            acRegistryData) != 0 )
        {
        // Just set the return flag to mark that we failed.
        //
        iRet = -1;
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	DefaultTelnetAppDlgProc
 *
 * DESCRIPTION:
 *	The dialog procedure for the "Default Telnet App" dialog.
 *  This dialog asks the user if he/she wants HyperTerminal
 *  to be the default telnet app for IE and NN. There also is
 *  a check box to disable this potentially annoying feature.
 *
 * PARAMETERS:
 *	hDlg - The dialog's window handle.
 *  wMsg - The message being sent to the window.
 *  wPar - The message's wParam.
 *  lPar - The message's lParam.
 *
 * RETURNS:
 *	TRUE or FALSE
 *
 * AUTHOR:  C. Baumgartner, 11/26/96
 */
INT_PTR CALLBACK DefaultTelnetAppDlgProc(HWND hDlg, UINT wMsg,
        WPARAM wPar, LPARAM lPar)
    {

	static	DWORD aHlpTable[] = {IDC_CK_STOP_ASKING,	IDH_TELNETCK_STOP_ASKING,
                                IDC_PB_YES,             IDH_TELNETCK_YES,
								IDC_PB_NO,				IDH_TELNETCK_NO,	
								0, 						0};

	switch (wMsg)
		{
	case WM_DESTROY:
        // Check the value of the "Stop asking me" checkbox.
        //
        SetTelnetCheckFlag(!(IsDlgButtonChecked(hDlg, IDC_CK_STOP_ASKING) == BST_CHECKED));
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDC_PB_YES:
            SetDefaultTelnetApp();
			EndDialog(hDlg, TRUE);
			break;

		case IDC_PB_NO:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\telnetck.h ===
#if !defined(INCL_TELNETCK)
#define INCL_TELNETCK

/*	File: D:\WACKER\tdll\telnetck.h (Created: 26-Nov-1996 by cab)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description:
 *      Declares the functions used to implement "telnet checking".
 *      This is HyperTerminal's way of assuring that it is the
 *      default telnet app for Internet Explorer and Netscape Navigator.
 *
 *	$Revision: 2 $
 *	$Date: 5/09/01 4:38p $
 */

// IsHyperTerminalDefaultTelnetApp
//
// Returns TRUE if HyperTerminal is the default telnet app
// for Internet Explorer and Netscape Navigator.
//
BOOL IsHyperTerminalDefaultTelnetApp(void);

// AskForDefaultTelnetApp
//
// Returns the value of the "telnet checking" flag. If this is TRUE,
// the app should check whether it is the default telnet app for IE
// and Netscape. If it isn't the default telnet app, then display
// the "Default Telnet App" dialog. The user can disable "telnet
// checking" by checking the "Stop asking me this question" box.
//
BOOL QueryTelnetCheckFlag(void);

// DefaultTelnetAppDlgProc
//
// The dialog procedure for the "Default Telnet App" dialog.
// This dialog asks the user if he/she wants HyperTerminal
// to be the default telnet app for IE and NN. There also is
// a check box to disable this potentially annoying feature.
//
INT_PTR CALLBACK DefaultTelnetAppDlgProc(HWND hDlg, UINT wMsg,
    WPARAM wPar, LPARAM lPar);

//	SetTelnetCheckFlag
//
// Sets the "telnet checking" flag which will either turn on or off
// this feature the next time HyperTerminal starts.
int SetTelnetCheckFlag(BOOL fCheck);

//	SetDefaultTelnetApp
//
//	Sets the default telnet application for IE and Netscape to HyperTerminal.
int SetDefaultTelnetApp(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termcur.c ===
/*	File: D:\WACKER\tdll\termcur.c (Created: 26-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 3/26/02 8:44a $
 */
#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "session.h"
#include "assert.h"
#include "timers.h"
#include <emu\emu.h>
#include "term.h"
#include "term.hh"
#include "misc.h"

static void CalcHstCursorRect(const HHTERM hhTerm, const PRECT prc);
static void CalcLclCursorRect(const HHTERM hhTerm, const PRECT prc);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CalHstCursorRect (static function seen only by TERMPROC.C)
 *
 * DESCRIPTION:
 *	Figures out the bounding rectangle of the host cursor.
 *
 * ARGUMENTS:
 *	HTERM	hTerm	  - pointer to the terminal instance data
 *	PRECT	prc 	  - pointer to rectangle to fill
 *
 * RETURNS:
 *	Nothing.
 *
 */
static void CalcHstCursorRect(const HHTERM hhTerm, const PRECT prc)
	{
	int iRow;
	
	prc->bottom = ((hhTerm->ptHstCur.y + 2 - hhTerm->iVScrlPos)) * hhTerm->yChar;
	prc->top	= prc->bottom - hhTerm->iHstCurSiz;

	prc->left	= (((hhTerm->ptHstCur.x - hhTerm->iHScrlPos) * hhTerm->xChar)) +
						hhTerm->xIndent + hhTerm->xBezel;

	prc->right	= prc->left + hhTerm->xChar;

	// Check for double wide left/right pair.  If so, make the
	// cursor wider.

	iRow = (hhTerm->ptHstCur.y + hhTerm->iTopline) % MAX_EMUROWS;

	if (hhTerm->ptHstCur.x < (MAX_EMUCOLS - 1) &&
			hhTerm->fppstAttr[iRow][hhTerm->ptHstCur.x].dblwilf &&
				hhTerm->fppstAttr[iRow][hhTerm->ptHstCur.x+1].dblwirt)
		{
		prc->right += hhTerm->xChar;
		}

	// This keeps the cursor from appearing in the indent margin.

	if (prc->left <= hhTerm->xIndent)
		prc->left = prc->right = 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CalLclCursorRect (static function seen only by TERMPROC.C)
 *
 * DESCRIPTION:
 *	Figures out the bounding rectangle of the selection cursor.
 *
 * ARGUMENTS:
 *	hhTerm	 hhTerm 	- pointer to the terminal instance data
 *	PRECT	prc 	  - pointer to rectangle to fill
 *
 * RETURNS:
 *	Nothing.
 *
 */
static void CalcLclCursorRect(const HHTERM hhTerm, const PRECT prc)
	{
	prc->left = ((hhTerm->ptLclCur.x - hhTerm->iHScrlPos) * hhTerm->xChar)
		+ hhTerm->xIndent + hhTerm->xBezel;

	prc->right = prc->left + 2;
	prc->top = (hhTerm->ptLclCur.y - hhTerm->iVScrlPos) * hhTerm->yChar;
	prc->bottom = prc->top + hhTerm->yChar;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PaintHostCursor
 *
 * DESCRIPTION:
 *	Paints the host cursor at the position and style in hLayout.  Also
 *	Hides and shows the caret or local cursor which was not part of the
 *	orginal design here but fit in nicely.
 *
 */
void PaintHostCursor(const HHTERM hhTerm, const BOOL fOn, const HDC hdc)
	{
	RECT	rc;

	if (hhTerm->fHstCurOn == fOn)
		return;

	hhTerm->fHstCurOn = fOn;
	CalcHstCursorRect(hhTerm, &rc);
	InvertRect(hdc, &rc);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PaintLocalCursor
 *
 * DESCRIPTION:
 *	Local meaning the seletion cursor in this case.
 *
 */
void PaintLocalCursor(const HHTERM hhTerm, const BOOL fOn, const HDC hdc)
	{
	RECT	rc;

	if (hhTerm->fCursorsLinked && hhTerm->fLclCurOn == 0)
		return;

	if (hhTerm->fLclCurOn == fOn)
		return;

	hhTerm->fLclCurOn = fOn;
	CalcLclCursorRect(hhTerm, &rc);
	InvertRect(hdc, &rc);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ShowCursors
 *
 * DESCRIPTION:
 *	Use to just show the host cursor but also shows the caret or local
 *	cursor as well.
 *
 * ARGUMENTS:
 *	HHTERM	hhTerm	- internal terminal handle.
 *
 * RETURNS:
 *	VOID
 *
 */
void ShowCursors(const HHTERM hhTerm)
	{
	const HDC hdc = GetDC(hhTerm->hwnd);

	PaintHostCursor(hhTerm, TRUE, hdc);
	PaintLocalCursor(hhTerm, TRUE, hdc);

	ReleaseDC(hhTerm->hwnd, hdc);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	HideCursors
 *
 * DESCRIPTION:
 *	Use to just hide the host cursor but also hides the caret or local
 *	cursor as well.
 *
 * ARGUMENTS:
 *	HHTERM	hhTerm	- internal terminal handle.
 *
 * RETURNS:
 *	VOID
 *
 */
void HideCursors(const HHTERM hhTerm)
	{
	const HDC hdc = GetDC(hhTerm->hwnd);

	PaintHostCursor(hhTerm, FALSE, hdc);
	PaintLocalCursor(hhTerm, FALSE, hdc);

	ReleaseDC(hhTerm->hwnd, hdc);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SetLclCurPos
 *
 * DESCRIPTION:
 *	The local cursor is the marking cursor.  This routine just positions
 *	it according to the coordinates handling any painting requirements.
 *
 * ARGUMENTS:
 *	HHTERM	hhTerm	- internal terminal handle
 *	LPPOINT ptCur	- point structure where marking cursor goes
 *
 * RETURNS:
 *	VOID
 *
 */
void SetLclCurPos(const HHTERM hhTerm, const LPPOINT lpptCur)
	{
	const HDC hdc = GetDC(hhTerm->hwnd);

	PaintLocalCursor(hhTerm, FALSE, hdc);
	hhTerm->ptLclCur = *lpptCur;
	hhTerm->fCursorsLinked = FALSE;
	PaintLocalCursor(hhTerm, TRUE, hdc);

	ReleaseDC(hhTerm->hwnd, hdc);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	LinkCursors
 *
 * DESCRIPTION:
 *	Magic little function that causes the selection cursor to link-up with
 *	the host cursor.  This happens the view has to be shifted to present
 *	the host cursor or when characters are typed at the keyboard.
 *
 * ARGUMENTS:
 *	HHTERM	 hhTerm   - internal terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
void LinkCursors(const HHTERM hhTerm)
	{
	if (!hhTerm->fCursorsLinked)
		{
		const HDC hdc = GetDC(hhTerm->hwnd);

		hhTerm->fCursorsLinked = TRUE;
		PaintLocalCursor(hhTerm, FALSE, hdc);
		ReleaseDC(hhTerm->hwnd, hdc);

		hhTerm->fExtSelect = FALSE;

		MarkText(hhTerm, &hhTerm->ptBeg, &hhTerm->ptEnd, FALSE, MARK_ABS);
		hhTerm->ptBeg = hhTerm->ptEnd = hhTerm->ptHstCur;
		TestForMarkingLock(hhTerm);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MoveSelectionCursor
 *
 * DESCRIPTION:
 *	Moves the selection cursor by the specified amount and updates the
 *	terminal window so that the cursor is in view.	Used by kbd routines.
 *
 * ARGUMENTS:
 *	HTERM	hTerm	- handle to terminal
 *	HWND	hwnd	- terminal window
 *	INT 	x		- amount to move left or right
 *	INT 	y		- amount to move up or down
 *	BOOL	fMarking- TRUE means we are marking text.
 *
 * RETURNS:
 *	void
 *
 */
void MoveSelectionCursor(const HHTERM hhTerm,
						 const HWND hwnd,
							   int	x,
							   int	y,
							   BOOL fMarking)
	{
	int yTemp;
	POINT ptTmp;

	// Extended selection is where the user does not have to hold down
	// shift keys to select text. - mrw

	fMarking |= hhTerm->fExtSelect;

	if (fMarking == FALSE)
		UnmarkText(hhTerm);

	ptTmp = hhTerm->ptEnd;

	// This tests to see if the selection cursor is on-screen.	If the
	// selection cursor is off-screen, place it at the top of the
	// screen and then perform the operation.  This is how MicroSoft
	// Word behaves.

	if (hhTerm->ptEnd.y < hhTerm->iVScrlPos ||
			(hhTerm->ptEnd.y - hhTerm->iTermHite + 1) > hhTerm->iVScrlPos)
		{
		hhTerm->ptEnd.y = hhTerm->iVScrlPos;
		}

	hhTerm->ptEnd.x += x;
	hhTerm->ptEnd.x = max(min(hhTerm->iCols, hhTerm->ptEnd.x), 0);

	yTemp = hhTerm->ptEnd.y += y;
	hhTerm->ptEnd.y = max(min(hhTerm->iRows, hhTerm->ptEnd.y), hhTerm->iVScrlMin);

 	//mpt:1-23-98 attempt to re-enable DBCS code
#ifndef CHAR_NARROW
	termValidatePosition(hhTerm,
						x >= 0 ? VP_ADJUST_RIGHT : VP_ADJUST_LEFT,
						&hhTerm->ptEnd);
#endif

	if (fMarking == FALSE)
		hhTerm->ptBeg = hhTerm->ptEnd;

	SetLclCurPos(hhTerm, &hhTerm->ptEnd);

	// Figure out much to scroll vertically.

	if (hhTerm->ptEnd.y < hhTerm->iVScrlPos)
		y = hhTerm->ptEnd.y;

	else if ((hhTerm->ptEnd.y - hhTerm->iTermHite) >= hhTerm->iVScrlPos)
		y = hhTerm->ptEnd.y - hhTerm->iTermHite + 1;

	else
		y = hhTerm->iVScrlPos;

	// This condition occurs when we are scrolling and the Bezel is
	// present.
	//
	if (yTemp > hhTerm->ptEnd.y && y < hhTerm->iVScrlMax)
		y = hhTerm->iVScrlMax;

	// Do the scroll
	//
	if (y != hhTerm->iVScrlPos)
		SendMessage(hwnd, WM_VSCROLL, MAKEWPARAM(SB_THUMBPOSITION, y), 0);

	// Figure out much to scroll horizontally
	//
	if (hhTerm->ptEnd.x < hhTerm->iHScrlPos)
		x = hhTerm->ptEnd.x;

	else if (hhTerm->ptEnd.x >= (hhTerm->iHScrlPos + hhTerm->iCols - hhTerm->iHScrlMax))
		x = hhTerm->ptEnd.x - (hhTerm->iCols - hhTerm->iHScrlMax) + 1;

	else
		x = hhTerm->iHScrlPos;

	if (x != hhTerm->iHScrlPos)
		SendMessage(hwnd, WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, x), 0);

	// Force update to keep things smooth looking.	Note, UpdateWindow()
	// does nothing if the update rectangle is NULL.

	if (fMarking)
		MarkText(hhTerm, &ptTmp, &hhTerm->ptEnd, TRUE, MARK_XOR);

	UpdateWindow(hwnd);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CursorTimerProc
 *
 * DESCRIPTION:
 *	Multiplex timer callback routine used for cursor blinking.	Also
 *	controls blinking text.
 *
 * ARGUMENTS:
 *	pvhwnd	- terminal window handle.
 *	ltime	- contains time elapsed.
 *
 * RETURNS:
 *	void
 *
 */
void CALLBACK CursorTimerProc(void *pvhwnd, long ltime)
	{
	const HWND hwnd = (HWND)pvhwnd;

	if (GetFocus() == hwnd)
		{
		const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

		if (hhTerm->fBlink && !IsTerminalServicesEnabled())
			{
			const HDC hdc = GetDC(hhTerm->hwnd);
			PaintHostCursor(hhTerm, hhTerm->fHstCurOn ? FALSE : TRUE, hdc);
			ReleaseDC(hhTerm->hwnd, hdc);
			}

		BlinkText(hhTerm);
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termhdl.c ===
/*	File: D:\WACKER\tdll\termhdl.c (Created: 10-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 15 $
 *	$Date: 7/08/02 6:50p $
 */

#include <windows.h>
#pragma hdrstop

#include <string.h>
#include "stdtyp.h"
#include <term\res.h>
#include "tdll.h"
#include "globals.h"
#include "mc.h"
#include "assert.h"
#include "session.h"
#include "timers.h"
#include "update.h"
#include <emu\emu.h>
#include <emu\emu.hh>
#include "htchar.h"
#include "term.h"
#include "term.hh"
#include "misc.h"

// This structure never referenced directly.  Instead, a pointer is
// stored to this array.  Was easier to initialize by being static.

static const COLORREF crEmuColors[MAX_EMUCOLORS] =
	{
	RGB(  0,   0,	0), 			// black
	RGB(  0,   0, 128),             // blue
	RGB(  0, 128,   0),             // green
	RGB(  0, 128, 128),             // cyan
	RGB(128,   0,   0),             // red
	RGB(128,   0, 128),             // magenta
	RGB(128, 128,  32),             // yellow
	RGB(192, 192, 192),             // white (lt gray)
	RGB(128, 128, 128),             // black (gray)
	RGB(  0,   0, 255),             // intense blue
	RGB(  0, 255,   0),             // intense green
	RGB(  0, 255, 255),             // intense cyan
	RGB(255,   0,   0),             // intense red
	RGB(255,   0, 255),             // intense magenta
	RGB(255, 255,   0),             // intense yellow
	RGB(255, 255, 255)				// intense white
	};

static BOOL AllocTxtBuf(ECHAR ***fpalpstr, int const sRows, int const sCols);
static BOOL AllocAttrBuf(PSTATTR **fpapst, const int sRows, const int sCols);
static void FreeTxtBuf(ECHAR ***fpalpstr, const int sRows);
static void FreeAttrBuf(PSTATTR **fpapst, const int sRows);
static BOOL termAllocBkBuf(const HHTERM hhTerm);
static void termFreeBkBuf(const HHTERM hhTerm);
static void GetDefaultDBCSFont(const HHTERM hhTerm);
static int APIENTRY EnumFontCallback(LPLOGFONT lplf, LPTEXTMETRIC lptm,
							DWORD dwType, LPVOID lpData);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	RegisterTerminalClass
 *
 * DESCRIPTION:
 *	Registers the terminal class.  Called in InitApplication()
 *
 * ARGUMENTS:
 *	hInstance	- Instance handle of app.
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL RegisterTerminalClass(const HINSTANCE hInstance)
	{
	WNDCLASSEX  wc;

	memset(&wc, 0, sizeof(WNDCLASSEX));
	wc.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hInstance, TERM_CLASS, &wc) == FALSE)
		{
		wc.style		 = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
		wc.lpfnWndProc	 = TermProc;
		wc.cbClsExtra	 = 0;
		wc.cbWndExtra	 = sizeof(LONG_PTR);
		wc.hInstance	 = hInstance;
		wc.hIcon		 = NULL;
		wc.hCursor		 = LoadCursor(0, IDC_ARROW);
		wc.hbrBackground = NULL;
		wc.lpszMenuName  = NULL;
		wc.lpszClassName = TERM_CLASS;
		wc.hIconSm       = NULL;

		if (RegisterClassEx(&wc) == FALSE)
			{
			assert(FALSE);
			return FALSE;
			}
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateTerminalWindow
 *
 * DESCRIPTION:
 *	Creates a terminal window.
 *
 * ARGUMENTS:
 *	hwndSession - session window handle.
 *
 * RETURNS:
 *	hwnd or zero.
 *
 */
HWND CreateTerminalWindow(const HWND hwndSession)
	{
	HWND hwnd;

	hwnd = CreateWindowEx(
	  WS_EX_CLIENTEDGE,
	  TERM_CLASS,
	  "",
	  WS_CHILD | WS_HSCROLL | WS_VSCROLL | WS_CLIPSIBLINGS | WS_VISIBLE,
	  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
	  hwndSession,
	  (HMENU)IDC_TERMINAL_WIN,
	  glblQueryDllHinst(),
	  0
      );

	if (hwnd == 0)
		{
		assert(FALSE);
		return 0;
		}

	return hwnd;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateTerminalHdl
 *
 * DESCRIPTION:
 *	Creates an internal terminal handle.
 *
 * ARGUMENTS:
 *	hSession	- session handle
 *	hwndTerm	- terminal window handle.
 *
 * RETURNS:
 *	HHTERM or zero on error.
 *
 */
HHTERM CreateTerminalHdl(const HWND hwndTerm)
	{
	HHTERM hhTerm;

	hhTerm = (HHTERM)malloc(sizeof(*hhTerm));

	if (hhTerm == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hhTerm, 0, sizeof(*hhTerm));
	hhTerm->hwnd = hwndTerm;
	hhTerm->hwndSession = GetParent(hwndTerm);
	hhTerm->hSession = (HSESSION)GetWindowLongPtr(GetParent(hwndTerm), GWLP_USERDATA);

	/* --- ProcessMessage() aquires a session handle from here. --- */

	SetWindowLongPtr(hwndTerm, 0, (LONG_PTR)hhTerm->hSession);

	hhTerm->iRows = 24; 	// standard, loading an emulator could change it.
	hhTerm->iCols = 80; 	// standard, loading an emulator could change it.

	hhTerm->pacrEmuColors = crEmuColors;
	hhTerm->xBezel = BEZEL_SIZE;
	hhTerm->xIndent = 3;
	hhTerm->fCursorTracking = TRUE;
	hhTerm->fCursorsLinked = TRUE;
	hhTerm->fBlink = TRUE;

	if ( !IsTerminalServicesEnabled() )
		{
		//
		// Set the caret and text blink rate to the system's caret
		// blink rate setting.
		//
		hhTerm->uBlinkRate = GetCaretBlinkTime();
		}
	else
		{
		//
		// Set the text blink rate to once every 2 seconds.
		//
		hhTerm->uBlinkRate = 2000;
		}

	hhTerm->iCurType = EMU_CURSOR_LINE;
	hhTerm->hUpdate = updateCreate(hhTerm->hSession);

	memset(hhTerm->underscores, '_', MAX_EMUCOLS);
	hhTerm->underscores[MAX_EMUCOLS-1] = TEXT('\0');

	if (hhTerm->hUpdate == 0)
		return 0;

	// Allocate space for terminal text and attributes.

	if (AllocTxtBuf(&hhTerm->fplpstrTxt, MAX_EMUROWS, MAX_EMUCOLS) == FALSE)
		return 0;

	if (AllocAttrBuf(&hhTerm->fppstAttr, MAX_EMUROWS, MAX_EMUCOLS) == FALSE)
		return 0;

	if (termSysColorChng(hhTerm) == FALSE)
		return 0;

	if (termSetFont(hhTerm, 0) == FALSE)
		return 0;

	if (termAllocBkBuf(hhTerm) == FALSE)
		return 0;

	return hhTerm;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DestroyTerminalHdl
 *
 * DESCRIPTION:
 *	Gracefully cleans up the terminal handle.
 *
 * ARGUMENTS:
 *	hhTerm	- internal terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
void DestroyTerminalHdl(const HHTERM hhTerm)
	{
	if (hhTerm == 0)
		return;

	if (hhTerm->hUpdate)
		updateDestroy(hhTerm->hUpdate);

	//TODO: destroy terminal window.

	FreeTxtBuf(&hhTerm->fplpstrTxt, MAX_EMUROWS);
	FreeAttrBuf(&hhTerm->fppstAttr, MAX_EMUROWS);

	/* --- Delete fonts --- */

	if (hhTerm->hFont)
		DeleteObject(hhTerm->hFont);

	//if (hhTerm->hUFont)
	//	  DeleteObject(hhTerm->hUFont);

	if (hhTerm->hDblHiFont)
		DeleteObject(hhTerm->hDblHiFont);

	//if (hhTerm->hDblHiUFont)
	//	  DeleteObject(hhTerm->hDblHiUFont);

	if (hhTerm->hDblWiFont)
		DeleteObject(hhTerm->hDblWiFont);

	//if (hhTerm->hDblWiUFont)
	//	  DeleteObject(hhTerm->hDblWiUFont);

	if (hhTerm->hDblHiWiFont)
		DeleteObject(hhTerm->hDblHiWiFont);

	//if (hhTerm->hDblHiWiUFont)
	//	  DeleteObject(hhTerm->hDblHiWiUFont);

	/* --- Delete alternate symbol fonts --- */

	if (hhTerm->hSymFont)
		DeleteObject(hhTerm->hSymFont);

	//if (hhTerm->hSymUFont)
	//	  DeleteObject(hhTerm->hSymUFont);

	if (hhTerm->hSymDblHiFont)
		DeleteObject(hhTerm->hSymDblHiFont);

	//if (hhTerm->hSymDblHiUFont)
	//	  DeleteObject(hhTerm->hSymDblHiUFont);

	if (hhTerm->hSymDblWiFont)
		DeleteObject(hhTerm->hSymDblWiFont);

	//if (hhTerm->hSymDblWiUFont)
	//	  DeleteObject(hhTerm->hSymDblWiUFont);

	if (hhTerm->hSymDblHiWiFont)
		DeleteObject(hhTerm->hSymDblHiWiFont);

	//if (hhTerm->hSymDblHiWiUFont)
	//	  DeleteObject(hhTerm->hSymDblHiWiUFont);

	/* --- Other stuff --- */

	if (hhTerm->hbrushTerminal)
		DeleteObject(hhTerm->hbrushTerminal);

	if (hhTerm->hDkGrayPen)
		DeleteObject(hhTerm->hDkGrayPen);

	if (hhTerm->hLtGrayPen)
		DeleteObject(hhTerm->hLtGrayPen);

	if (hhTerm->hbrushTermHatch)
		DeleteObject(hhTerm->hbrushTermHatch);

	if (hhTerm->hbrushBackHatch)
		DeleteObject(hhTerm->hbrushBackHatch);

	if (hhTerm->hbrushDivider)
		DeleteObject(hhTerm->hbrushDivider);

	if (hhTerm->hbrushHighlight)
		DeleteObject(hhTerm->hbrushHighlight);

	if (hhTerm->hCursorTimer)
		TimerDestroy(&hhTerm->hCursorTimer);

	if (hhTerm->fplpstrBkTxt)
		termFreeBkBuf(hhTerm);

	free(hhTerm);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	AllocTxtBuf
 *
 * DESCRIPTION:
 *	Allocates text buffer for terminal image.
 *
 * ARGUMENTS:
 *	fpalpstr	- pointer to pointer to buffer array.
 *	sRows		- number of rows
 *	sCols		- number of cols in each row.
 *
 * RETURNS:
 *	BOOL
 *
 */
static BOOL AllocTxtBuf(ECHAR ***fpalpstr, int const sRows, int const sCols)
	{
	register int i;

	FreeTxtBuf(fpalpstr, sRows); // free any old stuff

	if ((*fpalpstr = (ECHAR **)malloc((unsigned int)sRows * sizeof(ECHAR *))) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	memset(*fpalpstr, 0, (unsigned int)sRows * sizeof(ECHAR *));

	for (i = 0 ; i < sRows ; ++i)
		{
		if (((*fpalpstr)[i] = (ECHAR *)malloc(sizeof(ECHAR) * (unsigned int)sCols)) == 0)
			{
			FreeTxtBuf(fpalpstr, sRows);
			assert(FALSE);
			return FALSE;
			}

		ECHAR_Fill((*fpalpstr)[i], EMU_BLANK_CHAR, (unsigned int)sCols);
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	AllocAttrBuf
 *
 * DESCRIPTION:
 *	Allocates attribute buffer for terminal image.
 *
 * ARGUMENTS:
 *	fpapst		- pointer to pointer to buffer array.
 *	sRows		- number of rows
 *	sCols		- number of cols in each row.
 *
 * RETURNS:
 *	BOOL
 *
 */
static BOOL AllocAttrBuf(PSTATTR **fpapst, const int sRows, const int sCols)
	{
	register int i, j;
	STATTR stAttr;

	memset(&stAttr, 0, sizeof(STATTR));
	stAttr.txtclr = (unsigned int)GetNearestColorIndex(GetSysColor(COLOR_WINDOWTEXT));
	stAttr.bkclr =	(unsigned int)GetNearestColorIndex(GetSysColor(COLOR_WINDOW));

	FreeAttrBuf(fpapst, sRows);  // free any old stuff

	if ((*fpapst = (PSTATTR *)malloc((unsigned int)sRows * sizeof(PSTATTR))) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	for (i = 0 ; i < sRows ; ++i)
		{
		if (((*fpapst)[i] = (PSTATTR)malloc(sizeof(STATTR) * (unsigned int)sCols)) == 0)
			{
			FreeAttrBuf(fpapst, sRows);  // free any old stuff
			assert(FALSE);
			return FALSE;
			}

		for (j = 0 ; j < sCols ; ++j)
			MemCopy((*fpapst)[i]+j, &stAttr, sizeof(STATTR));
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	FreeTxtBuf
 *
 * DESCRIPTION:
 *	Free-up any allocated buffers for terminal text image
 *
 * ARGUMENTS:
 *	fpalpstr	- pointer to pointer to buffer array.
 *	sRows		- number of rows
 *	sCols		- number of cols in each row.
 *
 * RETURNS:
 *	void
 *
 */
static void FreeTxtBuf(ECHAR ***fpalpstr, const int sRows)
	{
	register int i;
	ECHAR **alpstr = *fpalpstr;

	if (alpstr)
		{
		for (i = 0 ; *alpstr && i < sRows ; ++i)
			{
			free(*alpstr);
			*alpstr = NULL;
			alpstr += 1;
			}

		free(*fpalpstr);
		*fpalpstr = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	FreeAttrBuf
 *
 * DESCRIPTION:
 *	Free-up any allocated buffers for terminal attribute image
 *
 * ARGUMENTS:
 *	fpapst		- pointer to pointer to buffer array.
 *	sRows		- number of rows
 *	sCols		- number of cols in each row.
 *
 * RETURNS:
 *	void
 *
 */
static void FreeAttrBuf(PSTATTR **fpapst, const int sRows)
	{
	register int i;
	PSTATTR *apst = *fpapst;

	if (apst)
		{
		for (i = 0 ; *apst && i < sRows ; ++i)
			{
			free(*apst);
			*apst = NULL;
			apst += 1;
			}

		free(*fpapst);
		*fpapst = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termSysColorChng
 *
 * DESCRIPTION:
 *	Creates new brushes because system colors have changed.  Also used
 *	during initialization of terminal window.
 *
 * ARGUMENTS:
 *	hhTerm	- internal terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
BOOL termSysColorChng(const HHTERM hhTerm)
	{
	#define HATCH_PATTERN HS_BDIAGONAL

	HBRUSH hBrush;
	HPEN hPen;
	COLORREF cr;

	hhTerm->crBackScrl = GetSysColor(COLOR_BTNFACE);
	hhTerm->crBackScrlTxt = GetSysColor(COLOR_BTNTEXT);

	hhTerm->hBlackPen = GetStockObject(BLACK_PEN);
	hhTerm->hWhitePen = GetStockObject(WHITE_PEN);

	/* ----------------------- */

	cr = GetSysColor(COLOR_WINDOW);

	if ((hBrush = CreateSolidBrush(cr)) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	hhTerm->crTerm = cr;

	if (hhTerm->hbrushTerminal)
		DeleteObject(hhTerm->hbrushTerminal);

	hhTerm->hbrushTerminal = hBrush;

	/* ----------------------- */

	cr = GetSysColor(COLOR_BTNFACE);

	if ((hBrush = CreateSolidBrush(cr)) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	hhTerm->crBackScrl = cr;

	if (hhTerm->hbrushBackScrl)
		DeleteObject(hhTerm->hbrushBackScrl);

	hhTerm->hbrushBackScrl = hBrush;

	/* ----------------------- */

	cr = GetSysColor(COLOR_BTNSHADOW);

	if ((hBrush = CreateSolidBrush(cr)) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhTerm->hbrushDivider)
		DeleteObject(hhTerm->hbrushDivider);

	hhTerm->hbrushDivider = hBrush;

	/* ----------------------- */

	cr = GetSysColor(COLOR_HIGHLIGHT);

	if ((hBrush = CreateSolidBrush(cr)) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhTerm->hbrushHighlight)
		DeleteObject(hhTerm->hbrushHighlight);

	hhTerm->hbrushHighlight = hBrush;

	/* ----------------------- */

	cr = GetSysColor(COLOR_BTNFACE);

	if ((hPen = CreatePen(PS_SOLID, 0, cr)) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhTerm->hLtGrayPen)
		DeleteObject(hhTerm->hLtGrayPen);

	hhTerm->hLtGrayPen = hPen;

	/* ----------------------- */

	hBrush = CreateHatchBrush(HATCH_PATTERN, GetSysColor(COLOR_BTNFACE));

	if (hBrush == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhTerm->hbrushTermHatch)
		DeleteObject(hhTerm->hbrushTermHatch);

	hhTerm->hbrushTermHatch = hBrush;

	/* ----------------------- */

	hBrush = CreateHatchBrush(HATCH_PATTERN, GetSysColor(COLOR_BTNSHADOW));

	if (hBrush == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhTerm->hbrushBackHatch)
		DeleteObject(hhTerm->hbrushBackHatch);

	hhTerm->hbrushBackHatch = hBrush;

	/* ----------------------- */

	cr = GetSysColor(COLOR_BTNSHADOW);

	if ((hPen = CreatePen(PS_SOLID, 0, cr)) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (hhTerm->hDkGrayPen)
		DeleteObject(hhTerm->hDkGrayPen);

	hhTerm->hDkGrayPen = hPen;

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termSetFont
 *
 * DESCRIPTION:
 *	Sets the terminal font to the given font.  If hFont is zero,
 *	termSetFont() trys to create a default font.
 *
 * ARGUMENTS:
 *	hhTerm	- internal term handle.
 *	plf 	- pointer to logfont
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL termSetFont(const HHTERM hhTerm, const PLOGFONT plf)
	{
	HDC 	hdc;
	LOGFONT lf;
	HFONT	hFont;
	char	ach[256];
	TEXTMETRIC tm;
	int		nSize1, nSize2;
	int		nCharSet;

	if (plf == 0)
		{
		// No font, use the default font for HyperTerminal
        // (usually New Courier)

		memset(&lf, 0, sizeof(LOGFONT));

        // Using different font sizes based upon screen resolution
		// using the resource file.

		// For VGA screens, we need a smaller font.
		//
        if (LoadString(glblQueryDllHinst(), IDS_TERM_DEF_VGA_SIZE,
                ach, sizeof(ach) / sizeof(TCHAR)))
            {
            nSize1 = atoi(ach);
            }
		else
            {
			nSize1 = -11;
            }

        if (LoadString(glblQueryDllHinst(), IDS_TERM_DEF_NONVGA_SIZE,
                ach, sizeof(ach) / sizeof(TCHAR)))
            {
            nSize2 = atoi(ach);
            }

		else
            {
			nSize2 = -15;
            }

		lf.lfHeight = (GetSystemMetrics(SM_CXSCREEN) < 810) ? nSize1 : nSize2;

        // mrw:3/5/96 - Font comes out really dinky on high res screens.
        //
        #if defined(INCL_USE_TERMINAL_FONT)
        if (GetSystemMetrics(SM_CXSCREEN) >= 1024)
            lf.lfHeight = -19;
        #endif

		lf.lfPitchAndFamily = FIXED_PITCH | MONO_FONT;

        if (LoadString(glblQueryDllHinst(), IDS_TERM_DEF_FONT,
                ach, sizeof(ach) / sizeof(TCHAR)))
            {
            strncpy(lf.lfFaceName, ach, sizeof(lf.lfFaceName));
            lf.lfFaceName[sizeof(lf.lfFaceName)/sizeof(TCHAR)-1] = TEXT('\0');
            }

        if (LoadString(glblQueryDllHinst(), IDS_TERM_DEF_CHARSET,
                ach, sizeof(ach) / sizeof(TCHAR)))
            {
            nCharSet = atoi(ach);
			lf.lfCharSet = (BYTE)nCharSet;
            }
		}

	else
		{
        memcpy(&lf, plf, sizeof(lf));
		}

    /* --- Attempt to get the font from the system. -- */

	hFont = CreateFontIndirect(&lf);

    //
    // Moved GetObject() here from below in case there is a problem
    // with the font. REV: 05/11/2001
    //

    if (hFont == 0 || GetObject(hFont, sizeof(LOGFONT), &lf) == 0)
		{
		//*lf.lfCharSet = ANSI_CHARSET;

		//*hFont = CreateFontIndirect(&lf);

		//*if (hFont == 0 || GetObject(hFont, sizeof(LOGFONT), &lf) == 0)
			{
			assert(FALSE);
            //
            // An error occurred when attempting to create/load this
            // font.  Post a message to display the Font selection
            // common control dialog to select a font. REV: 05/11/2001
            //
            PostMessage(hhTerm->hwndSession, WM_COMMAND, IDM_VIEW_FONTS, (LPARAM)0);
			return FALSE;
			}
		}

    /* --- Ok, we have our base font, blast the previous fonts --- */

	if (hhTerm->hFont)
		{
		DeleteObject(hhTerm->hFont);
		hhTerm->hFont = 0;
		}


	if (hhTerm->hDblHiFont)
		{
		DeleteObject(hhTerm->hDblHiFont);
		hhTerm->hDblHiFont = 0;
		}

	if (hhTerm->hDblWiFont)
		{
		DeleteObject(hhTerm->hDblWiFont);
		hhTerm->hDblWiFont = 0;
		}

	if (hhTerm->hDblHiWiFont)
		{
		DeleteObject(hhTerm->hDblHiWiFont);
		hhTerm->hDblHiWiFont = 0;
		}

	/* --- And the symbol fonts --- */

	if (hhTerm->hSymFont)
		{
		DeleteObject(hhTerm->hSymFont);
		hhTerm->hSymFont = 0;
		}

	if (hhTerm->hSymDblHiFont)
		{
		DeleteObject(hhTerm->hSymDblHiFont);
		hhTerm->hSymDblHiFont = 0;
		}

	if (hhTerm->hSymDblWiFont)
		{
		DeleteObject(hhTerm->hSymDblWiFont);
		hhTerm->hSymDblWiFont = 0;
		}

	if (hhTerm->hSymDblHiWiFont)
		{
		DeleteObject(hhTerm->hSymDblHiWiFont);
		hhTerm->hSymDblHiWiFont = 0;
		}

	/* --- Commit to the new font --- */

	hhTerm->hFont = hFont;

    #if 0
    //
    // Moved GetObject() from here from above in case there is a problem
    // with creating the font. REV: 05/11/2001
    //
    if (GetObject(hFont, sizeof(LOGFONT), &lf) == 0)
		{
		assert(FALSE);
		return FALSE;
		}
    #endif // 0

	/* --- save what we really got --- */

	hhTerm->lf = lf;

	/* --- Get size of selected font. --- */

	hdc = GetDC(hhTerm->hwnd);
	hFont = (HFONT)SelectObject(hdc, hFont);

	GetTextMetrics(hdc, &tm);
	SelectObject(hdc, hFont);

	ReleaseDC(hhTerm->hwnd, hdc);

	hhTerm->xChar = tm.tmAveCharWidth;
	hhTerm->yChar = tm.tmHeight;

    #if defined(FAR_EAST)
	if ((tm.tmMaxCharWidth % 2) == 0)
		{
		hhTerm->iEvenFont = TRUE;
		}
	else
		{
		hhTerm->iEvenFont = FALSE;
		}

    #else
    hhTerm->iEvenFont = TRUE;   //mrw:10/10/95
    #endif

	// We need to know if the font is italic because it changes the
	// way we draw.  The italic fonts are regular fonts sheared.  The
	// shear causes the character to draw into the next text box.
	// This really messes us up.  To get around the problem, when
	// we're italic, we simply repaint the whole line when an text
	// comes in. - mrw,12/19/94
	//
	hhTerm->fItalic = tm.tmItalic;

	/* --- Set bezel size based on font --- */

	hhTerm->xBezel = BEZEL_SIZE;

	if (hhTerm->yChar < BEZEL_SIZE)
		{
		hhTerm->xBezel = max(5+OUTDENT, hhTerm->yChar);
		}

	switch (hhTerm->iCurType)
		{
	case EMU_CURSOR_LINE:
	default:
		hhTerm->iHstCurSiz = GetSystemMetrics(SM_CYBORDER) * 2;
		break;

	case EMU_CURSOR_BLOCK:
		hhTerm->iHstCurSiz = hhTerm->yChar;
		break;

	case EMU_CURSOR_NONE:
		hhTerm->iHstCurSiz = 0;
		break;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termMakeFont
 *
 * DESCRIPTION:
 *	When user selects a font, we only create the standard non-underlined
 *	font.  If the paint routines encounter an attribute that needs a
 *	a different font, then we create it on the spot.  This is more
 *	economic since often we won't need all 8 fonts for a given session.
 *
 * ARGUMENTS:
 *	hhTerm		- internal terminal handle
 *	fUnderline	- font is underlined
 *	fHigh		- font is double high
 *	fWide		- font is double wide
 *
 * RETURNS:
 *	0 on error, hFont on success.
 *
 */
HFONT termMakeFont(const HHTERM hhTerm, const BOOL fUnderline,
				   const BOOL fHigh, const BOOL fWide, const BOOL fSymbol)
	{
	LOGFONT lf;
	HFONT	hFont;

	lf = hhTerm->lf;
	lf.lfWidth = hhTerm->xChar;

	if (fSymbol)
		{
		//lf.lfCharSet = SYMBOL_CHARSET;
		StrCharCopyN(lf.lfFaceName, "Arial Alternative Symbol", sizeof(lf.lfFaceName));
		}

	if (fUnderline)
		lf.lfUnderline = 1;

	if (fHigh)
		lf.lfHeight *= 2;

	if (fWide)
		lf.lfWidth *= 2;

	if ((hFont = CreateFontIndirect(&lf)) == 0)
		assert(FALSE);

	return hFont;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fAllocBkBuf
 *
 * DESCRIPTION:
 *	Allocates buffer space for backscroll text
 *
 * ARGUMENTS:
 *	hhTerm	- internal terminal handle
 *
 * RETURNS:
 *	BOOL
 *
 */
static BOOL termAllocBkBuf(const HHTERM hhTerm)
	{
	register int i;

	// This number should be big enough so that a maximized window of
	// backscroll text can be displayed.

	hhTerm->iMaxPhysicalBkRows = hhTerm->iPhysicalBkRows = min(5000,
		(GetSystemMetrics(SM_CYFULLSCREEN) / hhTerm->yChar) + 1);

	if ((hhTerm->fplpstrBkTxt = malloc((unsigned int)hhTerm->iMaxPhysicalBkRows *
			sizeof(ECHAR *))) == 0)
		{
		return FALSE;
		}

	for (i = 0 ; i < hhTerm->iMaxPhysicalBkRows ; ++i)
		{
		if ((hhTerm->fplpstrBkTxt[i] =
				malloc(MAX_EMUCOLS * sizeof(ECHAR))) == 0)
			{
			termFreeBkBuf(hhTerm);
			return FALSE;
			}

		ECHAR_Fill(hhTerm->fplpstrBkTxt[i], EMU_BLANK_CHAR, MAX_EMUCOLS);
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	FreeBkBuf
 *
 * DESCRIPTION:
 *	Frees space allocated to backscroll buffer.
 *
 * ARGUMENTS:
 *	hhTerm	- internal terminal handle
 *
 * RETURNS:
 *	void
 *
 */
static void termFreeBkBuf(const HHTERM hhTerm)
	{
	register int i;

	for (i = 0 ; i < hhTerm->iMaxPhysicalBkRows ; ++i)
		{
		if (hhTerm->fplpstrBkTxt[i])
			{
			free(hhTerm->fplpstrBkTxt[i]);
			hhTerm->fplpstrBkTxt[i] = NULL;
			}
		}

	free(hhTerm->fplpstrBkTxt);
	hhTerm->fplpstrBkTxt = NULL;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	GetNearestColorIndex
 *
 * DESCRIPTION:
 *	Duplicates a palette function that I couldn't get to work.  Basicly,
 *	the emulator has a table of colors it is allowed to use.  When the
 *	user picks a color, this function returns the index of the color that
 *	most closely matches.  How does it do this you say?  Well, imagine
 *	the problem as 3D space.  The pallete colors all map into this space.
 *	The goal is to find the pallete color closest to the given colorref
 *	value.	Borrowing from the 10th grade algrebra we know that:
 *
 *		X^2 + Y^2 + Z^2 = C^2
 *
 *	The distance between two points is then:
 *
 *		(X - X')^2 + (Y - Y')^2 + (Z - Z') = C'^2
 *
 *	The point with the smallest C'^2 value wins!
 *
 * ARGUMENTS:
 *	COLORREF *acr	- color table to use for matching
 *	COLORREF cr 	- color to match.
 *
 * RETURNS:
 *	An index of the closest matching color.
 *
 */
int GetNearestColorIndex(COLORREF cr)
	{
	int   i, idx = 0;
	unsigned int  R, G, B;
	unsigned long C, CMin = (unsigned long)-1;

	for (i = 0 ; i < DIM(crEmuColors) ; ++i)
		{
		R = GetRValue(crEmuColors[i]) - GetRValue(cr);	R *= R;
		G = GetGValue(crEmuColors[i]) - GetGValue(cr);	G *= G;
		B = GetBValue(crEmuColors[i]) - GetBValue(cr);	B *= B;

		C = (ULONG)(R + G + B);

		if (C < CMin)
			{
			CMin = C;
			idx = i;

			if (C == 0) 	// we matched!
				break;
			}
		}

	return idx;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	UnregisterTerminalClass
 *
 * DESCRIPTION:
 *	unregisters the terminal class.  Called in InitApplication()
 *
 * ARGUMENTS:
 *	hInstance	- Instance handle of app.
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL UnregisterTerminalClass(const HINSTANCE hInstance)
	{
	return UnregisterClass(TERM_CLASS, hInstance);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termmos.c ===
/*	File: D:\WACKER\tdll\termmos.c (Created: 26-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 5/29/02 2:17p $
 */
//#define DEBUGSTR 1

#include <windows.h>
#pragma hdrstop

#include <stdlib.h>

#include "stdtyp.h"
#include "assert.h"
#include "session.h"
#include "timers.h"
#include "cloop.h"
#include "htchar.h"
#include <emu\emu.h>
#include "term.h"
#include "term.hh"

static int InMiddleofWideChar(ECHAR *pszRow, int iCol);


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_LBTNDN
 *
 * DESCRIPTION:
 *	Message handler for left mouse button down.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *	iFlags	- mouse flags from message
 *	xPos	- x position from message
 *	yPos	- y position from message
 *
 * RETURNS:
 *	void
 *
 */
void TP_WM_LBTNDN(const HWND hwnd, const unsigned uFlags,
				  const int xPos, const int yPos)
	{
	MSG msg;
	POINT ptTemp;
	unsigned i, t;
#ifndef CHAR_NARROW
	int iRow;
#endif
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	// Need to wait here for the length of a double-click to see
	// if we are going to receive a double-click.

	i = GetDoubleClickTime();

	for (i += t = GetTickCount() ;	t < i ; t = GetTickCount())
		{
		// In a double-click sequence, we get a WM_LBUTTONUP message.
		// We need to avoid checking for WM_LBUTTONUP.	I tried to
		// do this by removing messages from the queue but things
		// got very sticky.

		if (PeekMessage(&msg, hwnd, WM_MOUSEFIRST, WM_MOUSELAST,
				PM_NOYIELD | PM_NOREMOVE))
			{
			if (msg.message == WM_LBUTTONDBLCLK)
				return;

			if (msg.message == WM_LBUTTONUP)
				continue;

			break;
			}
		}

	if (GetKeyState(VK_SHIFT) >= 0 || !hhTerm->fMarkingLock)
		{
		MarkText(hhTerm, &hhTerm->ptBeg, &hhTerm->ptEnd, FALSE, MARK_ABS);

		// Get new text caret position/marking region.

		hhTerm->ptBeg.x = hhTerm->ptEnd.x =
			min((xPos - hhTerm->xIndent - hhTerm->xBezel + (hhTerm->xChar/2))
					/ hhTerm->xChar + hhTerm->iHScrlPos,
				hhTerm->iHScrlPos + (hhTerm->iCols - hhTerm->iHScrlMax));

		hhTerm->ptBeg.y = hhTerm->ptEnd.y =
			min(yPos / hhTerm->yChar + hhTerm->iVScrlPos,
				hhTerm->iVScrlPos + hhTerm->iTermHite - 1);

	 	//mpt:1-23-98 attempt to re-enable DBCS code
#ifndef CHAR_NARROW
		termValidatePosition(hhTerm, VP_ADJUST_LEFT, &hhTerm->ptBeg);
		termValidatePosition(hhTerm, VP_ADJUST_LEFT, &hhTerm->ptEnd);
#endif
	}

	else
		{
		// Shift key in conjunction with LBUTTONDOWN allows user
		// to adjust selection area.

		ptTemp = hhTerm->ptEnd;

		hhTerm->ptEnd.y =
			min(yPos / hhTerm->yChar + hhTerm->iVScrlPos,
				hhTerm->iVScrlPos + hhTerm->iTermHite - 1);

		//(hhTerm, VP_ADJUST_LEFT, &hhTerm->ptEnd);

		MarkText(hhTerm, &ptTemp, &hhTerm->ptEnd, TRUE, MARK_XOR);
		}

	TestForMarkingLock(hhTerm);

	if (hhTerm->hMarkingTimer == 0)
		{
		TimerCreate(hhTerm->hSession,
			        &hhTerm->hMarkingTimer,
					100,
					MarkingTimerProc,
					(void *)hwnd);
		}

#ifndef CHAR_NARROW
	if (hhTerm->ptBeg.y > 0)
		{

		iRow = ((hhTerm->ptBeg.y - 1) + hhTerm->iTopline) % MAX_EMUROWS;
		if (hhTerm->fppstAttr[iRow][hhTerm->ptBeg.x].wirt == TRUE)
			{
			hhTerm->ptBeg.x--;
			hhTerm->ptEnd.x--;
			}
		}
    else
        {
		iRow = yPos / hhTerm->yChar;

		// If the backscroll buffer is not filling the entire display,
		// then we need to adjust the offset by the amount not showing.

		if (abs(hhTerm->iVScrlPos) < hhTerm->iPhysicalBkRows)
			iRow += hhTerm->iPhysicalBkRows + hhTerm->iVScrlPos;

		// Calculate the offset into the local backscroll display.

		if (hhTerm->iPhysicalBkRows > 0)
			{
			iRow = (hhTerm->iNextBkLn + hhTerm->iPhysicalBkRows + iRow) %
					hhTerm->iPhysicalBkRows;
			}
		else
			{
			iRow = 0;
			}

        if (InMiddleofWideChar(hhTerm->fplpstrBkTxt[iRow], hhTerm->ptBeg.x))
			{
			hhTerm->ptBeg.x--;
			hhTerm->ptEnd.x--;
			}
        }
#endif

	SetLclCurPos(hhTerm, &hhTerm->ptBeg);
	SetCapture(hwnd);
	sessSetSuspend(hhTerm->hSession, SUSPEND_TERMINAL_LBTNDN);
	hhTerm->fCapture = TRUE;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_MOUSEMOVE
 *
 * DESCRIPTION:
 *	Message handler for mouse move
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *	iFlags	- mouse flags from message
 *	xPos	- x position from message
 *	yPos	- y position from message
 *
 * RETURNS:
 *	void
 *
 */
void TP_WM_MOUSEMOVE(const HWND hwnd, const unsigned uFlags,
					 const int xPos, const int yPos)
	{
	int i, l; //iRow; mrw,3/1/95
#ifndef CHAR_NARROW
	int iRow;
#endif
	POINT ptTemp, ptBeg, ptEnd;
	ECHAR *pachTxt;
	long lBeg, lEnd, lOld;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (hhTerm->fCapture == FALSE)
		return;

	ptTemp = hhTerm->ptEnd;

	// Rather a subtle move here.  If we are selecting by word, we
	// want to hightlight the word as soon as we touch the character.
	// In normal highlighting, we trigger at the half way point
	// on the character.  This removes a bug where you could double
	// click on the first char of a word and not select the word.

	i = (hhTerm->fSelectByWord) ? hhTerm->xChar-1 : hhTerm->xChar/2;

	ptEnd.x =
		max(min(((xPos - hhTerm->xIndent - hhTerm->xBezel + i) /
				hhTerm->xChar) + hhTerm->iHScrlPos,
			hhTerm->iHScrlPos + (hhTerm->iCols - hhTerm->iHScrlPos)),
				hhTerm->iHScrlPos);

	ptEnd.y = (yPos / hhTerm->yChar) + hhTerm->iVScrlPos;

	// Boundary conditions need special treatment.

	if (ptEnd.y > hhTerm->iRows) // bottom of terminal
		{
		ptEnd.y = hhTerm->iRows;
		ptEnd.x = hhTerm->iCols;
		}

	else if (ptEnd.y < hhTerm->iVScrlMin) // top of backscroll
		{
		ptEnd.y = hhTerm->iVScrlPos;
		ptEnd.x = 0;
		}

	#if 0
	{
	char ach[20];
	wsprintf(ach, "x=%d, y=%d, yPos=%d", ptEnd.x, ptEnd.y, yPos);
	SetWindowText(sessQueryHwndStatusbar(hhTerm->hSession), ach);
	}
	#endif

	// Selection by word requires more work.

	if (hhTerm->fSelectByWord)
		{
		if (ptEnd.y > 0)
			{
			i =  (ptEnd.y + hhTerm->iTopline - 1) % MAX_EMUROWS;
			pachTxt = hhTerm->fplpstrTxt[i];
			}

		else if (ptEnd.y < 0)
			{
			i = yPos / hhTerm->yChar;

			// If the backscroll buffer is not filling the entire display,
			// then we need to adjust the offset by the amount not showing.

			if (abs(hhTerm->iVScrlPos) < hhTerm->iPhysicalBkRows)
				i += hhTerm->iPhysicalBkRows + hhTerm->iVScrlPos;

			// Calculate the offset into the local backscroll display.

			if (hhTerm->iPhysicalBkRows)
				{
				i = (hhTerm->iNextBkLn + hhTerm->iPhysicalBkRows + i) %
					hhTerm->iPhysicalBkRows;
				}
			else
				{
				i = 0;
				}

			pachTxt = hhTerm->fplpstrBkTxt[i];
			}

		else
			{
			return;
			}

		ptBeg = hhTerm->ptBeg;
		lBeg = (ptBeg.y * hhTerm->iCols) + ptBeg.x;
		lEnd = (ptEnd.y * hhTerm->iCols) + ptEnd.x;
		lOld = (ptTemp.y * hhTerm->iCols) + ptTemp.x;

		// When selecting by word, we want to keep the word we first
		// highlighted, highlighted if we change directions.  We do
		// this by swapping the beginning and end points.  Actually,
		// this can get fooled if the user moves across the the
		// transition point but not across the word but the extra
		// logic to get this case seemed more work than its worth.

		if (lEnd <= lBeg && lOld > lBeg)
			hhTerm->ptBeg = ptTemp;

		else if (lEnd >= lBeg && lOld < lBeg)
			hhTerm->ptBeg = ptTemp;

		// How we select things depends on the direction unfortunatly.

		if (lEnd > lBeg)
			{
			if ((l = strlentrunc(pachTxt, hhTerm->iCols)) < ptEnd.x)
				{
				i = l;
				}

			else if (xPos < 0)
				{
				// Special hack when cursor is off to the
				// left of the window.

				i = 0;
				}

			else if (i = max(ptEnd.x-1, 0), pachTxt[i] == ETEXT(' '))
				{
				for (i = ptEnd.x-1 ; i > -1 ; --i)
					{
					/* This may not work correctly for DBCS characters */
					if (i == -1 || pachTxt[i] != ETEXT(' '))
						{
						i += 1;
						break;
						}
					}
				}

			else
				{
				for (i = max(ptEnd.x-1, 0) ; i < l ; ++i)
					{
					/* This may not work correctly for DBCS characters */
					if (pachTxt[i] == ETEXT(' '))
						break;
					}
				}
			}

		else // Select backwords case
			{
			if ((l = strlentrunc(pachTxt, hhTerm->iCols)) < ptEnd.x)
				{
				i = hhTerm->iCols;
				}

			else if (i = max(ptEnd.x-1, 0), pachTxt[i] == ETEXT(' '))
				{
				for (i = max(ptEnd.x-1, 0) ; i < l ; ++i)
					{
					if (pachTxt[i] != ETEXT(' '))
						break;
					}
				}

			else
				{
				for (i = ptEnd.x-1 ; i > -1 ; --i)
					{
					/* This may not work correctly for DBCS characters */
					if (pachTxt[i] == ETEXT(' '))
						{
						i += 1;
						break;
						}
					}
				}
			}

		ptEnd.x = max(i, 0);
		}

	lBeg = (ptBeg.y * hhTerm->iCols) + ptBeg.x;
	lEnd = (ptEnd.y * hhTerm->iCols) + ptEnd.x;

#ifndef CHAR_NARROW
	// How we select things depends on the direction unfortunatly.
	if (ptEnd.y > 0)
		{
		iRow = ((ptEnd.y - 1) + hhTerm->iTopline) % MAX_EMUROWS;

		if (hhTerm->fppstAttr[iRow][ptEnd.x].wirt == TRUE)
			if (lEnd > lBeg)
				{
				ptEnd.x++;
				}
			else
				{
				ptEnd.x--;
				}
		}
    else
        {
		iRow = yPos / hhTerm->yChar;

		// If the backscroll buffer is not filling the entire display,
		// then we need to adjust the offset by the amount not showing.

		if (abs(hhTerm->iVScrlPos) < hhTerm->iPhysicalBkRows)
			iRow += hhTerm->iPhysicalBkRows + hhTerm->iVScrlPos;

		// Calculate the offset into the local backscroll display.

		if (hhTerm->iPhysicalBkRows > 0)
			{
			iRow = (hhTerm->iNextBkLn + hhTerm->iPhysicalBkRows + iRow) %
				hhTerm->iPhysicalBkRows;
			}
		else
			{
			iRow = 0;
			}

        if (InMiddleofWideChar(hhTerm->fplpstrBkTxt[iRow], ptEnd.x))
            {
			if (lEnd > lBeg)
				{
				ptEnd.x++;
				}
			else
				{
				ptEnd.x--;
				}
            }
		}
#endif

	if (ptTemp.x == ptEnd.x && ptTemp.y == ptEnd.y)
		return;

	//(hhTerm, VP_ADJUST_LEFT, &ptEnd);
	hhTerm->ptEnd = ptEnd;
	SetLclCurPos(hhTerm, &ptEnd);
	MarkText(hhTerm, &ptTemp, &ptEnd, TRUE, MARK_XOR);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_LBTNUP
 *
 * DESCRIPTION:
 *	Message handler for left mouse button up.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *	iFlags	- mouse flags from message
 *	xPos	- x position from message
 *	yPos	- y position from message
 *
 * RETURNS:
 *	void
 *
 */
void TP_WM_LBTNUP(const HWND hwnd, const unsigned uFlags,
				  const int xPos, const int yPos)
	{
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (hhTerm->fCapture == FALSE)
		return;

	// Let mousemove logic set the final end point.

	SendMessage(hwnd, WM_MOUSEMOVE, uFlags, MAKELONG(xPos, yPos));

	// Kill the marking timer!

	if (hhTerm->hMarkingTimer != (HTIMER)0)
		{
		TimerDestroy(&hhTerm->hMarkingTimer);
		}

	// Turnoff flags associated with text-marking and give back the mouse.

	ReleaseCapture();
	hhTerm->fCapture = FALSE;
	hhTerm->fSelectByWord = FALSE;
	sessClearSuspend(hhTerm->hSession, SUSPEND_TERMINAL_LBTNDN);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_LBTNDBLCLK
 *
 * DESCRIPTION:
 *	Message handler for left mouse button double click.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *	iFlags	- mouse flags from message
 *	xPos	- x position from message
 *	yPos	- y position from message
 *
 * RETURNS:
 *	void
 *
 */
void TP_WM_LBTNDBLCLK(const HWND hwnd, const unsigned uFlags,
					  const int xPos, const int yPos)
	{
	int i, j, k, l, m;
	ECHAR *pachTxt;
	POINT ptTemp, ptBeg, ptEnd;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	i = (yPos / hhTerm->yChar) + hhTerm->iVScrlPos;
	j = ((xPos - hhTerm->xIndent - hhTerm->xBezel) / hhTerm->xChar) + hhTerm->iHScrlPos;

	ptTemp.x = j;
	ptTemp.y = i;

	ptBeg = hhTerm->ptBeg;
	ptEnd = hhTerm->ptEnd;

	// If we double-clicked over selected text and we have the correct
	// options set, then send it to the host.

	if (hhTerm->iBtnOne == B1_COPYWORD || hhTerm->iBtnOne == B1_COPYWORDENTER)
		{
		if (PointInSelectionRange(&ptTemp, &ptBeg, &ptEnd, hhTerm->iCols))
			{
			//*CopyTextToHost(hSession,
			//*    CopyTextFromTerminal(hSession, &ptBeg, &ptEnd, FALSE));

			if (hhTerm->iBtnOne == B1_COPYWORDENTER)
				CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), TEXT("\r"), 1, 0);

			return;
			}
		}

	// Nope, just figure out what to highlight.

	if (i > 0)
		{
		m =  (i + hhTerm->iTopline - 1) % MAX_EMUROWS;
		pachTxt = hhTerm->fplpstrTxt[m];
		}

	else if (i < 0)
		{
		m = yPos / hhTerm->yChar;

		// If the backscroll buffer is not filling the entire display,
		// then we need to adjust the offset by the amount not showing.

		if (abs(hhTerm->iVScrlPos) < hhTerm->iPhysicalBkRows)
			m += hhTerm->iPhysicalBkRows + hhTerm->iVScrlPos;

		// Calculate the offset into the local backscroll display.

		if (hhTerm->iPhysicalBkRows > 0)
			{
			m = (hhTerm->iNextBkLn + hhTerm->iPhysicalBkRows + m) %
				hhTerm->iPhysicalBkRows;
			}
		else
			{
			m = 0;
			}

		pachTxt = hhTerm->fplpstrBkTxt[m];
		}

	else
		{
		return;
		}

	// Determine where the the word starts and ends.  If the user
	// clicks on white space, do the else case below.

	if ((m = strlentrunc(pachTxt, hhTerm->iCols)) > j)
		{
		if (pachTxt[j] != ETEXT(' '))
			{
			for (k = j ; k > 0 ; --k)
				{
				/* This may not work correctly for DBCS characters */
				if (pachTxt[k] == ETEXT(' '))
					{
					k += 1;
					break;
					}
				}

			for (l = j ; l < m ; ++l)
				{
				/* This may not work correctly for DBCS characters */
				if (pachTxt[l] == ETEXT(' '))
					break;
				}

			MarkText(hhTerm, &ptBeg, &ptEnd, FALSE, MARK_ABS);

			ptBeg.x = k;
			ptBeg.y = i;
			ptEnd.x = l;
			ptEnd.y = i;

			hhTerm->ptBeg = ptBeg;
			hhTerm->ptEnd = ptEnd;

			MarkText(hhTerm, &ptBeg, &ptEnd, TRUE, MARK_ABS);

			// If we have any kind of a sending operation selected,
			// then override marking

			if (hhTerm->iBtnOne == B1_COPYWORD || hhTerm->iBtnOne == B1_COPYWORDENTER)
				{
				if (PointInSelectionRange(&ptTemp, &ptBeg, &ptEnd, hhTerm->iCols))
					{
					//* CopyTextToHost(hSession,
					//* 	CopyTextFromTerminal(hSession, &ptBeg, &ptEnd,
					//* 		FALSE));

					if (hhTerm->iBtnOne == B1_COPYWORDENTER)
						CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), TEXT("\r"), 1, 0);

					return;
					}
				}

			SetLclCurPos(hhTerm, &ptEnd);

			if (hhTerm->hMarkingTimer == 0)
				{
				TimerCreate(hhTerm->hSession,
					        &hhTerm->hMarkingTimer,
							100,
							MarkingTimerProc,
							(void *)hwnd);
				}

			hhTerm->fSelectByWord = TRUE;
			SetCapture(hwnd);
			hhTerm->fCapture = TRUE;
			}
		}

	else /* --- white-space case. --- */
		{
		if (hhTerm->iBtnOne == B1_COPYWORDENTER)
			CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), TEXT("\r"), 1, 0);
		}

	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	InMiddleofWideChar
 *
 * DESCRIPTION:
 *	Determines if we are in the middle of a wide character in the row.  We can do this because:
 *              1: The image is in ECHARS, which means that we can deal with individual col. positions.
 *              2: The characters are doubled in the image, being displayed as left/right pairs, we are
 *                      just trying to find out if we are in the middle of one of these pairs
 *
 * ARGUMENTS:
 *      ECHAR *pszString - emulator/backscroll row image
 *
 * RETURNS:
 *      TRUE: we are in the middle of a character
 *      FALSE: no we are not
 *
 * AUTHOR: JFH:1/28/94 - yes this was a saturday, oh well it's cold out right now anyways.
 */
static int InMiddleofWideChar(ECHAR *pszRow, int iCol)
    {
    ECHAR *pszChar;
    int nRet = FALSE;
    int nPos;
    BOOL fDBCSFlag = FALSE;

    if (pszRow == NULL)
		{
        assert(FALSE);
        return nRet;
        }

    // If we are in col. 0, we can not be in the middle of a character
    if (iCol == 0)
        {
        return FALSE;
        }

    pszChar = pszRow;

    for (nPos = 0; nPos <= iCol ; nPos++)
        {
        if (isDBCSChar(*pszChar))
	        {
            if (fDBCSFlag)
				{
				if ((nPos == iCol) && (*(pszChar - 1) == *pszChar))
					{
                    nRet = TRUE;
                    }
				fDBCSFlag = FALSE;
				}
				else
					{
					fDBCSFlag = TRUE;
					}
            }
        else
			{
			fDBCSFlag = FALSE;
    		}

		pszChar++;
		}

	return nRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termpnt.c ===
/*	File: D:\WACKER\tdll\termpnt.c (Created: 11-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/09/01 4:38p $
 */
// #define	DEBUGSTR	1

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "assert.h"
#include "timers.h"
#include "htchar.h"
#include <emu\emu.h>
#include "mc.h"
#include "term.hh"

static
void TextAttrOut(const HHTERM	  hhTerm,
				 const HDC		  hDC,
				 const int		  x,
				 const int		  y,
				 const ECHAR	  *lpachText,
				 const PSTATTR	  apstAttrs,
				 const int        fForceRight,
				 const int		  nCount,
				 const int		  iRow,
				 const int		  iCol);
static int MapCells(const ECHAR *each, const int nStrLen, const int nCellPos);

void termPaint(const HHTERM hhTerm, const HWND hwnd)
	{
	PAINTSTRUCT ps;
	RECT rc, rci;
	HBRUSH hBrush;
	HFONT hFont;
	int i, j, k, l, m, n;
	int iOffset;
	int iPaintBeg;
	int iPaintEnd;
	int xr, xl;
	ECHAR **fplpstrTxt;
	POINT ptTemp;
	const int iScrlInc = hhTerm->yChar;
	const HDC hdc = BeginPaint(hwnd, &ps);
#ifndef CHAR_NARROW
	int x;
	int fRight;
	ECHAR aechTmpBuf[MAX_EMUCOLS + 1];
#endif

	SetTextAlign(hdc, TA_BOTTOM);
	SelectObject(hdc, hhTerm->hbrushTerminal);
	hFont = (HFONT)SelectObject(hdc, hhTerm->hFont);

	iPaintBeg = max(hhTerm->iVScrlMin,
		hhTerm->iVScrlPos + (ps.rcPaint.top / hhTerm->yChar));

	iPaintEnd = min(hhTerm->iRows + 1, hhTerm->iVScrlPos +
			((min(hhTerm->iTermHite * hhTerm->yChar, ps.rcPaint.bottom) +
				hhTerm->yChar - 1) / hhTerm->yChar));

	rc = ps.rcPaint;

	/* -------------- xl is calculation of left edge. ------------- */

	if (hhTerm->iHScrlPos == 0)
		xl = 0;

	else
		xl = min(0, -(hhTerm->iHScrlPos * hhTerm->xChar)
				- hhTerm->xBezel + hhTerm->xChar);

	/* -------------- xr = right edge of text. ------------- */

	xr = xl + (hhTerm->iCols * hhTerm->xChar) + hhTerm->xIndent
		+ hhTerm->xBezel;

	if (ps.rcPaint.bottom > (i = ((hhTerm->iTermHite
			- (hhTerm->xBezel ? 1 : 0)) * hhTerm->yChar)))
		{
		// Only draw between bottom line and top of the bezel, since the
		// bezel gets drawn below anyway.  If no bezel, fill to the bottom
		// of the terminal window.
		//
		rc.top	  = max(rc.top, i);

		rc.bottom = min(rc.bottom,
					hhTerm->cy - ((hhTerm->iVScrlMax == hhTerm->iVScrlPos) ?
					hhTerm->xBezel : 0));

		rc.left  += (xl == 0 && iPaintEnd > 0 && rc.left == 0) ?
					hhTerm->xBezel : 0;

		rc.right  = min(rc.right, xr + hhTerm->xIndent);

		FillRect(hdc, &rc, (iPaintEnd < 0) ? hhTerm->hbrushBackScrl :
											 hhTerm->hbrushTerminal);
		}

	// Could be space beyond the emulator screen (ie. hi-res monitor)
	// that needs filling with the approproiate color.

	if (ps.rcPaint.right > xr)
		{
		rc.left = xr;

		ptTemp.x = 0;
		ptTemp.y = hhTerm->yBrushOrg;
		ClientToScreen(hwnd, &ptTemp);

		if (iPaintBeg <= 0)
			{
			rc.top = (-hhTerm->iVScrlPos + iPaintBeg) * hhTerm->yChar;

			rc.bottom = (iPaintEnd <= 0) ? ps.rcPaint.bottom :
				(-hhTerm->iVScrlPos + min(1, iPaintEnd)) * hhTerm->yChar;

			rc.right = rc.left + hhTerm->xIndent + hhTerm->xBezel;

			FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
			rc.right = ps.rcPaint.right;

			if (i)
				{
				SetBkColor(hdc, hhTerm->crBackScrl);
				SetBrushOrgEx(hdc, ptTemp.x, ptTemp.y, NULL);
				rc.left += hhTerm->xIndent + hhTerm->xBezel;

				if (hhTerm->xBezel)
					FillRect(hdc, &rc, hhTerm->hbrushBackScrl);

				else
					FillRect(hdc, &rc, hhTerm->hbrushBackHatch);


				rc.left -= hhTerm->xIndent + hhTerm->xBezel;
				}
			}

		if (iPaintEnd >= 0)
			{
			rc.top = (-hhTerm->iVScrlPos + max(1, iPaintBeg)) * hhTerm->yChar
							- hhTerm->yChar/2;

			rc.bottom = ps.rcPaint.bottom;
			rc.right = rc.left + hhTerm->xIndent;

			FillRect(hdc, &rc, hhTerm->hbrushTerminal);
			rc.right = ps.rcPaint.right;

			if (i)
				{
				SetBkColor(hdc, hhTerm->crTerm);
				SetBrushOrgEx(hdc, ptTemp.x, ptTemp.y, 0);
				rc.left += hhTerm->xIndent + hhTerm->xBezel;

				if (hhTerm->xBezel)
					FillRect(hdc, &rc, hhTerm->hbrushBackScrl);

				else
					FillRect(hdc, &rc, hhTerm->hbrushTermHatch);
				}
			}
		}

	// Fill in the indent margin along the left side of the terminal.

	if (ps.rcPaint.left < (hhTerm->xIndent +
			(hhTerm->iHScrlPos ? 0 : hhTerm->xBezel)))
		{
		rc.left = ps.rcPaint.left;
		rc.right = hhTerm->xIndent + (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel);

		// When scrolling down during marking, corners were left unpainted.
		// This guy corrects that. - mrw

		if (iPaintBeg < 0)
			{
			rc.top = (-hhTerm->iVScrlPos + iPaintBeg) * hhTerm->yChar;
			rc.bottom = (-hhTerm->iVScrlPos + min(0,iPaintEnd)) * hhTerm->yChar;
			FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
			}

		if (iPaintEnd > 0)
			{
			// The top & bottom should only redraw from & to the bezel.
			// that is all that's needed...
			//
			rc.top	  = (-hhTerm->iVScrlPos + max(1, iPaintBeg)) *
							hhTerm->yChar;

			rc.bottom = (hhTerm->iVScrlPos == hhTerm->iVScrlMax) ?
							hhTerm->cy - hhTerm->xBezel : ps.rcPaint.bottom;

			rc.left   = max(ps.rcPaint.left,
							((hhTerm->iHScrlPos == 0) ? hhTerm->xBezel : 0));

			FillRect(hdc, &rc, hhTerm->hbrushTerminal);
			}

		// New outdented bezel style requires filling with gray between
		// bezel and left edge.

		if (hhTerm->iHScrlPos == 0 && ps.rcPaint.left <= OUTDENT &&
				iPaintEnd > 0)
			{
			rc.top   	= (-hhTerm->iVScrlPos + max(0, iPaintBeg)) * hhTerm->yChar;
			rc.bottom	= (-hhTerm->iVScrlPos + iPaintEnd + 2) * hhTerm->yChar;
			rc.right 	= OUTDENT;
			rc.left 	= ps.rcPaint.left;

			FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
			}
		}

	/* -------------- Paint bezel here ------------- */

	if (hhTerm->xBezel)
		{
		/* -------------- Left edge ------------- */

		if (iPaintEnd >= 0)
			{
			// n is the width of the thick gray section of the bezel.
			// we surround the thick gray part with four lines of
			// of white and gray lines.  That's why we subtract 4.

			n = hhTerm->xBezel - OUTDENT - 4;

			/* -------------- Left edge ------------- */

			rc.left = xl + OUTDENT;
			rc.right = rc.left + hhTerm->xBezel;

			k = ((hhTerm->iVScrlMax - hhTerm->iVScrlPos + hhTerm->iTermHite)
					* hhTerm->yChar) + (hhTerm->cy % hhTerm->yChar);

			rc.top = (-hhTerm->iVScrlPos * hhTerm->yChar) + OUTDENT;
			rc.bottom = k - OUTDENT;

			if (IntersectRect(&rci, &rc, &ps.rcPaint))
				{
				/* --- Paint outer border --- */

				SelectObject(hdc, hhTerm->hWhitePen);
				MoveToEx(hdc, rc.left, rc.top++, NULL);
				LineTo(hdc, rc.left++, rc.bottom--);

				MoveToEx(hdc, rc.left, rc.top++, NULL);
				LineTo(hdc, rc.left++, rc.bottom--);

                /* --- Paint middle portion --- */

				rc.right = rc.left + n;
	            FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				rc.left += n;
				rc.top += n;
				rc.bottom -= n;

                /* --- Paint inner border --- */

				SelectObject(hdc, hhTerm->hDkGrayPen);
				MoveToEx(hdc, rc.left, rc.top++, NULL);
				LineTo(hdc, rc.left++, rc.bottom--);

				SelectObject(hdc, hhTerm->hBlackPen);
				MoveToEx(hdc, rc.left, rc.top, NULL);
				LineTo(hdc, rc.left, rc.bottom);
				}

			/* -------------- Bottom edge ------------- */

			rc.left = xl + OUTDENT;
			rc.right = xr + hhTerm->xIndent + hhTerm->xBezel - 1 - OUTDENT;
			l = rc.right; // save for right side.

			rc.bottom = k;
			rc.top = rc.bottom - hhTerm->xBezel;

			if (IntersectRect(&rci, &rc, &ps.rcPaint))
				{
				/* --- Paint from bezel to bottom of screen --- */

				m = rc.top;
				rc.top = rc.bottom - OUTDENT;
				FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				rc.top = m;
				rc.bottom -= OUTDENT + 1;

				/* --- Paint outer border --- */

				SelectObject(hdc, hhTerm->hBlackPen);
				MoveToEx(hdc, rc.left++, rc.bottom, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				SelectObject(hdc, hhTerm->hDkGrayPen);
				MoveToEx(hdc, rc.left++, rc.bottom, NULL);
				LineTo(hdc, rc.right--, rc.bottom);

                /* --- Paint middle portion --- */

				rc.top = rc.bottom - n;
	            FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				rc.left += n;
				rc.right -= n-1;
				rc.bottom -= n;

                /* --- Paint inner border --- */

				SelectObject(hdc, hhTerm->hWhitePen);
				MoveToEx(hdc, rc.left++, rc.bottom, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				MoveToEx(hdc, rc.left++, rc.bottom, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				SelectObject(hdc, hhTerm->hDkGrayPen);
				MoveToEx(hdc, rc.left++, rc.bottom, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				/* --- Fill in the bottom below bezel --- */

				rc.top = k;
				rc.bottom = rc.top + OUTDENT;
				rc.left = xl + OUTDENT;
				rc.right = l + 1;

				FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				}

			/* -------------- Right edge ------------- */

			rc.top = (-hhTerm->iVScrlPos * hhTerm->yChar) + OUTDENT;
			rc.bottom = k;
			rc.right = l + OUTDENT + 1;
			rc.left = rc.right - hhTerm->xBezel;

			if (IntersectRect(&rci, &rc, &ps.rcPaint))
				{
				/* --- Paint outdent region --- */

				rc.left = l;
				FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				rc.bottom -= OUTDENT;
				rc.right -= OUTDENT + 1;

				/* --- Paint outer border --- */

				SelectObject(hdc, hhTerm->hBlackPen);
				MoveToEx(hdc, rc.right, rc.top++, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				SelectObject(hdc, hhTerm->hDkGrayPen);
				MoveToEx(hdc, rc.right, rc.top++, NULL);
				LineTo(hdc, rc.right, rc.bottom--);

                /* --- Paint middle portion --- */

				rc.left = rc.right - n;
	            FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				rc.top += n-1;
				rc.right -= n;
				rc.bottom -= n-1;

                /* --- Paint inner border --- */

				SelectObject(hdc, hhTerm->hWhitePen);
				MoveToEx(hdc, rc.right, rc.top++, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				MoveToEx(hdc, rc.right, rc.top++, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				SelectObject(hdc, hhTerm->hDkGrayPen);
				MoveToEx(hdc, rc.right, rc.top++, NULL);
				LineTo(hdc, rc.right--, rc.bottom--);

				/* --- Fill area to right of bezel --- */

				rc.left = l + 1;
				rc.right = rc.left + OUTDENT;
				rc.top = -hhTerm->iVScrlPos * hhTerm->yChar;
				rc.bottom = k + OUTDENT;

				FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
				}
			}
		}

	// Paint backscroll buffer.  Stuff going into the backscroll
	// region is always on a line basis.   You'll notice that the
	// calculation for l in the terminal area portion is more
	// complicated since stuff comes in at times on a character
	// basis.  l represents the number of characters in the
	// character string to paint.

	i = iPaintBeg;

	if (i < iPaintEnd && i < 0)
		{
		j = (ps.rcPaint.left - hhTerm->xIndent
			- (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel)) / hhTerm->xChar;

		j = max(j, 0);

		k = (j * hhTerm->xChar) + hhTerm->xIndent
				+ (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel);

		j += hhTerm->iHScrlPos - (hhTerm->xBezel && hhTerm->iHScrlPos ? 1:0);

		l = min(hhTerm->iCols - j,
			(ps.rcPaint.right + hhTerm->xChar - 1 - k) / hhTerm->xChar);

		fplpstrTxt = hhTerm->fplpstrBkTxt;
		m = hhTerm->iPhysicalBkRows;

		if (hhTerm->fBackscrlLock == TRUE)
			iOffset = (abs(hhTerm->iVScrlPos - i) + hhTerm->iNextBkLn) % m;

		else
			iOffset = (m + i + hhTerm->iNextBkLn) % m;

		n = iScrlInc * (-hhTerm->iVScrlPos + i);

#ifdef CHAR_NARROW
		for ( ; i < iPaintEnd && i < 0 ; i+=1, n+=iScrlInc)
			{
			TextAttrOut(hhTerm, hdc, k, n, fplpstrTxt[iOffset]+j,
				(PSTATTR)0, FALSE, l, i, j);

			if (++iOffset >= m)
				iOffset = 0;
			}
#else
        // This little hack is here to display wide (Kanji) characters in
		// the backscroll, without all of the fuss of adding attributes.
		// It forces the backscroll to always paint the
        // enitre row, and strips out the repeated left/right pairs

		j = (OUTDENT - (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel)) / hhTerm->xChar;
		j = max(j, 0);
			
		k = (j * hhTerm->xChar) + OUTDENT
				+ (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel);
		j += hhTerm->iHScrlPos - (hhTerm->xBezel && hhTerm->iHScrlPos ? 1:0);
		l = hhTerm->iCols - j;
		
		for ( ; i < iPaintEnd && i < 0 ; i+=1, n+=iScrlInc)
			{
			// Hack for starting on the right half of a DB char
			fRight = FALSE;

			for (x = 0; x <= j; )
				{
				if (isDBCSChar(*(fplpstrTxt[iOffset]+x)))
					{
					fRight = (x == j) ? FALSE : TRUE;
					x += 2;
					}
				else
					{
					fRight = FALSE;
					x += 1;
					}
				}

			memset(aechTmpBuf, 0, sizeof(aechTmpBuf));
			StrCharStripDBCSString(aechTmpBuf, sizeof(aechTmpBuf),
				fplpstrTxt[iOffset]+j); //mpt:12-11-97 too many parameters? , l * sizeof(ECHAR));

			TextAttrOut(hhTerm, hdc, k, n, aechTmpBuf,
				(PSTATTR)0, fRight, l, i, j);

			if (++iOffset >= m)
				iOffset = 0;
			}
#endif
		}

	/* -------------- Paint divider bar if necessary ------------- */

	for ( ; i == 0 ; ++i)
		{
		if (hhTerm->xBezel)
			{
			// n is the width of the thick gray section of the bezel.
			// we surround the thick gray part with four lines of
			// of white and gray lines.  That's why we subtract 4.

			n = hhTerm->xBezel - OUTDENT - 4;

			rc.top = -hhTerm->iVScrlPos * hhTerm->yChar;
			rc.bottom = rc.top + OUTDENT;
            rc.left = ps.rcPaint.left;
            rc.right = ps.rcPaint.right;

			/* --- Paint gap above divider bar --- */

            FillRect(hdc, &rc, hhTerm->hbrushBackScrl);

			rc.left = xl + hhTerm->xBezel + hhTerm->xIndent;
			rc.right = xr;

            /* --- If hightlighting, paint gap above divider --- */

			if (min(hhTerm->ptBeg.y, hhTerm->ptEnd.y) < 0 &&
					max(hhTerm->ptBeg.y, hhTerm->ptEnd.y) > 0)
				{
				FillRect(hdc, &rc, hhTerm->hbrushHighlight);
				}

			rc.left = xl + OUTDENT;
			rc.right = xr + hhTerm->xIndent + hhTerm->xBezel - OUTDENT - 1;

			/* --- note: order is important, bottom, top --- */

			rc.bottom = rc.top + hhTerm->yChar;
			rc.top += OUTDENT;

            /* --- Paint top outside border --- */

			SelectObject(hdc, hhTerm->hWhitePen);
			MoveToEx(hdc, rc.left++, rc.top, NULL);
			LineTo(hdc, rc.right--, rc.top++);

			MoveToEx(hdc, rc.left++, rc.top, NULL);
			LineTo(hdc, rc.right--, rc.top++);

            /* --- Paint middle section --- */

            m = rc.bottom;
			rc.bottom = rc.top + n;
            FillRect(hdc, &rc, hhTerm->hbrushBackScrl);
            rc.bottom = m;
			rc.left += n;
			rc.top += n;
			rc.right -= n;

            /* --- Paint bottom border --- */

			SelectObject(hdc, hhTerm->hDkGrayPen);
			MoveToEx(hdc, rc.left++, rc.top, NULL);
			LineTo(hdc, rc.right--, rc.top++);

			SelectObject(hdc, hhTerm->hBlackPen);
			MoveToEx(hdc, rc.left++, rc.top, NULL);
			LineTo(hdc, rc.right, rc.top++);

			/* --- Fill in any space left below the bezel --- */

			FillRect(hdc, &rc, hhTerm->hbrushTerminal);

			if (min(hhTerm->ptBeg.y, hhTerm->ptEnd.y) < 0 &&
					max(hhTerm->ptBeg.y, hhTerm->ptEnd.y) > 0)
				{
				rc.left = hhTerm->xIndent;
				rc.left += (hhTerm->iHScrlPos) ? 0 : hhTerm->xBezel;
				rc.right -= hhTerm->xIndent;
				FillRect(hdc, &rc, hhTerm->hbrushHighlight);
				}
			}

		else
			{
			j = (hhTerm->yChar * -hhTerm->iVScrlPos);
			k = (hhTerm->yChar) / 3;

			// Create highlight brush if textmarking crosses divider

			if (min(hhTerm->ptBeg.y, hhTerm->ptEnd.y) < 0 &&
					max(hhTerm->ptBeg.y, hhTerm->ptEnd.y) > 0)
				{
				hBrush = hhTerm->hbrushHighlight;
				}

			else
				{
				hBrush = 0;
				}

			rc = ps.rcPaint;

			rc.top = j;
			rc.bottom = j + k + (hhTerm->yChar % 3);

			l = rc.right =
					((hhTerm->iCols - hhTerm->iHScrlPos) * hhTerm->xChar)
						+ hhTerm->xIndent + hhTerm->xIndent +
							hhTerm->xBezel + hhTerm->xBezel;

			FillRect(hdc, &rc, (hBrush != (HBRUSH)0) ?
												hBrush :
												hhTerm->hbrushBackScrl);

			rc.top = rc.bottom;
			rc.bottom = rc.top + k;
			rc.right = ps.rcPaint.right;
			FillRect(hdc, &rc, hhTerm->hbrushDivider);

			rc.top = rc.bottom;
			rc.bottom = j + hhTerm->yChar;
			rc.right = l;
			FillRect(hdc, &rc, (hBrush != (HBRUSH)0) ?
												hBrush :
												hhTerm->hbrushTerminal);
			}
		}

	/* -------------- Paint the active terminal portion. ------------- */

	xl = (hhTerm->iHScrlPos) ? 0 : hhTerm->xBezel;

	if (i < iPaintEnd)
		{
		j = (ps.rcPaint.left - hhTerm->xIndent - xl) / hhTerm->xChar;

		j = max(j, 0);

		k = (j * hhTerm->xChar) + hhTerm->xIndent + xl;

		j += hhTerm->iHScrlPos - (hhTerm->xBezel && hhTerm->iHScrlPos ? 1:0);

		l = min(hhTerm->iCols - j,
			(ps.rcPaint.right + hhTerm->xChar - 1 - k) / hhTerm->xChar);

		// Formulas to convert from terminal to buffer row and back.
		// b = (t - 1 + top) % rows
		// t = (b + rows - top) % rows
		// t is always between 1 and rows+1.

		iOffset = (i - 1 + hhTerm->iTopline) % MAX_EMUROWS;
		n = iScrlInc * (-hhTerm->iVScrlPos + i);

		for ( ; i < iPaintEnd ; i += 1, n += iScrlInc)
			{
			TextAttrOut(hhTerm, hdc, k, n, hhTerm->fplpstrTxt[iOffset]+j,
				hhTerm->fppstAttr[iOffset]+j, FALSE, l, i, j);

			if (++iOffset >= MAX_EMUROWS)
				iOffset = 0;
			}
		}

	/* --- Draw cursors --- */

	if (hhTerm->fHstCurOn)
		{
		hhTerm->fHstCurOn = FALSE;
		PaintHostCursor(hhTerm, TRUE, hdc);
		}

	if (hhTerm->fLclCurOn)
		{
		hhTerm->fLclCurOn = FALSE;
		PaintLocalCursor(hhTerm, TRUE, hdc);
		}

	/* --- cleanup time --- */

	SelectObject(hdc, GetStockObject(WHITE_BRUSH));
	SelectObject(hdc, GetStockObject(BLACK_PEN));
	SelectObject(hdc, hFont);

	EndPaint(hwnd, &ps);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TextAttrOut
 *
 * DESCRIPTION:
 *	Draws text and attributes on the terminal screen.  Optimizes call to
 *	TextOut based on attributes.  For example, If attributes are all the
 *	same for a given line, then only one call to TextOut is made.
 *
 * ARGUMENTS:
 *	HHTERM	hhTerm		- internal terminal handle
 *	HDC 	hdc 		- Device context from WM_PAINT
 *	int 	x			- x offset in pixels
 *	int 	y			- y offset in pixels
 *	ECHAR	*lpachText	- long pointer to begining of text to print
 *	PSTATTR apstAttrs	- Array of pointers to attribute structures
 *	int		fForceRight - used for DBCS in the backscroll
 *	int 	nCount		- number of characters to draw.
 *	int 	iRow		- logical row being displayed
 *	int 	iCol		- logical col being displayed
 *
 * RETURNS:
 *	void
 *
 */
static void TextAttrOut(const HHTERM	 hhTerm,
						const HDC		 hdc,
						const int		 x,
						const int		 y,
						const ECHAR	 	*lpachText,
						const PSTATTR	 apstAttrs,
						const int        fForceRight,
						const int		 nCount,
						const int		 iRow,
						const int		 iCol)
	{
	int 			 i = 0, 			// track of how many chars drawn.
					 j, 				// number of characters in a run.
					 k, 				// offset where run began.
					 nXPos;
	int 			 nXStart, nYStart;	// screen pos where chars are drawn.
#ifndef CHAR_NARROW
	int		nByteCount = 0;
#endif
	int				 nBegAdj = 0;
	int				 nEndAdj = 0;
	int				 nStrLen = 0;
	TCHAR            achBuf[MAX_EMUCOLS * 2];
	ECHAR			 aechTmp[MAX_EMUCOLS + 1];
	PSTATTR 		 pstAttr 		= 0;
	unsigned int	 uTxtclr, uBkclr;
	BOOL			 fUnderlnFont = FALSE;
	BOOL			 fSymbolFont = FALSE;
	BOOL			 fDblHiHi = FALSE;
	BOOL			 fDblHiLo = FALSE;
	BOOL			 fDblWiLf = FALSE;
	BOOL			 fDblWiRt = FALSE;
	BOOL			 fWiLf	  = FALSE;
	BOOL			 fWiRt 	  = FALSE;
	BOOL			 fFirstPass = TRUE;
	RECT			 rc;

	DbgOutStr("TAO %d\r\n", iRow, 0, 0, 0, 0);

	while (i < nCount)
		{
		k = i;	// save offset of where this run begins in k.
		if (iRow < 0)
			{
			int	  nCurPos;
			long  l,
				  lBeg,
				  lEnd;
			BOOL  fMarking = FALSE;

			// Store the positions of the 1st char to draw
			nCurPos = i;

			// This check is a speed tweak.  If the marking and backscrl
			// locks are off, we know that no text is can be marked.  This
			// would be the normal case when stuff is streaming into the
			// terminal so we save the work done of the else body by
			// by checking and thus speed up the display.

			// For Far East we have to force the backscroll to paint every
			// character individualy.  This is becuase MicroSquish is not
			// able to provide fixed pitch fonts that are fixed pitch for
			// DBCS characters.
            //
			if (hhTerm->fMarkingLock == FALSE && 
				hhTerm->fBackscrlLock == FALSE &&
				hhTerm->iEvenFont == TRUE)
				{
				SetBkColor(hdc, hhTerm->crBackScrl);
				SetTextColor(hdc, hhTerm->crBackScrlTxt);
				i = j = nCount;
				}

			else
				{
            #ifdef CHAR_NARROW
				lBeg = hhTerm->ptBeg.y * hhTerm->iCols + hhTerm->ptBeg.x;
				lEnd = hhTerm->ptEnd.y * hhTerm->iCols + hhTerm->ptEnd.x;

            #else
				// Hack city man :)
				// In the mouse handling routines, we modify the selection 
				// cursor position so that you can't put it into the middle
				// of a wide character.  The problem is that at this
				// point the repeated characters have been removed.
				// Therefore we need to modify the cursor position to take
				// into account the number of repeated characters that
				// were removed from the string as of our current drawing 
				// position into that string.
				// pant, pant, pant.
				lBeg = hhTerm->ptBeg.x;
				lEnd = hhTerm->ptEnd.x;

				if (hhTerm->ptBeg.y == iRow)
					{
					lBeg = MapCells(lpachText , hhTerm->iCols, hhTerm->ptBeg.x);
					}

				if (hhTerm->ptEnd.y == iRow)
					{
					lEnd = MapCells(lpachText , hhTerm->iCols, hhTerm->ptEnd.x);
					}

				if (hhTerm->iEvenFont)
					{
					nBegAdj = lBeg - hhTerm->ptBeg.x;
					nEndAdj = lEnd - hhTerm->ptEnd.x;
					}
				else
					{
					nBegAdj = 0;
					nEndAdj = 0;
					}

				lBeg = hhTerm->ptBeg.y * hhTerm->iCols + lBeg;
				lEnd = hhTerm->ptEnd.y * hhTerm->iCols + lEnd;
#endif

				if (lBeg > lEnd)
					{
					l = lEnd;
					lEnd = lBeg;
					lBeg = l;
					}

				// IN_RANGE macro is inclusive so subtract one from sEnd
				// which at this point is known to be larger than sBeg

				lEnd -= 1;

				l = iRow * hhTerm->iCols + i + iCol;
				fMarking = (BOOL)IN_RANGE(l, lBeg, lEnd);

				if (fMarking)
					{
					SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
					SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
					}
				else
					{
					SetBkColor(hdc, hhTerm->crBackScrl);
					SetTextColor(hdc, hhTerm->crBackScrlTxt);
					}

				// For Far East we have to force the backscroll to paint every
				// character individualy.  This is becuase MicroSquish is not
				// able to provide fixed pitch fonts that are fixed pitch for
				// DBCS characters.
				if (hhTerm->iEvenFont)
					{
					for (j = 0 ; i < nCount ; ++i, ++j, ++l)
						{
						if (fMarking != (BOOL)IN_RANGE(l, lBeg, lEnd))
							break;
						}
					}
				else
					{
					i++;
					j = 1;
					}
				}

			nXPos = k = i - j;

#ifndef CHAR_NARROW
            if (nCurPos > 0) // Only copy the buffer if nCurPos > 0. REV: 04/11/2001.
                {
			    MemCopy(aechTmp, lpachText , (unsigned)nCurPos * sizeof(ECHAR));
			    nXPos = CnvrtECHARtoMBCS(achBuf, sizeof(achBuf), aechTmp, (unsigned)nCurPos * sizeof(ECHAR));
    			//nXPos = StrCharGetByteCount(achBuf); // mrw;5/17/95
                }

			// 18-May-1995	DLW
			// Added for the case where a DBCS string is started with half of
			// the character, like when scrolling to the right
			if (fForceRight && fFirstPass)
				{
				fWiRt = TRUE;
				}
			else
				{
				if (fForceRight)
					nXPos = max(0, nXPos - 1);
				}
#endif
			}

		// At this point we know were not painting in the backscrl area.
		// Since the terminal area has attributes that backscrl does not
		// have (ie. color, underlining, etc.) we need to do more work.
		//
		else
			{
			pstAttr = apstAttrs+i;
			uTxtclr = pstAttr->txtclr;
			uBkclr	= pstAttr->bkclr;

			// Test for attributes

			if (pstAttr->revvid)
				{
				unsigned uTmp = uTxtclr;
				uTxtclr = uBkclr;
				uBkclr	= uTmp;
				}

			if (pstAttr->hilite)
				{
				// Colors are arranged so that high intensity colors are
				// in the lower half of the color array (currently 16
				// colors corresponding to the IBM PC colors).	This
				// guy sets the color to the opposite intensity.

				uTxtclr = (uTxtclr + (MAX_EMUCOLORS/2)) % MAX_EMUCOLORS;

				if (uTxtclr == uBkclr)
					uTxtclr = (uTxtclr + 1) % MAX_EMUCOLORS;
				}

			if (pstAttr->bklite)
				{
				uBkclr = (uBkclr + (MAX_EMUCOLORS/2)) % MAX_EMUCOLORS;

				if (uBkclr == uTxtclr)
					uBkclr = (uBkclr + 1) % MAX_EMUCOLORS;
				}

			if (pstAttr->blink)
				{
				int iBufRow;

				if (hhTerm->iBlink == 0)
					hhTerm->iBlink = 1;

				if (hhTerm->iBlink == -1)
					uTxtclr = uBkclr;

				iBufRow = (iRow - 1 + hhTerm->iTopline) % MAX_EMUROWS;
				hhTerm->abBlink[iBufRow] = (BYTE)TRUE;
				}

			if (pstAttr->undrln)
				fUnderlnFont = TRUE;

			if (pstAttr->blank)
				uTxtclr = uBkclr;

			// Only allow one double height attribute
			//
			if (pstAttr->dblhihi)
				fDblHiHi = TRUE;

			else if (pstAttr->dblhilo)
				fDblHiLo = TRUE;

			// Only allow one double wide attribute
			//
			if (pstAttr->dblwilf)
				fDblWiLf = TRUE;

			else if (pstAttr->dblwirt)
				fDblWiRt = TRUE;

			// Only allow one wide attribute
			//
			if (pstAttr->wilf)
				fWiLf = TRUE;

			else if (pstAttr->wirt)
				fWiRt = TRUE;

			// If the symbol attribute is on, use alternate font.
			//
			if (pstAttr->symbol)
				fSymbolFont = TRUE;

			// Find the longest run of characters with the same attributes.
			//
			for (j = 0 ; i < nCount ; ++i, ++j)
				{
				if (memcmp(pstAttr, apstAttrs+i, sizeof(STATTR)) != 0)
					break;
				}

			/* --- Set text and background colors --- */

			if (pstAttr->txtmrk)
				{
				SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
				SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
				}

			else
				{
				SetBkColor(hdc, hhTerm->pacrEmuColors[uBkclr]);
				SetTextColor(hdc, hhTerm->pacrEmuColors[uTxtclr]);
				}

			/* --- How hard can it be to pick a font? --- */

			if (fDblHiHi || fDblHiLo)
				{
				if (fDblWiLf || fDblWiRt)
					{
					if (fSymbolFont)
						{
						if (hhTerm->hSymDblHiWiFont == 0)
							hhTerm->hSymDblHiWiFont = termMakeFont(hhTerm, 0, 1, 1, 1);

						SelectObject(hdc, hhTerm->hSymDblHiWiFont);
						}

					else
						{
						if (hhTerm->hDblHiWiFont == 0)
							hhTerm->hDblHiWiFont = termMakeFont(hhTerm, 0, 1, 1, 0);

						SelectObject(hdc, hhTerm->hDblHiWiFont);
						}
					}

				else
					{
					if (fSymbolFont)
						{
						if (hhTerm->hSymDblHiFont == 0)
							hhTerm->hSymDblHiFont = termMakeFont(hhTerm, 0, 1, 0, 1);

						SelectObject(hdc, hhTerm->hSymDblHiFont);
						}

					else
						{
						if (hhTerm->hDblHiFont == 0)
							hhTerm->hDblHiFont = termMakeFont(hhTerm, 0, 1, 0, 0);

						SelectObject(hdc, hhTerm->hDblHiFont);
						}
					}
				}

			else if (fDblWiLf || fDblWiRt)
				{
				if (fSymbolFont)
					{
					if (hhTerm->hSymDblWiFont == 0)
						hhTerm->hSymDblWiFont = termMakeFont(hhTerm, 0, 0, 1, 1);

					SelectObject(hdc, hhTerm->hSymDblWiFont);
					}

				else
					{
					if (hhTerm->hDblWiFont == 0)
						hhTerm->hDblWiFont = termMakeFont(hhTerm, 0, 0, 1, 0);

					SelectObject(hdc, hhTerm->hDblWiFont);
					}
				}

			else if (fSymbolFont)
				{
				if (hhTerm->hSymFont == 0)
					hhTerm->hSymFont = termMakeFont(hhTerm, 0, 0, 0, 1);

				SelectObject(hdc, hhTerm->hSymFont);
				}

			nXPos = k = i - j;
			}

		// Ok, go ahead, paint that text, make my day...

		// Guess I better explain myself here.	When Windows synthesizes
		// a font to get something like bold or italic, TextOut has a nasty
		// habit of adding a pixel to the end of the string (be it a
		// character or a run of characters).  This is documented in the
		// TEXTMETRIC structure in the description of tmOverHang.  This has
		// some unfortunate side effects (Don't believe me?  Try defing the
		// old stuff back in, select a bold font and do some hightlighting
		// and scrolling).	The solution is to explicitly clip so that text
		// is drawn only where I say it can draw.  This amounts in extra
		// work but the end result seems no slower. - mrw
        //
		rc.left   = x + (nXPos * hhTerm->xChar);

#if defined(FAR_EAST)
		if (rc.left > (x + (hhTerm->iCols * hhTerm->xChar)))
			rc.left = x + (hhTerm->iCols * hhTerm->xChar);
#endif

		rc.right  = rc.left + ((j - nEndAdj) * hhTerm->xChar);

		if (rc.right > (x + (hhTerm->iCols * hhTerm->xChar)))
			rc.right = x + (hhTerm->iCols * hhTerm->xChar);

		rc.top	  = y;
		rc.bottom = y + hhTerm->yChar;

		// If we're painting the bottom half of a double high character,
		// we need to raise the origin of where the character is drawn
		// by an additional char height.  The clipping rectangle insures
		// that only the cell portion is actually drawn.

		nYStart = (fDblHiHi) ? rc.bottom + hhTerm->yChar : rc.bottom;

		// More painting tricks.  If we're painting double wide characters
		// we'll be painting them one at a time.  Why you ask?  Well, this
		// routine tries to paint the longest run of characters with the
		// same attributes.  Just makes good windows sense.  In the case
		// of double wide however, the attributes come as double-wide left,
		// double-wide right.  Since the "double-wide" character has a
		// different attribute in its left side and right side, this
		// routine will paint each half one at a time (seperate calls to
		// ExtTextOut()).  This is useful and wanted.  Because we clip
		// the drawing area to the cell or cells region, we can draw the
		// right half by offsetting the x origin by one character cell
		// to the left.  Windows clipping logic will only draw in the
		// actual cell region so we get the right half of the character.
		// Lot of explaination for one measely line of code.
        //
		nXStart = (fDblWiRt || fWiRt) ? rc.left - hhTerm->xChar : rc.left;

		/* --- Hero of the day, ExtTextOut! --- */

		MemCopy(aechTmp, lpachText + k, (unsigned int)j * sizeof(ECHAR));

		nStrLen = CnvrtECHARtoMBCS(achBuf, sizeof(achBuf), aechTmp,
			(unsigned)j * sizeof(ECHAR)); //mrw:5/17/95

		achBuf[nStrLen] = TEXT('\0');

        #if defined(FAR_EAST) // mrw:10/10/95 - ifdef'ed this code
		if (!hhTerm->iEvenFont && !(fForceRight && fFirstPass))
			{
			// If this is a DBCS character we are painting, then we want to paint 2 cells
			// instead of 1 (makes sense, DBCS characters are twice as wide as SBCS).
			if (IsDBCSLeadByte(*achBuf))
				{
				rc.right += hhTerm->xChar;
                rc.right = min(rc.right, x + (hhTerm->iCols * hhTerm->xChar));
				}
			}
        #endif

		ExtTextOut(hdc, nXStart, nYStart, ETO_CLIPPED | ETO_OPAQUE,
			&rc, achBuf, (unsigned)nStrLen, 0);

		// Experiment.	Most terminals underline their fonts by placing
		// underscores under the characters.  The Windows underline font
		// places a thin line through the baseline of the character.
		// Many hosts use underlining in conjunction with box draw chars
		// to envelop regions of the screen.  The underscores complete
		// envelope and don't give the apperance of part of the characters
		// bleeding through. - mrw
		//
		if (fUnderlnFont)
			{
			// The double height makes the underscores too thick yet we
			// want to maintain the double-wide or symbol font we may be
			// using so check and recast the font to the samething without
			// the height component. - mrw
			//
			if (fDblHiHi || fDblHiLo)
				{
				if (fDblWiLf || fDblWiRt)
					{
					if (fSymbolFont)
						{
						if (hhTerm->hSymDblWiFont == 0)
							hhTerm->hSymDblWiFont = termMakeFont(hhTerm, 0, 0, 1, 1);

						SelectObject(hdc, hhTerm->hSymDblWiFont);
						}

					else
						{
						if (hhTerm->hDblWiFont == 0)
							hhTerm->hDblWiFont = termMakeFont(hhTerm, 0, 0, 1, 0);

						SelectObject(hdc, hhTerm->hDblWiFont);
						}
					}

				else if (fSymbolFont)
					{
					if (hhTerm->hSymFont == 0)
						hhTerm->hSymFont = termMakeFont(hhTerm, 0, 0, 0, 1);

					SelectObject(hdc, hhTerm->hSymFont);
					}

				else
					{
					SelectObject(hdc, hhTerm->hFont);
					}
				}

			// Set background to transparent so only the underscore
			// portion overpaints the character cell.
			//
			SetBkMode(hdc, TRANSPARENT);

			ExtTextOut(hdc, nXStart, nYStart, ETO_CLIPPED,
				&rc, hhTerm->underscores, (unsigned)j, 0);

			SetBkMode(hdc, OPAQUE);
			}

		/* --- Reselect the regular font only if we had to switch --- */

		if (fUnderlnFont || fDblHiHi || fDblHiLo || fDblWiLf || fDblWiRt
				|| fSymbolFont)
			{
			SelectObject(hdc, hhTerm->hFont);
			fUnderlnFont = FALSE;
			fSymbolFont = FALSE;
			fDblHiHi = FALSE;
			fDblHiLo = FALSE;
			fDblWiLf = FALSE;
			fDblWiRt = FALSE;
			}

		fWiRt = FALSE;
		fWiLf = FALSE;
		fFirstPass = FALSE;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MapCells
 *
 * DESCRIPTION:
 *  Maps screen cell position to internal screen image (echar image) position
 *
 * ARGUMENTS:
 *  each - source string (does it start from beg of line?)
 *  nStrLen - length in bytes
 *  nCellPos - screen position to 
 *
 * RETURNS:
 *	void
 *
 */
static int MapCells(const ECHAR *each, const int nStrLen, const int nCellPos)
	{
	int i, nCount;

	if (each == NULL)
		{
		assert(FALSE);
		return 0;
		}

	for (i = 0, nCount = 0; nCount < nCellPos && i < nStrLen; i++)
		{
		if (isDBCSChar(each[i]))
			{
			nCount += 2;
			}
		else
			{
			nCount += 1;
			}
		}
	return i;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termcpy.c ===
/*	File: D:\WACKER\tdll\termcpy.c (Created: 24-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 5/09/01 4:38p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "mc.h"
#include "tdll.h"
#include "htchar.h"
#include "session.h"
#include "backscrl.h"
#include "assert.h"
#include <emu\emu.h>
#include "term.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CopyMarkedTextFromTerminal
 *
 * DESCRIPTION:
 *	Helper function that gets the marked region and passes the call
 *	onto CopyTextFromTerminal().
 *
 * ARGUMENTS:
 *	hSession	- public session handle
 *	ppv 		- pointer to a buffer pointer
 *	pdwCnt		- pointer to size variable
 *	fIncludeLF	- TRUE means include linefeeds.
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL CopyMarkedTextFromTerminal(const HSESSION hSession, void **ppv,
								DWORD *pdwCnt, const BOOL fIncludeLF)
	{
	BOOL  fReturn;
	ECHAR *pechBuf;
	TCHAR *pszOutput;
	const HWND	hwndTerm = sessQueryHwndTerminal(hSession);
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwndTerm, GWLP_USERDATA);

	fReturn = CopyTextFromTerminal(hSession, &hhTerm->ptBeg, &hhTerm->ptEnd,
									ppv, pdwCnt, fIncludeLF);

	pechBuf = *ppv;
	// Strip Out Any repeated Characters in the string
	StrCharStripDBCSString(pechBuf, (long)StrCharGetEcharByteCount(pechBuf), pechBuf);

	// hMem currently points to an array of ECHAR's, convert this to
	// TCHARS before giving the results to the caller.
	pszOutput = malloc((ULONG)StrCharGetEcharByteCount(pechBuf) + 1);
	CnvrtECHARtoMBCS(pszOutput, (ULONG)StrCharGetEcharByteCount(pechBuf) + 1,
						pechBuf,StrCharGetEcharByteCount(pechBuf)+1);//mrw:5/17/95
	*(pszOutput + StrCharGetEcharByteCount(pechBuf)) = ETEXT('\0');
	free(pechBuf);
	pechBuf = NULL;
	*ppv = pszOutput;
	*pdwCnt = (ULONG)StrCharGetByteCount(pszOutput);

	return fReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CopyTextFromTerminal
 *
 * DESCRIPTION:
 *	A work-horse function that will use the given points as a marked region
 *	and do the necessary work to make a copy of the marked text into
 *	a new memory region.  The marked range can include the backscroll
 *	region and cross into the terminal region.	The begining and ending
 *	points are in terminal coordinates (backscroll lines are numbered
 *	-1 to -infinity, terminal lines are numbered 1 to 24, line 0 is the
 *	divider line and does not exist for copies but can be included in
 *	the range).  It is *not* a requirement that the begininig point be
 *	less than the ending point.
 *
 * ARGUMENTS:
 *	HSESSION	hSession	- handle to the session.
 *	LPPOINT 	lpptBeg 	- begining point of marked region.
 *	LPPOINT 	lpptEnd 	- end point of mark region.
 *	void	  **pv			- pointer to buffer pointer
 *	DWORD	   *pdwCnt		- pointer to double word for size
 *	BOOL		fIncludeLF	-
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL CopyTextFromTerminal(const HSESSION hSession,
						  const PPOINT pptBeg,
						  const PPOINT pptEnd,
						  void **ppv,
						  DWORD *pdwCnt,
						  const BOOL fIncludeLF)
	{
	int 		iWant,
				iGot,
				yLn,
				xCol,
				iLen,
				iTmp,
				iRows,
				iCols,
				iTopline,
				iOffset,
				iBkLns,
                iSize;
	DWORD		dwSize, dwOldSize;
	ECHAR		*lpachTxt;
	ECHAR		*lpachBuf;
	ECHAR		achTmp[256],
			   *pachTmp;
	ECHAR	   **alpstrTxt;
	long		lBeg, lEnd;
	HCURSOR 	hCursor;
	ECHAR	   *hMem = 0;			   // malloc memory
	ECHAR	   *hMemTmp = 0;		   // malloc memory
	POINT		ptBeg, ptEnd, ptTmp;
	const HWND	hwndTerm = sessQueryHwndTerminal(hSession);
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwndTerm, GWLP_USERDATA);
	const HBACKSCRL hBackscrl = sessQueryBackscrlHdl(hhTerm->hSession);

	*ppv = 0;
	*pdwCnt = 0;

	hCursor = SetCursor(LoadCursor((HINSTANCE)0, IDC_WAIT));
	dwSize = 1; // By starting at one, we always have room for the '\0'.

	iRows = hhTerm->iRows;
	iCols = hhTerm->iCols;
	iTopline = hhTerm->iTopline;
	alpstrTxt = hhTerm->fplpstrTxt;

	ptBeg = *pptBeg;
	ptEnd = *pptEnd;

	/* --- do some range checking for the line number --- */

	iBkLns = backscrlGetNumLines(hBackscrl);
	iBkLns = -iBkLns;

	if (ptBeg.y > 0 && ptBeg.y > iRows)
		ptBeg.y = iRows;

	if (ptBeg.y < 0 && ptBeg.y < iBkLns)
		ptBeg.y = iBkLns;

	if (ptEnd.y > 0 && ptEnd.y > iRows)
		ptEnd.y = iRows;

	if (ptEnd.y < 0 && ptEnd.y < iBkLns)
		ptEnd.y = iBkLns;

	/* --- and do some range checking for the column number --- */

	if (ptBeg.x < 0)		/* negative column doesn't make much sense */
		ptBeg.x = 0;

	if (ptBeg.x >= iCols)
		ptBeg.x = iCols - 1;

	if (ptEnd.x < 0)		/* see above */
		ptEnd.x = 0;

	if (ptEnd.x >= iCols)
		ptEnd.x = iCols - 1;

	/* --- convert to offsets --- */

	lBeg = (ptBeg.y * iCols) + ptBeg.x;
	lEnd = (ptEnd.y * iCols) + ptEnd.x;

	if (lBeg == lEnd)
		{
		SetCursor(hCursor);
		return FALSE;
		}

	sessSetSuspend(hSession, SUSPEND_TERMINAL_COPY);

	if (lBeg > lEnd)
		{
		ptTmp = ptEnd;
		ptEnd = ptBeg;
		ptBeg = ptTmp;
		}

	if ((hMem = malloc(dwSize * sizeof(ECHAR))) == 0)
		{
		assert(FALSE);
		SetCursor(hCursor);
		sessClearSuspend(hSession, SUSPEND_TERMINAL_COPY);
		return FALSE;
		}

	// Get first line of range

	iGot = 0;
	lpachTxt = 0;
	achTmp[0] = ETEXT('\0');

	if (ptBeg.y < 0)
		{
		xCol  = ptBeg.x;
		yLn   = ptBeg.y;
		iWant = ptEnd.y - ptBeg.y + 1;

		if (iWant > 0)
			{
			while (iWant > 0)
				{
				if (backscrlGetBkLines(hBackscrl, yLn, iWant, &iGot,
						&lpachTxt, &iOffset) == FALSE)
					{
					goto PROCESS_ERROR;
					}

				lpachTxt += iOffset;

				// Lets say the user has highlighted an area of the backscroll
				// region that has no data (ie. a blank line).	Adding xCol to
				// lpachTxt is incorrect.  This for-loop checks for this
				// condition and resets lpachTxt to the beginning of the line.
				// Incidentally, this also sets xCol to 0 which is necessary
				// for subsequent lines to feed in correctly.

				for (lpachBuf = lpachTxt ; xCol > 0 ; --xCol, ++lpachTxt)
					{
					if (*lpachTxt == ETEXT('\n'))
						{
						lpachTxt = lpachBuf;
						xCol = 0;
						break;
						}
					}

				iWant -= iGot;

				while (iGot-- > 0 && yLn < ptEnd.y && yLn < -1)
					{
					for (pachTmp = achTmp, iTmp = 0 ;
						 *lpachTxt != ETEXT('\n') &&
                         //
                         // Fix for not getting full backscroll buffer
                         // in DBCS versions by taking into account the
                         // size of the ECHAR. REV: 03/07/2001
                         //
                         iTmp < MAX_EMUCOLS * sizeof(ECHAR);
						 ++pachTmp, ++iTmp)
						{
						*pachTmp = *lpachTxt++;
						}

					// Fail Safe:  if the text we received from
					// backscrlGetBkLines() is mangled somehow and we
					// don't see a newline, then abort before we seg.

                    //
                    // Fix for not getting full backscroll buffer
                    // in DBCS versions by taking into account the
                    // size of the ECHAR. REV: 03/07/2001
                    //

					if (iTmp >= MAX_EMUCOLS * sizeof(ECHAR))
						goto PROCESS_ERROR;

					lpachTxt += 1;
					*pachTmp++ = ETEXT('\r');

					if (fIncludeLF)
						*pachTmp++ = ETEXT('\n');

					*pachTmp   = ETEXT('\0');

					hMemTmp = hMem;
					dwOldSize = dwSize - 1;
					dwSize += (DWORD)StrCharGetEcharLen(achTmp);
					hMem = realloc(hMemTmp, dwSize *sizeof(ECHAR));

					if (hMem == 0)
						goto PROCESS_ERROR;

					/* remember how a realloc works */
					hMemTmp = (ECHAR *)0;

					lpachBuf = hMem + dwOldSize;
					iSize = StrCharGetEcharByteCount(achTmp);
                    if ( iSize )
                        MemCopy(lpachBuf, achTmp, iSize );
					hMem[dwSize - 1] = ETEXT('\0');

					yLn += 1;
					}

				if (yLn >= ptEnd.y || yLn >= -1)
					break;
				}

			// Another bug bytes the dust.	Wasn't checking to see if iGot
			// was the reason we exited the loop above.  It caused things
			// to seg occassionally.

			if (iGot >= 0)
				{
				// Last line stuff (could be crossing into terminal area but
				// we still need to clean-up backscroll stuff.

				if (ptBeg.y == ptEnd.y)
					xCol = ptEnd.x - ptBeg.x;

				else if (ptEnd.y < 0) /* && ptEnd.x > 0) removed - mrw */
					xCol = ptEnd.x;

				else
					xCol = iCols;

				for (pachTmp = achTmp ; xCol-- > 0 && *lpachTxt != ETEXT('\n'); ++pachTmp)
					*pachTmp = *lpachTxt++;

				if (ptEnd.y >= 0)
					{
					*pachTmp++ = ETEXT('\r');

					if (fIncludeLF)
						*pachTmp++ = ETEXT('\n');
					}

				*pachTmp = ETEXT('\0');
				}

			hMemTmp = hMem;
			dwOldSize = dwSize - 1;
			dwSize += (DWORD)StrCharGetEcharLen(achTmp);

			hMem = realloc(hMemTmp, dwSize * sizeof(ECHAR));

			if (hMem == 0)
				goto PROCESS_ERROR;

			/* remember how a realloc works */
			hMemTmp = (ECHAR *)0;

			lpachBuf = hMem + dwOldSize;
			iSize = StrCharGetEcharByteCount(achTmp);
            if ( iSize )
                MemCopy(lpachBuf, achTmp, iSize);
			hMem[dwSize - 1] = ETEXT('\0');
			} // end if (iWant > 0)

		// terminal area...

		if (ptEnd.y >= 0)
			{
			yLn = 1;

			while (yLn <= ptEnd.y)
				{
				iTmp = ((yLn + iTopline) % MAX_EMUROWS) - 1;

				if (iTmp < 0)
					iTmp = MAX_EMUROWS - 1;

				lpachTxt = alpstrTxt[iTmp];

				iLen = strlentrunc(lpachTxt, iCols);
				xCol = (yLn == ptEnd.y) ? min(ptEnd.x, iLen) : iLen;

				for (pachTmp = achTmp ; xCol > 0 ; --xCol)
					*pachTmp++ = *lpachTxt++;

				if (yLn != ptEnd.y)
					{
					*pachTmp++ = ETEXT('\r');

					if (fIncludeLF)
						*pachTmp++ = ETEXT('\n');
					}

				*pachTmp = ETEXT('\0');

				hMemTmp = hMem;
				dwOldSize = dwSize - 1;
				dwSize += (DWORD)StrCharGetEcharLen(achTmp);
				hMem = realloc(hMemTmp, dwSize * sizeof(ECHAR));

				if (hMem == 0)
					goto PROCESS_ERROR;
	
				/* remember how a realloc works */
				hMemTmp = (ECHAR *)0;

				lpachBuf = hMem + dwOldSize;
			    iSize = StrCharGetEcharByteCount(achTmp);
                if ( iSize )
    				MemCopy(lpachBuf, achTmp, iSize );
				hMem[dwSize - 1] = ETEXT('\0');

				yLn += 1;
				}
			}
		}

	else // terminal only case
		{
		if (ptBeg.y >= 0)
			{
			yLn = ptBeg.y;

			while (yLn <= ptEnd.y)
				{
				iTmp = ((yLn + iTopline) % MAX_EMUROWS) - 1;

				if (iTmp < 0)
					iTmp = MAX_EMUROWS - 1;

				lpachTxt = alpstrTxt[iTmp];

				if (ptBeg.y == ptEnd.y)
					{
					lpachTxt += ptBeg.x;

					xCol = min(strlentrunc(lpachTxt, iCols - ptBeg.x),
						ptEnd.x - ptBeg.x);
					}

				else if (yLn == ptBeg.y)
					{
					lpachTxt += ptBeg.x;
					xCol = strlentrunc(lpachTxt, iCols - ptBeg.x);
					}

				else if (yLn == ptEnd.y)
					{
					xCol = min(ptEnd.x, strlentrunc(lpachTxt, iCols));
					}

				else
					{
					xCol = strlentrunc(lpachTxt, iCols);
					}


				for (pachTmp = achTmp ; xCol > 0 ; --xCol)
					*pachTmp++ = *lpachTxt++;


				if (yLn != ptEnd.y)
					{
					*pachTmp++ = ETEXT('\r');

					if (fIncludeLF)
						*pachTmp++ = ETEXT('\n');
					}

				*pachTmp = ETEXT('\0');

				hMemTmp = hMem;
				dwOldSize = dwSize - 1;
				dwSize += (DWORD)StrCharGetEcharLen(achTmp);
				hMem = realloc(hMemTmp, dwSize * sizeof(ECHAR));

				if (hMem == 0)
					goto PROCESS_ERROR;

				/* remember how a realloc works */
				hMemTmp = (ECHAR *)0;

				lpachBuf = hMem + dwOldSize;
				
			    iSize = StrCharGetEcharByteCount(achTmp);
                if ( iSize )
                    MemCopy(lpachBuf, achTmp, iSize );
				hMem[dwSize - 1] = ETEXT('\0');

				yLn += 1;
				}
			}
		}

	SetCursor(hCursor);

	*ppv = hMem;
	*pdwCnt = (ULONG)StrCharGetEcharByteCount(hMem);
	sessClearSuspend(hSession, SUSPEND_TERMINAL_COPY);
	return TRUE;

	// process error condition here.

	PROCESS_ERROR:

    if (hMem)
        {
        free(hMem);
        hMem = NULL;
        }

	if (hMemTmp)
		{
		free(hMemTmp);
		hMemTmp = NULL;
		}

	SetCursor(hCursor);
	sessClearSuspend(hSession, SUSPEND_TERMINAL_COPY);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	strlentrunc
 *
 * DESCRIPTION:
 *	Finds the length of a character buffer less the trailing whitespace.
 *
 * ARGUMENTS:
 *	pach	- array of t characters
 *	iLen	- length of buffer
 *
 * RETURNS:
 *	new length
 *
 */
int strlentrunc(const ECHAR *pach, const int iLen)
	{
	int i;

	for (i = iLen-1 ; i >= 0 ; --i)
		{
		switch (pach[i])
			{
		/* Whitespace characters */
		case ETEXT('\0'):
		case ETEXT('\t'):
		case ETEXT('\n'):
		case ETEXT('\v'):
		case ETEXT('\f'):
		case ETEXT('\r'):
		case ETEXT(' '):
			break;

		default:
			return i+1;
			}
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termupd.c ===
/*	File: D:\WACKER\tdll\termupd.c (Created: 11-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 3/27/02 1:35p $
 */

#include <windows.h>
#pragma hdrstop

#include <stdlib.h>
#include <limits.h>

#include "stdtyp.h"
#include "assert.h"
#include "session.h"
#include <emu\emu.h>
#include <emu\emu.hh>
#include "update.h"
#include "update.hh"
#include "backscrl.h"
#include "timers.h"
#include "tdll.h"
#include "htchar.h"
#include "term.h"
#include "term.hh"
#include "mc.h"

static void termUpdate(const HHTERM hhTerm);
static int termReallocBkBuf(const HHTERM hhTerm, const int iLines);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termGetUpdate
 *
 * DESCRIPTION:
 *	Queries the update records and emulator to update the terminal image.
 *
 * ARGUMENTS:
 *	hhTerm	- internal terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
void termGetUpdate(const HHTERM hhTerm, const int fRedraw)
	{
	ECHAR		   **pachTxt,
					*pachTermTxt,
					*pachEmuTxt;
	PSTATTR 	   *pstAttr,
					pstTermAttr,
					pstEmuAttr;
	int 			i, j, k, m;
	BYTE		   *pabLines;

//	const iRows = hhTerm->iRows;
//	const iCols = hhTerm->iCols;
	const iRows = MAX_EMUROWS;
	const iCols = MAX_EMUCOLS;

	const HEMU hEmu = sessQueryEmuHdl(hhTerm->hSession);
	const HHUPDATE hUpd = (HHUPDATE)sessQueryUpdateHdl(hhTerm->hSession);

	/* --- Lock emulators so we have execlusive access --- */

	emuLock(hEmu);

	pachTxt = emuGetTxtBuf(hEmu);
	pstAttr = emuGetAttrBuf(hEmu);

	// Now check to see what needs updating...

	if (hUpd->bUpdateType == UPD_LINE)
		{
		struct stLineMode *pstLine = &hUpd->stLine;

		if (pstLine->iLine != -1)
			{
			// The emulators can place the cursor one past the number
			// of columns.	Why, I don't know, so we check and adjust
			// so we don't overwrite our client arrays.

			pstLine->xEnd = min(pstLine->xEnd, iCols);
			assert(pstLine->xBeg <= pstLine->xEnd);

			k = (pstLine->iLine + hUpd->iTopline) % MAX_EMUROWS;

			pachEmuTxt	= pachTxt[k] + pstLine->xBeg;
			pachTermTxt = hhTerm->fplpstrTxt[k] + pstLine->xBeg;

			pstEmuAttr	= pstAttr[k] + pstLine->xBeg;
			pstTermAttr = hhTerm->fppstAttr[k] + pstLine->xBeg;

			for (k = pstLine->xEnd - pstLine->xBeg ; k >= 0 ; --k)
				{
				// Televideo uses \xFF as a NULL character.

				if (*pachEmuTxt == ETEXT('\0') || *pachEmuTxt == ETEXT('\xFF'))
					*pachTermTxt = ETEXT(' ');

				else
					*pachTermTxt = *pachEmuTxt;

				*pstTermAttr = *pstEmuAttr;

				pachTermTxt += 1;
				pachEmuTxt	+= 1;

				pstTermAttr += 1;
				pstEmuAttr	+= 1;
				}
			}
		}

	else if (hUpd->bUpdateType == UPD_SCROLL)
		{
		struct stScrlMode *pstScrl = &hUpd->stScrl;

		hUpd->iLines = hhTerm->iBkLines =
			backscrlGetNumLines(sessQueryBackscrlHdl(hhTerm->hSession));

		/* -------------- Backscroll portion ------------- */

		if ((i = min(hhTerm->iBkLines, pstScrl->iBksScrlInc)) > 0)
			termGetBkLines(hhTerm, i, -i, BKPOS_ABSOLUTE);

		/* -------------- Terminal portion ------------- */

		if (pstScrl->iScrlInc != 0)
			{
			if (pstScrl->iScrlInc > 0)
				{
				i = max(0, pstScrl->yEnd - pstScrl->iScrlInc + 1);
				m = pstScrl->yEnd;
				}

			else
				{
				i = pstScrl->yBeg;
				m = min(iRows, pstScrl->yBeg - pstScrl->iScrlInc - 1);
				}


			k = ((i + hUpd->iTopline) % MAX_EMUROWS);

			for (; i <= m ; ++i)
				{
				// Server and Client have different size emulator images
				// for historical reasons.	Server side has 2 extra characters
				// per row.

				pachTermTxt = hhTerm->fplpstrTxt[k];
				pachEmuTxt = pachTxt[k];

				pstTermAttr = hhTerm->fppstAttr[k];
				pstEmuAttr = pstAttr[k];

				// Update the terminal buffer now.

				for (j = 0 ; j < iCols ; ++j, ++pachTermTxt, ++pachEmuTxt)
					{
					// Televideo uses \xFF as a NULL character.

					if (*pachEmuTxt == ETEXT('\0') ||
							*pachEmuTxt == ETEXT('\xFF'))
						{
						*pachTermTxt = ETEXT(' ');
						}

					else
						{
						*pachTermTxt = *pachEmuTxt;
						}
					}

				MemCopy(pstTermAttr, pstEmuAttr, iCols * sizeof(STATTR));

				if (++k >= MAX_EMUROWS)
					k = 0;
				}
			}

		// Check for lines now.

		k = hUpd->iTopline;
		pabLines = pstScrl->auchLines + pstScrl->iFirstLine;

		for (j = 0 ; j < iRows ; ++j, ++pabLines)
			{
			if (*pabLines != 0)
				{
				pachEmuTxt = pachTxt[k];
				pachTermTxt = hhTerm->fplpstrTxt[k];

				pstEmuAttr = pstAttr[k];
				pstTermAttr = hhTerm->fppstAttr[k];

				// Update the terminal buffer now.

				for (i = 0 ; i < iCols ; ++i, ++pachTermTxt, ++pachEmuTxt)
					{
					// Televideo uses \xFF as a NULL character.

					if (*pachEmuTxt == ETEXT('\0') ||
							*pachEmuTxt == ETEXT('\xFF'))
						{
						*pachTermTxt = ETEXT(' ');
						}

					else
						{
						*pachTermTxt = *pachEmuTxt;
						}
					}

				MemCopy(pstTermAttr, pstEmuAttr, iCols * sizeof(STATTR));
				}

			if (++k >= MAX_EMUROWS)
				k = 0;
			}

		// Another ugly situation.	Because we can mark stuff in the
		// backscroll buffer and still have updates coming in, we have
		// to bump the marking region by the scrollinc to keep everything
		// synchronized.  Note, we don't need to check for Marking locks
		// because we could not have been here had any been in place.

		if (hhTerm->ptBeg.y < 0 || hhTerm->ptEnd.y < 0)
			{
			hhTerm->ptBeg.y -= pstScrl->iScrlInc;
			hhTerm->ptEnd.y -= pstScrl->iScrlInc;
			}

		// Update emulator's topline field now.

		hhTerm->iTopline = hUpd->iTopline;
		}

	// Save a copy of the update handle in term.  This way we can
	// release our lock and paint without blocking the emulator.

	*(HHUPDATE)hhTerm->hUpdate = *hUpd;
	updateReset(hUpd);

	/* --- Important to remember to unlock emulator --- */

	emuUnlock(hEmu);

	/* --- Now let the terminal figure out how to paint itself. --- */

	if (fRedraw)
		termUpdate(hhTerm);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termUpdate
 *
 * DESCRIPTION:
 *	Invalidates the proper portions of the terminal buffers, updates
 *	scrollbars, and generally takes care of the busy work of keeping
 *	the terminal screen up to date.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *
 * RETURNS:
 *	void
 *
 */
static void termUpdate(const HHTERM hhTerm)
	{
	RECT  rc;
	int   i, j, l;
	BYTE *pauchLines;
	SCROLLINFO scrinf;
	const HHUPDATE hUpd = (HHUPDATE)hhTerm->hUpdate;

	GetClientRect(hhTerm->hwnd, &rc);

	// Adjust rectangle not to include indent/outdent areas.  This
	// will be ignored if we are scrolling the whole terminal.

	rc.left += hhTerm->xIndent + (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel);
	rc.right = min(((hhTerm->iCols * hhTerm->xChar) + hhTerm->xIndent + hhTerm->xBezel),
					rc.right);

	if (hUpd->bUpdateType == UPD_LINE)
		{
		if (hUpd->stLine.iLine != -1)
			{
			rc.top	  = (hUpd->stLine.iLine -
							hhTerm->iVScrlPos + 1) * hhTerm->yChar;

			rc.bottom = rc.top + hhTerm->yChar;

			rc.left   = ((hUpd->stLine.xBeg -
							hhTerm->iHScrlPos) * hhTerm->xChar)
								+ hhTerm->xIndent + hhTerm->xBezel;

			rc.right  = ((hUpd->stLine.xEnd -
							hhTerm->iHScrlPos + 1) * hhTerm->xChar)
								+ hhTerm->xIndent + hhTerm->xBezel;

			// Invalidate entire line when doing italics
			//
			if (hhTerm->fItalic)
				{
				rc.left = 0;
				rc.right = hhTerm->cx;
				}

			InvalidateRect(hhTerm->hwnd, &rc, FALSE);
			}
		}

	else if (hUpd->bUpdateType == UPD_SCROLL)
		{
		// Scroll range will change because new text is
		// scrolling into the backscroll region.

		i = hhTerm->iVScrlMin;
		j = hhTerm->iVScrlMax;

		if (i == j)
			hhTerm->fBump = FALSE;

		l = 0;

		// If bezel is drawn, make sure we have room
		//
		if (hhTerm->xBezel)
			{
			if ((hhTerm->cy % hhTerm->yChar) < (hhTerm->xBezel + 1))
				l = 1;
			}

		hhTerm->iVScrlMin = min(-hUpd->iLines,
			hhTerm->iRows - hhTerm->iTermHite + 1 + l);

		// This forces the terminal paint correctly if the minimum
		// number of lines changes such that the current vertical
		// scrolling position is no longer valid. mrw:6/19/95
		//
		if (hhTerm->iVScrlPos < hhTerm->iVScrlMin)
			hhTerm->iVScrlPos = hhTerm->iVScrlMin;

		if (i != hhTerm->iVScrlMin)
			{
			scrinf.cbSize= sizeof(scrinf);
			scrinf.fMask = SIF_DISABLENOSCROLL | SIF_RANGE | SIF_PAGE;
			scrinf.nMin  = hhTerm->iVScrlMin;
			scrinf.nMax  = hhTerm->iVScrlMax + hhTerm->iTermHite - 1;
			scrinf.nPage = (unsigned int)hhTerm->iTermHite;
			SetScrollInfo(hhTerm->hwnd, SB_VERT, &scrinf, TRUE);
			}

		// This is subtle but necessary.  When the window is
		// large enough to show full terminal and backscroll
		// and the backscroll is empty, iVScrlPos is 0.  The
		// moment the backscroll buffer becomes larger than
		// the backscroll area displayed, the iVScrlPos becomes
		// iVScrlMax in the case where text is coming in at the
		// bottom of the terminal screen.  We could update the
		// scrollbar on every pass, but this causes an annoying
		// flicker in the scrollbar.  This next piece of code
		// catches the transition from backscroll smaller than
		// displayed area to backscroll greater than displayed
		// area and updates the scrollbar position.

		// DbgOutStr("bump=%d, Min=%d, Max=%d\r\n",
		//	  hhTerm->fBump, hhTerm->iVScrlMin, hhTerm->iVScrlMax, 0, 0);

		if (!hhTerm->fBump && hhTerm->iVScrlMin != hhTerm->iVScrlMax)
			{
			// DbgOutStr("Pos = %d\r\n", hhTerm->iVScrlPos, 0, 0, 0, 0);

			scrinf.cbSize= sizeof(scrinf);
			scrinf.fMask = SIF_DISABLENOSCROLL | SIF_POS;
			scrinf.nPos = hhTerm->iVScrlPos;
			SetScrollInfo(hhTerm->hwnd, SB_VERT, &scrinf, TRUE);
			hhTerm->fBump = TRUE;
			}

		// Scroll specified area.

		rc.top = max(0, hUpd->stScrl.yBeg -
			hhTerm->iVScrlPos + 1) * hhTerm->yChar;

		rc.bottom = min(hhTerm->iTermHite,
			(hUpd->stScrl.yEnd -
				 hhTerm->iVScrlPos + 2)) *	hhTerm->yChar;

		// use iOffset to check for cursor erase operation.

		if (!hhTerm->fBackscrlLock)
			{
			HideCursors(hhTerm);

			ScrollWindow(hhTerm->hwnd, 0, -hhTerm->yChar *
				hUpd->stScrl.iScrlInc, (LPRECT)0, &rc);

			DbgOutStr("scroll %d", -hhTerm->yChar * hUpd->stScrl.iScrlInc,
				0, 0, 0, 0);
			}

		// Examine the lines portion of update record.

		// Note, this is a negative area rectangle (ie. top is larger
		// than bottom).
		//
		rc.top = INT_MAX;
		rc.bottom = 0;

		pauchLines = hUpd->stScrl.auchLines +
						hUpd->stScrl.iFirstLine;

		for (j = 0 ; j < hhTerm->iRows ; ++j, ++pauchLines)
			{
			if (*pauchLines != (UCHAR)0)
				{
				//iPaintEnd = max(iPaintEnd, j+1);
				DbgOutStr("pauchLines->%d\r\n", j, 0, 0, 0, 0);

				// Map invalid line to terminal.

				l = (j - hhTerm->iVScrlPos + 1) * hhTerm->yChar;

				if (l >= 0)
					{
					rc.top = min(rc.top, l);
					rc.bottom = max(rc.bottom, l + hhTerm->yChar);
					}

				InvalidateRect(hhTerm->hwnd, &rc, FALSE);
				}
			}
		} /* else */

	// Update the host cursor position according to the update record.
	// mrw:6/19/95 - comparison was backwards.
	//
	if (hhTerm->ptHstCur.y != hUpd->iRow || hhTerm->ptHstCur.x != hUpd->iCol)
		{
		HideCursors(hhTerm);
		hhTerm->ptHstCur.y = hUpd->iRow;
		hhTerm->ptHstCur.x = hUpd->iCol;
		}

	// Important to paint now.	If we wait, and the
	// backscroll region is also invalid, Windows will take
	// the union of these two rectangles and paint a much
	// larger region of the screen than is needed or wanted.
	// Note: UpdateWindow does nothing if the update region
	// in empty.

	UpdateWindow(hhTerm->hwnd);

	// Now take care of the backscroll buffer.

	i = hUpd->stScrl.iBksScrlInc;

	if (i && hUpd->bUpdateType == UPD_SCROLL)
		{
		rc.top = 0;
		rc.bottom = min(hhTerm->iTermHite, -hhTerm->iVScrlPos) * hhTerm->yChar;

		if (rc.bottom > rc.top && !hhTerm->fBackscrlLock)
			{
			HideCursors(hhTerm);
			ScrollWindow(hhTerm->hwnd, 0, -hhTerm->yChar * i, (LPRECT)0, &rc);
			UpdateWindow(hhTerm->hwnd);
			}

		else if (hhTerm->fBackscrlLock)
			{
			hhTerm->iVScrlPos -= i;
			scrinf.cbSize= sizeof(scrinf);
			scrinf.fMask = SIF_DISABLENOSCROLL | SIF_POS;
			scrinf.nPos = hhTerm->iVScrlPos;
			SetScrollInfo(hhTerm->hwnd, SB_VERT, &scrinf, TRUE);
			}
		}

	// Important to do this again before we turn the host cursor
	// back on.
	// Note: UpdateWindow does nothing if the update region
	// is empty.

	UpdateWindow(hhTerm->hwnd);
	ShowCursors(hhTerm);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termGetBkLines
 *
 * DESCRIPTION:
 *	This function is uglier than ulgy.	This function updates the local
 *	backscroll buffer after it has been filled by backscrlCFillLocalBk().
 *	This function only graps the actual number of lines it needs to update
 *	the local backscroll page.	The reason it is complex is because the
 *	server also stores it's backscroll buffer in pages.  If this routine
 *	requires data from more than one page, it must repeatedly ask the
 *	server until the request is satisfied.	Some assumptions are made
 *	here (and in backscrlCFillLocalBk()).  First and foremost, requests
 *	are never made beyond the backscroll region.  The caller's of these
 *	routines does this right now.  Second, if x number of lines are asked
 *	for, this routine will continue to try until it meets the request.
 *	Again, the callers are smart enough not to exceed the backscroll ranges.
 *
 * ARGUMENTS:
 *	HHTERM		hhTerm			-- internal terminal handle
 *	int 		iScrlInc		-- the # of lines and the direction scrolled
 *	int 		yBeg			-- depends on sType
 *	int 		iType			-- if BKPOS_THUMBPOS, yBeg is the thumb pos.
 *								   if BKPOS_ABSOLUTE, yBeg is absolute pos.
 *
 * RETURNS:
 *	nothing
 *
 */
void termGetBkLines(const HHTERM hhTerm, const int iScrlInc, int yBeg, int sType)
	{
	int 			i, j, k, l;
	int 			iWant, iGot;
	int 			iOffset;
	ECHAR			*pachTxt,		// terminal buffer
					*pachBkTxt;		// engine buffer
	const HBACKSCRL hBackscrl = sessQueryBackscrlHdl(hhTerm->hSession);

	if (abs(iScrlInc) > hhTerm->iPhysicalBkRows)
		{
		termFillBk(hhTerm, yBeg);
		return;
		}

	// Get needed backscroll text from server

	if (iScrlInc < 0)
		{
		assert(sType != BKPOS_ABSOLUTE);
		i = iScrlInc;

		// l is a wrap counter and is calculated for speed.
		//
		l = hhTerm->iNextBkLn = (hhTerm->iNextBkLn +
			hhTerm->iPhysicalBkRows + iScrlInc) % hhTerm->iPhysicalBkRows;
		}

	else
		{
		if (sType == BKPOS_THUMBPOS)
			{
			yBeg += hhTerm->iTermHite - iScrlInc;
			assert(yBeg < 0);
			}

		i = 0;
		}

	// Since backscroll memory is pages we have to make multiple requests.
	//
	for (iWant=abs(iScrlInc), iGot=0 ; iWant > 0 ; iWant-=iGot, yBeg+=iGot)
		{
		if (backscrlGetBkLines(hBackscrl, yBeg, iWant, &iGot, &pachBkTxt,
				&iOffset) == FALSE)
			{
			return;
			}

		pachBkTxt += iOffset;

		// Apply text to backscroll buffer

		if (iScrlInc < 0)
			{
			for (k=0 ; (i < 0)	&&	(k < iGot) ; ++i, ++k)
				{
				pachTxt = hhTerm->fplpstrBkTxt[l];

				for (j = 0 ; j < MAX_EMUCOLS && *pachBkTxt != ETEXT('\n') ; ++j)
					{
					assert(*pachBkTxt);
					*pachTxt++ = *pachBkTxt++;
					}

				for ( ; j < MAX_EMUCOLS ; ++j)
					*pachTxt++ = ' ';

				pachBkTxt += 1;  // Blow past newline marker...

				if (++l >= hhTerm->iPhysicalBkRows)
					l = 0;
				}
			}

		else
			{
			for (k=0 ; (i < iScrlInc)  &&  (k < iGot) ; ++i, ++k)
				{
				pachTxt = hhTerm->fplpstrBkTxt[hhTerm->iNextBkLn];

				for (j = 0 ; j < MAX_EMUCOLS && *pachBkTxt != ETEXT('\n') ; ++j)
					{
					assert(*pachBkTxt != ETEXT('\0'));
					*pachTxt++ = *pachBkTxt++;
					}

				for ( ; j < MAX_EMUCOLS ; ++j)
					*pachTxt++ = ETEXT(' ');

				if (++hhTerm->iNextBkLn >= hhTerm->iPhysicalBkRows)
					hhTerm->iNextBkLn = 0;

				pachBkTxt += 1;  // Blow past newline marker...
				}
			}
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termFillBk
 *
 * DESCRIPTION:
 *	This routine fills an entire local (refering a view) backscroll buffer.
 *	It is called only three times.	Whenever the transistion is made from
 *	active backscrolling to static backscrolling.  When the Scroll
 *	increment during a static backscroll operation is greater than the size
 *	of the view (and therefore the number of lines in the backscroll buffer
 *	as denoted by hhTerm->iPhysicalBkRows).  And when the terminal window
 *	is resized.
 *
 * ARGUMENTS:
 *	HHTERM		hhTerm			-- internal terminal handle
 *	int 		iTermHite		-- # of rows that will fit on current terminal
 *	int 		iBkPos			-- where to start in backscroll
 *
 * RETURNS:
 *	void
 *
 */
void termFillBk(const HHTERM hhTerm, const int iBkPos)
	{
	int 			i, j;
	int 			iWant,
					iGot,
					yBeg;
	int 			iOffset;
	ECHAR		   **fplpstrBkTxt,
					*pachTxt,		// terminal buffer
					*pachBkTxt;		//
	const HBACKSCRL hBackscrl = sessQueryBackscrlHdl(hhTerm->hSession);

	if (hhTerm->iTermHite > hhTerm->iMaxPhysicalBkRows)
		{
		if (termReallocBkBuf(hhTerm, hhTerm->iTermHite) != 0)
			{
			assert(FALSE);
			return;
			}
		}

	/* --- Empty the rest of terminal's backscroll buffer --- */

	for (i = 0 ; i < hhTerm->iPhysicalBkRows ; ++i)
		ECHAR_Fill(hhTerm->fplpstrBkTxt[i], EMU_BLANK_CHAR, MAX_EMUCOLS);

	/* --- Grab whatever we can from the engine's backscroll buffer --- */

	hhTerm->iPhysicalBkRows = hhTerm->iTermHite;
	hhTerm->iNextBkLn = 0;

    // mrw: 2/29/96 - moved the check for an empty buffer to past where 
    // the iPhyscialRows gets set.
    //
	if (hhTerm->iBkLines == 0)
		return;

	//*yBeg = iBkPos;
	yBeg = max(-hhTerm->iBkLines, iBkPos);
	iWant = min(hhTerm->iTermHite, abs(yBeg));
	fplpstrBkTxt = hhTerm->fplpstrBkTxt + (hhTerm->iTermHite - iWant);

	for (iGot=0 ; iWant > 0 ; iWant-=iGot, yBeg+=iGot)
		{
		if (backscrlGetBkLines(hBackscrl, yBeg, iWant, &iGot, &pachBkTxt,
				&iOffset) == FALSE)
			{
			return;
			}

		pachBkTxt += iOffset;

		for (i = 0 ; i < iGot ; ++i, ++fplpstrBkTxt)
			{
			pachTxt = *fplpstrBkTxt;

			for (j = 0 ; j < MAX_EMUCOLS && *pachBkTxt != ETEXT('\n') ; ++j)
				{
				assert(*pachBkTxt);
				*pachTxt++ = *pachBkTxt++;
				}

			for ( ; j < MAX_EMUCOLS ; ++j)
				*pachTxt++ = ETEXT(' ');

			pachBkTxt += 1;
			}
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termReallocBkBuf
 *
 * DESCRIPTION:
 *	This happens when the user changes to a smaller font which allows more
 *	rows on the screen.
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle
 *	iLines	- number of lines to realloc
 *
 * RETURNS:
 *	0=OK, 1=error
 *
 */
static int termReallocBkBuf(const HHTERM hhTerm, const int iLines)
	{
	int     i;
	ECHAR** pTempfplpstrBkTxt = NULL;

	if (iLines < hhTerm->iMaxPhysicalBkRows)
		{
		return 0;
		}

	pTempfplpstrBkTxt =
		(ECHAR**)realloc(hhTerm->fplpstrBkTxt,
						(unsigned int)iLines * sizeof(ECHAR *));

	if (pTempfplpstrBkTxt == NULL)
		{
		return 1;
		}
	else
		{
		hhTerm->fplpstrBkTxt = pTempfplpstrBkTxt;
		}

	for (i = hhTerm->iMaxPhysicalBkRows ; i < iLines ; ++i)
		{
		if ((hhTerm->fplpstrBkTxt[i] = malloc(MAX_EMUCOLS * sizeof(ECHAR)))
				== 0)
			{
			assert(FALSE);
			return 1;
			}

		ECHAR_Fill(hhTerm->fplpstrBkTxt[i], EMU_BLANK_CHAR, MAX_EMUCOLS);
		}

	hhTerm->iMaxPhysicalBkRows = iLines;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\term.hh ===
/*	File: D:\WACKER\tdll\term.hh (Created: 07-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 3/26/02 8:41a $
 */

/* --- Macros --- */

#define MAX_EMUCOLORS	16
#define BEZEL_SIZE		13
#define OUTDENT 		3

// MARK_XOR and MARK_ABS used to tell MarkText() to mark text in terminal
// window image buffer.

#define MARK_XOR	1
#define MARK_ABS	2

/* --- Private Messages --- */

#define WM_TERM_SCRLMARK	WM_USER+0x200
#define WM_TERM_KLUDGE_FONT WM_USER+0x201

/* --- Data Structures --- */

typedef struct stTerm *HHTERM;

struct stTerm
	{
	ECHAR	   **fplpstrTxt; 		// Text buffer
	PSTATTR    *fppstAttr;			// array of pointers to attribute structs.
	BYTE		abBlink[MAX_EMUROWS]; // array of chars used to check blinking

	int 		iTopline;			// top line of text buffer.

	int 		iRows,				// number of rows
				iCols;				// number of columns

	HBRUSH		hbrushBackScrl, 	// color of backscroll region.
				hbrushDivider,		// color of divider bar.
				hbrushTerminal, 	// emulator's clear attribute.
				hbrushHighlight,	// highlight brush
				hbrushBackHatch,	// backscroll hatched brush
				hbrushTermHatch;	// terminal hatched brush

	COLORREF	crBackScrl, 		// RGB background color of backscroll.
				crBackScrlTxt,		// RGB text color of backscroll.
				crTerm; 			// RGB terminal background (clear attr).

	HPEN		hBlackPen,			// Pen used to draw bezel border
				hWhitePen,			// Pen used to draw bezel highlight
				hDkGrayPen, 		// Pen used to draw bezel face
				hLtGrayPen; 		// Pen used to draw bezel shadow

	HWND		hwnd,				// terminal window handle.
				hwndSession;		// session window handle.
	HSESSION	hSession;			// session handle.

	HFONT		hFont,				// terminal font
				hDblHiFont, 		// double high
				hDblWiFont, 		// double wide
				hDblHiWiFont;		// double high wide

	HFONT		hSymFont,			// symbol terminal font
				hSymDblHiFont,		// symbol double high
				hSymDblWiFont,		// symbol double wide
				hSymDblHiWiFont;	// symbol double high wide

	LOGFONT 	lf, 				// terminal logfont structure
				lfSys,				// logfont read from system file
				lfHold; 			// for kludge font

	int 		xChar,				// width of font
				yChar,				// height of font
				cx, 				// width of client area
				cy, 				// height of client area
				iTermHite,			// terminal height expressed as rows
				iEvenFont;			// Flag indicating we have an even pixeled font

	int 		iBlink, 			// state of blink (-1=on,0=disabled,1=off)
				fBlink, 			// true if blinking host cursor set
				fFocus, 			// true if we have the focus
				fBump,				// used to position vertical thumb
				fCapture,			// mouse captured
				fHstCurOn,			// host cursor
				fSelectByWord,		// selecting text by word
				fScrolled,			// scrolling routines set this.
				iBtnOne,			// what a dbl clk button one does
				fLclCurOn,			// marking cursor
				fCursorsLinked, 	// cursors are the same
				fCursorTracking,	// terminal view tracks to cursor
				fMarkingLock,		// true if we've marked text
				fExtSelect, 		// true if extended text selection on
				fBackscrlLock,		// true if only backscroll visible
				fItalic;			// true if font is italic

	unsigned	uBlinkRate; 		// blink rate set on handle creation

	const COLORREF *pacrEmuColors;	// pointer array to emulator colors

	int 		iVScrlMin,			// scrollbar control variables
				iVScrlMax,
				iVScrlPos,
				iHScrlMin,
				iHScrlMax,
				iHScrlPos;

	int 		xBezel, 			// size of bezel in pixels
				xIndent,			// amount in pixels to indent from bezel
				yBrushOrg;			// brush orign used for hatchbrush

	POINT		ptHstCur,			// host cursor coordinates
				ptLclCur,			// local (marking) cursor coordinates
				ptBeg,				// beginning of marked region
				ptEnd;				// end of marked region

	int 		iCurType;			// Type of cursor defined in emu\emu.h
	int 		iHstCurSiz; 		// Vertical size of host cursor

	HTIMER		hCursorTimer,		// timer for blinking terminal cursor
				hMarkingTimer;		// used for scroll marking

	HUPDATE 	hUpdate;			// copy of info from termGetUpdate()

	TCHAR		underscores[MAX_EMUCOLS];	// used to do underlining

	/* --- Stuff from Client-side backscroll handle ---*/

	ECHAR	   **fplpstrBkTxt;		// bckscrl text buffer
	int 		iPhysicalBkRows,	// # of physical rows used by the buffer
				iMaxPhysicalBkRows, // Max size of buffer based on font.
				iNextBkLn,			// next line to receive text in buffer
				iBkLines;			// used in TP_WM_SIZE()
	};

/* --- Function prototypes --- */

/* --- termproc.c --- */

LRESULT CALLBACK TermProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);

void TP_WM_SIZE(const HWND hwnd,
				const unsigned fwSizeType,
				const int iWidth,
				const int iHite);

/* --- termhdl.c --- */

HHTERM CreateTerminalHdl(const HWND hwndTerm);
void DestroyTerminalHdl(const HHTERM hhTerm);
BOOL termSysColorChng(const HHTERM hhTerm);

void termSetClrAttr(const HHTERM hhTerm);
BOOL termSetFont(const HHTERM hhTerm, const PLOGFONT plf);

HFONT termMakeFont(const HHTERM hhTerm, const BOOL fUnderline,
				   const BOOL fHigh, const BOOL fWide, const BOOL fSymbol);

/* --- termcpy.c --- */

int strlentrunc(const ECHAR *pach, const int iLen);

/* --- termmos.c --- */

void TP_WM_LBTNDN(const HWND hwnd, const unsigned uFlags, const int xPos, const int yPos);
void TP_WM_MOUSEMOVE(const HWND hwnd, const unsigned uFlags, const int xPos, const int yPos);
void TP_WM_LBTNUP(const HWND hwnd, const unsigned uFlags, const int xPos, const int yPos);
void TP_WM_LBTNDBLCLK(const HWND hwnd, const unsigned uFlags, const int xPos, const int yPos);

/* --- termcur.c --- */

void ShowCursors(const HHTERM hhTerm);
void HideCursors(const HHTERM hhTerm);
void PaintHostCursor(const HHTERM hhTerm, const BOOL fOn, const HDC hdc);
void PaintLocalCursor(const HHTERM hhTerm, const BOOL fOn, const HDC hdc);
void CALLBACK CursorTimerProc(void *pvhwnd, long ltime);
void LinkCursors(const HHTERM hhTerm);
void SetLclCurPos(const HHTERM hhTerm, const LPPOINT lpptCur);

void MoveSelectionCursor(const HHTERM hhTerm,
						 const HWND hwnd,
							   int	x,
							   int	y,
							   BOOL fMarking);

/* --- termutil.c --- */

BOOL termTranslateKey(const HHTERM hhTerm, const HWND hwnd, const KEY_T Key);
void BlinkText(const HHTERM hhTerm);
void termQuerySnapRect(const HHTERM hhTerm, LPRECT prc);

void UnmarkText(const HHTERM hhTerm);
void MarkTextAll(HHTERM hhTerm);
void TestForMarkingLock(const HHTERM hhTerm);
void CALLBACK MarkingTimerProc(void *pvhWnd, long lTime);

void MarkText(const HHTERM	   hhTerm,
			  const LPPOINT    ptBeg,
			  const LPPOINT    ptEnd,
			  const BOOL	   fMark,
			  const int 	   sMarkingMethod);

BOOL PointInSelectionRange(const PPOINT ppt,
						   const PPOINT pptBeg,
						   const PPOINT pptEnd,
						   const int	iCols);

#define	VP_NO_ADJUSTMENT		0
#define	VP_ADJUST_RIGHT			1
#define	VP_ADJUST_LEFT			2

BOOL termValidatePosition(const HHTERM	hhTerm,
						  const int		nAdjustmentMode,
						  		POINT	*pLocation);


/* --- termupd.c --- */

void termGetUpdate(const HHTERM hhTerm, const int fRedraw);
void termGetBkLines(const HHTERM hhTerm, const int iScrlInc, int yBeg, int sType);
void termFillBk(const HHTERM hhTerm, const int iScrlPos);

/* --- termpnt.c --- */

void termPaint(const HHTERM hhTerm, const HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termproc.c ===
/*	File: D:\WACKER\tdll\termproc.c (Created: 06-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 8 $
 *	$Date: 5/29/02 2:17p $
 */

#include <windows.h>
#include <imm.h>
#pragma hdrstop
// #define	DEBUGSTR	1

#include "stdtyp.h"
#include "sf.h"
#include "sess_ids.h"
#include "assert.h"
#include "session.h"
#include "backscrl.h"
#include "timers.h"
#if defined(INCL_KEY_MACROS)
#include "keyutil.h"
#endif
#include "chars.h"
#include "cloop.h"
#include "misc.h"
#include <emu\emu.h>
#include "term.h"
#include "term.hh"

// When parsing values for mouse moves, scrolls, etc. HIWORD and LOWORD
// clip the sign extension since these are 16 bit values.  These macros
// cast the result to a short so that sign extension works correctly

#define LOSHORT(x)	((short)LOWORD(x))
#define HISHORT(x)	((short)HIWORD(x))

// HORZPAGESIZE represents the size in columns of one page horizontally.
// We need this for two reasons.  1) We need a page size so we know how far
// to skip when user "pages" horizontally using the scrollbar.	2) So we
// have a size to set for the thumb size.  Ten is arbritary but seems
// about right. - mrw

#define HORZPAGESIZE	10

/* --- static function prototypes ---*/

static void TP_WM_CREATE(const HWND hwnd);

static void TP_WM_CHAR(const HWND hwnd, const UINT message,
					   const WPARAM wPar, const LPARAM lPar);

static void TP_WM_IME_CHAR(const HWND hwnd, const UINT message,
					  		const WPARAM wPar, const LPARAM lPar);

static int kabExpandMacroKey( const HSESSION hSession, KEY_T aKey );
static void TP_WM_TERM_KEY(const HWND hwnd, KEY_T Key);
static void TP_WM_SETFOCUS(const HWND hwnd);
static void TP_WM_KILLFOCUS(const HWND hwnd);
static void TP_WM_VSCROLL(HWND hwnd, int nCode, int nPos, HWND hwndScrl);
static void TP_WM_HSCROLL(HWND hwnd, int nCode, int nPos, HWND hwndScrl);
static void TP_WM_TERM_TRACK(const HHTERM hhTerm, const int fForce);
static void TP_WM_EMU_SETTINGS(const HHTERM hhTerm);
static int TP_WM_TERM_LOAD_SETTINGS(const HHTERM hhTerm);
static int TP_WM_TERM_SAVE_SETTINGS(const HHTERM hhTerm);
static void TP_WM_TERM_FORCE_WMSIZE(const HHTERM hhTerm);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TermProc
 *
 * DESCRIPTION:
 *	Terminal window
 *
 * ARGUMENTS:
 *	Standard CALLBACK args
 *
 * RETURNS:
 *	Standard CALLBACK codes
 *
 */
LRESULT CALLBACK TermProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	HHTERM hhTerm;

	switch (uMsg)
		{
		case WM_HELP:
			// We do not want start the help engine due to F1 when function
			// keys are being interpreted as terminal keys
			// (NOT Windows keys). JRJ 12/94
			//
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

			if(emuIsEmuKey(sessQueryEmuHdl(hhTerm->hSession),
					VIRTUAL_KEY | VK_F1))
				{
		    	return 0;
				}

			break;

		case WM_CREATE:
			TP_WM_CREATE(hwnd);
			return 0;

		case WM_SIZE:
			TP_WM_SIZE(hwnd, (unsigned)wPar, LOSHORT(lPar), HISHORT(lPar));
			return 0;

		case WM_IME_CHAR:
			TP_WM_IME_CHAR(hwnd, uMsg, wPar, lPar);
			return 0;

		case WM_KEYDOWN:
		case WM_CHAR:
			TP_WM_CHAR(hwnd, uMsg, wPar, lPar);
			return 0;

		case WM_PAINT:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termPaint(hhTerm, hwnd);
			return 0;

		case WM_SYSCOLORCHANGE:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termSysColorChng(hhTerm);
			return 0;

		case WM_SETFOCUS:
			TP_WM_SETFOCUS(hwnd);
			return 0;

		case WM_KILLFOCUS:
			TP_WM_KILLFOCUS(hwnd);
			return 0;

		case WM_VSCROLL:
			TP_WM_VSCROLL(hwnd, LOWORD(wPar), HISHORT(wPar), (HWND)lPar);
			return 0;

		case WM_HSCROLL:
			TP_WM_HSCROLL(hwnd, LOWORD(wPar), HISHORT(wPar), (HWND)lPar);
			return 0;

		case WM_LBUTTONDOWN:
			TP_WM_LBTNDN(hwnd, (unsigned)wPar, LOSHORT(lPar), HISHORT(lPar));
			return 0;

		case WM_MOUSEMOVE:
			TP_WM_MOUSEMOVE(hwnd, (unsigned)wPar, LOSHORT(lPar), HISHORT(lPar));
			return 0;

		case WM_LBUTTONUP:
			TP_WM_LBTNUP(hwnd, (unsigned)wPar, LOSHORT(lPar), HISHORT(lPar));
			return 0;

		case WM_LBUTTONDBLCLK:
			TP_WM_LBTNDBLCLK(hwnd, (unsigned)wPar, LOSHORT(lPar), HISHORT(lPar));
			return 0;

		case WM_DESTROY:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			DestroyTerminalHdl(hhTerm);
			hhTerm = NULL;
			return 0;

		/* --- Public terminal messages --- */

		case WM_TERM_GETUPDATE:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termGetUpdate(hhTerm, TRUE);
			return 0;

		case WM_TERM_BEZEL:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			hhTerm->xBezel = (hhTerm->xBezel) ? 0 : BEZEL_SIZE;

			// Need to recompute scrollbar min's and max's since the
			// presence/absence of the bezel affects these items.  This
			// is done in the WM_SIZE handler and can be called directly
			// with the current client size.

			TP_WM_SIZE(hwnd, SIZE_RESTORED, hhTerm->cx, hhTerm->cy);
			InvalidateRect(hwnd, 0, FALSE);
			return 0;

		case WM_TERM_Q_BEZEL:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			return hhTerm->xBezel;

		case WM_TERM_Q_SNAP:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termQuerySnapRect(hhTerm, (LPRECT)lPar);
			return 0;

		case WM_TERM_KEY:
			TP_WM_TERM_KEY(hwnd, (unsigned)wPar);
			return 0;

        case WM_TERM_CLRATTR:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termSetClrAttr(hhTerm);
			return 0;

		case WM_TERM_GETLOGFONT:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			*(PLOGFONT)lPar = hhTerm->lf;
			return 0;

		case WM_TERM_SETLOGFONT:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termSetFont(hhTerm, (PLOGFONT)lPar);
			return 0;

		case WM_TERM_Q_MARKED:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			return hhTerm->fMarkingLock;

		case WM_TERM_UNMARK:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			LinkCursors(hhTerm);
			return 0;

		case WM_TERM_MARK_ALL:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			MarkTextAll(hhTerm);
			return 0;

		case WM_TERM_TRACK:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			TP_WM_TERM_TRACK(hhTerm, (int)wPar);
			return 0;

		case WM_TERM_EMU_SETTINGS:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			TP_WM_EMU_SETTINGS(hhTerm);
			return 0;

		case WM_TERM_Q_MARKED_RANGE:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			*(PPOINT)wPar = hhTerm->ptBeg;
			*(PPOINT)lPar = hhTerm->ptEnd;
			return 0;
			
		case WM_TERM_LOAD_SETTINGS:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			TP_WM_TERM_LOAD_SETTINGS(hhTerm);
			return 0;
			
		case WM_TERM_SAVE_SETTINGS:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			TP_WM_TERM_SAVE_SETTINGS(hhTerm);
			return 0;

		case WM_TERM_FORCE_WMSIZE:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			TP_WM_TERM_FORCE_WMSIZE(hhTerm);
			return 0;
		
		/* --- Private terminal messages --- */

		case WM_TERM_SCRLMARK:
			MarkingTimerProc((void *)hwnd, 0);
			return 0;

		case WM_TERM_KLUDGE_FONT:
			hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
			termSetFont(hhTerm, &hhTerm->lfHold);
			RefreshTermWindow(hwnd);
			return 0;

		default:
			break;
		}

	return DefWindowProc(hwnd, uMsg, wPar, lPar);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_CREATE
 *
 * DESCRIPTION:
 *	Create message processor for terminal window.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_CREATE(const HWND hwnd)
	{
	HHTERM hhTerm;
	SCROLLINFO scrinf;
#if(WINVER >= 0x0500)
	LONG_PTR ExStyle;

	ExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
	//
	// [mhamid] If it is mirrored then turn off mirroing.
	//
	if (ExStyle & WS_EX_LAYOUTRTL)
		{
		SetWindowLongPtr(hwnd, GWL_EXSTYLE, (LONG_PTR)(ExStyle & ~WS_EX_LAYOUTRTL));
		}
#endif // WINVER >= 0x0500

	// Create an internal handle for instance data storage.

	hhTerm = CreateTerminalHdl(hwnd);

	// Need to set this even if hTerm is 0 so WM_DESTROY works.

	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)hhTerm);

	if (hhTerm == 0)
		{
		assert(FALSE);
		ExitProcess(1);
		}

	scrinf.cbSize = sizeof(scrinf);
	scrinf.fMask = SIF_DISABLENOSCROLL;
	SetScrollInfo(hwnd, SB_VERT, &scrinf, 0);
	return;
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_CMD
 *
 * DESCRIPTION:
 *	WM_COMMAND processor for TermProc()
 *
 * ARGUMENTS:
 *	hwnd		- terminal window handle
 *	nId 		- item, control, or accelerator identifier
 *	nNotify 	- notification code
 *	hwndCtrl	- handle of control
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_CMD(const HWND hwnd, const int nId, const int nNotify,
					  const HWND hwndCtrl)
	{
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch (nId)
		{
		case WM_USER:
			break;
		}

	return;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_SIZE
 *
 * DESCRIPTION:
 *	WM_SIZE message processor for termproc.  If iWidth and iHite are zero,
 *	then the window sizes itself to fit the session window accounting for
 *	statusbars and toolbars.
 *
 * ARGUMENTS:
 *	hwnd		- terminal window
 *	fwSizeType	- from WM_SIZE
 *	iWidth		- width of window
 *	iHite		- hite of window
 *
 * RETURNS:
 *	void
 *
 */
void TP_WM_SIZE(const HWND hwnd,
				const unsigned fwSizeType,
				const int iWidth,
				const int iHite)
	{
	RECT rc, rcTmp;
	int i, j, k;
	SCROLLINFO scrinf;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	const HWND hwndToolbar = sessQueryHwndToolbar(hhTerm->hSession);
	const HWND hwndStatusbar = sessQueryHwndStatusbar(hhTerm->hSession);
	const HWND hwndSidebar = sessQuerySidebarHwnd(hhTerm->hSession);

	// If the window is hidden, we really don't need to do anything.

	if (!IsWindowVisible(hwnd))
		return;

	// If we get a message with 0, 0 for width, hite, make terminal window
	// fit the session window less the toolbar and statusbar if present.

	if (iWidth == 0 && iHite == 0)
		{
		GetClientRect(hhTerm->hwndSession, &rc);

		// Note: See if we can use sessQuery funcs for
		// this
		if (IsWindow(hwndToolbar) && IsWindowVisible(hwndToolbar))
			{
			GetWindowRect(hwndToolbar, &rcTmp);
			rc.top += (rcTmp.bottom - rcTmp.top);
			}

		if (IsWindow(hwndStatusbar) && IsWindowVisible(hwndStatusbar))
			{
			GetWindowRect(hwndStatusbar, &rcTmp);
			rc.bottom -= (rcTmp.bottom - rcTmp.top);
			rc.bottom += 2 * GetSystemMetrics(SM_CYBORDER);
			}

		if (IsWindow(hwndSidebar) && IsWindowVisible(hwndSidebar))
			{
			GetWindowRect(hwndSidebar, &rcTmp);
			rc.left += (rcTmp.right - rcTmp.left);
			}

		MoveWindow(hwnd, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
			TRUE);
		}

	// Compute size related items.

	else
		{
		hhTerm->cx = iWidth;
		hhTerm->cy = iHite;

		// Set Min's and Max's now.

		i = hhTerm->iTermHite;	// save old height for bottom line alignment
		hhTerm->iTermHite = hhTerm->cy / hhTerm->yChar;

		// If bezel is drawn, make sure we have room

		j = 0;

		if (hhTerm->xBezel)
			{
			if ((hhTerm->cy % hhTerm->yChar) < (hhTerm->xBezel + 1))
				j = 1;
			}

		hhTerm->iVScrlMin = min(-hhTerm->iBkLines,
			hhTerm->iRows - hhTerm->iTermHite + 1 + j);

		// Little hack here to make sure that if we were at the bottom
		// we show the bottom.

		k = (hhTerm->iVScrlMax == hhTerm->iVScrlPos);

		hhTerm->iVScrlMax = max(hhTerm->iVScrlMin, hhTerm->iRows + 1 + j
								- hhTerm->iTermHite);

		// First time through set to bottom

		if (k)
			hhTerm->iVScrlPos = hhTerm->iVScrlMax;

		else
			hhTerm->iVScrlPos -= hhTerm->iTermHite - i;

		hhTerm->iVScrlPos = max(hhTerm->iVScrlPos, hhTerm->iVScrlMin);
		hhTerm->iVScrlPos = min(hhTerm->iVScrlPos, hhTerm->iVScrlMax);

		// hhTerm->iHScrlMax = #Cols - #Cols Showing
		hhTerm->iHScrlMax = max(0, hhTerm->iCols -
			((hhTerm->cx - hhTerm->xIndent - (2 * hhTerm->xBezel))
				/ hhTerm->xChar));

		hhTerm->iHScrlPos = min(hhTerm->iHScrlPos, hhTerm->iHScrlMax);

		// Check to see if we scrolled entirely into backscroll
		// region.	If so, set fBackscrlLock for this view.  And refill
		// its backscroll buffer (important).

		if ((hhTerm->iVScrlPos + hhTerm->iTermHite) <= 0)
			{
			hhTerm->fBackscrlLock = TRUE;
			termFillBk(hhTerm, hhTerm->iVScrlPos);
			}

		else
			{
			hhTerm->fBackscrlLock = FALSE;
			termFillBk(hhTerm, -hhTerm->iTermHite);
			}

		/* --- Vertical scroll bar --- */

		scrinf.cbSize= sizeof(scrinf);
		scrinf.fMask = SIF_DISABLENOSCROLL | SIF_PAGE | SIF_POS | SIF_RANGE;
		scrinf.nMin  = hhTerm->iVScrlMin;
		scrinf.nMax  = hhTerm->iVScrlMax + hhTerm->iTermHite - 1;
		scrinf.nPos  = hhTerm->iVScrlPos;
		scrinf.nPage = hhTerm->iTermHite;

		SetScrollInfo(hwnd, SB_VERT, &scrinf, TRUE);

		/* --- Horizontal scroll bar --- */

		i = hhTerm->iHScrlMax - hhTerm->iHScrlMin;
		scrinf.cbSize= sizeof(scrinf);
		scrinf.fMask = SIF_PAGE | SIF_POS | SIF_RANGE;
		scrinf.nMin  = hhTerm->iHScrlMin;
		scrinf.nMax  = hhTerm->iHScrlMax + HORZPAGESIZE - 1;
		scrinf.nPos  = hhTerm->iHScrlPos;
		scrinf.nPage = HORZPAGESIZE;

		SetScrollInfo(hwnd, SB_HORZ, &scrinf, TRUE);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_SETFOCUS
 *
 * DESCRIPTION:
 *	Handler for WM_SETFOCUS message
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle.
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_SETFOCUS(const HWND hwnd)
	{
	int i;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	hhTerm->fFocus = TRUE;

	// Use Multiplexer timer for cursor and blinking text.

	if (!hhTerm->hCursorTimer)
		{
		i = TimerCreate(hhTerm->hSession,
			            &hhTerm->hCursorTimer,
						(long)hhTerm->uBlinkRate,
						CursorTimerProc,
						(void *)hwnd);

		if (i != TIMER_OK)
			assert(FALSE);
		}

	ShowCursors(hhTerm);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_KILLFOCUS
 *
 * DESCRIPTION:
 *	Handler for WM_KILLFOCUS message.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle.
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_KILLFOCUS(const HWND hwnd)
	{
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	hhTerm->fFocus = FALSE;

	if (hhTerm->hCursorTimer)
		{
		TimerDestroy(&hhTerm->hCursorTimer);
		}

	HideCursors(hhTerm);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_VSCROLL
 *
 * DESCRIPTION:
 *	Message handler for terminal window's WM_VSCROLL
 *
 * ARGUMENTS:
 *	hwnd		- terminal window handle
 *	nCode		- scrollbar value
 *	nPos		- scrollbox pos
 *	hwndScrl	- window handle of scrollbar
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_VSCROLL(HWND hwnd, int nCode, int nPos, HWND hwndScrl)
	{
	int i;
	int iScrlInc;
	RECT rc;
	SCROLLINFO scrinf;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch (nCode)
		{
		case SB_TOP:
			iScrlInc = -(hhTerm->iVScrlPos - hhTerm->iVScrlMin);
			break;

		case SB_BOTTOM:
			iScrlInc = hhTerm->iVScrlMax - hhTerm->iVScrlPos;
			break;

		case SB_LINEUP:
			iScrlInc = -1;
			break;

		case SB_LINEDOWN:
			iScrlInc = 1;
			break;

		case SB_PAGEUP:
			iScrlInc = min(-1, -hhTerm->iTermHite);
			break;

		case SB_PAGEDOWN:
			iScrlInc = max(1, hhTerm->iTermHite);
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			iScrlInc = nPos - hhTerm->iVScrlPos;
			break;

		default:
			iScrlInc = 0;
			break;
		}

	if ((iScrlInc = max(-(hhTerm->iVScrlPos - hhTerm->iVScrlMin),
			min(iScrlInc, hhTerm->iVScrlMax - hhTerm->iVScrlPos))) != 0)
		{
		HideCursors(hhTerm);
		hhTerm->iVScrlPos += iScrlInc;

		GetClientRect(hwnd, &rc);
		i = rc.bottom;
		rc.bottom = hhTerm->iTermHite * hhTerm->yChar;

		hhTerm->yBrushOrg = (hhTerm->yBrushOrg +
			(-hhTerm->yChar * iScrlInc)) % 8;

		ScrollWindow(hwnd, 0, -hhTerm->yChar * iScrlInc, 0, &rc);
		scrinf.cbSize = sizeof(scrinf);
		scrinf.fMask = SIF_DISABLENOSCROLL | SIF_POS;
		scrinf.nPos = hhTerm->iVScrlPos;
		SetScrollInfo(hwnd, SB_VERT, &scrinf, TRUE);

		hhTerm->fScrolled = TRUE;

		// Check to see if we scrolled entirely into backscroll
		// region.	If so, set fBackscrlLock for this view.

		if ((hhTerm->iVScrlPos + hhTerm->iTermHite) <= 0)
			{
			if (hhTerm->fBackscrlLock == FALSE)
				termFillBk(hhTerm, hhTerm->iVScrlPos);

			else
				termGetBkLines(hhTerm, iScrlInc, hhTerm->iVScrlPos, BKPOS_THUMBPOS);

			hhTerm->fBackscrlLock = TRUE;
			}

		else
			{
			if (hhTerm->fBackscrlLock == TRUE)
				termFillBk(hhTerm, -hhTerm->iTermHite);

			hhTerm->fBackscrlLock = FALSE;
			}

		// Make two seperate calls to WM_PAINT to optimize screen
		// updates in the case of a negative scroll operation.

		if (iScrlInc < 0)
			UpdateWindow(hwnd);

		// Fill-in fractional part of line at bottom of terminal
		// screen with appropriate color by invalidating that region.

		if (i > rc.bottom)
			{
			rc.top = rc.bottom;
			rc.bottom = i;
			InvalidateRect(hwnd, &rc, FALSE);
			}

		UpdateWindow(hwnd);
		ShowCursors(hhTerm);

		#if 0  // debugging stuff...
			{
			char ach[50];
			wsprintf(ach, "pos=%d min=%d max=%d", hhTerm->iVScrlPos,
				hhTerm->iVScrlMin, hhTerm->iVScrlMax);
			SetWindowText(sessQueryHwndStatusbar(hhTerm->hSession), ach);
			}
		#endif
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_HSCROLL
 *
 * DESCRIPTION:
 *	Message handler for terminal window's WM_HSCROLL
 *
 * ARGUMENTS:
 *	hwnd		- terminal window handle
 *	nCode		- scrollbar value
 *	nPos		- scrollbox pos
 *	hwndScrl	- window handle of scrollbar
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_HSCROLL(HWND hwnd, int nCode, int nPos, HWND hwndScrl)
	{
	int i, j, k;
	int iScrlInc;
	RECT rc;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch (nCode)
		{
		case SB_LINEUP:
			iScrlInc = -1;
			break;

		case SB_LINEDOWN:
			iScrlInc = 1;
			break;

		case SB_PAGEUP:
			iScrlInc = -HORZPAGESIZE;
			break;

		case SB_PAGEDOWN:
			iScrlInc = HORZPAGESIZE;
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			iScrlInc = nPos - hhTerm->iHScrlPos;
			break;

		default:
			iScrlInc = 0;
			break;
		}

	if ((iScrlInc = max(-hhTerm->iHScrlPos,
			min(iScrlInc, hhTerm->iHScrlMax - hhTerm->iHScrlPos))) != 0)
		{
		HideCursors(hhTerm);
		i = -hhTerm->xChar * iScrlInc;
		j = 0;

		hhTerm->iHScrlPos += iScrlInc;
		GetClientRect(hwnd, &rc);
		rc.left += hhTerm->xIndent;

		// We have to adjust for the bezel when it is visible
		if (hhTerm->xBezel &&
				(hhTerm->iHScrlPos == 0 ||
				(hhTerm->iHScrlPos - iScrlInc) == 0)   ||
				 hhTerm->iHScrlPos == hhTerm->iHScrlMax ||
				(hhTerm->iHScrlPos - iScrlInc == hhTerm->iHScrlMax))
			{
			k = hhTerm->xBezel - hhTerm->xChar;
			i += (iScrlInc > 0) ? -k : k;
			j = 1;	// set for test below
			}

		ScrollWindow(hwnd, i, 0, 0, &rc);
		SetScrollPos(hwnd, SB_HORZ, hhTerm->iHScrlPos, TRUE);


#if defined(FAR_EAST)
	InvalidateRect(hwnd, NULL, FALSE);
#endif

		hhTerm->fScrolled = TRUE;

		if (j == 1)
			{
			GetUpdateRect(hwnd, &rc, FALSE);
			rc.left = 0;	// makes sure bezel is drawn.
			InvalidateRect(hwnd, &rc, FALSE);
			}

		UpdateWindow(hwnd);
		ShowCursors(hhTerm);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_CHAR
 *
 * DESCRIPTION:
 *	Processes the WM_CHAR and WM_KEYDOWN messages for termproc.
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *	message - WM_CHAR or WM_KEYDOWN
 *	wPar	- wParam
 *	lPar	- lParam
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_CHAR(const HWND hwnd, const UINT message,
					   const WPARAM wPar, const LPARAM lPar)
	{
	MSG msg;
	KEY_T Key;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

#if 0
    //
    // Removed this which caused problems with the OnScreen Keyboard (OSK)
    // in Whistler. REV: 01/12/2001
    //
    if (GetKeyState(VK_LBUTTON) < 0)
		return;
#endif

    //DbgOutStr("TP_WM_CHAR 0x%x 0x%x 0x%lx\r\n", message, wPar, lPar, 0,0);

	msg.hwnd	= hwnd;
	msg.message = message;
	msg.wParam	= wPar;
	msg.lParam	= lPar;

	Key = TranslateToKey(&msg);

	if (!termTranslateKey(hhTerm, hwnd, Key))
		{
		CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), &Key, 1, CLOOP_KEYS);
		LinkCursors(hhTerm);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_IME_CHAR
 *
 * DESCRIPTION:
 *	Processes the WM_IME_CHAR message for FE version of WACKER
 *
 * ARGUMENTS:
 *	hwnd	- terminal window handle
 *	message - WM_IME_CHAR
 *	wPar	- wParam
 *	lPar	- lParam
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_IME_CHAR(const HWND hwnd, const UINT message,
							const WPARAM wPar, const LPARAM lPar)
	{
	KEY_T ktCode1;
	KEY_T ktCode2;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    //DbgOutStr("TP_WM_IME_CHAR 0x%x 0x%x 0x%lx\r\n", message, wPar, lPar, 0,0);

	/*
	 * Later on, we may decide to create or modify something like the stuff
	 * that goes on in TP_WM_CHAR, but until we get a better understanding of
	 * how to process this stuff, just do it right here, in line, in all of
	 * its ugly experimental foolishness.
	 */
	ktCode1 = (KEY_T)(wPar & 0xFF);		    /* Lower eight bits */
	ktCode2 = (KEY_T)((wPar >> 8) & 0xFF);	/* Upper eight bits */

	/*
	 * The documentation says that the lower eight bits are the first char,
	 * but I am not too sure about that.  It looks like the upper eight bits
	 * is the lead byte and the lower eight bits is not.  Keep an eye on this.
	 */

	//mpt:2-7-98 apparently, the korean ime can send us single byte characters
	//           with 'null' as the other character, for some reason most host
	//           systems don't like it when we send that null out the port.
	if (ktCode2 != 0)
		CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), &ktCode2, 1, CLOOP_KEYS);

	if (ktCode1 != 0)
		CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), &ktCode1, 1, CLOOP_KEYS);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_TERM_KEY
 *
 * DESCRIPTION:
 *	Term keys are keys we know are going to be translated by the
 *	session macro or emulator sequence
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static void TP_WM_TERM_KEY(const HWND hwnd, KEY_T Key)
	{
	// Until we have a real macro key expander...
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (GetKeyState(VK_LBUTTON) < 0)
		return;

	if ( kabExpandMacroKey(hhTerm->hSession, Key) == 0)
        {
		CLoopSend(sessQueryCLoopHdl(hhTerm->hSession), &Key, 1, CLOOP_KEYS);
        }

	LinkCursors(hhTerm);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_TERM_TRACK
 *
 * DESCRIPTION:
 *	Causes terminal to track to the cursor position.  If wPar is
 *	0, then we track only if we are not backscroll-locked and not
 *	Mark-locked.  If wPar is not 0, then we force tracking,
 *	unmarking and unlocking the backscroll if necessary
 *
 * ARGUMENTS:
 *	hhTerm	- private term handle
 *	fForce	- force tracking no matter what.
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_TERM_TRACK(const HHTERM hhTerm, const int fForce)
	{
	int i, j;

	if ((hhTerm->fCursorTracking == 0 || hhTerm->fBackscrlLock != 0)
			&& fForce == 0)
		{
		return;
		}

	j = 0;

	// First track vertically

	if (hhTerm->ptHstCur.y < hhTerm->iVScrlPos)
		i = hhTerm->ptHstCur.y;

	else if ((hhTerm->ptHstCur.y - hhTerm->iTermHite + 2) > hhTerm->iVScrlPos)
		i = hhTerm->ptHstCur.y - hhTerm->iTermHite + 2;

	else
		i = hhTerm->iVScrlPos;

	if (i != hhTerm->iVScrlPos)
		{
		// If we have enough room to display the entire terminal
		// then go go to iVScrlMax

		if (hhTerm->iTermHite > hhTerm->iRows)
			i = hhTerm->iVScrlMax;

		SendMessage(hhTerm->hwnd, WM_VSCROLL, MAKEWPARAM(SB_THUMBPOSITION, i), 0);
		j = 1;
		}

	// Now check for horizontal placement and adjust to make cursor
	// visible.

	if (hhTerm->ptHstCur.x < hhTerm->iHScrlPos)
		{
		i = hhTerm->ptHstCur.x;
		}

	else if (hhTerm->ptHstCur.x >= hhTerm->iHScrlPos +
							hhTerm->iCols - hhTerm->iHScrlMax)
		{
		i = hhTerm->ptHstCur.x - (hhTerm->iCols - hhTerm->iHScrlMax) + 5;
		}

	else
		{
		i = hhTerm->iHScrlPos;
		}

	if (i != hhTerm->iHScrlPos)
		{
		SendMessage(hhTerm->hwnd, WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, i), 0);
		j = 1;
		}

	if (j)
		LinkCursors(hhTerm);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_EMU_SETTINGS
 *
 * DESCRIPTION:
 *	Something important in the emulator has changed (like loading a new
 *	emulator or changing the number of rows or columns).
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_EMU_SETTINGS(const HHTERM hhTerm)
	{
	int iRows, iCols;
	BOOL fChange = FALSE;
	int iCurType;
	STEMUSET stEmuUserSettings;

	const HEMU hEmu = sessQueryEmuHdl(hhTerm->hSession);

	/* --- Check rows and columns --- */

	emuQueryRowsCols(hEmu, &iRows, &iCols);

	if (iRows != hhTerm->iRows || iCols != hhTerm->iCols)
		{
		hhTerm->iRows = iRows;
		hhTerm->iCols = iCols;
		fChange = TRUE;
		}

	/* --- Query other emulator settings --- */

	iCurType = emuQueryCursorType(hEmu);

	emuQuerySettings(hEmu, &stEmuUserSettings);
	hhTerm->fBlink = stEmuUserSettings.fCursorBlink;

	/* --- Check cursor type --- */

	if (iCurType != hhTerm->iCurType)
		{
		fChange = TRUE;
		hhTerm->iCurType = iCurType;

		switch (hhTerm->iCurType)
			{
		case EMU_CURSOR_LINE:
		default:
			hhTerm->iHstCurSiz = GetSystemMetrics(SM_CYBORDER) * 2;
			break;

		case EMU_CURSOR_BLOCK:
			hhTerm->iHstCurSiz = hhTerm->yChar;
			break;

		case EMU_CURSOR_NONE:
			hhTerm->iHstCurSiz = 0;
			break;
			}
		}

	if (fChange)
		RefreshTermWindow(hhTerm->hwnd);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_TERM_LOAD_SETTINGS
 *
 * DESCRIPTION:
 *	Loads terminal settings from session file.
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle
 *
 * RETURNS:
 *	0=OK
 *
 */
static int TP_WM_TERM_LOAD_SETTINGS(const HHTERM hhTerm)
	{
	LONG lSize;

	if (hhTerm == 0)
		{
		assert(FALSE);
		return 1;
		}

	lSize = sizeof(hhTerm->lfSys);

	if (sfGetSessionItem(sessQuerySysFileHdl(hhTerm->hSession),
			SFID_TERM_LOGFONT, &lSize, &hhTerm->lfSys) == 0)
		{
		termSetFont(hhTerm, &hhTerm->lfSys);
		RefreshTermWindow(hhTerm->hwnd);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_TERM_SAVE_SETTINGS
 *
 * DESCRIPTION:
 *	Saves terminal settings to session file.
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle
 *
 * RETURNS:
 *	0=OK
 *
 */
static int TP_WM_TERM_SAVE_SETTINGS(const HHTERM hhTerm)
	{
	if (hhTerm == 0)
		{
		assert(FALSE);
		return 1;
		}

	if (memcmp(&hhTerm->lf, &hhTerm->lfSys, sizeof(hhTerm->lf)))
		{
		sfPutSessionItem(sessQuerySysFileHdl(hhTerm->hSession),
			SFID_TERM_LOGFONT, sizeof(hhTerm->lf), &hhTerm->lf);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TP_WM_TERM_FORCE_WMSIZE
 *
 * DESCRIPTION:
 *	Forces the terminal through its resize code to get things properly
 *	updated.  Used only when session is first initialized.
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
static void TP_WM_TERM_FORCE_WMSIZE(const HHTERM hhTerm)
	{
	RECT rc;

	if (!IsWindow(hhTerm->hwnd))
		return;

	hhTerm->iVScrlPos = hhTerm->iVScrlMax;
	hhTerm->iHScrlPos = 0;

	GetClientRect(hhTerm->hwnd, &rc);
	termGetUpdate(hhTerm, FALSE);
	TP_WM_SIZE(hhTerm->hwnd, 0, rc.right, rc.bottom);
	InvalidateRect(hhTerm->hwnd, 0, FALSE);
	return;
	}

//******************************************************************************
// Method:
//    kabExpandMacroKey
//
// Description:
//    Determines if the key is a macro key and if so expands the macro and send
//    the keys to the CLOOP
//
// Arguments:
//    hSession - Session handle
//    aKey     - The key to be expanded
//
// Returns:
//    non zero - if the key has been expanded, zero if the key is not a macro
//
// Throws:
//    None
//
// Author: Dwayne M. Newsome, 06/10/1998
//
//

static int kabExpandMacroKey( const HSESSION hSession, KEY_T aKey )
    {
    int lReturn = 0;

#if defined INCL_KEY_MACROS
    keyMacro lKeyMacro;
    int lKeyIndex = -1;
    int lIndex    = 0;

    lKeyMacro.keyName = aKey;
    lKeyIndex = keysFindMacro( &lKeyMacro );

    if ( lKeyIndex >= 0 )
        {
        keysGetMacro( lKeyIndex, &lKeyMacro );

		//
		// Replace the virtual return key with '\r' so that all the
		// line end processing works correctly. REV: 5/16/2002
		//
		for ( lIndex = 0; lIndex < lKeyMacro.macroLen; lIndex++ )
			{
			if ((VK_RETURN | VIRTUAL_KEY) == lKeyMacro.keyMacro[lIndex])
				{
				lKeyMacro.keyMacro[lIndex] = TEXT('\r');
				}
			}

        CLoopSend( sessQueryCLoopHdl(hSession), &lKeyMacro.keyMacro,
                   lKeyMacro.macroLen, CLOOP_KEYS );

        lReturn = 1;
        }
#endif

    return lReturn;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\termutil.c ===
/*	File: D:\WACKER\tdll\termutil.c (Created: 23-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 3/26/02 8:46a $
 */
#include <windows.h>
#pragma hdrstop

//#define	DEBUGSTR	1	

#include <stdlib.h>
#include <limits.h>

#include "stdtyp.h"
#include "session.h"
#include "assert.h"
#include "timers.h"
#include "chars.h"
#include <emu\emu.h>
#include "term.h"
#include "term.hh"
#include "statusbr.h"
#include <term\res.h>

static int InMiddleofWideChar(ECHAR *pszRow, int iCol);
//
// The following function is from code mofified slightly
// from MSDN for determining if you are currently running as a
// remote session (Terminal Service). REV: 10/03/2001
//
BOOL ValidateProductSuite ( LPSTR SuiteName );

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termQuerySnapRect
 *
 * DESCRIPTION:
 *	Returns the minimum rectangle that will encompass a full terminal.
 *
 * ARGUMENTS:
 *	hhTerm	- internal terminal handle.
 *	prc 	- pointer to rect
 *
 * RETURNS:
 *	void
 *
 */
void termQuerySnapRect(const HHTERM hhTerm, LPRECT prc)
	{
	prc->left = prc->top = 0;

	prc->right = (hhTerm->iCols * hhTerm->xChar) +
		(2 * (hhTerm->xIndent + hhTerm->xBezel)) +
			(2 * GetSystemMetrics(SM_CXEDGE)) +
				GetSystemMetrics(SM_CXVSCROLL);

	prc->bottom = ((hhTerm->iRows + 2) * hhTerm->yChar) +
		(2 * GetSystemMetrics(SM_CYEDGE));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MarkText
 *
 * DESCRIPTION:
 *	Work horse routine that marks and unmarks text on the terminal screen.
 *	It has two methods for marking, ABSOLUTE and XOR.  ABSOLUTE sets the
 *	range of cells given by ptBeg and ptEnd to the given setting (fMark)
 *	while XOR will perform an exclusive or on the cell range.  ABSOLUTE
 *	is used to unmark cells mostly.
 *
 * ARGUMENTS:
 *	HTERM	hTerm	- handle to a terminal
 *	LPPOINT ptBeg	- one end of the marking range
 *	LPPOINT ptEnd	- the other end of the marking range
 *	BOOL	fMark	- new marking state of cells
 *	SHORT	fMarkingMethod - MARK_ABS or MARK_XOR
 *
 *
 * RETURNS:
 *	VOID
 *
 */
void MarkText(const HHTERM	   hhTerm,
			  const LPPOINT    ptBeg,
			  const LPPOINT    ptEnd,
			  const BOOL	   fMark,
			  const int 	   sMarkingMethod)
	{
	int    iOffsetBeg,
		   iOffsetEnd,
		   sTermBeg,
		   sTermEnd,
		   i, j;
	RECT   rc;
	long   yBeg, yEnd;

	//const  int iMaxCells = hhTerm->iRows * TERM_COLS;
	//
	const  int iMaxCells = MAX_EMUROWS * MAX_EMUCOLS;

	//iOffsetBeg = ((ptBeg->y - 1) * TERM_COLS) + ptBeg->x;
	//iOffsetEnd = ((ptEnd->y - 1) * TERM_COLS) + ptEnd->x;
	//
	iOffsetBeg = ((ptBeg->y - 1) * MAX_EMUCOLS) + ptBeg->x;
	iOffsetEnd = ((ptEnd->y - 1) * MAX_EMUCOLS) + ptEnd->x;


	// Check if we moved enough to actually mark something.

	if (iOffsetBeg == iOffsetEnd)
		return;

	// Determine offsets for terminal area.

	sTermBeg = min(max(iOffsetBeg, 0), iMaxCells);
	sTermEnd = min(max(iOffsetEnd, 0), iMaxCells);

	// This routine use to reference the text and attribute buffers as
	// a continous buffer.	When switching over to pointer arrays, I
	// introduced the [i/sCols][i%sCols] notation to keep from having
	// to change the entire routine.

	if (sTermBeg != sTermEnd)
		{
		//i = (min(sTermBeg, sTermEnd)
		//    + (hhTerm->iTopline * TERM_COLS)) % iMaxCells;
		//
		i = (min(sTermBeg, sTermEnd)
		    + (hhTerm->iTopline * MAX_EMUCOLS)) % iMaxCells;


		j = abs(sTermEnd - sTermBeg);

		switch (sMarkingMethod)
			{
		case MARK_XOR:
			while (j-- > 0)
				{
				if (i >= iMaxCells)
					i = 0;

				//hhTerm->fppstAttr[i/TERM_COLS][i%TERM_COLS].txtmrk
				//    ^= (unsigned)fMark;
				//
				hhTerm->fppstAttr[i/MAX_EMUCOLS][i%MAX_EMUCOLS].txtmrk
				    ^= (unsigned)fMark;

				i += 1;
				}
			break;

		case MARK_ABS:
			while (j-- > 0)
				{
				if (i >= iMaxCells)
					i = 0;

				//hhTerm->fppstAttr[i/TERM_COLS][i%TERM_COLS].txtmrk
				//    = (unsigned)fMark;
				//
				hhTerm->fppstAttr[i/MAX_EMUCOLS][i%MAX_EMUCOLS].txtmrk
				    = (unsigned)fMark;


				i += 1;
				}
			break;

		default:
			assert(0);
			break;
			}
		}

	TestForMarkingLock(hhTerm);

	// Invalidate the rectangle covering the marked region

	yBeg = min(ptBeg->y, ptEnd->y);
	yEnd = max(ptBeg->y, ptEnd->y);

	rc.left = hhTerm->xIndent + (hhTerm->iHScrlPos ? 0 : hhTerm->xBezel);

	//rc.right = min((hhTerm->xChar * hhTerm->iCols) + hhTerm->xIndent +
	//			(hhTerm->iHScrlPos ? 0 : hhTerm->xBezel), hhTerm->cx);
	//
	rc.right = min((hhTerm->xChar * MAX_EMUCOLS) + hhTerm->xIndent +
				(hhTerm->iHScrlPos ? 0 : hhTerm->xBezel), hhTerm->cx);
	rc.top = (yBeg - hhTerm->iVScrlPos) * hhTerm->yChar;
	rc.bottom = (yEnd + 1 - hhTerm->iVScrlPos) * hhTerm->yChar;

	InvalidateRect(hhTerm->hwnd, &rc, FALSE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MarkTextAll
 *
 * DESCRIPTION:
 *	Marks all of the text on the terminal screen and backscroll buffer.
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle
 *
 * RETURNS:
 *	void
 *
 */
void MarkTextAll(HHTERM hhTerm)
	{
	MarkText(hhTerm, &hhTerm->ptBeg, &hhTerm->ptEnd, FALSE, MARK_ABS);

	hhTerm->ptBeg.x = 0;
	hhTerm->ptBeg.y = hhTerm->iVScrlMin;

	//iEmuId = EmuQ(sessQueryEmuHdl(hhTerm->hSession)
	hhTerm->ptEnd.x = hhTerm->iCols;
	hhTerm->ptEnd.y = hhTerm->iRows;

	MarkText(hhTerm, &hhTerm->ptBeg, &hhTerm->ptEnd, TRUE, MARK_ABS);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	UnmarkText
 *
 * DESCRIPTION:
 *	Unmarks all text on the terminal screen
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle
 *
 * RETURNS:
 *	void
 *
 */
void UnmarkText(const HHTERM hhTerm)
	{
	MarkText(hhTerm, &hhTerm->ptBeg, &hhTerm->ptEnd, FALSE, MARK_ABS);
	hhTerm->ptBeg = hhTerm->ptEnd;
	TestForMarkingLock(hhTerm);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TestForMarkingLock
 *
 * DESCRIPTION:
 *	Checks to seek if hTerm->fMarkingLock should be on or off.
 *
 * ARGUMENTS:
 *	HTERM	hTerm	- handle to a terminal
 *
 * RETURNS:
 *	VOID
 *
 */
void TestForMarkingLock(const HHTERM hhTerm)
	{
	hhTerm->fMarkingLock = (memcmp(&hhTerm->ptBeg, &hhTerm->ptEnd,
		sizeof(POINT)) == 0) ?	FALSE : TRUE;

	if (hhTerm->fMarkingLock)
		sessSetSuspend(hhTerm->hSession, SUSPEND_TERMINAL_MARKING);

	else
		sessClearSuspend(hhTerm->hSession, SUSPEND_TERMINAL_MARKING);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PointInSelectionRange
 *
 * DESCRIPTION:
 *	Tests if given point is within the range of the given beginning and
 *	ending points.	Note, pptBeg does not have to be less the pptEnd.
 *
 * ARGUMENTS:
 *	const PPOINT	ppt 	- point to test.
 *	const PPOINT	pptBeg	- one end of the range.
 *	const PPOINT	pptEnd	- other end of the range.
 *	const int		iCols	- number of columns in current emulator.
 *
 * RETURNS:
 *	TRUE if in range, else FALSE
 *
 */
BOOL PointInSelectionRange(const PPOINT ppt,
						   const PPOINT pptBeg,
						   const PPOINT pptEnd,
						   const int	iCols)
	{
	long l, lBeg, lEnd;

	l = (ppt->y * iCols) + ppt->x;
	lBeg = (pptBeg->y * iCols) + pptBeg->x;
	lEnd = (pptEnd->y * iCols) + pptEnd->x;

	if (l >= min(lBeg, lEnd) && l < max(lBeg, lEnd))
		return TRUE;

	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termTranslateKey
 *
 * DESCRIPTION:
 *	Does the dirty work of translate accelator keys.
 *
 * ARGUMENTS:
 *	HTERM	hTerm	- terminal handle.
 *	HWND	hwnd	- terminal window handle.
 *	USHORT	usKey	- key code from utilGetCharacter().
 *
 * RETURNS:
 *	 TRUE if it processed char, else FALSE
 *
 */
BOOL termTranslateKey(const HHTERM hhTerm, const HWND hwnd, const KEY_T Key)
	{
	POINT		ptTmp;
	INT 		x = 0;
	STEMUSET	stEmuSet;
	BOOL		fShiftKey,
				fScrlLk;

	if (Key == 0)
		return TRUE;

	fScrlLk = GetKeyState(VK_SCROLL) & 1;
	fShiftKey = (Key & SHIFT_KEY) ? TRUE : FALSE;

	// Check to see if we use it.

	switch (Key)
		{
	/* -------------- VK_HOME ------------- */

	case VK_HOME | VIRTUAL_KEY:
	case VK_HOME | VIRTUAL_KEY | SHIFT_KEY:
	case VK_HOME | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_HOME | VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY:
		MoveSelectionCursor(hhTerm, hwnd, -hhTerm->iCols, 0, fShiftKey);
		break;

	case VK_HOME | VIRTUAL_KEY | CTRL_KEY:
	case VK_HOME | VIRTUAL_KEY | CTRL_KEY | SHIFT_KEY:
	case VK_HOME | VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY:
	case VK_HOME | VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY | SHIFT_KEY:
		MoveSelectionCursor(hhTerm, hwnd, -hhTerm->iCols,
			hhTerm->iVScrlMin - hhTerm->iRows, fShiftKey);
		break;

	case VK_HOME | VIRTUAL_KEY | ALT_KEY:
	case VK_HOME | VIRTUAL_KEY | ALT_KEY | SHIFT_KEY:
	case VK_HOME | VIRTUAL_KEY | ALT_KEY | SHIFT_KEY | CTRL_KEY:
	case VK_HOME | VIRTUAL_KEY | ALT_KEY | SHIFT_KEY | CTRL_KEY | EXTENDED_KEY:
		break;

	/* -------------- VK_END ------------- */

	case VK_END | VIRTUAL_KEY:
	case VK_END | VIRTUAL_KEY | SHIFT_KEY:
	case VK_END | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_END | VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY:
		MoveSelectionCursor(hhTerm, hwnd, hhTerm->iCols - hhTerm->ptEnd.x,
			0, fShiftKey);
		break;

	case VK_END | VIRTUAL_KEY | CTRL_KEY:
	case VK_END | VIRTUAL_KEY | CTRL_KEY | SHIFT_KEY:
	case VK_END | VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY:
	case VK_END | VIRTUAL_KEY | CTRL_KEY | SHIFT_KEY | EXTENDED_KEY:
		MoveSelectionCursor(hhTerm, hwnd, hhTerm->iCols, INT_MAX/2, fShiftKey);
		break;

	/* -------------- VK_PRIOR & VK_NEXT ------------- */

	case VK_PRIOR | VIRTUAL_KEY:
	case VK_NEXT  | VIRTUAL_KEY:
	case VK_PRIOR | VIRTUAL_KEY | SHIFT_KEY:
	case VK_NEXT  | VIRTUAL_KEY | SHIFT_KEY:
	case VK_PRIOR | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_NEXT  | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_PRIOR | VIRTUAL_KEY | EXTENDED_KEY| SHIFT_KEY:
	case VK_NEXT  | VIRTUAL_KEY | EXTENDED_KEY| SHIFT_KEY:
		ptTmp = hhTerm->ptEnd;

		if (fShiftKey == 0)
			UnmarkText(hhTerm);

		if (hhTerm->ptEnd.y < hhTerm->iVScrlPos ||
				(hhTerm->ptEnd.y - hhTerm->iTermHite + 1) > hhTerm->iVScrlPos
					|| !hhTerm->fLclCurOn)
			{
			x = 1; // means it is out of view.
			}

		SendMessage(hwnd, WM_VSCROLL, ((UCHAR)Key == VK_NEXT) ?
			SB_PAGEDOWN : SB_PAGEUP, 0);

		if (x)
			{
			hhTerm->ptEnd.y = hhTerm->iVScrlPos;

			if (hhTerm->fLclCurOn)
				SetLclCurPos(hhTerm, &hhTerm->ptEnd);
			}

		else
			{
			if ((UCHAR)Key == VK_NEXT)
				{
				hhTerm->ptEnd.y += hhTerm->iTermHite;
				hhTerm->ptEnd.y = min(hhTerm->iRows, hhTerm->ptEnd.y);
				}

			else
				{
				hhTerm->ptEnd.y -= hhTerm->iTermHite;
				hhTerm->ptEnd.y = max(hhTerm->iVScrlMin, hhTerm->ptEnd.y);
				}

			if (hhTerm->fLclCurOn)
				SetLclCurPos(hhTerm, &hhTerm->ptEnd);
			}

		if (!fShiftKey)
			hhTerm->ptBeg = hhTerm->ptEnd;

		if (fShiftKey)
			MarkText(hhTerm, &ptTmp, &hhTerm->ptEnd, TRUE, MARK_XOR);

		break;

	case VK_PRIOR | VIRTUAL_KEY | CTRL_KEY:
	case VK_NEXT  | VIRTUAL_KEY | CTRL_KEY:
	case VK_PRIOR | VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY:
	case VK_NEXT  | VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY:
		UnmarkText(hhTerm);

		SendMessage(hwnd, WM_HSCROLL, ((UCHAR)Key == VK_NEXT) ?
			SB_PAGEDOWN : SB_PAGEUP, 0);

		break;

	/* -------------- VK_UP ------------- */

	case VK_UP | VIRTUAL_KEY:
	case VK_UP | VIRTUAL_KEY | SHIFT_KEY:
	case VK_UP | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_UP | VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY:
		MoveSelectionCursor(hhTerm, hwnd, 0, -1, fShiftKey);
		break;

	/* -------------- VK_DOWN ------------- */

	case VK_DOWN | VIRTUAL_KEY:
	case VK_DOWN | VIRTUAL_KEY | SHIFT_KEY:
	case VK_DOWN | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_DOWN | VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY:
		MoveSelectionCursor(hhTerm, hwnd, 0, 1, fShiftKey);
		break;

	/* -------------- VK_LEFT ------------- */

	case VK_LEFT | VIRTUAL_KEY:
	case VK_LEFT | VIRTUAL_KEY | SHIFT_KEY:
	case VK_LEFT | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_LEFT | VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY:
		MoveSelectionCursor(hhTerm, hwnd, -1, 0, fShiftKey);
		break;

	/* -------------- VK_RIGHT ------------- */

	case VK_RIGHT | VIRTUAL_KEY:
	case VK_RIGHT | VIRTUAL_KEY | SHIFT_KEY:
	case VK_RIGHT | VIRTUAL_KEY | EXTENDED_KEY:
	case VK_RIGHT | VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY:
		MoveSelectionCursor(hhTerm, hwnd, 1, 0, fShiftKey);
		break;

	/* -------------- VK_F4 ------------- */

	case VK_F4 | CTRL_KEY | VIRTUAL_KEY:
		PostMessage(sessQueryHwnd(hhTerm->hSession), WM_CLOSE, 0, 0L);
		break;

	/* -------------- VK_F8 ------------- */

	case VK_F8 | VIRTUAL_KEY:
		if (fScrlLk || hhTerm->fMarkingLock)
			{
			hhTerm->fExtSelect = !hhTerm->fExtSelect;
			break;
			}
		return FALSE;

	/* -------------- CTRL-C ------------- */

	case 0x03:
	case VK_INSERT | VIRTUAL_KEY | CTRL_KEY:
	case VK_INSERT | VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY:
		if (fScrlLk || hhTerm->fMarkingLock)
			{
			PostMessage(sessQueryHwnd(hhTerm->hSession), WM_COMMAND, IDM_COPY, 0);
			break;
			}

		return FALSE;

	/* -------------- CTRL-V ------------- */

	case 0x16:
	case VK_INSERT | VIRTUAL_KEY | SHIFT_KEY:
	case VK_INSERT | VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY:
		if (emuQuerySettings(sessQueryEmuHdl(hhTerm->hSession),
				&stEmuSet) == 0 && stEmuSet.nTermKeys != EMU_KEYS_TERM)
			{
			PostMessage(sessQueryHwnd(hhTerm->hSession), WM_COMMAND,
				IDM_PASTE, 0);

			break;
			}

		 return FALSE;

	/* -------------- CTRL-X ------------- */
	/* -------------- CTRL-Z ------------- */

	case 0x18:
	case 0x1A:
		if (fScrlLk || hhTerm->fMarkingLock)
			return TRUE;

		return FALSE;

	/* -------------- Scroll Lock ------------- */

	case VIRTUAL_KEY | VK_SCROLL:
	case VIRTUAL_KEY | SHIFT_KEY | VK_SCROLL:
	case VIRTUAL_KEY | ALT_KEY | VK_SCROLL:
	case VIRTUAL_KEY | ALT_KEY | SHIFT_KEY | VK_SCROLL:
		if (fScrlLk)
			sessSetSuspend(hhTerm->hSession, SUSPEND_SCRLCK);
		else
			sessClearSuspend(hhTerm->hSession, SUSPEND_SCRLCK);

		PostMessage(sessQueryHwndStatusbar(hhTerm->hSession),
			SBR_NTFY_REFRESH, (WPARAM)SBR_SCRL_PART_NO, 0);

		return TRUE;

	/* -------------- Num Lock ------------- */

	case VIRTUAL_KEY | EXTENDED_KEY | VK_NUMLOCK:
	case VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY | VK_NUMLOCK:
	case VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY | VK_NUMLOCK:
	case VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY | SHIFT_KEY | VK_NUMLOCK:
		PostMessage(sessQueryHwndStatusbar(hhTerm->hSession),
			SBR_NTFY_REFRESH, (WPARAM)SBR_NUML_PART_NO, 0);
		return TRUE;

	/* -------------- Caps Lock ------------- */

	case VIRTUAL_KEY | VK_CAPITAL:
	case VIRTUAL_KEY | SHIFT_KEY | VK_CAPITAL:
	case VIRTUAL_KEY | ALT_KEY | VK_CAPITAL:
	case VIRTUAL_KEY | ALT_KEY | SHIFT_KEY | VK_CAPITAL:
		PostMessage(sessQueryHwndStatusbar(hhTerm->hSession),
			SBR_NTFY_REFRESH, (WPARAM)SBR_CAPL_PART_NO, 0);
		return TRUE;

	/* -------------- Let it through based on scroll lock ------------- */

	default:
		return fScrlLk;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MarkingTimerProc
 *
 * DESCRIPTION:
 *	Multiplex timer callback routine used for text marking
 *
 * ARGUMENTS:
 *	pvhWnd	- terminal window.
 *	lTime	- contains time elapsed.
 *
 * RETURNS:
 *	void
 *
 */
void CALLBACK MarkingTimerProc(void *pvhWnd, long lTime)
	{
	const HWND	 hwnd = (HWND)pvhWnd;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	MSG 		 msg;
	POINT		 ptTemp;

	if (hhTerm->fCapture == FALSE)
		return;

	// This is TRUE if timer went off after we posted ourselves a message.
	//
	PeekMessage(&msg, hwnd, WM_TERM_SCRLMARK, WM_TERM_SCRLMARK, PM_REMOVE);

	// Because mouse messages go in the system queue and don't get put in
	// our application queue until its empty, we need to check.
	//
	if (PeekMessage(&msg, hwnd, WM_LBUTTONUP, WM_LBUTTONUP, PM_NOREMOVE) == TRUE)
		return;

	// The scrolling routines set this whenever they actually perform
	// a scroll.  So we set it FALSE here.	Then if any of the SendMessage()
	// calls below actually scroll, we know to post a message back to
	// ourselves to continue scrolling.

	hhTerm->fScrolled = FALSE;

	GetCursorPos(&ptTemp);
	MapWindowPoints(GetDesktopWindow(), hwnd, &ptTemp, 1);

	/* -------------- We control the horizontal ------------- */

	if (ptTemp.x > hhTerm->cx)
		SendMessage(hwnd, WM_HSCROLL, SB_LINEDOWN, 0);

	else if (ptTemp.x < 0)
		SendMessage(hwnd, WM_HSCROLL, SB_LINEUP, 0);

	/* -------------- We control the vertical ------------- */

	if (ptTemp.y > hhTerm->cy)
		SendMessage(hwnd, WM_VSCROLL, SB_LINEDOWN, 0);

	else if (ptTemp.y < 0)
		SendMessage(hwnd, WM_VSCROLL, SB_LINEUP, 0);

	// If we scrolled, post a message back to ourselves.  Do this because
	// the timer resolution is not short enough to produce a fast, smooth
	// scrolling effect.  Ideally, it would be better to drive this
	// entirely from timer intervals, but its too slow compared to other
	// apps.

	if (hhTerm->fScrolled)
		{
		SendMessage(hwnd, WM_MOUSEMOVE, MK_LBUTTON, MAKELPARAM(ptTemp.x, ptTemp.y));
		UpdateWindow(hwnd);
		//Sleep(10); // so we don't scroll too fast on fast machines.
		PostMessage(hwnd, WM_TERM_SCRLMARK, 0, 0);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termSetClrAttr
 *
 * DESCRIPTION:
 *	Called as a result of the emulator notifying the terminal that
 *	it's clear attribute has changed.  This function calls the
 *	appropriate emulator call to get the attribute and then
 *	sets appropriate terminal variables.
 *
 * ARGUMENTS:
 *	hhTerm	- private terminal handle.
 *
 * RETURNS:
 *	void
 *
 */
void termSetClrAttr(const HHTERM hhTerm)
	{
	HBRUSH hBrush;
	STATTR stAttr;

	emuQueryClearAttr(sessQueryEmuHdl(hhTerm->hSession), &stAttr);

	hhTerm->crTerm = hhTerm->pacrEmuColors[(stAttr.revvid) ?
		stAttr.txtclr : stAttr.bkclr];

	if ((hBrush = CreateSolidBrush(hhTerm->crTerm)) == 0)
		return;

	if (hhTerm->hbrushTerminal)
		DeleteObject(hhTerm->hbrushTerminal);

	hhTerm->hbrushTerminal = hBrush;
	InvalidateRect(hhTerm->hwnd, 0, FALSE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	BlinkText
 *
 * DESCRIPTION:
 *	Routine to toggle blinking-attribute cells on and off.
 *
 * ARGUMENTS:
 *	HWND	hwnd	- terminal window handle.
 *
 * RETURNS:
 *	VOID
 *
 */
void BlinkText(const HHTERM hhTerm)
	{
	int 		i, j, k;
	DWORD		dwTime;
	RECT		rc;
	BOOL		fUpdate,
				fBlinks = FALSE;
	const int m = hhTerm->iRows;		// for speed
	const int n = hhTerm->iCols;		// for speed


	// hhTerm->iBlink is a tristate variable.  If it is zero,
	// there are no blink attributes in the image and we can exit
	// immediately (this is an optimization).  Otherwise, we toggle
	// hhTerm->iBlink between -1 and 1, invalidate only those areas
	// that have blinks, and paint.

	if (hhTerm->iBlink == 0)
		return;

	hhTerm->iBlink = (hhTerm->iBlink == -1) ? 1 : -1;
	dwTime = GetTickCount();

	for (i = 0 ; i < m ; ++i)
		{
		const int r = (i + hhTerm->iTopline) % MAX_EMUROWS;

		if (hhTerm->abBlink[r] == 0)
			continue;

		// Don't let this routine gobble-up to much time.  If we can't
		// paint all the blinks, we can't paint all the blinks.

		if ((GetTickCount() - dwTime) >= (DWORD)(hhTerm->uBlinkRate/2))
			return;

		for (j = 0, fUpdate = FALSE ; j < n ; ++j)
			{
			if (hhTerm->fppstAttr[r][j].blink)
				{
				for (k = j, j += 1 ; j < n ; ++j)
					{
					if (hhTerm->fppstAttr[r][j].blink == 0)
						break;
					}

				rc.left = ((k - hhTerm->iHScrlPos) * hhTerm->xChar) + hhTerm->xIndent + hhTerm->xBezel;
				rc.right = rc.left + ((j - k) * hhTerm->xChar);

				rc.top = (i + 1 - hhTerm->iVScrlPos) * hhTerm->yChar;

				//rc.top = ((((i + m - hhTerm->iTopline) % m) + 1)
				//	  - hhTerm->iVScrlPos) * hhTerm->yChar;

				rc.bottom = rc.top + hhTerm->yChar;

				//
				// Currently we are blinking the text in the terminal
				// emulator screen. If we don't want the text to blink
				// when running in a Terminal Service session (Remote
				// Desktop Connection) then uncomment the following
				// line.  REV: 10/4/2001
				//
				// if (!IsTerminalServicesEnabled()) // REMOVE:REV 10/4/2001
					{
					InvalidateRect(hhTerm->hwnd, &rc, FALSE);
					fUpdate = TRUE;
					}
				fBlinks = TRUE;
				}
			}

		// Should draw here.  Reason: if line 1 had a blinker and line 24
		// had a blinker, we would have to repaint the whole terminal window
		// since windows combines invalid regions.

		if (fUpdate)
			UpdateWindow(hhTerm->hwnd);

		hhTerm->abBlink[r] = (BYTE)fUpdate;
		}

	if (fBlinks == FALSE)
		hhTerm->iBlink = 0;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	RefreshTernWindow
 *
 * DESCRIPTION:
 *	Calls the WM_SIZE code for terminal window
 *
 * ARGUMENTS:
 *	hwnd	- Terminal Window to refresh
 *
 * RETURNS:
 *	void
 *
 */
void RefreshTermWindow(const HWND hwndTerm)
	{
	RECT rc;
	const HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwndTerm, GWLP_USERDATA);

	if (hhTerm) // need to check validatity of handle. mrw:3/1/95
		{
        TP_WM_SIZE(hhTerm->hwnd, 0, 0, 0); // mrw:11/3/95
		GetClientRect(hwndTerm, &rc);
		TP_WM_SIZE(hhTerm->hwnd, 0, rc.right, rc.bottom);
		InvalidateRect(hwndTerm, 0, FALSE);
		}
	return;
	}

//mpt:1-23-98 attempt to re-enable DBCS code
//#if 0
#ifndef CHAR_NARROW
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termValidatePosition
 *
 * DESCRIPTION:
 *	Checks the marking cursor position information in the HHTERM struct and
 *	determines if it is valid by checking the underlying characters to see if
 *	the cursor would split a double byte character.  It optionally adjusts
 *	the position to a valid position.
 *
 * ARGUMENTS:
 *	hhTerm				-- internal terminal data structure
 *	nAdjustmentMode		-- one of the following values:
 *								VP_NO_ADJUSTMENT
 *								VP_ADJUST_RIGHT
 *								VP_ADJUST_LEFT
 *
 * RETURNS:
 *	TRUE if the input values are OK, otherwise FALSE.  Note that the adjust
 *	parameter and any actions performed do not alter the return value.
 *
 */
BOOL termValidatePosition(const HHTERM	hhTerm,
						  const int		nAdjustmentMode,
						  		POINT	*pLocation)
	{
	BOOL bRet = TRUE;

	if (pLocation->y <= 0)
		return TRUE;
	
	if ( hhTerm->fppstAttr[pLocation->y - 1][pLocation->x].wirt == TRUE )
		{
		switch (nAdjustmentMode)
			{
			case VP_ADJUST_RIGHT:
				if ( pLocation->x < hhTerm->iCols )
					{
					DbgOutStr("incrementing %d\r\n", pLocation->x, 0,0,0,0);
					pLocation->x++;
					bRet = FALSE;
					}
				break;

			case VP_ADJUST_LEFT:
				if (pLocation->x > 0)
					{
					DbgOutStr("decrementing %d\r\n", pLocation->x, 0,0,0,0);
					pLocation->x--;
					bRet = FALSE;
					}
				break;

			default:
				break;
			}
		}
	
	return bRet;
	}
#endif // !CHAR_NARROW

#if 0 //DEADWOOD
	BOOL bRet = TRUE;
	int bLeadByteSeen;
	int nOffset;
	LONG lIndx;
	LPTSTR pszStr = (LPTSTR)NULL;

	/*
	 * This function just doesn't work correctly.  The reason for that is
	 * that I don't understand how the lines are organized and indexed in
	 * the terminal.  For now, this works OK if you just have a few lines
	 * on the terminal screen for testing.  Nothing in the backscroll.  I
	 * have no idea what other problems it has.
	 *
	 * DLW (17-Aug-1994)
	 *
	 * OK, I have made some attempt to get this stuff working correctly.
	 * At least it doesn't seg anymore and seems to work most of the time.
	 * I know that it still screws up when the scroll numbers are not just
	 * right, so it is pretty obvious that it still is not what it should
	 * be. So, it still needs to be checked by someone who knows what they
	 * are doing (which leaves me out).
	 *
	 * DLW (18-Aug-1994)
	 */

	nOffset = 0;
	if (pLocation->y <= 0)
		{
		nOffset  = hhTerm->iPhysicalBkRows + hhTerm->iNextBkLn + pLocation->y;
		nOffset %= hhTerm->iPhysicalBkRows;

		pszStr = (LPTSTR)hhTerm->fplpstrBkTxt[nOffset];
		}
	else if (pLocation->y > 0)
		{
		nOffset = pLocation->y - 1;

		pszStr = (LPTSTR)hhTerm->fplpstrTxt[nOffset];
		}

	assert(pszStr);

	if (pszStr == (LPTSTR)NULL)
		return FALSE;

	/*
	 * We need to loop thru the string and check if the last character before
	 * the specified character is a DBCS lead byte.  If it is, we return FALSE
	 * and perform any requested adjustment.
	 */

	bLeadByteSeen = FALSE;
	for (lIndx = 0; lIndx < pLocation->x; lIndx += 1)
		{
		if (bLeadByteSeen)
			{
			/* The rule is that a lead byte can NEVER follow a lead byte */
			bLeadByteSeen = FALSE;
			}
		else
			{
			bLeadByteSeen = IsDBCSLeadByte(pszStr[lIndx]);
			}
		}

	if (lIndx == pLocation->x)
		{
		bRet = !bLeadByteSeen;
		}

	if (!bRet)
		{
		switch (nAdjustmentMode)
			{
			case VP_ADJUST_RIGHT:
				DbgOutStr("incrementing %d\r\n", pLocation->x, 0,0,0,0);
				/* TODO: range check this first */
				pLocation->x += 1;
				break;

			case VP_ADJUST_LEFT:
				DbgOutStr("decrementing %d\r\n", pLocation->x, 0,0,0,0);
				/* TODO: range check this first */
				pLocation->x -= 1;
				break;

			default:
				break;
			}
		}
	return bRet;
	}
#endif


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termGetLogFont
 *
 * DESCRIPTION:
 *	This is here to handle a problem with calling send message in
 *	the minitel load routines.
 *
 * ARGUMENTS:
 *	hwndTerm	- Terminal Window
 *
 * RETURNS:
 *	0=OK
 *
 * AUTHOR: mrw,2/21/95
 *
 */
int termGetLogFont(const HWND hwndTerm, LPLOGFONT plf)
	{
	HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwndTerm, GWLP_USERDATA);
	assert(plf != 0);

	if (hhTerm == 0)
		return -1; // mrw:6/15/95

	*plf = hhTerm->lf;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	termSetLogFont
 *
 * DESCRIPTION:
 *	This is here to handle a problem with calling send message in
 *	the minitel load routines.
 *
 * ARGUMENTS:
 *	hwndTerm	- Terminal Window
 *
 * RETURNS:
 *	0=OK
 *
 * AUTHOR: mrw,2/21/95
 *
 */
int termSetLogFont(const HWND hwndTerm, LPLOGFONT plf)
	{
	HHTERM hhTerm = (HHTERM)GetWindowLongPtr(hwndTerm, GWLP_USERDATA);
	assert(plf != 0);

	if (hhTerm == 0) // mrw,3/2/95
		return -1;

	hhTerm->lfHold = *plf;
	PostMessage(hwndTerm, WM_TERM_KLUDGE_FONT, 0, 0);

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\translat.h ===
/*	File: D:\WACKER\translat.h (Created: 24-Aug-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 1/29/02 2:24p $
 */

HTRANSLATE CreateTranslateHandle(HSESSION hSession);
int InitTranslateHandle(HTRANSLATE hTranslate, BOOL LoadDLL );
int LoadTranslateHandle(HTRANSLATE hTranslate);
int SaveTranslateHandle(HTRANSLATE hTranslate);
int DestroyTranslateHandle(HTRANSLATE hTranslate);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\translat.hh ===
/*	File: D:\WACKER\translat.hh (Created: 24-Aug-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:39p $
 */

struct stTransInternal
	{
	HSESSION hSession;
	HINSTANCE hInstance;			/* Returned from LoadLibrary */
	};

typedef	struct stTransInternal ST_TRANS_INT;
typedef	ST_TRANS_INT *PST_TRANS_INT;

// For now we'll include the .HH file where we need access to the
// structure.  Later, we'll go back and write wrappers for the
// few places this needs to referenced.  Also, the session handle
// should probably not own the translate handle.  It may be more
// appropriate to think of this as function of the cloop - mrw, 3/1/95
//
struct stTranslate
	{
	int   (*pfnIsDeviceLoaded)(VOID *pV);
	int   (*pfnDoDialog)(HWND hWnd, VOID *pV);
	VOID *(*pfnCreate)(HSESSION hSession);	// why is this void *? - mrw
	int   (*pfnInit)(VOID *pV);
	int   (*pfnLoad)(VOID *pV);
	int   (*pfnSave)(VOID *pV);
	int   (*pfnDestroy)(VOID *pV);
	int   (*pfnIn)(VOID *pV, TCHAR cC, int *nReady, int nSize, TCHAR *pszC);
	int   (*pfnOut)(VOID *pV, TCHAR cC, int *nReady, int nSize, TCHAR *pszC);

	VOID *pDllHandle;			/* the handle from the DLL */
	VOID *pInternal;			/* internal handle used internally */
	};

typedef	struct stTranslate	ST_TRANSLATE;
typedef ST_TRANSLATE *HHTRANSLATE;

// These functions as well as the function pointers above take VOID *
// pointers.  I'ld like to see them point to some incomplete type
// at the very least for typechecking purposes. - mrw 3/1/95
//
static int translateInternalFalse(VOID *pV);
static int translateInternalTrue(VOID *pV);
static VOID *translateInternalVoid(HSESSION hSession);
static int translateInternalDoDlg(HWND hWnd, VOID *pV);
static int translateInternalCio(VOID *pV, TCHAR cC, int *nR, int nS, TCHAR *pC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\toolbar.c ===
/*	File: D:\WACKER\tdll\toolbar.c (Created: 02-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 6/11/01 4:42p $
 */

#define OEMRESOURCE 	// Need for OBM bitmaps...

#include <windows.h>
#include <commctrl.h>

#include "assert.h"
#include "stdtyp.h"
#include "globals.h"
#include "session.h"
#include <term\res.h>

#define BTN_CNT 7

struct stToolbarStuff
	{
	int nSpacer;			/* Number of spaces to insert before button */
	int nBmpNum;			/* Index of the bitmap for this button */
	int nCmd;				/* Command to associate with the button */
	int nStrRes;			/* String resource ID number */
	};

static struct stToolbarStuff stTS[] = {
	{1, 0, IDM_NEW,				IDS_TTT_NEW},			/* New button */
	{0, 1, IDM_OPEN,			IDS_TTT_OPEN},			/* Open button */
	{1, 2, IDM_ACTIONS_DIAL,	IDS_TTT_DIAL},			/* Dial button */
	{0, 3, IDM_ACTIONS_HANGUP,	IDS_TTT_HANGUP},		/* Hangup button */
	{1, 4, IDM_ACTIONS_SEND,	IDS_TTT_SEND},			/* Send button */
	{0, 5, IDM_ACTIONS_RCV,		IDS_TTT_RECEIVE},		/* Receive button */
	{1, 6, IDM_PROPERTIES,		IDS_TTT_PROPERTY},		/* Properties button */
  //{1, 7, IDM_HELPTOPICS,		IDS_TTT_HELP}			/* Help button */
	};

static void AddMinitelButtons(const HWND hwnd);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateSessionToolbar
 *
 * DESCRIPTION:
 *	Creates a toolbar intended for use with the a session
 *
 * ARGUMENTS:
 *	hwndSession - session window handle
 *
 * RETURNS:
 *	Window handle to toolbar or zero on error.
 *
 */
/* ARGSUSED */
HWND CreateSessionToolbar(const HSESSION hSession, const HWND hwndSession)
	{
	HWND	 hWnd = 0;
	int		 iLoop = 0;
	DWORD	 lTBStyle = TBSTYLE_TOOLTIPS | WS_CHILD | WS_VISIBLE;
	TBBUTTON lButton;

	//
    // Changed to use Flat style in version 4.0 - mpt 06-10-98
	//

#if defined( INCL_COOL_TOOLBARS )
	lTBStyle |= TBSTYLE_FLAT;
#endif

	//
	// Create a toolbar with no buttons.
	//

	hWnd = CreateToolbarEx( hwndSession,
						    lTBStyle,
						    IDC_TOOLBAR_WIN,
						    BTN_CNT,
							glblQueryDllHinst(),
							IDB_BUTTONS_SMALL,
							NULL,				 // Array of buttons
							0,					 // Number of buttons in array
							16, 16,				 // button size
							16, 16,	 			 // bitmap size
							sizeof( TBBUTTON ) );

	assert( hWnd );

	if ( IsWindow( hWnd ) )
		{
		//
		// Add some buttons.
		//

		for ( iLoop = 0; iLoop < BTN_CNT; iLoop++ )
			{
			int iIndex;

			for ( iIndex = 0; iIndex < stTS[ iLoop ].nSpacer; iIndex++ )
				{
				//
				// Don't add seperator at beginning of toolbar.
				//

				if ( iLoop != 0 )
					{
					//
					// Just insert space between two buttons.
					//

					lButton.iBitmap   = 0;
					lButton.idCommand = 0;
					lButton.fsState   = TBSTATE_ENABLED;
					lButton.fsStyle   = TBSTYLE_SEP;
					lButton.dwData    = 0;
					lButton.iString   = 0;
            
					SendMessage( hWnd, TB_ADDBUTTONS, 1, (LPARAM)&lButton );
					}
				}

			lButton.iBitmap   = stTS[ iLoop ].nBmpNum;
			lButton.idCommand = stTS[ iLoop ].nCmd;
			lButton.fsState   = TBSTATE_ENABLED;
			lButton.fsStyle   = TBSTYLE_BUTTON;
			lButton.dwData    = 0;
			lButton.iString   = 0;

			SendMessage( hWnd, TB_ADDBUTTONS, 1, (LPARAM)&lButton );
			}
		}

	ToolbarEnableButton(hWnd, IDM_ACTIONS_DIAL, TRUE);
	ToolbarEnableButton(hWnd, IDM_ACTIONS_HANGUP, FALSE);
	return hWnd;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ToolbarNotification
 *
 * DESCRIPTION:
 *	This function is called when the toolbar sends a notification message to
 *	the session window.
 *
 * ARGUMENTS:
 *	hwnd     -- the window handle of the session window
 *	nId      -- the control ID (the tool bar in this case)
 *	nNotify  -- the notification code
 *	hwndCtrl -- the window handle of the tool bar
 *
 * RETURNS:
 *	Whatever the notification requires.  See individual code below.
 *
 */
/* ARGSUSED */
LRESULT ToolbarNotification(const HWND hwnd,
						const int nId,
						const int nNotify,
						const HWND hwndCtrl)
	{
	//lint -e648	TBN constants overflow
	LRESULT lRet = 0;
	static int nCount;

	switch ((UINT)nNotify)
		{
		case TBN_BEGINADJUST:
			/*
			 * No return value.
			 */
			nCount = 1;
			break;

		case TBN_QUERYDELETE:
			/*
			 * Return TRUE to delete the button or FALSE to prevent the button
			 * from being deleted.
			 */
			lRet = FALSE;
			break;

		case TBN_QUERYINSERT:
			/*
			 * Return TRUE to insert the new button in front of the given
			 * button, or FALSE to prevent the button from being inserted.
			 */
			if (nCount > 0)
				{
				nCount -= 1;
				lRet = TRUE;
				}
			break;

		default:
			break;
		}

	return lRet;
	//lint +e648
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ToolbarNeedsText
 *
 * DESCRIPTION:
 *	This function is called when the toolbar sends a notification message to
 *	the session window saying that it needs text for the ToolTips window.
 *
 * ARGUMENTS:
 *	hwnd     -- the window handle of the session window
 *	lPar     -- the lPar that the session window got
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
void ToolbarNeedsText(HSESSION hSession, LPARAM lPar)
	{
	unsigned int nLoop;
	LPTOOLTIPTEXT pText = (LPTOOLTIPTEXT)lPar;

	for (nLoop = 0 ; nLoop < DIM(stTS) ; nLoop += 1)
		{
		if ((int)pText->hdr.idFrom == stTS[nLoop].nCmd)
			{
			LoadString(glblQueryDllHinst(), (UINT)stTS[nLoop].nStrRes,
						pText->szText,
						sizeof(pText->szText) / sizeof(TCHAR));
			return;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ToolbarEnableButton
 *
 * DESCRIPTION:
 *	Enables or disables a button based on the state.
 *
 * ARGUMENTS:
 *	hwndToolbar - Window handle to toolbar
 *	fEnable - bool to determine wether to enable or disable the button
 *
 */
void ToolbarEnableButton(const HWND hwndToolbar, const int uID, BOOL fEnable)
	{
	assert( hwndToolbar );

	if ( IsWindow( hwndToolbar ) )
		{
		PostMessage( hwndToolbar, TB_ENABLEBUTTON, uID, fEnable );
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\timers.c ===
/* timers.c -- Multiplexed timer routines -- run several timers off one
 *					Windows timer.
 *
 *	Copyright 1994 by Hilgraeve, Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 5/29/02 2:17p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include <tdll\assert.h>
#include "mc.h"
#include "session.h"
#include "timers.h"

typedef struct s_timer ST_TIMER;
typedef struct s_timer_mux ST_TIMER_MUX;

struct s_timer_mux
	{
	HSESSION  hSession;
	HWND	  hWnd;
	UINT	  uiID;
	UINT_PTR  uiTimer;
	UINT	  uiLastDuration;
	int 	  fInMuxProc;
	ST_TIMER *pstFirst;
	ST_TIMER *pstCurrent;
	};

struct s_timer
	{
	HSESSION     hSession;
	ST_TIMER	 *pstNext;
	ST_TIMER_MUX *pstTimerMux;
	long		  lInterval;
	long		  lLastFired;
	long		  lFireTime;
	void		  *pvData;
	TIMERCALLBACK pfCallback;
	};


void TimerInsert(ST_TIMER_MUX *pstTimerMux, ST_TIMER *pstTimer);
int  TimerSet(ST_TIMER_MUX *pstTimerMux);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerMuxCreate
 *
 * DESCRIPTION:
 *	Creates a Timer Multiplexer from which any number of individual timers
 *	can be created. A Timer Multiplexer uses only one Windows Timer now
 *	matter how many individual timers are created from it.
 *
 * ARGUMENTS:
 *	pHTM -- A pointer to an HTIMERMUX handle. This handle must be used in
 *			subsequent calls to CreateTimer
 *
 * RETURNS:
 *	TIMER_OK		  if successful
 *	TIMER_NOMEM 	  if there is insufficient memory
 *	TIMER_NOWINTIMER  if there are no Windows timers available
 *	TIMER_ERROR 	  if invalid parameters are passed.
 */
int TimerMuxCreate(const HWND hWnd, const UINT uiID, HTIMERMUX * const pHTM, const HSESSION hSession)
	{
	//
	// sessQueryTimerMux() locks the session's TimerMux
	// critical section. Call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section. REV: 5/21/2002
	//
	HTIMERMUX hTM = sessQueryTimerMux(hSession);

	int iReturnVal = TIMER_OK;
	ST_TIMER_MUX *pstTM;

	if (!hWnd || !pHTM)
		{
		assert(FALSE);
		return TIMER_ERROR;
		}

	if ((pstTM = malloc(sizeof(ST_TIMER_MUX))) == NULL)
		{
		iReturnVal = TIMER_NOMEM;
		}
	else
		{
		pstTM->hSession = hSession;
		pstTM->hWnd = hWnd;
		pstTM->uiID = uiID;
		pstTM->uiTimer = 0;
		pstTM->uiLastDuration = 0;
		pstTM->pstFirst = (ST_TIMER *)0;
		pstTM->pstCurrent = (ST_TIMER *)0;
		pstTM->fInMuxProc = FALSE;

		iReturnVal = TimerSet(pstTM);

		DbgOutStr("TimerMux handle %#lx created.\r\n", pstTM, 0, 0, 0, 0);
		}

	if (iReturnVal != TIMER_OK)
		{
		(void)TimerMuxDestroy((HTIMERMUX *)&pstTM, hSession);
		}

	*pHTM = (HTIMERMUX)pstTM;

	//
	// Don't forget to call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section locked in
	// sessQueryTimerMux(). REV: 5/21/2002
	//
	sessReleaseTimerMux(hSession);

	return iReturnVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerMuxDestroy
 *
 * DESCRIPTION:
 *	Destroys a timer multiplexer and any timers still active
 *
 * ARGUMENTS:
 *	phTM -- Pointer to a timer mux handle of type HTIMERMUX created by
 *			an earlier call to TimerMuxCreate. The value pointed to will
 *			be set to NULL after the TimerMux is destroyed
 *
 * RETURNS:
 *	TIMER_OK
 */
int TimerMuxDestroy(HTIMERMUX * const phTM, const HSESSION hSession)
	{
	//
	// sessQueryTimerMux() locks the session's TimerMux
	// critical section. Call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section. REV: 5/21/2002
	//
	HTIMERMUX hTM = sessQueryTimerMux(hSession);

	ST_TIMER *pstTimer;
	ST_TIMER_MUX *pstTimerMux;
	assert(phTM);

	pstTimerMux = (ST_TIMER_MUX *)*phTM;

	if (pstTimerMux)
		{
		while (pstTimerMux->pstFirst)
			{
			pstTimer = pstTimerMux->pstFirst;
			(void)TimerDestroy((HTIMER *)&pstTimer);
			}
		if (pstTimerMux->uiTimer)
			{
			DbgOutStr("KillTimer (timers.c)\r\n",0,0,0,0,0);
			(void)KillTimer(pstTimerMux->hWnd, pstTimerMux->uiID);
			}
		free(pstTimerMux);
		pstTimerMux = NULL;

		DbgOutStr("TimerMux handle 0x%lx destroyed.\r\n", pstTimerMux, 0, 0, 0, 0);
		}

	*phTM = (HTIMERMUX)0;

	//
	// Don't forget to call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section locked in
	// sessQueryTimerMux(). REV: 5/21/2002
	//
	sessReleaseTimerMux(hSession);

	return TIMER_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerCreate
 *
 * DESCRIPTION:
 *	Creates a timer that will call a registered call back function at
 *	regular intervals specified in milliseconds. Once created, a timer
 *	can be destroyed by calling TimerDestroy(). TimerDestroy can be called
 *	from within the timer callback procedure.
 *
 * ARGUMENTS:
 *	hTM 	   -- A timer multiplexer handle returned from a call to
 *					TimerMuxCreate
 *	phTimer    -- Pointer to a variable of type HTIMER to receive the
 *					handle of the new timer.
 *	lInterval -- The timer interval in milliseconds. The callback function
 *					will be called repeatedly at roughly this interval until
 *					the timer is destroyed. The timer will operate at a minimum
 *					resolution depending on system capabilities. In Windows 3.x,
 *					the minimum resolution is 55 msecs. Due to the operation
 *					of the underlying Windows timer function, any interval may
 *					be extended an arbitrary amount of time.
 *	pfCallback -- Pointer to a function to be called after each interval.
 *					This function should be of type TIMER_CALLBACK. The
 *					value passed should be the result of calling
 *					MakeProcInstance on the actual callback function.
 *
 *					This function should accept two arguments: a void ptr
 *					value which will contain any value supplied in the
 *					pvData argument described below; and an unsigned long
 *					which will be set to the actual duration of the most
 *					recent interval in milliseconds.
 *	pvData	   -- Can contain any arbitrary data. This value will be
 *					associated with the timer created and will be passed as
 *					an argument when the callback funtion is called.
 *
 * RETURNS:
 *	TIMER_OK		 if timer could be created.
 *	TIMER_NOMEM 	 if there was insufficient memory
 *	TIMER_NOWINTIMER if no Windows timers are available
 *	TIMER_ERROR 	 if parameters were invalid (also generates an assert)
 */
int TimerCreate(const HSESSION      hSession,
					  HTIMER		* const phTimer,
					  long			lInterval,
				const TIMERCALLBACK pfCallback,
					  void			*pvData)
	{
	//
	// sessQueryTimerMux() locks the session's TimerMux
	// critical section. Call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section. REV: 5/21/2002
	//
	HTIMERMUX hTM = sessQueryTimerMux(hSession);

	ST_TIMER_MUX * const pstTimerMux = (ST_TIMER_MUX *)hTM;
	ST_TIMER *pstTimer = (ST_TIMER *)0;
	int iReturnVal = TIMER_OK;

	assert(pstTimerMux && pfCallback);

	if (pstTimerMux)
		{
		// Guard against a zero interval
		if (lInterval == 0L)
			{
			++lInterval;
			}

		if (!pstTimerMux || !pfCallback)
			{
			iReturnVal = TIMER_ERROR;
			}
		else if ((pstTimer = malloc(sizeof(*pstTimer))) == NULL)
			{
			iReturnVal = TIMER_NOMEM;
			}
		else
			{
			pstTimer->hSession    = hSession;
			pstTimer->pstNext     = (ST_TIMER *)0;
			pstTimer->pstTimerMux = pstTimerMux;
			pstTimer->lInterval   = lInterval;
			pstTimer->lLastFired  = (long)GetTickCount();
			pstTimer->lFireTime   = pstTimer->lLastFired + lInterval;
			pstTimer->pvData      = pvData;
			pstTimer->pfCallback  = pfCallback;

			TimerInsert(pstTimerMux, pstTimer);

			// Following code caused problems when called from a thread other
			//	than the main thread
			// if ((iReturnVal = TimerSet(pstTimerMux)) != TIMER_OK)
			//	   (void)TimerDestroy((HTIMER *)&pstTimer);

			PostMessage(pstTimerMux->hWnd, WM_FAKE_TIMER, 0, 0);

			DbgOutStr("Timer handle %#lx (%#lx) created.\r\n", pstTimer, pstTimerMux, 0, 0, 0);
			}

		if (phTimer)
			{
			*phTimer = (HTIMER)pstTimer;
			}

		}

	//
	// Don't forget to call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section locked in
	// sessQueryTimerMux(). REV: 5/21/2002
	//
	sessReleaseTimerMux(hSession);

	return iReturnVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerDestroy
 *
 * DESCRIPTION:
 *	Destroys a timer created with TimerCreate. This routine can be called
 *	to destroy a timer from within its own callback functionl
 *
 * ARGUMENTS:
 *	hTimer -- A timer handle returned from a call to TimerCreate.
 *
 * RETURNS:
 *	TIMER_OK  if the timer is found and destroyed.
 *	TIMER_ERROR if the handle could not be found.
 */
int TimerDestroy(HTIMER * const phTimer)
	{
	int 		  iReturnVal = TIMER_OK;
	ST_TIMER	  stDummy;
	ST_TIMER	 *pstTimer = (ST_TIMER *)*phTimer;
	ST_TIMER	 *pstScan;
	ST_TIMER	 *pstFound;
	ST_TIMER_MUX *pstTimerMux;

	assert(phTimer);

	if (pstTimer)
		{
		//
		// sessQueryTimerMux() locks the session's TimerMux
		// critical section. Call sessReleaseTimerMux() to unlock
		// the session's TimerMux critical section. REV: 5/21/2002
		//
		HTIMERMUX hTM = sessQueryTimerMux(pstTimer->hSession);
		//
		// Get the session handle for call to sessReleaseTimerMux() later.
		//
		const HSESSION hSession = pstTimer->hSession;

		// Get pointer to parent struct
		pstTimerMux = pstTimer->pstTimerMux;

		if (pstTimerMux)
			{
			// If a timer is being destroyed from within its own callback, it
			//	 has already been removed from the timer chain. Setting
			//	 pstTimerMux->pstCurrent to NULL will prevent it from being
			//	 rescheduled.
			if (pstTimer == pstTimerMux->pstCurrent)
				{
				free(pstTimer);
				pstTimer = NULL;
				DbgOutStr("Timer destroyed 0x%lx\r\n", (LONG)pstTimer, 0, 0, 0, 0);
				*phTimer = (HTIMER)0;
				pstTimerMux->pstCurrent = (ST_TIMER *)0;
				}

			else
				{
				// Set up dummy node at head of list to avoid a bunch of
				//	 special cases
				stDummy.pstNext = pstTimerMux->pstFirst;
				pstScan = &stDummy;

				// Scan through list for match, maintaining pointer to the
				//	 node BEFORE
				while ((pstFound = pstScan->pstNext) != (ST_TIMER *)0)
					{
					if (pstFound == pstTimer)
						{
						break;
						}
					pstScan = pstFound;
					}

				// pstFound will be NULL if timer was not in list, otherwise
				//	pstFound is the node to remove and pstScan is the node
				//	prior to it
				if (!pstFound)
					{
					iReturnVal = TIMER_ERROR;
					}
				else
					{
					pstScan->pstNext = pstFound->pstNext;
					DbgOutStr("Timer handle 0x%lx destroyed.\r\n", pstFound, 0, 0, 0, 0);
					free(pstFound);
					pstFound = NULL;

					// If we just destroyed a timer from within its own callback,
					//	leave a sign so the timer proc will know
					if (pstFound == pstTimerMux->pstCurrent)
						pstTimerMux->pstCurrent = (ST_TIMER *)0;

					// Remove dummy node from start of list
					pstTimerMux->pstFirst = stDummy.pstNext;
					*phTimer = (HTIMER)0;
					}
				}
			}
		else
			{
			iReturnVal = TIMER_ERROR;
			}

		//
		// Don't forget to call sessReleaseTimerMux() to unlock
		// the session's TimerMux critical section locked in
		// sessQueryTimerMux(). REV: 5/21/2002
		//
		sessReleaseTimerMux(hSession);
		}

	return iReturnVal;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerMuxProc
 *
 * DESCRIPTION:
 *	This function should be called by the window proc of the window whose
 *	handle was passed to TimerMuxCreate when a WM_TIMER message is received.
 *	It uses one Windows timer to control any number of individual multiplexed
 *	timers.
 *
 * ARGUMENTS:
 *	hSession -- The session to retreive the TimerMux handle from.
 *
 * RETURNS:
 *	nothing
 */
void TimerMuxProc(const HSESSION hSession)
	{
	//
	// sessQueryTimerMux() locks the session's TimerMux
	// critical section. Call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section. REV: 5/21/2002
	//
	HTIMERMUX hTM = sessQueryTimerMux(hSession);

	ST_TIMER *pstScan;
	ST_TIMER_MUX * const pstTimerMux = (ST_TIMER_MUX *)hTM;
	long lNow;
	TIMERCALLBACK *pfCallback;

	// Callbacks to timer procs to the printing routines can take a
	// long time because of paper-out, etc.  Since the AbortProc in
	// the printer routines yields via a message loop, it is possible
	// (read probable) that we can recursively enter this routine.
	// The fInMuxProc flag guards against such an event. - mrw

	if (!pstTimerMux->fInMuxProc)
		{
		pstTimerMux->fInMuxProc = TRUE;
		}
	else
		{
		return;
		}

	lNow = (long)GetTickCount();
	DbgOutStr("%ld ", lNow, 0, 0, 0, 0);

	// In the following routine, note that the node associated with the
	//	current call back is NOT linked into the timer chain during the
	//	call back. This allows TimerDestroy to be called on a timer from
	//	within its own call back. It is also OK to call TimerCreate from
	//	within call backs.

	// Since timer ticks can be delayed, more than one event may have expired
	pstScan = pstTimerMux->pstFirst;
	while (pstScan && lNow > pstScan->lFireTime)
		{
		// Keep track of which timer is being called
		pstTimerMux->pstCurrent = pstScan;

		// Remove current node from list (will be added back in later if
		//	not destroyed)
		pstTimerMux->pstFirst = pstScan->pstNext;

		pfCallback = &pstScan->pfCallback;

		// Give up the critical section while doing the callback so
		// a lengthy call back won't delay any other threads
		sessReleaseTimerMux(hSession);

		// Activate the call back function
		(*pfCallback)(pstScan->pvData, lNow - pstScan->lLastFired);

		hTM = sessQueryTimerMux(hSession);
		assert(pstTimerMux == (ST_TIMER_MUX *)hTM);

		lNow = (long)GetTickCount();
		DbgOutStr("%ld ", lNow, 0, 0, 0, 0);

		// If timer was destroyed during callback, pstTimerMux->pstCurrent will have
		//	been sent to NULL; otherwise reschedule this timer
		if ((pstScan = pstTimerMux->pstCurrent) != (ST_TIMER *)0)
			{
			DbgOutStr("Reschedule ", 0, 0, 0, 0, 0);
			// Reschedule timer
			pstScan->lLastFired = lNow;
			pstScan->lFireTime = lNow + pstScan->lInterval;

			// link this timer back into the list
			TimerInsert(pstTimerMux, pstScan);
			pstTimerMux->pstCurrent = (ST_TIMER *)0;
			}

		// First node on list is always the next one due to fire
		pstScan = pstTimerMux->pstFirst;
		}

	(void)TimerSet(pstTimerMux);

	pstTimerMux->fInMuxProc = FALSE;
//	LeaveCriticalSection(&pstTimerMux->critsec);

	//
	// Don't forget to call sessReleaseTimerMux() to unlock
	// the session's TimerMux critical section locked in
	// sessQueryTimerMux(). REV: 5/21/2002
	//
	sessReleaseTimerMux(hSession);

	return;
	}


//			INTERNAL ROUTINES


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerInsert
 *
 * DESCRIPTION:
 *	Links a timer control node into the linked list of all multiplexed timers.
 *	The list is maintained in order by when the node is due to fire.
 *
 * ARGUMENTS:
 *	pstTimerMux -- Handle to the timer multiplexer.
 *	pstTimer	-- Pointer to a node to be inserted.
 *
 * RETURNS:
 *	nothing
 */
void TimerInsert(ST_TIMER_MUX *pstTimerMux,
				 ST_TIMER *pstTimer)
	{
	ST_TIMER *pstScan;

	pstScan = pstTimerMux->pstFirst;

	// If there are no other nodes in the list or if the new timer is
	//	 scheduled before the first one in the list, link new one in first
	if (!pstScan || pstTimer->lFireTime < pstScan->lFireTime)
		{
		pstTimer->pstNext = pstScan;
		pstTimerMux->pstFirst = pstTimer;
		}
	else
		{
		// Insert sorted by lFireTime
		while (pstScan->pstNext &&
				pstScan->pstNext->lFireTime < pstTimer->lFireTime)
			{
			pstScan = pstScan->pstNext;
			}

		// Link into chain
		pstTimer->pstNext = pstScan->pstNext;
		pstScan->pstNext = pstTimer;
		}

	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: TimerSet
 *
 * DESCRIPTION:
 *	Sets up a Windows timer using SetTimer to fire when the next multiplexed
 *	timer needs attention. Since the Window timer operates with an interval
 *	specified in a USHORT, there are times when the timer may have to be
 *	set to go off before the next required interval. If there are no
 *	multiplexed timers to be serviced, the timer is set to its maximum time
 *	anyway. By keeping one timer whether we need it or not, we guarantee
 *	that one will be available when we DO need it.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	TIMER_OK if successful.
 *	TIMER_NOWINTIMER if no Windows timers were available
 */
int TimerSet(ST_TIMER_MUX *pstTimerMux)
	{
	UINT uiDuration = 100000;
	int  iReturnVal = TIMER_OK;
	long lTickCount;

	if (pstTimerMux->pstFirst)
		{
		lTickCount = (long)GetTickCount();

		if (pstTimerMux->pstFirst->lFireTime <= lTickCount)
			uiDuration = 1; 	// Timer has already expired
		else
			uiDuration = (UINT)(pstTimerMux->pstFirst->lFireTime - lTickCount);
		}

	if (pstTimerMux->uiTimer == 0 || uiDuration != pstTimerMux->uiLastDuration)
		{
		// if (pstTimerMux->uiTimer != 0)
		//	   {
		//	   DbgOutStr("KillTimer (timers.c)\r\n",0,0,0,0,0);
		//	   fResult = KillTimer(pstTimerMux->hWnd, pstTimerMux->uiID);
		//	   assert(fResult);
		//	   }

		pstTimerMux->uiTimer =
			SetTimer(pstTimerMux->hWnd, pstTimerMux->uiID, uiDuration, NULL);

		DbgOutStr("SetTimer (timers.c)\r\n", 0,0,0,0,0);

		if (pstTimerMux->uiTimer == 0)
			{
			iReturnVal = TIMER_NOWINTIMER;
			}

		pstTimerMux->uiLastDuration = uiDuration;
		}

	return (iReturnVal);
	}

//	End of timers.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\update.c ===
/*	File: D:\WACKER\tdll\update.c (Created: 09-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:36p $
 */

#include <windows.h>
#pragma hdrstop

#include <math.h>

#include "stdtyp.h"
#include "mc.h"
#include "assert.h"
#include "session.h"
#include <emu\emu.h>

#include "update.h"
#include "update.hh"

static HHUPDATE VerifyUpdateHdl(const HUPDATE hUpdate);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateCreate
 *
 * DESCRIPTION:
 *	Creates and initializes an update record.  Make sure to call
 *	UpdateDestroy when before killing the session or pay dear and dire
 *	consequences in lost memory blocks - a Windows no-no.
 *
 * ARGUMENTS:
 *	None, zippo, nil, nada, zilch, nothing.
 *
 * RETURNS:
 *	If you're lucky, and it's Tuesday, and I can program (highly unlikely),
 *	a handle (read pointer) to the update record.  Otherwize, a NULL pointer
 *	indicating that you're a memory piggy.
 *
 */
HUPDATE updateCreate(const HSESSION hSession)
	{
	HHUPDATE hUpd;

	// Get some space for the update record.

	hUpd = (HHUPDATE)malloc(sizeof(struct stUpdate));

	if (hUpd == (HHUPDATE)0)		  // release version returns NULL
		{
		assert(FALSE);
		return 0;
		}

	memset(hUpd, 0, sizeof(struct stUpdate));
	hUpd->hSession = hSession;
	updateReset(hUpd);

	return (HUPDATE)hUpd;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateDestory
 *
 * DESCRIPTION:
 *	Releases memory allocated for Update record.
 *
 * ARGUMENTS:
 *	HUPDATE 	hUpdate -- handle of update record to nuke.
 *
 * RETURNS:
 *	void
 */
void updateDestroy(const HUPDATE hUpdate)
	{
	HHUPDATE hUpd = (HHUPDATE)hUpdate;

	if (hUpd == (HHUPDATE)0)
		return;

	free(hUpd);
	hUpd = NULL;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	VerifyUpdateHdl
 *
 * DESCRIPTION:
 *	Verifies that we have a valid update handle.
 *
 * ARGUMENTS:
 *	hUpdate - external update handle
 *
 * RETURNS:
 *	Internal update handle or zero on error.
 *
 */
static HHUPDATE VerifyUpdateHdl(const HUPDATE hUpdate)
	{
	const HHUPDATE hUpd = (HHUPDATE)hUpdate;

	if (hUpd == 0)
		{
		assert(0);
		ExitProcess(1);
		}

	return hUpd;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateReset
 *
 * DESCRIPTION:
 *	Resets the update record to its initial state.
 *
 * ARGUMENTS:
 *	HUPDATE 	hUpdate -- handle of update record to reset.
 *
 * RETURNS:
 *	nothing
 *
 */
void updateReset(const HHUPDATE hUpd)
	{
	// Something tricky going on here.	I purposely don't reset the
	// sTopline, sRow, sCol, and usCType values so that they persist.
	// This avoids some problems on Client side of trying to figure
	// out what has changed.

	hUpd->bUpdateType = UPD_LINE;
	hUpd->fUpdateLock = FALSE;
	hUpd->stLine.iLine = -1;
	hUpd->fRealloc = FALSE;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateScroll
 *
 * DESCRIPTION:
 *	Modifies update record to reflect the specified scrolling operation.
 *
 * ARGUMENTS:
 *	Never argues.  Just does what it's told to do.
 *
 *	HUPDATE 	hUpdate 	-- the update record of course.
 *	int 		yBeg		-- begining line # of scroll region (inclusive)
 *	int 		yEnd		-- ending line # of scroll region (inclusive)
 *	int 		sScrlInc	-- Amount to scroll (negative or positive)
 *	int 		sTopline	-- line in image buf of screen row 0 (emu_imgtop)
 *	BOOL		fSave		-- wheather to save line to backscroll buffer.
 *
 * RETURNS:
 *	Nothing
 *
 */
void updateScroll(const HUPDATE hUpdate,
				  const int yBeg,
				  const int yEnd,
				  const int iScrlInc,
				  const int iTopLine,
				  const BOOL  fSave)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);
	struct stScrlMode *pstScrl;
	int  i, j;

	pstScrl = &hUpd->stScrl;

	DbgOutStr("iScrollInc=%d, yBeg=%d, yEnd=%d, iTopLine=%d\r\n",
		iScrlInc, yBeg, yEnd, iTopLine, 0);

	if (hUpd->bUpdateType != UPD_SCROLL)
		{
		DbgOutStr("Trans to Scroll Mode\r\n", 0, 0, 0, 0, 0);
		i = hUpd->stLine.iLine; 	// save this value for test below.

		// Setup initial scroll mode paramaters.

		hUpd->bUpdateType = UPD_SCROLL;
		pstScrl->iFirstLine = 0;
		pstScrl->iScrlInc = 0;
		pstScrl->iRgnScrlInc = 0;
		pstScrl->iBksScrlInc = 0;
		pstScrl->yBeg = 0;
		pstScrl->yEnd = 0;

		memset(pstScrl->auchLines, 0, UPD_MAXLINES * sizeof(BYTE));

		// If we were updating in line mode, make sure to mark that line
		// in scroll mode.

		if (i != -1)
			{
			pstScrl->auchLines[i] = (UCHAR)1;
			DbgOutStr("Trans -> %d\r\n", i, 0, 0, 0, 0);
			}
		}

	hUpd->iTopline = iTopLine;
	pstScrl->fSave = fSave;

	emuQueryRowsCols(sessQueryEmuHdl(hUpd->hSession), &j, &i);

	// Adjust for zero offset used by emulators...
	//
	j -= 1;

	/* -------------- Full screen scroll-up case ------------- */

	if (yBeg == 0 && yEnd == j && iScrlInc > 0)
		{
		pstScrl->yBeg = yBeg;
		pstScrl->yEnd = yEnd;

		pstScrl->iScrlInc += iScrlInc;

		pstScrl->iFirstLine =
			min(pstScrl->iFirstLine+iScrlInc, (UPD_MAXLINES-1)/2);
		}

	/* -------------- Region scroll and scroll-down ------------- */

	else
		{
		if (iScrlInc > 0)
			pstScrl->iRgnScrlInc += iScrlInc;

		memset(pstScrl->auchLines + pstScrl->iFirstLine + yBeg, 1,
			(abs(yEnd-yBeg)+1) * sizeof(UCHAR));
		}

	if ((pstScrl->iScrlInc + pstScrl->iRgnScrlInc) >= hUpd->iScrlMax)
		hUpd->fUpdateLock = TRUE;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateBackscroll
 *
 * DESCRIPTION:
 *	This function updates the number of lines scrolled in the backscroll
 *	buffer which may be different than the number of lines scrolled in
 *	the terminal.  I had to decouple the scrolling of these two regions
 *	to handle the goofy way internet systems clear the screen.	This
 *	function is only called by backscrlAdd().
 *
 * ARGUMENTS:
 *	HUPDATE 	hUpdate 	- the update record of course.
 *	int 		iLInes		- number of lines to scroll backscroll buffer.
 *
 * RETURNS:
 *	void
 *
 */
void updateBackscroll(const HUPDATE hUpdate, const int iLines)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);
	struct stScrlMode *pstScrl;
	int  i;

	pstScrl = &hUpd->stScrl;

	if (hUpd->bUpdateType != UPD_SCROLL)
		{
		DbgOutStr("Trans to Scroll Mode (BS)\r\n", 0, 0, 0, 0, 0);
		i = hUpd->stLine.iLine; 	// save this value for test below.

		// Setup initial scroll mode paramaters.

		hUpd->bUpdateType = UPD_SCROLL;
		pstScrl->iFirstLine = 0;
		pstScrl->iScrlInc = 0;
		pstScrl->iRgnScrlInc = 0;
		pstScrl->iBksScrlInc = 0;
		pstScrl->yBeg = 0;
		pstScrl->yEnd = 0;

		memset(pstScrl->auchLines, 0, UPD_MAXLINES * sizeof(BYTE));

		// If we were updating in line mode, make sure to mark that line
		// in scroll mode.

		if (i != -1)
			{
			pstScrl->auchLines[i] = (UCHAR)1;
			DbgOutStr("Trans -> %d\r\n", i, 0, 0, 0, 0);
			}
		}

	pstScrl->iBksScrlInc += iLines;
	DbgOutStr("iBksScrlInc = %d\r\n", pstScrl->iBksScrlInc, 0, 0, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateLine
 *
 * DESCRIPTION:
 *	Modifies the update record line array for the given line range.
 *
 * ARGUMENTS:
 *	HUPDATE 	hUpdate 	-- the update record of course.
 *	int 		yBeg		-- begining line # (inclusive)
 *	int 		yEnd		-- ending line # (inclusive)
 *
 * RETURNS:
 *	void
 *
 */
void updateLine(const HUPDATE hUpdate, const int yBeg, const int yEnd)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);
	BYTE *pauchLines;
	struct stScrlMode *pstScrl;

	assert(hUpd != (HHUPDATE)0);

	pstScrl = &hUpd->stScrl;			 // for speed...

	if (hUpd->bUpdateType != UPD_SCROLL)
		{
		DbgOutStr("Trans to Line Mode\r\n", 0, 0, 0, 0, 0);

		memset(pstScrl->auchLines, 0, UPD_MAXLINES);

		// 10/20/92 - This if statement fixes a bug that caused the
		// update records to miss a line that was being updated in
		// character mode and then jumping to another line - mrw.

		if (hUpd->stLine.iLine != -1)
			{
			pauchLines = pstScrl->auchLines + hUpd->stLine.iLine;
			*pauchLines = (UCHAR)1;
			DbgOutStr("Trans -> %d\r\n", hUpd->stLine.iLine, 0, 0, 0, 0);
			}

		hUpd->bUpdateType = UPD_SCROLL;

		pstScrl->yBeg	  = 0;
		pstScrl->yEnd	  = 0;
		pstScrl->iScrlInc = 0;
		pstScrl->iRgnScrlInc = 0;
		pstScrl->iBksScrlInc = 0;
		pstScrl->fSave	  = FALSE;
		pstScrl->iFirstLine = 0;
		}

	memset(pstScrl->auchLines+pstScrl->iFirstLine+yBeg, 1, yEnd-yBeg+1);
	DbgOutStr("Line -> %d - %d\r\n", yBeg, yEnd, 0, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateChar
 *
 * DESCRIPTION:
 *	Modifies the update record when it is in character mode.  This is a
 *	complex function but it handles a character a quickly as possible.
 *	Usually, only one or two checks are made.  Also, if this routine
 *	is called in line mode, it calls the appropriate line mode routine.
 *
 * ARGUMENTS:
 *	HUPDATE 	hUpdate 	-- handle to update buffer
 *	int 		yPos		-- line to modify
 *	int 		xPos		-- character position within line.
 *
 * RETURNS:
 *	TRUE on success
 *
 */
void updateChar(const HUPDATE hUpdate,
				const int yPos,
				const int xBegPos,
				const int xEndPos)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);
	struct stLineMode *pstLine;

	assert(hUpd != (HHUPDATE)0);
	assert(xBegPos <= xEndPos);

	// First check to see if we are in line mode.  If not, check if this
	// line is included in the UPD_SCROLL parameters of hUpd already.
	// The check is made to avoid the overhead of a function call if the
	// line is already set in the UPD_SCROLL parameters.

	if (hUpd->bUpdateType == UPD_SCROLL)
		{
		struct stScrlMode *pstScrl = &hUpd->stScrl;

		if (pstScrl->auchLines[yPos + pstScrl->iFirstLine] == 0)
			updateLine((HUPDATE)hUpd, yPos, yPos);

		return;
		}

	// Ok, it is just a line.  Update the UPD_LINE parameters.
	// Check to see that we have not jumped to a different line however.
	// If we have, we are no longer in UPD_LINE mode.

	pstLine = &hUpd->stLine;		 // for speed...

	if (yPos != pstLine->iLine)
		{
		// Check to see if sLine == -1.  This means the update buffer was
		// just flushed and reset and that this is the first change to come
		// in since that time.	Otherwise, we have more than one line in
		// our update region and have to jump to UPD_SCROLL mode.

		if (pstLine->iLine != -1)
			{
			updateLine((HUPDATE)hUpd, pstLine->iLine, pstLine->iLine);
			updateLine((HUPDATE)hUpd, yPos, yPos);
			}

		else
			{
			pstLine->iLine = yPos;
			pstLine->xBeg = xBegPos;
			pstLine->xEnd = xEndPos;

			DbgOutStr("Char -> iLine=%d, xBeg=%d, xEnd=%d\r\n",
			   yPos, xBegPos, xEndPos, 0, 0);
			}

		return;
		}

	// Ok, we've eliminated any conflicts.  Go ahead and update.

	if (xBegPos < pstLine->xBeg)
		pstLine->xBeg = xBegPos;

	if (xEndPos > pstLine->xEnd)
		pstLine->xEnd = xEndPos;

	DbgOutStr("Char -> iLine=%d, xBeg=%d, xEnd=%d\r\n",
	   yPos, xBegPos, xEndPos, 0, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateCursorPos
 *
 * DESCRIPTION:
 *	Sets the row and col values of the host cursor in the given update handle
 *
 * ARGUMENTS:
 *	HUPDATE 	hUpdate - need I say!
 *	int 		iRow	- host cursor row
 *	int 		iCol	- host cursor col
 *
 * RETURNS:
 *	nothing
 *
 */
void updateCursorPos(const HUPDATE hUpdate,
					 const int iRow,
					 const int iCol)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);

	hUpd->iRow = iRow;
	hUpd->iCol = iCol;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateSetReallocFlag
 *
 * DESCRIPTION:
 *	Sets the realloc flag in the update records.  This flag can only be
 *	cleared by a client update request.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int updateSetReallocFlag(const HUPDATE hUpdate, const BOOL fState)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);

	hUpd->fRealloc = fState ? TRUE : FALSE;
	NotifyClient(hUpd->hSession, EVENT_TERM_UPDATE, 0);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	updateSetScrlMax
 *
 * DESCRIPTION:
 *	Sets the upper limit on the number of lines that can be scrolled
 *	before the update records stop accepting input.
 *
 * ARGUMENTS:
 *	hUpdate 	- external update handle
 *	iScrlmax	- max limit
 *
 * RETURNS:
 *	0
 *
 */
int updateSetScrlMax(const HUPDATE hUpdate, const int iScrlMax)
	{
	const HHUPDATE hUpd = VerifyUpdateHdl(hUpdate);

	hUpd->iScrlMax = iScrlMax;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\timers.h ===
/* timers.h -- External definitions for multiplexed timer routines.
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *
 *	$Revision: 2 $
 *	$Date: 5/29/02 2:17p $
 */

#if !defined(TIMERS_H)
#define TIMERS_H 1

//	Function return values
#define TIMER_OK			0
#define TIMER_ERROR 		1
#define TIMER_NOMEM 		2
#define TIMER_NOWINTIMER	3

// Defined types
typedef void (CALLBACK *TIMERCALLBACK)(void *, long);


// Function protocols
extern int	TimerMuxCreate(const HWND        hWnd,
						   const UINT        uiID,
						   HTIMERMUX * const pHTM,
						   const HSESSION    hSession);
extern int	TimerMuxDestroy(HTIMERMUX * const phTM,
							const HSESSION    hSession);
extern void TimerMuxProc(const HSESSION hSession);
extern int	TimerCreate(const HSESSION 	    hSession,
							  HTIMER		* const phTimer,
							  long			lInterval,
						const TIMERCALLBACK pfCallback,
							  void			*pvData);
extern int TimerDestroy(HTIMER * const phTimer);

#endif	// !defined(TIMERS_H)

// End of timers.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\update.hh ===
/*	File: D:\WACKER\tdll\update.hh (Created: 09-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:36p $
 */

#if !defined(INCL_HHUPDATE)
#define INCL_HHUPDATE

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	Update record formats:

	The server hands display information to the client via update records.
	These update records describe changes since the last time the client
	requested display information.	To optimize this information exchange,
	the update record has several "personalities".	Scroll mode, sends
	information on a line basis.  Line mode sends information about a
	single line.  The server decides which to send.

 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define UPD_SCROLL		1			// scroll mode
#define UPD_LINE		2			// line mode

#define UPD_MAXLINES  	MAX_EMUROWS * 2		// This value must be twice the size
											// of the maximum number of rows for any
											// emulator in any mode!

struct stScrlMode
	{
	int   yBeg, yEnd,
		  iScrlInc, 				// iScrlInc for full screen scrolls.
		  iRgnScrlInc,				// iRgnScrlInc for region scrolls.
		  iBksScrlInc;				// amount backscrl has scrolled.
	BYTE  auchLines[UPD_MAXLINES];	// array used to record line changes.
	int   iFirstLine;				// points to first line in auchLines[].
	BOOL  fSave;					// if true, save changes to backscroll.
	};


struct stLineMode
	{
	int iLine, xBeg, xEnd;		  // range of columns within a line.
	};

struct stUpdate
	{
	BYTE		bUpdateType;
	int 		iTopline;			// always need to know the top line.
	int 		iLines; 			// number of lines in backscroll buffer
	int 		iRow;				// cursor row (offset from 0)
	int 		iCol;				// cursor col (offset from 0)
	int 		iCType; 			// cursor type
	int 		iScrlMax;			// maximum allowable amount to scroll.
	BOOL		fUpdateLock;		// update record full.
	BOOL		fRealloc;			// emulator resized its image buffers.

	struct stScrlMode	stScrl;
	struct stLineMode	stLine;

	HSESSION	hSession;
	};

typedef struct stUpdate *HHUPDATE;

/* --- Function Prototypes ---*/

void updateReset(const HHUPDATE hUpd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\translat.c ===
/*	File: D:\WACKER\tdll\translat.c (Created: 24-Aug-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 8 $
 *	$Date: 7/08/02 6:50p $
 */

#include <windows.h>
#pragma hdrstop

#include <stdlib.h>

#include "features.h"
#include "stdtyp.h"

#if defined(CHARACTER_TRANSLATION)

#include "mc.h"
#include "translat.h"
#include "session.h"
#include "tdll.h"
#include "htchar.h"
#include "misc.h"		// mscStripName()

#include "translat.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CreateTranslateHandle
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
HTRANSLATE CreateTranslateHandle(HSESSION hSession)
	{
	HHTRANSLATE hT = NULL;
	PST_TRANS_INT hI;
	size_t size;

	size  = sizeof(ST_TRANSLATE);
	size += sizeof(ST_TRANS_INT);
	size += sizeof(LONG);

	hT = malloc(size);

	if (hT)
		{
		memset(hT, 0, size);
		hI = (PST_TRANS_INT)(hT + 1);
		hI->hSession = hSession;
		InitTranslateHandle((HTRANSLATE)hT, TRUE);
		}

	return (HTRANSLATE)hT;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC int LoadTranslateDll(HTRANSLATE pH)
	{
	HHTRANSLATE      pstH = (HHTRANSLATE)pH;
	PST_TRANS_INT    hI;
	HANDLE           sH = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA  stF;
	TCHAR            szFileName[MAX_PATH];
	TCHAR            szPath[MAX_PATH];
	TCHAR           *pDllName = TEXT("HTRN_*.DLL");

    if (pstH == NULL)
        {
        assert(0);
        return -1;
        }

	hI = (PST_TRANS_INT)(pstH + 1);

	//
	// The translation DLL is not in the path, so check in the
	// module's directory.
	//

	GetModuleFileName((HINSTANCE)0, szFileName, MAX_PATH);
	GetFullPathName(szFileName, MAX_PATH, szPath, NULL);

	mscStripName(szPath);

	if (StrCharGetStrLength(szPath) + StrCharGetStrLength(pDllName) <= MAX_PATH)
		{
		StrCharCat(szPath, pDllName);

		sH = FindFirstFile(szPath, &stF);
		}

	//
	// The translation DLL is not in the module's directory, so see if
	// it is in the same location as the HyperTerminal executable (which
	// we extract from the registry).
	//
	if (sH == INVALID_HANDLE_VALUE)
		{
		DWORD dwSize = MAX_PATH;
		HKEY  hKey;

		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
						 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\HyperTrm.exe"),
						 0,
						 KEY_QUERY_VALUE,
						 &hKey) == ERROR_SUCCESS)
			{
			if (RegQueryValueEx(hKey, NULL, 0, 0,
								szFileName, &dwSize) == ERROR_SUCCESS)
				{
				if (szFileName[0] == TEXT('\"'))
					{
					StrCharCopyN(szPath, &szFileName[1], MAX_PATH);
					}
				else
					{
					StrCharCopyN(szPath, szFileName, MAX_PATH);
					}

				mscStripName(szPath);

				if (StrCharGetStrLength(szPath) + StrCharGetStrLength(pDllName) <= MAX_PATH)
					{
					StrCharCat(szPath, pDllName);

					sH = FindFirstFile(szPath, &stF);
					}
				}

			RegCloseKey(hKey);
			}
		}

	if (sH != INVALID_HANDLE_VALUE)
		{
		mscStripName(szPath);
		if (StrCharGetStrLength(szPath) +
			StrCharGetStrLength(stF.cFileName) <= MAX_PATH)
			{
			StrCharCat(szPath, stF.cFileName);
			hI->hInstance = LoadLibrary(szPath);
			if (hI->hInstance)
				{
				/* Load library succeeded */

				(FARPROC)pstH->pfnCreate = GetProcAddress(hI->hInstance,
												TEXT("transCreateHandle"));
				/* Do we need to error check these things ? */
				(FARPROC)pstH->pfnInit = GetProcAddress(hI->hInstance,
												TEXT("transInitHandle"));
				(FARPROC)pstH->pfnLoad = GetProcAddress(hI->hInstance,
												TEXT("transLoadHandle"));
				(FARPROC)pstH->pfnSave = GetProcAddress(hI->hInstance,
												TEXT("transSaveHandle"));
				(FARPROC)pstH->pfnDestroy = GetProcAddress(hI->hInstance,
												TEXT("transDestroyHandle"));
				(FARPROC)pstH->pfnDoDialog = GetProcAddress(hI->hInstance,
												TEXT("transDoDialog")); 
				(FARPROC)pstH->pfnIn = GetProcAddress(hI->hInstance,
												TEXT("transCharIn"));
				(FARPROC)pstH->pfnOut = GetProcAddress(hI->hInstance,
												TEXT("transCharOut"));

				pstH->pfnIsDeviceLoaded = translateInternalTrue;
				}
			else
				{
				pstH->pfnCreate = translateInternalVoid;
				pstH->pfnInit = translateInternalFalse;
				pstH->pfnLoad = translateInternalFalse;
				pstH->pfnSave = translateInternalFalse;
				pstH->pfnDestroy = translateInternalFalse;
				pstH->pfnDoDialog = translateInternalDoDlg;
				pstH->pfnIn = translateInternalCio;
				pstH->pfnOut = translateInternalCio;
				pstH->pfnIsDeviceLoaded = translateInternalFalse;
				}
			}
		FindClose(sH);
		}

	if ((*pstH->pfnIsDeviceLoaded)(pstH->pDllHandle))
		{
		/* TODO: create the new translation handle */
		pstH->pDllHandle = (*pstH->pfnCreate)(hI->hSession);

		if (pstH->pDllHandle)
			{
			(*pstH->pfnInit)(pstH->pDllHandle);
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	InitTranslateHandle
 *
 * DESCRIPTION:
 *	Returns the handle to a known state
 *
 * ARGUMENTS:
 *	A translate handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise a negative error code.
 *
 */
int InitTranslateHandle(HTRANSLATE pH, BOOL LoadDLL)
	{
	HHTRANSLATE pstH = (HHTRANSLATE)pH;
	PST_TRANS_INT hI;

    if (pstH == NULL)
        {
        assert(0);
        return -1;
        }

    hI = (PST_TRANS_INT)(pstH + 1);

	/*
	 * Clean up the old function if necessary
	 */
	if (pstH->pfnIsDeviceLoaded)
		{
		/* Try not to call a NULL pointer */
		if ((*pstH->pfnIsDeviceLoaded)(pstH->pDllHandle))
			{
			/* Internally, we always return a FALSE */
			if (pstH->pfnDestroy)
				{
				(*pstH->pfnDestroy)(pstH->pDllHandle);
				}
			hI = (PST_TRANS_INT)(pstH + 1);
			if (hI->hInstance)
				{
				FreeLibrary(hI->hInstance);
				}
			hI->hInstance = (HINSTANCE)0;
			}
		}

	/*
	 * Initialize the function pointers
	 */
	pstH->pDllHandle = (VOID *)0;

	pstH->pfnCreate = translateInternalVoid;
	pstH->pfnInit = translateInternalFalse;
	pstH->pfnLoad = translateInternalFalse;
	pstH->pfnSave = translateInternalFalse;
	pstH->pfnDestroy = translateInternalFalse;

	pstH->pfnIsDeviceLoaded = translateInternalFalse;
	pstH->pfnDoDialog = translateInternalDoDlg;

	pstH->pfnIn = translateInternalCio;
	pstH->pfnOut = translateInternalCio;

	if (LoadDLL == TRUE)
		{
		LoadTranslateDll((HTRANSLATE)pstH);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	LoadTranslateHandle
 *
 * DESCRIPTION:
 *	Chacks to see if an acceptable DLL is available and loads it if it is.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int LoadTranslateHandle(HTRANSLATE pH)
	{
	HHTRANSLATE pstH = (HHTRANSLATE)pH;
	PST_TRANS_INT hI;

    if (pstH == NULL)
        {
        assert(0);
        return -1;
        }

    hI = (PST_TRANS_INT)(pstH + 1);

	if ((*pstH->pfnIsDeviceLoaded)(pstH->pDllHandle))
		{
		/* TODO: create the new translation handle */
		// pstH->pDllHandle = (*pstH->pfnCreate)(hI->hSession);

		if (pstH->pDllHandle)
			{
			// (*pstH->pfnInit)(pstH->pDllHandle);
			(*pstH->pfnLoad)(pstH->pDllHandle);
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int SaveTranslateHandle(HTRANSLATE pH)
	{
	HHTRANSLATE pstH = (HHTRANSLATE)pH;

    if (pstH == NULL)
        {
        assert(0);
        return -1;
        }

    if ((*pstH->pfnIsDeviceLoaded)(pstH->pDllHandle))
		{
		if (pstH->pDllHandle)
			{
			(*pstH->pfnSave)(pstH->pDllHandle);
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int DestroyTranslateHandle(HTRANSLATE pH)
	{
	HHTRANSLATE pstH = (HHTRANSLATE)pH;

    if (pstH == NULL)
        {
        assert(0);
        return -1;
        }

    /* Set everything back to a known state */
	InitTranslateHandle(pH, FALSE);

    //
    // Don't forget to destroy the translate handle so we don't
    // have a memory leak. REV: 03/20/2001.
    //
	if (pstH->pfnDestroy)
		{
		(*pstH->pfnDestroy)(pstH->pDllHandle);
		}

    free(pstH);
	pstH = NULL;

	pH = NULL;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static int translateInternalDoDlg(HWND hWnd, VOID *pV)
	{
	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	translateInternalFalse
 *	translateInternalTrue
 *
 * DESCRIPTION:
 *	Dummy fill in routines that return a constant
 *
 * ARGUMENTS:
 *	pV	-- an unused DLL translation handle (probably a NULL)
 *
 * RETURNS:
 *	Either TRUE or FALSE, depending.
 *
 */
static int translateInternalFalse(VOID *pV)
	{
	return FALSE;
	}

static int translateInternalTrue(VOID *pV)
	{
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	translateInternalVoid
 *
 * DESCRIPTION:
 *	A dummy stub to fill in for a handle creation routine
 *
 * ARGUMENTS:
 *	hSession	-- the ever popular session handle
 *
 * RETURNS:
 *	Always returns a NULL pointer
 *
 */
static VOID *translateInternalVoid(HSESSION hSession)
	{
	return (VOID *)0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	translateInternalCio
 *
 * DESCRIPTION:
 *	Internal character in and character out function.  This is simply a
 *	loopback function that is used as a dummy function if the translation
 *	DLL is not available.  It is used as the default in the initialized
 *	but not loaded structure.
 *
 * ARGUMENTS:
 *	pV	-- handle to the translation DLL (nothing in this case)
 *	cC	-- the character to be translated
 *	nR	-- the number of characters returned (returned to caller)
 *	nS	-- maximum number of characters that can be returned
 *	pC	-- where to return the returned characters
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise a negative error code
 *
 */
static int translateInternalCio(VOID *pV, TCHAR cC, int *nR, int nS, TCHAR *pC)
	{
	if (nS > 0)
		{
		*nR = 1;
		*pC = cC;
		return 0;
		}
	return (-1);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\update.h ===
/*	File: D:\WACKER\tdll\update.h (Created: 09-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:40p $
 */

#if !defined(INCL_HUPDATE)
#define INCL_HUPDATE

// Function prototypes...

HUPDATE updateCreate		(const HSESSION);
void	updateDestroy		(const HUPDATE hUpdate);

void	updateScroll		(const HUPDATE hUpdate,
							 const int yBeg,
							 const int yEnd,
							 const int iScrlInc,
							 const int iTopRow,
							 const BOOL fSave
							);

void	updateLine			(const HUPDATE hUpdate,
							 const int yBeg,
							 const int yEnd
							);

void	updateChar			(const HUPDATE hUpdate,
							 const int yPos,
							 const int xBegPos,
							 const int xEndPos
							);

void	updateCursorPos 	(const HUPDATE hUpdate,
							 const int sRow,
							 const int sCol
							);

int  updateSetReallocFlag(const HUPDATE hUpdate, const BOOL fState);
BOOL updateIsLocked 	 (const HUPDATE hUpdate);
int  updateSetLock		 (const HUPDATE hUpdate, const BOOL fState);
int  updateSetScrlMax	 (const HUPDATE hUpdate, const int iScrlMax);

void updateBackscroll	 (const HUPDATE hUpdate, const int iLines);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\upgrddlg.h ===
#if !defined(INCL_UPGRDDLG)
#define INCL_UPGRDDLG

/*	File: D:\WACKER\tdll\upgrddlg.h (Created: 02-Dec-1996 by cab)
 *
 *	Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *  Description:
 *      Implements the "Upgrade Information" dialog. This dialog
 *      displays a simple rich text edit control and displays
 *      information on how to upgrade to our latest and greatest
 *      product.
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:21p $
 */

INT_PTR DoUpgradeDialog(HWND hwndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\vu_meter.h ===
/*	File: C:|WACKER\TDLL\VU_METER.C (Created: 10-JAN-1994)
 *	Created from:
 *	File: C:\HA5G\ha5g\s_text.h (Created: 27-SEP-1991)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 10/27/00 1:23p $
 */

#define WM_VU_SETMAXRANGE		(WM_USER+0x390)
#define WM_VU_SETHIGHVALUE		(WM_USER+0x391)
#define WM_VU_SETCURVALUE		(WM_USER+0x392)
#define WM_VU_SET_DEPTH 		(WM_USER+0x393)

extern BOOL RegisterVuMeterClass(HANDLE hInstance);
extern BOOL UnregisterVuMeterClass(HANDLE hInstance);

extern LRESULT CALLBACK VuMeterWndProc(HWND hWnd,
			      		    		UINT wMsg,
				    				WPARAM wPar,
					    			LPARAM lPar);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\vu_meter.hh ===
/*	File: C:\WACKER\TDLL\VU_METER.HH (Created: 10-Jan-1994)
 *	Created from:
 *	File: C:\HA5G\ha5g\s_text.hh (Created: 27-SEP-1991)
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:40p $
 */

// #define	STXT_DEF_DEPTH		3
#define	STXT_DEF_DEPTH		1

struct s_vumeter
	{
	ULONG	ulCheck;			/* Validity check field */
	ULONG	cBackGround;		/* Fill color for background */
	ULONG	cFillColor; 		/* Color to use for progress display */
	ULONG	cRefillColor;		/* Color used in retries progress display */
	ULONG	cMarkColor; 		/* Color used when retries are going */
	ULONG	cUpperEdge; 		/* Upper and left edge 3D border color */
	ULONG	cLowerEdge; 		/* Lower and right edge 3D border color */
	ULONG	ulMaxRange; 		/* Maximum range value */
	ULONG	ulHiValue;			/* Highest value so far */
	ULONG	ulCurValue; 		/* Current value */
	USHORT	usDepth;
	};

#define VUMETER_VALID	0x744D7556

typedef struct s_vumeter VUMETER;
typedef VUMETER FAR *LPVM;

#define VUMETER_OK(x)	((x!=NULL)&&(x->ulCheck==VUMETER_VALID))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\xfdspdlg.h ===
/*	C:\WACKER\TDLL\XFDSPDLG.H (Created: 10-Jan-1994)
 *	xfer_dsp.h -- outer include file for various transfer related operations
 *
 *	Copyright 1994 by Hilgraeve, Inc. - Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 8/23/01 12:21p $
 *
 */

#if !defined(XFER_DSP_H_DEFINED)
#define XFER_DSP_H_DEFINED

/*
 * This is a list of control IDs used in the display
 */

#define	XFR_DISPLAY_CLASS		"XfrDisplayClass"

INT_PTR CALLBACK XfrDisplayDlg(HWND, UINT, WPARAM, LPARAM);

// extern HWND xfrReceiveCreateDisplay(HSESSION);
// extern HWND xfrSendCreateDisplay(HSESSION);

// extern VOID xfrNewDisplayWindow(HWND, INT, LPSTR, DLGPROC);

/* internal message used in shutdown processing */
#define XFR_SHUTDOWN					200

/*
 * This is a list of user defined messages used internally by the transfer
 * display functions.
 */

#define	WM_DLG_TO_DISPLAY				WM_USER+161		/* wMsg value */

#define	XFR_BUTTON_PUSHED				1				/* wPar value */
														/* lPar is button ID */

#define	XFR_UPDATE_DLG					2				/* wPar value */
														/* a fake message */

#define	XFR_SINGLE_TO_DOUBLE			3				/* wPar value */




#define	WM_DISPLAY_TO_DLG				WM_USER+162		/* wMsg value */

#define	XFR_UPDATE_DATA					1				/* wPar value */
														/* lPar is pointer */

#define	XFR_FORCE_DATA					2				/* wPar value */
														/* lPar is pointer */

#define	XFR_GET_DATA					3				/* wPar value */

#define XFER_LOST_CARRIER               WM_USER+163

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\vu_meter.c ===
/*  File: \WACKER\TDLL\VU_METER.C (Created: 10-JAN-1994)
 *	Created from:
 *	File: C:\HA5G\ha5g\stxtproc.c (Created: 27-SEP-1991)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 4/16/02 2:41p $
 */

#include <windows.h>
#pragma hdrstop

#define WE_DRAW_EDGE	1

#include "stdtyp.h"
#include "mc.h"
#include <tdll\assert.h>

#include <term\xfer_dlg.h>

#include "vu_meter.h"
#include "vu_meter.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	RegisterVuMeterClass
 *
 * DESCRIPTION:
 *	Registers the VU Meter window class.  (No kidding!)
 *
 * PARAMETERS:
 *	Hinstance -- the instance handle
 *
 * RETURNS:
 *	Whatever RegisterClass returns.
 */
BOOL RegisterVuMeterClass(HANDLE hInstance)
	{
	BOOL            bRetVal = TRUE;
	WNDCLASSEX      wndclass;

	memset(&wndclass, 0, sizeof(WNDCLASSEX));
	wndclass.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hInstance, VU_METER_CLASS, &wndclass) == FALSE)
		{
		if (bRetVal)
			{
			wndclass.style          = CS_HREDRAW | CS_VREDRAW;
			wndclass.lpfnWndProc    = VuMeterWndProc;
			wndclass.cbClsExtra     = 0;
			wndclass.cbWndExtra     = sizeof(VOID FAR *);
			wndclass.hIcon          = NULL;
			wndclass.hInstance      = hInstance;
			wndclass.hCursor        = NULL;
			wndclass.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
			wndclass.lpszMenuName   = NULL;
			wndclass.lpszClassName  = VU_METER_CLASS;
			wndclass.hIconSm        = NULL;

			bRetVal = RegisterClassEx(&wndclass);
			}
		}

	return bRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	VuMeterWndProc
 *
 * DESCRIPTION:
 *	Window procedure for implementing our own internal VU Meter.
 *
 * ARGUEMENTS:
 *	The standard window proc stuff.
 *
 * RETURNS:
 *
 */
LRESULT CALLBACK VuMeterWndProc(HWND hWnd,
	     	    			   UINT wMsg,
		    				   WPARAM wPar,
							   LPARAM lPar)
	{
	LPVM	psV;

	switch (wMsg)
		{
		case WM_CREATE:
			psV = (LPVM)malloc(sizeof(VUMETER));
			SetWindowLongPtr(hWnd, 0, (LONG_PTR)psV);

			if (psV)
				{
				psV->ulCheck = VUMETER_VALID;

#if FALSE
				/* Old colors */
				psV->cBackGround  = 0x00000000;
				psV->cFillColor   = 0x0000FF00;
				psV->cRefillColor = 0x00800080;
				psV->cMarkColor   = 0x0000FFFF;

				psV->cUpperEdge   = 0x00808080;
				psV->cLowerEdge   = 0x00FFFFFF;

#endif
				psV->cBackGround  = GetSysColor(COLOR_3DFACE);
				psV->cFillColor   = GetSysColor(COLOR_3DDKSHADOW);
				psV->cRefillColor = 0x00800080;		/* Unused */
				psV->cMarkColor   = GetSysColor(COLOR_3DSHADOW);

				psV->cUpperEdge   = GetSysColor(COLOR_3DSHADOW);
				psV->cLowerEdge   = GetSysColor(COLOR_3DHILIGHT);

				psV->ulMaxRange   = 0;
				psV->ulHiValue	  = 0;
				psV->ulCurValue   = 0;

				psV->usDepth	  = STXT_DEF_DEPTH;
			}

			break;

		case WM_DESTROY:
			psV = (LPVM)GetWindowLongPtr(hWnd, 0);
			if (VUMETER_OK(psV))
				{
				free(psV);
				psV = NULL;
				}
			SetWindowLongPtr(hWnd, 0, (LONG_PTR)0L);
			break;

		case WM_GETDLGCODE:
			/* Static controls don't want any of these */
			return DLGC_STATIC;

		case WM_PAINT:
			{
			int nEnd;
			int nIndex;
			int nFill;
			int nReFill;
#if defined(WE_DRAW_EDGE)
			int nHeight;
			int nWidth;
#endif
			int nStep;
			RECT rcC;
			RECT rcE;
			RECT rcD;
			PAINTSTRUCT ps;
			HBRUSH hBrush;

			BeginPaint(hWnd, &ps);

			psV = (LPVM)GetWindowLongPtr(hWnd, 0);
			if (VUMETER_OK(psV))
				{
				/*
				 * We erase/fill in the invalid region
				 */
				hBrush = CreateSolidBrush(psV->cBackGround);
				FillRect(ps.hdc, &ps.rcPaint, hBrush);
				DeleteObject(hBrush);

#if defined(WE_DRAW_EDGE)
				/*
				 * We redraw the edging completely, every time
				 */
				nHeight = (int)GetSystemMetrics(SM_CYBORDER) * (int)psV->usDepth;
				nWidth	= (int)GetSystemMetrics(SM_CXBORDER) * (int)psV->usDepth;

				GetClientRect(hWnd, &rcC);

				/* Draw the top edge */
				hBrush = CreateSolidBrush(psV->cUpperEdge);
				for (nIndex = 0; nIndex < nHeight; nIndex += 1)
					{
					rcE = rcC;
					rcE.top = nIndex;
					rcE.bottom = nIndex + 1;
					rcE.right -= nIndex;
					FillRect(ps.hdc, &rcE, hBrush);
					}
				/* Draw the left edge */
				for (nIndex = 0; nIndex < nWidth; nIndex += 1)
					{
					rcE = rcC;
					rcE.left = nIndex;
					rcE.right = nIndex + 1;
					rcE.bottom -= nIndex;
					FillRect(ps.hdc, &rcE, hBrush);
					}
				DeleteObject(hBrush);
				/* Draw the bottom edge */
				hBrush = CreateSolidBrush(psV->cLowerEdge);
				for (nIndex = 0; nIndex < nHeight; nIndex += 1)
					{
					rcE = rcC;
					rcE.top = rcE.bottom - nIndex - 1;
					rcE.bottom = rcE.bottom - nIndex;
					rcE.left += nIndex + 1;
					FillRect(ps.hdc, &rcE, hBrush);
					}
				/* Draw the right edge */
				for (nIndex = 0; nIndex < nWidth; nIndex += 1)
					{
					rcE = rcC;
					rcE.left = rcE.right - nIndex - 1;
					rcE.right = rcE.right - nIndex;
					rcE.top += nIndex + 1;
					FillRect(ps.hdc, &rcE, hBrush);
					}
				DeleteObject(hBrush);
#else

				DrawEdge(ps.hdc, &ps.rcPaint,
						 EDGE_SUNKEN,
						 BF_SOFT | BF_RECT);

#endif

				/*
				 * Try and fill in the progress.  This is done by building
				 * a loop the would rewrite all of the lighted 'pixels' that
				 * would normally be light.  This is then modified by checking
				 * the intersection of the lighted region and the invalid area.
				 * If they interset, do the write, otherwise skip it.
				 */
				if ((psV->ulMaxRange > 0) &&
					(psV->ulCurValue > 0) &&
					(psV->ulHiValue > 0))
					{
					HBRUSH hbFill;
					HBRUSH hbRefill;

					/* These lines must match those in the WM_VU_SETCURVALUE */
					GetClientRect(hWnd, &rcC);
					InflateRect(&rcC,
								-((INT)psV->usDepth),
								-((INT)psV->usDepth));
					nEnd = rcC.right - rcC.left;

					nFill = (int)(((ULONG)nEnd * psV->ulCurValue) /
												psV->ulMaxRange);
					nReFill = (int)(((ULONG)nEnd * psV->ulHiValue) /
												psV->ulMaxRange);
					
					/* Build simulated LEDs */
					hbFill = CreateSolidBrush(psV->cFillColor);
					hbRefill = CreateSolidBrush(psV->cMarkColor);

					rcE = rcC;
					rcE.right = rcE.left + ((rcE.bottom - rcE.top) / 2);
					InflateRect(&rcE,
								(int)(rcE.left - rcE.right) / 3,
								(int)(rcE.top - rcE.bottom) / 3);
					nStep = rcE.right - rcE.left;
					nStep *= 2;

					/*
					 * TODO: figure out how to set the beginning and end of
					 * this loop to eliminate dead cycles
					 */
					for (nIndex = 0; nIndex < nEnd; nIndex += nStep)
						{
						if (IntersectRect(&rcD, &rcE, &ps.rcPaint) != 0)
							{
							hBrush = hbFill;
							if (nIndex > nFill)
								{
								hBrush = hbRefill;
								}
							if (nIndex > nReFill)
								{
								hBrush = NULL;
								}
							if (hBrush != NULL)
								{
								FillRect(ps.hdc, &rcE, hBrush);
								}
							}
						OffsetRect(&rcE, nStep, 0);
						}
					DeleteObject(hbFill);
					DeleteObject(hbRefill);
					hBrush = NULL;
					}
				}

			EndPaint(hWnd, &ps);
			}
			break;

		case WM_VU_SETMAXRANGE:
			psV = (LPVM)GetWindowLongPtr(hWnd, 0);
			if (VUMETER_OK(psV))
				{
				psV->ulMaxRange = (ULONG)lPar;
				psV->ulHiValue	= 0;
				psV->ulCurValue = 0;
				InvalidateRect(hWnd, NULL, FALSE);
				DbgOutStr("VUmeter max range %ld\r\n", lPar, 0, 0, 0, 0);
				}
			break;

		case WM_VU_SETHIGHVALUE:
			psV = (LPVM)GetWindowLongPtr(hWnd, 0);
			if (VUMETER_OK(psV))
				{
				if ((ULONG)lPar > psV->ulMaxRange)
					psV->ulHiValue = psV->ulMaxRange;
				else
					psV->ulHiValue = (ULONG)lPar;

				if (psV->ulCurValue > psV->ulHiValue)
					psV->ulCurValue = psV->ulHiValue;
				InvalidateRect(hWnd, NULL, FALSE);
				DbgOutStr("VUmeter high value %ld\r\n", lPar, 0, 0, 0, 0);
				}
			break;

		case WM_VU_SETCURVALUE:
			/*
			 * There are two separate tasks to be performed here.
			 * 1. Make sure the values are correctly updated.
			 * 2. Invalidate the correct region.
			 */
			psV = (LPVM)GetWindowLongPtr(hWnd, 0);
			if (VUMETER_OK(psV))
				{
				ULONG ulOldValue;
				ULONG ulLeft;
				ULONG ulRight;
				RECT rc;
				INT base;

				if (psV->ulMaxRange == 0)
					break;

				ulOldValue = psV->ulCurValue;

				if ((ULONG)lPar > psV->ulMaxRange)
					psV->ulCurValue = psV->ulMaxRange;
				else
					psV->ulCurValue = (ULONG)lPar;

				if (psV->ulCurValue > psV->ulHiValue)
					psV->ulHiValue = psV->ulCurValue;

				ulLeft = ulOldValue;			/* Get the low end */
				if (psV->ulCurValue < ulLeft)
					ulLeft = psV->ulCurValue;
				ulRight = ulOldValue;			/* Get the high end */
				if (psV->ulCurValue > ulRight)
					ulRight = psV->ulCurValue;

				/*
				 * Check for early exit
				 */
				if ((psV->ulCurValue == 0) && (psV->ulHiValue == 0))
					break;

				/* These lines must match those in WM_PAINT */
				GetClientRect(hWnd, &rc);
				InflateRect(&rc, -((INT)psV->usDepth), -((INT)psV->usDepth));
				base = rc.right - rc.left;

				ulLeft = ((ULONG)base * ulLeft) / psV->ulMaxRange;
				ulRight = ((ULONG)base * ulRight) / psV->ulMaxRange;

				base = rc.left;
				rc.left = base + (INT)ulLeft;
#if !defined(MIRRORS)
				rc.right = base + (INT)ulRight;
#endif

				InvalidateRect(hWnd, &rc, FALSE);
				DbgOutStr("VUmeter current value %ld\r\n", lPar, 0, 0, 0, 0);
				}
			break;

		case WM_VU_SET_DEPTH:
			psV = (LPVM)GetWindowLongPtr(hWnd, 0);
			if (VUMETER_OK(psV))
				{
				if (wPar < 7)
					{
					psV->usDepth = (USHORT)wPar;
					InvalidateRect(hWnd, NULL, FALSE);
					}
				}
			break;

		default:
			break;
		}

	return DefWindowProc(hWnd, wMsg, wPar, (LPARAM)lPar);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	UnregisterVuMeterClass
 *
 * DESCRIPTION:
 *	Registers the VU Meter window class.  (No kidding!)
 *
 * PARAMETERS:
 *	Hinstance -- the instance handle
 *
 * RETURNS:
 *	Whatever RegisterClass returns.
 */
BOOL UnregisterVuMeterClass(HANDLE hInstance)
	{
	return UnregisterClass(VU_METER_CLASS, hInstance);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\xfdspdlg.hh ===
/* C:\WACKER\TDLL\XFDSPDLG.HH (Created: 10-Jan-1994)
 * Created from:
 * s_r_dlg.h - various stuff used in sends and recieves
 *
 *	Copyright 1994 by Hilgraeve, Inc -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 5/04/01 3:36p $
 */

/*
 * This data is getting moved into the structure in xfer_msc.hh.  It is here
 * only as a transitional device.
 */

struct stReceiveDisplayRecord
	{
	/*
	 * First, we have the bit flags indicating which fields have changed
	 */
	int 	bChecktype		: 1;
	int 	bErrorCnt		: 1;
	int 	bPcktErrCnt		: 1;
	int 	bLastErrtype	: 1;
	int 	bVirScan		: 1;
	int 	bTotalSize		: 1;
	int 	bTotalSoFar		: 1;
	int 	bFileSize		: 1;
	int 	bFileSoFar		: 1;
	int 	bPacketNumber	: 1;
	int 	bTotalCnt		: 1;
	int 	bFileCnt		: 1;
	int 	bEvent			: 1;
	int 	bStatus			: 1;
	int 	bElapsedTime	: 1;
	int 	bRemainingTime	: 1;
	int 	bThroughput		: 1;
	int 	bProtocol		: 1;
	int 	bMessage		: 1;
	int 	bOurName		: 1;
	int 	bTheirName		: 1;

	/*
	 * Then, we have the data fields themselves
	 */
	int 	wChecktype; 				/* Added for XMODEM */
	int 	wErrorCnt;
	int 	wPcktErrCnt;				/* Added for XMODEM */
	int 	wLastErrtype;				/* Added for XMODEM */
	int 	wVirScan;
	long	lTotalSize;
	long	lTotalSoFar;
	long	lFileSize;
	long	lFileSoFar;
	long	lPacketNumber;				/* Added for XMODEM */
	int 	wTotalCnt;
	int 	wFileCnt;
	int 	wEvent;
	int 	wStatus;
	long	lElapsedTime;
	long	lRemainingTime;
	long	lThroughput;
	int 	uProtocol;
	TCHAR	acMessage[80];
	TCHAR	acOurName[256];
	TCHAR	acTheirName[256];
	};

typedef struct stReceiveDisplayRecord	sRD;
typedef sRD FAR *psRD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\xfer_msc.hh ===
/*	File: D:\WACKER\tdll\xfer_msc.hh (Created: 30-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 4/25/02 11:26a $
 */

 #include "tdll\sess_ids.h"




#define XFER_MESSAGE_LENGTH 80
#define XFER_NAME_LENGTH 256



/*
 * All the structures in this structure are defined in other modules.  They
 * all conform to the single rule that the first element of the structure is
 * an integer that contains the size of the structure.
 */

struct stSizeType
	{
	int nSize;
	};

typedef struct stSizeType SZ_TYPE;

struct stXferData
	{

	HSESSION hSession;

	/* This holds the generic transfer parameters */
	SZ_TYPE		*xfer_old_params;	/* for conditional save */
	SZ_TYPE		*xfer_params;		/* the parameters currently in use */

	/* TODO: add stuff for conditional save */

	/* This holds the protocol specific parameters */
	SZ_TYPE		*xfer_proto_params[SFID_PROTO_PARAMS_END - SFID_PROTO_PARAMS];

#define XFER_NONE               0
#define	XFER_SEND		1
#define	XFER_RECV		2
	int nDirection;

#define XFER_ABORT              1
#define XFER_SKIP               2
#define XFER_NO_AUTOSTART       3
        int nUserCancel;                        /* User canceled the transfer */

        int nCarrierLost;                       /* Carrier has been lost */


	/* This holds the stuff for the send list */
        int nSendListCount;                     /* How many files so far */
        TCHAR **acSendNames;                    /* Pointer to list block */

        VOID *pXferStuff;                       /* Set by the other side for storage */

	/*
	 * This block of stuff is used by the transfer displays.
	 */
        HWND hwndXfrDisplay;                    /* handle of the display window */

	int nLgSingleTemplate;			/* template ID for single file transfer */
	int nLgMultiTemplate;			/* template ID for multiple file xfer */

#if FALSE
	/* Removed and switched to integers */
	LPCSTR pszLgSingleTemplate;		/* template for single file transfer */
	LPCSTR pszLgMultiTemplate;		/* template for multiple file transfer */
#if FALSE
	/* Size change is not supported in Lower Wacker */
	LPTSTR pszSmSingleTemplate;
	LPTSTR pszSmMultiTemplate;
#endif
#endif

        int nStatusBase;                        /* start of status ID list */
        int nEventBase;                         /* start of event ID list */

        int nOldBps;                            /* Saved copy of the following */
        int nBps;                               /* TRUE to display as BPS vs CPS */

        int nExpanded;                          /* Set if we have already expanded */

        int nCancel;                            /* the ever popular cancel option */
        int nSkip;                              /* TRUE if we want to skip this file */

        int nPerCent;                           /* Percent done, if we know it */

        int nClose;                             /* The transfer finished */
        int nCloseStatus;                       /* The closing status */
	/*
	 * First, we have the bit flags indicating which fields have changed
	 */
	int		bChecktype		: 1;
	int		bErrorCnt		: 1;
	int		bPcktErrCnt		: 1;
	int		bLastErrtype	: 1;
	int		bTotalSize		: 1;
	int		bTotalSoFar		: 1;
	int		bFileSize		: 1;
	int		bFileSoFar		: 1;
	int		bPacketNumber	: 1;
	int		bTotalCnt		: 1;
	int		bFileCnt		: 1;
	int		bEvent			: 1;
	int		bStatus			: 1;
	int		bElapsedTime	: 1;
	int		bRemainingTime	: 1;
	int		bThroughput		: 1;
	int		bProtocol		: 1;
	int		bMessage		: 1;
	int		bOurName		: 1;
	int		bTheirName		: 1;

	/*
	 * Then, we have the data fields themselves
	 */
        int             wChecktype;             /* Added for XMODEM */
        int             wErrorCnt;
        int             wPcktErrCnt;            /* Added for XMODEM */
        int             wLastErrtype;           /* Added for XMODEM */
        long            lTotalSize;
        long            lTotalSoFar;
        long            lFileSize;
        long            lFileSoFar;
        long            lPacketNumber;          /* Added for XMODEM */
        int             wTotalCnt;
        int             wFileCnt;
        int             wEvent;
        int             wStatus;
        long            lElapsedTime;
        long            lRemainingTime;
        long            lThroughput;
        int             uProtocol;

	TCHAR	acMessage[XFER_MESSAGE_LENGTH];
	TCHAR	acOurName[XFER_NAME_LENGTH];
	TCHAR	acTheirName[XFER_NAME_LENGTH];
        /*
	 * End of the transfer display data !!
	 */

	};

typedef struct stXferData XD_TYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\xfer_msc.c ===
/*	File: D:\WACKER\tdll\xfer_msc.c (Created: 28-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 24 $
 *	$Date: 5/15/02 4:38p $
 */

#include <windows.h>
#pragma hdrstop

#include <term\res.h>
#include "stdtyp.h"
#include "session.h"
#include "mc.h"
#include "tdll.h"
#include "htchar.h"
#include "cloop.h"
#include "tdll\assert.h"
#include "globals.h"
#include "errorbox.h"
#include "file_msc.h"
#include "xfdspdlg.h"
#include "sf.h"

#include "sess_ids.h"

#include "misc.h"

#include "xfer\xfer.h"
#include "xfer\xfer.hh"
#include "xfer_msc.h"
#include "xfer_msc.hh"
#include "xfer\xfer_tsc.h"

void xferCancelAutoStart(HSESSION hSession, long lProtocol);
static void xfrInitDspStruct(HXFER hXfer);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 *
 *                          X F E R _ M S C . C
 *
 *	This module contains various functions that are used in this dll in order
 *	to implement transfers.  While most of the code exists in the dialog procs
 *	for the Transfer Send and Transfer Receive dialogs, some is here to make
 *	things a little bit easier.
 *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#define	LIST_CHUNK	2

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CreateXferHdl
 *
 * DESCRIPTION:
 *	This function creates an "empty" Xfer handle.  It has stuff in it.  It
 *	just didn't come from the user.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	A blinded pointer to the Xfer handle.
 *
 */
HXFER CreateXferHdl(const HSESSION hSession)
	{
	int nRet;
	XD_TYPE *pX;

	pX = (XD_TYPE *)malloc(sizeof(XD_TYPE));
	assert(pX);
	if (pX)
		{
		memset(pX, 0, sizeof(XD_TYPE));

		nRet = InitializeXferHdl(hSession, (HXFER)pX);
		if (nRet != 0)
            {
			goto CXHexit;
            }

	    pX->nSendListCount = 0;
	    pX->acSendNames = NULL;

        // Make sure to set the Transfer direction to none. REV: 02/14/2001
        pX->nDirection = XFER_NONE;
		}

	return (HXFER)pX;
CXHexit:
	if (pX)
		{
		if (pX->xfer_params)
			{
			free(pX->xfer_params);
			pX->xfer_params = NULL;
			}
		if (pX->xfer_old_params)
			{
			free(pX->xfer_old_params);
			pX->xfer_old_params = NULL;
			}
		free(pX);
		pX = NULL;
		}
	return (HXFER)0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	InitializeXferHdl
 *
 * DESCRIPTION:
 *	This function initializes the Xfer handle to a known state.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	hXfer    -- the Xfer handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
INT InitializeXferHdl(const HSESSION hSession, HXFER hXfer)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)hXfer;

	assert(pX);

	if (pX == 0)
        {
        return -2;
        }
    else
		{
		int nIdx;

        if (pX->xfer_params)
            {
            free(pX->xfer_params);
            pX->xfer_params = NULL;
            }

        if (pX->xfer_old_params)
            {
            free(pX->xfer_old_params);
            pX->xfer_old_params = NULL;
            }

		//
		// We don't want to clear out the xfer_proto_params
		// since they do not change, but since memset is used
		// below, we must. REV: 4/10/2002
		//
		if (pX->xfer_proto_params)
			{
			/*
			 * Loop through the protocol specific stuff
			 */
			for (nIdx = SFID_PROTO_PARAMS_END - SFID_PROTO_PARAMS; nIdx >= 0; nIdx--)
				{
				if (pX->xfer_proto_params[nIdx])
					{
					free(pX->xfer_proto_params[nIdx]);
					pX->xfer_proto_params[nIdx] = NULL;
					}
				}
			}

		if (pX->acSendNames)
			{
			int nIdx;

			/* Clear list */
			for (nIdx = pX->nSendListCount - 1; nIdx >= 0; nIdx--)
				{
				if (pX->acSendNames[nIdx])
					{
					free(pX->acSendNames[nIdx]);
					pX->acSendNames[nIdx] = NULL;
					}
				pX->nSendListCount = nIdx;
				}

			free(pX->acSendNames);
			pX->acSendNames = NULL;
			pX->nSendListCount = 0;
			}

		if (pX->pXferStuff)
			{
			free(pX->pXferStuff);
			pX->pXferStuff = NULL;
			}

		//
		// TODO:REV 4/10/2002 This should be put into a function to
		// initialize the structure instead of just using memset.
		//
        memset(pX, 0, sizeof(XD_TYPE));

		pX->hSession = hSession;

		pX->nBps = 0;
		pX->nOldBps = pX->nBps;

		xfrQueryParameters(sessQueryXferHdl(hSession), &pX->xfer_params);
		if (pX->xfer_params == (SZ_TYPE *)0)
			return -1;

		pX->xfer_old_params = malloc(pX->xfer_params->nSize);
		if (pX->xfer_old_params == (SZ_TYPE *)0)
			{
			free(pX->xfer_params);
			pX->xfer_params = (SZ_TYPE *)0;
			return -1;
			}
		MemCopy(pX->xfer_old_params, pX->xfer_params, pX->xfer_params->nSize);

		pX->nSendListCount = 0;
	    pX->acSendNames = NULL;

        // Make sure to set the Transfer direction to none. REV: 02/14/2001
        pX->nDirection = XFER_NONE;
        }

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	LoadXferHdl
 *
 * DESCRIPTION:
 *	This function loads data from the session file into the Xfer handle.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
INT LoadXferHdl(HXFER hXfer)
	{
	long lSize;
	XD_TYPE *pX;
	SZ_TYPE *pZ;

	pX = (XD_TYPE *)hXfer;

	if (pX)
		{

		InitializeXferHdl(pX->hSession, hXfer);

		/*
		 * Try and load up the general parameters first
		 */
		pZ = (SZ_TYPE *)0;
#if FALSE
		/* removed as per MRW request */
		sfdGetDataBlock(pX->hSession,
						SFID_XFER_PARAMS,
						(void **)&pZ);
#endif
		pZ = NULL;
		lSize = 0;
		sfGetSessionItem(sessQuerySysFileHdl(pX->hSession),
						SFID_XFER_PARAMS,
						&lSize,
						NULL);
		if (lSize > 0)
			{
			size_t lXfrParamsStructSize = sizeof(XFR_PARAMS);
			assert((size_t)lSize == lXfrParamsStructSize);

			if ((size_t)lSize < lXfrParamsStructSize)
				{
				pZ = malloc(lXfrParamsStructSize);

				if (pZ)
					{
					memset(pZ, 0, lXfrParamsStructSize);
					}
				}
			else
				{
				pZ = malloc(lSize);
				}

			if (pZ)
				{
				sfGetSessionItem(sessQuerySysFileHdl(pX->hSession),
								SFID_XFER_PARAMS,
								&lSize,
								pZ);
				}
			}
		if (pZ)
			{
			if (pX->xfer_params)
				{
				free(pX->xfer_params);
				pX->xfer_params = NULL;
				}

			pX->xfer_params = pZ;
			if (pX->xfer_old_params)
				{
				free(pX->xfer_old_params);
				pX->xfer_old_params = NULL;
				}

			pX->xfer_old_params = malloc(lSize);
			MemCopy(pX->xfer_old_params, pX->xfer_params, lSize);
			}

		/*
		 * Try and get the Bps/Cps flag
		 */
		lSize = sizeof(pX->nBps);
		sfGetSessionItem(sessQuerySysFileHdl(pX->hSession),
						SFID_XFR_USE_BPS,
						&lSize,
						&pX->nBps);
		pX->nOldBps = pX->nBps;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SaveXferHdl
 *
 * DESCRIPTION:
 *	This function is called to save all the settings in the Xfer handle out
 *	to the session file.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
INT SaveXferHdl(HXFER hXfer)
	{
	int nSize = 0;
	XD_TYPE *pX;
	SZ_TYPE *pZ;

	pX = (XD_TYPE *)hXfer;

	if (pX)
		{
		/*
		 * Save the generic transfer stuff
		 */
		pZ = pX->xfer_params;
        if (pZ)
            {
		    nSize = pZ->nSize;
            }
#if FALSE
		/* removed as per MRW request */
		sfdPutDataBlock(pX->hSession,
						SFID_XFER_PARAMS,
						pX->xfer_params);
#endif
		if (memcmp(pX->xfer_old_params, pX->xfer_params, nSize) != 0)
			{
			sfPutSessionItem(sessQuerySysFileHdl(pX->hSession),
							SFID_XFER_PARAMS,
							nSize,
							pZ);
			}

		/*
		 * Save the Bps/Cps flag
		 */
		if (pX->nBps != pX->nOldBps)
			{
			sfPutSessionItem(sessQuerySysFileHdl(pX->hSession),
							SFID_XFR_USE_BPS,
							sizeof(pX->nBps),
							&pX->nBps);
			pX->nOldBps = pX->nBps;
			}

		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
INT DestroyXferHdl(HXFER hXfer)
	{
	int nIndex;
	XD_TYPE *pX = (XD_TYPE *)hXfer;

	if (pX)
		{
		if (pX->xfer_params)
			{
			free(pX->xfer_params);
			pX->xfer_params = NULL;
			}

		if (pX->xfer_old_params)
			{
			free(pX->xfer_old_params);
			pX->xfer_old_params = NULL;
			}

		if (pX->xfer_proto_params)
			{
			/*
			 * Loop through the protocol specific stuff
			 */
			for (nIndex = SFID_PROTO_PARAMS_END - SFID_PROTO_PARAMS; nIndex >= 0; nIndex--)
				{
				if (pX->xfer_proto_params[nIndex])
					{
					free(pX->xfer_proto_params[nIndex]);
					pX->xfer_proto_params[nIndex] = NULL;
					}
				}
			}

		/*
		 * Free up stuff as necessary
		 */
		if (pX->acSendNames)
			{
			for (nIndex = pX->nSendListCount - 1; nIndex >= 0; nIndex--)
				{
				if (pX->acSendNames[nIndex])
					{
					free(pX->acSendNames[nIndex]);
					pX->acSendNames[nIndex] = NULL;
					}
				pX->nSendListCount = nIndex;
				}

			free(pX->acSendNames);
			pX->acSendNames = NULL;
			pX->nSendListCount = 0;
			}

		if (pX->pXferStuff)
			{
			free(pX->pXferStuff);
			pX->pXferStuff = NULL;
			}

		free(pX);
		pX = NULL;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrSetDataPointer
 *
 * DESCRIPTION:
 *	This function is called from the transfer routines in the transfer dll
 *	to save the pointer to the parameter block that was passed to them.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	pData     -- the pointer to be saved
 *
 * RETURNS:
 *	Nothing.
 *
 */
VOID WINAPI xfrSetDataPointer(HXFER hXfer, VOID *pData)
	{
	XD_TYPE *pH;

	// pH = (XD_TYPE *)sessQueryXferHdl(hSession);
	pH = (XD_TYPE *)hXfer;
	assert(pH);
	if (pH)
		{
		pH->pXferStuff = pData;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrQueryDataPointer
 *
 * DESCRIPTION:
 *	This function is called from the transfer routines in the transfer dll to
 *	recover the saved data pointer to the parameter block that was passed to
 *	them.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	ppData    -- pointer to where to put the pointer
 *
 * RETURNS:
 *	Nothing.
 *
 */
VOID WINAPI xfrQueryDataPointer(HXFER hXfer, VOID **ppData)
	{
	XD_TYPE *pH;

	// pH = (XD_TYPE *)sessQueryXferHdl(hSession);
	pH = (XD_TYPE *)hXfer;
	assert(pH);
	if (pH)
		{
		*ppData = pH->pXferStuff;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrQueryParameters
 *
 * DESCRIPTION:
 *	This function returns a pointer to the default transfer parameters.  It
 *	gets the pointer to the block from the session handle and passed the
 *	the pointer to the caller.
 *
 * PARAMETERS:
 *	hSession     -- the session handle
 *	ppData       -- pointer to where the pointer should be saved
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code
 *
 */

INT WINAPI xfrQueryParameters(HXFER hXfer, VOID **ppData)
	{
	INT nRet = 0;
	XD_TYPE *pH = (XD_TYPE *)hXfer;
	XFR_PARAMS *pX = NULL;

	if (ppData == NULL)
		{
		assert(FALSE);
		nRet = XFR_BAD_PARAMETER;
		}
	else if (pH && pH->xfer_params)
		{
		pX = (XFR_PARAMS *)pH->xfer_params;
		}
	else
		{
		/* Build a default one */
		pX = (XFR_PARAMS *)malloc(sizeof(XFR_PARAMS));
		assert(pX);
		if (pX == (XFR_PARAMS *)0)
            {
			assert(FALSE);
			nRet = XFR_NO_MEMORY;
            }
        else
            {
			pX->nSize             = sizeof(XFR_PARAMS);

			/* Initialize the defaults */
#if defined(INCL_ZMODEM_CRASH_RECOVERY)
			pX->nRecProtocol      = XF_ZMODEM_CR;
			pX->fSavePartial      = TRUE;
#else   // defined(INCL_ZMODEM_CRASH_RECOVERY)
            pX->nRecProtocol      = XF_ZMODEM;
			pX->fSavePartial      = FALSE;
#endif  // defined(INCL_ZMODEM_CRASH_RECOVERY)
			pX->fUseFilenames     = TRUE;
			pX->fUseDateTime      = TRUE;
			pX->fUseDirectory     = FALSE;
			pX->nRecOverwrite     = XFR_RO_REN_SEQ;

			pX->nSndProtocol      = XF_ZMODEM_CR;
			pX->fChkSubdirs       = FALSE;
			pX->fIncPaths         = FALSE;
			}
		}

	if (nRet == 0)
		{
		if (hXfer != NULL && pX != NULL)
			{
			xfrSetParameters(hXfer, (VOID *)pX);
			}

		if (*ppData != pX)
			{
			if (*ppData)
				{
				free(*ppData);
				*ppData = NULL;
				}
			*ppData = (VOID *)pX;
			}
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrSetParameters
 *
 * DESCRIPTION:
 *	This function is called to change the default transfer parameters.  If
 *	the parameter block returned is different from the default block, the
 *	settings are copied.  If the block is the same, then they don't need to
 *	be.  Please note that the previous function is exported and can be called
 *	to get the parameters, but this function is not exported and cannot be
 *	accessed externally.
 *
 * PARAMETERS:
 *	hSession     -- the session handle
 *	pData        -- pointer to the new parameter block
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfrSetParameters(HXFER hXfer, VOID *pData)
	{
	XD_TYPE *pX;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;

	if (pX)
		{
		/* TODO: check that we really need to change it */
		if (pX->xfer_params)
			{
			if (pX->xfer_params != (SZ_TYPE *)pData)
				{
				free(pX->xfer_params);
				pX->xfer_params = NULL;
				}
			}

		pX->xfer_params = (SZ_TYPE *)pData;
		}
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
int WINAPI xfrQueryProtoParams(HXFER hXfer, int nId, VOID **ppData)
	{
	int nRet = 0;
	int nLimit = SFID_PROTO_PARAMS_END - SFID_PROTO_PARAMS;
	XD_TYPE *pX = NULL;

	if ((nId < 0) || (nId > nLimit))
		{
		nRet = XFR_BAD_PARAMETER;
		}
	else
		{
		// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
		pX = (XD_TYPE *)hXfer;
		assert(pX);
		if (pX)
			{
			*ppData = (VOID *)pX->xfer_proto_params[nId];
			}
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
void WINAPI xfrSetProtoParams(HXFER hXfer, int nId, VOID *pData)
	{
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrSendAddToList
 *
 * DESCRIPTION:
 *	This function is called to add a file to the list of files that are being
 *	ququed up to send to whatever system we are connected to.
 *
 * PARAMETERS:
 *	hSession   -- the session handle
 *	pszFile    -- the file name, see note below
 *
 * NOTE:
 *	If the second parameter, "pszFile" is NULL, this function acts as a
 *	empty or clear list function.
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
int xfrSendAddToList(HXFER hXfer, LPCTSTR pszFile)
	{
	int nRet = 0;
	XD_TYPE *pX;
	LPTSTR pszName;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX)
		{
		if (pszFile == NULL)
			{
			int nIdx;

			assert(FALSE);

			/* Clear list */
			for (nIdx = pX->nSendListCount - 1; nIdx >=0; nIdx--)
				{
				if (pX->acSendNames[nIdx])
					{
					free(pX->acSendNames[nIdx]);
					pX->acSendNames[nIdx] = NULL;
					}
				pX->nSendListCount = nIdx;
				}

			free(pX->acSendNames);
			pX->acSendNames = NULL;
			pX->nSendListCount = 0;
			}
		else
			{
			/* Do we have enough space on the list ? */
			if (pX->nSendListCount == 0)
				{
				/* Allocate the initial chunk */
				if (pX->acSendNames)
					{
					int nIdx;

					assert(FALSE);
					//
					// Make sure to clear out all the names in the list.
					//
					for (nIdx = pX->nSendListCount; nIdx >= 0; nIdx--)
						{
						if (pX->acSendNames[nIdx])
							{
							free(pX->acSendNames[nIdx]);
							pX->acSendNames[nIdx] = NULL;
							}
						}
					free(pX->acSendNames);
					pX->acSendNames = NULL;
					}

				pX->acSendNames = malloc(sizeof(TCHAR *) * LIST_CHUNK);

				if (pX->acSendNames == NULL)
					{
					nRet = XFR_NO_MEMORY;
					goto SATLexit;
					}
				}
			else if (((pX->nSendListCount + 1) % LIST_CHUNK) == 0)
				{
				/* Need a bigger chunk */
				TCHAR **pTempacSendNames = NULL;

				pTempacSendNames = 
					(TCHAR**)realloc(pX->acSendNames,
									(unsigned int)sizeof(TCHAR *) * (unsigned int)((pX->nSendListCount + 1 + LIST_CHUNK)));

				if (pTempacSendNames == NULL)
					{
					nRet = XFR_NO_MEMORY;
					goto SATLexit;
					}
				else
					{
					pX->acSendNames = pTempacSendNames;
					}
				}

			pX->acSendNames[pX->nSendListCount] = NULL;
			pX->nSendListCount++;

			/* Add item to list */
			pszName = malloc(StrCharGetByteCount(pszFile) + 1);
			if (pszName == NULL)
				{
				nRet = XFR_NO_MEMORY;
				goto SATLexit;
				}
			StrCharCopy(pszName, pszFile);
			pX->acSendNames[pX->nSendListCount - 1] = pszName;
			}
		}
SATLexit:
	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrSendListSend
 *
 * DESCRIPTION:
 *	This function is called to send the files that were previously placed on
 *	the send list.  The list is cleared after the operation.
 *
 * PARAMETERS:
 *	hSession    -- the session handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
int xfrSendListSend(HXFER hXfer)
	{
	HSESSION hSession;
	int nRet = 0;
	int nIdx;
	long lSize;
	long lTmp;
	LPTSTR pszName;
	XD_TYPE *pX;
	XFR_SEND *pSend;
	HCLOOP hCL;
	HWND toolbar;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX != NULL)
		{
		hSession = pX->hSession;
        assert(hSession);

        if (hSession == NULL)
            {
            return XFR_BAD_PARAMETER;
            }

        //
        // Return an error if a file transfer is currently
        // in progress.  REV: 08/06/2001.
        //
        if (pX->nDirection != XFER_NONE)
            {
            nRet = XFR_IN_PROGRESS;
            return nRet;
            }

		//
		// Return an error if not currently connected due to a
		// loss of carrier. REV: 9/7/2001
		// 
		if (pX->nCarrierLost == TRUE)
			{
			nRet = XFR_NO_CARRIER;
			return nRet;
			}

		pSend = malloc(sizeof(XFR_SEND));
		assert(pSend);
		if (pSend == NULL)
			{
			nRet = XFR_NO_MEMORY;
			goto SLSexit;
			}
		memset(pSend, 0, sizeof(XFR_SEND));

		/*
		 * Fill in the single stuff
		 */
		pSend->pParams = (XFR_PARAMS *)pX->xfer_params;
		pSend->nProtocol = pSend->pParams->nSndProtocol;
		pSend->pProParams = (VOID *)pX->xfer_proto_params[pSend->nProtocol];
		pSend->nCount = pX->nSendListCount;
		pSend->nIndex = 0;

		/* TODO: initialize stuff like the templates and status/event bases */

		/*
		 * Do the file specific stuff
		 */
		pSend->pList = malloc(sizeof(XFR_LIST) * pSend->nCount);
		assert(pSend->pList);
		if (pSend->pList == NULL)
			{
			nRet = XFR_NO_MEMORY;
			goto SLSexit;
			}
		for (lSize = 0, nIdx = 0; nIdx < pSend->nCount; nIdx += 1)
			{
			pszName = pX->acSendNames[nIdx];
			lTmp = 0;
			GetFileSizeFromName(pszName, &lTmp);
			pSend->pList[nIdx].lSize = lTmp;
			lSize += lTmp;
			pSend->pList[nIdx].pszName = pszName;
			}
		/* These no longer belong to this side */

		//
		// The filename buffers have been moved to the list,
		// so the SendNames structure is no longer pointing to
		// memory that is to be freed by pX. REV: 4/16/2002
		//
		for (nIdx = pX->nSendListCount - 1; nIdx >=0; nIdx--)
			{
			if (pX->acSendNames[nIdx])
				{
				pX->acSendNames[nIdx] = NULL;
				}
			pX->nSendListCount--;
			}

		free(pX->acSendNames);
		pX->acSendNames = NULL;
		pX->nSendListCount = 0;

		pX->nDirection = XFER_SEND;

		pSend->lSize = lSize;

		xfrInitDspStruct(hXfer);

		switch (pSend->nProtocol)
			{
#if FALSE
			case XF_HYPERP:
				pX->nLgSingleTemplate = IDD_XFERHPRSNDSTANDARDSINGLE;
				pX->nLgMultiTemplate = IDD_XFERHPRSNDSTANDARDDOUBLE;
				pX->nStatusBase = IDS_TM_SS_ZERO;
				pX->nEventBase = IDS_TM_SE_ZERO;
				break;
#endif
			case XF_KERMIT:
				pX->nLgSingleTemplate = IDD_XFERKRMSNDSTANDARDSINGLE;
				pX->nLgMultiTemplate = IDD_XFERKRMSNDSTANDARDDOUBLE;
				pX->nStatusBase = pX->nEventBase = IDS_TM_K_ZERO;
				break;
			case XF_CSB:
			default:
				assert(FALSE);
			case XF_ZMODEM:
			case XF_ZMODEM_CR:
				pX->nLgSingleTemplate = IDD_XFERZMDMSNDSTANDARDSINGLE;
				pX->nLgMultiTemplate = IDD_XFERZMDMSNDSTANDARDDOUBLE;
				pX->nStatusBase = IDS_TM_SZ_ZERO;
				pX->nEventBase = IDS_TM_SZ_ZERO;
				break;
			case XF_XMODEM:
			case XF_XMODEM_1K:
				pX->nLgSingleTemplate = IDD_XFERXMDMSNDSTANDARDDISPLAY;
				pX->nLgMultiTemplate = pX->nLgSingleTemplate;
				pX->nStatusBase = pX->nEventBase = IDS_TM_RX_ZERO;
				break;
			case XF_YMODEM:
			case XF_YMODEM_G:
				pX->nLgSingleTemplate = IDD_XFERYMDMSNDSTANDARDSINGLE;
				pX->nLgMultiTemplate = IDD_XFERYMDMSNDSTANDARDDOUBLE;
				pX->nStatusBase = pX->nEventBase = IDS_TM_RX_ZERO;
				break;
			}

		toolbar = sessQueryHwndToolbar( hSession );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_SEND, FALSE );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_RCV, FALSE );

		pX->pXferStuff = (VOID *)pSend;

		pX->nExpanded = FALSE;

		pX->hwndXfrDisplay = DoModelessDialog(glblQueryDllHinst(),
										MAKEINTRESOURCE(pX->nLgSingleTemplate),
										sessQueryHwnd(hSession),
										XfrDisplayDlg,
										(LPARAM)hSession);

		/*
		 * Now get it going
		 */
		hCL = sessQueryCLoopHdl(hSession);
		if (hCL)
			{
			// DbgOutStr("Tell CLoop TRANSFER_READY\r\n", 0,0,0,0,0);

			CLoopControl(hCL, CLOOP_SET, CLOOP_TRANSFER_READY);
			}
		}

SLSexit:
	if (nRet != 0)
		{
		/* Clean up before we leave */
		if (pSend != NULL)
			{
			for (nIdx = pSend->nCount - 1; nIdx >= 0; nIdx--)
				{
				if (pSend->pList[nIdx].pszName)
					{
					free(pSend->pList[nIdx].pszName);
					pSend->pList[nIdx].pszName = NULL;
					}
				}
			free(pSend->pList);
			pSend->pList = NULL;
			free(pSend);
			pSend = NULL;
			}
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrRecvStart
 *
 * DESCRIPTION:
 *	This function is called when we think we have everything that we need
 *	in order to start a Transfer Receive operation.
 *
 * PARAMETERS:
 *	hSession    -- the session handle
 *	pszDir      -- a string with a directory in it
 *	pszName     -- a string with a file name in it (maybe)
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
int xfrRecvStart(HXFER hXfer, LPCTSTR pszDir, LPCTSTR pszName)
	{
	HSESSION hSession;
	int nRet = 0;
	XD_TYPE *pX;
	XFR_RECEIVE *pRec;
	HCLOOP hCL;
	HWND toolbar;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX)
		{
		hSession = pX->hSession;
        assert(hSession);

        if (hSession == NULL)
            {
            return XFR_BAD_PARAMETER;
            }

        //
        // Return an error if a file transfer is currently
        // in progress.  REV: 08/06/2001.
        //
        if (pX->nDirection != XFER_NONE)
            {
            nRet = XFR_IN_PROGRESS;
            return nRet;
            }

		//
		// Return an error if not currently connected due to a
		// loss of carrier. REV: 9/7/2001
		// 
		if (pX->nCarrierLost == TRUE)
			{
			nRet = XFR_NO_CARRIER;
			return nRet;
			}

		pRec = (XFR_RECEIVE *)malloc(sizeof(XFR_RECEIVE));
		assert(pRec);
		if (pRec == (XFR_RECEIVE *)0)
			{
			nRet = XFR_NO_MEMORY;
			goto RSexit;
			}
		memset(pRec, 0, sizeof(XFR_RECEIVE));

		pRec->pParams = (XFR_PARAMS *)pX->xfer_params;
		pRec->nProtocol = pRec->pParams->nRecProtocol;
		pRec->pProParams = (VOID *)pX->xfer_proto_params[pRec->nProtocol];
		pRec->pszDir = malloc(StrCharGetByteCount(pszDir) + 1);
		if (pRec->pszDir == (LPTSTR)0)
			{
			nRet = XFR_NO_MEMORY;
			goto RSexit;
			}
		StrCharCopy(pRec->pszDir, pszDir);
		pRec->pszName = malloc(StrCharGetByteCount(pszName) + 1);
		if (pRec->pszName == (LPTSTR)0)
			{
			nRet = XFR_NO_MEMORY;
			goto RSexit;
			}
		StrCharCopy(pRec->pszName, pszName);

		xfrInitDspStruct(hXfer);

		switch (pRec->nProtocol)
			{
#if FALSE
			case XF_HYPERP:
				pX->nLgSingleTemplate = IDD_XFERHPRRECSTANDARDSINGLE;
				pX->nLgMultiTemplate = IDD_XFERHPRRECSTANDARDDOUBLE;
				pX->nStatusBase = IDS_TM_RS_ZERO;
				pX->nEventBase = IDS_TM_RE_ZERO;
				break;
#endif
			case XF_KERMIT:
				pX->nLgSingleTemplate = IDD_XFERKRMRECSTANDARDDISPLAY;
				pX->nLgMultiTemplate = pX->nLgSingleTemplate;
				pX->nStatusBase = pX->nEventBase = IDS_TM_K_ZERO;
				break;
			case XF_CSB:
			default:
				assert(FALSE);
			case XF_ZMODEM:
            case XF_ZMODEM_CR:
				pX->nLgSingleTemplate = IDD_XFERZMDMRECSTANDARDSINGLE;
				pX->nLgMultiTemplate = IDD_XFERZMDMRECSTANDARDDOUBLE;
				pX->nStatusBase = IDS_TM_SZ_ZERO;
				pX->nEventBase = IDS_TM_SZ_ZERO;
				break;
			case XF_XMODEM:
			case XF_XMODEM_1K:
				pX->nLgSingleTemplate = IDD_XFERXMDMRECSTANDARDDISPLAY;
				pX->nLgMultiTemplate = pX->nLgSingleTemplate;
				pX->nStatusBase = pX->nEventBase = IDS_TM_RX_ZERO;
				break;
			case XF_YMODEM:
			case XF_YMODEM_G:
				pX->nLgSingleTemplate = IDD_XFERYMDMRECSTANDARDDISPLAY;
				pX->nLgMultiTemplate = pX->nLgSingleTemplate;
				pX->nStatusBase = pX->nEventBase = IDS_TM_RX_ZERO;
				break;
			}

		toolbar = sessQueryHwndToolbar( hSession );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_SEND, FALSE );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_RCV, FALSE );
		
		pX->nDirection = XFER_RECV;

		pX->pXferStuff = (VOID *)pRec;

		pX->nExpanded = FALSE;

		pX->hwndXfrDisplay = DoModelessDialog(glblQueryDllHinst(),
										MAKEINTRESOURCE(pX->nLgSingleTemplate),
										sessQueryHwnd(hSession),
										XfrDisplayDlg,
										(LPARAM)hSession);

		hCL = sessQueryCLoopHdl(hSession);
		if (hCL)
			{
			CLoopControl(hCL, CLOOP_SET, CLOOP_TRANSFER_READY);
			}
		}
RSexit:
	if (nRet != 0)
		{
		/*
		 * If we failed, clean up the mess.
		 */
		if (pRec != (XFR_RECEIVE *)0)
			{
			if (pRec->pszDir != (LPTSTR)0)
				{
				free(pRec->pszDir);
				pRec->pszDir = NULL;
				}
			if (pRec->pszName != (LPTSTR)0)
				{
				free(pRec->pszName);
				pRec->pszName = NULL;
				}
			free(pRec);
			pRec = NULL;
			}
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrGetEventBase
 *
 * DESCRIPTION:
 *	This function is called by the transfer display.  It is used to get the
 *	starting number (of the the resource strings) of a list of events that
 *	can be displayed for some of the transfer protocols.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	A resource ID that should be passed on to LoadString.
 *
 */
int xfrGetEventBase(HXFER hXfer)
	{
	XD_TYPE *pX;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX)
		{
		return pX->nEventBase;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrGetStatusBase
 *
 * DESCRIPTION:
 *	This function is called bye the transfer display.  It is used to get the
 *	starting number (of the resource strings) of a list of status messages that
 *	can be displayed for some of the transfer protocols.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	A resource ID that should be passed on to LoadString.
 *
 */
int xfrGetStatusBase(HXFER hXfer)
	{
	XD_TYPE *pX;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX)
		{
		return pX->nStatusBase;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrGetXferDspBps
 *
 * DESCRIPTION:
 *	This function is called to get the current value of the BPS/CPS flag.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	The current value of the BPS flag.
 *
 */
int xfrGetXferDspBps(HXFER hXfer)
	{
	XD_TYPE *pX;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX)
		{
		return pX->nBps;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrSetXferDspBps
 *
 * DESCRIPTION:
 *	This function is called to set the BPS/CPS flag in the tranfer handle.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	nBps     -- the new BPS flag
 *
 * RETURNS:
 *	The old value of the BPS flag.
 *
 */
int xfrSetXferDspBps(HXFER hXfer, int nBps)
	{

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrInitDspStruct
 *
 * DESCRIPTION:
 *	This function is called before a transfer is started to make sure that
 *	the display variables in the transfer structure are all set to a known
 *	initial value.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	Nothing.
 */
static void xfrInitDspStruct(HXFER hXfer)
	{
	XD_TYPE *pX;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);
	if (pX)
		{
		pX->nClose         = 0;
		pX->nCloseStatus   = 0;

		pX->bChecktype     = 0;
		pX->bErrorCnt      = 0;
		pX->bPcktErrCnt    = 0;
		pX->bLastErrtype   = 0;
		pX->bTotalSoFar    = 0;
		pX->bFileSize      = 0;
		pX->bFileSoFar     = 0;
		pX->bPacketNumber  = 0;
		pX->bTotalCnt      = 0;
		pX->bTotalSize     = 0;
		pX->bFileCnt       = 0;
		pX->bEvent         = 0;
		pX->bStatus        = 0;
		pX->bElapsedTime   = 0;
		pX->bRemainingTime = 0;
		pX->bThroughput    = 0;
		pX->bProtocol      = 0;
		pX->bMessage       = 0;
		pX->bOurName       = 0;
		pX->bTheirName     = 0;
		pX->wChecktype     = 0;
		pX->wErrorCnt      = 0;
		pX->wPcktErrCnt    = 0;
		pX->wLastErrtype   = 0;
		pX->lTotalSize     = 0L;
		pX->lTotalSoFar    = 0L;
		pX->lFileSize      = 0L;
		pX->lFileSoFar     = 0L;
		pX->lPacketNumber  = 0L;
		pX->wTotalCnt      = 0;
		pX->wFileCnt       = 0;
		pX->wEvent         = 0;
		pX->wStatus        = 0;
		pX->lElapsedTime   = 0L;
		pX->lRemainingTime = 0L;
		pX->lThroughput    = 0L;
		pX->uProtocol      = 0;

		TCHAR_Fill(pX->acMessage, TEXT('\0'),
					sizeof(pX->acMessage) / sizeof(TCHAR));
		TCHAR_Fill(pX->acOurName, TEXT('\0'),
					sizeof(pX->acOurName) / sizeof(TCHAR));
		TCHAR_Fill(pX->acTheirName, TEXT('\0'),
					sizeof(pX->acTheirName) / sizeof(TCHAR));
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrCleanUpReceive
 *
 * DESCRIPTION:
 *	This function is called from xfrDoTransfer after a transfer in order to
 *	clean up the stuff that was allocated in order to do the transfer.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *	Nothing.
 */
void xfrCleanUpReceive(HSESSION hSession)
	{
	XD_TYPE *pX;
	XFR_RECEIVE *pR;
	HWND toolbar;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	assert(pX);
	if (pX)
		{
		pR = (XFR_RECEIVE *)pX->pXferStuff;
		assert(pR);
		if (pR)
			{
			if (pR->pszDir != NULL)
				{
				free(pR->pszDir);
				pR->pszDir = NULL;
				}
			if (pR->pszName != NULL)
				{
				free(pR->pszName);
				pR->pszName = NULL;
				}

			free(pR);
			pR = NULL;
			}

		pX->pXferStuff = (void *)0;
		pX->nExpanded = FALSE;

        // Make sure to reset the Transfer direction. REV: 02/14/2001
        pX->nDirection = XFER_NONE;

		toolbar = sessQueryHwndToolbar( hSession );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_SEND, TRUE );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_RCV, TRUE );
        }
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrCleanUpSend
 *
 * DESCRIPTION:
 *	This function is called from xfrDoTransfer after a transfer in order to
 *	clean up the stuff that was allocated in order to do the transfer.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *	Nothing.
 */
void xfrCleanUpSend(HSESSION hSession)
	{
	XD_TYPE *pX;
	XFR_SEND *pS;
	HWND toolbar;

	/* TODO: finish this thing up */

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	assert(pX);
	if (pX)
		{
		pS = (XFR_SEND *)pX->pXferStuff;
		assert(pS);
		if (pS)
			{
			int n;

			if (pS->pList)
				{
				for (n = pS->nCount - 1; n >= 0; n--)
					{
					if (pS->pList[n].pszName)
						{
						free(pS->pList[n].pszName);
						pS->pList[n].pszName = NULL;
						}
					}
				free(pS->pList);
				pS->pList = NULL;
				}
			free(pS);
			pS = NULL;
			}
		pX->pXferStuff = (void *)0;
		pX->nExpanded = FALSE;

        // Make sure to reset the Transfer direction. REV: 02/14/2001
        pX->nDirection = XFER_NONE;

		toolbar = sessQueryHwndToolbar( hSession );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_SEND, TRUE );
		ToolbarEnableButton( toolbar, IDM_ACTIONS_RCV, TRUE );
        }
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrDoTransfer
 *
 * DESCRIPTION:
 *	Yes, folks, this is the one you have been waiting for.  It runs in the
 *	CLOOP thread.  It calls the XFER DLL (if there is one).  It slices.  It
 *	dices.  It actually does the transfer.
 *
 * PARAMETERS:
 *	hSession -- the font of all knowledge
 *
 * RETURNS:
 *	Nothing.  What can be said after a transfer is done?
 *
 */
void xfrDoTransfer(HXFER hXfer)
	{
	XD_TYPE *pX;
	HSESSION hSession = (HSESSION)0;
	int nRet = 0;
	int nTitle;
	TCHAR acTitle[64];
	TCHAR acMessage[255];

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	if (pX)
		{
		hSession = pX->hSession;

		switch (pX->nDirection)
			{
			case XFER_SEND:
				nTitle = IDS_XD_SEND;
				nRet = xfrSend(hSession, (XFR_SEND *)pX->pXferStuff);
				xfrCleanUpSend(hSession);
				break;
			case XFER_RECV:
				nTitle = IDS_XD_RECEIVE;
				nRet = xfrReceive(hSession, (XFR_RECEIVE *)pX->pXferStuff);
				xfrCleanUpReceive(hSession);
				break;
			default:
				assert(FALSE);
				break;
			}
		}

	if (sessQuerySound(hSession))
		{
		mscMessageBeep(MB_OK);
		}

	switch (nRet)
		{
		case TSC_OK:
		case TSC_COMPLETE:
		case TSC_CANT_START:
			break;
		default:
			LoadString(glblQueryDllHinst(),
					nTitle,
					acTitle,
					sizeof(acTitle) / sizeof(TCHAR));
			LoadString(glblQueryDllHinst(),
					nRet + IDS_TM_XFER_ZERO,
					acMessage,
					sizeof(acMessage) / sizeof(TCHAR));
			if (StrCharGetStrLength(acMessage) > 0)
				{
				TimedMessageBox(sessQueryHwnd(hSession),
								acMessage,
								acTitle,
								MB_OK | MB_ICONINFORMATION,
								sessQueryTimeout(hSession));
				}
			break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrSetPercentDone
 *
 * DESCRIPTION:
 *	This function is called to set the percent done value for a transfer.
 *	This value is only of real use when the program is shown as an icon.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	nPerCent -- the percent done (0 to 100)
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfrSetPercentDone(HXFER hXfer, int nPerCent)
	{
	XD_TYPE *pX;
	HWND hwnd;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;
	assert(pX);

	if (pX)
		{
		// DbgOutStr("Set percent %d", nPerCent, 0,0,0,0);
		pX->nPerCent = nPerCent;
		hwnd = sessQueryHwnd(pX->hSession);
		if (IsIconic(hwnd))
			{
			// DbgOutStr(" !!!", 0,0,0,0,0);
			InvalidateRect(hwnd, 0, TRUE);
			}
		// DbgOutStr("\r\n", 0,0,0,0,0);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrGetPercentDone
 *
 * DESCRIPTION:
 *	This function is called to get the stored percentage value for a transfer.
 *	This is usually done only to display the value as an icon.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	The percentage (0 to 100).
 *
 */
int  xfrGetPercentDone(HXFER hXfer)
	{
	XD_TYPE *pX;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;

	if (pX)
		{
		return pX->nPerCent;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrGetDisplayWindow
 *
 * DESCRIPTION:
 *	Returns the window handle of the transfer display window, if any.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	A window handle (HWND) or NULL.
 *
 */
HWND xfrGetDisplayWindow(HXFER hXfer)
	{
	HWND hRet;
	XD_TYPE *pX;

	hRet = (HWND)0;

	// pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	pX = (XD_TYPE *)hXfer;

	if (pX)
		{
		hRet = pX->hwndXfrDisplay;		/* handle of the display window */
		}

	return hRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrDoAutostart
 *
 * DESCRIPTION:
 *	This function is called whenever the session proc gets an XFER_REQ event.
 *	This usually indicates that somebody wants to do a ZMODEM receive.  In
 *	UPPER WACKER other protocols will be added, notably CSB and HyperP.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	lProtocol -- which protocol is requested
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfrDoAutostart(HXFER hXfer, long lProtocol)
	{
	XD_TYPE *pX;
	HSESSION hSession;

	pX = (XD_TYPE *)hXfer;
	assert(pX);
    if (pX == NULL)
        {
        return;
        }

    hSession = pX->hSession;
    assert(hSession);

    if (hSession == NULL)
        {
        return;
        }

	switch (lProtocol)
		{
		case XF_ZMODEM:
		case XF_ZMODEM_CR:
			{
            int nXferRecvReturn;
			int nOldProtocol;
			LPCTSTR  pszDir;
			XFR_PARAMS *pP;
			XFR_Z_PARAMS *pZ;

			pP = (XFR_PARAMS *)0;
			xfrQueryParameters(hXfer, (VOID **)&pP);
			assert(pP);

			#if	defined(INCL_ZMODEM_CRASH_RECOVERY)
			//
			// For Zmodem autostarts, check to see if the receiver's
			// protocol is set for plain Zmodem. Otherwise use
            // crash recovery.
			//
            if (pP->nRecProtocol == XF_ZMODEM)
                {
                lProtocol = XF_ZMODEM;
                }
            else
                {
                lProtocol = XF_ZMODEM_CR;
                }
			#endif	// defined(INCL_ZMODEM_CRASH_RECOVERY)

			pZ = (XFR_Z_PARAMS *)0;
			xfrQueryProtoParams(hXfer,
								(int)lProtocol,
								(void **)&pZ);
			if (pZ)
				{
				//
				// See if autostart is OK.
				//
				if (!pZ->nAutostartOK)
					{
					xferCancelAutoStart(hSession, lProtocol);
					break;					/* Not allowed ! */
					}
				}

			//
			// See if we should allow host initiated file transfers.
			//
			if (!sessQueryAllowHostXfers(hSession))
				{
				xferCancelAutoStart(hSession, lProtocol);
				break;					/* Not allowed ! */
				}

			nOldProtocol = pP->nRecProtocol;
			pP->nRecProtocol = (int)lProtocol;

			/* Try and start up the transfer */
			pszDir = filesQueryRecvDirectory(sessQueryFilesDirsHdl(hSession));

			nXferRecvReturn = xfrRecvStart(hXfer, pszDir, "");

            //
            // Don't save the settings if a file transfer is in
            // progress otherwise the current file transfer could
            // get corrupted.  REV: 08/06/2001.
            //
            if (nXferRecvReturn == XFR_IN_PROGRESS)
                {
                TCHAR acMessage[256];

			    if (sessQuerySound(hSession))
                    {
				    mscMessageBeep(MB_ICONHAND);
                    }

			    LoadString(glblQueryDllHinst(),
					    IDS_ER_XFER_RECV_IN_PROCESS,
					    acMessage,
					    sizeof(acMessage) / sizeof(TCHAR));

			    TimedMessageBox(sessQueryHwnd(hSession),
							    acMessage,
							    NULL,
							    MB_OK | MB_ICONEXCLAMATION,
							    sessQueryTimeout(hSession));

                //
                // TODO:REV 08/06/2001 We should send a ZModem cancel
                // back to let the other side know we are not able to
                // recieve the file at this point.
				//
				// Actually a ZCOMPL is the correct responce when we
				// are not to receive an autostart delivery, but that
				// may cause an existing ZModem file transfer to be
				// replied to as complete, so we won't do this until
				// we figure out what to do in this case. REV: 4/25/2002
                //
				// xferCancelAutoStart(hSession, lProtocol);
                }

			/* Restore what we changed up above */
			pP->nRecProtocol = nOldProtocol;
			}
			break;

		default:
			assert(FALSE);
			break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferCancelAutoStart
 *
 * DESCRIPTION:
 *	This function is called whenever the session proc gets an autostart
 *  file transfer event.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	lProtocol -- which protocol is requested
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xferCancelAutoStart(HSESSION hSession, long lProtocol)
	{
	#if defined(TODO)
	//
	// Send a ZCOMPL header here to let other end know we
	// we can't accept an autostart delivery. REV: 4/25/2002
	//
	zmdm_rcv(hSession, lProtocol, TRUE, FALSE);

	hXfer->nUserCancel = XFER_NO_AUTOSTART;
	hXfer->
	xfrDoTransfer(hXfer);

	zshhdr(pZ, ZCOMPL, pZ->Txhdr);
	#endif // defined(TODO)
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\xfdspdlg.c ===
/*	File: C:\WACKER\TDLL\XFDSPDLG.C (Created: 10-Jan-1994)
 *	Created from:
 *	File: C:\HA5G\ha5g\xfdspdlg.c (Created: 9-Oct-1992)
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 10/12/01 5:19p $
 */
#include <windows.h>
#pragma hdrstop

// #define	DEBUGSTR	1

// As of 14-Apr-94 (build 89) still doesn't work
// As of the May Beta, it did work
#define	DO_FM	1

#include <term\res.h>
#include <term\xfer_dlg.h>
#include "stdtyp.h"
#include "mc.h"
#include "tdll.h"
#include "htchar.h"
#include "misc.h"
#include <tdll\assert.h>
#include "session.h"
#include "globals.h"
#include "xfer_msc.h"
#include "xfer_msc.hh"
#include "vu_meter.h"
#include <xfer\xfer.h>

#include "xfdspdlg.h"
#include "xfdspdlg.hh"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	HSESSION hSession;
	HWND	 hDlg;				/* our window handle */

	HBRUSH	 hBrush;			/* background brush */

	XD_TYPE *pstD;				/* transfer and display data */

	INT		 nIsCancelActive;	/* flag for cancel option */
	};

typedef	struct stSaveDlgStuff SDS;

VOID PASCAL xfrDisplayFunc(SDS *pstL);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	XfrDisplayDlg
 *
 * DESCRIPTION:
 *	This is the dialog function for the transfer display.  It is a little bit
 *	different in that it is a modeless dialog and it hangs around and shows
 *	the status of a ongoing transfer.
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK XfrDisplayDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;


	switch (wMsg)
		{
	case WM_INITDIALOG:
		{
		LPTSTR acPtrs[3];
		TCHAR acProto[64];
		TCHAR acFmt[64];
		TCHAR acName[128];
		TCHAR acBuffer[256];

		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			}

		pS->hSession = (HSESSION)lPar;
		pS->hDlg = hDlg;
		pS->hBrush = 0;
		pS->pstD = (XD_TYPE *)sessQueryXferHdl(pS->hSession);
		pS->nIsCancelActive = 0;

        //
        // Make sure to set the loss of carrier flag to FALSE. REV: 08/23/2001
        //
        if (pS->pstD != (XD_TYPE *)0)
            {
		    pS->pstD->nCarrierLost = FALSE;
            }

		mscCenterWindowOnWindow(hDlg, sessQueryHwnd(pS->hSession));

		/*
		 * We need to set the title on the display
		 */

		{
		int nIndex;
		int nState;
		XFR_PROTOCOL *pX;
		XFR_PARAMS *pP;
		/* This section is in braces because it may go into a function later */

		pP = (XFR_PARAMS *)0;
		xfrQueryParameters(sessQueryXferHdl(pS->hSession), (VOID **)&pP);
		assert(pP);

		if (pS->pstD->nDirection == XFER_RECV)
			nState = pP->nRecProtocol;
		else
			nState = pP->nSndProtocol;

		pX = (XFR_PROTOCOL *)0;
		xfrGetProtocols(pS->hSession, &pX);
		assert(pX);

		if (pX != (XFR_PROTOCOL *)0)
			{
			for (nIndex = 0; pX[nIndex].nProtocol != 0; nIndex += 1)
				{
				if (nState == pX[nIndex].nProtocol)
					{
					StrCharCopy(acProto, pX[nIndex].acName);
					break;
					}
				}
			free(pX);
			pX = NULL;
			}
		}

		sessQueryName(pS->hSession, acName, sizeof(acName) / sizeof(TCHAR));

		LoadString(glblQueryDllHinst(),
					(pS->pstD->nDirection == XFER_RECV) ?
									IDS_XD_RECV_TITLE : IDS_XD_SEND_TITLE,
					acFmt,
					sizeof(acFmt) / sizeof(TCHAR));

		acPtrs[0] = acProto;
		acPtrs[1] = acName;
		acPtrs[2] = 0;
#if defined(DO_FM)
		FormatMessage(
					FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
					acFmt,
					0,				/* Message ID, ignored */
					0,				/* also ignored */
					acBuffer,		/* result */
					sizeof(acBuffer) / sizeof(TCHAR),
					(va_list *)&acPtrs[0]);
#else
		wsprintf(acBuffer, "%s transfer for %s", acPtrs[0], acPtrs[1]);
#endif

		SetWindowText(hDlg, acBuffer);

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);
		}
		break;

	case WM_CLOSE:
		{
		XD_TYPE *pX;

		pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
		assert(pS);
		pX = pS->pstD;
		assert(pX);
		if (pX)
			{
			pX->nUserCancel = XFER_ABORT;
			}
		}
		break;

	case WM_DESTROY:
		pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
		if (pS)
			{
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);
			}
		break;

	case WM_DLG_TO_DISPLAY:
		// DbgOutStr("WM_DLG_TO_DISPLAY\r\n", 0,0,0,0,0);

		switch(wPar)
			{
			case XFR_SINGLE_TO_DOUBLE:
				{
				HWND hwndOld;
				XD_TYPE *pX;

				// DbgOutStr("XFR_SINGLE_TO_DOUBLE\r\n", 0,0,0,0,0);

				pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
				if (pS)
					{
					pX = pS->pstD;
					assert(pX);

					if (pX->nExpanded)
						{
						break;
						}

					pX->nExpanded = TRUE;

					if (pX->nLgSingleTemplate == pX->nLgMultiTemplate)
						{
						break;
						}

					/* Must actually need to change */

					DbgOutStr("New Display!!!\r\n", 0,0,0,0,0);

					hwndOld = pX->hwndXfrDisplay;

					pX->hwndXfrDisplay = DoModelessDialog(glblQueryDllHinst(),
										MAKEINTRESOURCE(pX->nLgMultiTemplate),
										sessQueryHwnd(pS->hSession),
										XfrDisplayDlg,
										(LPARAM)pS->hSession);
					assert(pX->hwndXfrDisplay);

					//JMH 03-11-96: Originally PostMessage, but it turns out
					// some of the flags could be updated and reset by the old
					// progress dialog after they were set below. Changing this
					// to SemdMessage forces the old dialog to end immediately.
					//
					PostMessage(sessQueryHwnd(pS->hSession),
								WM_SESS_ENDDLG,
								0, (LPARAM)hwndOld);

					pX->bChecktype     = 1;
					pX->bErrorCnt      = 1;
					pX->bPcktErrCnt    = 1;
					pX->bLastErrtype   = 1;
					pX->bTotalSoFar    = 1;
					pX->bFileSize      = 1;
					pX->bFileSoFar     = 1;
					pX->bPacketNumber  = 1;
					pX->bTotalCnt      = 1;
					pX->bTotalSize     = 1;
					pX->bFileCnt       = 1;
					pX->bEvent         = 1;
					pX->bStatus        = 1;
					pX->bElapsedTime   = 1;
					pX->bRemainingTime = 1;
					pX->bThroughput    = 1;
					pX->bProtocol      = 1;
					pX->bMessage       = 1;
					pX->bOurName       = 1;
					pX->bTheirName     = 1;

					// xfrDisplayFunc(pS);
					PostMessage(pX->hwndXfrDisplay,
								WM_DLG_TO_DISPLAY,
								XFR_UPDATE_DLG, 0);
					}
				}
				break;
			case XFR_BUTTON_PUSHED:
				/* Probably not needed any more */
				break;
			case XFR_UPDATE_DLG:
				// DbgOutStr("XFR_UPDATE_DLG\r\n", 0,0,0,0,0);
				/* Update the display */
				pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

				//assert(pS->pstD->bTheirName == 1);

				if (pS)
					{
					xfrDisplayFunc(pS);
					}
				break;
			default:
				break;
			}
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case XFR_SHRINK:
			/* Not a feature in Lower Wacker */
			break;

		case XFR_SKIP:
			/* Only for some protocols */
			{
			XD_TYPE *pX;

			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			assert(pS);
			pX = pS->pstD;
			assert(pX);
			if (pX)
				{
				pX->nUserCancel = XFER_SKIP;
				}
			}
			break;

        //
        // Added XFR_SHUTDOWN back in to allow the session to cancel
        // (abort) the transfer when disconnecting. REV: 02/01/2001
        //
        case XFR_SHUTDOWN:
		case XFR_CANCEL:   // Yes, XFER_CANCEL and IDCANCEL
		case IDCANCEL:	   // go together. - mrw
			{
			XD_TYPE *pX;

			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			assert(pS);
			pX = pS->pstD;
			assert(pX);
			if (pX)
				{
				pX->nUserCancel = XFER_ABORT;
				}
			}
			break;

        case XFER_LOST_CARRIER:
            {
			XD_TYPE *pX;

			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			assert(pS);
            if (pS)
                {
			    pX = pS->pstD;
			    assert(pX);
			    if (pX)
				    {
				    pX->nCarrierLost = TRUE;
				    }
                }
			}
			break;

		case XFR_EXPAND:
			/* Not a feature in Lower Wacker */
			break;

		case XFR_CBPS:
			{
			XD_TYPE *pX;

			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			assert(pS);
			pX = pS->pstD;
			assert(pX);
			if (pX)
				{
				if (pX->nBps)
					{
					pX->nBps = FALSE;
					}
				else
					{
					pX->nBps = TRUE;
					}
				}
			}
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	xfrDisplayFunc
 *
 * DESCRIPTION:
 *	Multiplex timer callback routine used for transfer display
 *
 * ARGUMENTS:
 *	DWORD	dwData	- double word data value passed thru timer
 *	ULONG	uTime	- contains time elapsed.
 *
 * RETURNS:
 *	TRUE always
 *
 */
VOID PASCAL xfrDisplayFunc(SDS *pstL)
	{
	XD_TYPE *pstD;
	HWND hwnd;
	UCHAR acBuffer[64];

	pstD = pstL->pstD;

	//assert(pstD->bTheirName == 1);

	if (pstD->bTheirName)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_THEIR_NAME_BOX);
		if (hwnd)
			{
			SetWindowText(hwnd, pstD->acTheirName);
			pstD->bTheirName = 0;
			}
		}

	if (pstD->bOurName)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_OUR_NAME_BOX);
		if (hwnd)
			{
			SetWindowText(hwnd, pstD->acOurName);
			pstD->bOurName = 0;
			}
		}

	if (pstD->bTotalCnt)
		{
		if (pstD->wTotalCnt > 1)
			{
			assert(pstD->hwndXfrDisplay);
			if (pstD->hwndXfrDisplay)
				{
				PostMessage(pstD->hwndXfrDisplay,
							WM_DLG_TO_DISPLAY,
							XFR_SINGLE_TO_DOUBLE,
							0L);
				pstD->bTotalCnt = 0;
				return;
				}
			}
		}

	if (pstD->bFileCnt)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_FILES_BOX);
		if (hwnd)
			{
			TCHAR   acMsg[64];
			INT_PTR Args[2];

			LoadString(glblQueryDllHinst(),
						pstD->wTotalCnt ? IDS_XD_I_OF_I : IDS_XD_ONLY_1,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			Args[0] = pstD->wFileCnt;
			Args[1] = pstD->wTotalCnt;

            //
            // Make sure to clear out the buffer.
            //
            TCHAR_Fill(acBuffer, TEXT('\0'), sizeof(acBuffer) / sizeof(TCHAR));

			FormatMessage(FORMAT_MESSAGE_FROM_STRING |
						  FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  acMsg,
						  0,
						  0,
						  acBuffer,
						  sizeof(acBuffer) / sizeof(TCHAR),
						  (va_list *)Args);

			//wsprintf(acBuffer, acMsg,
			//		  pstD->wFileCnt,
			//		  pstD->wTotalCnt);
#if FALSE
			if (pstD->wTotalCnt == 0)
				{
				wsprintf(acBuffer,
						 "%d",
						 pstD->wFileCnt);
				}
			else
				{
				wsprintf(acBuffer,
						 "%d of %d",
						 pstD->wFileCnt,
						 pstD->wTotalCnt);
				}
#endif
			SetWindowText(hwnd, acBuffer);
			pstD->bFileCnt = 0;
			}
		}

	if (pstD->bEvent)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_EVENT_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						xfrGetEventBase(sessQueryXferHdl(pstL->hSession))
							+ pstD->wEvent,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));
			SetWindowText(hwnd, acMsg);
			pstD->bEvent = 0;
			}
		}

	if (pstD->bPacketNumber)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_PACKET_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						IDS_XD_INT,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			wsprintf(acBuffer, acMsg, pstD->lPacketNumber);
			SetWindowText(hwnd, acBuffer);
			pstD->bPacketNumber = 0;
			}
		}

	if (pstD->bErrorCnt)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_RETRIES_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						IDS_XD_INT,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			wsprintf(acBuffer,
					 acMsg,
					 pstD->wErrorCnt);
			SetWindowText(hwnd, acBuffer);
			pstD->bErrorCnt = 0;
			}
		}

	if (pstD->bStatus)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_STATUS_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						xfrGetStatusBase(sessQueryXferHdl(pstL->hSession))
							+ pstD->wStatus,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));
			SetWindowText(hwnd, acMsg);
			pstD->bStatus = 0;
			}
		}

	if (pstD->bFileSize)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_FILE_METER);
		if (hwnd)
			{
			PostMessage(hwnd,
						WM_VU_SETMAXRANGE,
						0, pstD->lFileSize);
			PostMessage(hwnd,
						WM_VU_SETCURVALUE,
						0, 0L);
			}
		hwnd = GetDlgItem(pstL->hDlg, XFR_FILE_SIZE_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						IDS_XD_KILO,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			wsprintf(acBuffer,
					 acMsg,
					 (UINT)((pstD->lFileSize + 1023) / 1024)
					);
			SetWindowText(hwnd, acBuffer);
			}
		pstD->bFileSize = 0;
		}

	if (pstD->bFileSoFar)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_FILE_METER);
		if (hwnd)
			{
			PostMessage(hwnd,
						WM_VU_SETCURVALUE,
						0, pstD->lFileSoFar);
			}

		hwnd = GetDlgItem(pstL->hDlg, XFR_FILE_BOX);
		if (hwnd)
			{
			LPTSTR acPtrs[3];
			TCHAR acNumF[8];
			TCHAR acNum1[32];
			TCHAR acNum2[32];
			TCHAR acMsg[128];
			// DbgOutStr("display filesofar %ld %ld 0x%lx\r\n",
			//			pstD->lFileSoFar, pstD->lFileSize, pstD, 0,0);

#if FALSE
			/* Changed to what follows for Internationalization */
			LoadString(glblQueryDllHinst(),
						pstD->lFileSize ? IDS_XD_K_OF_K : IDS_XD_KILO,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			wsprintf(acBuffer, acMsg,
					 (UINT)((pstD->lFileSoFar + 1023) / 1024),
					 (UINT)((pstD->lFileSize + 1023) / 1024));
#endif
			if (pstD->lFileSize)
				{
				LoadString(glblQueryDllHinst(),
							IDS_XD_K_OF_K,
							acMsg,
							sizeof(acMsg) / sizeof(TCHAR));
				LoadString(glblQueryDllHinst(),
							IDS_XD_INT,
							acNumF,
							sizeof(acNumF) / sizeof(TCHAR));
				wsprintf(acNum1, acNumF, ((pstD->lFileSoFar + 1023) / 1024));
				wsprintf(acNum2, acNumF, ((pstD->lFileSize + 1023) / 1024));
				acPtrs[0] = acNum1;
				acPtrs[1] = acNum2;
				acPtrs[2] = NULL;
#if defined(DO_FM)
				FormatMessage(
					FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
					acMsg,
					0,				/* String ID, ignored */
					0,				/* Also ignored */
					acBuffer,
					sizeof(acBuffer) / sizeof(TCHAR),
					(va_list *)&acPtrs[0]
					);
#else
				wsprintf(acBuffer, "%sK of %sK", acPtrs[0], acPtrs[1]);
#endif
				}
			else
				{
				LoadString(glblQueryDllHinst(),
							IDS_XD_KILO,
							acMsg,
							sizeof(acMsg) / sizeof(TCHAR));

				wsprintf(acBuffer, acMsg,
						 (UINT)((pstD->lFileSoFar + 1023) / 1024),
						 (UINT)((pstD->lFileSize + 1023) / 1024));
				}
			SetWindowText(hwnd, acBuffer);
			}
		pstD->bFileSoFar = 0;
		}

	if (pstD->bTotalSoFar)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_TOTAL_METER);
		// DbgOutStr("TotalSoFar %ld 0x%x\r\n", pstD->lTotalSoFar, hwnd, 0,0,0);
		if (hwnd)
			{
			PostMessage(hwnd,
						WM_VU_SETCURVALUE,
						0, pstD->lTotalSoFar);
			}

		hwnd = GetDlgItem(pstL->hDlg, XFR_TOTAL_BOX);
		if (hwnd)
			{
			LPTSTR acPtrs[3];
			TCHAR acNumF[8];
			TCHAR acNum1[32];
			TCHAR acNum2[32];
			TCHAR acMsg[128];
			// DbgOutStr("display totalsofar %ld %ld 0x%lx\r\n",
			//			pstD->lTotalSoFar, pstD->lTotalSize, pstD, 0,0);

#if FALSE
			/* Changed to what follows for Internationalization */
			LoadString(glblQueryDllHinst(),
						pstD->lTotalSize ? IDS_XD_K_OF_K : IDS_XD_KILO,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			wsprintf(acBuffer, acMsg,
					 (UINT)((pstD->lTotalSoFar + 1023) / 1024),
					 (UINT)((pstD->lTotalSize + 1023) / 1024)
				 );
#endif
			if (pstD->lFileSize)
				{
				LoadString(glblQueryDllHinst(),
							IDS_XD_K_OF_K,
							acMsg,
							sizeof(acMsg) / sizeof(TCHAR));
				LoadString(glblQueryDllHinst(),
							IDS_XD_INT,
							acNumF,
							sizeof(acNumF) / sizeof(TCHAR));
				wsprintf(acNum1, acNumF, ((pstD->lTotalSoFar + 1023) / 1024));
				wsprintf(acNum2, acNumF, ((pstD->lTotalSize + 1023) / 1024));
				acPtrs[0] = acNum1;
				acPtrs[1] = acNum2;
				acPtrs[2] = NULL;
#if defined(DO_FM)
				FormatMessage(
					FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
					acMsg,
					0,				/* String ID, ignored */
					0,				/* Also ignored */
					acBuffer,
					sizeof(acBuffer) / sizeof(TCHAR),
					(va_list *)&acPtrs[0]
					);
#else
				wsprintf(acBuffer, "%sK of %sK", acPtrs[0], acPtrs[1]);
#endif
				}
			else
				{
				LoadString(glblQueryDllHinst(),
							IDS_XD_KILO,
							acMsg,
							sizeof(acMsg) / sizeof(TCHAR));

				wsprintf(acBuffer, acMsg,
						 (UINT)((pstD->lTotalSoFar + 1023) / 1024),
						 (UINT)((pstD->lTotalSize + 1023) / 1024));
				}
			SetWindowText(hwnd, acBuffer);
			}

		if (pstD->lTotalSize != 0)
			{
			xfrSetPercentDone(sessQueryXferHdl(pstL->hSession),
						(int)((pstD->lTotalSoFar * 100L) / pstD->lTotalSize));
			}

		pstD->bTotalSoFar = 0;
		}

	if (pstD->bTotalSize)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_TOTAL_METER);
		// DbgOutStr("TotalSize %ld 0x%x\r\n", pstD->lTotalSize, hwnd, 0,0,0);
		if (hwnd)
			{
			PostMessage(hwnd,
						WM_VU_SETMAXRANGE,
						0, pstD->lTotalSize);
			PostMessage(hwnd,
						WM_VU_SETCURVALUE,
						0, 0L);
			pstD->bTotalSize = 0;
			}
		}

	if (pstD->bElapsedTime)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_ELAPSED_BOX);
		if (hwnd)
			{
			wsprintf(acBuffer,
					 " %02d:%02d:%02d",
					 (USHORT)(pstD->lElapsedTime / 3600),
					 (USHORT)((pstD->lElapsedTime / 60) % 60),
					 (USHORT)(pstD->lElapsedTime % 60)
					 );
			SetWindowText(hwnd, acBuffer);
			pstD->bElapsedTime = 0;
			}
		}

	if (pstD->bRemainingTime)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_REMAINING_BOX);
		if (hwnd)
			{
			if (pstD->lRemainingTime < 0)
				pstD->lRemainingTime = 0;

			wsprintf(acBuffer,
					 " %02d:%02d:%02d",
					 (USHORT)(pstD->lRemainingTime / 3600),
					 (USHORT)((pstD->lRemainingTime / 60) % 60),
					 (USHORT)(pstD->lRemainingTime % 60)
					 );
			SetWindowText(hwnd, acBuffer);
			pstD->bRemainingTime = 0;
			}
		}

	if (pstD->bThroughput)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_THRUPUT_BOX);
		if (hwnd)
			{
			int nValue;
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
					xfrGetXferDspBps(sessQueryXferHdl(pstL->hSession)) ?
						IDS_XD_BPS : IDS_XD_CPS,
					acMsg,
					sizeof(acMsg) / sizeof(TCHAR));

			nValue = pstD->lThroughput;
			if (xfrGetXferDspBps(sessQueryXferHdl(pstL->hSession)))
				nValue *= 10;

			wsprintf(acBuffer, acMsg, nValue);

			SetWindowText(hwnd, acBuffer);
			pstD->bThroughput = 0;
			}
		}

	if (pstD->bLastErrtype)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_LAST_ERROR_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						xfrGetStatusBase(sessQueryXferHdl(pstL->hSession))
							+ pstD->wLastErrtype,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));
			SetWindowText(hwnd, acMsg);
			pstD->bLastErrtype = 0;
			}
		}

	if (pstD->bPcktErrCnt)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_PACKET_RETRY_BOX);
		if (hwnd)
			{
			TCHAR acMsg[64];

			LoadString(glblQueryDllHinst(),
						IDS_XD_INT,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			wsprintf(acBuffer,
					 acMsg,
					 pstD->wPcktErrCnt);

			SetWindowText(hwnd, acBuffer);
			pstD->bPcktErrCnt = 0;
			}
		}

	if (pstD->bChecktype)
		{
		int nTag;
		TCHAR acMsg[64];

		hwnd = GetDlgItem(pstL->hDlg, XFR_ERROR_CHECKING_BOX);
		if (hwnd)
			{
			switch (pstD->wChecktype)
				{
				default:
				case 0:
					nTag = IDS_XD_CRC;
					break;
				case 1:
					nTag = IDS_XD_CHECK;
					break;
				case 2:
					nTag = IDS_XD_STREAM;
					break;
				}
			LoadString(glblQueryDllHinst(),
						nTag,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			SetWindowText(hwnd, acMsg);
			pstD->bChecktype = 0;
			}
		}

	if (pstD->bProtocol)
		{
		int nTag;
		TCHAR acMsg[64];

		hwnd = GetDlgItem(pstL->hDlg, XFR_PROTOCOL_BOX);
		if (hwnd)
			{
			switch (pstD->uProtocol)
				{
				default:
				case 1:
					nTag = IDS_XD_CB;
					break;
				case 2:
					nTag = IDS_XD_BP;
					break;
				}
			LoadString(glblQueryDllHinst(),
						nTag,
						acMsg,
						sizeof(acMsg) / sizeof(TCHAR));

			SetWindowText(hwnd, acMsg);
			pstD->bProtocol = 0;
			}
		}

	if (pstD->bMessage)
		{
		hwnd = GetDlgItem(pstL->hDlg, XFR_MESSAGE_BOX);
		if (hwnd)
			{
			SetWindowText(hwnd, pstD->acMessage);
			pstD->bMessage = 0;
			}
		}

	if (pstD->nClose)
		{
		HWND hWnd;

		/* It's time to quit */

		xfrSetPercentDone(sessQueryXferHdl(pstL->hSession), 0);

		// We decided that the new way might be a bit safer
		// EndModelessDialog(pstD->hwndXfrDisplay);

		hWnd = pstD->hwndXfrDisplay;
		pstD->hwndXfrDisplay = (HWND)0;

		PostMessage(sessQueryHwnd(pstL->hSession),
					WM_SESS_ENDDLG,
					0, (LPARAM)hWnd);
		}

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\xfer_msc.h ===
/*	File: D:\WACKER\tdll\xfer_msc.h (Created: 28-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:41p $
 */

extern HXFER CreateXferHdl(const HSESSION hSession);

// extern INT InitializeXferHdl(const HSESSION hSession);

extern INT InitializeXferHdl(const HSESSION hSession, HXFER hXfer);

extern INT LoadXferHdl(HXFER hXfer);

// extern INT SaveXferHdl(const HSESSION hSession);

extern INT SaveXferHdl(HXFER hXfer);

// extern INT DestroyXferHdl(const HSESSION hSession);

extern INT DestroyXferHdl(HXFER hXfer);

// extern VOID WINAPI xfrSetDataPointer(HSESSION hSession, VOID *pData);

extern VOID WINAPI xfrSetDataPointer(HXFER hXfer, VOID *pData);

// extern VOID WINAPI xfrQueryDataPointer(HSESSION hSession, VOID **ppData);

extern VOID WINAPI xfrQueryDataPointer(HXFER hXfer, VOID **ppData);

// extern INT WINAPI xfrQueryParameters(HSESSION hSession, VOID **ppData);

extern INT WINAPI xfrQueryParameters(HXFER hXfer, VOID **ppData);

// extern void xfrSetParameters(HSESSION hSession, VOID *pData);

extern void xfrSetParameters(HXFER hXfer, VOID *pData);

// extern int WINAPI xfrQueryProtoParams(HSESSION hSession, int nId, VOID **ppData);

extern int WINAPI xfrQueryProtoParams(HXFER hXfer, int nId, VOID **ppData);

// extern void WINAPI xfrSetProtoParams(HSESSION hSession, int nId, VOID *pData);

extern void WINAPI xfrSetProtoParams(HXFER hXfer, int nId, VOID *pData);

// extern int xfrSendAddToList(HSESSION hSession, LPCTSTR pszFile);

extern int xfrSendAddToList(HXFER hXfer, LPCTSTR pszFile);

// extern int xfrSendListSend(HSESSION hSession);

extern int xfrSendListSend(HXFER hXfer);

// extern int xfrRecvStart(HSESSION hSession, LPCTSTR pszDir, LPCTSTR pszName);

extern int xfrRecvStart(HXFER hXfer, LPCTSTR pszDir, LPCTSTR pszName);

// extern int xfrGetEventBase(HSESSION hSession);

extern int xfrGetEventBase(HXFER hXfer);

// extern int xfrGetStatusBase(HSESSION hSession);

extern int xfrGetStatusBase(HXFER hXfer);

// extern int xfrGetXferDspBps(HSESSION hSession);

extern int xfrGetXferDspBps(HXFER hXfer);

// extern int xfrSetXferDspBps(HSESSION hSession, int nBps);

extern int xfrSetXferDspBps(HXFER hXfer, int nBps);

// extern void xfrDoTransfer(HSESSION hSession);

extern void xfrDoTransfer(HXFER hXfer);

// extern void xfrDoAutostart(HSESSION hSession, long lProtocol);

extern void xfrDoAutostart(HXFER hXfer, long lProtocol);

// extern void xfrSetPercentDone(HSESSION hSession, int nPerCent);

extern void xfrSetPercentDone(HXFER hXfer, int nPerCent);

// extern int  xfrGetPercentDone(HSESSION hSession);

extern int  xfrGetPercentDone(HXFER hXfer);

// extern HWND xfrGetDisplayWindow(HSESSION hSession);

extern HWND xfrGetDisplayWindow(HXFER hXfer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\term\makefile.inc ===
$(O)\ver_exe.i: verexe.rc version.h
    cl /nologo /D$(VERSION) /I$(SDK_INC_PATH) /Tcverexe.rc /E > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\term\res.h ===
/*      File: D:\WACKER\term\res.h (Created: 26-Nov-1993)
 *
 *      Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *      All rights reserved
 *
 *      $Revision: 23 $
 *      $Date: 5/01/02 1:54p $
 */

//NOTE: Take this one out if it is defined in some CHICAGO build.
#if !(defined(DS_NONBOLD))
	#define DS_NONBOLD      4L
#endif

#include "..\tdll\features.h"

/*-----------------------------------------------------------------------------
 * Here are our naming conventions for IDs for dialog, menu, string,
 * accelerator, control and etc.  If you modify this file also modify the
 * corresponding copies (KOPYKAT.RH - KopyKat, HA5G.H - HA/Win, RES.H - Wacker).
 *
 * IDx_[yy_][module_]name
 *
 * where x is           D for dialogs
 *                                      C for controls
 *                                      M for menus
 *                                      A for accelerators
 *                                      S for strings
 *                                      U for RC data
 *                                      V for VERSIONINFO resource
 *
 *               yy is          BM for bitmap
 *                                      CB for combo box
 *                                      CK for check box
 *                                      EF for edit field
 *                                      FR for frame control
 *                                      GR for group box
 *                                      IC for icon
 *                                      LB for list box
 *                                      ML for multi-line edit box
 *                                      PB for push button
 *                                      RB for radio button
 *                                      SB for spin button
 *                                      SL for slider control
 *                                      ST for static text
 *                                      VU for vu meter (custom control)
 *
 *                                      (yy is only used if x is D)
 *
 *                                      NOTE: If you need to make up an id for a control not listed,
 *                                      assign it a unique two letter sequence and add it into
 *                                      the list in alphabetic order.
 *
 *               module         is provided to give us the ability to further distinguish
 *                                      controls.  It will allow for IDC_CB_VT100_CharacterSets
 *                                      and IDC_CB_VT52_CharacterSets to coexist.
 *
 *               name           is the control specific description.
 *
 *--------------------------------------------------------------------------- */

/* ----- Dialog Identifiers ----- */

#define IDD_TRANSFERSEND                100
#define IDD_TRANSFERRECEIVE             200
#define IDD_RECEIVEFILENAME2            300
#define IDD_RECEIVEFILENAME             400
#define IDD_FINDDIRECTORY               500
#define IDD_NEWCONNECTION               600
#define IDD_XFERZMDMSNDSTANDARDDOUBLE   700
#define IDD_XFERZMDMSNDSTANDARDSINGLE   800
#define IDD_XFERZMDMRECSTANDARDDOUBLE   900
#define IDD_XFERZMDMRECSTANDARDSINGLE  1000
#define IDD_XFERYMDMSNDSTANDARDDOUBLE  1100
#define IDD_XFERYMDMSNDSTANDARDSINGLE  1200
#define IDD_XFERYMDMRECSTANDARDDISPLAY 1300
#define IDD_XFERXMDMSNDSTANDARDDISPLAY 1400
#define IDD_XFERXMDMRECSTANDARDDISPLAY 1500
#define IDD_XFERKRMSNDSTANDARDDOUBLE   1600
#define IDD_XFERKRMSNDSTANDARDSINGLE   1700
#define IDD_XFERKRMRECSTANDARDDISPLAY  1800
#define IDD_XFERHPRSNDSTANDARDSINGLE   1900
#define IDD_XFERHPRSNDSTANDARDDOUBLE   2000
#define IDD_XFERHPRRECSTANDARDSINGLE   2100
#define IDD_XFERHPRRECSTANDARDDOUBLE   2200
#define IDD_CAPTURE                    2300
#define IDD_TAB_PHONENUMBER            2400
#define IDD_TAB_TERMINAL               2500
#define IDD_PRINTABORT                 2600
#define IDD_CUSTOM_PAGE_SETUP          2601
#define IDD_ASCII_SETUP                2700
#define IDD_SCRN_COLOR_SETTINGS        3400	// Moved from EMUDLGS.RC to DIALOGS.RC -- REV: 12/28/2001
#define IDD_ABOUT_DLG                  2750
#define IDD_UPGRADE_INFO               2751
#define IDR_UPGRADE_TEXT               2752
#define IDD_DEFAULT_TELNET             2753
#define IDD_KEYSUMMARYDLG              2754
#define IDD_KEYDLG                     2755
#define IDD_TERMINAL_SIZE_AND_COLORS   2756
#ifdef INCL_NAG_SCREEN
#define IDD_NAG_SCREEN                 2757
#define IDD_NAG_REGISTER               2758
#define IDD_NAG_PURCHASE               2759
#define IDD_REGISTRATION_REMINDER      2760
#endif
#define IDC_TERMINAL_SIZE_AND_COLORS    1005
#define IDC_EDIT_ROWS                   1006
#define IDC_EDIT_COLUMNS                1007
#ifdef INCL_NAG_SCREEN
#define IDC_NAG_CODE                    1008
#define IDC_NAG_PURCHASE                1009
#define IDC_NAG_TIME                    1010
#define IDC_NAG_ICON                    1011
#define IDC_REGISTER_EDIT               1012
#define IDC_PURCHASE_METHOD_WEB         1013
#define IDC_PURCHASE_METHOD_ORDER       1014
#define IDC_ORDER_INFO_NAME             1015
#define IDC_ORDER_INFO_COMPANY          1016
#define IDC_ORDER_INFO_ADDRESS          1017
#define IDC_ORDER_INFO_PHONE            1018
#define IDC_ORDER_INFO_EXTENSION        1019
#define IDC_CREDIT_CARD_MASTERCARD      1020
#define IDC_CREDIT_CARD_VISA            1021
#define IDC_CREDIT_CARD_AMERICAN_EXPRESS    1022
#define IDC_ORDER_INFO_CARD_NUMBER      1023
#define IDC_ORDER_INFO_CARD_EXPIRATION  1024
#define IDC_ORDER_EMAIL                 1025
#define IDC_ORDER_PRINT                 1027
#define IDC_ORDER_PHONE                 1028
#define IDC_ORDER_HOURS					1029
#define IDC_NAG_EXP_DAYS                1030
#endif
#define IDC_BUTTON3                     1026
#define IDC_STATIC5                     1112
#define IDC_STATIC6                     1113
#define IDC_STATIC7                     1114
#define IDC_TEXT_BLACK                  1303
#define IDC_TEXT_DARKGRAY               1304
#define IDC_TEXT_DARKBLUE               1305
#define IDC_TEXT_BLUE                   1306
#define IDC_TEXT_DARKGREEN              1307
#define IDC_TEXT_GREEN                  1308
#define IDC_TEXT_DARKCYAN               1309
#define IDC_TEXT_CYAN                   1310
#define IDC_TEXT_DARKRED                1311
#define IDC_TEXT_RED                    1312
#define IDC_TEXT_DARKMAGENTA            1313
#define IDC_TEXT_DARKYELLOW             1314
#define IDC_TEXT_LIGHTGRAY              1315
#define IDC_TEXT_MAGENTA                1316
#define IDC_TEXT_YELLOW                 1317
#define IDC_TEXT_WHITE                  1318
#define IDC_BACK_BLACK                  1319
#define IDC_BACK_DARKGRAY               1320
#define IDC_BACK_DARKBLUE               1321
#define IDC_BACK_BLUE                   1322
#define IDC_BACK_DARKGREEN              1323
#define IDC_BACK_GREEN                  1324
#define IDC_BACK_DARKCYAN               1325
#define IDC_BACK_CYAN                   1326
#define IDC_BACK_DARKRED                1327
#define IDC_BACK_RED                    1340
#define IDC_BACK_DARKMAGENTA            1341
#define IDC_BACK_DARKYELLOW             1342
#define IDC_BACK_LIGHTGRAY              1343
#define IDC_BACK_MAGENTA                1344
#define IDC_BACK_YELLOW                 1345
#define IDC_BACK_WHITE                  1346
#define IDC_TEXT_PREVIEW                1347
#define IDC_PREVIEW_GROUPBOX            1348
#define IDC_REGISTER_NOW                1349
#define IDC_REGISTER_LATER              1350
#define IDC_REGISTER_NOT                1351
#define IDC_STATIC                      -1

/* ---- from CNCTTAPI.RC ---- */

#define IDD_CNCT_CONFIRM               2800
#define IDD_CNCT_NEWPHONE              2900
#define IDD_DIALING                                3000
#define IDD_CNCT_PCMCIA                            3100

/* ---- from EMUDLGS.RC  ---- */

#define IDD_ANSI_SETTINGS				3500
#define IDD_VT100_SETTINGS				3600
#define IDD_VT100J_SETTINGS				3650
#define IDD_VT52_SETTINGS				3700
#define IDD_VT220_SETTINGS				3750
#define IDD_VT320_SETTINGS				3755
#define IDD_TTY_SETTINGS				3800
#define IDD_MINITEL_SETTINGS			3900
#define IDD_VIEWDATA_SETTINGS			3950

/* ----- Menu Identifiers ----- */

#define IDM_MENU_BASE                   40000

#define IDM_MAIN_MENU_FILE              0
#define IDM_MAIN_MENU_EDIT              1
#define IDM_MAIN_MENU_VIEW              2
#define IDM_MAIN_MENU_ACTIONS   3
#define IDM_MAIN_MENU_HELP              4

#define IDM_NEW                         100
#define IDM_OPEN                        101
#define IDM_SAVE                        102
#define IDM_SAVE_AS                     103
#define IDM_PAGESETUP           104
#define IDM_CHOOSEPRINT         105
#define IDM_PRINT                       106
#define IDM_PROPERTIES          107
#define IDM_EXIT                        108

#define IDM_COPY                        200
#define IDM_PASTE                       201
#define IDM_SELECT_ALL          202
#define IDM_CLEAR_BACKSCROLL    203
#define IDM_CLEAR_SCREEN        204

#define IDM_VIEW_TOOLBAR        300
#define IDM_VIEW_STATUS         301
#define IDM_VIEW_FONTS          302
#define IDM_VIEW_SNAP       303

#define IDM_ACTIONS_DIAL                    400
#define IDM_ACTIONS_HANGUP                  401
#define IDM_ACTIONS_SEND                    402
#define IDM_ACTIONS_RCV                     403
#define IDM_ACTIONS_CAP                     404
#define IDM_ACTIONS_PRINT                   405
#define IDM_ACTIONS_SEND_TEXT       406
#define IDM_ACTIONS_WAIT_FOR_CALL   407
#define IDM_ACTIONS_STOP_WAITING    408

#define IDM_CAPTURE_STOP                420
#define IDM_CAPTURE_PAUSE               421
#define IDM_CAPTURE_RESUME              422

#define IDM_PRNECHO_STOP                424
#define IDM_PRNECHO_PAUSE               425
#define IDM_PRNECHO_RESUME              426

//#define IDM_HELP                              500
#define IDM_HELPTOPICS          501
#define IDM_ABOUT               502
#define IDM_KEY_MACROS          503
#define IDM_PURCHASE_INFO       504
#define IDM_REG_CODE            505
#define IDM_REGISTER            506
#define IDM_DISCUSSION          507

/* --- Identifiers for Test Menu --- */

#define IDM_TEST_SAVEAS                 600
#define IDM_TEST_CLEARTERM              601
#define IDM_TEST_CLEARBACK              602
#define IDM_TEST_SELECTTERM     603
#define IDM_TEST_SELECTBACK     604
#define IDM_TEST_CONNECT                605
#define IDM_TEST_DISCONNECT     606
#define IDM_TEST_TESTFILE               610
#define IDM_TEST_BEZEL                  611
#define IDM_TEST_SNAP                   612
#define IDM_TEST_SHOWTIPS               613
#define IDM_TEST_NEW_CONNECTION 617
#define IDM_TEST_FLUSH_BACKSCRL 618

#define IDM_TEST_LOAD_EMU               619
#define IDM_TEST_LOAD_AUTO              620
#define IDM_TEST_LOAD_ANSI              621
#define IDM_TEST_LOAD_VT52              622
#define IDM_TEST_LOAD_VT100     623
#define IDM_TEST_LOAD_VIEWDATA  624
#define IDM_TEST_LOAD_MINITEL   625
#define IDM_TEST_LOAD_TTY               626

#define IDM_TEST_SESSNAME               627
#define IDM_TEST_LOAD_VT220     628

/* ---  --- */

#define IDM_CUST_TOOLBAR        700

/* --- Session Context Menu Identifiers --- */

#define IDM_CONTEXT_SEND                800
#define IDM_CONTEXT_RECEIVE             801
#define IDM_CONTEXT_PRINT               802
#define IDM_CONTEXT_COPY                803
#define IDM_CONTEXT_PASTE               804
#define IDM_CONTEXT_SELECT_ALL          805
#define IDM_CONTEXT_WHATS_THIS          806
#define IDM_CONTEXT_SNAP                807
#define IDM_CONTEXT_CLEAR_BACKSCROLL    808
#define IDM_CONTEXT_CLEAR_SCREEN        809

/* --- Identifiers for Minitel toolbar buttons --- */

#define IDM_MINITEL_INDEX                               900
#define IDM_MINITEL_CANCEL                              901
#define IDM_MINITEL_PREVIOUS                    902
#define IDM_MINITEL_REPEAT                              903
#define IDM_MINITEL_GUIDE                               904
#define IDM_MINITEL_CORRECT                     905
#define IDM_MINITEL_NEXT                                906
#define IDM_MINITEL_SEND                                907
#define IDM_MINITEL_CONFIN                              908

/* --- String identifiers --- */

#define IDS_GNRL_APPNAME                100
#define IDS_GNRL_AUTHOR                 101
#define IDS_GNRL_HELPFILE               102
#define IDS_GNRL_PRSHT_TITLE    103
#define IDS_GNRL_NEW_CNCT               104
#define IDS_GNRL_HAS                    105
#define IDS_GNRL_CNFRM_SAVE     106
#define IDS_GNRL_CNFRM_OVER     107
#define IDS_GNRL_CNFRM_DCNCT    108
#define IDS_GNRL_ELLIPSIS               109
#define IDS_GNRL_CREATE_PATH    110
#define IDS_GNRL_INVALID_CHARS  111
#define IDS_GNRL_INVALID_NAME   112
#define IDS_GNRL_PROFILE_DIR    113
//mpt:8-22-97
#if defined(INCL_USE_HTML_HELP)
#define IDS_HTML_HELPFILE               114
#endif
#ifdef INCL_NAG_SCREEN
#define IDS_GNRL_UNREGISTERED   115
#endif
#define IDS_GNRL_HILGRAVE_COPYRIGHT		116		
#define IDS_GNRL_NEED_FNAME				117
#define IDS_GNRL_INVALID_FNAME_CHARS	118
#define IDS_GNRL_NEED_COUNTRYCODE		119	
#define IDS_GNRL_NEED_AREACODE			120
#define IDS_GNRL_NEED_PHONENUMBER		121
#define IDS_GNRL_NEED_CONNECTIONTYPE	122
#define IDS_GNRL_INVALID_FILE_CHARS     123
#define IDS_GNRL_NEED_SESSION_NAME		124

#define IDS_TTT_NEW        130
#define IDS_TTT_OPEN       131
#define IDS_TTT_DIAL       132
#define IDS_TTT_HANGUP     133
#define IDS_TTT_SEND       134
#define IDS_TTT_RECEIVE    135
#define IDS_TTT_PROPERTY   136
/* #define IDS_TTT_HELP           137 */

/* --- String identifiers for Minitel sidebar button strings --- */

#define IDS_SIDEBAR_INDEX          138
#define IDS_SIDEBAR_CANCEL         139
#define IDS_SIDEBAR_PREVIOUS   140
#define IDS_SIDEBAR_REPEAT         141
#define IDS_SIDEBAR_GUIDE          142
#define IDS_SIDEBAR_CORRECT    143
#define IDS_SIDEBAR_NEXT           144
#define IDS_SIDEBAR_MSEND          145
#define IDS_SIDEBAR_CONFIN         146

/* --- End Mintel string ids --- */

#define IDS_CMM_ALL_FILES1 200
#define IDS_CMM_ALL_FILES2 201
#define IDS_CMM_SEL_FILES  202
#define IDS_CMM_SEL_DIR    203

#define IDS_SND_DLG_DD     204
#define IDS_SND_DLG_FILE   205

#define IDS_CMM_SAVE_AS    206
#define IDS_CMM_LOAD_SESS  207
#define IDS_CMM_HAS_FILES1 208
#define IDS_CMM_HAS_FILES2 209
#define IDS_CMM_HAS_FILES3 210
#define IDS_CMM_HAS_FILES4 211
#define IDS_SND_TXT_FILE   212

#define IDS_RM_APPEND      220
#define IDS_RM_OVERWRITE   221
#define IDS_RM_REFUSE      222
#define IDS_RM_NEWER       223
#define IDS_RM_DATE        224
#define IDS_RM_SEQUENCE    225

#define IDS_CPF_DLG_FILE                230
#define IDS_CPF_FILES1                  231
#define IDS_CPF_FILES2                  232
#define IDS_CPF_FILES3                  233
#define IDS_CPF_FILES4                  234
#define IDS_CPF_CAP_OFF                 235
#define IDS_CPF_CAP_ON                  236
#define IDS_CPF_SELECT_FILE             237
#define IDS_CPF_CAP_FILE                238

#define IDS_XD_RECEIVE     240
#define IDS_XD_SEND        241
#define IDS_XD_ON          242
#define IDS_XD_OFF         243
#define IDS_XD_CRC         244
#define IDS_XD_CHECK       245
#define IDS_XD_STREAM      246
#define IDS_XD_CB          247
#define IDS_XD_BP          248
#define IDS_XD_INT         249
#define IDS_XD_I_OF_I      250
#define IDS_XD_KILO        251
#define IDS_XD_K_OF_K      252
#define IDS_XD_BPS         253
#define IDS_XD_CPS         254
#define IDS_XD_PERCENT     255
#define IDS_XD_RECV_TITLE  256
#define IDS_XD_SEND_TITLE  257
#define IDS_XD_ONLY_1      258

#define IDS_XD_PROTO_X_1   270
#define IDS_XD_PROTO_X     271
#define IDS_XD_PROTO_Y     272
#define IDS_XD_PROTO_Y_G   273
#define IDS_XD_PROTO_Z     274
#define IDS_XD_PROTO_K     275
#define IDS_XD_PROTO_Z_CR  276

#define IDS_MB_TITLE_WARN  300
#define IDS_MB_TITLE_ERR   301
#define IDS_MB_MSG_NO_FILE 310

#define IDS_TM_SD_ZERO                  365
#define IDS_TM_SD_ONE                   366
#define IDS_TM_SD_TWO                   367
#define IDS_TM_SD_THREE                 368
#define IDS_TM_SD_FOUR                  369
#define IDS_TM_SD_FIVE                  370
#define IDS_TM_SD_SIX                   371
#define IDS_TM_SD_SEVEN                 372
#define IDS_TM_SD_EIGHT                 373

#define IDS_TM_XFER_ZERO        375
#define IDS_TM_XFER_ONE         376
#define IDS_TM_XFER_TWO         377
#define IDS_TM_XFER_THREE       378
#define IDS_TM_XFER_FOUR        379
#define IDS_TM_XFER_FIVE        380
#define IDS_TM_XFER_SIX         381
#define IDS_TM_XFER_SEVEN       382
#define IDS_TM_XFER_EIGHT       383
#define IDS_TM_XFER_NINE        384
#define IDS_TM_XFER_TEN         385
#define IDS_TM_XFER_ELEVEN      386
#define IDS_TM_XFER_TWELVE      387
#define IDS_TM_XFER_THIRTEEN    388
#define IDS_TM_XFER_FOURTEEN    389
#define IDS_TM_XFER_FIFTEEN     390
#define IDS_TM_XFER_SIXTEEN     391
#define IDS_TM_XFER_SEVENTEEN   392
#define IDS_TM_XFER_EIGHTEEN    393
#define IDS_TM_XFER_NINETEEN    394
#define IDS_TM_XFER_TWENTY      395
#define IDS_TM_XFER_TWENTYONE   396
#define IDS_TM_XFER_TWENTYTWO   397
#define IDS_TM_XFER_TWENTYTHREE 398
#define IDS_TM_XFER_TWENTYFOUR  399

#define IDS_TM_SZ_ZERO          400
#define IDS_TM_SZ_ONE           401
#define IDS_TM_SZ_TWO           402
#define IDS_TM_SZ_THREE         403
#define IDS_TM_SZ_FOUR          404
#define IDS_TM_SZ_FIVE          405
#define IDS_TM_SZ_SIX           406
#define IDS_TM_SZ_SEVEN         407
#define IDS_TM_SZ_EIGHT         408
#define IDS_TM_SZ_NINE          409
#define IDS_TM_SZ_TEN           410
#define IDS_TM_SZ_ELEVEN        411
#define IDS_TM_SZ_TWELVE        412
#define IDS_TM_SZ_THIRTEEN      413
#define IDS_TM_SZ_FOURTEEN      414
#define IDS_TM_SZ_FIFTEEN       415
#define IDS_TM_SZ_SIXTEEN       416
#define IDS_TM_SZ_SEVENTEEN     417
#define IDS_TM_SZ_EIGHTEEN      418
#define IDS_TM_SZ_NINETEEN      419
#define IDS_TM_SZ_TWENTY        420
#define IDS_TM_SZ_TWENTYONE     421
#define IDS_TM_SZ_TWENTYTWO     422
#define IDS_TM_SZ_TWENTYTHREE   423
#define IDS_TM_SZ_TWENTYFOUR    424
#define IDS_TM_SZ_TWENTYFIVE    425
#define IDS_TM_SZ_TWENTYSIX     426

#define IDS_TM_RX_ZERO                  430
#define IDS_TM_RX_ONE                   431
#define IDS_TM_RX_TWO                   432
#define IDS_TM_RX_THREE                 433
#define IDS_TM_RX_FOUR                  434
#define IDS_TM_RX_FIVE                  435
#define IDS_TM_RX_SIX                   436
#define IDS_TM_RX_SEVEN                 437
#define IDS_TM_RX_EIGHT                 438
#define IDS_TM_RX_NINE                  439
#define IDS_TM_RX_TEN                   440
#define IDS_TM_RX_ELEVEN                441
#define IDS_TM_RX_TWELVE                442
#define IDS_TM_RX_THIRTEEN              443
#define IDS_TM_RX_FOURTEEN              444

#define IDS_TM_RS_ZERO                  450
#define IDS_TM_RS_ONE                   451
#define IDS_TM_RS_TWO                   452
#define IDS_TM_RS_THREE                 453
#define IDS_TM_RS_FOUR                  454

#define IDS_TM_RE_ZERO                  455
#define IDS_TM_RE_ONE                   456
#define IDS_TM_RE_TWO                   457
#define IDS_TM_RE_THREE                 458
#define IDS_TM_RE_FOUR                  459
#define IDS_TM_RE_FIVE                  460
#define IDS_TM_RE_SIX                   461
#define IDS_TM_RE_SEVEN                 462
#define IDS_TM_RE_EIGHT                 463
#define IDS_TM_RE_NINE                  464
#define IDS_TM_RE_TEN                   465
#define IDS_TM_RE_ELEVEN                466
#define IDS_TM_RE_TWELVE                467
#define IDS_TM_RE_THIRTEEN              468
#define IDS_TM_RE_FOURTEEN              469
#define IDS_TM_RE_FIFTEEN               470
#define IDS_TM_RE_SIXTEEN               471
#define IDS_TM_RE_SEVENTEEN             472
#define IDS_TM_RE_EIGHTEEN              473

#define IDS_TM_SS_ZERO                  475
#define IDS_TM_SS_ONE                   476
#define IDS_TM_SS_TWO                   477
#define IDS_TM_SS_THREE                 478
#define IDS_TM_SS_FOUR                  479
#define IDS_TM_SS_FIVE                  480

#define IDS_TM_SE_ZERO                  481
#define IDS_TM_SE_ONE                   482
#define IDS_TM_SE_TWO                   483
#define IDS_TM_SE_THREE                 484
#define IDS_TM_SE_FOUR                  485
#define IDS_TM_SE_FIVE                  486
#define IDS_TM_SE_SIX                   487
#define IDS_TM_SE_SEVEN                 488
#define IDS_TM_SE_EIGHT                 489
#define IDS_TM_SE_NINE                  490
#define IDS_TM_SE_TEN                   491
#define IDS_TM_SE_ELEVEN                492
#define IDS_TM_SE_TWELVE                493
#define IDS_TM_SE_THIRTEEN              494

#define IDS_TM_KRM_CANT_OPEN    497
#define IDS_TM_KRM_CANT_WRITE   498
#define IDS_TM_KRM_VIRUS_DETECT 499

#define IDS_TM_K_ZERO                   500
#define IDS_TM_K_ONE                    501
#define IDS_TM_K_TWO                    502
#define IDS_TM_K_THREE                  503
#define IDS_TM_K_FOUR                   504
#define IDS_TM_K_FIVE                   505
#define IDS_TM_K_SIX                    506
#define IDS_TM_K_SEVEN                  507
#define IDS_TM_K_EIGHT                  508
#define IDS_TM_K_NINE                   509

/* --- Statusbar Messages --- */

#define IDS_STATUSBR_CONNECT                    510
#define IDS_STATUSBR_CONNECT_FORMAT     511
#define IDS_STATUSBR_CONNECT_FORMAT_X   512
#define IDS_STATUSBR_DISCONNECT                 513
#define IDS_STATUSBR_CONNECTING                 514
#define IDS_STATUSBR_DISCONNECTING              515
#define IDS_STATUSBR_SCRL                               516
#define IDS_STATUSBR_CAPL                               517
#define IDS_STATUSBR_NUML                               518
#define IDS_STATUSBR_CAPTUREON                  519
#define IDS_STATUSBR_PRINTECHOON                520
#define IDS_STATUSBR_COM                                521
#define IDS_STATUSBR_AUTODETECT                 522
#define IDS_STATUSBR_COM_TCPIP          523
#define IDS_WINSOCK_SETTINGS_STR        524
#define IDS_STATUSBR_ANSWERING          525

/* --- Error Messages --- */

//#define IDS_ER_CNCT_FIND_DLL    600
//#define IDS_ER_CNCT_LOAD_DLL    601
#define IDS_ER_CNCT_BADCNTRYCDE 602
#define IDS_ER_CNCT_BADAREACODE 603
#define IDS_ER_CNCT_BADPHONENUM 604
#define IDS_ER_CNCT_BADLINE     605
#define IDS_ER_CNCT_NOMODEMS    606
#define IDS_ER_CNCT_TAPIFAILED  607
#define IDS_ER_CNCT_TAPINOMEM   608
#define IDS_ER_CNCT_CALLUNAVAIL 609
#define IDS_ER_CNCT_PORTFAILED  610
#define IDS_ER_TAPI_INIFILE     611
#define IDS_ER_TAPI_NODRIVER    612
#define IDS_ER_TAPI_NOMULTI     613
#define IDS_ER_TAPI_CONFIG              614
#define IDS_ER_CNCT_BADADDRESS  615
#define IDS_ER_TAPI_NEEDS_INFO  616
#define IDS_ER_TCPIP_FAILURE    617
#define IDS_ER_TCPIP_BADADDR    618
#define IDS_ER_TCPIP_MISSING_ADDR 619
#define IDS_OPEN_FAILED         620
#define IDS_ER_INVALID_TELNETID 621
#define IDS_ER_TAPI_UNKNOWN     622
#define IDS_ER_CNCT_BADADDRESS2 623
#define IDS_ER_CNCT_ACTIVETRANSFER 629
#define IDS_ER_CNCT_ACTIVETEXTSEND 630
#define IDS_ER_TAPI_NEEDS_RESET 631
#define IDS_ER_BACKSCROLL_SIZE  632
#define IDS_ER_TCPIP_MISSING_PORT  633
#define IDS_ER_CNCT_PASSTHROUGH 624
#define IDS_ER_LINE_DELAY_SIZE  625
#define IDS_ER_CHAR_DELAY_SIZE  626
#define IDS_ER_INVALID_PORT     627

#define IDS_PRINT_NOMEM                 702
#define IDS_PRINT_CANCEL                703
#define IDS_PRINT_ERROR                 704
#define IDS_PRINT_NOW_PRINTING  705
#define IDS_PRINT_OF_DOC                706
#define IDS_PRINT_ON_DEV                707
#define IDS_ER_NO_BITMAP                708
#define IDS_ER_TITLE                    709
#define IDS_ER_BAD_SESSION              710
#define IDS_PRINT_NO_PRINTER    711
#define IDS_PRINT_TITLE                 712
#define IDS_ER_REINIT                   713
#define IDS_ER_TAPI_REINIT      714
#define IDS_ER_TAPI_REINIT2     715
#define IDS_PRINT_FILTER_1              716
#define IDS_PRINT_FILTER_2              717
#define IDS_PRINT_FILTER_3              718
#define IDS_PRINT_FILTER_4              719
#define IDS_PRINT_TOFILE                720
#define IDS_PRINT_FILENAME              721
#define IDS_PRINT_CAPTURE_DOC			722

#define IDS_ER_XFER_NO_FILE     800
#define IDS_ER_OPEN_FAILED      801
#define IDS_ER_XFER_SEND_IN_PROCESS     802
#define IDS_ER_XFER_RECV_IN_PROCESS     803

/* --- Dialing messages --- */

#define IDS_DIAL_OFFERING               900
#define IDS_DIAL_DIALTONE               901
#define IDS_DIAL_DIALING                902
#define IDS_DIAL_RINGBACK               903
#define IDS_DIAL_BUSY                   904
#define IDS_DIAL_CONNECTED              905
#define IDS_DIAL_DISCONNECTED   906
#define IDS_DIAL_NOANSWER               907
#define IDS_DIAL_NODIALTONE     908
#define IDS_DIAL_REDIAL_IN      909

#define IDS_CNCT_OPEN                   910
#define IDS_CNCT_CLOSE                  911
#define IDS_CNCT_DIRECTCOM              912
#define IDS_CNCT_DELAYEDDIAL    913
#define IDS_CNCT_DIRECTCOM_NT   914

#define IDS_TERM_DEF_FONT               920
#define IDS_TERM_DEF_CHARSET    921
#define IDS_TERM_DEF_VGA_SIZE   922
#define IDS_TERM_DEF_NONVGA_SIZE 923
#define IDS_PRINT_DEF_FONT      924
#define IDS_UPGRADE_FONT                925
#define IDS_UPGRADE_FONT_SIZE   926
#define IDS_PRINT_DEF_CHARSET   927

/* Emulator names       */

#define IDS_EMUNAME_BASE		930
#define IDS_EMUNAME_AUTO		930
#define IDS_EMUNAME_ANSI		931
#define IDS_EMUNAME_MINI		932
#define IDS_EMUNAME_VIEW		933
#define IDS_EMUNAME_TTY 		934
#define IDS_EMUNAME_VT100		935
#define IDS_EMUNAME_VT52		936
#define IDS_EMUNAME_VT100J		937
#define IDS_EMUNAME_ANSIW		938
#define IDS_EMUNAME_VT220		939
#define IDS_EMUNAME_VT320		940
#define IDS_EMUNAME_VT100PLUS   941
#define IDS_EMUNAME_VTUTF8		942

/* This is a special flag to make upgrade text localizable */
#define IDS_USE_RTF              999

/* Upgrade text, next 50 id's reserved for upgrade text */

#define IDS_UPGRADE             1000

/* Upgrade button parameters */

#define IDS_UPGRADE_INFO        1051

#ifdef INCL_KEY_MACROS
#define IDS_MACRO_CTRL          1061
#define IDS_MACRO_ALT           1062
#define IDS_MACRO_SHIFT         1063
#define IDS_MACRO_ENTER         1064
#define IDS_MACRO_TAB           1065
#define IDS_MACRO_BS            1066
#define IDS_MACRO_INSERT        1067
#define IDS_MACRO_DEL           1068
#define IDS_MACRO_HOME          1069
#define IDS_MACRO_END           1070
#define IDS_MACRO_UP            1071
#define IDS_MACRO_DOWN          1072
#define IDS_MACRO_PAGEUP        1073
#define IDS_MACRO_PAGEDOWN      1074
#define IDS_MACRO_LEFT          1075
#define IDS_MACRO_RIGHT         1076
#define IDS_MACRO_CENTER        1077
#define IDS_MACRO_F1            1078
#define IDS_MACRO_F2            1079
#define IDS_MACRO_F3            1080
#define IDS_MACRO_F4            1081
#define IDS_MACRO_F5            1082
#define IDS_MACRO_F6            1083
#define IDS_MACRO_F7            1084
#define IDS_MACRO_F8            1085
#define IDS_MACRO_F9            1086
#define IDS_MACRO_F10           1087
#define IDS_MACRO_F11           1088
#define IDS_MACRO_F12           1089
#define IDS_MACRO_F13           1090
#define IDS_MACRO_F14           1091
#define IDS_MACRO_F15           1092
#define IDS_MACRO_F16           1093
#define IDS_MACRO_F17           1094
#define IDS_MACRO_F18           1095
#define IDS_MACRO_F19           1096
#define IDS_MACRO_F20           1097
#define IDS_MACRO_F21           1098
#define IDS_MACRO_F22           1099
#define IDS_MACRO_F23           1100
#define IDS_MACRO_F24           1101
#define IDS_MACRO_BUTTON1       1102
#define IDS_MACRO_BUTTON2       1103
#define IDS_MACRO_BUTTON3       1104
#define IDS_MACRO_BREAK         1105
#define IDS_MACRO_BACKTAB       1106
#define IDS_MACRO_NEWLINE       1107
#define IDS_MACRO_ALTGRAF       1108
#define IDS_MACRO_PAUSE         1109
#define IDS_MACRO_CAPLOCK       1110
#define IDS_MACRO_ESC           1111
#define IDS_MACRO_PRNTSCREEN    1112
#define IDS_MACRO_CLEAR         1113
#define IDS_MACRO_EREOF         1114
#define IDS_MACRO_PA1           1115
#define IDS_MACRO_ADD           1116
#define IDS_MACRO_SUB           1117
#define IDS_MACRO_2             1118
#define IDS_MACRO_6             1119
#define IDS_MACRO_MINUS         1120
#define IDS_MACRO_NUMPAD0       1121
#define IDS_MACRO_NUMPAD1       1122
#define IDS_MACRO_NUMPAD2       1123
#define IDS_MACRO_NUMPAD3       1124
#define IDS_MACRO_NUMPAD4       1125
#define IDS_MACRO_NUMPAD5       1126
#define IDS_MACRO_NUMPAD6       1127
#define IDS_MACRO_NUMPAD7       1128
#define IDS_MACRO_NUMPAD8       1129
#define IDS_MACRO_NUMPAD9       1130
#define IDS_MACRO_NUMPADPERIOD  1131
#define IDS_MACRO_DECIMAL       1132
#define IDS_MACRO_FSLASH        1133
#define IDS_MACRO_MULTIPLY      1134
#define IDS_MACRO_NUMLOCK       1135
#define IDS_MACRO_SCRLLOCK      1136
#define IDS_MACRO_INTERRUPT     1137
#define IDS_MACRO_UNKNOWN       1138
#define IDS_MACRO_CAPSLOCK      1139

#define IDS_DELETE_KEY_MACRO       1140
#define IDS_DUPLICATE_KEY_MACRO    1141
#define IDS_KEY_MACRO_REDEFINITION 1142
#define IDS_MISSING_KEY_MACRO      1143
#endif


/* upper left corner of upgrade button in banner */
#define IDN_UPGRADE_BUTTON_X    95  //102
#define IDN_UPGRADE_BUTTON_Y    228
#define IDN_UPGRADE_BUTTON_W    110 //130
#define IDN_UPGRADE_BUTTON_H    28

/* --- Transfer Tables --- */

#define IDT_CSB_CRC_TABLE       100
#define IDT_CRC_32_TAB          101

/* --- Acclerator Table --- */

#define IDA_WACKER                      100
#define IDA_CONTEXT_MENU        WM_USER+0x300

/* --- Program termination code --- */

#define IDC_MISSING_FILE        1

/* --- Bitmaps used for buttons --- */

#define IDB_BUTTONS_LARGE         3000
#define IDB_BUTTONS_SMALL         3002

/* --- ICONS used for sessions --- */

/* Icons must be numbered in sequence from IDI_PROG because resource
 * compiler can not do arithmatic.
 */

#define IDI_PROG                        100

#define IDI_PROG1                       101
#define IDI_PROG2                       102
#define IDI_PROG3                       103
#define IDI_PROG4                       104
#define IDI_PROG5                       105
#define IDI_PROG6                       106
#define IDI_PROG7                       107
#define IDI_PROG8                       108
#define IDI_PROG9                       109
#define IDI_PROG10                      110
#define IDI_PROG11                      111
#define IDI_PROG12                      112
#define IDI_PROG13                      113
#define IDI_PROG14                      114
#define IDI_PROG15                      115
#define IDI_PROG16                      116
#define IDI_PROG17                      117
#define IDI_PROG18                      118
#define IDI_PROG19                      119
#define IDI_PROG20                      120
#define IDI_PROG21                      121
#define IDI_PROG22                      122
#define IDI_PROG23                      123
#define IDI_PROG24                      124
#define IDI_PROG25                      125
#define IDI_PROG26                      126
#define IDI_PROG27                      127
#define IDI_PROG28                      128
#define IDI_PROG29                      129
#define IDI_PROG30                      130
#define IDI_PROG31                      131
#define IDI_PROG32                      132
#define IDI_PROG33                      133
#define IDI_PROG34                      134
#define IDI_PROG35                      135
#define IDI_PROG36                      136
#define IDI_PROG37                      137
#define IDI_PROG38                      138
#define IDI_PROG39                      139
#define IDI_PROG40                      140
#define IDI_HYPERTERMINAL               141

/* Actually, I didn't know where to put this but it's used with the ICONS */
#define IDI_PROG_ICON_CNT       17

/* --- ID for program banner --- */

#define IDD_BM_BANNER           3001
#define IDR_GLOBE_AVI       4000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\term\term.c ===
/*	File: D:\WACKER\term.c (Created: 23-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 12/20/00 4:36p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\tdll.h>

#if !defined(NDEBUG)
//#include <nih\smrtheap.h>

// 'MemDefaultPoolFlags = MEM_POOL_SERIALIZE' is required by Smartheap
// if app is multithreaded.
//
#if !defined(NO_SMARTHEAP)
unsigned MemDefaultPoolFlags = MEM_POOL_SERIALIZE;
#endif

#endif

#if defined(MSVS6_DEBUG)
#if defined(_DEBUG)
//
// If compiling a debug build with VC6, then turn on the
// new heap debugging tools.  To enable this, add the
// define of MSVS6_DEBUG in your personal.cfg.
//
#include <crtdbg.h>
#endif // _DEBUG
#endif // MSVS6_DEBUG


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WinMain
 *
 * DESCRIPTION:
 *	Entry point for wacker
 *
 */
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow)
	{
	int i;

#if defined(MSVS6_DEBUG)
#if defined(_DEBUG)

	//
	// If compiling a debug build with VC6, then turn on the
	// new heap debugging tools.  To enable this, add the
	// define of MSVS6_DEBUG in your personal.cfg.
	//
	// Get the current state of the flag
	// and store it in a temporary variable
	//
	int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );

	//
	// Turn On (OR) - Keep freed memory blocks in the
	// heaps linked list and mark them as freed
	//
	tmpFlag |= _CRTDBG_DELAY_FREE_MEM_DF;

	//
	// Turn On (OR) - Enable debug heap allocations
	// and use of memory block type identifiers,
	// such as _CLIENT_BLOCK.
	//
	tmpFlag |= _CRTDBG_ALLOC_MEM_DF;

	//
	// Turn On (OR) - Enable debug heap memory leak check
	// at program exit.
	//
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	//
	// Turn Off (AND) - prevent _CrtCheckMemory from
	// being called at every allocation request
	//
	tmpFlag &= ~_CRTDBG_CHECK_ALWAYS_DF;

	//
	// Set the new state for the flag
	//
	_CrtSetDbgFlag( tmpFlag );

#endif // _DEBUG
#endif // MSVS6_DEBUG

	if (hPrevInst)
		return FALSE;

	/* --- Initialize Smartheap memory manager for debug version only. --- */

	#if !defined(NDEBUG)
    #if !defined(NO_SMARTHEAP)
	MemRegisterTask();
	#endif
    #endif

	/* --- Initialize this instance of the program --- */

	if (!InitInstance(hInst, (LPTSTR)lpCmdLine, nCmdShow))
		return FALSE;

	/* --- Process messages until the end --- */

	i = MessageLoop();

	/* --- Report any memory leaks in debug version only. --- */

	#if !defined(NDEBUG)
    #if !defined(NO_SMARTHEAP)
	dbgMemReportLeakage(MemDefaultPool, 1, 1); //lint !e522
    #endif
	#endif

#if defined(MSVS6_DEBUG)
#if defined(_DEBUG)
	//
	// Dump any memory leaks here.
	//
	_CrtDumpMemoryLeaks();

#endif // _DEBUG
#endif // MSVS6_DEBUG


	return i;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\cmprs.h ===
/* File: C:\WACKER\xfer\cmprs.h (Created: 20-Jan-1994)
 * created from HAWIN sources
 * CMPRS.H -- Exported definitions for HyperACCESS compression routines
 *
 *	Copyright 1989,1991,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#if !defined(EOF)
#define	EOF	(-1)
#endif

#define CMPRS_MINSIZE 4000L /* min. size of file to use compression on */

/* return codes from compress_status() */
#define COMPRESS_IDLE	  0
#define COMPRESS_ACTIVE   1
#define COMPRESS_SHUTDOWN 2
#define COMPRESS_ALL_DONE (-1)

#define DCMP_UNFINISHED (-2)
#define DCMP_FLUSH		(-4)
#define DCMP_RESET		(-5)

#define decompress_status compress_status

extern int   	compress_enable(void);
extern void 	compress_disable(void);
extern unsigned int	compress_status(void);
extern int  	compress_start(int (**getfunc)(void *),
								void *p,
								long *loadcnt,
								int fPauses);
extern void 	compress_stop(void);
extern int  	decompress_start(int (**put_func)(void *, int),
									  void *pP,
									  int fPauses);
extern void 	decompress_stop(void);
extern int 	    decompress_error(void);
extern int      decompress_continue(void);

/* from cmprsrle.c */
#if defined(DOS_HOST)
extern void 	 CmprsRLECompressBufrInit(BYTE *fpuchDataBufr,
					 int sDataCnt);
extern void 	 CmprsRLEDecompressInit(BYTE *fpuchDataBufr,
					 unsigned int usBufrSize,
					 int (*PutCodes)(int mch),
					 unsigned int *pusExpandedCnt);

#else
extern void 	 CmprsRLECompressBufrInit(BYTE FAR *fpuchDataBufr,
					 int sDataCnt);
extern void 	 CmprsRLEDecompressInit(BYTE FAR *fpuchDataBufr,
					 unsigned int usBufrSize,
					 int (*PutCodes)(int mch),
					 unsigned int *pusExpandedCnt);

#endif

extern void CmprsRLECompressBufrFini(void);
extern int  CmprsRLECompress(void);
extern int  CmprsRLEDecompress(int mch);

/***************************** end of cmprs.h **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\term\xfer_dlg.h ===
/*	File: D:\WACKER\term\xfer_dlg.h (Created: 11-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:33p $
 */

#define	TEXT_CLASS				"static"

#define	BV_TEXT_CLASS			"BeveledText"
#define	BVS_ALTCLR				0x100

#define VU_METER_CLASS			"VuMeterDisplay"

#define	XFR_SHRINK					101
#define	XFR_SKIP					102
#define	XFR_CANCEL					103
#define	XFR_EXPAND					104
#define	XFR_DIVIDER					105
#define	XFR_CBPS					106

#define	XFR_THEIR_NAME_LABEL		110
#define	XFR_THEIR_NAME_BOX			111

#define	XFR_VIR_LABEL				115
#define	XFR_VIR_BOX					116

#define	XFR_CMP_LABEL				120
#define	XFR_CMP_BOX					121

#define	XFR_OUR_NAME_LABEL			125
#define	XFR_OUR_NAME_BOX			126

#define	XFR_FILES_LABEL				130
#define	XFR_FILES_BOX				131

#define	XFR_EVENT_LABEL				135
#define	XFR_EVENT_BOX				136

#define	XFR_PACKET_LABEL			140
#define	XFR_PACKET_BOX				141

#define	XFR_RETRIES_LABEL			145
#define	XFR_RETRIES_BOX				146

#define	XFR_STATUS_LABEL			150
#define	XFR_STATUS_BOX				151

#define	XFR_TOTAL_CNT_LABEL			155
#define	XFR_TOTAL_CNT_BOX			156

#define	XFR_FILE_LABEL				160
#define	XFR_FILE_METER				161
#define	XFR_FILE_BOX				162

#define	XFR_TOTAL_LABEL				165
#define	XFR_TOTAL_METER				166
#define	XFR_TOTAL_BOX				167

#define	XFR_ELAPSED_LABEL			170
#define	XFR_ELAPSED_BOX				171

#define	XFR_REMAINING_LABEL			175
#define	XFR_REMAINING_BOX			176

#define	XFR_THRUPUT_LABEL			180
#define	XFR_THRUPUT_BOX				181

#define	XFR_PACKET_RETRY_LABEL		185
#define	XFR_PACKET_RETRY_BOX		186

#define	XFR_ERROR_CHECKING_LABEL	190
#define	XFR_ERROR_CHECKING_BOX		191

#define	XFR_FILE_SIZE_LABEL			195
#define	XFR_FILE_SIZE_BOX			196

#define	XFR_LAST_ERROR_LABEL		200
#define	XFR_LAST_ERROR_BOX			201

#define	XFR_PROTOCOL_LABEL			205
#define	XFR_PROTOCOL_BOX			206

#define	XFR_MESSAGE_LABEL			210
#define	XFR_MESSAGE_BOX				211
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\cmprs.hh ===
/* File: C:\WACKER\xfer\cmprs.hh (Created: 20-Jan-1994)
 * created from HAWIN sources
 * cmprs.hh -- Internal definitions for compression routines
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
// Set to 1 or 0 to enable/disable descriptive output
// #define SHOW 0

// Set to 1 or 0 to enable/disable use of assembly language module
#define USE_ASM 0


#define MAXNODES 4096	/* number of nodes in lookup tables */
#define MAXCODEBITS 12	/* largest code size in bits */
#define CLEARCODE 256	/* special code from compressor to decompressor to
							signal it to clear the table and start anew */
#define STOPCODE 257	/* special code from compressor to decompressor to
							signal it that following data will
							not be compressed */
#define FIRSTFREE 258	/* first code available to code pattern */


/* These variables are shared by the compression and decompression routines */

extern void *compress_tblspace;

struct s_cmprs_node
	{
	struct s_cmprs_node *first;
	struct s_cmprs_node *next;
	BYTE cchar;
	};


extern unsigned long  ulHoldReg;
extern int            sBitsLeft;
extern int            sCodeBits;
extern unsigned int   usMaxCode;
extern unsigned int   usFreeCode;
extern unsigned int   usxCmprsStatus;
extern int            fxLastBuildGood;
extern int            fFlushable;		// True if compression stream can

/* function prototypes: */

/* from cmprs1.c */
extern void   cmprs_inittbl(void);
extern int    cmprs_shutdown(void *);

/* from cmpgetc.asm */
extern int    cmprs_getc(void *);

/* from cmprs2.c */
extern int    dcmp_abort(void);
extern int    dcmp_start(void *pX, int c);
extern int    dcmp_putc(void *pX, int c);

/* from dcmplook.asm */
extern int    dcmp_lookup(unsigned int code);
extern void   dcmp_inittbl(void);


/* end of cmprs.hh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\cmprs0.c ===
/* File: C:\WACKER\xfer\cmprs0.c
 * created from HAWIN sources
 * cmprs0.c -- Functions common to compression and decompression
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
#include <windows.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>

#if !defined(BYTE)
#define BYTE unsigned char
#endif

#include "cmprs.h"
#include "cmprs.hh"

// debug_init(__FILE__)


/* Routines to handle overall compression enable and disable. */

void *compress_tblspace;

/* These variables are shared by the compression and decompression routines */

unsigned long  ulHoldReg;
int            sBitsLeft;
int            sCodeBits;
unsigned int   usMaxCode;
unsigned int   usFreeCode;
unsigned int   usxCmprsStatus = COMPRESS_IDLE;
int            fxLastBuildGood = FALSE;
int            fFlushable = FALSE;		 // True if compression stream can
										 //  flushed and resumed


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * compress_enable
 *
 * DESCRIPTION:
 *	Called to determine whether compression is feasible, and if it is to
 *	allocate the necessary memory to do so.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	If compression was already enabled, returns TRUE.
 *	If compression was not previously enabled, or if it was disabled,
 *	returns TRUE if memory is available for compression, FALSE otherwise.
 */
int compress_enable(void)
	{
#if defined(DOS_HOST)
	static struct s_cmprs_node tbl[MAXNODES+2];

	compress_tblspace = (void *)&tbl;
	return TRUE;

#else

	if (compress_tblspace != (void *)0)
		return(TRUE);
	else
		{
		compress_tblspace = malloc(sizeof(struct s_cmprs_node)*(MAXNODES+2));

		return(compress_tblspace != (void *)0);
		}
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * compress_disable
 *
 * DESCRIPTION
 *	Disables file compression and released memory used for compression tables.
 *	Has no effect if compression was not enabled.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void compress_disable(void)
	{
#if !defined(DOS_HOST)
	if (compress_tblspace != (void *)0)
		free(compress_tblspace);
	compress_tblspace = (void *)0;
#endif

	usxCmprsStatus = COMPRESS_IDLE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * compress_status
 *
 * DESCRIPTION:
 *	Returns current status of compression -- whether idle, active, or shutdown.
 *	Applies to both compression and decompression.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	COMPRESS_IDLE	  if compression has not been activated or has been stopped
 *						 normally
 *	COMPRESS_ACTIVE   if compression is currently active.
 *	COMPRESS_SHUTDOWN if compression has been activated but shut itself down
 *						 upon determining that the compression is not effective
 *						 on the current file.
 */
unsigned int compress_status(void)
	{
	return usxCmprsStatus;
	}

/* end of cmprs0.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\term\version.h ===
/*      File: D:\WACKER\term\version.h (Created: 5-May-1994)
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *      $Revision: 13 $
 *      $Date: 12/27/01 2:13p $
 */

#include <winver.h>
#include <ntverp.h>
#include "..\tdll\features.h"

/* ----- Version Information defines ----- */

#if defined(NT_EDITION)
/* Use this code when building the Microsoft Version */
#define IDV_FILEVER                     VER_PRODUCTVERSION
#define IDV_PRODUCTVER                  VER_PRODUCTVERSION
#define IDV_FILEVERSION_STR             VER_PRODUCTVERSION_STRING
#define IDV_PRODUCTVERSION_STR          VER_PRODUCTVERSION_STRING
#else
/* Use this code when building the Hilgraeve Private Edition */
#define IDV_FILEVER                     6,0,4,0
#define IDV_PRODUCTVER                  6,0,4,0
#define IDV_FILEVERSION_STR             "6.4\0"
#define IDV_PRODUCTVERSION_STR          "6.4\0"
#endif

/* Use this code when building all versions */

#define IDV_COMPANYNAME_STR             "Hilgraeve, Inc.\0"
#define IDV_LEGALCOPYRIGHT_STR          "Copyright \251 Hilgraeve, Inc. 2002\0"
#define IDV_LEGALTRADEMARKS_STR         "HyperTerminal \256 is a registered trademark of Hilgraeve, Inc. Microsoft\256 is a registered trademark of Microsoft Corporation. Windows\256 is a registered trademark of Microsoft Corporation.\0"
#define IDV_PRODUCTNAME_STR             VER_PRODUCTNAME_STR
#define IDV_COMMENTS_STR                "HyperTerminal \256 was developed by Hilgraeve, Inc.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\cmprs2.c ===
/* File: C:\WACKER\xfer\cmprs2.c (Created: 20-Jan-1994)
 * created from HAWIN source file
 * cmprs2.c -- Routines to implement data decompression
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
#include <windows.h>

#include <tdll\stdtyp.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"
#include "cmprs.hh"

#if SHOW
//	#include <stdio.h>
#endif

/* * * * * * * * * * * * * *
 * Decompression routines  *
 * * * * * * * * * * * * * */

typedef struct s_dcmp_node DCMP_NODE;
struct s_dcmp_node
	{
	DCMP_NODE *pstLinkBack;
	DCMP_NODE *pstLinkFwd;
	BYTE ucChar;
	};

#define NODE_CAST DCMP_NODE *

DCMP_NODE *pstDcmpTbl;			// pointer to lookup table
DCMP_NODE *pstCode = NULL;		// used to scan table for output

int (**ppfDcmpPutfunc)(void *, int); /* ptr. to ptr. to function used
											   by calling func */
int (*pfDcmpPutChar)(void *, int);	/* ptr. to function used
											   internally to get data */

void *pPsave;

DCMP_NODE *pstTblLimit = NULL;	/* pointer to table beyond 1st 256 nodes */
DCMP_NODE *pstExtraNode = NULL;	/* pointer to additional node used in spec. case */
int	 fDcmpError;					/* set TRUE if illegal code is received */
int	 fStartFresh = FALSE;
unsigned int	 usCodeMask;					/* mask to isolate varible sized codes */
unsigned int	 usOldCode; 					/* last code received */
int mcFirstChar;					/* final character of pattern readout, actually,
										   the FIRST character of pattern (characters
										   are read out in reverse order */

// #pragma optimize("lgea",on)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: decompress_start
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int decompress_start(int (**put_func)(void *, int),
					void *pP,
					int fPauses)
	{
	unsigned int usCount;
	DCMP_NODE *pstTmp;

	if (!compress_enable())
		return(FALSE);

	pPsave = pP;

	fFlushable = fPauses;

	// Due to the use of based pointers, we must use compress_tblspace + 1
	//	in the following code. Otherwise, node 0 (which could have an offset
	//	of 0 looks like a NULL pointer.
	// pstDcmpTbl = (DCMP_NODE *)(OFFSETOF(compress_tblspace) + 1);
	pstDcmpTbl = (DCMP_NODE *)(compress_tblspace);

	pstCode = NULL;
	pstExtraNode = (NODE_CAST)&pstDcmpTbl[MAXNODES];   /* last node */
	pstExtraNode->pstLinkFwd = NULL;
	pstTblLimit = (NODE_CAST)&pstDcmpTbl[256];
	for (usCount = 0, pstTmp = pstDcmpTbl; usCount < 256; ++usCount)
		{
		pstTmp->ucChar = (BYTE)usCount;
		++pstTmp;
		}

	ulHoldReg = 0;
	sBitsLeft = 0;
	sCodeBits = 9;
	usMaxCode = 512;
	usCodeMask = (1 << sCodeBits) - 1;
	usFreeCode = FIRSTFREE;
	fDcmpError = FALSE;
	fStartFresh = FALSE;
	ppfDcmpPutfunc = put_func;
	pfDcmpPutChar = *ppfDcmpPutfunc;
	*ppfDcmpPutfunc = dcmp_putc;
	usxCmprsStatus = COMPRESS_ACTIVE;
	#if SHOW
		printf("D                         decompress_start, sCodeBits=%d\n",
				sCodeBits);
	#endif
	return(TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: decompress_error
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int decompress_error(void)
	{
	return(fDcmpError);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: dcmp_start
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int dcmp_start(void *pX, int mcStartChar)
	{
	unsigned int usCode;

	ulHoldReg |= ((unsigned long)mcStartChar << sBitsLeft);
	sBitsLeft += 8;
	#if SHOW
		printf("D %02X         %08lX,%2d  dcmp_start\n", mcStartChar,
				ulHoldReg, sBitsLeft);
	#endif
	if (sBitsLeft >= sCodeBits)
		{
		usCode = (unsigned int)ulHoldReg & usCodeMask;
		ulHoldReg >>= sCodeBits;
		sBitsLeft -= sCodeBits;
		#if SHOW
			printf("D >> %03X     %08lX,%2d  sCodeBits=%d dcmp_start\n",
					usCode, ulHoldReg, sBitsLeft, sCodeBits);
		#endif
		/* Table has just been cleared, code must be in range of 0 - 255 */
		if (!IN_RANGE((INT)usCode, 0, 255))
			{
			#if SHOW
				printf("D >> %03X                  ERROR: out of range\n",
						usCode);
			#endif
			return(dcmp_abort());
			}
		else
			{
			#if SHOW
				printf("D        %02X               dcmp_start\n", usCode);
			#endif
			mcStartChar = (*pfDcmpPutChar)(pPsave, mcFirstChar =
					(INT)(usOldCode = usCode));
			*ppfDcmpPutfunc = dcmp_putc;
			}
		}
	return(mcStartChar);
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: dcmp_putc
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int dcmp_putc(void *pX, int mcInput)
	{
	unsigned int usCode;
	unsigned int usInCode;
	int  mcPutResult;
	DCMP_NODE *pstTmp;

	ulHoldReg |= ((unsigned long)mcInput << sBitsLeft);
	sBitsLeft += 8;
	#if SHOW
		printf("D %02X         %08lX,%2d\n", mcInput, ulHoldReg, sBitsLeft);
	#endif
	if (sBitsLeft >= sCodeBits)
		{
		usCode = (unsigned int)ulHoldReg & usCodeMask;
		ulHoldReg >>= sCodeBits;
		sBitsLeft -= sCodeBits;
		#if SHOW
			printf("D >> %03X     %08lX,%2d  sCodeBits=%d\n",
					usCode, ulHoldReg, sBitsLeft, sCodeBits);
		#endif
		if (usCode == STOPCODE)
			{
			if (!fFlushable)
				decompress_stop();
			else
				{
				// Pause in the data, leave lookup table intact but start
				//	receiving a fresh stream.
				sBitsLeft = 0;
				ulHoldReg = 0L;
				fStartFresh = TRUE;
				#if SHOW
					printf("D            %08lX,%2d  setting fFreshStart\n",
							ulHoldReg, sBitsLeft);
				#endif
				}
			}
		else if (usCode == CLEARCODE)
			{
			sCodeBits = 9;
			usMaxCode = 512;
			usCodeMask = (1 << sCodeBits) - 1;
			usFreeCode = FIRSTFREE;
			*ppfDcmpPutfunc = dcmp_start;
			#if SHOW
				printf("D                         CLEARCODE, sCodeBits=%d\n",
						sCodeBits);
			#endif
			}
		else if (usCode > (unsigned int)usFreeCode)
			{
			#if SHOW
				printf("D                         ERROR: usCode > usFreeCode of %03X\n",
						usFreeCode);
			#endif
			return(dcmp_abort());
			}
		else
			{
			pstCode = (NODE_CAST)&pstDcmpTbl[usInCode = usCode];
			if (usCode == usFreeCode)  /* spec. case k<w>k<w>k */
				{
				pstCode = (NODE_CAST)&pstDcmpTbl[usCode = usOldCode];
				pstExtraNode->ucChar = (BYTE)mcFirstChar;
				pstCode->pstLinkFwd = pstExtraNode;
				#if SHOW
					printf("D                         Special case: k<w>k<w>k\n");
				#endif
				}
			else
				pstCode->pstLinkFwd = NULL;
			while(pstCode > pstTblLimit)
				{
				pstCode->pstLinkBack->pstLinkFwd = pstCode;
				pstCode = pstCode->pstLinkBack;
				}
			mcFirstChar = pstCode->ucChar;

			if (!fStartFresh)
				{
				#if SHOW
					printf("D                         D Added %03X = %03X + %02X\n",
							usFreeCode, usOldCode, mcFirstChar);
				#endif
				if (usFreeCode < MAXNODES)
					{
					pstTmp = (NODE_CAST)&pstDcmpTbl[usFreeCode++];
					pstTmp->ucChar = (BYTE)mcFirstChar;
					pstTmp->pstLinkBack = (NODE_CAST)&pstDcmpTbl[usOldCode];
					}
				}
			fStartFresh = FALSE;

			usOldCode = usInCode;
			if (usFreeCode >= usMaxCode && sCodeBits < MAXCODEBITS)
				{
				++sCodeBits;
				usCodeMask = (1 << sCodeBits) - 1;
				usMaxCode *= 2;
				#if SHOW
					printf("D                         D New sCodeBits = %d\n",
							sCodeBits);
				#endif
				}

			while (pstCode != NULL)
				{
				#if SHOW
					printf("D        %02X               ", pstCode->ucChar);
				#endif
				if ((mcPutResult = (*pfDcmpPutChar)(pPsave, pstCode->ucChar)) < 0)
					{
					if (mcPutResult == DCMP_UNFINISHED)
						{
						#if SHOW
							printf("Interrupted");
						#endif
						pstCode = pstCode->pstLinkFwd;	 //  to pick up later
						mcInput = DCMP_UNFINISHED;
						break;
						}
					else
						{
						#if SHOW
							printf("ERROR: putc returned -1");
						#endif
						pstCode = NULL;
						mcInput = ERROR;
						break;
						}
					}
				#if SHOW
					printf("\n");
				#endif
				pstCode = pstCode->pstLinkFwd;
				}
			}
		}
	return(mcInput);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: decompress_continue
 *
 * DESCRIPTION:
 *	Needed for compression in remote control. Picks up expansion of an
 *	output string after it has been interrupted.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int decompress_continue(void)
	{
	int mcPutResult;
	int mcRetCode;

	// Deliver an initial unfinished code so routines downstream can pick
	//	up midstream if necessary
	if ((*pfDcmpPutChar)(pPsave, DCMP_UNFINISHED) == DCMP_UNFINISHED)
		return DCMP_UNFINISHED;

	// Now continue delivering any remaining expansion codes unless
	//	interrupted again
	while (pstCode != NULL)
		{
		if ((mcPutResult = (*pfDcmpPutChar)(pPsave, pstCode->ucChar)) < 0)
			{
			if (mcPutResult == DCMP_UNFINISHED)
				{
				pstCode = pstCode->pstLinkFwd;	 //  to pick up later
				mcRetCode = DCMP_UNFINISHED;
				break;
				}
			else
				{
				pstCode = NULL;
				mcRetCode = ERROR;
				break;
				}
			}
		pstCode = pstCode->pstLinkFwd;
		}

	return mcRetCode;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: dcmp_abort
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int dcmp_abort(void)
	{
	/* print error message or whatever */
	fDcmpError = TRUE;
	decompress_stop();
	return(ERROR);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: decompress_stop
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void decompress_stop(void)
	{
	#if SHOW
		printf("D                         Decompress_stop\n");
	#endif
	if (ppfDcmpPutfunc != NULL)
		{
		*ppfDcmpPutfunc = pfDcmpPutChar;
		ppfDcmpPutfunc = NULL;
		}
	usxCmprsStatus = COMPRESS_IDLE;
	}


/* end of cmprs2.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\cmprs1.c ===
/* File: C:\WACKER\xfer\cmprs1.c (Created: 20-Jan-1994)
 * created from HAWIN source file
 * cmprs1.c -- Routines to implement data compression
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
#include <windows.h>

#include <tdll\stdtyp.h>

#if !defined(BYTE)
#define	BYTE unsigned char
#endif

#include "cmprs.h"
#include "cmprs.hh"

#if SHOW
// #include <stdio.h>
#endif

unsigned int usPrefixCode = 0;	   /* code representing pattern matched so far */
int mcK;					  /* character to be appended to prefix for
									next match */

int (**ppfCmprsGetfunc)(void *) = NULL;
										/* pointer to the
										pointer to a function used by calling
										routine */

int (*pfCmprsGetChar)(void *);
										/* pointer to the function used
										internally to get data to compress */
void *pPsave;

long *plCmprsLoadcnt;
long lCmprsBegcnt;
long lCmprsLimitcnt = 1L;	   // Initializing to one disables compression
							   //  shut-down unless changed
struct s_cmprs_node *pstCmprsTbl;  /* pointer to compression lookup table */

#define NODE_CAST struct s_cmprs_node *

int lookup_code(void);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * compress_start
 *
 * DESCRIPTION
 *	This function is called to begin data compression. The calling routine
 *	should set up a pointer to a function through which it will make calls
 *	to get characters of data. The pointer should be initialized to point
 *	to the function that the compression routines should use to get raw
 *	data for compression. The pointer is then modified by the compression
 *	routines to point to the compressor. After compression is complete or
 *	abandoned, the pointer is restored to its original value.
 *	Example of calling sequence:
 *		int (*xgetc)();
 *		int fgetc();
 *
 *		xgetc = fgetc;
 *		if (compress_start(&xgetc))
 *			;
 *	If fPauses is TRUE, the compressor will flush existing data through when
 *	the input function returns an EOF but will not shutdown. Whenever the
 *	next non-EOF is retrieved, compression will resume where it left off will
 *	the pattern table still intact. The fPauses flag must be used by both
 *	the compression and decompression routines to work. If fPauses is used,
 *	the cmprs_stop() function must be used to shut compression down before
 *	compress_disable() is called.
 *
 * RETURN VALUE
 *	Returns TRUE if memory is available for table storage and at least one
 *	character is available from input; FALSE otherwise.
 */
int compress_start(int (**getfunc)(void *),
					void *pP,
					long *loadcnt,
					int fPauses)
	{
#if FALSE
#if !defined(LZTEST)
	long x;
#endif
#endif

	if (!compress_enable())
		return(FALSE);

	fFlushable = fPauses;

	fxLastBuildGood = FALSE;	 /* By setting this FALSE, we will cause
								 * compression to shut down if the very first
								 * table build indicates that compression is
								 * not effective. Thereafter, it will take two
								 * consecutive bad builds to shut it down.
								 */

	if ((plCmprsLoadcnt = loadcnt) != NULL && !fFlushable)
		{
		lCmprsBegcnt = *plCmprsLoadcnt;
		/*
		 *	Compressability of files can be roughly measured by how many input
		 *	characters must be read before the pattern table fills up. The
		 *	lower the number, the less efficient compression is. This
		 *	calculation determines a cutoff point for any combination of
		 *	machine speed and transfer rate based on experimental trials.
		 *
		 *	Note that this mechanism should not be used when the fPauses
		 *	parameter is TRUE because the decompressor would misinterpret
		 *	the data following the STOPCODE after compression shut down
		 */
#if FALSE
#if !defined(LZTEST)
		if ((x = (cnfg.bit_rate / cpu_speed())) == 0L)
			lCmprsLimitcnt = 4300L;
		else
			lCmprsLimitcnt = max(x * 774L - 500L, 4300L);
#else
		lCmprsLimitcnt = 4300L;
#endif
#endif
		lCmprsLimitcnt = 4300L;
		}
	pPsave = pP;
	ppfCmprsGetfunc = getfunc;
	pfCmprsGetChar = *ppfCmprsGetfunc;
	if ((mcK = (*pfCmprsGetChar)(pPsave)) != EOF)
		{

		*ppfCmprsGetfunc = cmprs_getc;
		cmprs_inittbl();
		ulHoldReg = 0L;
		ulHoldReg |= CLEARCODE;
		sBitsLeft = sCodeBits;
		usxCmprsStatus = COMPRESS_ACTIVE;

		#if SHOW
			printf("C %02X                      (starting, emit CLEARCODE)\n",
					mcK);
			printf("C -> %03X     %08lX,%2d\n", CLEARCODE,
					ulHoldReg, sBitsLeft);
		#endif

		return(TRUE);
		}
	else
		{
		ppfCmprsGetfunc = NULL;
		return(FALSE);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * compress_stop
 *
 * DESCRIPTION
 *	If compression has been started, it is turned off.
 */
void compress_stop(void)
	{
	#if SHOW
		printf("C Compress_stop\n");
	#endif

	if (ppfCmprsGetfunc != NULL)
		{
		*ppfCmprsGetfunc = pfCmprsGetChar;
		ppfCmprsGetfunc = NULL;
		}
	usxCmprsStatus = COMPRESS_IDLE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * cmprs_inittbl
 *
 * DESCRIPTION
 *	Used to initialize the lookup table used for compressing data.
 */
void cmprs_inittbl(void)
	{
	register INT iCount;

	sCodeBits = 9;
	usMaxCode = 512;
	usFreeCode = FIRSTFREE;

	// pstCmprsTbl = (struct s_cmprs_node *)(OFFSETOF(compress_tblspace));
	pstCmprsTbl = (struct s_cmprs_node *)(compress_tblspace);

	for (iCount = 0; iCount < FIRSTFREE; ++iCount)
		pstCmprsTbl[iCount].first = pstCmprsTbl[iCount].next = NULL;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * cmprs_shutdown
 *
 * DESCRIPTION
 *	This is the function that is installed by cmprs_getc when compression
 *	is ending. It is installed after cmprs_getc encounters the end of the input
 *	data. This function returns any remaining bytes, then returns EOF and
 *	restores the original getc function
 *
 * RETURN VALUE
 *	Returns the next code to be sent or EOF.
 */
int cmprs_shutdown(void *pX)
	{
	int mcRetCode;

	// If we haven't sent all the data yet, do so
	if (sBitsLeft > 0)
		{
		mcRetCode = (int)(ulHoldReg & 0x00FF);
		ulHoldReg >>= 8;
		sBitsLeft -= 8;

		#if SHOW
			printf("C        %02X  %08lX,%2d  Draining ulHoldReg\n",
					mcRetCode, ulHoldReg, sBitsLeft);
		#endif
		}
	else
		{
		// No more data waiting.
		mcRetCode = EOF;
		sBitsLeft = 0;

		if (!fFlushable)
			{
			// Not flushable, get compression out of the chain
			*ppfCmprsGetfunc = pfCmprsGetChar;
			ppfCmprsGetfunc = NULL;
			#if SHOW
				printf("                          !fFlushable, outta here\n");
			#endif
			}
		else
			{
			// Flushable, see whether we should resume compression
			if ((mcK = (*pfCmprsGetChar)(pPsave)) != EOF)
				{
				#if SHOW
					printf("C %02X                      fFlushable TRUE, restarting\n",
							mcK);
				#endif
				*ppfCmprsGetfunc = cmprs_getc;
				mcRetCode = cmprs_getc(pPsave);
				}
			}
		}
	return(mcRetCode);
	}


#if !USE_ASM
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * cmprs_getc
 *
 * DESCRIPTION
 *	This is the function installed by compress_start to be used by any routine
 *	that needs compressed data. It delivers bytes to the calling routine,
 *	but may read several characters from the input to do so.
 *
 * RETURN VALUE
 *	Returns next 8-bits of compressed data or EOF if no more is available.
 */
int cmprs_getc(void *pX)
	{
	int mcRetCode;
	int fBuildGood;

	if (sBitsLeft < 8)
		{
		usPrefixCode = (unsigned int)mcK;
		do
			{
			if ((mcK = (*pfCmprsGetChar)(pPsave)) == EOF)
				{
				/* at end of file, send last code followed by STOPCODE */
				/*	to stop decompression. Note that ulHoldReg may overflow */
				/*	if the maximum code size is greater than 12 bits */
				ulHoldReg |= ((unsigned long)usPrefixCode << sBitsLeft);
				sBitsLeft += sCodeBits;

				#if SHOW
					printf("C -1                      Shutdown,"
							" emit prefix and STOPCODE\n");
					printf("C -> %03X     %08lX,%2d  Codebits=%d\n",
							usPrefixCode, ulHoldReg, sBitsLeft, sCodeBits);
				#endif

				// If we're poised to switch to the next larger code size,
				// the decompressor will do so after the prior code, so
				// we should switch now too.
				if (usFreeCode >= usMaxCode && sCodeBits < MAXCODEBITS)
					{
					++sCodeBits;
					usMaxCode *= 2;
					#if SHOW
						printf("C                         "
								"New sCodeBits = %d (anticipating)\n",
								sCodeBits);
					#endif
					}

				usPrefixCode = STOPCODE;
				*ppfCmprsGetfunc = cmprs_shutdown;
				usxCmprsStatus = COMPRESS_IDLE;

				break;	/* let last code go out */
				}
			} while (lookup_code());
		ulHoldReg |= ((unsigned long)usPrefixCode << sBitsLeft);
		sBitsLeft += sCodeBits;
		#if SHOW
			printf("C -> %03X     %08lX,%2d  Codebits=%d\n", usPrefixCode,
					ulHoldReg, sBitsLeft, sCodeBits);
		#endif
		}
	mcRetCode = (int)(ulHoldReg & 0x00FF);
	ulHoldReg >>= 8;
	sBitsLeft -= 8;

	#if SHOW
		printf("C        %02X  %08lX,%2d\n", mcRetCode, ulHoldReg, sBitsLeft);
	#endif

	if (usFreeCode > usMaxCode)
		{
		/* We've used up all available codes at the current codesize */

		if (sCodeBits >= MAXCODEBITS)
			{
			/* We've filled the pattern table, either shut down or clear the
			 *	table and build a new one.
			 */

			fBuildGood = TRUE;
			if (plCmprsLoadcnt &&
					(*plCmprsLoadcnt - lCmprsBegcnt) < lCmprsLimitcnt)
				fBuildGood = FALSE;

			#if SHOW
			printf("C                         Table full, fBuildGood = %d\n",
					fBuildGood);
			#endif
			/* if two ineffective builds in a row (or if the very first build
			 *	is ineffective, shut compression down.
			 */

			if (!fBuildGood && !fxLastBuildGood)
				{
				/* compression is not effective, shut it down */

				ulHoldReg |= ((unsigned long)STOPCODE << sBitsLeft);
				sBitsLeft += sCodeBits;
				#if SHOW
					printf("C -> %03X     %08lX,%2d  Ineffective, emitting STOPCODE\n",
							STOPCODE, ulHoldReg, sBitsLeft);
				#endif
				*ppfCmprsGetfunc = cmprs_shutdown;
				usxCmprsStatus = COMPRESS_SHUTDOWN;
				}
			else
				{
				/* clear the table and build a new one in case the nature of
				 *	the data changes.
				 */
				ulHoldReg |= ((unsigned long)CLEARCODE << sBitsLeft);
				sBitsLeft += sCodeBits;
				#if SHOW
					printf("C -> %03X     %08lX,%2d  New table, emiting CLEARCODE\n",
							CLEARCODE, ulHoldReg, sBitsLeft);
				#endif
				cmprs_inittbl();
				lCmprsBegcnt = *plCmprsLoadcnt;
				}
			fxLastBuildGood = fBuildGood;
			}
		else
			{
			/* code size hasn't maxed out yet, bump to next larger code size */

			++sCodeBits;
			usMaxCode *= 2;
			#if SHOW
				printf("C                         New sCodeBits = %d, usMaxCode = %03X\n",
						sCodeBits, usMaxCode);
			#endif
			}
		}
	return(mcRetCode);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * lookup_code
 *
 * DESCRIPTION
 *	This is a 'C' language version of the table lookup routine. It is used
 *	when an internal lookup table is being used. An assembly language version
 *	is used if an external lookup table is being used.
 *	Given a current usPrefixCode and input character, this function
 *	attempts to find a new usPrefixCode for the combined pattern in the table.
 *	If so, it updates the usPrefixCode and returns TRUE. If the pattern is
 *	not found, it adds the combination to the table and returns FALSE.
 *
 * RETURN VALUE
 *	TRUE if usPrefixCode:mcK is found in the table. FALSE if not.
 */
int lookup_code(void)
	{
	int firstflag;
	struct s_cmprs_node *tptr = (NODE_CAST)&pstCmprsTbl[usPrefixCode];
	struct s_cmprs_node *newptr;


	firstflag = TRUE;
	if (tptr->first != NULL)
		{
		firstflag = FALSE;
		tptr = tptr->first;
		for (;;)
			{
			if (tptr->cchar == (BYTE)mcK)
				{
				usPrefixCode = (unsigned int)(tptr - (NODE_CAST)(&pstCmprsTbl[0]));

				#if SHOW
					printf("C %02X                      ->(%03X)\n",
							mcK, usPrefixCode);
				#endif

				return(TRUE);
				}
			if (tptr->next == NULL)
				break;
			else
				tptr = tptr->next;
			}
		}
	if (usFreeCode < MAXNODES)
		{
		#if SHOW
			printf("C %02X                      Added %03X = %03X + %02X\n",
					mcK, usFreeCode, usPrefixCode, mcK);
		#endif
		newptr = (NODE_CAST)&pstCmprsTbl[usFreeCode++];
		if (firstflag)
			tptr->first = newptr;
		else
			tptr->next = newptr;
		newptr->first = newptr->next = NULL;
		newptr->cchar = (BYTE)mcK;
		}
	else
		++usFreeCode;	 /* triggers clearing and rebuilding of table */
	return(FALSE);
	}

#endif

/* end of cmprs1.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\foo.h ===
/*	File: foo.h (Created: 01-Nov-1991)
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 4/05/02 4:34p $
 */

#define	FB_SIZE	2048

struct stFooBuffer
	{
	unsigned int usSend;
	unsigned char acSend[FB_SIZE];
	};

typedef	struct stFooBuffer	stFB;

extern int fooComSendChar(HCOM h, stFB *pB, BYTE c);

extern int fooComSendClear(HCOM h, stFB *pB);

extern int fooComSendPush(HCOM h, stFB *pB);

extern int fooComSendCharNow(HCOM h, stFB *pB, BYTE c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_rcv0.c ===
/* File: C:\WACKER\xfer\hpr_rcv0.c (created: 24-Jun-1994)
 * created from HAWIN source file:
 * hpr_rcv0.c -- Routines to implement HyperProtocol receiver.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#include <windows.h>
#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
// #include <tdll\com.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"

/* 
 *  not all event codes in this table are needed here, but having a complete
 *	table simplifies the lookup code substantially.
 */
int hr_result_codes[] = /* maps HyperProtocol event codes to result codes */
	{
	TSC_OK, 			/* HRE_NONE 	   */
	TSC_ERROR_LIMIT,	/* HRE_DATAERR	   */
	TSC_OUT_OF_SEQ, 	/* HRE_LOSTDATA    */
	TSC_NO_RESPONSE,	/* HRE_NORESP	   */
	TSC_ERROR_LIMIT,	/* HRE_RETRYERR    */
	TSC_BAD_FORMAT, 	/* HRE_ILLEGAL	   */
	TSC_OK, 			/* HRE_ERRFIXED    */
	TSC_RMT_CANNED, 	/* HRE_RMTABORT    */
	TSC_USER_CANNED,	/* HRE_USRCANCEL   */
	TSC_NO_RESPONSE,	/* HRE_TIMEOUT	   */
	TSC_ERROR_LIMIT,	/* HRE_DCMPERR	   */
	TSC_LOST_CARRIER,	/* HRE_LOST_CARR   */
	TSC_TOO_MANY,		/* HRE_TOO_MANY    */
	TSC_DISK_FULL,		/* HRE_DISK_FULL   */
	TSC_CANT_OPEN,		/* HRE_CANT_OPEN   */
	TSC_DISK_ERROR, 	/* HRE_DISK_ERR    */
	TSC_OLDER_FILE, 	/* HRE_OLDER_FILE  */
	TSC_NO_FILETIME,	/* HRE_NO_FILETIME */
	TSC_VIRUS_DETECT,	/* HRE_VIRUS_DET   */
	TSC_USER_SKIP,		/* HRE_USER_SKIP   */
	TSC_REFUSE			/* HRE_REFUSE	   */
	};


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hpr_rcv
 *
 * DESCRIPTION:
 *	Receives files using the Hyperprotocol transfer method.
 *
 * ARGUMENTS:
 *	attended	-- True if the program determines that a user is likely to be
 *					 present at the computer keyboard. FALSE if a user is NOT
 *					 likely to be present (such as host and script modes)
 *	single_file -- TRUE if user specified only a file name to receive the
 *					result of the transfer as opposed to naming a dirctory.
 *
 * RETURNS:
 *	TRUE if the transfer successfully completes. FALSE otherwise.
 */
int hpr_rcv(HSESSION hSession, int attended, int single_file)
	{
	struct s_hc *hc;
	HCOM	  hCom;
	int	      usRetVal;
	int		  iret;
	int 	  status;
	int 	  result;
	int 	  timeout_cnt = 0;
	int       mtype;
	BYTE     *mdata;
	char	  str[20];
	long	  timer;
	struct st_rcv_open stRcv;
	BYTE	  tmp_name[FNAME_LEN];

	hCom = sessQueryComHdl(hSession);

	hc = malloc(sizeof(struct s_hc));
	if (hc == NULL)
		return TSC_NO_MEM;

	memset(hc, 0, sizeof(struct s_hc));

	hc->hSession = hSession;

	/* initialize stuff */
	if (!hr_setup(hc))
		{
		free(hc);
		return TSC_NO_MEM;
		}

	/* initialize control variables */

	/* blocksize depends on the speed of the connection. Larger block sizes
	 * can be used for faster connections. If the blocksize is too large,
	 * error detection will be slow. If too small, there is unnecessary overhead
	 */
	hc->blocksize = 2048;
	// hc->blocksize = xfer_blocksize(hSession);

	hc->current_filen = 0;
	hc->datacnt = hc->blocksize;
	hc->deadmantime = 600;
	hc->total_tries = 0;
	hc->total_thru = 0L;
	hc->total_dsp = 0L;
	hc->ucancel = FALSE;
	hc->usecrc = TRUE;		/* first messages in will use CRC */
	hc->fhdl = NULL;

	hc->rc.checkpoint = 0L;
	hc->rc.files_expected = 0;
	hc->rc.bytes_expected = -1L;
	hc->rc.filesize = -1L;
	hc->rc.expected_msg = 0;
	hc->rc.cancel_reason = HRE_NONE;
	hc->rc.using_compression = FALSE;
	hc->rc.virus_detected = FALSE;

	hc->rc.hr_ptr_putc = hr_toss;
	hc->h_crc = hc->h_checksum = 0;

	omsg_init(hc, TRUE, FALSE);
	hc->rc.single_file = single_file; 	/*	 to the sender					 */


	/* Receiver begins the transfer by transmitting a starting message
		repeatedly until the sender begins */

	/* prepare the initial message */
	omsg_new(hc, 'c');

	/* tell sender who we are */
	hpr_id_get(hc, str);
	omsg_add(hc, str);

	/* we can express our opinion about what checktype and blocksize to use
	 *	but it will be up to the sender to make the final choice
	 */
	wsprintf(str, "T%d", hc->h_chkt == H_CRC ? H_CRC : H_CHECKSUM);
	omsg_add(hc, str);

	wsprintf(str, "B%d", hc->blocksize);
	omsg_add(hc, str);

	/* let sender know whether we can handle compression */
	if (hc->h_trycompress & compress_enable());
		{
		omsg_add(hc, "C");
		}

	/* A restart 0,0 request causes sender to start */
	omsg_add(hc, "R0,0");

	/* send first response packet at intervals until first H_MSGCHAR
	 *	 is received
	 */
	status = H_OK;
	hrdsp_status(hc, HRS_REQSTART);
	timer = startinterval();

	stRcv.pszSuggestedName = "junk.jnk";
	stRcv.pszActualName = tmp_name;
	// stRcv.pstFtCompare = NULL;
	stRcv.lFileTime = 0;
	// stRcv.pfnVscanOutput = NULL;
	// stRcv.ssmchVscanHdl = (SSHDLMCH)0;

	// hc->rc.pfVirusCheck = MakeProcInstance((FARPROC)hr_virus_detect,
	//								hSession->hInstance);

	// stRcv.pfnVscanOutput = (VOID (FAR *)(void *, int))hc->rc.pfVirusCheck;

	// transfer_build_rcv_name(&stRcv);
	xfer_build_rcv_name(hSession, &stRcv);

	// hc->rc.ssmchVscan = stRcv.ssmchVscanHdl;

	hc->xfertimer = -1;

#if FALSE
	/* if we are the host, don't send an immediate start request because
	 * the user probably had to start us first and then set himself up. If
	 * we are the attended machine, though, the other end has probably already
	 * been started.
	 */
	// sendnext = (attended ? 0 : 40);

	// Changed to always try to start immediately since we may be responding
	// to auto-start in which case sender is already waiting
	sendnext = 0;

	repeat
		{
		hc->xfertimer = startinterval();
		if (mComRcvBufrPeek(hCom, &rcode) != 0)
			{
			if (rcode == H_MSGCHAR)
				{
				if (!hr_resynch(hSession, HRE_NONE))
					status = H_NOSTART;
				break;
				}
			// RemoteGet(); 	   /* wrong character, remove it from buffer */
			mComRcvChar(hCom, &rcode);

			/* Other end can send us an ESC to cancel the transfer before
			 *	it ever gets started.
			 */
			if ((rcode == ESC) || (rcode == CAN))
				{
				status = H_RMTABORT;
				hrdsp_event(hSession, hc->rc.cancel_reason = HRE_RMTABORT);
				break;
				}
			}

		/* We can't wait forever to get started. If we haven't seen a start
		 *	character in H_START_WAIT seconds, give up.
		 */
		if ((time = interval(timer)) > H_START_WAIT * 10)
			{
			status = H_NOSTART;
			hc->rc.cancel_reason = HRE_NORESP;
			break;
			}

		/* see if it's time to send another startup request */
		else if (time > sendnext || (rcode & 0x7F) == '\r')
			{
			sendnext = time + 40;	/* send again in 4 seconds */
			omsg_send(hc, 1, FALSE, TRUE);
			}

		/* finally, see if someone at keyboard want's us to stop trying */
		iret = xfer_user_interrupt(hSession);
		if (iret == XFER_ABORT)
			{
			status = H_USERABORT;
			hrdsp_event(hSession, hc->rc.cancel_reason = HRE_USRCANCEL);
			break;
			}
		else if (iret == XFER_SKIP)
			{
			hr_reject_file(hSession, HRE_USER_SKIP);
			}

		hpr_idle(hSession);

		}

#endif

	omsg_send(hc, 1, FALSE, TRUE);
	if (!hr_resynch(hc, HRE_NONE))
		status = H_NOSTART;

	/* If status is still H_OK, it means we've synched with sender.
	 * We'll stay in this loop now until the transfer is finished.
	 */
	while (status == H_OK)
		{
		hr_still_alive(hc, FALSE, FALSE);   /* check whether deadman msg
											is in order */
		hrdsp_progress(hc, 0);		  /* keep user notified */

		/* Collect blocks of data, which may be interrupted by messages
		 * from the sender.
		 */
		result = hr_collect_data(hc, &hc->datacnt, TRUE, H_CHARTIME);
		if (result != HR_TIMEOUT)
			timeout_cnt = 0;
		switch(result)
			{
		case HR_VIRUS_FOUND:
			goto virus_found;

		case HR_COMPLETE:
			/* got all chars. we asked for, setup to receive another
			 * full block
			 */
			hc->rc.checkpoint = hc->h_filebytes;
			hc->h_checksum = hc->h_crc = 0;
			hc->datacnt = hc->blocksize;
			break;

		case HR_DCMPERR :
			/* data error caused decompression algorithm to fail */
			if (!hr_restart(hc, HRE_DCMPERR))
				status = H_NORESYNCH;
			break;

		case HR_BADCHECK :
			/* got complete block but checksum or CRC didn't match */
			if (!hr_restart(hc, HRE_DATAERR))
				status = H_NORESYNCH;
			break;

		case HR_LOSTDATA :
			/* received block n+1 before block n */
			if (!hr_restart(hc, HRE_LOSTDATA))
				status = H_NORESYNCH;
			break;

		case HR_MESSAGE:
			/* Block of data was interrupted by a message. All that's
			 * actually been detected is a message character in the data,
			 * we must now extract and analyze the message
			 */
			switch(result = hr_collect_msg(hc, &mtype, &mdata, H_CHARTIME))
				{
			case HR_KBDINT:
				/* local user interrupted us while receiving the message
				 * if user had interrupted us once and is doing it again
				 * while we are attempting to tell the other end what we're
				 * doing, drop out immediately and leave the sender to fend
				 * for himself.
				 */
				if (hc->ucancel)
					status = H_USERABORT;
				else
					{
					hr_kbdint(hc);
					/* try to let sender know what we're doing */
					if (!hr_cancel(hc, HRE_USRCANCEL))
						status = H_USERABORT;
					}
				break;

			case HR_TIMEOUT:
			case HR_BADMSG:
			case HR_BADCHECK:
				/* message was scrambled, try to resynch */
				if (!hr_restart(hc, HRE_DATAERR))
					status = H_NORESYNCH;
				break;

			case HR_LOSTDATA:
				/* message was recevied, but it was the wrong one */
				if (!hr_restart(hc, HRE_LOSTDATA))
					status = H_NORESYNCH;
				break;

			case HR_COMPLETE:
				/* message received ok, figure out what sender wants */
				status = hr_decode_msg(hc, mdata);
				break;
				}
			break;

		case HR_TIMEOUT:
			/* sender stopped sending to us, try to prod him into restartting */
			if (timeout_cnt++ < TIMEOUT_LIMIT)
				{
				/* TODO: generalize this
				if (cnfg.save_xprot)
					RemoteSendChar(cnfg.save_xon);
				*/
				hr_still_alive(hc, TRUE, TRUE); /* send file ack and timeout msg */
				}
			else
				{
				status = H_TIMEOUT;
				hc->rc.cancel_reason = HRE_TIMEOUT;
				}
			break;

		case HR_KBDINT:
			/* user is trying to interrupt the transfer */
			if (hc->ucancel)
				status = H_USERABORT;
			else
				{
				hr_kbdint(hc);
				/* try to inform sender about what we are doing */
				if (!hr_cancel(hc, HRE_USRCANCEL))
					status = H_USERABORT;
				}
			break;

		case HR_LOST_CARR:
			/* we lost carrier while trying to transfer */
			if (!hr_cancel(hc, HRE_LOST_CARR))
				status = H_TIMEOUT;
			break;

		case HR_FILEERR:
			/* A file error occurred while trying to save incoming data */
			if (!hr_cancel(hc, HRE_DISK_ERR))
				status = H_FILEERR;
			break;
			}

		/* during full-bore transfers, the data collection routines won't
		 *	waste time checking the keyboard for an interrupt request from
		 *	the user or carrier loss so we'll check here at least once per
		 *	data block
		 */
		iret = xfer_user_interrupt(hSession);
		if (iret == XFER_ABORT)
			{
			if (hc->ucancel)
				status = H_USERABORT;
			else
				{
				hr_kbdint(hc);
				if (!hr_cancel(hc, HRE_USRCANCEL))
					status = H_USERABORT;
				}
			}
		else if (iret == XFER_SKIP)
			{
			hr_reject_file(hc, HRE_USER_SKIP);
			}

		if (xfer_carrier_lost(hSession))
			if (!hr_cancel(hc, HRE_LOST_CARR))
					status = H_TIMEOUT;

		/* Actual virus detection occurs deep in the bowels of a transfer.
		 * Therefore, the detecting routine merely sets a flag and begins
		 * tossing data. We actually shut down here
		 */
virus_found:
		if (hc->rc.virus_detected)
			{
			hc->rc.virus_detected = FALSE;	/* don't come in here again */
			if (!hr_cancel(hc, HRE_VIRUS_DET))
				status = H_USERABORT;
			}
		}

	/* Transfer is all done, 'status' indicates the final result. */
	hrdsp_progress(hc, TRANSFER_DONE);
	compress_disable();

	// if (stRcv.ssmchVscanHdl != (SSHDLMCH)0)
	//	StrSrchStopSrch(stRcv.ssmchVscanHdl);

	// if (hc->rc.pfVirusCheck != NULL)
	//	{
	//	FreeProcInstance(hc->rc.pfVirusCheck);
	//	hc->rc.pfVirusCheck = NULL;
	//	}

	usRetVal = (int)hr_result_codes[hc->rc.cancel_reason];

	/* clear display, free memory, etc. */
	status = hr_wrapup(hc, attended, status);
	free(hc);

	return usRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_collect_msg
 *
 * DESCRIPTION:
 *	Called when a message has been detected within a block of data. Messages
 *	start with H_MSGCHAR (0x01). If an H_MSGCHAR occurs as part of the data
 *	being sent, it will be doubled. When it is encountered alone, this routine
 *	is called to extract the following message from the stream of data.
 *
 * ARGUMENTS:
 *	mtype	-- pointer to a variable to be updated with the message type
 *	mdata	-- pointer to a variable to be updated with the address of the
 *				message data
 *	timeout -- amount of time (in tenths of seconds) to wait for the data
 *				to complete the message.
 *
 * RETURNS:
 *	Returns a status code:
 *	  HR_COMPLETE -- message successfully received
 *	  HR_BADCHECK -- crc or checksum error on message data
 *	  HR_TIMEOUT  -- time out exceeded while waiting for data
 *	  HR_KBDINT   -- user interrupted from keyboard
 *	  HR_BADMSG   -- message data was not in recognized format
 *	  HR_LOSTDATA -- message was complete but message number was not the
 *						expected one.
 *	  HR_LOST_CARR --Lost carrier while collecting message
 */
// char FAR *storageptr;	 /* place to put data as we receive it */

int hr_collect_msg(struct s_hc *hc,
					int *mtype,
					BYTE **mdata,
					long timeout)
	{
	unsigned hold_checksum;
	unsigned hold_crc;
	int gotlen = FALSE;
	int count;
	int result = HR_UNDECIDED;
	int (*holdptr)(void *, int);
	int msgn;

	/* since a message is embedded within a data block, we need to preserve
	 * a few values for the interrupted data collection routine.
	 */
	holdptr = hc->rc.hr_ptr_putc;
	/* set collection routine to store data for us */
	hc->rc.hr_ptr_putc = hr_storedata;
	hold_checksum = hc->h_checksum;
	hold_crc = hc->h_crc;
	hc->h_checksum = 0; 			/* messages have their own check bytes */
	hc->h_crc = 0;

	/* We will retrieve the message in two parts, first we'll get the type and
	 *	length fields, then, based on those, we can collect the rest of the
	 *	message.
	 */
	hc->storageptr = hc->rc.rmsg_bufr;
	count = 2;
	while (result == HR_UNDECIDED)
		{
		switch (result = hr_collect_data(hc, &count, FALSE, timeout))
			{
		case HR_COMPLETE:
			if (!gotlen)
				{
				/* got first part, set up to get rest of message */
				result = HR_UNDECIDED;
				*mtype = hc->rc.rmsg_bufr[0];
				count = hc->rc.rmsg_bufr[1];
				if (count < 3)
					result = HR_BADMSG;
				gotlen = TRUE;
				}
			else
				{
				/* got everything, check for valid message */
				msgn = hc->rc.rmsg_bufr[2];
				count = hc->rc.rmsg_bufr[1];
				if (hc->usecrc)
					{
					if (hc->h_crc != 0)
						result = HR_BADCHECK;
					}
				else
					{
					hc->h_checksum -= hc->rc.rmsg_bufr[count];
					hc->h_checksum -= hc->rc.rmsg_bufr[count + 1];
					if (hc->rc.rmsg_bufr[count] != (BYTE)(hc->h_checksum % 256) ||
							hc->rc.rmsg_bufr[count + 1] !=
							(BYTE)(hc->h_checksum / 256))
						result = HR_BADCHECK;
					}
				hc->rc.rmsg_bufr[count] = '\0';
				}
			break;

		case HR_LOST_CARR:
		case HR_TIMEOUT:
		case HR_KBDINT:
			/* return same result */
			break;

		case HR_MESSAGE:
			/* we encountered what looked like a message within a message
			 *	but that is illegal
			 */
			result = HR_BADMSG;
			break;
			}
		}

	/* we're done, restore details for overlying data collection routine */
	hc->rc.hr_ptr_putc = holdptr;
	hc->h_checksum = hold_checksum;
	hc->h_crc = hold_crc;
	*mdata = &hc->rc.rmsg_bufr[3];
	if (result == HR_COMPLETE)
		{
		if (msgn != hc->rc.expected_msg)
			result = HR_LOSTDATA;
		else
			hc->rc.expected_msg = ++hc->rc.expected_msg % 256;
		}
	return(result);
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_still_alive
 *
 * DESCRIPTION:
 *	This routine is called periodically during receiving. It determines
 *	whether it is time to send the sender a 'deadman' message. Since there
 *	is no regular response from the receiver to the sender unless errors
 *	occur, the deadman message prevents the sender from sending into a void
 *	for long periods of time. If the sender doesn't receive ANYTHING from
 *	the receiver for the negotiated deadman time, it can assume the receiver
 *	is no longer active.
 *
 * ARGUMENTS:
 *	force	  -- TRUE if a deadman notification should be sent whether it is
 *					officially time for one or not.
 *	timed_out -- TRUE if receiver has timeout and we want sender to know that.
 *
 * RETURNS:
 *	nothing
 */
void hr_still_alive(struct s_hc *hc, int force, int timed_out)
	{
	char msg[20];

	if (force || (long)interval(omsg_last(hc)) >= hc->deadmantime)
		{
		omsg_new(hc, 'c');
		if (timed_out)
			omsg_add(hc, "t");

		/* While we're talking to the sender, we'll let him know how much
		 *	we've actually received. This lets him clear the table of
		 *	unacknowledged files that he keeps.
		 */
		// StrFmt(msg, "f%d,%lu", hc->current_filen, hc->rc.checkpoint);
		wsprintf(msg, "f%d,%lu", hc->current_filen, hc->rc.checkpoint);
		omsg_add(hc, msg);
		omsg_send(hc, BURSTSIZE, FALSE, FALSE);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_kbdint
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hr_kbdint(struct s_hc *hc)
	{
	/* TODO: fix this somehow
	if (!hc->ucancel)
		errorline(FALSE, strld(TM_WAIT_CONF));
	*/
	hc->ucancel = TRUE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_suspend_input
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hr_suspend_input(void *hS, int suspend)
	{
#if FALSE
	if (suspend)
		suspendinput(FLG_DISK_ACTIVE, 5);
	else
		allowinput(FLG_DISK_ACTIVE);
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_check_input
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 *
 */
void	hr_check_input(void *hS, int suspend)
	{
	}



/********************** end of hpr_rcv0.c ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\foo.c ===
/*	File: \foo.c (Created: 01-Nov-1991)
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 4/05/02 4:39p $
 */

#include <windows.h>
#pragma hdrstop

// #define     DEBUGSTR
#define	BYTE	unsigned char

#include <tdll\stdtyp.h>
#include <tdll\com.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include "foo.h"

#include "xfr_todo.h"

int fooComSendClear(HCOM h, stFB *pB)
	{
    int     rc;

	pB->usSend = 0;
	rc = ComSendClear(h);
    //assert(rc == COM_OK);

    return rc;
	}

int fooComSendChar(HCOM h, stFB *pB, BYTE c)
	{
    int rc = COM_OK;

	if (sizeof (pB->acSend) > pB->usSend)
		{
		pB->acSend[pB->usSend++] = c;

		rc = ComSndBufrSend(h, (void *)pB->acSend, pB->usSend, 200);
		//assert(rc == COM_OK);
		pB->usSend = 0;
		}
	else
		{
		rc = COM_NOT_ENOUGH_MEMORY;
		}

    return rc;
	}

int fooComSendPush(HCOM h, stFB *pB)
	{
    int rc = COM_OK;

	if (pB->usSend > 0)
		{
		rc = ComSndBufrSend(h, (void *)pB->acSend, pB->usSend, 200);
	    //assert(rc == COM_OK);
    	pB->usSend = 0;
		}

    return rc;
	}

int fooComSendCharNow(HCOM h, stFB *pB, BYTE c)
	{
    int     rc;

	rc = fooComSendChar(h, pB, c);
    //assert(rc == COM_OK);

    if (rc == COM_OK)
        {
	    rc = fooComSendPush(h, pB);
        //assert(rc == COM_OK);
        }

    return rc;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr.h ===
/* File: C:\WACKER\xfer\hpr.h (Created: 24-Jan-1994)
 * created from HAWIN source:
 * hpr.h  --  Exported definitions for HyperProtocol routines.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#if !defined(OFF)
#define	OFF	0
#endif
#if !defined(ON)
#define	ON	1
#endif

#define H_CHECKSUM		1
#define H_CRC			2

/* hpr_rcv display row values */
#define HR_DR_RCV_FILE	 1
#define HR_DR_VIR_SCAN	 1
#define HR_DR_STORING	 2
#define HR_DR_COMPRESS	 3
#define HR_DR_TOTAL_RET  3
#define HR_DR_FILE_SIZE  3
#define HR_DR_LAST_EVENT 4
#define HR_DR_FILES_RCVD 4
#define HR_DR_PSTATUS	 5
#define HR_DR_AMT_RCVD	 5
#define HR_DR_VUF		 8
#define HR_DR_VUT		 12
#define HR_DR_BOTMLINE	 15


/* hpr_snd display row values */
#define HS_DR_SND_FILE	 1
#define HS_DR_COMPRESS	 2
#define HS_DR_TOTAL_RET  2
#define HS_DR_FILE_SIZE  2
#define HS_DR_LAST_EVENT 3
#define HS_DR_FILES_SENT 3
#define HS_DR_PSTATUS	 4
#define HS_DR_AMT_SENT	 4
#define HS_DR_VUF		 7
#define HS_DR_VUT		 11
#define HS_DR_BOTMLINE	 14


/* these four variables are settable by user
 * an external routine can set these values to change the default
 * behavior of HyperProtocol
 */
// extern tbool h_useattr; 	   /* use received attributes when avail */
// extern tbool h_trycompress;    /* try to use compression when possible */
// extern tiny  h_chkt;		   /* 1 == checksum, 2 == CRC */
// extern tbool h_suspenddsk;	   /* TRUE if suspend for disk should be used */


/* the entry points for receiving and sending respectively */
extern int hpr_rcv(HSESSION hSession,
					  int attended,
					  int single_file);

extern int hpr_snd(HSESSION hSession,
					  int attended,
					  int hs_nfiles,
					  long hs_nbytes);


/********************* end of hpr.h ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr.hh ===
/* File: C:\WACKER\xfer\hpr.hh (Created: 24-Jan-1994)
 * created from HAWIN source file:
 * hpr.hh  --  Header file for HyperProtocol routines.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */


/* The NOTIMEOUTS constant can be defined to prevent HyperProtocol from
 *	timing out while waiting for the other end of the connection. This is
 *	useful while debugging when events may be drawn out by debugging activities
 */
/* #define NOTIMEOUTS */


/* Constants for HyperProtocol */

#define H_MSGCHAR		0x01
#define MAXRETRIES		5
#define MAX_START_TRIES 25
#define RESYNCH_TIME	50
#define RESYNCH_INC 	50
// #define RESYNCH_TIME    300
// #define RESYNCH_INC	   300
#define FINAL_ACK_WAIT	1800L
#define BURSTSIZE		5
#define TIMEOUT_LIMIT	3
#define H_START_WAIT	100 	/* no. of seconds to wait for startup */
#define H_MINBLOCK		128
#define H_MINDEADMAN	10
#define H_CHARTIME		100L

#define tochar(c) ((BYTE)((c) + 0x20))
#define unchar(c) ((BYTE)((c) - 0x20))
#define h_crc_calc(x, cc)\
	{\
	unsigned q;\
	q = (x->h_crc ^ (cc)) & 0x0F;\
	x->h_crc = (x->h_crc >> 4) ^ (q * 0x1081);\
	q = (x->h_crc ^ ((cc) >> 4)) & 0x0F;\
	x->h_crc = (x->h_crc >> 4) ^ (q * 0x1081);\
	}

/* * * * * * * * * * * * * * * * * * * * * * *
 * This section pertains to the sender only  *
 * * * * * * * * * * * * * * * * * * * * * * */

/* status display codes passed to hsdsp_status() */
#define HSS_WAITSTART	0
#define HSS_SENDING 	1
#define HSS_WAITACK 	2
#define HSS_WAITRESUME	3
#define HSS_CANCELLED	4
#define HSS_COMPLETE	5
#define HSS_MAX 		6

/* event display codes passed to hsdsp_event() */
#define HSE_GOTSTART	0
#define HSE_GOTRETRY	1
#define HSE_GOTRESUME	2
#define HSE_GOTACK		3
#define HSE_USRABORT	4
#define HSE_RMTABORT	5
#define HSE_USRCANCEL	6
#define HSE_RMTCANCEL	7
#define HSE_FILEERR 	8
#define HSE_NORESP		9
#define HSE_FULL		10
#define HSE_DONE		11
#define HSE_ILLEGAL 	12
#define HSE_ERRLIMIT	13
#define HSE_MAX 		14


/* structure for the file status table. This table holds details about files
 *	during and after the time they are sent until they are acknowledged by
 *	the receiver.
 */
struct s_ftbl
	{
	int filen;				/* file number (1st file sent is 1, etc.		 */
	int cntrl;				/* control bits FTC_CONFIRMED and FTC_COMPRESSED */
	int status;				/* transfer status, normal, aborted, error, etc. */
	long flength;			/* length of this file in bytes 				 */
	long dsp_bytes; 		/* length of all files prior to this file		 */
	long thru_bytes;		/* amt. of data actually sent prior to this file */
	TCHAR fname[FNAME_LEN]; /* file name */
	};

/* file table control bits */
#define FTC_CONFIRMED	0x01
#define FTC_COMPRESSED	0x02
#define FTC_DONT_CMPRS	0x04

/* file table status values */
#define FTS_NORMAL		0
#define FTS_USRABORT	1
#define FTS_RMTABORT	2
#define FTS_FILEERR 	3
#define FTS_COMMERR 	4

/* control structure used by hyperprotocol sender */
struct s_hsc
	{
	int 	ft_current; 		/* index to current file in file table */
	int 	ft_open;			/* index to currently opened file */
	int 	ft_top; 			/* index of highest used entry in file table */
	int 	ft_limit;			/* number of entries available in file table */
	jmp_buf jb_bailout;			/* jump buffer used to bail out of xfer */
	jmp_buf jb_restart;			/* jump buffer used during restarts */
	int		rmt_compress;		/* TRUE if remote has indicated it is able to
										handle compression */
	int 	nfiles; 			/* no. of files to be transferred */
	long	nbytes; 			/* no. of bytes to be transferred */
	long	bytes_sent; 		/* no. of bytes actually passed to xmitter */

	int 	rmtchkt;			/* Type of error checking requested by remote
										session. H_CRC by default. */
	long	last_response;		/* time last message received */
	int 	lastmsgn;			/* last message number */
	int		rmtcancel;			/* TRUE if remote has cancelled xfer */
	int		started;			/* TRUE after 1st restart message is received
										from remote */
	int 	lasterr_filenum;	/* file number of last restart request */
	long	lasterr_offset; 	/* file offset of last restart request */
	int 	sameplace;			/* no. of consecutive restarts to same spot*/
	int		receiver_timedout;	/* true if receiver sent time out msg */

	struct s_ftbl *hs_ftbl;		/* pointer to dynamically allocated file
									progress table */
	int		(*hs_ptrgetc)(void *);	/* pointer to function to get
										characters to send */
	};


/* globals used by sender */
// extern struct s_hsc FAR *hsc;		/* contains transfer control variables */
// extern struct s_ftbl FAR *hs_ftbl;	/* pointer to dynamically allocated file
//										progress table */
// extern metachar (NEAR *hs_ptrgetc)(void);/* pointer to function to get
//											characters to send */

/* macros used to send characters using the double buffering scheme */
#define HSXB_SIZE	1024
#define HSXB_CYCLE	75

#define hs_xmit_(p,c) (--p->hsxb.cnt > 0 ? (*p->hsxb.bptr++ = (c)) : hs_xmit_switch(p,c))
#define HS_XMIT(p,c) {if ((c) == H_MSGCHAR) hs_xmit_(p,c); hs_xmit_(p,c);}

struct s_hsxb
	{
	char *curbufr;		/* buffer being filled */
	char *altbufr;		/* other buffer, possibly being transmitted */
	char *bptr; 		/* place to put next character to be sent */
	unsigned bufrsize;	/* size of each buffer in bytes */
	unsigned total; 	/* number of bytes still free in the current buffer
						   not counting those in the current fill cycle */
	unsigned cnt;		/* number of bytes left to load in this fill cycle */
	};


// extern unsigned hse_text[];
// extern unsigned hss_text[];
// extern struct s_hsxb hsxb;		/* control structure for double buffered
//										transmission scheme */

#define HS_XMIT_CLEAR hs_xbclear
#define HS_XMIT_FLUSH hs_xbswitch

struct s_hprsd
	{
	int 	 k_received;
	unsigned int hld_options;
	};

// extern struct s_hprsd FAR *hsd;

/* * * * * * * * * * * * * * * * * * * * * * * *
 * This section pertains to the receiver only  *
 * * * * * * * * * * * * * * * * * * * * * * * */

/* Result codes for overall transfer */
#define H_OK			0
#define H_ERRLIMIT		1
#define H_BADMSGFMT 	2
#define H_FILEERR		3
#define H_NORESYNCH 	4
#define H_USERABORT 	5
#define H_TIMEOUT		6
#define H_COMPLETE		7
#define H_NOSTART		8
#define H_RMTABORT		9

/* Result codes for data collection routines */
#define HR_UNDECIDED	0
#define HR_COMPLETE 	1
#define HR_TIMEOUT		2
#define HR_MESSAGE		3
#define HR_KBDINT		4
#define HR_FILEERR		5
#define HR_NOCARRIER	6
#define HR_BADCHECK 	7
#define HR_BADMSG		8
#define HR_LOSTDATA 	9
#define HR_DCMPERR		10
#define HR_LOST_CARR	11
#define	HR_VIRUS_FOUND	12

/* Hyper receive status codes for hrdsp_status() */
#define HRS_REQSTART	0
#define HRS_REQRESYNCH	1
#define HRS_REC 		2
#define HRS_CANCELLED	3
#define HRS_COMPLETE	4
#define HRS_MAX 		5

/* event codes for hrdsp_event() */
#define HRE_NONE			0
#define HRE_DATAERR 		1
#define HRE_LOSTDATA		2
#define HRE_NORESP			3
#define HRE_RETRYERR		4
#define HRE_ILLEGAL 		5
#define HRE_ERRFIXED		6
#define HRE_RMTABORT		7
#define HRE_USRCANCEL		8
#define HRE_TIMEOUT 		9
#define HRE_DCMPERR 		10
#define HRE_LOST_CARR		11
#define HRE_TOO_MANY		12
#define HRE_DISK_FULL		13
#define HRE_CANT_OPEN		14
#define HRE_DISK_ERR		15
#define HRE_OLDER_FILE		16
#define HRE_NO_FILETIME 	17
#define HRE_VIRUS_DET		18
#define	HRE_USER_SKIP		19
#define HRE_USER_REFUSED 	20
#define HRE_MAX 			21


/* Structure containing control variables for the receiver */
struct s_hrc
	{
	long  bytes_expected;		/* total number of bytes expected for xfer */
	long  checkpoint;			/* number of bytes known to be good */
	long  basesize; 			/* original size of file being appended to */
	int   expected_msg; 		/* number of next expected message */
								/* a timestamp of 0 means unused */
	unsigned long ul_lstw;		/* timestamp of file being received, if any */
	unsigned long ul_cmp;		/* time to compare to if /N option used */
								/* a timestamp of -1 means rejected by time */
	long  filesize; 			/* size of file being received */
	int   files_expected;		/* number of files to be rcvd. during xfer */
	BYTE  rmtfname[FNAME_LEN];  /* name remote system used for file */
	TCHAR ourfname[FNAME_LEN]; /* name we will use for file */
	int   cancel_reason;		/* event code associated with cancellation */
	int   using_compression;	/* TRUE if we're using compression */
	BYTE rmsg_bufr[256];		/* buffer to build outgoing messages */
	int  single_file;			/* TRUE if user named single file as dest */
	//SSHDLMCH ssmchVscan;		/* handle for virus scanning */
	int virus_detected;			/* set TRUE upon virus detection */
	//FARPROC pfVirusCheck;		/* pointer to function for virus check */

	int (*hr_ptr_putc)(void *, int);
	};

// VOID _export PASCAL hr_virus_detect(VOID FAR *h, USHORT usMatchId);

/* globals for receiver */
// extern struct s_hrc FAR *hrc;/* pointer to receiver's control structure */
// extern metachar (NEAR *hr_ptr_putc)(metachar);

extern int hr_result_codes[];  /* maps HyperProtocol event codes to
									transfer status codes */

/******************************************************/
/* control structure used by both sender and receiver */
/******************************************************/

struct s_hc
	{
	HSESSION  hSession;

	int 	  blocksize;		/* current size of data blocks */
	int 	  current_filen;	/* current file number */
	int 	  datacnt;			/* keeps track of data sent or received */
	long	  deadmantime;		/* time between dead man notices */
	unsigned  total_tries;		/* number of restarts */
	long	  total_thru;		/* total number of bytes transferred */
	long	  total_dsp;		/* total number of bytes for vu display */
	int		  ucancel;			/* set true if user hits cancel key */
	int		  usecrc;			/* set true if CRC is being used */
	long	  xfertimer;		/* interval timer value */
	long	  xfertime; 		/* transfer time */
	BYTE	  omsg_bufr[256];	/* outgoing message buffer */
	BYTE	 *omsg; 			/* pointer into outgoing message buffer */
	int 	  omsgn;			/* next outgoing message number */
	int		  omsg_printable;	/* true of outgoing message characters
									should be confined to printable chrs */
	int		  omsg_embed;		/* true if outgoing messages should be embedded
									in other outgoing data */
	long	  last_omsg;		/* time last outgoing message was sent */

	unsigned  h_checksum;		/* used to calculate data checksum */
	unsigned  h_crc;			/* used to calculate data crcs */
	long	  h_filebytes;		/* counts bytes transferred */

								/* External parameters set by the user */
	int       h_useattr;		/* use received attributes when available */
	int       h_trycompress;	/* try to use compression when possible */
	int       h_chkt;			/* 1 == checksum, 2 == CRC */
	int       h_resynctime;		/* new resync time value */
	int       h_suspenddsk;		/* old feature, no longer used */

	long      displayed_time;	/* used in display timing */

	BYTE     *storageptr;		/* temporary use */

	BYTE      msgdata[96];		/* more static storate stuff */
	BYTE     *dptr;
	int       rmcnt;

	struct s_hrc rc;			/* data used for receiving */

	struct s_hsc sc;			/* data used for sending */

	struct s_hsxb hsxb;			/* control structure for double buffered */

	struct s_hprsd sd;			/* display stuff */

	ST_IOBUF *fhdl;
	};


/* Globals used by sender and receiver.
 * These items are defined as globals rather than being placed int one
 *	of the control structures because they are accessed frequently in
 *	speed-sensitive portions of the code.
 */
// extern struct s_hc FAR *hc; 			/* pointer to control structure */
// extern unsigned    h_checksum;		/* used to calculate data checksum */
// extern unsigned    h_crc;			/* used to calculate data crcs */
// extern long 	   h_filebytes; 	/* counts bytes transferred */

/*************************/
/* function prototypes : */
/*************************/

/* used by both sender and receiver -- */
extern void 	omsg_init(struct s_hc *hc, int fPrintable, int fEmbedMsg);
extern void 	omsg_new(struct s_hc *hc, BYTE type);
extern int  	omsg_add(struct s_hc *hc, BYTE *newfield);
extern int		omsg_setnum(struct s_hc *hc, int n);
extern int		omsg_send(struct s_hc *hc,
						int burstcnt,
						int usecrc,
						int backspace);
extern long 	omsg_last(struct s_hc *hc);
extern int		omsg_number(struct s_hc *hc);

// extern void	   h_crc_calc(uchar);

/* used by receiver -- */
extern int		hr_collect_msg(struct s_hc *, int *, BYTE **, long);
extern int      hr_storedata(void *, int);
extern void 	hr_still_alive(struct s_hc *, int, int);
extern void 	hr_kbdint(struct s_hc *);
extern int		hr_decode_msg(struct s_hc *, BYTE *);
extern int		hr_reject_file(struct s_hc *, int);
extern int  	hr_closefile(struct s_hc *, int);
extern int		hr_collect_data(struct s_hc *, int *, int, long);
extern int  	hr_cancel(struct s_hc *, int);
extern int  	hr_restart(struct s_hc *, int);
extern int  	hr_resynch(struct s_hc *, int);
extern int      hr_putc(void *, int);
extern int      hr_putc_vir(void *, int);
extern int      hr_toss(void *, int);

extern void  hr_suspend_input(VOID *hS, int suspend);
extern void  hr_check_input(VOID *hS, int suspend);

/* used by sender -- */
extern int  	hyper_sendx(struct s_hc *, int);
extern int  	hs_datasend(struct s_hc *);
extern void 	hs_dorestart(struct s_hc *, int, long, int, int);
extern int		hs_reteof(struct s_hc *);
extern int		hs_getc(struct s_hc *);
extern void 	hs_background(struct s_hc *);
extern void 	hs_rcvmsg(struct s_hc *);
extern void 	hs_filebreak(struct s_hc *hc, int nfiles, long nbytes);
extern void 	hs_waitack(struct s_hc *);
extern void 	hs_decode_rmsg(struct s_hc *, BYTE *);
extern void 	hs_fileack(struct s_hc *, int);
extern void 	hs_logx(struct s_hc *, int);

/******************* end of hpr.hh *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_rcv1.c ===
/* File: C:\WACKER\xfer\hpr_rcv1.c (Created: 24-Jan-1994)
 * created from HAWIN source file
 * hpr_rcv1.c  --  Routines to implement HyperProtocol receiver.
 *
 *	Copyright 1989,1993,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
// #define DEBUGSTR

#include <windows.h>
#include <setjmp.h>
#include <stdlib.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"
#include "itime.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_decode_msg
 *
 * DESCRIPTION:
 *	Called when a complete message has been received to decode the fields
 *	of the message. Messages are composed of printable characters in one
 *	or more fields separated by semicolons. Each field within a message
 *	is considered to be independent of any others but fields are guaranteed
 *	to be examined left to right with a message. Fields containing badly
 *	formatted information generate an error but fields containing unrecognized
 *	data are ignored.
 *	Note also that certain message fields may prevent subsequent fields from
 *	being decoded. For instance, if a partial data block 'P' field indicates
 *	that the previous data block was no good, a restart will be requested
 *	immediately and any undecoded fields will be ignored.
 *
 * ARGUMENTS:
 *	mdata -- A pointer to the printable string that contains the message
 *				fields.
 *
 * RETURNS:
 *	A status code which can be one of:
 *		H_OK		if all fields were decoded without incident
 *		H_BADMSGFMT if a field is of a recognized type but contains badly
 *						formatted data.
 *		H_NORESYNCH if a restart was needed as the result of a field but
 *						could not be completed.
 *		H_FILEERR	if a file error occurred while processing a field
 *		H_COMPLETE	if the end of transfer field was encountered.
 */
int hr_decode_msg(struct s_hc *hc, BYTE *mdata)
	{
	HCOM hCom;
	BYTE *field;
	BYTE mstr[20];
	int result = H_OK, retval, HRE_code;
	int i;
	BYTE typecode;
	struct st_rcv_open stRcv;

	hCom = sessQueryComHdl(hc->hSession);

	// field = _fstrtok(mdata, FstrScolon());
	field = strtok(mdata, ";");
	while (field != NULL)
		{
		switch(typecode = *field++)
			{
		case 'N' : /* number of files to expect */
			if (!hc->rc.files_expected)
				{
				hc->rc.files_expected = (int)atol(field);
				if (hc->rc.files_expected > 1 && hc->rc.single_file &&
						!hr_cancel(hc, HRE_TOO_MANY))
					return(H_BADMSGFMT);	/* this may need a new status */
				hrdsp_filecnt(hc, hc->rc.files_expected);
				}
			break;

		case 'S' :	/* size in bytes of all files */
			if (hc->rc.bytes_expected == -1L)
				{
				if ((hc->rc.bytes_expected = atol(field)) <= 0)
					hc->rc.bytes_expected = -1L;
				else
					hrdsp_totalsize(hc, hc->rc.bytes_expected);
				}
			break;

		case 'A' :	/* abort current file */
			hrdsp_event(hc, HRE_RMTABORT);
			if (hc->fhdl)
				hr_closefile(hc, HRE_RMTABORT);
			break;

		case 'P' :	/* check partial block */
			if ((int)atol(field) != (hc->blocksize - hc->datacnt)
					|| (field = strchr(field, ',')) == NULL
					|| (unsigned)atol(field + 1)
					!= (hc->usecrc ? hc->h_crc : hc->h_checksum))
				if (!hr_restart(hc, HRE_DATAERR))
					return(H_NORESYNCH);
			hc->rc.checkpoint = hc->h_filebytes;
			hc->datacnt = hc->blocksize;
			hc->h_checksum = hc->h_crc = 0;
			break;

		case 'F' :	/* new file */
			if (hc->current_filen && hc->fhdl && !hr_closefile(hc, HRE_NONE))
				return(H_FILEERR);
			/* set up for new file */
			hc->h_filebytes = hc->rc.checkpoint = 0L;
			hc->rc.filesize = -1L;
			hc->rc.ul_lstw = 0;				/* don't know date/time */
			if ((int)atol(field) != ++hc->current_filen ||
					(field = strchr(field, ',')) == NULL)
				return(H_BADMSGFMT);
			strcpy(hc->rc.rmtfname, ++field);
			hc->rc.filesize = -1L;


			/* set up argument structure and let transfer open the file
			 */
			stRcv.pszSuggestedName = hc->rc.rmtfname;
			stRcv.pszActualName = hc->rc.ourfname;
			/* TODO: figure out how this time stuff works */
			stRcv.lFileTime = hc->rc.ul_cmp;

			// stRcv.pfnVscanOutput = hr_virus_detect;
			// stRcv.pfnVscanOutput = (VOID (FAR *)(VOID FAR *, USHORT))hc->rc.pfVirusCheck;
			// stRcv.ssmchVscanHdl = hc->rc.ssmchVscan;

			if ((retval = xfer_open_rcv_file(hc->hSession, &stRcv, 0L)) != 0)
				{
				switch (retval)
				{
				case -6:
					HRE_code = HRE_USER_REFUSED;
					break;
				case -5:
					HRE_code = HRE_DISK_ERR;
					break;
				case -4:
					HRE_code = HRE_NO_FILETIME;
					break;
				case -3:
					HRE_code = HRE_CANT_OPEN;
					break;
				case -2:
					HRE_code = HRE_OLDER_FILE;
					break;
				case -1:
				default:
					HRE_code = HRE_CANT_OPEN;
					break;
				}

				if (!hr_cancel(hc, HRE_code))
					return(H_FILEERR);
				}
			hc->fhdl = stRcv.bfHdl;
			hc->rc.basesize = stRcv.lInitialSize;

			// hc->rc.ssmchVscan = stRcv.ssmchVscanHdl;
			// xferMsgVirusScan(hSession, (hc->rc.ssmchVscan == (SSHDLMCH)0) ? 0:1);
			// hc->rc.virus_detected = FALSE;

			hrdsp_compress(hc, FALSE);
			hrdsp_newfile(hc, hc->current_filen, hc->rc.rmtfname, hc->rc.ourfname);
			hc->datacnt = hc->blocksize;
			hc->h_checksum = hc->h_crc = 0;

			/* If there is no valid compare time, then the /N option is not
			 *	being used or there is no existing file and we can set up to
			 *	store received data. If there is a compare time, keep tossing
			 *	characters until we've verified that the incoming file is
			 *	newer than what we have.
			 */
			if (hc->rc.ul_cmp == (unsigned long)(-1))
				hc->rc.hr_ptr_putc = hr_toss;
			//else if (hc->rc.ssmchVscan == (SSHDLMCH)0)/* is virscan active? */
			//	hc->rc.hr_ptr_putc = hr_putc;
			// else
			//hc->rc.hr_ptr_putc = hr_putc_vir;
			else
				hc->rc.hr_ptr_putc = hr_putc;

			break;

		case 'V' :	/* Version identifier from sender */
			i = (int)atol(field);
			if ((field = strchr(field, ',')) == NULL)
				return(H_BADMSGFMT);

			/* if version restrictions were found, stop the transfer */
			if (hpr_id_check(hc, i, ++field))
				break;
			/* else fall through */

		case 'X' :
			if (hc->rc.cancel_reason == HRE_NONE)
				hc->rc.cancel_reason = HRE_RMTABORT;
			hrdsp_event(hc, hc->rc.cancel_reason);
			/* fall through */

		case 'E' :	/* end of transfer */
			omsg_new(hc, 'c');
			// StrFmt(mstr, "E%d", hc->current_filen + 1);
			wsprintf(mstr, "E%d", hc->current_filen + 1);
			omsg_add(hc, mstr);
			// RemoteClear();  /* get rid of any prod messages */
			ComRcvBufrClear(hCom);

			/* Sending the next message as a burst causes the excess characters
			 *	to be sent to the remote system after the transfer has ended,
			 *	perhaps causing them to dither on the display. It is tempting
			 *	to send a single message rather that a burst, but the receiver
			 *	is going to assume the transfer is done and exit after sending
			 *	this message so there is no chance for an error recovery if
			 *	the message is hit.
			 */
			omsg_send(hc, BURSTSIZE, FALSE, TRUE);
			hc->xfertime = interval(hc->xfertimer);
			hrdsp_status(hc, typecode == 'E' ? HRS_COMPLETE : HRS_CANCELLED);
			if (hc->current_filen > 0 && hc->fhdl)
				{
				if (typecode == 'E')
					{
					if (!hr_closefile(hc, HRE_NONE))
						return(H_FILEERR);
					}
				else
					hr_closefile(hc, hc->rc.cancel_reason);
				}
			return(H_COMPLETE);

		case 'C' :
			if (strlen(field) == 0 &&
				!decompress_start(&hc->rc.hr_ptr_putc, hc, FALSE))
				{
				result = H_FILEERR;
				}
			else
				{
				hrdsp_compress(hc, TRUE);
				hc->rc.using_compression = TRUE;
				hrdsp_status(hc, HRS_REC);
				}
			break;

		case 's' :
			if ((hc->rc.filesize = atol(field)) > 0)
				hrdsp_filesize(hc, hc->rc.filesize);
			break;

		case 't' :	/* file time/date */
			{
			unsigned long ulTime;
			struct tm stT;

			memset(&stT, 0, sizeof(struct tm));
			stT.tm_year = atoi(field);		/* ?? adjust */
			if ((field = strchr(field, ',')) != NULL)
				stT.tm_mon = atoi(++field);
			if (field != NULL && (field = strchr(field, ',')) != NULL)
				stT.tm_mday = atoi(++field);
			if (field != NULL && (field = strchr(field, ',')) != NULL)
				stT.tm_hour = atoi(++field);
			if (field != NULL && (field = strchr(field, ',')) != NULL)
				stT.tm_min = atoi(++field);
			if (field != NULL && (field = strchr(field, ',')) != NULL)
				stT.tm_sec = atoi(++field);

			ulTime = mktime(&stT);
			if ((long)ulTime == (-1))
				ulTime = 0;
			else
				ulTime -= itimeGetBasetime();

			hc->rc.ul_lstw = ulTime;

			/*
			 * if hc->rc.ul_cmp contains a valid date/time, it means that
			 * the /N options was used and the file being received already
			 * exists.  Compare the two times and reject any file that is
			 * not newer than what we already have.
			 */
			if (hc->rc.ul_cmp != 0)
				{
				if (hc->rc.ul_cmp >= hc->rc.ul_lstw)
					{
					/* reject incoming file */
					hr_reject_file(hc, HRE_OLDER_FILE);
					hc->rc.ul_cmp = (unsigned long)(-1);
					}
				else
					{
					/* everything is OK */
					// if (hc->rc.ssmchVscan == (SSHDLMCH)0)
						hc->rc.hr_ptr_putc = hr_putc;	/* no virus checking */
					// else   
					// 	hc->rc.hr_ptr_putc = hr_putc_vir;	/* use vir check */
					hc->rc.ul_cmp = 0;
					}
				}
			}
			break;

		case 'B' :
			hc->blocksize = (int)atol(field);
			break;

		case 'D' :
			hc->deadmantime = atol(field) * 10;
			break;

		case 'I' :
			hr_still_alive(hc, TRUE, FALSE);
			break;

		case 'T' :
			if ((i = (int)atol(field)) == 1)
				hc->usecrc = FALSE;
			else if (i == 2)
				hc->usecrc = TRUE;
			else
				result = H_BADMSGFMT;
			break;

		default:
			/* ignore, might be option supported in later version */
			break;
			}
		// field = _fstrtok(NULL, FstrScolon());
		field = strtok(NULL, ";");
		}
	return(result);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_reject_file
 *
 * DESCRIPTION:
 *	Called when we are trying to reject a file that we are receiving.
 *
 * ARGUEMENTS:
 *	reason	-- why we are rejecting the file
 *
 * RETURNS:
 *	Always TRUE
 */
int	hr_reject_file(struct s_hc *hc, int reason)
	{
	BYTE mstr[20];

	/* reject incoming file */
	omsg_new(hc, 'c');
	wsprintf(mstr, "A%d", hc->current_filen);
	omsg_add(hc, mstr);
	omsg_send(hc, BURSTSIZE, FALSE, TRUE);
	hrdsp_event(hc, reason);
	hr_closefile(hc, reason);

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_closefile
 *
 * DESCRIPTION:
 *	Called when the receiver is through saving to a particular file prior
 *	to switching to another file or finishing the transfer.
 *
 * ARGUMENTS:
 *	reason -- an event code indicating why this file is being closed
 *
 * RETURNS:
 *	TRUE if file is closed without problem.
 *	FALSE if an error occurred while closing.
 */
int hr_closefile(struct s_hc *hc, int reason)
	{
	int retcode;

	hrdsp_progress(hc, FILE_DONE);
	hc->total_thru += hc->h_filebytes;
	hc->total_dsp += ((hc->rc.filesize == -1) ? hc->h_filebytes : hc->rc.filesize);
	if (hc->fhdl != NULL)
		{
		// retcode = transfer_close_rcv_file(hc->fhdl, hr_result_codes[reason],
		retcode = xfer_close_rcv_file(hc->hSession,
									hc->fhdl,
									hr_result_codes[reason],
									hc->rc.rmtfname,
									hc->rc.ourfname,
									xfer_save_partial(hc->hSession),
									hc->h_filebytes + hc->rc.basesize,
									hc->h_useattr ? hc->rc.ul_lstw : 0L);
		}

	hc->fhdl = NULL;
	hc->h_filebytes = 0;
	hc->rc.using_compression = FALSE;
	hc->rc.hr_ptr_putc = hr_toss;
	return retcode;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_cancel
 *
 * DESCRIPTION:
 *	This routine is called when a problem or interruption during receiving
 *	forces a cancellation of the transfer. This routine attempts to inform
 *	the sender of the cancellation so that a graceful shutdown can be
 *	accomplished.
 *	It is up to the sender to actually shut down the transfer. We just send
 *	an interruption message to the sender asking him to do so.
 *
 * ARGUMENTS:
 *	reason -- A code providing the reason we must cancel. The reason codes
 *			are the same as the receiver event codes defined in the header
 *			file as HRE_*****
 *
 * RETURNS:
 *	TRUE if the sender responded to our request within a reasonable time.
 *	FALSE if the sender did not respond.
 *
 */
int hr_cancel(struct s_hc *hc, int reason)
	{
	HCOM hCom;
	BYTE str[40];

	hCom = sessQueryComHdl(hc->hSession);

	if (hc->rc.cancel_reason == HRE_NONE)
		hc->rc.cancel_reason = reason;

	if (reason == HRE_LOST_CARR)
		return FALSE;

	omsg_new(hc, 'c');
	// StrFmt(str, "X;R%d,%lu", hc->current_filen, hc->rc.checkpoint);
	wsprintf(str, "X;R%d,%lu", hc->current_filen, hc->rc.checkpoint);

	DbgOutStr("%s\r\n", (LPSTR)str, 0,0,0,0);

	omsg_add(hc, str);
	hc->rc.hr_ptr_putc = hr_toss;
	// RemoteClear();
	ComRcvBufrClear(hCom);
	hc->h_filebytes = hc->rc.checkpoint;
	omsg_send(hc, BURSTSIZE, FALSE, FALSE);
	return(hr_resynch(hc, reason));
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_restart
 *
 * DESCRIPTION:
 *	This routine is called when an error in the received data forces us
 *	to restart the transfer at the last known good location. This routine
 *	formats the interruption request message to the sender, sends the first
 *	message, then passes control to hr_resynch to figure out when and if
 *	the sender responds.
 *
 * ARGUMENTS:
 *	reason -- A code indicating the reason for the restart. The codes used
 *			are the receiver event codes itemized in the header file as
 *			HRE_*****
 *
 * RETURNS:
 *	TRUE if sender responds to the restart request.
 *	FALSE if the sender does not respond within a reasonable time.
 */
int hr_restart(struct s_hc *hc, int reason)
	{
	HCOM hCom;
	BYTE str[15];

	hCom = sessQueryComHdl(hc->hSession);

	omsg_new(hc, 'c');
	// StrFmt(str, "R%d,%lu", hc->current_filen, hc->rc.checkpoint);
	wsprintf(str, "R%d,%lu", hc->current_filen, hc->rc.checkpoint);
	omsg_add(hc, str);
	// RemoteClear();
	ComRcvBufrClear(hCom);

	/* Don't start accepting characters if file is being rejected due to
	 *	/N option and there is a file open to receive them.
	 */
	if ((hc->rc.ul_cmp == (unsigned long)(-1)) && (hc->fhdl != NULL))
		// hc->rc.hr_ptr_putc = (hc->rc.ssmchVscan == (SSHDLMCH)0) ? hr_putc : hr_putc_vir;
		hc->rc.hr_ptr_putc = hr_putc;
	else
		hc->rc.hr_ptr_putc = hr_toss;

	if (hc->rc.using_compression)
		decompress_start(&hc->rc.hr_ptr_putc, hc, FALSE);
	hc->h_filebytes = hc->rc.checkpoint;
	omsg_send(hc, BURSTSIZE, FALSE, FALSE);
	if (hc->fhdl)
		{
		fio_seek(hc->fhdl,
				(long)hc->rc.checkpoint + hc->rc.basesize,
				FIO_SEEK_SET);
		}
	return(hr_resynch(hc, reason));
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_resynch
 *
 * DESCRIPTION:
 *	Attempts to resynchronize the receiver with the data stream coming
 *	from the sender.  This routine is called when the receiver starts or
 *	after any interruption where the receiver asked the sender to restart
 *	its sending from a new location. The calling routine will have already
 *	sent the first copy of the restart message to the sender. This routine
 *	will monitor all messages arriving from the sender, looking for a
 *	restart message that matches the last request sent out. This routine
 *	will resend the restart request message at intervals to account for
 *	possible data loss or error in either the receiver message or the
 *	response from the sender.
 *
 * ARGUMENTS:
 *	hSession -- The session handle
 *	reason	 -- A reason code describing why the resynch must be performed.
 *				This will be HRE_NONE only in the case of initial startup.
 *
 * RETURNS:
 *	TRUE if resynch was successful.
 *	FALSE if resynch failed
 */
int hr_resynch(struct s_hc *hc, int reason)
	{
	HCOM hCom;
	int fStarted = FALSE;
	int tries = 0;
	int try_limit = 0;
	int request_again = FALSE; /* first request already made */
	int result, i, j;
	int iret;
	// long l;
	long timer, time_limit;
	TCHAR rcode;
	int mtype;
	BYTE *msgdata;
	BYTE *field;
	int ok;
	struct
		{
		int msgn;
		long time;
		} request_tbl[MAX_START_TRIES];
	/* this variable is not accessed if NOTIMEOUTS is on */
	long tmptime;				/*lint -esym(550,tmptime)*/

	hCom = sessQueryComHdl(hc->hSession);

	// reason will be HRE_NONE only if this is the initial resynch call
	// so we will set fStarted appropriately and use it to control behavior
	// later on
	if (reason == HRE_NONE)
		{
		fStarted = FALSE;
		try_limit = MAX_START_TRIES;
		}
	else
		{
		fStarted = TRUE;
		try_limit = MAXRETRIES;
		hrdsp_event(hc, reason);
		hrdsp_status(hc, HRS_REQRESYNCH);
		++hc->total_tries;
		hrdsp_errorcnt(hc, hc->total_tries);
		}
	// time_limit = RESYNCH_TIME;		// MOBIDEM
	j = hc->h_resynctime;
	j *= 10;
	if (j == 0)
		j = RESYNCH_TIME;
	time_limit = j;

	request_tbl[0].msgn = omsg_number(hc);
	timer = request_tbl[0].time = startinterval();
	DbgOutStr("Initial:%d, %ld, %ld\r\n",
			request_tbl[0].msgn, timer, time_limit, 0, 0);
	for ( ; ; )
		{
		if (request_again)
			{
			if (++tries >= try_limit)
				{
				hrdsp_status(hc, HRS_CANCELLED);
				if (hc->rc.cancel_reason == HRE_NONE)
					hc->rc.cancel_reason = HRE_RETRYERR;
				return(FALSE);
				}
			if (fStarted)
				omsg_send(hc, BURSTSIZE, FALSE, FALSE);
			else
				omsg_send(hc, 1, FALSE, TRUE);

			// Record this attempt in the table so we can match up responses
			request_tbl[tries].msgn = omsg_number(hc);
			timer = request_tbl[tries].time = startinterval();
			++hc->total_tries;
			hrdsp_errorcnt(hc, hc->total_tries);
			request_again = FALSE;
			DbgOutStr("Restart:%d, %0ld, %0ld\r\n",
					request_tbl[tries].msgn, timer, time_limit, 0, 0);
			}

		iret = xfer_user_interrupt(hc->hSession);
		if (iret == XFER_ABORT)
			{
			if (!fStarted || hc->ucancel)
				return(FALSE);
			else
				{
				return(hr_cancel(hc, HRE_USRCANCEL));
				}
			}
		else if (iret == XFER_SKIP)
			{
			hr_reject_file(hc, HRE_USER_SKIP);
			}

		if (xfer_carrier_lost(hc->hSession))
			return hr_cancel(hc, HRE_LOST_CARR);

#if !defined(NOTIMEOUTS)
		if ((tmptime = interval(timer)) > time_limit)
			{
			request_again = TRUE;
			if (fStarted)
				// time_limit += RESYNCH_INC;		// MOBIDEM
				{
				j = hc->h_resynctime;
				j *= 10;
				if (j == 0)
					j = RESYNCH_INC;
				time_limit += j;
				}
			hrdsp_event(hc, HRE_NORESP);
			}
		else
#endif
		if (mComRcvChar(hCom, &rcode) == 0)
			xfer_idle(hc->hSession);
		else if (rcode == H_MSGCHAR)
			{
			/* restart messages always start with #0 & use CRC */
			hc->rc.expected_msg = 0;
			hc->usecrc = TRUE;
			mtype = ' ';
			result = hr_collect_msg(hc, &mtype, &msgdata, H_CHARTIME);
			if (result == HR_KBDINT)
				{
				if (hc->ucancel)
					return(FALSE);
				else
					{
					hr_kbdint(hc);
					return(hr_cancel(hc, HRE_USRCANCEL));
					}
				}

			else if (result == HR_LOST_CARR)
				return hr_cancel(hc, HRE_LOST_CARR);

			else if (result != HR_COMPLETE) /* HR_TIMEOUT or HR_BAD??? */
				{
				DbgOutStr("Bad message\r\n", 0,0,0,0,0);
				if (mtype == 'R')	/* probably our resynch, try again */
					{
					DbgOutStr("Bad message was type R\r\n", 0,0,0,0,0);
					hrdsp_event(hc, HRE_RETRYERR);
					request_again = TRUE;
					}
				}
			else if (mtype == 'R')	/* good Resynch message */
				{
				if (!fStarted)
					hc->xfertimer = startinterval();
				fStarted = TRUE;
				field = strtok(msgdata, ";");
				if (field == NULL || *field++ != 'R')
					{
					DbgOutStr("Bad format\r\n", 0,0,0,0,0);
					request_again = TRUE;
					hrdsp_event(hc, HRE_ILLEGAL);
					}
				else
					{
					if (unchar(*field) != (BYTE)request_tbl[tries].msgn)
						{
						for (i = tries - 1; i >= 0; --i)
							if (unchar(*field) == (BYTE)request_tbl[i].msgn)
								{
								// We got a response to an earlier restart request.
								// Adjust the amount of time we wait for responses
								// based on the actual time of the message just
								// received.

								// time_limit = interval(request_tbl[i].time) +
								//		RESYNCH_INC;		// MOBIDEM
								j = hc->h_resynctime;
								j *= 10;
								if (j == 0)
									j = RESYNCH_INC;
								time_limit = interval(request_tbl[i].time) + j;

								DbgOutStr("Got %d, new time_limit=%ld\r\n",
										request_tbl[i].msgn, time_limit, 0,0,0);
								break;	/* don't ask for retry */
								}
						if (i < 0)
							{
							hrdsp_event(hc, HRE_RETRYERR);
							request_again = TRUE;
							DbgOutStr("Not in table\r\n", 0,0,0,0,0);
							}
						}
					else
						{
						ok = TRUE;
						// field = _fstrtok(NULL, FstrScolon());
						field = strtok(NULL, ";");
						while (field != NULL)
							{
							switch (*field++)
								{
							case 'f':
								if ((int)atol(field) != hc->current_filen)
									ok = FALSE;
								break;
							case 'o':
								if (atol(field) != hc->rc.checkpoint)
									ok = FALSE;
								break;
							case 'B':
								hc->blocksize = (int)atol(field);
								break;
							case 'T' :
								if ((i = (int)atol(field)) == 1)
									hc->usecrc = FALSE;
								else if (i == 2)
									hc->usecrc = TRUE;
								break;
							default:
								break;
								}
							// field = _fstrtok(NULL, FstrScolon());
							field = strtok(NULL, ";");
							}
						if (ok)
							{
							hc->h_checksum = hc->h_crc = 0;
							hc->datacnt = hc->blocksize;
							if (reason != HRE_NONE || tries > 0)
								hrdsp_event(hc, HRE_ERRFIXED);
							hrdsp_status(hc, HRS_REC);
							DbgOutStr("Resynch successful\r\n", 0,0,0,0,0);
							return(TRUE);
							}
						else
							{
							hrdsp_event(hc, HRE_RETRYERR);
							request_again = TRUE;
							DbgOutStr("Not OK\r\n", 0,0,0,0,0);
							}
						}
					}
				}
			}
		}
	/*lint -unreachable*/
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_virus_detect
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
#if FALSE
STATICF VOID _export PASCAL hr_virus_detect(VOID FAR *h, USHORT usMatchId)
	{

	hc->rc.virus_detected = TRUE; /* force cancel of transfer */
	}
#endif


/********************** end of hpr_rcv1.c ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr.c ===
/* File: C:\WACKER\xfer\hpr.c (Created: 25-Jan-1994)
 * created from HAWIN source file
 * hpr.c  --  Functions common to HyperSend and HyperSave routines.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#include <windows.h>
#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>


#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *	Routines to handle building and sending of outgoing messages   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_init
 *
 * DESCRIPTION:
 *	Called before using any other omsg_ functions to provide the routines
 *	with resources.
 *
 * ARGUMENTS:
 *	bufr		-- A pointer to a memory buffer that the omsg routines can
 *					use to build messages. It must be large enough for the
 *					largest message to be sent plus a size byte and two
 *					check bytes.
 *	size		-- The size of bufr in bytes.
 *	fPrintable	 -- TRUE if the message should be sent in printable form. If
 *					this is TRUE, the only non-printable character sent as
 *					a part of outgoing messages will be the initial SOH
 *					character. The size and check bytes are converted to
 *					printable characters.
 *	sndfunc 	-- A pointer to a function that omsg_send can use to transmit
 *					a message after it has been formatted. The function should
 *					accepet a single character argument and return VOID.
 *
 * RETURNS:
 *	nothing
 */
void omsg_init(struct s_hc *hc, int fPrintable, int fEmbedMsg)
	{
	hc->omsg_printable = fPrintable;
	hc->omsg_embed = fEmbedMsg;
	omsg_setnum(hc, -1);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_new
 *
 * DESCRIPTION:
 *	Begins formatting a new message. Messages are built up in pieces and
 *	can be sent more than once. This function discards any old message
 *	and sets up a new one containing no fields.
 *
 * ARGUMENTS:
 *	type -- A single character type character to be used in the message
 *			type field of the the new message.
 *
 * RETURNS:
 *	nothing
 */
void omsg_new(struct s_hc *hc, BYTE type)
	{
	hc->omsg_bufr[0] = type;
	hc->omsg_bufr[1] = ' ';
	hc->omsg_bufr[2] = ' ';
	hc->omsg_bufr[3] = '\0';
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_add
 *
 * DESCRIPTION:
 *	Adds a field to a message being built. A prior call to omsg_new will have
 *	set up an empty message. One or more fields can then be added to the
 *	message using this funtion. A semi-colon will automatically be appended
 *	to the field.
 *
 * ARGUMENTS:
 *	newfield - A text string containing the field to be added.
 *
 * RETURNS:
 *	TRUE if field is added, FALSE if there is insufficient room in the
 *	message buffer.
 */
int omsg_add(struct s_hc *hc, BYTE *newfield)
	{
	if (strlen(hc->omsg_bufr) + strlen(newfield) > sizeof(hc->omsg_bufr) - 3)
		return(FALSE);
	strcat(hc->omsg_bufr, newfield);
	strcat(hc->omsg_bufr, ";");
	return(TRUE);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_setnum
 *
 * DESCRIPTION:
 *	Messages are numbered consecutively as they are sent. This function
 *	forces a the messages to start at a new number. Since message numbers
 *	are incremented just before a message is sent, this funtion changes the
 *	effective number of the last message sent. The next message out will have
 *	a number one greater than the number specified in this function.
 *
 * ARGUMENTS:
 *	n -- The new starting number for outgoing messages.
 *
 * RETURNS:
 *	Returns the new message number as a convenience.
 */
int omsg_setnum(struct s_hc *hc, int n)
	{
	return(hc->omsgn = n);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_send
 *
 * DESCRIPTION:
 *	Completes a message and transmits it. The size and check fields of the
 *	current message are computed and the message is transmitted according to
 *	instructions. The message number is automatically incremented just before
 *	transmission.
 *
 * ARGUMENTS:
 *	burstcnt  -- Number of identical copies of the message to send
 *	usecrc	  -- If TRUE, the CRC calculation is used to calculate the
 *					check bytes. If FALSE, a simple sum is used.
 *	backspace -- If TRUE, each character out is followed by a backspace to
 *					keep the messages from showing up on the remote computer
 *					screen if they haven't started their transfer yet.
 *
 * RETURNS:
 *	The number assigned to the message as it was transmitted.
 */
int omsg_send(struct s_hc *hc, int burstcnt, int usecrc, int backspace)
	{
	HCOM hCom;
	register unsigned checksum;
	unsigned hold_crc = hc->h_crc;	/* hold onto data crc & restore at end */
	int t;
	size_t sl;
	register size_t i;

	hCom = sessQueryComHdl(hc->hSession);

	hc->omsgn = (hc->omsgn + 1) % (hc->omsg_printable ? 94 : 256);
	sl = strlen(hc->omsg_bufr);

	/* len includes check bytes */
	hc->omsg_bufr[1] = (hc->omsg_printable ? tochar(sl) : (BYTE)sl);

	hc->omsg_bufr[2] = (hc->omsg_printable ?
			tochar(hc->omsgn) : (BYTE)hc->omsgn);
	hc->h_crc = checksum = 0;
	for (i = 0; i < sl; ++i)
		{
		checksum += hc->omsg_bufr[i];
		if (usecrc)
			h_crc_calc(hc, hc->omsg_bufr[i]);
		}
	if (hc->omsg_printable)
		{
		hc->omsg_bufr[sl] = (BYTE)tochar(checksum & 0x3F);
		hc->omsg_bufr[sl + 1] = (BYTE)tochar((checksum >> 6) & 0x3F);
		}
	else
		{
		hc->omsg_bufr[sl] = (BYTE)((usecrc ? hc->h_crc : checksum) % 256);
		hc->omsg_bufr[sl + 1] = (BYTE)((usecrc ? hc->h_crc : checksum) / 256);
		}

	for (t = 0; t < burstcnt; ++t)
		{
		if (hc->omsg_embed)
			{
			hs_xmit_(hc, H_MSGCHAR);
			if (backspace)
				hs_xmit_(hc, '\b');
			for(i = 0; i < sl + 2; ++i)
				{
				if (hc->omsg_bufr[i] == H_MSGCHAR)
					{
					hs_xmit_(hc, hc->omsg_bufr[i]);
					if (backspace)
						hs_xmit_(hc, '\b');
					}
				hs_xmit_(hc, hc->omsg_bufr[i]);
				if (backspace)
					hs_xmit_(hc, '\b');
				}
			}
		else
			{
			ComSendChar(hCom, H_MSGCHAR);

			if (backspace)
				ComSendChar(hCom, '\b');

			for(i = 0; i < sl + 2; ++i)
				{
				if (hc->omsg_bufr[i] == H_MSGCHAR)
					{
					ComSendChar(hCom, hc->omsg_bufr[i]);

					if (backspace)
						ComSendChar(hCom, '\b');
					}
				ComSendChar(hCom, hc->omsg_bufr[i]);

				if (backspace)
					ComSendChar(hCom, '\b');
				}
			}
		}


	if (hc->omsg_embed)
		{
		if (backspace)
			{
			hs_xmit_(hc, ' ');
			hs_xmit_(hc, '\b');
			}
		}
	else
		{
		if (backspace)
			{
			ComSendChar(hCom, ' ');
			ComSendChar(hCom, '\b');
			}
		ComSendWait(hCom);
		}

	hc->last_omsg = startinterval();
	hc->omsg_bufr[sl] = '\0';
	hc->h_crc = hold_crc;
	return(hc->omsgn);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_last
 *
 * DESCRIPTION:
 *	Returns the time that the last message was sent in a form suitable to
 *	use with interval(). Passing the returned value to interval() will give
 *	the time in tenths of a second since the last message was sent.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
long omsg_last(struct s_hc *hc)
	{
	return(hc->last_omsg);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * omsg_number
 *
 * DESCRIPTION:
 *	Returns the message number of the last message sent. The value will be
 *	-1 if no messages have been sent.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	The number of the last message.
 */
int omsg_number(struct s_hc *hc)
	{
	return(hc->omsgn);
	}


#if FALSE	/* this is a 'C' version of the code in hpr_calc.asm */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * h_crc_calc
 *
 * DESCRIPTION:
 *	Does byte-by-byte CRC calcuation for HyperProtocol
 *
 * ARGUMENTS:
 *	cc -- Next character to include in CRC calculation. The global value
 *			h_crc is modified to include the effects of cc
 *
 * RETURNS:
 *	nothing
 */
void NEAR h_crc_calc(uchar cc)
	{
	register unsigned q;

	q = (h_crc ^ cc) & 0x0F;
	h_crc = (h_crc >> 4) ^ (q * 0x1081);
	q = (h_crc ^ (cc >> 4)) & 0x0F;
	h_crc = (h_crc >> 4) ^ (q * 0x1081);
	}

#endif

/********************* end of hpr.c ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_sd.hh ===
/* File: C:\WACKER\xfer\hpr_sd.hh (Created: 24-Jan-1994)
 * created from HAWIN source file:
 * hpr_sd.hh  --  Header file containing system dependent declarations for
 *					Hyperprotocol
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

/* progress display codes */
#define FILE_DONE		1
#define TRANSFER_DONE	2


/* for HyperACCESS, convert references to file routines to bfile routines */
// #define FILETYPE  BFILE
// #define FileClose nb_close
// #define FileError nb_error
// #define FileSeek  nb_seek
// #define FilePutc  nb_putc
// #define FileGetc  nb_getc
// #define RemoteQueryBitRate() cnfg.bit_rate

// #define RemoteSendChar(c)	ComSendChar(c)
// #define RemoteSendDone() 	ComSendWait()

extern int hr_setup(struct s_hc *hc);
extern int hr_wrapup(struct s_hc *hc, int attended, int status);
extern void hpr_id_get(struct s_hc *hc, BYTE *dst);
extern int hpr_id_check(struct s_hc *hc, int rev, BYTE *name);


/* These routines are used to display the ongoing status of a transfer.
 * They may be implemented as macros or functions as needed. If no
 * display of a particular item is desired, a macro can be defined to
 * disable it.
 *	i.e.  #define hrdsp_errorcnt(cnt)
 */

/* During receiving:
 *
 *	hrdsp_filecnt(cnt)		  if sender transmits number of files coming
 *	hrdsp_totalsize(bytes)	  if sender transmits total bytes being sent
 *	hrdsp_newfile(theirname, ourname, filen)  upon start of new file
 *	hrdsp_filesize(size)	  if size of current file is transmitted
 *	hrdsp_progress(filebytes) at intervals during transfer
 *	hrdsp_errorcnt(cnt) 	  whenever an error is encountered
 *	hrdsp_event(event_code)   when significant events occur
 *	hrdsp_status(status_code) when status of transfer changes
 */

extern void hrdsp_compress(struct s_hc *hc, int cnt);
extern void hrdsp_errorcnt(struct s_hc *hc, int cnt);
extern void hrdsp_filecnt(struct s_hc *hc, int cnt);
extern void hrdsp_totalsize(struct s_hc *hc, long bytes);
extern void hrdsp_progress(struct s_hc *hc, int status);
extern void hrdsp_status(struct s_hc *hc, int status);
extern void hrdsp_event(struct s_hc *hc, int event);

extern void hrdsp_newfile(struct s_hc *hc,
							int filen,
							char FAR *theirname,
							char FAR *ourname);

extern void hrdsp_filesize(struct s_hc *hc, long fsize);


// extern void hpr_idle(struct s_hc *hc);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *								 SENDING								 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

extern void hsdsp_compress(struct s_hc *hc, int tf);
extern void hsdsp_retries(struct s_hc *hc, int t);
extern void hsdsp_status(struct s_hc *hc, int s);
extern void hsdsp_event(struct s_hc *hc, int e);


extern int hs_setup(struct s_hc *hc, int nfiles, long nbytes);
extern void hs_wrapup(struct s_hc *hc, int attended, int bailout_status);
extern void hs_fxmit(struct s_hc *, BYTE);
extern BYTE hs_xmit_switch(struct s_hc *, BYTE);
extern void hs_xbswitch(struct s_hc *);
extern void hs_xbclear(struct s_hc *);

extern void  hsdsp_progress(struct s_hc *hc, int status);
extern void  hsdsp_newfile(struct s_hc *hc,
							int filen,
							TCHAR *fname,
							long flength);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_snd0.c ===
/* File: C:\WACKER\xfer\hpr_snd0.c (Created: 25-Jan-1994)
 * created from HAWIN source file
 * hpr_snd0.c -- Routines to provide HyperProtocol file send function in
 *			  HyperACCESS.
 *
 *	Copyright 1988,89,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 1/11/02 1:45p $
 */

#include <windows.h>
#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hpr_snd
 *
 * DESCRIPTION:
 *	Handles file sending using the Hyperprotocol transfer method.
 *
 * ARGUMENTS:
 *	attended --  True if the program determines that a user is likely to be
 *				 present at the computer keyboard. FALSE if a user is NOT likely
 *				 to be present (such as host and script modes).
 *	hs_nfiles -- The number of files scheduled to be sent. (Other concurrent
 *				 processes may remove files before we get to them so we may
 *				 not actually send this many files.)
 *	hs_nbytes -- The total size of all files scheduled to be sent. (See note
 *				 in description of hs_nfiles.)
 *
 * RETURNS:
 *	TRUE if the transfer successfully completes. FALSE otherwise.
 */
int hpr_snd(HSESSION hSession, int attended, int hs_nfiles, long hs_nbytes)
	{
	struct s_hc *hc;
	HCOM			  hCom;
	int 			  bailout;
	long			  timer;
	register int cc;

	hCom = sessQueryComHdl(hSession);

	hc = malloc(sizeof(struct s_hc));
	if (hc == NULL)
		return TSC_NO_MEM;

	memset(hc, 0, sizeof(struct s_hc));

	hc->hSession = hSession;

	/* initialize stuff */
	if (!hs_setup(hc, hs_nfiles, hs_nbytes))
		{
		free(hc);
		return TSC_NO_MEM;
		}

	/* force a file break on the next char. fetch */
	hc->sc.hs_ptrgetc = hs_reteof;

	/* initialize variables etc. */
	hc->h_filebytes = 0L;
	// hc->blocksize = 2048;
	// hc->blocksize = xfer_blocksize(hSession);
	hc->blocksize = max(hc->blocksize, H_MINBLOCK);
	hc->current_filen = 0;
	hc->deadmantime = 600;

	hc->total_tries = 0;
	hsdsp_retries(hc, hc->total_tries);

	hc->total_dsp = 0L;
	hc->total_thru = 0L;
	hc->ucancel = FALSE;
	hc->usecrc = TRUE;			/* to start out */
	hc->fhdl = NULL;

	hc->sc.nfiles = hs_nfiles;
	hc->sc.nbytes = hs_nbytes;
	hc->sc.bytes_sent = hc->h_filebytes;
	hc->sc.rmtcancel = FALSE;
	hc->sc.last_response = (long)startinterval();
	hc->sc.lastmsgn = -1;
	hc->sc.rmt_compress = FALSE;		/* until we hear otherwise */
	hc->sc.rmtchkt = H_CRC;			/* until we hear otherwise */
	hc->sc.started = FALSE;
	hc->sc.lasterr_filenum = -1;
	hc->sc.lasterr_offset = -1L;
	hc->sc.sameplace = 0;

	/* setup file table */
	hc->sc.ft_current = 0;
	hc->sc.ft_top = hc->sc.ft_open = 0;

	hc->sc.hs_ftbl[0].filen = 0;
	hc->sc.hs_ftbl[0].cntrl = 0;
	hc->sc.hs_ftbl[0].status = TSC_OK;
	hc->sc.hs_ftbl[0].flength = 0L;
	hc->sc.hs_ftbl[0].thru_bytes = 0L;
	hc->sc.hs_ftbl[0].dsp_bytes = 0L;

	hc->sc.hs_ftbl[0].fname[0] = TEXT('\0');
	// strblank(hc->sc.hs_ftbl[0].fname);

	omsg_init(hc, FALSE, TRUE);

	if ((bailout = setjmp(hc->sc.jb_bailout)) == 0)
		{
		/* do normal transfer */

		// RemoteClear();  /* get rid of possible stacked-up starts */
		ComRcvBufrClear(hCom);

		/* restarts and file aborts will branch here */
		if (setjmp(hc->sc.jb_restart) == 0)
			{
			/* first time through, wait for receiver to begin */
			hsdsp_status(hc, HSS_WAITSTART);
			timer = (long)startinterval();
#if defined(NOTIMEOUTS)
			while (TRUE)
#else
			while ((long)interval(timer) < 600L)
#endif
				{
				/* prevent deadman timeout */
				hc->xfertimer = hc->sc.last_response = (long)startinterval();
				hs_background(hc);	/* will exit with longjump to restart */
				if (hc->ucancel)
					 longjmp(hc->sc.jb_bailout, TSC_USER_CANNED);

				xfer_idle(hc->hSession);

				}
			hsdsp_event(hc, HSE_NORESP);
			longjmp(hc->sc.jb_bailout, TSC_NO_RESPONSE);
			}

		/* Restarts jump here via longjmp */
		hsdsp_status(hc, HSS_SENDING);
		hsdsp_progress(hc, 0);
		for (;;)/* this loop is only exited by a longjmp to hc->sc.jb_bailout */
			{	/*	  or hc->sc.jb_restart									*/
			hs_background(hc);
			if (hs_datasend(hc))
				{
				/* sent out full data block */
				cc = omsg_setnum(hc, (omsg_number(hc) + 1) % 256);
				hc->h_checksum += (unsigned)cc;
				if (hc->usecrc)
					h_crc_calc(hc, (BYTE)cc);
				HS_XMIT(hc, (BYTE)cc);
				HS_XMIT(hc, (BYTE)((hc->usecrc?hc->h_crc:hc->h_checksum)%256));
				HS_XMIT(hc, (BYTE)((hc->usecrc?hc->h_crc:hc->h_checksum)/256));
				/* update display */
				hsdsp_progress(hc, 0);
				hc->datacnt = 0;
				hc->h_crc = hc->h_checksum = 0;
				}
			else	/* encountered EOF in data */
				{
				if (hc->h_filebytes > 0)	/* EOF probably got counted */
					--hc->h_filebytes;
				hc->sc.bytes_sent = hc->h_filebytes;
				hsdsp_progress(hc, FILE_DONE);
				hs_filebreak(hc, hs_nfiles, hs_nbytes);
				}

			xfer_idle(hc->hSession);

			}
		}
	else	/* a longjmp(hc->sc.jb_bailout, reason) was called */
		{
		if (bailout == TSC_COMPLETE)
			{
			bailout = TSC_OK;
			}
		else
			{
			hc->xfertime = (long)interval(hc->xfertimer);
			if (hc->fhdl)
				{
				hc->sc.hs_ftbl[hc->sc.ft_current].status = (int)bailout;
				fio_close(hc->fhdl);
				hc->fhdl = NULL;
				}
			}
		hsdsp_status(hc, bailout == TSC_OK ? HSS_COMPLETE : HSS_CANCELLED);
		}

	/* cleanup and exit */;
	/* make sure final vu meter is displayed full */
	hc->total_dsp += hc->sc.hs_ftbl[hc->sc.ft_current].flength;
	hc->total_thru += hc->h_filebytes;
	hc->h_filebytes = hc->sc.bytes_sent = 0L;
	hsdsp_progress(hc, TRANSFER_DONE);

	hs_logx(hc, TRUE);
	hs_wrapup(hc, attended, bailout);
	free(hc);
	compress_disable();

	return((USHORT)bailout);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_dorestart
 *
 * DESCRIPTION:
 *	Called when an interrupt message from the receiver requests that
 *	transmission be restarted from a particular location. (The entire
 *	transfer is started by an initial request from the receiver to restart
 *	at file 0, offset 0.
 *	This routine responds to a restart request by interrupting any current
 *	data being sent and sending a special restart message. It then sets up
 *	to resume transmission at a new location
 *
 * ARGUMENTS:
 *	filenum -- The file number of the file to restart.
 *	offset	-- The offset into the file specified by filenum.
 *	msgnum	-- The message number of the restart request. This number is
 *				included in the restart message sent back so the receiver
 *				will know which restart request it corresponds to.
 *	abort	-- True if the restart is the result of a request by the
 *				receiving program to abort transfer of the current file.
 *
 * RETURNS:
 *	nothing (This function always exits via a longjmp to the restart location
 *				or to the bailout location)
 */
void hs_dorestart(struct s_hc *hc, int filenum, long offset, int msgnum, int abort)
	{
	char str[20];
	register struct s_ftbl FAR *ft;
	int cnt;
	long fsize;

	HS_XMIT_CLEAR(hc);	/* clear any pending data waiting for transmission */
	omsg_setnum(hc, -1);/* restart numbering */
	omsg_new(hc, 'R');	/* start a special 'R'estart message */
#if FALSE
	hc->usecrc = (h_chkt == H_CRC || hc->sc.rmtchkt == H_CRC);
#endif

	hc->usecrc = ((hc->h_chkt == H_CRC) || (hc->sc.rmtchkt == H_CRC));

	wsprintf(str, "R%c;T%d", tochar(msgnum), hc->usecrc ? H_CRC : H_CHECKSUM);
	omsg_add(hc, str);

	/* if we're backing up to an earlier point, tell receiver what blocksize
	 *	to use and verify the file number and offset
	 */
	if (!abort && filenum > 0)
		{
		/* since the transfer is not error-free, retreat to min. blocksize */
		hc->blocksize = H_MINBLOCK;
		// StrFmt(str, "B%d;f%d;o%lu", hc->blocksize, filenum, offset);
		wsprintf(str, "B%d;f%d;o%lu", hc->blocksize, filenum, offset);
		omsg_add(hc, str);
		}
	omsg_send(hc, 1, TRUE, FALSE);

	/* find the requested file in the file table */
	while(hc->sc.ft_current >= 0)
		{
		if (hc->sc.hs_ftbl[hc->sc.ft_current].filen == filenum)
			break;
		--hc->sc.ft_current;
		}

	/* if we couldn't find the requested file in the file table it's
		Trouble with a capital 'T' */
	if (hc->sc.ft_current < 0)
		{
		hsdsp_event(hc, HSE_ILLEGAL);
		longjmp(hc->sc.jb_bailout, TSC_BAD_FORMAT);
		}

	ft = &hc->sc.hs_ftbl[hc->sc.ft_current]; /* set local ptr. into table for speed */
	hc->current_filen = filenum;

	/* Check that we're not stuck on an unresolvable problem. Twenty-five
	 *	consecutive requests to restart at the same place means the transfer
	 *	isn't ever likely to succeed. Probably caused by something like
	 *	an intermediate device stripping characters out.
	 */
	if (hc->sc.lasterr_offset == offset && hc->sc.lasterr_filenum == filenum)
		{
		if (++hc->sc.sameplace >= 25)
			{
			ft->status = TSC_ERROR_LIMIT;
			hsdsp_event(hc, HSE_ERRLIMIT);
			longjmp(hc->sc.jb_bailout, TSC_ERROR_LIMIT);
			}
		}
	else
		{
		hc->sc.lasterr_offset = offset;
		hc->sc.lasterr_filenum = filenum;
		hc->sc.sameplace = 0;
		}

	if (abort && ft->status == TSC_OK) /* aborting current file ? */
		ft->status = TSC_RMT_CANNED;

	if (hc->ucancel || hc->sc.rmtcancel)	/* received restart while trying
											to cancel */
		for (cnt = hc->sc.ft_current; cnt <= hc->sc.ft_top; ++cnt)
			{
			hc->sc.hs_ftbl[cnt].status =
					(int)(hc->ucancel ? TSC_USER_CANNED : TSC_RMT_CANNED);
			}

	/* if this isn't a simple backup operation, force the next character
	 *	read to return an EOF which will, in turn, force hs_filebreak to
	 *	be called to handle these more difficult situations
	 */
	if (filenum == 0 || ft->status != TSC_OK)
		hc->sc.hs_ptrgetc = hs_reteof;
	else
		{
		/* reopen file if necessary */
		hc->h_filebytes = hc->sc.bytes_sent = offset;
		hc->total_dsp = ft->dsp_bytes;
		hc->total_thru = ft->thru_bytes;
		if (hc->sc.ft_current != hc->sc.ft_open)
			{
			if (hc->fhdl)
				fio_close(hc->fhdl);
			hc->fhdl = NULL;
			hc->sc.ft_open = hc->sc.ft_current;
			if (xfer_opensendfile(hc->hSession, &hc->fhdl, ft->fname, &fsize,
					NULL, NULL) != 0)
				{
				ft->status = TSC_CANT_OPEN;
				hc->sc.ft_open = -1;
				}
			hsdsp_newfile(hc, filenum, ft->fname, fsize);
			}
		if (ft->status == TSC_OK)
			{
			if (fio_seek(hc->fhdl, offset, FIO_SEEK_SET) == EOF)
				ft->status = TSC_DISK_ERROR;
			else
				{
				hc->sc.hs_ptrgetc = hs_getc;

				/* restart compression if necessary */
				if (bittest(ft->cntrl, FTC_COMPRESSED))
					{
					compress_start(&hc->sc.hs_ptrgetc,
									hc,
									&hc->h_filebytes,
									FALSE);
					hsdsp_compress(hc, ON);
					hsdsp_status(hc, HSS_SENDING);
					}
				else
					hsdsp_compress(hc, OFF);
				}
			}
		}
	hc->datacnt = 0;
	hc->h_checksum = hc->h_crc = 0;
	longjmp(hc->sc.jb_restart, 1);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_background
 *
 * DESCRIPTION:
 *	Called by the main transfer loops to handle asynchronous background tasks.
 *	Specifically, the serial port is scanned for incoming messages from the
 *	receiver. This routine also detects when the receiver has been silent too
 *	long (and thus may be dead).
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void hs_background(struct s_hc *hc)
	{

	hs_rcvmsg(hc);

	if (xfer_user_interrupt(hc->hSession))
		{
		hsdsp_event(hc, HSE_USRCANCEL);
		if (hc->ucancel)		/* this is the second time */
			longjmp(hc->sc.jb_bailout, TSC_USER_CANNED);
		else
			{
			hc->ucancel = TRUE;
			/* TODO: fix this somehow */
			/* errorline(FALSE, strld(TM_WAIT_CONF)); */
			hc->sc.hs_ptrgetc = hs_reteof; /* force sending to break */
			}
		}

	if (xfer_carrier_lost(hc->hSession))
		longjmp(hc->sc.jb_bailout, TSC_LOST_CARRIER);

#if !defined(NOTIMEOUTS)
	if ((long)interval(hc->sc.last_response) > (hc->deadmantime * 2L + 100L))
		{
		hsdsp_event(hc, HSE_NORESP);
		longjmp(hc->sc.jb_bailout, TSC_NO_RESPONSE);
		}
#endif

	xfer_idle(hc->hSession);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_rcvmsg
 *
 * DESCRIPTION:
 *	Called by hs_background to collect messages from the receiver piecemeal
 *	and call hs_decode_rmsg when a complete message is assembled.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
#define IDLE			-1
#define AWAITING_TYPE	-2
#define AWAITING_LEN	-3

void hs_rcvmsg(struct s_hc *hc)
	{
	HCOM hCom;
	TCHAR cc;
	unsigned rm_checksum;
	BYTE *sp;

	hCom = sessQueryComHdl(hc->hSession);

	// while ((cc = RemoteGet()) != -1)
	while (mComRcvChar(hCom, &cc) != 0)
		{
		if ((*hc->dptr = (BYTE)cc) == H_MSGCHAR)
			{
			/* start receiving new message, even if last one hadn't finished */
			hc->rmcnt = AWAITING_TYPE + 1;
			hc->dptr = hc->msgdata;
			}
		// TODO: figure the correct way for this - else if (!isprint(*hc->dptr))
		else if ((*hc->dptr < 0x20) || (*hc->dptr > 0x7E))
			/* ignore other non-printing characters */;
		else
			{
			switch(--hc->rmcnt)
				{
			case IDLE:
				++hc->rmcnt;	/* so we'll still be idle next time */
				break;
			case AWAITING_TYPE:
				++hc->dptr; 	/* keep type char. */
				hc->rmcnt = AWAITING_LEN + 1;
				break;
			case AWAITING_LEN:
				if ((hc->rmcnt = unchar(*hc->dptr)) < 3 || hc->rmcnt > 94)
					{
					hc->rmcnt = IDLE + 1;
					hc->dptr = hc->msgdata;
					}
				else
					++hc->dptr;
				break;
			default:
				++hc->dptr; 	/* just keep the char. */
				break;
			case 0: 		/* just received final char. of message */
				hc->rmcnt = IDLE + 1;	/* start over with next char. */
				/* verify the checksum */
				--hc->dptr; 			/* point to first char of checksum */
				rm_checksum = 0;
				for (sp = hc->msgdata; sp < hc->dptr; ++sp)
					rm_checksum += *sp;
				/* sp now points to first check char */
				hc->dptr = hc->msgdata;
				if (*sp == tochar(rm_checksum & 0x3F) &&
						*(sp + 1) == tochar((rm_checksum >> 6) & 0x3F))
					{
					/* received valid message */
					hc->sc.last_response = (long)startinterval();
					if (unchar(hc->msgdata[2]) != (BYTE)hc->sc.lastmsgn)
						{
						/* new message */
						*sp = '\0';
						hc->sc.lastmsgn = unchar(hc->msgdata[2]);
						hs_decode_rmsg(hc, hc->msgdata);
						}
					}
				break;
				}
			}

		xfer_idle(hc->hSession);

		}

	xfer_idle(hc->hSession);

	}

/************************* end of hpr_snd0.c ****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_sd.c ===
/* File: C:\WACKER\xfer\hpr_sd.c (Created: 25-Jan-1994)
 * created from HAWIN source file
 * hpr_sd.c -- System dependent routines to support HyperProtocol
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
// #define DEBUGSTR


#include <windows.h>
#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"

// struct s_hprsd FAR *hsd;

/* RECEIVING */

#define DRR_RCV_FILE 1
#define DRR_STORING  2

// int suspend_for_disk = 0;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_setup
 *
 * DESCRIPTION:
 *	Called as a HyperProtocol receive session is beginning. This routine
 *	must allocate memory for control structures hc and hrc. It may also
 *	initiate a screen display to use during the transfer and do any other
 *	necessary setup.
 *	Values for the user-settable globals, h_useattr, h_trycompress, h_chkt
 *	and h_suspenddsk, should also be set here if they have not already been
 *	set through the use of program options or menu settings.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	TRUE if transfer can continue.
 *	FALSE if a memory allocation or other type of error occurred.
 */
int hr_setup(struct s_hc *hc)
	{
	unsigned int uiOldOptions;
	XFR_PARAMS *pX;
	XFR_HP_PARAMS *pH;

	pX = (XFR_PARAMS *)0;
	xfrQueryParameters(hc->hSession, (VOID **)&pX);
	if (pX != (XFR_PARAMS *)0)
		hc->h_useattr = pX->fUseDateTime;

	pH = (XFR_HP_PARAMS *)xfer_get_params(hc->hSession, XF_HYPERP);

	hc->blocksize     = pH->nBlockSize;
	hc->h_chkt        = (pH->nCheckType == HP_CT_CRC) ? H_CRC : H_CHECKSUM;
	hc->h_resynctime  = pH->nResyncTimeout;
	hc->h_trycompress = pH->nTryCompression;

	if (xfer_set_comport(hc->hSession, FALSE, &uiOldOptions) != TRUE)
		{
		/* TODO: put in an error message of some sort */
		return FALSE;
		}

	hc->sd.hld_options = uiOldOptions;

	hrdsp_compress(hc, compress_status() == COMPRESS_ACTIVE);

	hc->sd.k_received = 0;

	return TRUE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_wrapup
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int hr_wrapup(struct s_hc *hc, int attended, int status)
	{

 	xfer_restore_comport(hc->hSession, hc->sd.hld_options);
	/* TODO: decide if anything can be done if we get an error */

	if (hc->fhdl || status == H_FILEERR)   /* abnormal exit */
		{
		xfer_log_xfer(hc->hSession, FALSE,
					hc->rc.rmtfname, NULL,
					hr_result_codes[hc->rc.cancel_reason]);

		fio_close(hc->fhdl);
		hc->fhdl = NULL;
		DeleteFile(hc->rc.ourfname);
		}
	if (hc->fhdl)
		{
		fio_close(hc->fhdl);
		hc->fhdl = NULL;
		}
	if (attended)
		{
#if FALSE
		menu_bottom_line(BL_ESC, 0L);
#if defined(OS2)
		if (os2_cfg_popup)
			popup_replybox(-1, ENTER_RESP, T_POPUP_WAIT, TM_POPUP_COMPLETE);
#endif
		DosBeep(beepfreq, beeplen);
		menu_replybox(hc->sd.msgrow, ENTER_RESP, 0,
				(int)transfer_status_msg((USHORT)hr_result_codes[hc->rc.cancel_reason]));
#endif
		}

	xferMsgClose(hc->hSession);

	return status;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_progress
 *
 * DESCRIPTION:
 *	Displays the progress of a filetransfer on screen by showing the number of
 *	bytes transferred and updating the vu meters if they have been initialized.
 *
 * ARGUMENTS:
 *	final -- If TRUE, indicates that the transfer is finished and the final
 *			 progress display is needed. Durning a transfer the number of
 *			 bytes is rounded off to the next lower 'k'. After a transfer
 *			 is completed, the final display is rounded UP.
 *
 * RETURNS:
 *
 */
void hrdsp_progress(struct s_hc *hc, int status)
	{
	long ttime, stime;
	long bytes_rcvd;
	long cps;

	long new_elapsed = -1;
	long new_remaining = -1;
	long new_cps = -1;
	long new_file = -1;
	long new_total = -1;

	if (hc->xfertimer == -1L)
		return;
	ttime = bittest(status, TRANSFER_DONE) ?
			hc->xfertime : interval(hc->xfertimer);

	if ((stime = ttime / 10L) != hc->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		/* Display elapsed time */
		new_elapsed = (hc->displayed_time = stime);

		/* Display amount received */
		bytes_rcvd = hc->total_dsp + hc->h_filebytes;

		/* if an error occurs at the end of an interrupt data block, it
		 *	can temporarily appear that we've received more data than is
		 *	actually available -- make sure we don't show more received than
		 *	is coming.
		 */
		if (hc->rc.bytes_expected > 0L && bytes_rcvd > hc->rc.bytes_expected)
			bytes_rcvd = hc->rc.bytes_expected;

		new_file = hc->h_filebytes;
		new_total = bytes_rcvd;

		/* Display current compression status */
		if (!bittest(status, FILE_DONE | TRANSFER_DONE))
			hrdsp_compress(hc, compress_status() == COMPRESS_ACTIVE);

		/* Display throughput and time remaining */
		if (stime > 0 &&
				(cps = ((hc->total_thru + hc->h_filebytes) * 10L) / ttime) > 0)
			{
			new_cps = cps;

			/* calculate time to completion */
			if (hc->rc.bytes_expected > 0L)
				{
				ttime = (hc->rc.bytes_expected - bytes_rcvd) / cps;
				if (hc->rc.files_expected > 1)
					ttime += (hc->rc.files_expected - hc->current_filen);
				new_remaining = ttime;
				}
			else if (hc->rc.filesize > 0L)
				{
				ttime = (hc->rc.filesize - hc->h_filebytes) / cps;
				new_remaining = ttime;
				}
			}
		}

	DbgOutStr("elapsed=%ld, remaining=%ld, cps=%ld\r\n",
			new_elapsed, new_remaining, new_cps, 0, 0);

	xferMsgProgress(hc->hSession,
					new_elapsed,
					new_remaining,
					new_cps,
					new_file,
					new_total);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_status
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hrdsp_status(struct s_hc *hc, int status)
	{

	xferMsgStatus(hc->hSession, status);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_event
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hrdsp_event(struct s_hc *hc, int event)
	{

	xferMsgEvent(hc->hSession, event);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_filecnt
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hrdsp_filecnt(struct s_hc *hc, int cnt)
	{

	xferMsgFilecnt(hc->hSession, cnt);
	}

void hrdsp_errorcnt(struct s_hc *hc, int cnt)
	{

	xferMsgErrorcnt(hc->hSession, cnt);
	}

void hrdsp_compress(struct s_hc *hc, int cnt)
	{

	xferMsgCompression(hc->hSession, cnt);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_totalsize
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hrdsp_totalsize(struct s_hc *hc, long bytes)
	{

	xferMsgTotalsize(hc->hSession, bytes);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_newfile
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hrdsp_newfile(struct s_hc *hc,
					int filen,
					BYTE *theirname,
					TCHAR *ourname)
	{

	xferMsgNewfile(hc->hSession, filen, theirname, ourname);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hrdsp_filesize
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hrdsp_filesize(struct s_hc *hc, long fsize)
	{

	xferMsgFilesize(hc->hSession, fsize);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
#if FALSE
void NEARF hpr_idle(HSESSION hS)
	{
	/* update elapsed time */
	// task_exec();

	DoYield(mGetCLoopHdl(hS));

	}
#endif

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *								 SENDING								 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_setup
 *
 * DESCRIPTION:
 *	Handles transfer initialization and intial screen display.
 *
 * ARGUMENTS:
 *	nfiles -- The number of files that will be sent
 *	nbytes -- The total number of bytes to be sent.
 *
 * RETURNS:
 *	TRUE if no errors were encountered and its ok for transfer to proceed.
 *	FALSE if lack of memory prevents start of transfer.
 */
int hs_setup(struct s_hc *hc, int nfiles, long nbytes)
	{
	unsigned int uiOldOptions;
	int enough_memory = TRUE;
	XFR_PARAMS *pX;
	XFR_HP_PARAMS *pH;

	pX = (XFR_PARAMS *)0;
	xfrQueryParameters(hc->hSession, (VOID **)&pX);
	if (pX != (XFR_PARAMS *)0)
		hc->h_useattr = pX->fUseDateTime;

	pH = (XFR_HP_PARAMS *)xfer_get_params(hc->hSession, XF_HYPERP);

	hc->blocksize     = pH->nBlockSize;
	hc->h_chkt        = (pH->nCheckType == HP_CT_CRC) ? H_CRC : H_CHECKSUM;
	hc->h_resynctime  = pH->nResyncTimeout;
	hc->h_trycompress = pH->nTryCompression;

	hc->dptr = hc->msgdata;
	hc->rmcnt = 0;

	if (xfer_set_comport(hc->hSession, TRUE, &uiOldOptions) != TRUE)
		{
		/* TODO: decide of we need an error message or something */
		return FALSE;
		}

	hc->hsxb.bufrsize = HSXB_SIZE;
	hc->hsxb.cnt = HSXB_CYCLE;
	hc->hsxb.total = hc->hsxb.bufrsize - hc->hsxb.cnt;
	hc->hsxb.bptr = hc->hsxb.curbufr;

	hc->hsxb.curbufr = NULL;
	hc->hsxb.altbufr = NULL;

	if (enough_memory)
		hc->hsxb.curbufr = malloc(hc->hsxb.bufrsize);
	if (hc->hsxb.curbufr == NULL)
		enough_memory = FALSE;

	if (enough_memory)
		hc->hsxb.altbufr = malloc(hc->hsxb.bufrsize);
	if (hc->hsxb.altbufr == NULL)
		enough_memory = FALSE;

	/* allocate as much memory as is available for the file table */
	if (enough_memory)
		{
		hc->sc.ft_limit = 32; 			/* just for now */

		hc->sc.hs_ftbl = malloc((size_t)(hc->sc.ft_limit + 1) * sizeof(struct s_ftbl));
		if (hc->sc.hs_ftbl == NULL)
			enough_memory = FALSE;
		}

	/* if we couldn't get enough memory, report it and leave */
	if (!enough_memory)
		{
		if (hc->hsxb.curbufr != NULL)
			free(hc->hsxb.curbufr);
		if (hc->hsxb.altbufr != NULL)
			free(hc->hsxb.altbufr);
		if (hc->sc.hs_ftbl != NULL)
			free(hc->sc.hs_ftbl);

		/* TODO: add reperror call, or something like it */
		assert(enough_memory);

		return(FALSE);
		}

	hc->sd.hld_options = uiOldOptions;

	hsdsp_compress(hc, compress_status() == COMPRESS_ACTIVE);

	xferMsgFilecnt(hc->hSession, nfiles);

	xferMsgTotalsize(hc->hSession, nbytes);

	return TRUE;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_wrapup
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hs_wrapup(struct s_hc *hc, int attended, int bailout_status)
	{
	// bxmit_clear();	/* make sure no dregs are left in xmitter buffer */
	ComSndBufrClear(sessQueryComHdl(hc->hSession));

	xfer_restore_comport(hc->hSession, hc->sd.hld_options);
	/* TODO: decide if it is useful to actually check for an error */

	if (bailout_status == TSC_OK)
		{
		// hp_report_xtime((unsigned)hc->xfertime);
		}


	/* free all the memory we used */

	xferMsgClose(hc->hSession);

	free(hc->hsxb.curbufr);
	free(hc->hsxb.altbufr);
	free(hc->sc.hs_ftbl);
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_fxmit
 *
 * DESCRIPTION:
 *	Sends a single character using HyperProtocol's dual buffering system.
 *	This functions does exactly what the macro hs_xmit_ does, but is in
 *	function form so it can be passed as a pointer.
 *
 * ARGUMENTS:
 *	c -- The character to be transmitted.
 *
 * RETURNS:
 *	nothing
 */
void hs_fxmit(struct s_hc *hc, BYTE c)
	{
	hs_xmit_(hc, c);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_xmit_switch
 *
 * DESCRIPTION:
 *	Sends a character using HyperProtocol's dual buffering system and checks
 *	whether it is time to switch buffers. Normally, one buffer will be in the
 *	process of being transmitted while the other is being filled. If the
 *	transmission is completed before the next buffer has been filled, some
 *	idle time could be wasted waiting for the second buffer to fill. This
 *	routine checks whether the transmitter is idle. If it is, it sets up the
 *	current buffer to start transmitting and begins filling the other buffer.
 *	If the transmitter is still busy, it continues on filling the current
 *	buffer.
 *
 * ARGUMENTS:
 *	c -- The character to be transmitted.
 *
 * RETURNS:
 *	Returns the argument as a convenience.
 */
BYTE hs_xmit_switch(struct s_hc *hc, BYTE c)
	{
	*hc->hsxb.bptr++ = c;	/* place the character in the current buffer */

	if (!ComSndBufrBusy(sessQueryComHdl(hc->hSession)) || (hc->hsxb.total == 0))
		{
		/* start xmitting this buffer and filling the other */
		hs_xbswitch(hc);
		}
	else
		{
		/* keep going with same buffer by starting a new fill cycle */
#if defined(FINETUNE)
		hc->hsxb.cnt = min(usr_hsxb_cycle, hc->hsxb.total);
#else
		hc->hsxb.cnt = min(HSXB_CYCLE, hc->hsxb.total);
#endif
		hc->hsxb.total -= hc->hsxb.cnt;
		}

	xfer_idle(hc->hSession);

	return(c);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_xbswitch
 *
 * DESCRIPTION:
 *	Switches the currently filling buffer with the transmitting buffer.
 *	This function performs the actual switch described in the header for the
 *	function hs_xmit_switch(). The current buffer is set up be transmitted
 *	and the other buffer is setup to be filled. If the transmitter is busy
 *	This function will wait for a defined period of time for it to complete.
 *	If the function has to wait longer than a certain minimum time, the
 *	event and status messages will be updated to inform the user of the delay.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void hs_xbswitch(struct s_hc *hc)
	{
	HCOM hCom;
	register int displayed = FALSE;
	long timer;
	long time;
	unsigned bsize;

	hCom = sessQueryComHdl(hc->hSession);

	if (hc->hsxb.bptr > hc->hsxb.curbufr)/* if there is anything to transmit */
		{
		bsize = (unsigned)(hc->hsxb.bptr - hc->hsxb.curbufr);
		if (ComSndBufrSend(hCom, hc->hsxb.curbufr, bsize, 10))
			{
			timer = startinterval();
			while (ComSndBufrSend(hCom, hc->hsxb.curbufr, bsize, 10))
				{
				// hs_background(hSession);
				/* keep elapsed time display accurate */
				if ((time = (interval(hc->xfertimer) / 10L)) != hc->displayed_time)
					xferMsgProgress(hc->hSession,
									(hc->displayed_time = time),
									-1, -1, -1, -1);


				if (!displayed &&  interval(timer) > 40L)
					{
					hsdsp_event(hc, HSE_FULL);
					hsdsp_status(hc, HSS_WAITRESUME);
					displayed = TRUE;
					}
				}
			if (displayed)
				{
				hsdsp_event(hc, HSE_GOTRESUME);
				hsdsp_status(hc, HSS_SENDING);
				}
			}
		/* hc->sc.bytes_sent is used in the throughput and time remaining
		 * calculations. It is always ahead of the number of characters
		 * actually transmitted because of buffering. To keep it from
		 * being too far ahead, we add in only half of the buffer about
		 * to be queued for transmission. Since a buffer-full may span
		 * more than one file, don't let value go negative
		 */
		if ((hc->sc.bytes_sent = hc->h_filebytes - (bsize / 2)) < 0)
			hc->sc.bytes_sent = 0;
		hc->hsxb.bptr = hc->hsxb.altbufr;
		hc->hsxb.altbufr = hc->hsxb.curbufr;
		hc->hsxb.curbufr = hc->hsxb.bptr;
#if defined(FINETUNE)
		hc->hsxb.cnt = usr_hsxb_cycle;
#else
		hc->hsxb.cnt = HSXB_CYCLE;
#endif
		hc->hsxb.total = hc->hsxb.bufrsize - hc->hsxb.cnt;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_xbclear
 *
 * DESCRIPTION:
 *	Clears the dual buffering system used in HyperProtocol. Any buffer being
 *	transitted is cut off and the current fill buffer is emptied.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void hs_xbclear(struct s_hc *hc)
	{
	hc->hsxb.bptr = hc->hsxb.curbufr;
#if defined(FINETUNE)
	hc->hsxb.cnt = usr_hsxb_cycle;
#else
	hc->hsxb.cnt = HSXB_CYCLE;
#endif
	hc->hsxb.total = hc->hsxb.bufrsize - hc->hsxb.cnt;

	// xmit_count = 0;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hsdsp_progress
 *
 * DESCRIPTION:
 *	Updates display fields on screen to indicate the progress of the transfer.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void hsdsp_progress(struct s_hc *hc, int status)
	{
	long new_stime = -1;
	long new_ttime = -1;
	long new_cps = -1;
	long file_so_far = -1;
	long total_so_far = -1;

	long ttime, stime;
	long bytes_sent;
	long cps;
	// int	k_sent;

	if (hc->xfertimer == -1L)
		return;

	ttime = bittest(status, TRANSFER_DONE) ?
			hc->xfertime : interval(hc->xfertimer);
	if ((stime = ttime / 10L) != hc->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		new_stime = stime;

		/* Display amount transferred */
		bytes_sent = hc->total_dsp + hc->sc.bytes_sent;

		if (!bittest(status, TRANSFER_DONE))
			file_so_far = hc->sc.bytes_sent;
		total_so_far = bytes_sent;

		/* Display throughput and time remaining */
		if ((stime > 2 ||
			 ttime > 0 && bittest(status, FILE_DONE | TRANSFER_DONE)) &&
			(cps = ((hc->total_thru + hc->sc.bytes_sent) * 10L) / ttime) > 0)
			{
			new_cps = cps;

			ttime = ((hc->sc.nbytes - bytes_sent) / cps) +
						hc->sc.nfiles - hc->current_filen;
			new_ttime = ttime;
			}
		hc->displayed_time = stime;
		}

	xferMsgProgress(hc->hSession,
					new_stime,
					new_ttime,
					new_cps,
					file_so_far,
					total_so_far);

	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hsdsp_newfile
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hsdsp_newfile(struct s_hc *hc, int filen, TCHAR *fname, long flength)
	{

	xferMsgNewfile(hc->hSession,
				   filen,
				   NULL,
				   fname);

	xferMsgFilesize(hc->hSession, flength);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hsdsp_compress
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */

void hsdsp_compress(struct s_hc *hc, int tf)
	{

	xferMsgCompression(hc->hSession, tf);
	}

 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hsdsp_retries
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */

void hsdsp_retries(struct s_hc *hc, int t)
	{

	xferMsgErrorcnt(hc->hSession, t);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hsdsp_status
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */

void hsdsp_status(struct s_hc *hc, int s)
	{

	xferMsgStatus(hc->hSession, s);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hsdsp_event
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */

void hsdsp_event(struct s_hc *hc, int e)
	{

	xferMsgEvent(hc->hSession, e);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hpr_id_get
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void hpr_id_get(struct s_hc *hc, BYTE *dst)
	{
	wsprintf(dst, "V%u,%s", 100, (BYTE *)"HyperTerm by Hilgraeve, Inc.");
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hpr_id_check
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int hpr_id_check(struct s_hc *hc, int rev, BYTE *name)
	{
	/* no restrictions on who we'll talk to */
	rev = rev;			  /* keep compiler and lint from complaining */
	name = name;

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\itime.h ===
/* itime.h -- functions to handle time in our program
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

extern void itimeSetFileTime(LPCTSTR pszName, unsigned long ulTime);

extern unsigned long itimeGetFileTime(LPCTSTR pszName);

extern unsigned long itimeGetBasetime(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_res.c ===
/* File: C:\WACKER\xfer\hpr_res.c (Created: 25-Jan-1995)
 * created from HAWIN source file
 * hpr_res.c -- Routines to implement HyperProtocol. These	are the routines
 *			that make character-by-character calls and must be fast
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
// #define	DEBUGSTR	1

#include <windows.h>
#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_collect_data
 *
 * DESCRIPTION:
 *	 Collects and stores bytes for HyperProtocol
 *		save routine.  This routine exits when one of several conditions
 *		is detected and returns a code to indicate which condition caused
 *		it to exit. Exit conditions are decribed below.
 *	In any case, the checksum, crc, and character count variables have
 *	valid values up to the point where collection stopped.
 *
 * ARGUMENTS:
 *	charcount -- number of characters to collect
 *	docheck   -- TRUE if collected data should be subject to error checking
 *	timeout   -- idle time (in tenths of seconds) after which we should give
 *				  up and return HR_TIMEOUT
 *
 * RETURNS:
 *	A status code is returned which may be one of:
 *
 *		HR_COMPLETE -- The predetermined maximum received character count
 *					was reached.
 *		HR_BADCHECK -- All characters were received, but a checksum error
 *					was detected.
 *		HR_MESSAGE	-- The message character, ASCII 01, was detected followed
 *					by a character other than another ASCII 01. The 2nd
 *					character of the sequence is NOT removed from the buffer.
 *		HR_TIMEOUT	-- There was a period of time during which no characters
 *					were received that exceeded the predetermined limit.
 *		HR_KBDINT  -- The user typed an ESC key at the keyboard. This will only
 *					be detected by the hr_collect_data routine if there is a
 *					break in the received data.
 *		HR_FILEERR -- An error occured while storing a byte of the received
 *					data.
 *		HR_LOST_CARR -- Carrier was lost while waiting for data
 *
 */
int hr_collect_data(struct s_hc *hc, int *charcount, int docheck, long timeout)
	{
	HCOM hCom;
	register int ourcount = *charcount;
	int rcvd_msgnum = -1;
	int chkbytes_needed = 2;
	int iret;
	TCHAR cc;
	int got1 = FALSE;
	long timer;
	int result = HR_UNDECIDED;
	unsigned rcvd_checksum = 0;

	hCom = sessQueryComHdl(hc->hSession);

	for ( ; ; )
		{
		if (mComRcvChar(hCom, &cc) == 0)
			{
			timer = startinterval();
			while (mComRcvChar(hCom, &cc) == 0) /* while no chars */
				{
				xfer_idle(hc->hSession);
				iret = xfer_user_interrupt(hc->hSession);
				if (iret == XFER_ABORT)
					{
					result = HR_KBDINT;
					break;
					}
				else if (iret == XFER_SKIP)
					{
					hr_reject_file(hc, HRE_USER_SKIP);
					}

				if (xfer_carrier_lost(hc->hSession))
					{
					result = HR_LOST_CARR;
					break;
					}

#if !defined(NOTIMEOUTS)
				if ((long)interval(timer) > timeout)
					{
					hrdsp_event(hc, HRE_TIMEOUT);
					result = HR_TIMEOUT;
					break;
					}
#endif
				}
			if (result != HR_UNDECIDED)
				break;
			}

		if ((!got1 && cc != H_MSGCHAR) || (got1 && cc == H_MSGCHAR))
			{
			got1 = FALSE;
			if (hc->usecrc)
				h_crc_calc(hc, (BYTE)cc);
			if (ourcount > 0)
				{
				hc->h_checksum += (unsigned)cc;
				if ((*hc->rc.hr_ptr_putc)(hc, cc) ==  -1 /* ERROR */)
					{
					result = decompress_error() ? HR_DCMPERR : HR_FILEERR;
					break;
					}
				else if (--ourcount <= 0 && !docheck)
					{
					result = HR_COMPLETE;
					break;
					}
				}
			else if (rcvd_msgnum == -1)
				{
				rcvd_msgnum = cc;
				hc->h_checksum += (unsigned)cc;
				}
			else
				{
				rcvd_checksum +=
						((unsigned)cc * (chkbytes_needed == 2 ? 1 : 256));
				if (--chkbytes_needed <= 0)
					{
					result = HR_COMPLETE;
					break;
					}
				}
			}
		else if (got1)	/* got1 && cc != H_MSGCHAR */
			{
			result = HR_MESSAGE;	/* leave char. in buffer */
			mComRcvBufrPutback(hCom, cc);
			break;
			}
		else			/* !got1 && cc == H_MSGCHAR */
			got1 = TRUE;
		}
	if (result == HR_COMPLETE && docheck)
		{
		if (hc->usecrc)
			result = (hc->h_crc == 0 ? HR_COMPLETE : HR_BADCHECK);
		else if (hc->h_checksum != rcvd_checksum)
			result = HR_BADCHECK;
		if (result == HR_COMPLETE)
			if (rcvd_msgnum == hc->rc.expected_msg)
				hc->rc.expected_msg = ++hc->rc.expected_msg % 256;
			else
				result = HR_LOSTDATA;
		}
	*charcount = ourcount;

	if (hc->rc.virus_detected)
		result = HR_VIRUS_FOUND;

	return(result);
	}

// extern char FAR *storageptr;	/* place to put data as we receive it */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_storedata
 *
 * DESCRIPTION:
 *	This is a little routine used by hr_collect_msg to collect the data
 *	within a message. Data is normally written directly to the receive file.
 *	This routine, however, collects it into memory.
 *
 * ARGUMENTS:
 *	c -- a character to be stored
 *
 * RETURNS:
 *	Returns the character stored.
 */
int hr_storedata(struct s_hc *hc, int c)
	{
	*hc->storageptr++ = (char)c;
	return(c);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_putc
 *
 * DESCRIPTION:
 *	This is the normal function for dispatching received characters. It
 *	is normally called through a pointer to a function. When decompression
 *	is active, the pointer be redirected to point at the decompression
 *	routine and the decompression code may then be calling this function.
 *	In either case, this function writes one character to the output file
 *	and counts it.
 *
 * ARGUMENTS:
 *	c -- the character to be written
 *
 * RETURNS:
 *	The argument.
 */
int hr_putc(struct s_hc *hc, int c)
	{
	return (fio_putc(c, hc->fhdl));
	// return (FilePutc(c, hc->fhdl));
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_putc_vir
 *
 * DESCRIPTION:
 *	This is the normal function for dispatching received characters. It
 *	is normally called through a pointer to a function. When decompression
 *	is active, the pointer be redirected to point at the decompression
 *	routine and the decompression code may then be calling this function.
 *	In either case, this function writes one character to the output file
 *	and counts it.
 *	This version also performs virus checking. If a virus is detected, the
 *	StrSrchNextChar routine will call hr_virus_detect().
 *
 * ARGUMENTS:
 *	c -- the character to be written
 *
 * RETURNS:
 *	The argument.
 */
int hr_putc_vir(struct s_hc *hc, int c)
	{
	// ++hc->h_filebytes;
	// StrSrchNextChar(hc->rc.ssmchVscan, (VOID FAR *)NULL, (UCHAR)c);
	return (fio_putc(c, hc->fhdl));
	// return (FilePutc(c, hc->fhdl));
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hr_toss
 *
 * DESCRIPTION:
 *	This function is installed in place of hr_putc during periods between when
 *	a data error has been detected and the transfer successfully resynchs so
 *	that bogus data will not be stored in the output file. It merely tosses
 *	the character.
 *
 * ARGUMENTS:
 *	c -- the received character.
 *
 * RETURNS:
 *	the argument
 */
int hr_toss(struct s_hc *hc, int c)
	{
	/* throw character away without counting it */
	return(c);
	}

// Resident routines for sending


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_datasend
 *
 * DESCRIPTION:
 *	Attempts to send enough data to complete the current data block (as
 *	defined by (hc->blocksize).
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	TRUE if all bytes were sent.
 *	FALSE if an EOF is encountered prior to the end of the block.
 */
int hs_datasend(struct s_hc *hc)
	{
	register int cc;
	register int count = hc->blocksize - hc->datacnt;

	for ( ; ; )
		{
		if ((cc = (*hc->sc.hs_ptrgetc)(hc)) == EOF)
			{
			hc->datacnt = hc->blocksize - count;
			return(FALSE);
			}
		hc->h_checksum += (unsigned)cc;
		if (hc->usecrc)
			h_crc_calc(hc, (BYTE)cc);
		HS_XMIT(hc, (BYTE)cc);
		if (--count == 0)
			{
			hc->datacnt = hc->blocksize - count;

			/* Display current compression status */
			hsdsp_compress(hc, compress_status() == COMPRESS_ACTIVE);
			return(TRUE);
			}
		}
	/*lint -unreachable*/
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_reteof
 *
 * DESCRIPTION:
 *	This function merely returns an EOF code. Since all requests for file
 *	characters are made through a pointer to a function, that pointer can
 *	be set to this function to force the next request to return an EOF.
 *	It is normally used to interrupt the transmission of data and force a
 *	call to hs_filebreak to set a new location.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	Always returns EOF
 */
int hs_reteof(struct s_hc *hc)
	{
	return(EOF);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_getc
 *
 * DESCRIPTION:
 *	Fetches one character from the input file and counts it in h_filebytes.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	The character fetched.
 */
int hs_getc(struct s_hc *hc)
	{
	return(fio_getc(hc->fhdl));
	// return(FileGetc(hc->fhdl));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\hpr_snd1.c ===
/* File: C:\WACKER\xfer\hpr_snd1.c (Created: 26-Jan-1994)
 * created from HAWIN source file
 * hpr_snd1.c -- Routines to provide HyperProtocol file send function in
 *			  HyperACCESS.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#include <windows.h>
#include <stdlib.h>
#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "itime.h"
#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "hpr.h"
#include "hpr.hh"
#include "hpr_sd.hh"


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_namecheck
 *
 * DESCRIPTION:
 *	This function is called to check the extension on a filename and to guess
 *	if it should be compressed or not.
 *
 * ARGUEMENTS:
 *	ft -- struct s_ftbl *, contains the name and gets the flag value
 *
 * RETURNS:
 *	Nothing, but may set flags in the structure passed as arguement
 */
void hs_namecheck(struct s_ftbl *ft)
	{
	BYTE *ptr;

	if (strlen(ft->fname) < 5)
		return;

	ptr = ft->fname + strlen(ft->fname) - 4;
	if (*ptr++ != '.')
		return;

	/* the extensions we are currently checking for are:
	 *	ARC
	 *	LZH
	 *	PAK
	 *	ZIP
	 *	ZOO
	 */
#if FALSE
	/* TODO: replace with something else ANSI compatible */
	if ((strnicmp(ptr, "ARC", 3) == 0) ||
		(strnicmp(ptr, "LZH", 3) == 0) ||
		(strnicmp(ptr, "PAK", 3) == 0) ||
		(strnicmp(ptr, "ZIP", 3) == 0) ||
		(strnicmp(ptr, "ZOO", 3) == 0))
			bitset(ft->cntrl, FTC_DONT_CMPRS);
#endif

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_filebreak
 *
 * DESCRIPTION:
 *	Handles changes to the currently open file. This routine is called whenever
 *	the data loading routine gets an EOF while attempting to load the next
 *	data character. This can happen when the program first starts or when
 *	a file is exhausted or when a file error is encountered. It can also
 *	occur artificially when, for example, a restart is requested to force
 *	a change in file or file position.
 *
 * ARGUMENTS:
 *	nfiles -- Total number of files expected to be sent during this transfer.
 *				This is only used in the initial (file 0) control message.
 *	nbytes -- Total number of bytes expected to be sent during this transfer.
 *				This is only used in the initial (file 0) control message.
 *
 * RETURNS:
 *	nothing
 */
void hs_filebreak(struct s_hc *hc, int nfiles, long nbytes)
	{
	BYTE str[90];
	BYTE name_to_send[FNAME_LEN];
	struct s_ftbl *ft;

	/* we've either hit a real EOF, or the restart routine
		has backed us up into an aborted file, or we're just
		starting, or we've encountered a file error, or user cancelled.
	*/
	omsg_new(hc, 'C');
	if (hc->datacnt > 0)
		{
		/* put partial block record in message */
		wsprintf(str, "P%u,%u", hc->datacnt,
				(hc->usecrc ? hc->h_crc : hc->h_checksum));
		omsg_add(hc, str);
		hc->datacnt = hc->h_crc = hc->h_checksum = 0;
		}

	if (hc->ucancel || hc->sc.rmtcancel)
		{
		hpr_id_get(hc, str);
		omsg_add(hc, str);
		omsg_add(hc, "X");
		hs_waitack(hc);
		}

	if (hc->current_filen == 0)
		{
		/* just getting started or need to start over */
		/* put 'V', 'B', 'D', 'N', and 'S' records in message */
		hpr_id_get(hc, str);	/* add 'V' field */
		omsg_add(hc, str);
		wsprintf(str, "B%d;D%d;N%u;S%lu", hc->blocksize,
				(int)(hc->deadmantime / 10), nfiles, nbytes);
		omsg_add(hc, str);
		}
	else
		{
#if FALSE
		/* TODO: put this back in later */
		if (fio_error(hc->fhdl))
			{
			/* print error message on the screen */
			hc->sc.hs_ftbl[hc->sc.ft_current].status = TSC_DISK_ERROR;
			}
#endif
		if (hc->sc.hs_ftbl[hc->sc.ft_current].status != TSC_OK)
			{
			strcpy(str, "A");
			omsg_add(hc, str);
			}
		}

	/* scan up the file table looking for first non-cancelled file or
	 *	for top of table
	 */
	while (++hc->sc.ft_current <= hc->sc.ft_top
			&& hc->sc.hs_ftbl[hc->sc.ft_current].status != TSC_OK)
		{
		xfer_name_to_send(hc->hSession,
						hc->sc.hs_ftbl[hc->sc.ft_current].fname,
						name_to_send);
		wsprintf(str, "F%u,%s",
				hc->current_filen = hc->sc.hs_ftbl[hc->sc.ft_current].filen,
				name_to_send);
		omsg_add(hc, str);
		/* put size field in so rcvr can keep display accurate */
		wsprintf(str, "s%lu", hc->sc.hs_ftbl[hc->sc.ft_current].flength);
		omsg_add(hc, str);
		omsg_send(hc, 1, hc->usecrc, FALSE);
		/* now that we've started this file, tell receiver to abort it
		 *	right away since its status is no longer TSC_OK
		 */
		omsg_new(hc, 'C');
		strcpy(str, "A");
		omsg_add(hc, str);
		}

	/* Now we should be ready for next file. We're either pointing at a
	 *	normal file in the table to be restarted or we're at the top
	 *	of the table and its time to open the next file
	 */
	hc->sc.hs_ptrgetc = hs_getc;
	/* set pointer into table for speed */
	ft = &hc->sc.hs_ftbl[hc->sc.ft_current];
	if (hc->sc.ft_current <= hc->sc.ft_top)
		{
		/* try to reopen a file from the table */
		hc->current_filen = ft->filen;
		if (hc->fhdl != NULL && hc->sc.ft_current == hc->sc.ft_open)
			{
			/* file is already open */
			fio_seek(hc->fhdl, 0, FIO_SEEK_SET);
			}
		else
			{
			/* reopen previously opened file */
			if (hc->fhdl)
				{
				fio_close(hc->fhdl);
				}
			hc->fhdl = NULL;
			hc->sc.ft_open = hc->sc.ft_current;
			hc->current_filen = ft->filen;
			hc->h_filebytes = hc->sc.bytes_sent = 0L;
			hc->total_dsp = ft->dsp_bytes;
			hc->total_thru = ft->thru_bytes;
			if (xfer_opensendfile(hc->hSession, &hc->fhdl, ft->fname,
					&ft->flength, NULL, NULL) != 0)
				{
				/* display error */
				ft->status = TSC_CANT_OPEN;
				hc->sc.hs_ptrgetc = hs_reteof;
				hc->sc.ft_open = -1;
				}
			}
		}

	else if (xfer_nextfile(hc->hSession, name_to_send))
		{
		/* There are no more previously started files in the table to be
		 *	restarted, but there is another brand new file to send
		 */
		if (hc->sc.ft_top >= hc->sc.ft_limit)
			{
			hsdsp_event(hc, HSE_FULL);
			hsdsp_status(hc, HSS_WAITACK);
			omsg_add(hc, "I");
			omsg_send(hc, 1, hc->usecrc, FALSE);
			omsg_new(hc, 'C');
			HS_XMIT_FLUSH(hc);
			while(hc->sc.ft_top >= hc->sc.ft_limit)
				{
				hs_background(hc);	/* wait for space in table */
				hs_logx(hc, FALSE);
				}
			hsdsp_event(hc, HSE_GOTACK);
			hsdsp_status(hc, HSS_SENDING);
			/* items may shift in hs_ftbl during hs_background */
			ft = &hc->sc.hs_ftbl[hc->sc.ft_current];
			}

		/* open next file and install it in the table */
		if (hc->fhdl)
			{
			fio_close(hc->fhdl);
			}
		hc->fhdl = NULL;
		strcpy(ft->fname, name_to_send);

		ft->filen = ++hc->current_filen;
		ft->cntrl = 0;
		ft->status = TSC_OK;
		hs_namecheck(ft);
		hc->total_dsp = ft->dsp_bytes =
								hc->sc.hs_ftbl[hc->sc.ft_top].dsp_bytes +
								hc->sc.hs_ftbl[hc->sc.ft_top].flength;
		hc->total_thru = ft->thru_bytes =
				hc->sc.hs_ftbl[hc->sc.ft_top].thru_bytes + hc->h_filebytes;

		hc->sc.ft_top = hc->sc.ft_open = hc->sc.ft_current;

		hc->h_filebytes = hc->sc.bytes_sent = 0;
		if (xfer_opensendfile(hc->hSession, &hc->fhdl, ft->fname, &ft->flength,
				NULL, NULL) != 0)
			{
			/* display error? */
			hc->fhdl = NULL;
			ft->status = TSC_CANT_OPEN;
			hc->sc.ft_open = -1;
			hc->sc.hs_ptrgetc = hs_reteof;
			}
		}
	else	/* no more files in table and no new files to send */
		{
		if (hc->fhdl)
			{
			fio_close(hc->fhdl);
			}
		hc->sc.ft_open = -1;
		hc->fhdl = NULL;
		--hc->sc.ft_current;	/* don't point off top of table */
		hsdsp_event(hc, HSE_DONE);
		omsg_add(hc, "E");
		hs_waitack(hc);
		}

	/* put file name and attribute records in message */
	xfer_name_to_send(hc->hSession, ft->fname, name_to_send);
	wsprintf(str, "F%d,%s", ft->filen, name_to_send);
	omsg_add(hc, str);
	wsprintf(str, "s%lu", ft->flength);
	omsg_add(hc, str);

	if (hc->fhdl)
		{
		unsigned long ftime;
		struct tm *pT;

		ftime = itimeGetFileTime(ft->fname);
		ftime += itimeGetBasetime();		/* fudge for C 7 and later */
		pT = localtime(&ftime);
		wsprintf(str, "t%d,%d,%d,%d,%d,%d",
				pT->tm_year + 1900,
				pT->tm_mon,
				pT->tm_mday,
				pT->tm_hour,
				pT->tm_min,
				pT->tm_sec);
		omsg_add(hc, str);

#if FALSE
		if (hc->sc.rmt_compress && h_trycompress &&
				!bittest(ft->cntrl, FTC_DONT_CMPRS) &&
				ft->flength > CMPRS_MINSIZE &&
				compress_start(&hc->sc.hs_ptrgetc, &h_filebytes, FALSE))
#endif
		if (hc->sc.rmt_compress && hc->h_trycompress &&
				!bittest(ft->cntrl, FTC_DONT_CMPRS) &&
				ft->flength > CMPRS_MINSIZE &&
				compress_start(&hc->sc.hs_ptrgetc, hc, &hc->h_filebytes, FALSE))
			{
			hsdsp_compress(hc, ON);
			/* hsdsp_status(hc, HSS_SENDING); */
			omsg_add(hc, "C");
			bitset(ft->cntrl, FTC_COMPRESSED);
			}
		else
			{
			hsdsp_compress(hc, OFF);
			bitclear(ft->cntrl, FTC_COMPRESSED);
			}
		}
	omsg_send(hc, 1, hc->usecrc, FALSE);

	HS_XMIT_FLUSH(hc);
	hsdsp_newfile(hc, ft->filen, ft->fname, ft->flength);
	hsdsp_progress(hc, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_waitack
 *
 * DESCRIPTION:
 *	Called at the end of a transfer to wait for the final acknowldgement from
 *	receiver or until a restart message forces us to back up and retransmit
 *	some of the data. This routine never returns directly to its caller. It
 *	always exits by way of a longjmp either during a hs_background call if
 *	an 'END' or 'RESTART' message is received or at the end of the function
 *	if it times out without receiving either message.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing (see DESCRIPTION)
 */
void hs_waitack(struct s_hc *hc)
	{
	long timer;

	omsg_send(hc, 1, hc->usecrc, FALSE);
	hc->sc.receiver_timedout = FALSE;
	HS_XMIT_FLUSH(hc);
	hsdsp_status(hc, HSS_WAITACK);
	timer = startinterval();


	/* wait for 60 seconds, until longjmp either restarts or ends transfer */
	while (interval(timer) < FINAL_ACK_WAIT)
		{
		hs_background(hc);
		if (hc->sc.receiver_timedout)
			{
			/* receiver must have missed our end of transfer message */
			omsg_send(hc, 1, hc->usecrc, FALSE);
			HS_XMIT_FLUSH(hc);
			hc->sc.receiver_timedout = FALSE;
			}
		}
	/* if we get here, we didn't get response from receiver for 60 seconds */
	hsdsp_event(hc, HSE_NORESP);
	longjmp(hc->sc.jb_bailout, TSC_NO_RESPONSE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_decode_rmsg
 *
 * DESCRIPTION:
 *	Called by hs_rcvmsg when a complete message has been received. This routine
 *	parses and interprets the message either by recording information sent by
 *	the receiver or by altering the course of the transfer in response to an
 *	interruption message. There may be several fields in a message but note
 *	that certain messages transfer control elsewhere via a longjmp and thus
 *	prevent any subsequent fields from being scanned ('E', 'X', and 'R'
 *	messages specifically). All messages from the receiver to the sender are
 *	sent in printable characters.
 *
 * ARGUMENTS:
 *	data -- A string containing the messages to be interpreted. Each message
 *			is in the form of: 'T<data>;'
 *			where T is a single character message identifier and <data> is
 *			optional associated information.
 *
 * RETURNS:
 *	nothing
 *	(exits via a longjmp when certain interruption messages are received)
 */
void hs_decode_rmsg(struct s_hc *hc, BYTE *data)
	{
	BYTE *field;
	int filenum;
	int mnum;
	int tval;

	if (data[0] != 'c') /* this is the only kind we know about now but don't */
		return; 		/*	consider it an error if newer versions send 	 */
						/*	other types */

	mnum = unchar(data[2]);
	field = strtok(&data[3], ";");
	while (field != NULL)
		{
		switch(*field++)
			{
		case 'f':		/* receiver has successfully received file fn */
			hs_fileack(hc, atoi(field));
			break;
		case 'B':		/* receiver is requesting a particular block size */
			if (hc->current_filen == 0)
				{
				tval = atoi(field);
				tval = max(tval, H_MINBLOCK);
				hc->blocksize = min(hc->blocksize, tval);
				}
			break;
		case 'D':		/* receiver is requesting a particular deadman time */
			tval = atoi(field);
			tval = max(tval, H_MINDEADMAN);
			hc->deadmantime = min(hc->deadmantime, tval * 10);
			break;
		case 'T':		/* receiver is requesting check type */
			hc->sc.rmtchkt = atoi(field);
			break;
		case 'C':		/* receiver is agreeing to do compression */
			if (!*field)
				hc->sc.rmt_compress = TRUE;
			break;
		case 'E':		/* receiver is acknowledging end of transfer */
			hc->xfertime = interval(hc->xfertimer);
			if (*field)
				hs_fileack(hc, atoi(field));
			hsdsp_event(hc, HSE_GOTACK);
			if (!hc->ucancel && !hc->sc.rmtcancel)
				longjmp(hc->sc.jb_bailout, TSC_COMPLETE);
			else
				longjmp(hc->sc.jb_bailout,
						hc->ucancel ? TSC_USER_CANNED : TSC_RMT_CANNED);
			break;
		case 'X':		/* receiver is requesting a cancellation of the xfer */
			if (*field)
				hs_fileack(hc, atoi(field));
			hsdsp_event(hc, HSE_RMTCANCEL);
			hc->sc.rmtcancel = TRUE;
			hc->sc.hs_ptrgetc = hs_reteof;
			break;
		case 'A':		/* receiver is aborting a single file */
			hs_fileack(hc, filenum = atoi(field));  /* all earlier files ok */

			/* If we're still sending the file being cancelled, mark it
			 * cancelled and set the character function pointer to hs_reteof
			 * to force a switch to the next file, if any.
			 * If we've already finished sending the file being cancelled,
			 * look it up in the file table and mark if cancelled so that
			 * if we're asked to back up into it, we won't bother resending
			 * it
			 */
			if (hc->current_filen == filenum)
				{
				hc->sc.hs_ftbl[hc->sc.ft_current].status = TSC_RMT_CANNED;
				hc->sc.hs_ptrgetc = hs_reteof; /* force switch to next file */
				}
			else
				{
				/* we're no longer sending file being canned */
				for (tval = hc->sc.ft_current; tval >= 0; --tval)
					if (hc->sc.hs_ftbl[tval].filen == filenum)
						hc->sc.hs_ftbl[tval].status = TSC_RMT_CANNED;
				}
			break;

		case 'V':
			tval = atoi(field);
			field = strchr(field, ',');

			/* if version restrictions were found, stop the transfer */
			if (!hpr_id_check(hc, tval, ++field))
				{
				hsdsp_event(hc, HSE_RMTCANCEL);
				hc->sc.rmtcancel = TRUE;
				hc->sc.hs_ptrgetc = hs_reteof;
				}
			break;

		case 'R':		/* receiver is requesting a restart */
			if (!hc->sc.started)
				{
				hsdsp_event(hc, HSE_GOTSTART);
				hc->sc.started = TRUE;
				}
			else
				{
				hsdsp_event(hc, HSE_GOTRETRY);
				hsdsp_retries(hc, ++hc->total_tries);
				}
			tval = atoi(strtok(field, ","));   /* get file number */
			hs_fileack(hc, tval);
			hs_dorestart(hc, tval, atoi(strtok(NULL, ",")), mnum, FALSE);
			break;

		case 't':		/* receiver stopped receiving data */
			hc->sc.receiver_timedout = TRUE;
			break;
			}
		field = strtok(NULL, ";");
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_fileack
 *
 * DESCRIPTION:
 *	Marks all transmitted files up to a specified file number as acknowledged,
 *	that is, as transmitted completely. This routine merely marks the files
 *	in the file table as complete; completed entries will be removed from the
 *	table later by hs_logx.
 *
 * ARGUMENTS:
 *	n -- The file number that the receiver considers current. All file numbers
 *		 lower than this can be considered complete.
 *
 * RETURNS:
 *	nothing
 */
void hs_fileack(struct s_hc *hc, int n)
	{
	register int ix = 0;

	while (ix <= hc->sc.ft_current)
		{
		if (ix <= hc->sc.ft_limit && hc->sc.hs_ftbl[ix].filen < n)
			bitset(hc->sc.hs_ftbl[ix].cntrl, FTC_CONFIRMED);
		++ix;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * hs_logx
 *
 * DESCRIPTION:
 *	Logs either all acknowledged transfers or all transfers to the log file
 *	and removes their entries from the file table. Note that the values of
 *	hc->sc.ft_top, hc->sc.ft_current, and hc->sc.ft_open can change during this
 *	operation.
 *
 * ARGUMENTS:
 *	all -- if TRUE, log all regardless of confirmation
 *
 * RETURNS:
 *	nothing
 */
void hs_logx(struct s_hc *hc, int all)
	{
	struct s_ftbl *ftptr = &hc->sc.hs_ftbl[0];

	while (hc->sc.ft_top >= 0 && (all ||
			(hc->sc.ft_current > 1 && bittest(hc->sc.hs_ftbl[0].cntrl,FTC_CONFIRMED))))
		{
		if (ftptr->filen > 0)
			{
			if (ftptr->status == TSC_OK &&
					!bittest(ftptr->cntrl,FTC_CONFIRMED))
				ftptr->status = TSC_ERROR_LIMIT;
			xfer_log_xfer(hc->hSession,
						TRUE,
						ftptr->fname,
						NULL,
						ftptr->status);
			}
		MemCopy((char *)&hc->sc.hs_ftbl[0], (char *)&hc->sc.hs_ftbl[1],
				(unsigned)hc->sc.ft_top * sizeof(struct s_ftbl));
		--hc->sc.ft_top;
		--hc->sc.ft_current;
		--hc->sc.ft_open;
		}
	}

/************************** end of hpr_snd1.c ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\krm.c ===
/* File: C:\WACKER\xfer\krm.c (Created: 28-Jan-1994)
 * created from HAWIN source file
 * krm.c  --  Functions common to both kermit send and kermit receive
 *		routines.
 *
 *	Copyright 1989,1990,1991,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 4/10/02 3:05p $
 */
#include <windows.h>
#pragma hdrstop

#include <time.h>
#include <stdlib.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <term\res.h>
#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "krm.h"
#include "krm.hh"

// int   krm_dbg;				 /* used for real-time debugging using dbg.c */

// int   k_useattr;			 /* send 'normalized' file names ? */

// int   k_maxl;				 /* maximum packet length we'll take */
// int   k_timeout;			 /* time they should wait for us */
// uchar k_chkt;				 /* check type we want to use */
// int   k_retries;			 /* no. of retries */
// uchar k_markchar;			 /* first char of each packet */
// uchar k_eol;				 /* end of line character for packets */
// int   k_npad;				 /* no. of pad chars. to send us */
// uchar k_padc;				 /* pad char. we want */

// struct s_krm_control FAR *kc;
// void (NEARF *KrmProgress)(HSESSION, bits);

// unsigned ke_msg[] =
	// {
	// TM_NULL,
	// TM_NO_RESP,
	// TM_GOT_RETRY,
	// TM_ERR_DATA,
	// TM_RMT_ERR,
	// TM_BAD_FMT,
	// TM_PCKT_REPT,
	// TM_BAD_SEQ,
	// TM_FAILED,
	// };

/* for mapping Kermit result codes to Transfer Status Codes */
int kresult_code[] =
	{
	TSC_OK, 			   /* KA_OK 		   0 */
	TSC_USER_CANNED,	   /* KA_LABORT1	   1 */
	TSC_RMT_CANNED, 	   /* KA_RABORT1	   2 */
	TSC_USER_CANNED,	   /* KA_LABORTALL	   3 */
	TSC_RMT_CANNED, 	   /* KA_RABORTALL	   4 */
	TSC_USER_CANNED,	   /* KA_IMMEDIATE	   5 */
	TSC_RMT_CANNED, 	   /* KA_RMTERR 	   6 */
	TSC_LOST_CARRIER,	   /* KA_LOST_CARRIER  7 */
	TSC_ERROR_LIMIT,	   /* KA_ERRLIMIT	   8 */
	TSC_OUT_OF_SEQ, 	   /* KA_OUT_OF_SEQ    9 */
	TSC_BAD_FORMAT, 	   /* KA_BAD_FORMAT   10 */
	TSC_TOO_MANY,		   /* KA_TOO_MANY	  11 */
	TSC_CANT_OPEN,		   /* KA_CANT_OPEN	  12 */
	TSC_DISK_FULL,		   /* KA_DISK_FULL	  13 */
	TSC_DISK_ERROR, 	   /* KA_DISK_ERROR   14 */
	TSC_OLDER_FILE, 	   /* KA_OLDER_FILE   15 */
	TSC_NO_FILETIME,	   /* KA_NO_FILETIME  16 */
	TSC_WONT_CANCEL,	   /* KA_WONT_CANCEL  17 */
	TSC_VIRUS_DETECT,	   /* KA_VIRUS_DETECT 18 */
	TSC_REFUSE			   /* KA_USER_REFUSED 19 */
	};


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	krmGetParameters
 *
 * DESCRIPTION:
 *	This function is called to initialize all of the user settable values
 *	that get passed in from the parameters dialog box.
 *
 * ARGUMENTS:
 *	kc -- pointer to the Kermit data block
 *
 * RETURNS:
 *	Nothing.
 *
 */
void krmGetParameters(ST_KRM *kc)
	{
	XFR_PARAMS *pX;
	XFR_KR_PARAMS *pK;

	pX = (XFR_PARAMS *)0;
	xfrQueryParameters(sessQueryXferHdl(kc->hSession), (VOID **)&pX);
	assert(pX);
	if (pX != (XFR_PARAMS *)0)
		kc->k_useattr = pX->fUseDateTime;

	pK = (XFR_KR_PARAMS *)xfer_get_params(kc->hSession, XF_KERMIT);
	assert(pK);
	if (pK)
		{
		kc->k_maxl        = pK->nBytesPerPacket;
		kc->k_timeout     = pK->nSecondsWaitPacket;
		kc->k_chkt        = (BYTE)pK->nErrorCheckSize;
		kc->k_retries     = pK->nRetryCount;
		kc->k_markchar    = (BYTE)pK->nPacketStartChar;
		kc->k_eol         = (BYTE)pK->nPacketEndChar;
		kc->k_npad        = pK->nNumberPadChars;
		kc->k_padc        = (BYTE)pK->nPadChar;
		}
	else
		{
		//
		// Set to the defaults set in xfrInitializeKermit().
		//
		kc->k_maxl        = 94;
		kc->k_timeout     = 5;
		kc->k_chkt        = 1;
		kc->k_retries     = 5;
		kc->k_markchar    = 1;
		kc->k_eol         = 13;
		kc->k_npad        = 0;
		kc->k_padc        = 0;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ksend_packet
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void ksend_packet(ST_KRM *kc,
					unsigned char type,
					unsigned dlength,
					int seq,
					KPCKT FAR *pckt)
	{
	unsigned csum;
	unsigned crc;
	int i;
	char *cp;
	int iSendStatus = COM_OK;

	if (type == 'N' || type == 'E') /* wait for input to clear */
		ComRcvBufrClear(kc->hCom);

	/* send any padding necessary */
	for (i = kc->its_npad + 1; --i > 0; )
		ComSendCharNow(kc->hCom, kc->its_padc);

	/* when received, only packet data is valid, we fill in remainder */
	pckt->pmark = kc->k_markchar;
	pckt->plen = (int)tochar(dlength + 3);
	if (kc->its_chkt == K_CHK2)
		pckt->plen += 1;
	else if (kc->its_chkt == K_CHK3)
		pckt->plen += 2;
	pckt->pseq = (int)tochar(seq);
	pckt->ptype = type;

	/* now figure check bytes */
	if (kc->its_chkt == K_CHK3)
		{
		crc = kcalc_crc((unsigned)0,
						(unsigned char *)&pckt->plen,
						(int)dlength + 3);
		cp = pckt->pdata + dlength;
		*cp++ = (char)tochar((crc >> 12) & 0x0F);
		*cp++ = (char)tochar((crc >> 6) & 0x3F);
		*cp++ = (char)tochar(crc & 0x3F);
		}
	else
		{
		csum = 0;
		cp = (char *)&pckt->plen;
		for (i = dlength + 4; --i > 0; )
			csum += *cp++;
		/* cp is left pointing to first byte past data */
		if (kc->its_chkt == K_CHK2)
			{
			*cp++ = (char)tochar((csum >> 6) & 0x3F);
			*cp++ = (char)tochar(csum & 0x3F);
			}
		else
			*cp++ = (char)tochar((((csum & 0xC0) >> 6) + csum) & 0x3F);
		}
	*cp = kc->its_eol;

	/* send off all chars in buffer */
	// (VOID)mComSndBufr(comhdl, (char *)pckt,
	//		(uchar)(unchar(pckt->plen) + 3), /* include mark, len & eol */
	//		100, kc->flagkey_hdl);

	iSendStatus = ComSndBufrSend(kc->hCom,
					             (void *)pckt,
					             (int)(unchar(pckt->plen) + 3),
					             100);

	assert(iSendStatus == COM_OK);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krec_packet
 *
 * DESCRIPTION:
 *	Receive a kermit packet, check it for validity and return either the
 *	type of the received packet or an error code.
 *
 * ARGUMENTS:
 *	len
 *	seq
 *	data
 *
 * RETURNS:
 *
 */
int krec_packet(ST_KRM *kc,
				int *len,
				int *seq,
				unsigned char *data)
	{
	TCHAR c = 0;
	char *bp;
	char hdr[3];
	int done, got_hdr;
	int cnt, i;
	long j;
	unsigned chksum;
	unsigned rchk;
	long stime;
	long timelimit = kc->its_timeout * 10L;

	   /* wait until any packet is transmitted */
	// (VOID)mComSndBufrWait(comhdl, 100, kc->flagkey_hdl);
	if (ComSndBufrWait(kc->hCom, 100) == COM_PORT_NOT_OPEN)
		{
		return(BAD_PACKET);
		}

	stime = (long)startinterval();
	while (c != (int)kc->k_markchar)
		{
		if (j = xfer_user_interrupt(kc->hSession))
			{
			/* Yes, this is needed */
			// XferAbort(kc->hSession, (LPVOID)((LPSTR)j));
			xfer_user_abort(kc->hSession, j);
			return(BAD_PACKET);
			}

		if (xfer_carrier_lost(kc->hSession))
			{
			return(BAD_PACKET);
			}

		(*kc->KrmProgress)(kc, 0);

		// if ((c = mComRcvChar(comhdl)) == -1)
		if (mComRcvChar(kc->hCom, &c) == 0)
			{
			if ((long)interval(stime) > timelimit)
				{
				return('T');
				}
			xfer_idle(kc->hSession, XFER_IDLE_IO);
			}
		else if (c != (int)kc->k_markchar)
			{
			}
		else
			;	/* for lint */
		}
	getpacket:
	chksum = 0;
	done = got_hdr = FALSE;
	bp = &hdr[0];
	cnt = 3;
	while (!done)
		{
		for (i = cnt + 1; --i > 0; )
			{
			// while ((c = mComRcvChar(comhdl)) == -1)
			while (mComRcvChar(kc->hCom, &c) == 0)
				{
				if (j = xfer_user_interrupt(kc->hSession))
					{
					// XferAbort(kc->hSession, (LPVOID)((LPSTR)j));
					xfer_user_abort(kc->hSession, j);
					return(BAD_PACKET);
					}

				if (xfer_carrier_lost(kc->hSession))
					{
					return(BAD_PACKET);
					}

				(*kc->KrmProgress)(kc, 0);

				if ((long)interval(stime) > timelimit)
					{
					return('T');
					}
				xfer_idle(kc->hSession, XFER_IDLE_IO);
				}
			*bp = (char)c;
			if ((unsigned char)*bp == kc->k_markchar)
				{
				goto getpacket;
				}
			chksum += *bp++;
			}
		if (!got_hdr)
			{
			got_hdr = TRUE;
			*seq = unchar(hdr[1]);
			cnt = unchar(hdr[0]) - 2;	/* we've already got seq & len chars */
			if (cnt < 0 || cnt > 92)
				{
				return(BAD_PACKET);
				}
			bp = data;
			}
		else
			done = TRUE;
		}
	bp -= kc->its_chkt;   /* move pointer back to beginning of check field */
	switch(kc->its_chkt)
		{
	case 1:
		*len = cnt - 1;
		chksum -= bp[0];
		chksum = (((chksum & 0xC0) >> 6) + chksum) & 0x3F;
		rchk = (unsigned char)unchar(bp[0]);
		break;
	case 2:
		*len = cnt - 2;
		chksum = (chksum - (bp[0] + bp[1])) & 0x0FFF;
		rchk = ((unsigned char)unchar(bp[0]) << 6) + unchar(bp[1]);
		break;
	case 3:
		*len = cnt - 3;
		rchk = ((unsigned char)unchar(bp[0]) << 12) +
				((unsigned char)unchar(bp[1]) << 6) +
				unchar(bp[2]);
		chksum = kcalc_crc((unsigned)0, hdr, 3);
		if (*len > 0)
			chksum = kcalc_crc(chksum, data, *len);
		break;

	default:
		break;
		}
	*bp = '\0';
	if (*len < 0 || chksum != rchk)
		{
		return(BAD_PACKET);
		}
	else
		{
		return(hdr[2]);
		}
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * buildparams
 *
 * DESCRIPTION:
 *	Build a packet containing our initializing parameters. Return length of
 *	data in packet.
 *
 * ARGUMENTS:
 *	initiating	-- TRUE if we're initiating the transfer, FALSE if we're ACKing
 *					its initializing packet
 *	bufr		-- a place to put the results
 * RETURNS:
 *
 */
int buildparams(ST_KRM *kc, int initiating, unsigned char *bufr)
	{
	unsigned char *bp = bufr;

	if (initiating) 	/* just tell them what we want to do */
		{
		*bp++ = (unsigned char)tochar(kc->k_maxl);	   /* MAXL */
		*bp++ = (unsigned char)tochar(kc->k_timeout);  /* TIME */
		*bp++ = (unsigned char)tochar(kc->k_npad);	   /* NPAD */
		*bp++ = (unsigned char)ctl(kc->k_padc); 	   /* PADC */
		*bp++ = (unsigned char)tochar(kc->k_eol);	   /* EOL */
		*bp++ = K_QCTL; 				   /* QCTL */
		*bp++ = 'Y';					   /* QBIN */
		*bp++ = (unsigned char)(kc->k_chkt + '0');	   /* CHKT */
		*bp++ = K_REPT; 				   /* REPT */
		*bp++ = (unsigned char)tochar(CAPMASK_ATTR);/* CAPAS */
		}
	else				/* we're responding to them */
		{
		/* MAXL */
		*bp++ = (char)tochar(kc->k_maxl);
		/* TIME */
		*bp++ = (char)tochar((abs(kc->k_timeout - kc->its_timeout) <= 2) ?
				kc->k_timeout + 2 : kc->k_timeout);
		/* NPAD */
		*bp++ = (unsigned char)tochar(kc->k_npad);
		/* PADC */
		*bp++ = (unsigned char)ctl(kc->k_padc);
		/* EOL */
		*bp++ = (unsigned char)tochar(kc->k_eol);
		/* QCTL */
		*bp++ = K_QCTL;
		/* QBIN */
		if (kc->its_qbin == 'Y')
			kc->its_qbin = (char)(cnfgBitsPerChar(kc->hSession) == 8 ? 'N' : K_QBIN);

		if (IN_RANGE(kc->its_qbin, 33, 62) || IN_RANGE(kc->its_qbin, 96, 126))
			*bp++ = kc->its_qbin;
		else
			*bp++ = 'N', kc->its_qbin = '\0';
		/* CHKT */
		if (!IN_RANGE(kc->its_chkt, 1, 3))
			kc->its_chkt = 1;
		*bp++ = (unsigned char)(kc->its_chkt + '0');
		/* REPT */
		if (IN_RANGE(kc->its_rept, 33, 62) || IN_RANGE(kc->its_rept, 96, 126))
			*bp++ = kc->its_rept;
		else
			*bp++ = ' ', kc->its_rept = '\0';

		if (kc->its_capat)	  /* if sender can handle A packets, we can too */
			*bp++ = tochar(CAPMASK_ATTR);
		}

	return (int)(bp - bufr);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * getparams
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	nothing
 */
void getparams(ST_KRM *kc, int initiating, unsigned char *bufr)
	{
	if (!*bufr)
		return;
	kc->its_maxl = (*bufr == ' ' ? 80 : unchar(*bufr));
	/* if user has shortened packet length, he must know something about
		intervening transmission system that other end may not know about */
	if (kc->its_maxl > kc->k_maxl)
		kc->its_maxl = kc->k_maxl;
	if (!*++bufr)
		return;
	kc->its_timeout = (*bufr == ' ' ? 10 : unchar(*bufr));
	if (!initiating && abs(kc->k_timeout - kc->its_timeout) <= 2)
		kc->its_timeout = kc->k_timeout + 2;

	if (!*++bufr)
		return;
	kc->its_npad = unchar(*bufr);

	if (!*++bufr)
		return;
	kc->its_padc = (char)(*bufr == ' ' ? '\0' : ctl(*bufr));

	if (!*++bufr)
		return;
	kc->its_eol = (char)(*bufr == ' ' ? '\r' : unchar(*bufr));

	if (!*++bufr)
		return;
	kc->its_qctl = (char)(*bufr == ' ' ? K_QCTL : *bufr);

	if (!*++bufr)
		return;
	kc->its_qbin = *bufr;
	if (initiating &&
			!(IN_RANGE(kc->its_qbin, 33, 62) || IN_RANGE(kc->its_qbin, 96, 126)))
		kc->its_qbin = '\0';

	if (!*++bufr)
		return;
	kc->its_chkt = (unsigned char)(*bufr - '0');
	if (initiating && kc->its_chkt != kc->k_chkt)
		kc->its_chkt = 1;

	if (!*++bufr)
		return;
	kc->its_rept = *bufr;
	if (!(IN_RANGE(kc->its_rept, 33, 62) || IN_RANGE(kc->its_rept, 96, 126)))
		kc->its_rept = '\0';
	if (initiating && kc->its_rept != K_REPT)
		kc->its_rept = '\0';
	if (!*++bufr)
		return;
	if (unchar(*bufr) & CAPMASK_ATTR)
		kc->its_capat = TRUE;

	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * kcalc_crc
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
// #if FALSE		/* implemented in machine code for speed */
unsigned kcalc_crc(unsigned crc, unsigned char *data, int cnt)
	{
	unsigned int c;
	unsigned q;

	while (cnt--)
		{
		c = *data++;
		q = (crc ^ c) & 017;
		crc = (crc >> 4) ^ (q * 010201);
		q = (crc ^ (c >> 4)) & 017;
		crc = (crc >> 4) ^ (q * 010201);
		}
	return(crc);
	}
// #endif

/* end of krm.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\itime.c ===
/* itime.c -- functions to handle time in our program
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 11/07/00 12:25p $
 */
#include <windows.h>
#pragma hdrstop

#include <time.h>
#include <memory.h>
#include <tdll\stdtyp.h>
#include <tdll\assert.h>

#include "itime.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 *                                                                            *
 *                             R E A D    M E                                 *
 *                                                                            *
 * Everybody keeps changing the time standard to whatever they feel might be  *
 * a little bit better for them.  So far I have found 3 different standards   *
 * in Microsoft functions.  This does not even count the fact that HyperP     *
 * uses its own format for time.                                              *
 *                                                                            *
 * Henceforth, all time values that are passed around in the program will be  *
 * based on the old UCT format of the number of seconds since Jan 1, 1970.    *
 *                                                                            *
 * Please use an unsigned long for these values.                              *
 *                                                                            *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

unsigned long itimeGetBasetime(void);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	itimeSetFileTime
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to set the date/time of a
 *	file.
 *
 * PARAMETERS:
 *	pszName -- pointer to a file name
 *	ulTime  -- our internal standard time format
 *
 * RETURNS:
 *	Nothing.
 *
 */
void itimeSetFileTime(LPCTSTR pszName, unsigned long ulTime)
	{
	time_t base_time;
	struct tm *pstT;
	WORD wDOSDate;
	WORD wDOSTime;
	HANDLE hFile;
	FILETIME stFileTime;

	/* Yes, we need to open the file */
	hFile = CreateFile(pszName,
						GENERIC_READ,
						FILE_SHARE_READ,
						0,
						OPEN_EXISTING,
						0,
						0);
	if (hFile == INVALID_HANDLE_VALUE)
		return;								/* No such file */

	base_time = itimeGetBasetime();
	if ((long)base_time == (-1))
		goto SFTexit;

	base_time += ulTime;	/* Convert to 1990 base */

	pstT = localtime(&base_time);
	assert(pstT);
	/* For some reason, this sometimes returns a NULL */
	if (pstT)
		{
		/* Build the "DOS" formats */
		wDOSDate = ((pstT->tm_year - 80) << 9) |
					(pstT->tm_mon << 5) |
					pstT->tm_mday;
		DbgOutStr("Date %d %d %d 0x%x\r\n",
					pstT->tm_year, pstT->tm_mon, pstT->tm_mday, wDOSDate, 0);

		wDOSTime = ((pstT->tm_hour - 1) << 11) |
					(pstT->tm_min << 5) |
					(pstT->tm_sec / 2);
		DbgOutStr("Time %d %d %d 0x%x\r\n",
					pstT->tm_hour, pstT->tm_min, pstT->tm_sec, wDOSTime, 0);

		/* Convert to CHICAGO format */
		/* TODO: as of 14-Mar-94, this doesn't work. Check later */
		if (!DosDateTimeToFileTime(wDOSDate, wDOSTime, &stFileTime))
			goto SFTexit;

		/* Set the time */
		SetFileTime(hFile, &stFileTime, &stFileTime, &stFileTime);
		}

SFTexit:
	/* Close the handle */
	CloseHandle(hFile);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	itimeGetFileTime
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to get the date/time of a
 *	file.
 *
 * PARAMETERS:
 *	pszName -- pointer to a file name
 *
 * RETURNS:
 *	The file date/time in our internal standard time format.
 *
 */
unsigned long itimeGetFileTime(LPCTSTR pszName)
	{
	unsigned long ulTime = 0;
	struct tm stT;
	WORD wDOSDate;
	WORD wDOSTime;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	FILETIME stFileTime;

	/* Yes, we need to open the file */
	hFile = CreateFile(pszName,
						GENERIC_READ,
						FILE_SHARE_READ,
						0,
						OPEN_EXISTING,
						0,
						0);
	if (hFile == INVALID_HANDLE_VALUE)
		goto GFTexit;

	if (!GetFileTime(hFile, NULL, NULL, &stFileTime))
		goto GFTexit;

	if (!FileTimeToDosDateTime(&stFileTime, &wDOSDate, &wDOSTime))
		goto GFTexit;

	memset(&stT, 0, sizeof(struct tm));
	stT.tm_mday = (wDOSDate & 0x1F);
	stT.tm_mon = ((wDOSDate >> 5) & 0xF);
	stT.tm_year = ((wDOSDate >> 9) & 0x7F);
	stT.tm_sec = (wDOSTime & 0x1F) * 2;
	stT.tm_min = ((wDOSTime >> 5) & 0x3F);
	stT.tm_hour = ((wDOSTime >> 11) & 0x1F);

	stT.tm_year += 80;

	ulTime = (unsigned long) mktime(&stT);
	if ((long)ulTime == (-1))
		ulTime = 0;
	else
		ulTime -= itimeGetBasetime();


GFTexit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return ulTime;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *	This function converts the "new" internal MICROSOFT time format (based at
 *	1900) to the "old" format (based at 1970).
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
unsigned long itimeGetBasetime()
	{
	unsigned long ulBaseTime = 0;
	struct tm stT;

	memset(&stT, 0, sizeof(struct tm));

	/* Get our base time */
	stT.tm_mday = 1;		/* Jan 1, 1970 */
	stT.tm_mon = 1;
	stT.tm_year = 70;

	ulBaseTime = (unsigned long) mktime(&stT);

	return ulBaseTime;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\krm.h ===
/* File: C:\WACKER\xfer\krm.h (Created: 28-Jan-1994)
 * created from HAWIN source file
 * krm.h  --  Exported definitions for KERMIT file transfer protocol routines.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

/* display rows for receiving */
#define KR_DR_RCV_FILE	 1
#define KR_DR_VIR_SCAN	 1
#define KR_DR_STORING	 2
#define KR_DR_COMPRESS	 3
#define KR_DR_FILE_SIZE  3
#define KR_DR_PACKET	 4
#define KR_DR_RETRIES	 4
#define KR_DR_TOTAL_RET  4
#define KR_DR_FILES_RCVD 4
#define KR_DR_LAST_ERR	 5
#define KR_DR_AMT_RCVD	 5
#define KR_DR_VUF		 8
#define KR_DR_BOTM_LINE  11

/* krm_snd display row values */
#define KS_DR_SND_FILE	 1
#define KS_DR_COMPRESS	 2
#define KS_DR_FILE_SIZE  2
#define KS_DR_PACKET	 3
#define KS_DR_RETRIES	 3
#define KS_DR_TOTAL_RET  3
#define KS_DR_FILES_SENT 3
#define KS_DR_LAST_ERR	 4
#define KS_DR_AMT_SENT	 4
#define KS_DR_VUF		 7
#define KS_DR_VUT		 11
#define KS_DR_BOTM_LINE  14


/* user settable options */

// extern int   k_useattr; 			/* send 'normalized' file names ? */
// extern int	 k_maxl;				/* maximum packet length we'll take */
// extern int	 k_timeout; 			/* time they should wait for us */
// extern uchar k_chkt;				/* check type we want to use */
// extern int	 k_retries; 			/* no. of retries */
// extern uchar k_markchar;			/* first char of each packet */
// extern uchar k_eol; 				/* end of line character for packets */
// extern int   k_npad;				/* no. of pad chars. to send us */
// extern uchar k_padc;				/* pad char. we want */



extern int krm_rcv(HSESSION hS, int attended, int single_file);
extern int krm_snd(HSESSION hS, int attended, int nfiles, long nbytes);

/* from KCALC.ASM */
extern unsigned kcalc_crc(unsigned crc, unsigned char *data, int cnt);

/********************* end of krm.h *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx.c ===
/* File: C:\WACKER\xfer\mdmx.c (Created: 17-Jan-1994)
 * created from HAWIN source file
 * mdmx.c
 *
 * 	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 7/12/02 8:09a $
 */
#include <windows.h>
#pragma hdrstop

#include <setjmp.h>

#define	BYTE	unsigned char

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\xfer_msc.h>
#include <tdll\file_io.h>
#include "xfr_srvc.h"
#include "xfr_todo.h"
#include "xfr_dsp.h"
#include "xfer_tsc.h"
#include "foo.h"

#include "xfer.h"
#include "xfer.hh"

#include "mdmx.h"
#include "mdmx.hh"

/*lint -e502*/				/* lint seems to want the ~ operator applied
							 *	only to unsigned, wer'e using uchar
							 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * mdmx_progress
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void mdmx_progress(ST_MDMX *pX, int status)
	{
	long ttime;
	long stime = -1;
	long etime = -1;
	long bytes_sent;
	long cps = -1;
	int  k_sent;
	// static long displayed_time = -1L;

	if (pX == NULL || pX->xfertimer == -1L)
		{
		return;
		}

	ttime = bittest(status, TRANSFER_DONE) ?
			pX->xfertime : (long)interval(pX->xfertimer);

	if ((stime = ttime / 10L) != pX->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		bytes_sent = pX->file_bytes + pX->total_bytes;

		if (bittest(status, TRANSFER_DONE))
			k_sent = (int)PART_HUNKS(bytes_sent, 1024);
		else
			k_sent = (int)FULL_HUNKS(bytes_sent, 1024);

		if ((stime > 2 ||
			 ttime > 0 && bittest(status, FILE_DONE | TRANSFER_DONE)) &&
			(cps = (bytes_sent * 10L) / ttime) > 0)
			{
			if (pX->nbytes > 0)
				{
				etime = ((pX->nbytes - bytes_sent) / cps);
				if (pX->nfiles > 0)
					etime += pX->nfiles - pX->filen;
				}
			else if (pX->filesize > 0)
				{
				etime = ((pX->filesize - pX->file_bytes) / cps);
				}
			}
		pX->displayed_time = stime;

		mdmxdspProgress(pX,
						stime,
						etime,
						cps,
						pX->file_bytes,
						bytes_sent);

		}
	}


/* end of mdmx.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\krm.hh ===
/* File: C:\WACKER\xfer\krm.hh (Created: 28-Jan-1994)
 * created from HAWIN source file
 * krm.hh  --  Internal definitions for KERMIT file transfer
 *					protocol routines.
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 4/24/02 3:36p $
 */

#define	Dbg(a,b)
#define	DbgW(a,b,c)
#define	DbgWW(a,b,c,d)
#define	DbgWWW(a,b,c,d,e)
#define	DbgL(a,b,c)

#if defined(ERROR)
#undef	ERROR
#endif
#define ERROR		  (-1)

#if !defined(MAXLINE)
#define	MAXLINE	130
#endif
#if !defined(DEL)
#define	DEL	0177
#endif

#define MAXPCKT 100 		/* maximum length for packet data */
#define K_QCTL '#'
#define K_QBIN '&'
#define K_REPT '~'
#define K_CHK1 1
#define K_CHK2 2
#define K_CHK3 3
#define CAPMASK_ATTR 0x08

#define tochar(ch) ((ch) + ' ')
#define unchar(ch) ((ch) - ' ')
#define ctl(ch) ((ch) ^ 0x40)

/* valid packet types include 'Y', 'N', 'S, 'I', 'F', 'A', 'D', 'Z',
 *	'B', 'E', 'R', 'C', 'K', 'T', 'G'
 *	plus special types returned by rec_packet():
 */
#define BAD_PACKET	'\030'

/* Kermit receive states */
#define KREC_INIT 0
#define KREC_FILE 1
#define KREC_DATA 2
#define KREC_COMPLETE 3
#define KREC_ABORT 4

/* Kermit packet error codes */
#define KE_NOERROR 0
#define KE_TIMEOUT 1
#define KE_NAK 2
#define KE_BAD_PACKET 3
#define KE_RMTERR 4
#define KE_WRONG 5
#define KE_REPEAT 6
#define KE_SEQUENCE 7
#define KE_FATAL 8

/* Kermit abort codes */
#define KA_OK			 0
#define KA_LABORT1		 1
#define KA_RABORT1		 2
#define KA_LABORTALL	 3
#define KA_RABORTALL	 4
#define KA_IMMEDIATE	 5
#define KA_RMTERR		 6
#define KA_LOST_CARRIER  7
#define KA_ERRLIMIT 	 8
#define KA_OUT_OF_SEQ	 9
#define KA_BAD_FORMAT	10
#define KA_TOO_MANY 	11
#define KA_CANT_OPEN	12
#define KA_DISK_FULL	13
#define KA_DISK_ERROR	14
#define KA_OLDER_FILE	15
#define KA_NO_FILETIME	16
#define KA_WONT_CANCEL	17
#define KA_VIRUS_DETECT 18
#define	KA_USER_REFUSED 19

/* progress display codes */
#define FILE_DONE		1
#define TRANSFER_DONE	2

#define KPCKT struct _kpckt
KPCKT
	{
	unsigned char pmark;
	unsigned char plen;
	unsigned char pseq;
	unsigned char ptype;
	unsigned char pdata[MAXPCKT];
	int datalen;
	};

struct s_krm_rcv_control
	{
	int 	  files_received;
	int 	  files_aborted;
	int 	  oldtries;
	int 	  dsptries;
	int 	  total_tries;
	long	  bytes_expected;
	int 	  size_known;
	int 	  lasterr;
	unsigned char  uabort_code;
	int 	  data_packet_rcvd;
	int 	  store_later;

	// struct	  s_filetime compare_time;
	unsigned long ul_compare_time;
	// struct	  s_filetime filetime;

	unsigned long ul_filetime;
	int 	  next_rtype;
	int 	  next_plen;
	int 	  next_rseq;
	unsigned char  next_packet[MAXPCKT];
	KPCKT	  resp_pckt;
	};

typedef struct s_krm_rcv_control ST_R_KRM;

typedef struct s_krm_control ST_KRM;

struct s_krm_control
	{
	HSESSION hSession;
	HCOM	 hCom;
	ST_IOBUF *fhdl;
	long   basesize;
	int    ksequence;
	int    packetnum;
	int    tries;
	int    abort_code;
	void * flagkey_hdl;
	long   xfertime;
	char   xtra_err[MAXLINE];
	char   their_fname[MAXPCKT];
	TCHAR   our_fname[FNAME_LEN];
	long   total_dsp;
	long   total_thru;
	long   nbytes;
	int    file_cnt;
	int    files_done;
	int    its_maxl;
	int    its_timeout;
	int    its_npad;
	unsigned char  its_padc;
	unsigned char  its_eol;
	unsigned char  its_chkt;
	unsigned char  its_qctl;
	unsigned char  its_qbin;
	unsigned char  its_rept;
	int    its_capat;
	int    fname_width;

	/* These used to be globals */
	int           k_useattr; 			/* send 'normalized' file names ? */
	int	          k_maxl;				/* maximum packet length we'll take */
	int	          k_timeout; 			/* time they should wait for us */
	unsigned char k_chkt;				/* check type we want to use */
	int	          k_retries; 			/* no. of retries */
	unsigned char k_markchar;			/* first char of each packet */
	unsigned char k_eol; 				/* end of line character for packets */
	int           k_npad;		  		/* no. of pad chars. to send us */
	unsigned char k_padc;				/* pad char. we want */
	 unsigned     total_retries;
	long          displayed_time;

	ST_R_KRM	kr;						/* receive control structure */

	/* variables for sending and receiving */
	KPCKT		*this_kpckt;
	KPCKT		*next_kpckt;
	long		kbytes_sent;
	int			(*p_kputc)(ST_KRM *p, int c);
	long		kbytes_received;
	int			(*p_kgetc)(ST_KRM *p);
	void		(*KrmProgress)(ST_KRM *p, int n);
	};

// extern int	 krm_dbg;	/* used for real-time debugging using dbg.c */

// extern struct s_krm_control FAR *kc;
// extern void (NEARF *KrmProgress)(HSESSION, bits);

// variables for receiving
// extern struct s_krm_rcv_control FAR *krc;
// extern metachar (NEAR *p_kputc)(metachar);
// extern long kbytes_received;

// variables for sending
// extern metachar (NEAR *p_kgetc)(void);
// extern long kbytes_sent;


extern unsigned  ke_msg[];			 /* packet error messages */
extern int		 kresult_code[];	 /* result codes */


/* function prototypes: */
extern void krm_box(int p_toprow,
					int p_leftcol,
					int p_botmrow,
					int p_rightcol);

extern void krm_box_remove(void);

extern void krmGetParameters(ST_KRM *kc);

extern void	ksend_packet(ST_KRM *hK,
							unsigned char type,
							unsigned dlength,
							int seq,
							KPCKT FAR *pckt);

extern int krec_packet(ST_KRM *hK,
						int *len,
						int *seq,
						unsigned char *data);

extern int buildparams(ST_KRM *hK,
						int initiating,
						unsigned char *bufr);

extern void getparams(ST_KRM *hK,
						int initiating,
						unsigned char *bufr);

extern void ks_progress(ST_KRM *hK, int status);
extern int krec_init(ST_KRM *hK);
extern int krec_file(ST_KRM *hK);
extern int krec_data(ST_KRM *hK);
extern void kr_progress(ST_KRM *hK, int status);

extern int kunload_packet(ST_KRM *hK,
						int len,
						unsigned char *bufr);

extern int kr_putc(ST_KRM *kc, int c);

extern void krm_rcheck(ST_KRM *hK, int before);
extern void krm_check_input(int suspend);

extern void kunload_attributes(ST_KRM *hK,
								unsigned char *data,
								KPCKT FAR *rsp_pckt);

extern void krm_settime(unsigned char *data, unsigned long *pl);

extern int kload_packet(ST_KRM *hK,
						unsigned char *bufr);

extern int ks_getc(ST_KRM *kc);

/************************** end of krm.hh *****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\krm_rcv.c ===
/* File: C:\WACKER\xfer\krm_rcv.c (Created: 28-Jan-1994)
 * created from HAWIN source file
 * krm_rcv.c  --  Routines for handling file transmission using KERMIT
 *				file transfer protocol.
 *
 *	Copyright 1989,1990,1991,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 7/11/02 11:10a $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>
#include <stdlib.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <term\res.h>
#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>
#include <tdll\session.h>
#include <tdll\htchar.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"
#include "itime.h"
#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "krm.h"
#include "krm.hh"

// struct s_krm_rcv_control FAR *krc;
// metachar (NEAR *p_kputc)(metachar);
// long kbytes_received;

// #define	DO_DATE(hS)		((xfer_flags(hS)&XF_USE_DATETIME)!=0L)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krm_rcv
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int krm_rcv(HSESSION hS, int attended, int single_file)
	{
	ST_KRM *kc;
	unsigned total_retries;
	unsigned uabort_seq = 0;
	int 	 kr_state;
	int		 iret;

	kc = NULL;

	kc = malloc(sizeof(*kc));
	if (kc == NULL)
		{
		xferMsgClose(hS);
		return TSC_NO_MEM;
		}

	kc->hSession = hS;
	kc->hCom = sessQueryComHdl(hS);

	kc->kbytes_received = 0;

	krmGetParameters(kc);

	kc->KrmProgress = kr_progress;

	kc->fhdl = NULL;
	kc->total_thru = 0L;
	kc->its_maxl = 80;
	kc->its_timeout = 10;
	kc->its_npad = 0;
	kc->its_padc = '\0';
	kc->its_eol = '\r';
	kc->its_chkt = 1;
	kc->its_qctl = K_QCTL;
	kc->its_qbin = '\0';
	kc->its_rept = '\0';
	kc->its_capat = FALSE;
	kc->files_done = 0;

	kc->xfertime = -1L;
	kc->kr.files_received = kc->kr.files_aborted = 0;
	kr_state = KREC_INIT;
	kc->ksequence = 0;
	kc->packetnum = 1;
	kc->tries = total_retries = 0;
	kc->kr.lasterr = KE_NOERROR;
	kc->abort_code = KA_OK;
	kc->kr.uabort_code = '\0';
	kc->kr.data_packet_rcvd = FALSE;
	kc->kr.dsptries = 0;
	kc->kr.store_later = FALSE;

	/* normally, the sender initiates a transfer, but if we're the terminal
	 *	end of the transfer, we may be able to get the sender to start up
	 *	without waiting for a timeout by sending a NAK packet as soon as we
	 *	start up.
	 */
	ksend_packet(kc, 'N', 0, kc->ksequence, &kc->kr.resp_pckt);

	for ( ; ; )
		{
		xfer_idle(kc->hSession, XFER_IDLE_IO);

		switch(kr_state)
			{
		case KREC_INIT:
			kr_state = krec_init(kc);
			if (kr_state == KREC_FILE)
				{
				/* clear init errors */

				xferMsgErrorcnt(kc->hSession, total_retries = 0);
				xferMsgLasterror(kc->hSession, 0);
				}
			break;

		case KREC_FILE:
			kc->kr.data_packet_rcvd = FALSE;
			kc->kr.next_rtype = '\0';   /* init for krec_data routine */
			kr_state = krec_file(kc);
			if (!kc->tries && kr_state == KREC_DATA)
				{
				xferMsgNewfile(kc->hSession,
							   ++kc->files_done,
							   kc->their_fname,
							   kc->our_fname);
				}
			break;

		case KREC_DATA:
			kr_state = krec_data(kc);
			if ((kc->kr.uabort_code == 'Z') &&
				(uabort_seq > (unsigned)(kc->packetnum + 3)))
				kr_state = KREC_ABORT;
			break;

		case KREC_COMPLETE:
			{
			int kret;
			kret = kresult_code[kc->abort_code];
			free(kc);
			kc = NULL;
			xferMsgClose(hS);
			return(kret);
			}
			/*lint -unreachable*/
			break;

		case KREC_ABORT:
			{
			int kret;

			xferMsgLasterror(kc->hSession, kc->kr.lasterr);

			if (kc->fhdl != NULL)
				xfer_close_rcv_file(hS,
									kc->fhdl,
									kresult_code[kc->abort_code],
									kc->their_fname,
									kc->our_fname,
									FALSE,
									0L,
									0);

			kret = kresult_code[kc->abort_code];
			free(kc);
			kc = NULL;
			xferMsgClose(hS);
			return(kret);
			}
			/*lint -unreachable*/
			break;

		default:
			assert(FALSE);
			break;
			}

		xferMsgPacketErrcnt(kc->hSession,
							kc->kr.dsptries ? kc->kr.dsptries : kc->tries);

		if (kc->tries || kc->kr.dsptries)
		 	{
			xferMsgErrorcnt(kc->hSession, ++kc->total_retries);
			xferMsgLasterror(kc->hSession, kc->kr.lasterr);

			kc->kr.dsptries = 0;
			}
		else
			xferMsgPacketnumber(kc->hSession, kc->packetnum);

		/* check for keyboard abort */
		if (iret = xfer_user_interrupt(kc->hSession))
			{
			if (iret == XFER_ABORT)
				{
				if (kc->kr.uabort_code)	 /* not the first time */
					{
					kc->abort_code = KA_IMMEDIATE;
					kr_state = KREC_ABORT;
					}
				else				/* start user abort process */
					{
					if (single_file)
						kc->kr.uabort_code = 'Z';
					else
						kc->kr.uabort_code = 'X';

					/* force it */
					kc->kr.uabort_code = 'Z';

					uabort_seq = kc->packetnum;
					kc->abort_code = (kc->kr.uabort_code == 'X' ?
							KA_LABORT1 : KA_LABORTALL);
					}
				}
			else
				{
				if (kc->kr.uabort_code == 0)
					{
					kc->kr.uabort_code = 'X';
					uabort_seq = kc->packetnum;
					kc->abort_code = KA_LABORT1;
					}
				}
			}

		if (xfer_carrier_lost(kc->hSession))
			{
			kc->abort_code = KA_LOST_CARRIER;
			kr_state = KREC_ABORT;
			}
		}

	/*lint -unreachable*/
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krec_init
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int krec_init(ST_KRM *kc)
	{
	int rtype;
	int plen, rseq;
	unsigned slen;
	unsigned char packet[MAXPCKT];
	unsigned char tchkt;

	if (kc->tries++ > kc->k_retries)
		{
		kc->abort_code = KA_ERRLIMIT ;
		return(KREC_ABORT);
		}
	switch (rtype = krec_packet(kc, &plen, &rseq, packet))
		{
	case 'S':
		kc->xfertime = (long)startinterval();
		getparams(kc, FALSE, packet);
		slen = (unsigned)buildparams(kc, FALSE, kc->kr.resp_pckt.pdata);
		tchkt = kc->its_chkt;
		kc->its_chkt = 1;	  /* response must use checktype 1 */
		ksend_packet(kc, 'Y', slen, kc->ksequence, &kc->kr.resp_pckt);
		kc->its_chkt = tchkt;
		kc->kr.oldtries = kc->tries;
		kc->tries = 0;
		kc->ksequence = (kc->ksequence + 1) % 64;
		++kc->packetnum;
		return(KREC_FILE);
		/*lint -unreachable*/
		break;

	case 'T':
	case BAD_PACKET:
		kc->kr.lasterr = (rtype == 'T' ? KE_TIMEOUT : KE_BAD_PACKET);
		ksend_packet(kc, 'N', 0, kc->ksequence, &kc->kr.resp_pckt);
		return(KREC_INIT);	/* try again */
		/*lint -unreachable*/
		break;

	case 'E':
		kc->kr.lasterr = KE_RMTERR;
		StrCharCopyN(kc->xtra_err, packet, MAXLINE);
		kc->abort_code = KA_RMTERR;
		return(KREC_ABORT);
		/*lint -unreachable*/
		break;

	default:
		kc->kr.lasterr = KE_WRONG;
		kc->abort_code = KA_BAD_FORMAT;
		return(KREC_ABORT);
		/*lint -unreachable*/
		break;
		}
	/*lint -unreachable*/
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krec_file
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int krec_file(ST_KRM *kc)
	{
	int rtype;
	int plen, rseq;
	unsigned slen;
	int result;
	unsigned char packet[MAXPCKT];
	struct st_rcv_open stRcv;
	// struct fn_parts fns;
	// int disk;

	if (kc->tries++ > kc->k_retries)
		{
		kc->abort_code = KA_ERRLIMIT ;
		return(KREC_ABORT);
		}
	rtype = krec_packet(kc, &plen, &rseq, packet);
	if (kc->kr.store_later && (rtype != 'B' || rseq != kc->ksequence))
		{
		/* if kc->kr.store_later is TRUE, it means a file has been received
		 *	 but it hasn't been closed yet to allow us to come here and
		 *	 see if we should stop the transfer timer before closing and
		 *	 logging the file. If the transfer isn't over, take care of
		 *	 the last file.
		 */
		// bf_setcheck(NULL);

		xfer_close_rcv_file(kc->hSession,
							kc->fhdl,
							TSC_OK,
							kc->their_fname,
							kc->our_fname,
							FALSE,
							kc->basesize + kc->kbytes_received,
							kc->k_useattr ? kc->kr.ul_filetime : 0);

		kc->kr.store_later = FALSE;
		kc->total_thru += kc->kbytes_received;
		kc->kbytes_received = 0;
		}

	switch (rtype)
		{
	case 'F':
		if (rseq != kc->ksequence)
			{
			kc->kr.lasterr = KE_SEQUENCE;
			kc->abort_code = KA_OUT_OF_SEQ;
			return(KREC_ABORT);
			}
		StrCharCopyN(kc->their_fname, packet, MAXPCKT);

		stRcv.pszSuggestedName = kc->their_fname;
		stRcv.pszActualName = kc->our_fname;

		kc->kr.ul_compare_time = 0;

		xfer_build_rcv_name(kc->hSession, &stRcv);

		result = xfer_open_rcv_file(kc->hSession, &stRcv, 0L);

		if (result != 0)
			{
			unsigned char buffer[64];

			LoadString(glblQueryDllHinst(),
						IDS_TM_KRM_CANT_OPEN,
						buffer, sizeof(buffer) / sizeof(TCHAR));
			StrCharCopyN(kc->kr.resp_pckt.pdata, buffer, MAXPCKT);
			ksend_packet(kc, 'E', StrCharGetByteCount(kc->kr.resp_pckt.pdata),
					kc->ksequence,
					&kc->kr.resp_pckt);
			kc->kr.lasterr = KE_FATAL;
			switch (result)
			{
			case -6:
				kc->abort_code = KA_USER_REFUSED;
				break;
			case -5:
				kc->abort_code = KA_CANT_OPEN;
				break;
			case -4:
				kc->abort_code = KA_NO_FILETIME;
				break;
			case -3:
				kc->abort_code = KA_TOO_MANY;
				break;
			case -2:
				kc->abort_code = KA_OLDER_FILE;
				break;
			case -1:
			default:
				kc->abort_code = KA_DISK_ERROR;
				break;
			}
			return(KREC_ABORT);
			}
		kc->fhdl = stRcv.bfHdl;
		kc->basesize = stRcv.lInitialSize;

		/* return our file name in Y packet */
		StrCharCopyN(kc->kr.resp_pckt.pdata, kc->our_fname, MAXPCKT);
		ksend_packet(kc, 'Y', StrCharGetByteCount(kc->our_fname), kc->ksequence,
				&kc->kr.resp_pckt);

		kc->kr.oldtries = kc->tries;
		kc->tries = 0;
		kc->ksequence = (kc->ksequence + 1) % 64;
		++kc->packetnum;
		kc->kr.ul_filetime = 0;			/* no date received yet */
		kc->kr.size_known = FALSE;

		kc->kbytes_received = 0L;
		kc->p_kputc = kr_putc;
		return(KREC_DATA);
		/*lint -unreachable*/
		break;

	case 'B':	/* end of batch */
		if (rseq != kc->ksequence)
			{
			kc->kr.lasterr = KE_SEQUENCE;
			kc->abort_code = KA_OUT_OF_SEQ;
			return(KREC_ABORT);
			}
		ksend_packet(kc, 'Y', 0, kc->ksequence, &kc->kr.resp_pckt);
		kc->xfertime = (long)interval(kc->xfertime);
		kr_progress(kc, TRANSFER_DONE);
		//hp_report_xtime((unsigned)(kc->xfertime / 10L));
		if (kc->kr.store_later)
			{
			/* This stuff is here to allow us to stop the transfer timer
			   before spending time closing the last file and logging the
			   transfer.
			*/
			//bf_setcheck(NULL);

			xfer_close_rcv_file(kc->hSession,
								kc->fhdl,
								TSC_OK,
								kc->their_fname,
								kc->our_fname,
								FALSE,
								kc->basesize + kc->kbytes_received,
								kc->k_useattr ? kc->kr.ul_filetime : 0);

			kc->kr.store_later = FALSE;
			kc->total_thru += kc->kbytes_received;
			kc->kbytes_received = 0;
			}
		kc->tries = 0;
		return(KREC_COMPLETE);
		/*lint -unreachable*/
		break;

	case 'S':	/* received another send init packet, maybe they missed ACK */
		if (kc->kr.oldtries++ > kc->k_retries)
			{
			kc->abort_code = KA_ERRLIMIT ;
			return(KREC_ABORT);
			}
		if (rseq == ((kc->ksequence == 0) ? 63 : kc->ksequence - 1))
			{
			slen = (unsigned)buildparams(kc, FALSE, kc->kr.resp_pckt.pdata);
			ksend_packet(kc, 'Y', slen, rseq, &kc->kr.resp_pckt);
			kc->tries = 0;
			kc->kr.dsptries = kc->kr.oldtries;
			kc->kr.lasterr = KE_REPEAT;
			return(KREC_FILE);
			}
		else
			{
			kc->kr.lasterr = KE_WRONG;
			kc->abort_code = KA_BAD_FORMAT;
			return(KREC_ABORT);
			}
		/*lint -unreachable*/
		break;

	case 'Z':
		if (kc->kr.oldtries++ > kc->k_retries)
			{
			kc->abort_code = KA_ERRLIMIT ;
			return(KREC_ABORT);
			}
		if (rseq == ((kc->ksequence == 0) ? 63 : kc->ksequence - 1))
			{
			ksend_packet(kc, 'Y', 0, rseq, &kc->kr.resp_pckt);
			kc->tries = 0;
			kc->kr.dsptries = kc->kr.oldtries;
			kc->kr.lasterr = KE_REPEAT;
			return(KREC_FILE);
			}
		else
			{
			kc->abort_code = KA_BAD_FORMAT;
			kc->kr.lasterr = KE_WRONG;
			return(KREC_ABORT);
			}
		/*lint -unreachable*/
		break;

	case 'T':
	case BAD_PACKET:
		kc->kr.lasterr = (rtype == 'T' ? KE_TIMEOUT : KE_BAD_PACKET);
		ksend_packet(kc, 'N', 0, kc->ksequence, &kc->kr.resp_pckt);
		return(KREC_FILE);	/* try again */
		/*lint -unreachable*/
		break;

	case 'E':
		kc->kr.lasterr = KE_RMTERR;
		StrCharCopyN(kc->xtra_err, packet, MAXLINE);
		kc->abort_code = KA_RMTERR;
		return(KREC_ABORT);
		/*lint -unreachable*/
		break;

	default:
		kc->kr.lasterr = KE_WRONG;
		kc->abort_code = KA_BAD_FORMAT;
		return(KREC_ABORT);
		/*lint -unreachable*/
		break;
		}
	/*lint -unreachable*/
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krec_data
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int krec_data(ST_KRM *kc)
	{
	int rtype;
	int kplen, krseq;
	unsigned char packet[MAXPCKT];

	if (kc->tries++ > kc->k_retries)
		{
		kc->abort_code = KA_ERRLIMIT;
		return(KREC_ABORT);
		}
	if (kc->kr.next_rtype == '\0')
		rtype = krec_packet(kc, &kplen, &krseq, packet);
	else
		{
		rtype = kc->kr.next_rtype;
		kplen = kc->kr.next_plen;
		krseq = kc->kr.next_rseq;
		MemCopy(packet, kc->kr.next_packet, (unsigned)MAXPCKT);
		kc->kr.next_rtype = '\0';
		}
	switch (rtype)
		{
	case 'A':					/* attribute packet */
	case 'D':					/* data packet		*/
		if (krseq != kc->ksequence)
			{
			if (kc->kr.oldtries++ > kc->k_retries)
				{
				kc->abort_code = KA_ERRLIMIT;
				return(KREC_ABORT);
				}
			if (krseq == ((kc->ksequence == 0) ? 63 : kc->ksequence - 1))
				{
				ksend_packet(kc, 'Y', 0, krseq, &kc->kr.resp_pckt);
				kc->tries = 0;
				kc->kr.dsptries = kc->kr.oldtries;
				kc->kr.lasterr = KE_REPEAT;
				return(KREC_DATA);
				}
			else
				{
				kc->abort_code = KA_OUT_OF_SEQ;
				return(KREC_ABORT);
				}
			}
		if (rtype == 'D')
			{
			/* got good data */

			/* If the /N option is being used, and an older file is being
			 *	received, a request was made to reject the file in the
			 *	response to the attribute packet. If a data packet comes
			 *	in anyway it means the sender failed to respond appropriately
			 *	and we must abort the transfer.
			 */
			if (kc->kr.uabort_code == 'N')
				{
				kc->abort_code = KA_WONT_CANCEL;
				return(KREC_ABORT);
				}

			/* If there is a compare_time still specified, it means the /N
			 *	option was specified but the sender failed to include an
			 *	attribute packet with a filetime. We must abort the transfer
			 */
			if (kc->kr.ul_compare_time != 0)
				{
				kc->abort_code = KA_NO_FILETIME;
				return(KREC_ABORT);
				}

			/* check for pending kbd abort and inlcude 'Z' or 'X' in packet */
			kc->kr.data_packet_rcvd = TRUE;
			kc->kr.resp_pckt.pdata[0] = kc->kr.uabort_code;
			ksend_packet(kc, 'Y', kc->kr.uabort_code ? 1 : 0, kc->ksequence,
					&kc->kr.resp_pckt);
			kr_progress(kc, 0);
			if (kunload_packet(kc, kplen, packet) == ERROR)
				{	/* storage file error */
				kc->kr.lasterr = KE_FATAL;
				kc->abort_code = KA_DISK_ERROR;
				LoadString(glblQueryDllHinst(),
							IDS_TM_KRM_CANT_WRITE,
							kc->xtra_err, sizeof(kc->xtra_err) / sizeof(TCHAR));
				/* we're already sent response to this packet, wait & send
					error packet with next packet number */
				Sleep((DWORD)1000);
				StrCharCopyN(kc->kr.resp_pckt.pdata, kc->xtra_err, MAXPCKT);
				ksend_packet(kc, 'E',
						StrCharGetByteCount(kc->kr.resp_pckt.pdata),
						(kc->ksequence + 1) % 64, &kc->kr.resp_pckt);
				return(KREC_ABORT);
				}

			}
		else if (rtype == 'A')
			{
			if (kc->kr.data_packet_rcvd) /* all 'A' packets must precede 'D' packets */
				{
				kc->kr.lasterr = KE_WRONG;
				kc->abort_code = KA_BAD_FORMAT;
				return(KREC_ABORT);
				}
			// strblank(kc->kr.resp_pckt.pdata);
			kc->kr.resp_pckt.pdata[0] = TEXT('\0');
			kunload_attributes(kc, packet, &kc->kr.resp_pckt);
			ksend_packet(kc, 'Y',
						StrCharGetByteCount(kc->kr.resp_pckt.pdata),
						kc->ksequence,
						&kc->kr.resp_pckt);
			}
		kc->kr.oldtries = kc->tries;
		kc->tries = 0;
		kc->ksequence = (kc->ksequence + 1) % 64;
		++kc->packetnum;
		return(KREC_DATA);
		/*lint -unreachable*/
		break;

	case 'Z':	/* end of file */
		if (krseq != kc->ksequence)
			{
			kc->kr.lasterr = KE_WRONG;
			kc->abort_code = KA_OUT_OF_SEQ;
			return(KREC_ABORT);
			}
		if (strcmp(packet, "D") == 0) /* discard file? */
			{
			if (!kc->kr.uabort_code)
				kc->abort_code = KA_RABORT1;

			xfer_close_rcv_file(kc->hSession,
								kc->fhdl,
								kresult_code[kc->abort_code],
								kc->their_fname,
								kc->our_fname,
								FALSE,
								0L,
								kc->k_useattr ? kc->kr.ul_filetime : 0);

			kc->total_thru += kc->kbytes_received;
			kc->kbytes_received = 0;
			++kc->kr.files_aborted;
			}
		else
			{
			/* file has been received */
			kr_progress(kc, FILE_DONE);
			++kc->kr.files_received;

			/* if all is well, hold off on closing file and logging tranfer
			 * until after the next packet is in. This way we can stop the
			 * transfer timer earlier
			 */
			if (kc->abort_code == KA_OK)
				kc->kr.store_later = TRUE;
			else
				{
				xfer_close_rcv_file(kc->hSession,
									kc->fhdl,
									kresult_code[kc->abort_code],
									kc->their_fname,
									kc->our_fname,
									FALSE,
									kc->basesize + kc->kbytes_received,
									kc->k_useattr ? kc->kr.ul_filetime : 0);

				kc->total_thru += kc->kbytes_received;
				kc->kbytes_received = 0;
				}
			}

		ksend_packet(kc, 'Y', 0, kc->ksequence, &kc->kr.resp_pckt);
		if (kc->kr.uabort_code == 'X' || kc->kr.uabort_code == 'N')
			kc->kr.uabort_code = '\0', kc->abort_code = KA_OK;
		kc->kr.oldtries = kc->tries;
		kc->tries = 0;
		kc->ksequence = (kc->ksequence + 1) % 64;
		++kc->packetnum;
		return(KREC_FILE);
		/*lint -unreachable*/
		break;
	case 'F':		/* receiving file name again? */
		if (kc->kr.oldtries++ > kc->k_retries)
			{
			kc->abort_code = KA_ERRLIMIT;
			return(KREC_ABORT);
			}
		if (krseq == ((kc->ksequence == 0) ? 63 : kc->ksequence - 1))
			{
			StrCharCopyN(kc->kr.resp_pckt.pdata, kc->our_fname, MAXPCKT);
			ksend_packet(kc, 'Y',
						StrCharGetByteCount(kc->our_fname),
						krseq,
						&kc->kr.resp_pckt);
			kc->tries = 0;
			kc->kr.lasterr = KE_REPEAT;
			kc->kr.dsptries = kc->kr.oldtries;
			return(KREC_DATA);
			}
		else
			{
			kc->kr.lasterr = KE_WRONG;
			kc->abort_code = KA_BAD_FORMAT;
			return(KREC_ABORT);
			}
		/*lint -unreachable*/
		break;

/* account for repeated 'X' packet here */
	case 'T':
	case BAD_PACKET:
		kc->kr.lasterr = (rtype == 'T' ? KE_TIMEOUT : KE_BAD_PACKET);
		ksend_packet(kc, 'N', 0, kc->ksequence, &kc->kr.resp_pckt);
		return(KREC_DATA);	/* try again */
		/*lint -unreachable*/
		break;

	case 'E':
		kc->kr.lasterr = KE_RMTERR;
		StrCharCopyN(kc->xtra_err, packet, MAXLINE);
		kc->abort_code = KA_RMTERR;
		return(KREC_ABORT);
		/*lint -unreachable*/
		break;

	default:
		kc->kr.lasterr = KE_WRONG;
		kc->abort_code = KA_BAD_FORMAT;
		return(KREC_ABORT);
		/*lint -unreachable*/
		break;
		}
	/*lint -unreachable*/
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * kr_progress
 *
 * DESCRIPTION:
 *	Displays transfer progress indicators for Kermit receive
 *
 * ARGUMENTS:
 *	final -- TRUE if final display for a file.
 *
 * RETURNS:
 *	nothing
 */
void kr_progress(ST_KRM *kc, int status)
	{
	long ttime, stime;
	long bytes_rcvd;
	long cps;
	int  k_rcvd;
	long krm_stime = -1;
	long krm_ttime = -1;
	long krm_cps = -1;
	long krm_file_so_far = -1;
	long krm_total_so_far = -1;

	if (kc->xfertime == -1L)
		return;
	ttime = bittest(status, TRANSFER_DONE) ?
			kc->xfertime : (long)interval(kc->xfertime);
	if ((stime = ttime / 10L) != kc->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		krm_stime = stime;

		bytes_rcvd = kc->total_thru + kc->kbytes_received;
		if (bittest(status, FILE_DONE | TRANSFER_DONE))
			k_rcvd = (int)PART_HUNKS(bytes_rcvd, 1024);
		else
			k_rcvd = (int)FULL_HUNKS(bytes_rcvd, 1024);

		krm_total_so_far = k_rcvd;

		krm_file_so_far = kc->kbytes_received;

		if (stime > 0 && (cps = (bytes_rcvd * 10L) / ttime) > 0)
			{
			krm_cps = cps;

			if ((kc->kr.bytes_expected > 0))
				{
				ttime = (kc->kr.bytes_expected - kc->kbytes_received) / cps;

				krm_ttime = ttime;
				}
			}
		kc->displayed_time = stime;
		}

		xferMsgProgress(kc->hSession,
						krm_stime,
						krm_ttime,
						krm_cps,
						krm_file_so_far,
						krm_total_so_far);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krm_rcheck
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
#if 0
void krm_rcheck(HSESSION hS, bool before)
	{
	if (before)
		{
		/* wait till next packet is in before writing to disk */
		Dbg(krm_dbg, D_KRM_RCHECK);
		kc->kr.next_rtype = krec_packet(hS, &kc->kr.next_plen, &kc->kr.next_rseq,
				kc->kr.next_packet);
		}
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krm_check_input
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 *
 */
#if 0
void krm_check_input(bool suspend)
	{
	int disk;
	struct fn_parts fns;
	static USHORT old_ovr;
		   USHORT new_ovr;

	if (suspend)
		{
		(VOID)mComGetErrors(comhdl, FALSE, NULL, &old_ovr, NULL, NULL);
		}
	else
		{
		(VOID)mComGetErrors(comhdl, FALSE, NULL, &new_ovr, NULL, NULL);
		if (new_ovr > old_ovr)
			{
			/*
			 * Got an error.  Make sure things are taken care of
			 * so that we don't get any more errors.
			 */
			if (kc->fhdl != NULL)
				{
				/* only do this if it might have been our file I/O */
				bf_setcheck(NULL);
				bf_setcheck(krm_rcheck);
				fl_dissect_fn(bf_name(kc->fhdl), &fns);
				disk = (fns.fn_drv[0] - 'A') & 0x1F;
				transfer_setspeed(disk, cnfg.bit_rate);
				}
			}
		}
	}
#endif


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * kunload_attributes
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void kunload_attributes(ST_KRM *kc, unsigned char *data, KPCKT *rsp_pckt)
	{
	unsigned char *limit = data + StrCharGetByteCount(data);
	unsigned len;
	unsigned char attrfield[20];

	while (data <= limit - 2)
		{
		len = (unsigned char)unchar(data[1]);
		if ((data + len + 1) >= limit)
			break;

		if (len <= sizeof(attrfield) - 1)
			{
			strncpy(attrfield, data + 2, len);
			attrfield[len] = '\0';
			switch (*data)
				{
			case '0':
				break;

			case '1':
				/* This attribute gives an exact byte count of a file as it
				 *	it was stored on the senders system. This is what we need
				 *	to display a vu_meter etc. as the file is received
				 *	(There is also a '!' field available that contains the
				 *	filesize expressed in K. We don't currently use that
				 *	field.
				 */
				if ((kc->kr.bytes_expected = atol(attrfield)) > 0)
					{
					kc->kr.size_known = TRUE;

					xferMsgFilesize(kc->hSession, kc->kr.bytes_expected);
					}
				break;

			case '#':
				/* This field specifies the creation date of the file on the
				 * senders system, expressed as "[yy]yymmdd[ hh:mm[:ss]]".
				 * We use this for two things: If the user has asked us to use
				 * received attributes, we set the time/date of the new file
				 * based on this field. If the user specified the /N receive
				 * option, we compare this received file time with the filetime
				 * of any existing file of the same name and reject the file
				 * unless the incoming file is newer.
				 */

				/* extract date/time from the packet data field */
				krm_settime(attrfield, &kc->kr.ul_filetime);

				/* if kc->kr.compare_time contains a valid date/time, it means
				 *	that the /N option was used and the file being received
				 *	already exists. Compare the two times and reject any file
				 *	that is not newer than what we already have.
				 */
				if (kc->kr.ul_compare_time != 0)
					{
					/* if incoming file (kc->kr.filetime) <= existing file
					 * (kc->kr.compare_time), reject the file
					 */
					if (kc->kr.ul_filetime <= kc->kr.ul_compare_time)
						{
						/* reject incoming file */
						StrCharCopyN(rsp_pckt->pdata, "N#", MAXPCKT);
						kc->kr.uabort_code = 'N';
						kc->abort_code = KA_OLDER_FILE;
						}
					else
						{
						/* clear compare_time or transfer would fail when
						 * first data packet is received
						 */
						kc->kr.ul_compare_time = 0;
						}
					}

				/* user may opt not to use received file time/date */
				if (!kc->k_useattr)
					kc->kr.ul_filetime = 0;
				break;

			default :
				/* ignore */
				break;
				}
			}
		data += (len + 2);
		}
	}

#define atoc(c) ((c) - (CHAR)'0')
#define	isadigit(x)	((x >= '0') && (x <= '9'))

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krm_settime
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void krm_settime(unsigned char *data, unsigned long *ptime)
	{
	unsigned long ltime;
	struct tm sT;
	unsigned char *datestr = data;
	unsigned char *timestr = NULL;
	char ch;
	int s;
	unsigned i;
	unsigned sl;

	sT.tm_year = sT.tm_hour = -1;

	if ((sl = StrCharGetByteCount(data)) > 7 && data[6] == ' ')
		{
		data[6] = '\0';
		timestr = &data[7];
		}
	else if (sl > 9 && data[8] == ' ')
		{
		data[8] = '\0';
		timestr = &data[9];
		}
	/* try to get date */
	if ((sl = StrCharGetByteCount(datestr)) == 6 || sl == 8)
		{
		for (i = 0; i < sl; ++i)
			if (!isadigit(datestr[i]))
				break;
		if (i == sl)
			{
			if (sl == 8)
				{
				ch = atoc(datestr[0]);
				s = (int)ch;
				sT.tm_year = s * 1000;
				sT.tm_year += ((int)atoc(datestr[1]) * 100);
				datestr += 2;
				}
			else
				{
				sT.tm_year = 1900;
				}
			sT.tm_year += (atoc(datestr[0]) * 10 + atoc(datestr[1]));
			sT.tm_mon = atoc(datestr[2]) * 10 + atoc(datestr[3]);
			sT.tm_mday = atoc(datestr[4]) * 10 + atoc(datestr[5]);
			}
		if (sT.tm_mon > 12 || sT.tm_mday > 31)
			sT.tm_year = -1;
		}

	/* try to get a time */
	if (timestr)
		{
		if (((sl = StrCharGetByteCount(timestr)) == 5 || (sl == 8 && timestr[5] == ':'))
				&& timestr[2] == ':')
			{
			sT.tm_hour = atoc(timestr[0]) * 10 + atoc(timestr[1]);
			sT.tm_min = atoc(timestr[3]) * 10 + atoc(timestr[4]);
			if (sl == 8)
				sT.tm_sec = atoc(timestr[6]) * 10 + atoc(timestr[7]);
			else
				sT.tm_sec = 0;
			}
		if (sT.tm_hour > 24 || sT.tm_min > 59 || sT.tm_sec > 59)
			sT.tm_hour = -1;
		}

	if (sT.tm_year == -1 || sT.tm_hour == -1)
		return;

	sT.tm_year -= 1900;
	ltime = (unsigned long)mktime(&sT);
	ltime += itimeGetBasetime();
	*ptime = ltime;
	}

/*********************** end of krm_rcv.c ****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\krm_snd.c ===
/* File: C:\WACKER\xfer\krm_snd.c (Created: 28-Jan-1994)
 * created from HAWIN source code
 * krm_snd.c  --  Routines for handling file transmission using KERMIT
 *				file transfer protocol.
 *
 *	Copyright 1989,1990,1991,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 7/11/02 11:10a $
 */
// #define	DEBUGSTR	1

#include <windows.h>
#pragma hdrstop

#include <time.h>
#include <stdlib.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <term\res.h>
#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>
#include <tdll\session.h>
#include <tdll\htchar.h>
#include <tdll\com.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"
#include "itime.h"
#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "krm.h"
#include "krm.hh"

// unsigned total_retries;
// metachar (NEAR *p_kgetc)(void);
// long kbytes_sent = 0L;
// KPCKT FAR *  this_kpckt;
// KPCKT FAR *  next_kpckt;

/* local funtion prototypes */
void build_attributes(ST_KRM *kc,
					unsigned char *bufr,
					long size,
					unsigned long ul_time);

int ksend_init(ST_KRM *kc);
int ksend_break(ST_KRM *kc);
int ksend_file(ST_KRM *kc, long fsize);

int wldindexx(const char *string,
				const char FAR *substr,
				char wildcard,
				int ic);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * krm_snd
 *
 * DESCRIPTION:
 *	send a file or files using kermit protocol
 *
 *	This routine also handles logging of kermit sending operations to the
 *	optional log file.
 *
 * ARGUMENTS:
 *	attended -- TRUE if transfer is run manually, FALSE if run under automation
 *				such as in host or hyperpilot
 *	nfile	 -- number of files to be sent
 *	nbytes	 -- total number of bytes to be sent in all files
 *
 * RETURNS:
 *	Returns TRUE if all files are sent successfully or if all cancellations
 *	were user-requested, 'graceful' ones. Returns FALSE if an error occurs
 *	at either end of transfer or if user forces an immediate exit.
 */
int krm_snd(HSESSION hS, int attended, int nfiles, long nbytes)
	{
	ST_KRM *kc;
	int result;
	long sndsize;
	unsigned long filetime;
	long ttime;

	kc = malloc(sizeof(ST_KRM));
	if (kc == NULL)
		{
		xferMsgClose(hS);
		return TSC_NO_MEM;
		}
	memset(kc, 0, sizeof(ST_KRM));

	kc->hSession = hS;
	kc->hCom = sessQueryComHdl(hS);

	kc->kbytes_sent = 0L;

	kc->this_kpckt = NULL;
	kc->next_kpckt = NULL;

	if (kc != NULL)
		kc->this_kpckt = malloc(sizeof(KPCKT));
	if (kc->this_kpckt != NULL)
		kc->next_kpckt = malloc(sizeof(KPCKT));
	if (kc->next_kpckt == NULL)
		{
		if (kc->this_kpckt != NULL)
			{
			free(kc->this_kpckt);
			kc->this_kpckt = NULL;
			}
		if (kc != NULL)
			{
			free(kc);
			kc = NULL;
			}
		xferMsgClose(hS);
		return TSC_NO_MEM;
		}

	krmGetParameters(kc);

	kc->KrmProgress = ks_progress;

	kc->total_retries = 0;

	xferMsgFilecnt(kc->hSession, nfiles);
	xferMsgTotalsize(kc->hSession, nbytes);

	kc->nbytes = nbytes;
	kc->file_cnt = nfiles;
	kc->files_done = 0;
	kc->its_maxl = 80;
	kc->its_timeout = 15;
	kc->its_npad = 0;
	kc->its_padc = '\0';
	kc->its_eol = kc->k_eol;
	kc->its_chkt = 1;
	kc->its_qctl = K_QCTL;
	kc->its_qbin = '\0';
	kc->its_rept = '\0';
	kc->its_capat = FALSE;

	kc->ksequence = 0;
	kc->packetnum = 1;
	kc->abort_code = KA_OK;
	kc->xfertime = -1L;

	if (!ksend_init(kc))
		{
		int kret;

		kret = kresult_code[kc->abort_code];

		free(kc->this_kpckt);
		kc->this_kpckt = NULL;
		free(kc->next_kpckt);
		kc->next_kpckt = NULL;
		free(kc);
		kc = NULL;

		xferMsgClose(hS);
		return(kret);
		}

	/* don't show init errors once transfer has started */
	kc->total_dsp = kc->total_thru = 0L;  /* new transfer starting */

	while(xfer_nextfile(kc->hSession, kc->our_fname))
		{
		// xfer_idle(kc->hSession, XFER_IDLE_IO);

		if (kc->abort_code == KA_LABORT1)	/* TODO: figure this out */
			kc->abort_code = KA_LABORTALL;

		if (kc->abort_code >= KA_LABORTALL)
			break;

		kc->abort_code = KA_OK;

		result = xfer_opensendfile(kc->hSession,
								&kc->fhdl,
								kc->our_fname,
								&sndsize,
								kc->their_fname,
								&filetime);
		if (result != 0)
			{
			kc->abort_code = KA_CANT_OPEN;
			break;
			}

		if (kc->its_capat)
			build_attributes(kc, kc->next_kpckt->pdata, sndsize, filetime);

		ksend_file(kc, sndsize);

		++kc->files_done;
		if (kc->fhdl)
			{
			fio_close(kc->fhdl);
			kc->fhdl = NULL;
			}

		/* log transfer status here based on kc->abort_code */

		xfer_log_xfer(kc->hSession,
					TRUE,
					kc->our_fname,
					NULL,
					kresult_code[kc->abort_code]);
		}

	if (kc->abort_code < KA_IMMEDIATE)
		ksend_break(kc);
	ks_progress(kc, TRANSFER_DONE);
	ttime = ((long)interval(kc->xfertime) / 10L);

	result = kresult_code[kc->abort_code];

	xferMsgClose(kc->hSession);

	free(kc->this_kpckt);
	kc->this_kpckt = NULL;
	free(kc->next_kpckt);
	kc->next_kpckt = NULL;
	free(kc);
	kc = NULL;

	xferMsgClose(hS);
	return(result);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * build_attributes
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void build_attributes(ST_KRM *kc,
					unsigned char *bufr,
					long size,
					unsigned long ul_time)
	{
	char str[15];
	int sl;
	struct tm *pt;

	/* add file size in K */
	wsprintf((LPSTR)str,
			(LPSTR)"%d",
			(int)(FULL_HUNKS(size, 1024)));

	wsprintf((LPSTR)bufr,
			(LPSTR)"!%c%s",
			tochar(sl = (int)StrCharGetByteCount(str)),
			(LPSTR)str);

	bufr += (sl + 2);

	/* add file size in bytes */
	wsprintf((LPSTR)str,
			(LPSTR)"%ld",
			(ULONG)size);

	wsprintf((LPSTR)bufr,
			(LPSTR)"1%c%s",
			tochar(sl = (int)StrCharGetByteCount(str)),
			(LPSTR)str);

	bufr += (sl + 2);

	/* add file date and time */
	ul_time += itimeGetBasetime();			/* Adjust to C7 and later */
	pt = localtime((time_t*)&ul_time);
	assert(pt);

	if (pt)
		{
		/*
		 * Dimwitted thing sometimes returns 0
		 */
		wsprintf((LPSTR)bufr,
				(LPSTR)"#%c%04d%02d%02d %02d:%02d:%02d",
				tochar(17),
				pt->tm_year + 1900,
				pt->tm_mon + 1,
				pt->tm_mday,
				pt->tm_hour,
				pt->tm_min,
				pt->tm_sec);

		bufr += 19;
		}

	/* system of origin */
	StrCharCat(bufr, ".\"U8");
	bufr += 4;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ksend_init
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int ksend_init(ST_KRM *kc)
	{
	unsigned plen;				/* length of outgoing packet data */
	char rpacket[MAXPCKT];		/* space to receive response packet */
	int rlen, rseq; 			/* length and sequence of response packet */
	int tries = 0;

	/* set init parameters as sender */
	plen = (unsigned)buildparams(kc, TRUE, kc->this_kpckt->pdata);
	xferMsgPacketnumber(kc->hSession, kc->packetnum);

	while (tries < kc->k_retries)
		{
		// xfer_idle(kc->hSession, XFER_IDLE_IO);

		xferMsgPacketErrcnt(kc->hSession, tries);

		ksend_packet(kc, 'S', plen, kc->ksequence, kc->this_kpckt);

		switch (krec_packet(kc, &rlen, &rseq, rpacket))
			{
		case 'Y':
			if (rseq == kc->ksequence)
				{
				kc->xfertime = (long)startinterval();
				getparams(kc, TRUE, rpacket);
				kc->ksequence = (kc->ksequence + 1) % 64;
				++kc->packetnum;
				return(TRUE);
				}

			/* fall through */

		case 'N':
			xferMsgLasterror(kc->hSession, KE_NAK);
			++tries;
			break;

		case 'T':
			xferMsgLasterror(kc->hSession, KE_TIMEOUT);
			++tries;
			break;

		case BAD_PACKET:
			if (xfer_user_interrupt(kc->hSession))
				{
				kc->abort_code = KA_IMMEDIATE;
				return (FALSE);
				}

			if (xfer_carrier_lost(kc->hSession))
				{
				kc->abort_code = KA_LOST_CARRIER;
				return (FALSE);
				}

			xferMsgLasterror(kc->hSession, KE_BAD_PACKET);
			++tries;
			break;

		case 'E':
			/* received error packet, abort transfer */
			xferMsgLasterror(kc->hSession, KE_RMTERR);
			strncpy(kc->xtra_err, rpacket, (unsigned)65);
			kc->abort_code = KA_RMTERR;
			return(FALSE);
			/*lint -unreachable*/
			break;

		default:
			/* unexpected packet type */
			kc->abort_code = KA_BAD_FORMAT;
			return(FALSE);
			/*lint -unreachable*/
			break;
			}
		}
	/* error count has been exceeded */
	kc->abort_code = KA_ERRLIMIT;
	return(FALSE);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ksend_break
 *
 * DESCRIPTION:
 *	Send 'B' packet to indicate end of transaction
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *
 */
int ksend_break(ST_KRM *kc)
	{
	char rpacket[MAXPCKT];		/* space to receive response packet */
	int rlen, rseq; 			/* length and sequence of response packet */
	int tries = 0;

	while (tries < kc->k_retries)
		{
		// xfer_idle(kc->hSession, XFER_IDLE_IO);

		ksend_packet(kc, 'B', 0, kc->ksequence, kc->this_kpckt);
		switch (krec_packet(kc, &rlen, &rseq, rpacket))
			{
		case 'Y':
			if (rseq == kc->ksequence)
				{
				kc->ksequence = (kc->ksequence + 1) % 64;
				++kc->packetnum;
				return(TRUE);
				}

			/* fall through */

		case 'N':
		case 'T':
		case BAD_PACKET:
			if (xfer_user_interrupt(kc->hSession))
				{
				kc->abort_code = KA_IMMEDIATE;
				return FALSE;
				}

			if (xfer_carrier_lost(kc->hSession))
				{
				kc->abort_code = KA_LOST_CARRIER;
				return FALSE;
				}

			++tries;
			break;

		case 'E':
			/* received error packet, abort transfer */
			StrCharCopyN(kc->xtra_err, rpacket, MAXLINE);
			kc->abort_code = KA_RMTERR;
			return(FALSE);
			/*lint -unreachable*/
			break;

		default:
			/* unexpected packet type */
			kc->abort_code = KA_BAD_FORMAT;
			return(FALSE);
			/*lint -unreachable*/
			break;
			}
		}
	/* error count has been exceeded */
	kc->abort_code = KA_ERRLIMIT;
	return(FALSE);
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ksend_file
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int ksend_file(ST_KRM *kc, long fsize)
	{
	int 		tries = 0;
	int			file_sent = FALSE;
	int			packet_sent = FALSE;
	int 		kbd_abort = KA_OK;
	char		rtype;
	int 		rlen, rseq;
	char		rpacket[MAXPCKT];
	int			sendattr;
	KPCKT 		*tmp;

	DbgOutStr("ksend_file %s\r\n", (LPSTR)kc->our_fname, 0,0,0,0);

	xferMsgNewfile(kc->hSession,
				kc->files_done + 1,
				kc->our_fname,
				kc->our_fname);

	xferMsgFilesize(kc->hSession, fsize);

	xferMsgPacketErrcnt(kc->hSession, 0);

	xferMsgPacketnumber(kc->hSession, 0);

	kc->p_kgetc = ks_getc;
	kc->kbytes_sent = 0;

	/* prepare file-header packet in this_kpckt */
	kc->this_kpckt->ptype = 'F';
	StrCharCopyN(kc->this_kpckt->pdata, kc->their_fname, MAXPCKT);
	kc->this_kpckt->datalen = (int)StrCharGetByteCount(kc->this_kpckt->pdata);
	sendattr = kc->its_capat &&
		(size_t)StrCharGetByteCount(kc->next_kpckt->pdata) <= (size_t)(kc->its_maxl - 5);

	while (!file_sent && kc->abort_code == KA_OK)  /* for each packet */
		{
		// xfer_idle(kc->hSession, XFER_IDLE_IO);

		tries = 0;
		packet_sent = FALSE;
		while (!packet_sent && tries++ < kc->k_retries && kc->abort_code == KA_OK)
			{
			// xfer_idle(kc->hSession, XFER_IDLE_IO);

			if (kbd_abort != KA_OK && tries == 1)
				{
				kc->this_kpckt->ptype = 'Z';
				kc->this_kpckt->datalen = 1;
				StrCharCopyN(kc->this_kpckt->pdata, "D", MAXPCKT);
				}

			DbgOutStr("Calling ksend_packet %d %c (0x%x)",
					tries, kc->this_kpckt->ptype, kc->this_kpckt->ptype, 0,0);

			ksend_packet(kc, kc->this_kpckt->ptype,
						 (unsigned)kc->this_kpckt->datalen,
						 kc->ksequence, kc->this_kpckt);

			if (xfer_carrier_lost(kc->hSession))
				{
				kc->abort_code = KA_LOST_CARRIER;
				break;
				}

			if (tries == 1) 	/* first try for this packet */
				{
				xferMsgPacketnumber(kc->hSession, kc->packetnum);

				if (fsize > 0)
					ks_progress(kc, 0);

				/* get next packet ready while first is being sent */
				if (sendattr)	/* data alreay prepared in next_kpckt */
					{
					kc->next_kpckt->datalen = (int)StrCharGetByteCount(kc->next_kpckt->pdata);
					kc->next_kpckt->ptype = 'A';
					sendattr = FALSE;
					}
				else if ((kc->next_kpckt->datalen =
						kload_packet(kc, kc->next_kpckt->pdata)) == ERROR)
					{
					kc->next_kpckt->ptype = 'E';
					kc->next_kpckt->datalen = (int)StrCharGetByteCount(kc->xtra_err);
					StrCharCopyN(kc->next_kpckt->pdata, kc->xtra_err, MAXPCKT);
					}
				else
					kc->next_kpckt->ptype = (char)(kc->next_kpckt->datalen ? 'D':'Z');

				DbgOutStr(" next packet %c (0x%x)\r\n",
						kc->next_kpckt->ptype, kc->next_kpckt->ptype, 0,0,0);

				} /* end of if (tries == 1) */
			else
				{
				xferMsgPacketErrcnt(kc->hSession, tries - 1);
				xferMsgErrorcnt(kc->hSession, ++kc->total_retries);

				DbgOutStr(" retry\r\n", 0,0,0,0,0);
				}

			rtype = (char)krec_packet(kc, &rlen, &rseq, rpacket);
			if (rtype == 'N' && (--rseq < 0 ? 63 : rseq) == kc->ksequence)
				rtype = 'Y';

			DbgOutStr("called krec_packet %c (0x%x)\r\n", rtype, rtype, 0,0,0);

			switch(rtype)
				{
			case 'Y':
				if (rseq == kc->ksequence)
					{
					packet_sent = TRUE;
					kc->ksequence = (kc->ksequence + 1) % 64;
					++kc->packetnum;
					if (kc->this_kpckt->ptype == 'A')/* response to attr pckt */
						{
						/* If receiver responded to an attribute packet with
						 *	an 'N' in the data field, do not transfer the file.
						 */

						if (rlen > 0 && *rpacket == 'N')
							kbd_abort = KA_RABORT1;
						}
					if (kc->this_kpckt->ptype == 'Z')/* have we sent last one?*/
						{
						file_sent = TRUE;
						kc->abort_code = kbd_abort;
						kbd_abort = KA_OK;
						}
					if (rlen == 1)
						{
						if (*rpacket == 'X')
							kbd_abort = KA_RABORT1;
						else if (*rpacket == 'Z')
							kbd_abort = KA_RABORTALL;
						}
					tmp = kc->this_kpckt;
					kc->this_kpckt = kc->next_kpckt;
					kc->next_kpckt = tmp;
					}
				else
					xferMsgLasterror(kc->hSession, KE_SEQUENCE);
				break;

			case 'N':
				xferMsgLasterror(kc->hSession, KE_NAK);
				break;

			case BAD_PACKET:
				xferMsgLasterror(kc->hSession, KE_BAD_PACKET);
				break;

			case 'T':
				xferMsgLasterror(kc->hSession, KE_TIMEOUT);
				break;

			case 'E':
				xferMsgLasterror(kc->hSession, KE_RMTERR);
				StrCharCopyN(kc->xtra_err, rpacket, MAXLINE);
				kc->abort_code = KA_RMTERR;
				return(FALSE);
				/*lint -unreachable*/
				break;

			default:
				xferMsgLasterror(kc->hSession, KE_WRONG);
				kc->abort_code = KA_BAD_FORMAT;
				return(FALSE);
				/*lint -unreachable*/
				break;
				}

			if (xfer_user_interrupt(kc->hSession))
				{
				if (kbd_abort == KA_OK) 	/* first time */
					{
					kbd_abort = KA_LABORT1;
					}
				else
					kc->abort_code = KA_IMMEDIATE;
				}

			if (xfer_carrier_lost(kc->hSession))
				kc->abort_code = KA_LOST_CARRIER;
			} /* end while (!packet_sent && etc.) */

		xferMsgPacketErrcnt(kc->hSession, tries = 0);

		if (kc->abort_code == KA_OK && !packet_sent) /* error count exceeded */
			kc->abort_code = KA_ERRLIMIT;
		} /* end while (!file_sent etc.) */

	xferMsgPacketnumber(kc->hSession, kc->packetnum);

	ks_progress(kc, FILE_DONE);
	kc->total_dsp += fsize;
	kc->total_thru += kc->kbytes_sent;
	kc->kbytes_sent = 0;
	return(file_sent);
	} /* end ksend_file() */


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ks_progress
 *
 * DESCRIPTION:
 *	Displays transfer progress indicators for Kermit Send
 *
 * ARGUMENTS:
 *	final -- TRUE if final display for a file.
 *
 * RETURNS:
 *	nothing
 */
void ks_progress(ST_KRM *kc, int status)
	{
	long ttime, stime;
	long bytes_sent;
	long cps;
	long krm_stime = -1;
	long krm_ttime = -1;
	long krm_cps = -1;
	long krm_file_so_far = -1;
	long krm_total_so_far = -1;

	if (kc->xfertime == -1L)
		return;
	ttime = (long)interval(kc->xfertime);

	if ((stime = ttime / 10L) != kc->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		/* Display elapsed time */
		krm_stime = stime;

		/* Display amount transferred */
		bytes_sent = kc->total_dsp + kc->kbytes_sent;

		krm_file_so_far = kc->kbytes_sent;
		krm_total_so_far = bytes_sent;

		/* Display throughput and est. time to completion */
		if ((stime > 2 ||
				ttime > 0 && bittest(status, FILE_DONE | TRANSFER_DONE)) &&
				(cps = ((kc->total_thru + kc->kbytes_sent) * 10L) / ttime) > 0)
			{
			krm_cps = cps;

			if ((kc->nbytes > 0))
				{
				ttime = ((kc->nbytes - bytes_sent) / cps) +
						kc->file_cnt - kc->files_done;
				krm_ttime = ttime;
				}
			}
		kc->displayed_time = stime;
		}

	xferMsgProgress(kc->hSession,
					krm_stime,
					krm_ttime,
					krm_cps,
					krm_file_so_far,
					krm_total_so_far);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#define	toupper(x) ((x)-'a'+'A')

int wldindexx(const char *string,
			const char *substr,
			char wildcard,
			int ic)
	/* ic - ignore case */
	{
	short index, limit;
	const char *s;
	const char *ss;

	if (*substr == '\0')
		return(0);
	index = 0;
	limit = (short)StrCharGetByteCount(string) - (short)StrCharGetByteCount(substr);
	while (index <= limit)
		{
		s = &string[index];
		ss = substr;
		while (*ss == wildcard || *s == *ss || (ic && isascii(*s)
					&& isascii(*ss) && toupper(*s) == toupper(*ss)))
			{
			++s;
			if (*++ss == '\0')
				return(index);
			}
		++index;
		}
	return(-1);
	}

/********************* end of krm_snd.c ********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\krm_res.c ===
/* File: C:\WACKER\xfer\krm_res.c (Created: 28-Jan-1994)
 * created from HAWIN source file
 * krm_res.c  --  Routines for handling file transmission using KERMIT
 *				file transfer protocol.
 *
 *	Copyright 1989,1991,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:22p $
 */

#include <windows.h>
#pragma hdrstop

#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>

#if !defined(BYTE)
#define	BYTE	unsigned char
#endif

#include "cmprs.h"

#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "krm.h"
#include "krm.hh"

// Resident routines for kermit receiving

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * kunload_packet
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int kunload_packet(ST_KRM *kc, int len, unsigned char *bufr)
	{
	int sethbit = FALSE;
	unsigned char c;
	unsigned char *bp;
	unsigned char c7;
	unsigned char *limit;
	int reptcount;
	int i;

	xfer_idle(kc->hSession, XFER_IDLE_IO);

	bp = bufr;
	limit = bufr + len;
	while (bp < limit)
		{
		c = *bp++;
		if (kc->its_rept && c == kc->its_rept)
			{
			reptcount = unchar(*bp++);
			c = *bp++;
			}
		else
			reptcount = 1;
		if (kc->its_qbin && c == kc->its_qbin)
			{
			sethbit = TRUE;
			c = *bp++;
			}
		if (c == kc->its_qctl)
			{
			c = *bp++;
			c7 = (unsigned char)(c & 0x7F);
			if (c7 != kc->its_qctl && c7 != kc->its_qbin && c7 != kc->its_rept)
				c = (unsigned char)ctl(c);
			}
		if (sethbit)
			{
			c |= 0x80;
			sethbit = FALSE;
			}
		for (i = reptcount + 1; --i > 0; )
			if ((*kc->p_kputc)(kc, c) == ERROR)
				return(ERROR);
		}	/* while (bp < limit) */

	/* pointer should stop right at limit, if not, somethings wrong */
	if (bp > limit)
		return(ERROR);
	else
		return(0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * kr_putc
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int kr_putc(ST_KRM *kc, int c)
	{

	++kc->kbytes_received;
	return ((int)(fio_putc(c, kc->fhdl)));
	}

// Resident routines for kermit sending


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * kload_packet
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int kload_packet(ST_KRM *kc, unsigned char *bufr)
	{
	char *bp = bufr;
	char *rp = bufr;
	char *limit;
	int rptcount = 1;
	int c, c7;
	int lastc = -1;
	int no8thbit = 0 /* (cnfg.bits_per_char != 8) */;

	xfer_idle(kc->hSession, XFER_IDLE_IO);

	limit = bufr + (kc->its_maxl - kc->its_chkt - 6);
	while (bp < limit)
		{
		if ((c = (*kc->p_kgetc)(kc)) == EOF)
			break;
		if (kc->its_rept)	  /* check for repeat characters */
			{
			if (c != lastc)
				{
				rptcount = 1;	/* start new check for repeat chars */
				rp = bp;
				lastc = c;
				}
			else if (++rptcount == 4)
				{
				bp = rp;		/* back up in buffer to where repeat started */
				while ((c = (*kc->p_kgetc)(kc)) == lastc && ++rptcount < 94)
					;
				if (c != lastc)
					{
					if (c != EOF)			/* note: putting the extra char. */
						{					/*	directly back into the send  */
						fio_ungetc(c, kc->fhdl);/* file buffer will not work */
						--kc->kbytes_sent;	/*	if p_kgetc is not pointing	  */
						}					/*	directly to ks_getc().		 */
					c = lastc;
					}
				lastc = -1;
				*bp++ = kc->its_rept;
				*bp++ = (char)tochar(rptcount);
				}
			}

		/* check for binary (8th bit) quoting */
		if (c & 0x80)
			{
			if (kc->its_qbin)	  /* do 8th-bit quoting */
				{
				*bp++ = kc->its_qbin;
				c &= 0x7F;
				}
			else if (no8thbit)
				{
				/* error! */
				// strcpy(kc->xtra_err, strld(TM_NOT_CNFGD));
				/* TODO: figure this error out */
				return(ERROR);
				}
			}

		/* check for characters needing control-quoting */
		c7 = (c & 0x7F);
		if (c7 < ' ' || c7 == DEL)
			{
			*bp++ = kc->its_qctl;
			c = ctl(c);
			}
		else if (c7 == (int)kc->its_qctl ||
				c7 == (int)kc->its_qbin ||
				c7 == (int)kc->its_rept)
			*bp++ = kc->its_qctl;
		*bp++ = (char)c;
		}
	if (fio_ferror(kc->fhdl))
		return(ERROR);

	return (int)(bp - bufr);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * ks_getc
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
#if 1
int ks_getc(ST_KRM *kc)
	{
	++kc->kbytes_sent;
	return(fio_getc(kc->fhdl));
	}
#else
int ks_getc(ST_KRM *kc)
	{
	int c;

	++kc->kbytes_sent;
	c = fio_getc(kc->fhdl);

	DbgOutStr("%c", c, 0,0,0,0);

	return c;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx.h ===
/* File: C:\WACKER\xfer\mdmx.h (Created: 17-Jan-1994)
 * created from HAWIN source file
 * mdmx.h -- Exported definitions for xmodem file transfer routines
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#if !defined(EOF)
#define EOF (-1)
#endif

/* error checking method values */
#define UNDETERMINED	0
#define CHECKSUM		1
#define CRC 			2

/* XMODEM and YMODEM user settable control values. These are exported to
 *	  the configuration routines.
 */

extern int mdmx_rcv(HSESSION hSession,
					   int attended,
					   int method,
					   int single_file);

extern int mdmx_snd(HSESSION hSession,
					   int attended,
					   int method,
					   unsigned nfiles,
					   long nbytes);

/* end of mdmx.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx_rcv.c ===
/* File: C:\WACKER\xfer\mdmx_rcv.c (Created: 18-Jan-1994)
 * created from HAWIN source file
 *
 * mdmx_rcv.c -- XMODEM compatible file receiving routines for HA5G
 *
 *	Copyright 1987,88,89,90,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 7/11/02 3:58p $
 */

#include <windows.h>
#pragma hdrstop

#include <stdlib.h>
// #include <setjmp.h>

#define	BYTE	unsigned char

#include <tdll\mc.h>
#include <tdll\stdtyp.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\file_io.h>
#include <tdll\htchar.h>
#include "xfr_srvc.h"
#include "xfr_todo.h"
#include "xfr_dsp.h"
#include "xfer_tsc.h"
#include "foo.h"

#include "cmprs.h"

#include "xfer.h"
#include "xfer.hh"

#include "mdmx.h"
#include "mdmx.hh"

#if !defined(STATIC_FUNC)
#define	STATIC_FUNC
#endif

/* * * * * * * * * * * * *
 *	Function Prototypes  *
 * * * * * * * * * * * * */

STATIC_FUNC void 	  start_receive(ST_MDMX *xc, unsigned expect);

STATIC_FUNC int	   wait_receive(ST_MDMX *xc);

STATIC_FUNC	int 	  receivepckt(ST_MDMX *xc,
								HSESSION hSession,
								unsigned expect,
								struct s_mdmx_pckt *pckt);

STATIC_FUNC	void	  respond(HSESSION hSession, ST_MDMX *xc, char code);

STATIC_FUNC	void	  xm_clear_input(HSESSION hSession);

STATIC_FUNC void	 xm_rcheck(ST_MDMX *xc, HSESSION hSession, int before);

STATIC_FUNC void	 xm_check_input(HSESSION hSession, int suspend);

extern	int	  xr_collect(ST_MDMX *, int, long, unsigned char **,
								  unsigned char *, unsigned *);


/*lint -e502*/				/* lint seems to want the ~ operator applied
							 *	only to unsigned, wer'e using uchar
							 */
#define ESC_MSG_COL 	1


/* * * * * * * * * * * *
 *	Shared Variables   *
 * * * * * * * * * * * */

// int (NEAR *p_putc)(metachar c) = xm_putc;
// static struct s_mdmx_pckt *next_pckt;
// static unsigned this_pckt;

// static tiny check_type;
// static int batch;
// static int streaming;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * mdmx_rcv
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int mdmx_rcv(HSESSION hSession, int attended, int method, int single_file)
	{
	ST_MDMX *xc;
	struct 	s_mdmx_pckt *last_pckt = NULL;
	struct 	s_mdmx_pckt *swap_pckt = NULL;
	struct 	st_rcv_open stRcv;
	TCHAR 	fname[FNAME_LEN];
	TCHAR 	our_fname[FNAME_LEN];
	long 	basesize;
	int 	still_trying = TRUE;
	int 	xpckt_size;
	int 	xstatus = TSC_OK;
	int 	override = FALSE;
	unsigned int uiOldOptions;
	unsigned tries, retries;
	unsigned char 	*cp;
	int 	blk_result = UNDEFINED, result = 0;
	char 	start_char;
	char 	nak_char;

	TCHAR_Fill(fname, TEXT('\0'), FNAME_LEN);

	/* allocate space for large packets since we don't necessarily know what
	 *	we'll be getting.
	 */
	xc = NULL;
	last_pckt = NULL;
	xc = malloc(sizeof(ST_MDMX));
	if (xc == NULL)
		goto done;
	memset(xc, 0, sizeof(ST_MDMX));
	DbgOutStr("xc = 0x%x\r\n", xc, 0,0,0,0);

	last_pckt = malloc(sizeof(ST_MDMX) + LARGE_PACKET + 2);
	if (last_pckt == NULL)
		goto done;
	memset(last_pckt, 0, sizeof(ST_MDMX));

	xc->next_pckt = malloc(sizeof(ST_MDMX) + LARGE_PACKET + 2);
	if (xc->next_pckt == NULL)
		goto done;
	memset(xc->next_pckt, 0, sizeof(ST_MDMX));

	xc->hSession = hSession;
	xc->hCom     = sessQueryComHdl(hSession);

	DbgOutStr("hs = 0x%x\r\n", hSession, 0,0,0,0);

	mdmxXferInit(xc, method);

	if (xfer_set_comport(hSession, FALSE, &uiOldOptions) != TRUE)
		goto done;
	else
		override = TRUE;

	xc->file_bytes = 0L;
	xc->total_bytes = 0L;
#if FALSE
	xc->flagkey = kbd_register_flagkey(ESC_KEY, NULL);
#endif
	xc->fh = NULL;
	xc->xfertimer = -1L;
	xc->xfertime = 0L;
	xc->nfiles = 0;
	xc->filen = 0;
	xc->filesize = -1L;
	xc->nbytes = -1L;

	still_trying = TRUE;
	blk_result = UNDEFINED;
	xc->batch = TRUE;
	xc->streaming = FALSE;
	start_char = 'C';
	xc->check_type = CRC;
	mdmxdspChecktype(xc, (xc->check_type == CRC) ? 0 : 1);
	if (method == XF_YMODEM_G)
		{
		xc->streaming = TRUE;
		start_char = 'G';
		}
	else if ((method == XF_XMODEM || method == XF_XMODEM_1K) &&
			xc->mdmx_chkt == CHECKSUM)
		{
		start_char = NAK;
		xc->check_type = CHECKSUM;
		}

	nak_char = start_char;
	xc->this_pckt = 0;

	tries = 0;
	mdmxdspPacketErrorcnt(xc, tries);

	retries = 0;
	mdmxdspErrorcnt(xc, retries);

	xc->mdmx_byte_cnt = 0L;

	mdmxdspChecktype(xc, (xc->check_type == CRC) ? 0 : 1);

	start_receive(xc, xc->this_pckt);	   /* setup to receive first pckt */
	if (attended)
		respond(hSession, xc, start_char);

	while (still_trying)
		{
		blk_result = wait_receive(xc);
		switch(blk_result)
			{
		case NOBATCH_PCKT:
			/* Received pckt 1 while waiting for pckt 0.
			 * This must be an XMODEM as opposed to a YMODEM transfer
			 */
			if (!single_file)
				{
				xstatus = TSC_BAD_FORMAT;
				still_trying = FALSE;
				break;
				}
			xc->this_pckt = 1;
			xc->batch = FALSE;
			xc->filesize = -1L;
			nak_char = NAK;

			stRcv.pszSuggestedName = "";
			stRcv.pszActualName = our_fname;
			stRcv.lFileTime = 0;

			result = xfer_open_rcv_file(hSession, &stRcv, 0L);
			if (result != 0)
				{
				switch (result)
				{
				case -6:
					xstatus = TSC_REFUSE;
					break;
				case -5:
					xstatus = TSC_CANT_OPEN;
					break;
				case -4:
					xstatus = TSC_NO_FILETIME;
					break;
				case -3:
					xstatus = TSC_CANT_OPEN;
					break;
				case -2:
					xstatus = TSC_OLDER_FILE;
					break;
				case -1:
				default:
					xstatus = TSC_CANT_OPEN;
					break;
				}
				still_trying = FALSE;
				break;
				}

			xc->fh = stRcv.bfHdl;
			xc->basesize = stRcv.lInitialSize;

			basesize = stRcv.lInitialSize;

			mdmxdspNewfile(xc,
						   0,
						   our_fname,
						   our_fname);

			/* fall through */
		case ALT_PCKT:
		case GOOD_PCKT:
			/* swap pckt pointers so we can work on this one while receiving
			 *	the next
			 */
			swap_pckt = last_pckt;
			last_pckt = xc->next_pckt;
			xc->next_pckt = swap_pckt;
			if (xc->this_pckt != 0)
				start_receive(xc, xc->this_pckt + 1);

			if (!xc->streaming)
				respond(hSession, xc, ACK);  /* send ACK as soon as possible */
										/* then send burst for Xmodem pckt 1 */
			if (xc->this_pckt == 0)
				{
				if (!*(last_pckt->bdata)) /* no more files? */
					{
					xc->xfertime = (long)interval(xc->xfertimer);
					still_trying = FALSE;
					break;
					}
				else if (xc->filen > 0 && single_file) /* getting too many files? */
					{
					xstatus = TSC_TOO_MANY;
					still_trying = FALSE;
					break;
					}

				start_receive(xc, 1);
				respond(hSession, xc, start_char);

				/* get info out of packet 0 and open file */
				StrCharCopyN(fname, last_pckt->bdata, FNAME_LEN);
				for (cp = fname; *cp != '\0'; cp++)
					if (*cp == '/')
						*cp = '\\';

				stRcv.pszSuggestedName = fname;
				stRcv.pszActualName = our_fname;
				stRcv.lFileTime = 0;
				xfer_build_rcv_name(hSession, &stRcv);

				result = xfer_open_rcv_file(hSession, &stRcv, 0L);
				if (result != 0)
					{
					switch (result)
					{
					case -6:
						xstatus = TSC_REFUSE;
						break;
					case -5:
						xstatus = TSC_CANT_OPEN;
						break;
					case -4:
						xstatus = TSC_NO_FILETIME;
						break;
					case -3:
						xstatus = TSC_CANT_OPEN;
						break;
					case -2:
						xstatus = TSC_OLDER_FILE;
						break;
					case -1:
					default:
						xstatus = TSC_CANT_OPEN;
						break;
					}
					still_trying = FALSE;
					break;
					}

				xc->fh = stRcv.bfHdl;
				xc->basesize = stRcv.lInitialSize;

				basesize = stRcv.lInitialSize;

				mdmxdspNewfile(xc,
							   ++xc->filen,
							   fname,
							   our_fname);

				/* accumlate last transfer total and start new counter */
				xc->total_bytes += xc->file_bytes;
				xc->mdmx_byte_cnt = xc->file_bytes = 0L;
				xc->filesize = -1L;
				cp = last_pckt->bdata +
						StrCharGetByteCount(last_pckt->bdata) + 1;
				if (*cp)
					{
					xc->filesize = atol(cp);

					mdmxdspFilesize(xc, xc->filesize);
					}
				nak_char = NAK;
				}
			else
				{
				/* unload packet data */
				cp = last_pckt->bdata;
				xpckt_size = (last_pckt->start_char == STX ?
						LARGE_PACKET : SMALL_PACKET);

				if (xs_unload(xc, cp, xpckt_size) == (-1) /* ERROR */ )
					{
					xm_clear_input(hSession);
					respond(hSession, xc, CAN);
					xstatus = TSC_DISK_ERROR;
					still_trying = FALSE;
					break;
					}

				// if (xc->filesize != -1L) jmh 03-08-96 to match HAWin
				if (xc->filesize > 0)
					xc->file_bytes = min(xc->filesize, xc->mdmx_byte_cnt);
				else
					xc->file_bytes = xc->mdmx_byte_cnt;
				}

			mdmxdspPacketnumber(xc, (long)++xc->this_pckt);

			if (tries)
				mdmxdspPacketErrorcnt(xc, tries = 0);

			mdmx_progress(xc, 0);


			break;

		case END_PCKT:
			/* the special EOT handling was removed from version 3.20
			 *	due to problems with RBBS-PC. It should be modified and
			 *	reenabled after experimentation.
			 */


			respond(hSession, xc, ACK); 			  /* ACK the EOT */
			mdmx_progress(xc, FILE_DONE);

			/* It's possible to get an unwanted EOT (if the ACK from the
			 *	first EOT is lost) so we should treat it like a repeated
			 *	packet.
			 */

			if (xc->fh)    /* if file was open */
				{
				if (!xfer_close_rcv_file(hSession,
										 xc->fh,
										 xstatus,
										 fname,
										 our_fname,
										 xfer_save_partial(hSession),
										 xc->basesize + xc->file_bytes /*xc->filesize jmh 03-08-96*/,
										 0))
					{
					xstatus = TSC_DISK_ERROR;
					still_trying = FALSE;
					break;
					}

				xc->fh = NULL;
				}

			if (!xc->batch)
				{
				xc->xfertime = (long)interval(xc->xfertimer);
				still_trying = FALSE;
				}
			else
				{
				start_receive(xc, xc->this_pckt = 0);
				respond(hSession, xc, nak_char = start_char);
				}

			if (tries)
				// VidWrtStrF(xc->toprow + XR_DR_RETRIES, xc->dc_retries,
						// "^H%-2d", tries = 0);
				mdmxdspPacketErrorcnt(xc, tries = 0);

			break;

		case REPEAT_PCKT:
			start_receive(xc, xc->this_pckt);
			respond(hSession, xc, ACK);
			++tries;
			break;

		case WRONG_PCKT:
			xm_clear_input(hSession);
			respond(hSession, xc, CAN);
			++tries;		/* to get packet error on screen */
			still_trying = FALSE;
			xstatus = TSC_OUT_OF_SEQ;
			break;

		case SHORT_PCKT:
		case BAD_FORMAT:
		case BAD_CHECK:
		case NO_PCKT:
			++tries;
			if (xc->mdmx_chkt == UNDETERMINED && xc->this_pckt == 0 && tries == 3
					&& method == XF_XMODEM)
				{
				xc->check_type = CHECKSUM;
				start_char = nak_char = NAK;
				// VidWrtStr(xc->toprow + XR_DR_ERR_CHK, xc->dc_err_chk,
						// strld(TM_CHECKSUM));

				mdmxdspChecktype(xc, 1);
				}
			xm_clear_input(hSession);
			respond(hSession, xc, nak_char);
			start_receive(xc, xc->this_pckt);
			break;

		case BLK_ABORTED:
			xm_clear_input(hSession);
			respond(hSession, xc, CAN);
			xstatus = TSC_USER_CANNED;
			still_trying = FALSE;
			break;

		case CARRIER_LOST:
			xm_clear_input(hSession);
			xstatus = TSC_LOST_CARRIER;
			still_trying = FALSE;
			break;

		case CANNED:
			xm_clear_input(hSession);
			xstatus = TSC_RMT_CANNED;
			still_trying = FALSE;
			break;

		default:
			// assert(FALSE);
			break;
			}

		if (tries)
			{
			mdmxdspPacketErrorcnt(xc, tries);

			mdmxdspErrorcnt(xc, ++retries);

			mdmxdspLastError(xc, blk_result);

			if ((tries >= (unsigned)xc->mdmx_tries) || (xc->streaming && xc->this_pckt > 0))
				{
				xm_clear_input(hSession);
				respond(hSession, xc, CAN);
				xstatus = TSC_ERROR_LIMIT;
				still_trying = FALSE;
				}
			}
		}	/* while (still_trying) */



	done:

	if (xc)
		{
		if (xc->xfertime == 0L)
			{
			xc->xfertime = (long)interval(xc->xfertimer);
			}

		mdmx_progress(xc, TRANSFER_DONE);
		}

	if (override)
		{
#if FALSE
		cnfg.send_xprot = hld_send_xprot;
		cnfg.save_xprot = hld_save_xprot;
		cnfg.bits_per_char = hld_bits_per_char;
		cnfg.parity_type = hld_parity_type;
		(void)(*ComResetPort)();
#endif
		xfer_restore_comport(hSession, uiOldOptions);
		}

	if (xc)
		{
		if (xstatus != TSC_OK)
			{
			if (xc->fh)
				{
				xfer_close_rcv_file(hSession,
									xc->fh,
									xstatus,
									fname,
									our_fname,
									xfer_save_partial(hSession),
									xc->basesize + xc->file_bytes /*xc->filesize jmh 03-08-96*/,
									0);
				}
			}

#if FALSE
		kbd_deregister_flagkey(xc->flagkey);
#endif
		mdmxdspCloseDisplay(xc);

		#if defined(DEADWOOD)
		if (xc->p_crc_tbl != NULL)
			{
			resFreeDataBlock(xc->hSession, xc->p_crc_tbl);
			xc->p_crc_tbl = NULL;
			}
		#else // defined(DEADWOOD
		//
		// We don't need to free xc->p_crc_tbl since it is pointing
		// to a static constant array. REV: 4/10/2002
		//
		xc->p_crc_tbl = NULL;
		#endif // defined(DEADWOOD)

		if (xc->next_pckt)
			{
			free(xc->next_pckt);
			xc->next_pckt = NULL;
			}

		free(xc);
		xc = NULL;
		}

	if (last_pckt)
		{
		free(last_pckt);
		last_pckt = NULL;
		}

	return((int)xstatus);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * start_receive
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC void  start_receive(ST_MDMX *xc, unsigned expect)
	{
	xc->next_pckt->result = UNDEFINED;
	xc->next_pckt->expected = expect;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * wait_receive
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC int wait_receive(ST_MDMX *xc)
	{
	if (xc->next_pckt->result == UNDEFINED)
		{
		xc->next_pckt->result = receivepckt(xc,
											xc->hSession,
											xc->next_pckt->expected,
											xc->next_pckt);
		}
	return xc->next_pckt->result;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * receivepckt
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC int  receivepckt(ST_MDMX *xc,
							HSESSION hSession,
							unsigned expect,
							struct s_mdmx_pckt *pckt)
	{
	long timer, timeout;
	int gothdr = FALSE;
	int started = FALSE;
	TCHAR cc;
	unsigned char *cp;
	int gotCAN = FALSE;
	unsigned char checksum;
	unsigned crc;
	int count;

	// DbgOutStr("pckt = 0x%x\r\n", pckt, 0,0,0,0);

	timer = (long)startinterval();

	/* wait for valid pckt-start character */
	timeout = (long)(xc->mdmx_pckttime * 10);

	while (!started)
		{
#if FALSE
		if (kbd_check_flagkey(xc->flagkey, TRUE))
			{
			kbd_flush();
			return(BLK_ABORTED);
			}
#endif

		if (xfer_carrier_lost(hSession))
			return CARRIER_LOST;

		if (xfer_user_interrupt(hSession))
			{
			mdmxdspLastError(xc, BLK_ABORTED);
			return(BLK_ABORTED);
			}

		mdmx_progress(xc, 0);

		if ((long)interval(timer) > timeout)
			return(NO_PCKT);

		// if ((cc = RemoteGet(hSession)) != -1)
		if (mComRcvChar(xc->hCom, &cc) != 0)
			{
			DbgOutStr("pckt = 0x%x\r\n", pckt, 0,0,0,0);
			switch(pckt->start_char = (unsigned char)cc)
				{
			case EOT:
				if (xc->xfertimer == -1L)
					xc->xfertimer = (long)startinterval();
				return(END_PCKT);
				/*lint -unreachable*/
				break;

			case SOH:
			case STX:
				started = TRUE;
				if (xc->xfertimer == -1L)
					xc->xfertimer = (long)startinterval();
				break;

			case CAN:
				/* if two consecutive CANs are received, drop out */
				if (gotCAN)
					return(CANNED);
				gotCAN = TRUE;
				break;

			default:
				/* ignore */
				gotCAN = FALSE; /* two CANs must be consecutive */
				break;
				}
			}
		else
			{
			xfer_idle(hSession, XFER_IDLE_IO);
			}
		}
	/* got valid start character, get packet numbers, data, & error codes */
	timeout = xc->mdmx_chartime * 10;
	cp = &pckt->pcktnum;
	count = 2;
	for (;;)
		{
		if (!xr_collect(xc, count, timeout, &cp, &checksum, &crc))
			return(SHORT_PCKT);
		if (!gothdr)
			{
			/* got pckt numbers, now get data and check code(s) */
			gothdr = TRUE;
			count = (pckt->start_char == STX ? LARGE_PACKET : SMALL_PACKET);
			count += (xc->check_type == CRC ? 2 : 1);
			checksum = 0;
			crc = 0;
			cp = pckt->bdata;
			}
		else
			break;
		}

	/* all bytes have been collected, check for valid packet */
	if (xc->check_type == CHECKSUM)
		{
		/* at this point we've included the checksum itself in the checksum
		 *	calculation. We need to back up, subtract the last char. from
		 *	the computation and use it for comparison instead.
		 */
		--cp;						/* point to received checksum */
		checksum = (unsigned char)(checksum - *cp);	/* we added one too many */
		if (checksum != *cp)
			return(BAD_CHECK);
		}
	else if (crc != 0)
			return(BAD_CHECK);

	if (pckt->pcktnum != (unsigned char)((~pckt->npcktnum) & 0xFF))
		{
		return(BAD_FORMAT);
		}

	if (pckt->pcktnum != (unsigned char)(expect % 256))
		{
		/* we always start out expecting ymodem batch, on an xmodem
		 *	 transfer, this code will detect the situation.
		 */
		if (!xc->filen && expect == 0 && pckt->pcktnum == 1)
			return NOBATCH_PCKT;
		else if (pckt->pcktnum == (unsigned char)((expect % 256) - 1))
			return REPEAT_PCKT; 	/* repeated packets are harmless */
		else
			return WRONG_PCKT;
		}

	/* if we got this far, the pckt is good */
	return(GOOD_PCKT);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * respond
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC void  respond(HSESSION hSession, ST_MDMX *xc, char code)
	/* wait for line to clear, then send code */
	{
	int i;

	ComSendChar(xc->hCom, &xc->stP, code);
	if (code == CAN)
		{
		for (i = 4 + 1; --i > 0; )
			ComSendChar(xc->hCom, &xc->stP, CAN);
		}
	ComSendWait(xc->hCom, &xc->stP);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xm_clear_input
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
STATIC_FUNC void  xm_clear_input(HSESSION hSession)
	{
	// RemoteClear(hSession); /* make sure no junk is left sitting in it */
	ComRcvBufrClear(sessQueryComHdl(hSession));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xm_rcheck
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
STATIC_FUNC void xm_rcheck(ST_MDMX *xc, HSESSION hSession, int before)
	{
	if (xc->streaming)
		{
		/* Do it different for YMODEM-G, since the sender won't wait for ACK */
#if FALSE
		if (before)
			suspendinput(FLG_DISK_ACTIVE, 5);
		else
			allowinput(FLG_DISK_ACTIVE);
#endif
		}
	else
		{
		if (before)
			{
			/* wait till next packet is in before writing to disk */
			if (xc->next_pckt->result == UNDEFINED)
				xc->next_pckt->result = wait_receive(xc);
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xm_check_input
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC void xm_check_input(HSESSION hSession, int suspend)
	{
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xr_collect
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int  xr_collect(ST_MDMX *xc, int count, long timeout,
			 unsigned char **ptr,
			 unsigned char *checksum, unsigned *crc)
	{
	unsigned char lchecksum;
	unsigned char *cp, *head;
	TCHAR rchar;
	int cnt;
	long timer;

	head = cp = *ptr;
	lchecksum = *checksum;
	cnt = count;

	while (cnt--)
		{
		// if ((rchar = RemoteGet(xc->hSession)) == -1)
		if (mComRcvChar(xc->hCom, &rchar) == 0)
			{
			xfer_idle(xc->hSession, XFER_IDLE_IO);
			/* driver hasn't put any new chars in rmt_bufr */
			timer = (long)startinterval();
			// while ((rchar = RemoteGet(xc->hSession)) == -1)
			while (mComRcvChar(xc->hCom, &rchar) == 0)
				{
				/* check for char timeout */
				xfer_idle(xc->hSession, XFER_IDLE_IO);
				if ((long)interval(timer) > timeout)
					return(FALSE);
				}
			}
		*cp = (unsigned char)rchar;
		lchecksum += *cp;
		++cp;
		}
	*ptr = cp;
	*checksum = lchecksum;
	if (count > 100)
		*crc = calc_crc(xc, (unsigned)0, head, count);
	return(TRUE);
	}

/***************************** end of mdmx_rcv.c **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx_crc.c ===
/*	File: D:\WACKER\xfer\mdmx_crc.c (Created: 18-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 4/12/02 5:00p $
 */
#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\assert.h>
#include <tdll\file_io.h>

#include "foo.h"

#include "mdmx.h"
#include "mdmx.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-==-=
 * FUNCTION:
 *	calc_crc
 *
 * DESCRIPTION:
 *	This is a C language replacement for the following assembly language code.
 *
 *			TITLE	mdmx_crc
 *
 *			cdecl=1
 *
 *		IFDEF cdecl
 *			.model medium,C
 *		ELSE
 *			.model medium,PASCAL
 *		ENDIF
 *			.CODE	XFER_TEXT
 *
 *		; unsigned cdecl calc_crc(unsigned startval, uchar *pntr, int count)
 *		calc_crc	PROC USES SI, startval:WORD, pntr:PTR BYTE, count:WORD
 *			mov	ax,startval	; get starting value
 *			mov	si,pntr 	; get pointer to data to check
 *			mov	bx,count	; get count of characters
 *
 *		cnt:	mov	dl,[si] 	; get next character
 *			inc	si		; ++pntr
 *			mov	cx,8		; cycle through 8 bits
 *		ccycle: rol	dl,1		; rotate bit into CRC
 *			rcl	ax,1
 *			jnc	noxor
 *			xor	ax,1021h	; perform XOR for 1 bits
 *		noxor:	loop	ccycle
 *			dec	bx		; keep count of characters checked
 *			jnz	cnt
 *			ret
 *
 *		calc_crc	ENDP
 *
 *			END
 *
 *
 * PARAMETERS:
 *
 * RETURNS:
 */

unsigned short calc_crc(ST_MDMX *pX,
						unsigned short startval,
						LPSTR pntr,
						int cnt)
	{
	int i;
	unsigned short crc_16;

	/*
	 * This code was taken from "crctst.c" in HA5.  If it doesn't work, check
	 * the code that is used in ZMODEM.HH in the "updcrc" macro.  It might
	 * work better.
	 *
	 * Yes, it did work better.
	 */
	assert(pX->p_crc_tbl);

	crc_16 = startval;

	for (i = 0; i < cnt; ++i)
		crc_16 = pX->p_crc_tbl[((crc_16 >> 8) & 255)] ^ (crc_16 << 8) ^ *pntr++;

	return crc_16;
	}


// --------------------------------------------------------------------
//
// The following was taked directly from shared code for HyperACCESS
// "\shared\xfer\crctable.c". REV: 4/5/2002
//
// --------------------------------------------------------------------
//

/* table for CRC calculations in CompuServe B protocol */
const unsigned short usCrc16Lookup[256] =
	{
	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
	};

/*
 * Copyright (C) 1986 Gary S. Brown.  You may use this program, or
 * code or tables extracted from it, as desired without restriction.
 */

/* First, the polynomial itself and its table of feedback terms.  The  */
/* polynomial is                                                       */
/* X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 */
/* Note that we take it "backwards" and put the highest-order term in  */
/* the lowest-order bit.  The X^32 term is "implied"; the LSB is the   */
/* X^31 term, etc.  The X^0 term (usually shown as "+1") results in    */
/* the MSB being 1.                                                    */

/* Note that the usual hardware shift register implementation, which   */
/* is what we're using (we're merely optimizing it by doing eight-bit  */
/* chunks at a time) shifts bits into the lowest-order term.  In our   */
/* implementation, that means shifting towards the right.  Why do we   */
/* do it this way?  Because the calculated CRC must be transmitted in  */
/* order from highest-order term to lowest-order term.  UARTs transmit */
/* characters in order from LSB to MSB.  By storing the CRC this way,  */
/* we hand it to the UART in the order low-byte to high-byte; the UART */
/* sends each low-bit to hight-bit; and the result is transmission bit */
/* by bit from highest- to lowest-order term without requiring any bit */
/* shuffling on our part.  Reception works similarly.                  */

/* The feedback terms table consists of 256, 32-bit entries.  Notes:   */
/*                                                                     */
/*     The table can be generated at runtime if desired; code to do so */
/*     is shown later.  It might not be obvious, but the feedback      */
/*     terms simply represent the results of eight shift/xor opera-    */
/*     tions for all combinations of data and CRC register values.     */
/*                                                                     */
/*     The values must be right-shifted by eight bits by the "updcrc"  */
/*     logic; the shift must be unsigned (bring in zeroes).  On some   */
/*     hardware you could probably optimize the shift in assembler by  */
/*     using byte-swap instructions.                                   */

const unsigned long ulCrc32Lookup[256] = /* CRC polynomial 0xedb88320 */
	{
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
	0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
	0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
	0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
	0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
	0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
	0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
	0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
	0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
	0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
	0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
	0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
	0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
	0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
	0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
	0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
	0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
	0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
	0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
	0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
	0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
	0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
	0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
	0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
	0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
	0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
	0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
	0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
	0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
	0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
	0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
	0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
	0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
	0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
	0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
	0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
	0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
	0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
	0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
	0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
	0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
	0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
	0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
	0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
	0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
	0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
	0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
	0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
	0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
	0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
	0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfer.h ===
/*	File: D:\WACKER\xfer\xfer.h (Created: 16-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 8 $
 *	$Date: 7/11/02 11:11a $
 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 *	This module contains all the function prototypes and associated data
 *	types that are needed to start transfers.
 *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

// CRC Calculation lookup tables
extern const unsigned short usCrc16Lookup[ ];
extern const unsigned long  ulCrc32Lookup[ ];

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Error codes from transfer routines */

#define	XFR_ERR_BASE			0x100

#define	XFR_NO_MEMORY			XFR_ERR_BASE+1
#define	XFR_BAD_PROTOCOL		XFR_ERR_BASE+2
#define	XFR_BAD_POINTER			XFR_ERR_BASE+3
#define	XFR_BAD_PARAMETER		XFR_ERR_BASE+4
#define XFR_IN_PROGRESS         XFR_ERR_BASE+5
#define XFR_NO_CARRIER          XFR_ERR_BASE+6
#define XFER_CNCT               XFR_ERR_BASE+7

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*
 * This structure contains the "generic" transfer parameters.
 * The values are set in the Transfer Send and Transfer Receive
 * dialogs and then passed to the transfer routines in the
 * session handle.
 */

struct xfer_parameters
	{
	int nSize;					/* Set to the size of this structure */

	/*
	 * This section is for receiving parameters
	 */
	int nRecProtocol;			/* default receiving protocol, see below */
	int fUseFilenames;			/* TRUE to use received filenames */
	int fUseDateTime;			/* TRUE to use received date and time */
	int fUseDirectory;			/* TRUE to use received directory */
	int fSavePartial;			/* TRUE to save partial files */

#define	XFR_RO_ALWAYS			0x1
#define	XFR_RO_NEVER			0x2
#define	XFR_RO_APPEND			0x3
#define	XFR_RO_NEWER			0x4
#define	XFR_RO_REN_DATE			0x5
#define	XFR_RO_REN_SEQ			0x6
	int nRecOverwrite;			/* default overwrite options */

	/*
	 * This section is for sending parameters
	 */
	int nSndProtocol;			/* default sending protocol, see below */
	int fChkSubdirs;			/* TRUE to check subdirs on search op */
	int fIncPaths;				/* TRUE to send paths to receiver */
	};

typedef struct xfer_parameters XFR_PARAMS;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/* Protocols supported */

#define	XF_HYPERP		1
#define	XF_ZMODEM		2
#define	XF_XMODEM		3
#define	XF_XMODEM_1K	4
#define	XF_YMODEM		5
#define	XF_YMODEM_G		6
#define	XF_KERMIT		7
#define	XF_CSB			8
#define	XF_ZMODEM_CR	9

#define	PROTOCOL_NAME_LENGTH 40
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

struct xfer_protocol
	{
	int nProtocol;
        TCHAR acName[PROTOCOL_NAME_LENGTH];   /* that should be big enough. JPN needs 32bytes at least*/
	};

typedef struct xfer_protocol XFR_PROTOCOL;

extern int WINAPI xfrGetProtocols(const HSESSION hSession,
								const XFR_PROTOCOL **ppList);


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#if defined(DEADWOOD)
extern int WINAPI xfrGetParameters(const HSESSION hSession,
								const int nProtocol,
								const HWND hwnd,
								VOID **ppData); /* protocol parameters */
#endif // defined(DEADWOOD)


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

struct xfer_receive
	{
	int nProtocol;				/* what protocol to use */
	XFR_PARAMS *pParams;		/* general transfer parameters */
	VOID *pProParams;			/* protocol specific parameters */
	LPTSTR pszDir;				/* prototype directory string */
	LPTSTR pszName;				/* prototype filename string */
	};

typedef struct xfer_receive XFR_RECEIVE;

extern int WINAPI xfrReceive(const HSESSION hSession,
								const XFR_RECEIVE *pXferRec);


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

struct xfer_send_list
	{
	long lSize;
	LPTSTR pszName;
	};

typedef struct xfer_send_list XFR_LIST;

struct xfer_send
	{
	int nProtocol;				/* what protocol to use */
	XFR_PARAMS *pParams;		/* general transfer parameters */
	VOID *pProParams;			/* protocol specific parameters */
	int nCount;					/* number of files to send */
	int nIndex;					/* current index into the list */
	long lSize;					/* total size of files in list */
	XFR_LIST *pList;			/* pointer to the list */
	};

typedef struct xfer_send XFR_SEND;

extern int WINAPI xfrSend(const HSESSION hSession,
							const XFR_SEND *pXferSend);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#define XF_DUPNAME_MASK 		0x00000F00L
#define XF_DUPNAME_APPEND		0x00000100L
#define XF_DUPNAME_OVERWRT		0x00000200L
#define XF_DUPNAME_REFUSE		0x00000300L
#define XF_DUPNAME_NEWER		0x00000400L
#define XF_DUPNAME_DATE 		0x00000500L
#define XF_DUPNAME_SEQ			0x00000600L

#define XF_CHECK_VIRUS			0x00001000L

#define XF_USE_FILENAME 		0x00002000L

#define XF_USE_DIRECTORY		0x00004000L

#define	XF_SAVE_PARTIAL			0x00008000L

#define	XF_USE_DATETIME			0x00010000L

#define XF_INCLUDE_SUBDIRS		0x00020000L

#define XF_INCLUDE_PATHS		0x00040000L

struct st_rcv_open
	{
	HANDLE bfHdl;
	TCHAR *pszSuggestedName;
	TCHAR *pszActualName;
	LONG  lInitialSize;
	// struct s_filetime FAR *pstFtCompare;
	LONG  lFileTime;
	// SSHDLMCH ssmchVscanHdl;
	VOID (FAR *pfnVscanOutput)(VOID FAR *hSession, USHORT usID);
	};

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

int xfer_makepaths(HSESSION hSession, LPTSTR pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx.hh ===
/* File: C:\WACKER\xfer\mdmx.hh (Created: 17-Jan-1994)
 * created from HAWIN source file
 * mdmx.hh -- Internal definitions for xmodem file transfer routines
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 4/12/02 5:00p $
 */


/* Various constants */
#define SMALL_PACKET 128
#define LARGE_PACKET 1024
#define SMALL_WAIT	50
#define MEDIUM_WAIT 200
#define LARGE_WAIT	400

/* Block results */
#define UNDEFINED	   0
#define GOOD_PCKT	   1
#define ALT_PCKT	   2
#define NOBATCH_PCKT   3
#define END_PCKT	   4
#define REPEAT_PCKT    5
#define WRONG_PCKT	   6
#define SHORT_PCKT	   7
#define BAD_FORMAT	   8
#define BAD_CHECK	   9
#define NO_PCKT 	   10
#define BLK_ABORTED    11
#define CARRIER_LOST   12
#define CANNED		   13

/* Responses include any character plus the following: */
#define NO_RESPONSE 	-1
#define ABORTED 		-2	/* also used as BlockReceive status */
#define CARR_LOST		-3

/* transfer status codes */
#define XS_OK			  0
#define XS_ABORTED		  1
#define XS_CANCELLED	  2
#define XS_NO_RESPONSE	  3
#define XS_COMMERR		  4
#define XS_FILEERR		  5
#define XS_SYNCHERR 	  6
#define XS_NOSPACE		  7
#define XS_CANTOPEN 	  8
#define XS_COMPLETE 	  9
#define XS_SHORTFILE	  10
#define XS_BATCH_EXPECTED 11

/* Status codes for mdmx_progress */
#define FILE_DONE	  1
#define TRANSFER_DONE 2

/* Control structure, allocated during transfers to hold control variables */
typedef	struct s_mdmx_cntrl ST_MDMX;
struct s_mdmx_cntrl
	{
	HSESSION				hSession;
	HCOM					hCom;			/* derived from the above */

	int						nProto;			/* The current protocol */

	long					file_bytes;
	long					total_bytes;
	void					*flagkey;
	ST_IOBUF				*fh;
	long					basesize;
	long					xfertimer;
	long					xfertime;
	unsigned				nfiles;
	unsigned				filen;
	long					filesize;
	long					nbytes;
	long					mdmx_byte_cnt;	/* count of bytes transferred */
	long					displayed_time;	/*  = -1L; */

	struct s_mdmx_pckt		*next_pckt;
	unsigned				this_pckt;

	int						check_type;
	int						batch;
	int						streaming;

	const unsigned short	*p_crc_tbl;		/* pointer to the CRC-16 table */

	int						mdmx_chkt;
	int						mdmx_tries;
	int						mdmx_chartime;
	int						mdmx_pckttime;

	stFB					stP;			/* Used in ComSend functions */

	int						(*p_getc)(ST_MDMX *);
	int						(*p_putc)(ST_MDMX *, int);
	};

// typedef	struct s_mdmx_cntrl ST_MDMX;

/* Global control variables */
// extern struct s_mdmx_cntrl *xc;
// extern metachar (NEAR *p_getc)(VOID); // for snd
// extern metachar (NEAR *p_putc)(metachar); // for rcv


/* Packet structure: allocated during transfers to hold packet contents */
struct s_mdmx_pckt
	{
	int    result;
	int    expected;
	int    pcktsize;
	long   byte_count;
	BYTE   start_char;
	BYTE   pcktnum;
	BYTE   npcktnum;
	BYTE   bdata[1];
	};

/* function prototypes : */
extern void	 mdmx_progress(ST_MDMX *pX, int status);

// extern unsigned calc_crc(unsigned startval, BYTE *pntr, int count);

extern unsigned short calc_crc(ST_MDMX *pX,
								unsigned short startval,
								LPSTR pntr,
								int cnt);

int load_pckt(ST_MDMX *pX,
				 struct s_mdmx_pckt *p,
				 unsigned pcktnum,
				 int kpckt,
				 int chktype);

int xm_getc(ST_MDMX *pX);

int xs_unload(ST_MDMX *pX, BYTE *cp, int size);

int xm_putc(ST_MDMX *pX, int c);


/*
 * the following were added for HA5G
 */

#define ComSendInit(h,p)		fooComSendClear(h,p)
#define ComSendWait(h,p)		fooComSendPush(h,p)
#define ComSendPush(h,p)		fooComSendPush(h,p)
#define ComSendChar(h,p,c)		fooComSendChar(h,p,c)
#define ComSendCharNow(h,p,c)	fooComSendCharNow(h,p,c)

// #define RemoteGet(h)		mComRcvChar(mGetComHdl(h))
// #define RemoteClear(h)		mComRcvBufrClear(mGetComHdl(h))

#define SOH 1
#define STX 2
#define EOT 4
#define ACK 6
#define	CAN	0x18
#define NAK 025
#define	ESC 0x1B

#define CPMEOF 032

extern void mdmxXferInit(ST_MDMX *pX, int method);

/*
 * The following are display functions, some of which might be removed and
 * replaced with MACROS.
 */

extern void mdmxdspFilecnt(ST_MDMX *pX, int cnt);

extern void mdmxdspErrorcnt(ST_MDMX *pX, int cnt);

extern void mdmxdspPacketErrorcnt(ST_MDMX *pX, int cnt);

extern void mdmxdspTotalsize(ST_MDMX *pX, long bytes);

extern void mdmxdspFilesize(ST_MDMX *pX, long fsize);

extern void mdmxdspNewfile(ST_MDMX *pX,
						   int filen,
						   LPSTR theirname,
						   LPTSTR ourname);

extern void mdmxdspProgress(ST_MDMX *pX,
							long stime,
							long ttime,
							long cps,
							long file_so_far,
							long total_so_far);

extern void mdmxdspChecktype(ST_MDMX *pX, int ctype);

extern void mdmxdspPacketnumber(ST_MDMX *pX, long number);

extern void mdmxdspLastError(ST_MDMX *pX, int errcode);

extern void mdmxdspCloseDisplay(ST_MDMX *pX);

/* end of mdmx.hh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx_sd.c ===
/* File: C:\WACKER\xfer\mdmx_sd.c (Created: 17-Jan-1994)
 * created from HAWIN
 * mdmx_sd.c -- Routines to handle xmodem displays for HA5a/G
 *
 *	Copyright 1989, 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 7/12/02 8:10a $
 */
#include <windows.h>
#pragma hdrstop

#include <setjmp.h>

#define	BYTE	unsigned char

#include <tdll\assert.h>
#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\xfer_msc.h>
#include <tdll\load_res.h>
#include <term\res.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>
#include <tdll\com.h>
#include "xfr_srvc.h"
#include "xfr_todo.h"
#include "xfr_dsp.h"
#include "xfer_tsc.h"
#include "foo.h"

#include "xfer.h"
#include "xfer.hh"

#include "mdmx.h"
#include "mdmx.hh"

void mdmxXferInit(ST_MDMX *xc, int method)
	{
	XFR_XY_PARAMS *pX;
	#if defined(DEADWOOD)
	DWORD         nLen;
	#endif // defined(DEADWOOD)

	if (xc)
		{
		ComSndBufrClear(sessQueryComHdl((xc->hSession)));
		ComRcvBufrClear(sessQueryComHdl((xc->hSession)));

		pX = (XFR_XY_PARAMS *)xfer_get_params(xc->hSession, method);
		assert(pX);

		if (pX)
			{
			switch (pX->nErrCheckType)
				{
				default:
				case XP_ECP_AUTOMATIC:
					xc->mdmx_chkt = UNDETERMINED;
					break;
				case XP_ECP_CRC:
					xc->mdmx_chkt = CRC;
					break;
				case XP_ECP_CHECKSUM:
					xc->mdmx_chkt = CHECKSUM;
					break;
				}
			xc->mdmx_tries        = pX->nNumRetries;
			xc->mdmx_chartime     = pX->nByteWait;
			xc->mdmx_pckttime     = pX->nPacketWait;
			}
		else
			{
			//
			// Set to the defaults set in xfrInitializeXandYmodem().
			//
			xc->mdmx_chkt = UNDETERMINED;
			xc->mdmx_tries        = 10;
			xc->mdmx_chartime     = 5;
			xc->mdmx_pckttime     = 20;
			}

		xc->p_putc            = xm_putc;
		// Should we do this ?
		// xc->p_getc            = xm_getc;

		xc->p_crc_tbl         = NULL;

		#if defined(DEADWOOD)
		resLoadDataBlock(glblQueryDllHinst(),
						IDT_CSB_CRC_TABLE,
						&xc->p_crc_tbl,
						&nLen);
		assert(nLen != 0);
		#else // defined(DEADWOOD)
		xc->p_crc_tbl = usCrc16Lookup;
		#endif // defined(DEADWOOD)
		}
	}

void mdmxdspFilecnt(ST_MDMX *pX, int cnt)
	{
	if (pX)
		{
		xferMsgFilecnt(pX->hSession, cnt);
		}
	}

void mdmxdspErrorcnt(ST_MDMX *pX, int cnt)
	{
	if (pX)
		{
		xferMsgErrorcnt(pX->hSession, cnt);
		}
	}

void mdmxdspPacketErrorcnt(ST_MDMX *pX, int cnt)
	{
	if (pX)
		{
		xferMsgPacketErrcnt(pX->hSession, cnt);
		}
	}

void mdmxdspTotalsize(ST_MDMX *pX, long bytes)
	{
	if (pX)
		{
		xferMsgTotalsize(pX->hSession, bytes);
		}
	}

void mdmxdspFilesize(ST_MDMX *pX, long fsize)
	{
	if (pX)
		{
		xferMsgFilesize(pX->hSession, fsize);
		}
	}

void mdmxdspNewfile(ST_MDMX *pX,
					int filen,
					LPSTR theirname,
					LPTSTR ourname)
	{
	if (pX)
		{
		xferMsgNewfile(pX->hSession,
					   filen,
					   theirname,
					   ourname);
		}
	}

void mdmxdspProgress(ST_MDMX *pX,
					 long stime,
					 long ttime,
					 long cps,
					 long file_so_far,
					 long total_so_far)
	{
	if (pX)
		{
		xferMsgProgress(pX->hSession,
						stime,
						ttime,
						cps,
						file_so_far,
						total_so_far);
		}
	}


void mdmxdspChecktype(ST_MDMX *pX, int ctype)
	{
	if (pX)
		{
		xferMsgChecktype(pX->hSession, ctype);
		}
	}

void mdmxdspPacketnumber(ST_MDMX *pX, long number)
	{
	if (pX)
		{
		xferMsgPacketnumber(pX->hSession, number);
		}
	}

void mdmxdspLastError(ST_MDMX *pX, int errcode)
	{
	if (pX)
		{
		xferMsgLasterror(pX->hSession, errcode);
		}
	}

void mdmxdspCloseDisplay(ST_MDMX * pX)
	{
	if (pX)
		{
		xferMsgClose(pX->hSession);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx_res.c ===
/* File: C:\WACKER\tdll\mdmx_res.c (Created: 17-Jan-1994)
 * created from HAWIN source file
 * mdmx_res.c -- Routines to handle xmodem sending for HA5G
 *
 *	Copyright 1989,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */
#include <windows.h>
#pragma hdrstop

#include <setjmp.h>

#define	BYTE	unsigned char

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\xfer_msc.h>
#include <tdll\file_io.h>
#include "xfr_srvc.h"
#include "xfr_todo.h"
#include "xfr_dsp.h"
#include "xfer_tsc.h"
#include "foo.h"

#include "xfer.h"
#include "xfer.hh"

#include "mdmx.h"
#include "mdmx.hh"

/*lint -e502*/				/* lint seems to want the ~ operator applied
							 *	only to unsigned, wer'e using uchar
							 */

// #pragma optimize("a", on)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * load_pckt
 *
 * DESCRIPTION:
 *	Prepares an XMODEM packet for transmission by filling it with data and
 *	initializing other fields such as
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int load_pckt(ST_MDMX *pX,
			 struct s_mdmx_pckt *p,
			 unsigned pcktnum,
			 int kpckt,
			 int chktype)
	{
	BYTE checksum;
	unsigned int crc;
	BYTE *cp;
	int cnt;
	int cc;

	p->pcktnum = (BYTE)(pcktnum % 0x100);
	p->npcktnum = (BYTE)(~p->pcktnum);
	cp = p->bdata;
	checksum = 0;
	p->result = 0;				/* will set TRUE if end of data is reached */

	for (cnt = (kpckt ? LARGE_PACKET : SMALL_PACKET); cnt > 0; --cnt)
		{
		if ((cc = (*pX->p_getc)(pX)) == EOF)
			{
			p->result = 1;			/* so compression display won't check */
#if FALSE
			/* TODO: figure out how to do this */
			if (nb_error(pX->fh))
				return FALSE;
#endif
			break;
			}
		checksum += (*cp++ = (BYTE)cc);
		}

	/* see if we're at end of file */
	if (cnt == (kpckt ? LARGE_PACKET : SMALL_PACKET))
		{
		p->start_char = EOT;
		p->pcktsize = 1;
		return TRUE;
		}

	/* if using large packets but this one is small enough, switch */
	if (kpckt && ((LARGE_PACKET-cnt) <= SMALL_PACKET))
		{
		kpckt = FALSE;						 /* set small packet flag	 */
			/* set count to 128-(1024-cnt)	*/
		cnt = (SMALL_PACKET - (LARGE_PACKET - cnt));
		}

	while (cnt-- > 0)
		{
		*cp++ = CPMEOF;
		checksum += CPMEOF;
		}

	p->start_char = (BYTE)(kpckt ? STX : SOH);
	p->pcktsize = (kpckt ? LARGE_PACKET : SMALL_PACKET) + 4;
	p->byte_count = pX->mdmx_byte_cnt;/* amt. transferred after this packet */
									/*	 is sent						  */
	if (chktype == CHECKSUM)
		{
		*cp = checksum;
		}
	else
		{
		*cp = 0;
		*(cp + 1) = 0;

		crc = calc_crc(pX, (unsigned)0, p->bdata,
				(kpckt ? LARGE_PACKET : SMALL_PACKET) + 2 );

		*cp++ = (BYTE)(crc / 0x100);
		*cp = (BYTE)(crc % 0x100);
		++p->pcktsize;
		}
	return(TRUE);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xm_getc
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int xm_getc(ST_MDMX *pX)
	{

	++pX->mdmx_byte_cnt;
	return(fio_getc(pX->fh));
	// return(nb_getc(pX->fh));
	}


// Receive routines

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int xs_unload(ST_MDMX *pX, BYTE *cp, int size)
	{
	int cnt;

	for (cnt = size + 1; --cnt > 0; )
		{
		if ((*pX->p_putc)(pX, (int)*cp++) == (-1) /* ERROR */)
			return ERROR;
		}
	return 0;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xm_putc
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int NEAR xm_putc(ST_MDMX *pX, int c)
	{

	pX->mdmx_byte_cnt += 1;
	return ((int)(fio_putc(c, pX->fh)));
	// return ((int)(nb_putc(c, pX->fh)));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\mdmx_snd.c ===
/* mdmx_snd.c -- Routines to handle xmodem sending for HA5G
 *
 *	Copyright 1989 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 4/24/02 3:49p $
 */
#include <windows.h>
#include <stdlib.h>

#pragma hdrstop
// #include <setjmp.h>

#define	BYTE	unsigned char

#include <tdll\mc.h>
#include <tdll\stdtyp.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\file_io.h>
#include <tdll\htchar.h>
#include "xfr_srvc.h"
#include "xfr_todo.h"
#include "xfr_dsp.h"
#include "xfer_tsc.h"
#include "foo.h"

#include "cmprs.h"

#include "xfer.h"
#include "xfer.hh"

#include "mdmx.h"
#include "mdmx.hh"

#if !defined(STATIC_FUNC)
#define	STATIC_FUNC
#endif

#if !defined(CMPRS_MINSIZE)
#define	CMPRS_MINSIZE	4000L
#endif

/* * * * * * * * * * * * * * * *
 *	local function prototypes  *
 * * * * * * * * * * * * * * * */

STATIC_FUNC	int xsend_start(ST_MDMX *xc, BYTE *start_chars, int *start_char);

STATIC_FUNC	int getresponse(ST_MDMX *xc, int time);

STATIC_FUNC	void make_file_pckt(ST_MDMX *xc,
								struct s_mdmx_pckt *p,
								char *fname,
								long size);

/* * * * * * * *
 *	Functions  *
 * * * * * * * */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * mdmx_snd
 *
 * DESCRIPTION:
 *	Sends a file using XMODEM or YMODEM protocol. Support 1k packets, batch
 *	transfers and 'G' option streaming.
 *
 * ARGUMENTS:
 *	attended -- TRUE if user is probably in attendance. Controls the display
 *				of some messages.
 *
 * RETURNS:
 *	True if transfer completes successfully, FALSE otherwise.
 */
int mdmx_snd(HSESSION hSession, int attended, int method, unsigned nfiles, long nbytes)
	{
	ST_MDMX *xc;
	struct s_mdmx_pckt * this_pckt = NULL;
	struct s_mdmx_pckt * next_pckt = NULL;
	struct s_mdmx_pckt * tpckt;

	/* column values for display box */
	TCHAR	 sfname[FNAME_LEN];// file name of file being sent
	TCHAR	 xname[FNAME_LEN]; // transmitted file name
	int	 still_trying;		// controls exit from main transfer loop
	int	 got_file;			// controls when to complete batch op
	int	 got_response;		// controls loop to get valid response
	int 	 tries = 0; 		// number of retries for each packet
	unsigned total_tries;		// number of retries for entire transfer
	int 	 response;			// response char. received from other end
	BYTE	 start_chars[3];	// acceptable start chars. from receiver
	int 	 xstatus = TSC_OK;  // winds up with overall status of transfer
	int 	 check_type;		// type of error checking in use
	unsigned pcktn; 			// number of packet currently being sent
	int	 override = FALSE;	// set TRUE if comm. details changed to
	unsigned int uiOldOptions;
	int	 batch; 			// TRUE if YMODEM batch transfers used
	int	 big_pckts; 		// TRUE if 1K packets are allowed
	int	 streaming; 		// TRUE if no packet responses expected

	if (xfer_set_comport(hSession, TRUE, &uiOldOptions) != TRUE)
		{
		goto done;
		}
	else
		{
		override = TRUE;
		}

	/* set up options based on method used */
	big_pckts = (method != XF_XMODEM);
	batch = (method == XF_YMODEM || method == XF_YMODEM_G);
	streaming = FALSE;	/* will be turned on if receiver starts with 'G' */
	// assert(nfiles == 1 || batch);

	this_pckt = NULL;
	next_pckt = NULL;

	xc = malloc(sizeof(ST_MDMX));
	if (xc == NULL)
		{
		goto done;
		}
	memset(xc, 0, sizeof(ST_MDMX));

	xc->hSession = hSession;
	xc->hCom     = sessQueryComHdl(hSession);

	// RemoteClear(hSession);
	ComRcvBufrClear(xc->hCom);

	this_pckt = malloc(sizeof(ST_MDMX) +
					   (big_pckts ? LARGE_PACKET : SMALL_PACKET) + 2);
	if (this_pckt == NULL)
		{
		goto done;
		}
	memset(this_pckt, 0, sizeof(ST_MDMX) +
						   (big_pckts ? LARGE_PACKET : SMALL_PACKET) + 2);

	next_pckt = malloc(sizeof(ST_MDMX) +
					   (big_pckts ? LARGE_PACKET : SMALL_PACKET) + 2);
	if (next_pckt == NULL)
		{
		goto done;
		}
	memset(next_pckt, 0, sizeof(ST_MDMX) +
						   (big_pckts ? LARGE_PACKET : SMALL_PACKET) + 2);

	mdmxXferInit(xc, method);  /* Could be smaller but this is easier */
	if (xc->p_crc_tbl == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	// hp_report_xtime(0);	   /* make invalid in case transfer bombs */
	xc->file_bytes = 0L;
	xc->total_bytes = 0L;
	xc->fh = NULL;
	xc->xfertimer = -1L;
	xc->nfiles = nfiles;	/* make these available to display routines */
	xc->filen = 0;
	xc->filesize = -1L;
	xc->nbytes = nbytes;

	mdmxdspTotalsize(xc, nbytes);
	mdmxdspFilecnt(xc, nfiles);

	xc->mdmx_byte_cnt = 0;
	StrCharCopy(start_chars, (batch ? "CG" : "C\x15"));  /* \x15 is NAK */
	check_type = CRC;
	mdmxdspChecktype(xc, (check_type == CRC) ? 0 : 1);
	total_tries = 0;
	mdmxdspErrorcnt(xc, total_tries);
	tries = 0;
	mdmxdspPacketErrorcnt(xc, tries);
	got_file = TRUE;
	while (got_file)
		{
		if ((got_file = xfer_nextfile(hSession, sfname)) == TRUE)
			{
			xc->total_bytes += xc->file_bytes;
			xc->file_bytes = xc->mdmx_byte_cnt = 0L;

			mdmxdspNewfile(xc,
						   xc->filen + 1,
						   sfname,
						   sfname);

			++xc->filen;

			if (xfer_opensendfile(hSession,
								  &xc->fh,
								  sfname,
								  &xc->filesize,
								  xname,
								  NULL) != 0)
				{
				xstatus = TSC_CANT_OPEN;
				goto done;
				}
			mdmxdspFilesize(xc, xc->filesize);
			}
		else
			{
			// strblank(xname);
			xname[0] = TEXT('\0');
			}

		pcktn = 0;
		if (batch)
			{
			make_file_pckt(xc, this_pckt, xname, xc->filesize);
			}

		if ((xstatus = xsend_start(xc, start_chars, &response)) != TSC_OK)
			{
			break;
			}

		if (xc->filen <= 1)
			{
			xc->xfertimer = (long)startinterval();	  /* start the clock  */
			if (response == NAK)
				{
				check_type = CHECKSUM;
				}
			mdmxdspChecktype(xc, (check_type == CRC) ? 0 : 1);
			if (response == 'G')
				{
				streaming = TRUE;
				mdmxdspChecktype(xc, 2);
				}

			/* once we've received the first start_char,
			 * subsequent ones must match
			 */
			start_chars[0] = (BYTE)response;
			start_chars[1] = '\0';
			}


		if (got_file)
			{
			xc->p_getc = xm_getc;
			tries = 0;
			if (!batch &&
					!load_pckt(xc, this_pckt, pcktn = 1, big_pckts, check_type))
				{
				xstatus = TSC_DISK_ERROR;
				goto done;
				}
			}


		/* get the first pckt on its way while we prepare the second pckt */
		if ( ComSndBufrSend(xc->hCom,
			                &this_pckt->start_char,
							(unsigned)this_pckt->pcktsize,
							SMALL_WAIT) == COM_PORT_NOT_OPEN )
			{
			xstatus = TSC_LOST_CARRIER;
			still_trying = FALSE;
			goto done;
			}

		mdmxdspPacketnumber(xc, pcktn);

		/* load next pckt*/
		if (got_file && !load_pckt(xc, next_pckt, ++pcktn, big_pckts, check_type))
			{
			xstatus = TSC_DISK_ERROR;
			goto done;
			}

		still_trying = TRUE;
		while (still_trying)
			{
			if (streaming)
				{
				/* these things are done in getresponse() if not streaming */

				if (xfer_carrier_lost(hSession))
					{
					xstatus = TSC_LOST_CARRIER;
					break;
					}

				if (xfer_user_interrupt(hSession))
					{
					xstatus = TSC_USER_CANNED;
					break;
					}
				}

			/* wait until last packet is out before watching for response */
			ComSndBufrWait(xc->hCom,
							this_pckt->pcktsize >= LARGE_PACKET ? LARGE_WAIT :
																  SMALL_WAIT);

			/* get response from receiver */
			got_response = FALSE;
			while (!got_response)
				{
				response = (streaming && this_pckt->start_char != EOT) ?
						ACK : getresponse(xc, 60);

				got_response = TRUE;

				switch(response)
					{
				case ACK:
					if (this_pckt->start_char == EOT)
						{
						/* successful */
						mdmx_progress(xc, FILE_DONE);
						xc->xfertime = (long)interval(xc->xfertimer);
						fio_close(xc->fh);

						xfer_log_xfer(hSession,
									  TRUE,
									  sfname,
									  NULL,
									  TSC_OK);

						xc->fh = NULL;
						xstatus = TSC_OK;
						still_trying = FALSE;
						}
					else
						{
						xc->file_bytes = this_pckt->byte_count;
						tpckt = this_pckt;
						this_pckt = next_pckt;
						next_pckt = tpckt;

						/* pcktn will only be <= 1 when batch is on and
						 *	we've just sent the filename packet (packet 0)
						 */
						if (pcktn <= 1 && (!got_file ||
								(xstatus = xsend_start(xc, start_chars, &response))
								!= TSC_OK))
							{
							still_trying = FALSE;
							break;
							}

						/* send packet */

						if ( ComSndBufrSend(xc->hCom,
									        &this_pckt->start_char,
									        (unsigned)this_pckt->pcktsize,
									        SMALL_WAIT) == COM_PORT_NOT_OPEN)
							{
							xstatus = TSC_LOST_CARRIER;
							still_trying = FALSE;
							break;
							}

						mdmxdspPacketnumber(xc, pcktn);

						mdmx_progress(xc, 0);
						if (tries != 0)
							{
							mdmxdspPacketErrorcnt(xc, 0);

							tries = 0;
							}
						if (this_pckt->start_char != EOT)
							{
							if (!load_pckt(xc, next_pckt, ++pcktn, big_pckts, check_type))
								{
								xstatus = TSC_DISK_ERROR;
								still_trying = FALSE;
								}
							}
						}
					break;

				case NO_RESPONSE:
					mdmxdspLastError(xc, 12);
					still_trying = FALSE;
					break;

				case ABORTED:
					xstatus = TSC_USER_CANNED;
					still_trying = FALSE;
					break;

				case CARR_LOST:
					xstatus = TSC_LOST_CARRIER;
					still_trying = FALSE;
					break;

				case 'C':
				case 'G':
					/* these act as NAKs for packets first packets */
					if (pcktn > 2)
						{
						got_response = FALSE;
						break;
						}
					/* else fall through */
				case NAK:
					if (++tries >= xc->mdmx_tries)
						{
						xstatus = TSC_ERROR_LIMIT;
						goto done;
						}
					else	/* send packet */
						{
						if (ComSndBufrSend(xc->hCom,
									       &this_pckt->start_char,
									       (unsigned)this_pckt->pcktsize,
									       SMALL_WAIT) == COM_PORT_NOT_OPEN)
							{
							xstatus = TSC_LOST_CARRIER;
							still_trying = FALSE;
							break;
							}
						}
					if (this_pckt->start_char == EOT && tries == 1)
						{
						break;	/* don't print first retransmission on final EOT */
						}
					mdmxdspPacketErrorcnt(xc, tries);

					mdmxdspErrorcnt(xc, ++total_tries);

					mdmxdspLastError(xc,
									 (response == NAK) ? 13 : 14);

					break;

				case CAN:
					if (getresponse(xc, 1) == CAN)  /* two consecutive CANs? */
						{
						xstatus = TSC_RMT_CANNED;
						still_trying = FALSE;
						break;
						}
					/* fall through */

				default:
					got_response = FALSE;
					break;
					}

				} /* end while (!got_response) */

			}	/* end while(still_trying) */

		if (!batch || xstatus != TSC_OK)
			{
			break;
			}

		}	/* end while(got_file) */

	done:

	mdmx_progress(xc, TRANSFER_DONE);

	mdmxdspCloseDisplay(xc);

	// ComSendSetCharDelay(hld_send_cdelay, COMSEND_SETDELAY);
	if (override)
		{
		#if FALSE
		cnfg.bits_per_char = hld_bits_per_char;
		cnfg.parity_type = hld_parity_type;
		(void)(*ComResetPort)();
		#endif
		xfer_restore_comport(hSession, uiOldOptions);
		}

	if (xc == NULL || this_pckt == NULL || next_pckt == NULL)
		{
		xstatus = TSC_NO_MEM;
		}

	if (xc != NULL)
		{
		// hp_report_xtime((unsigned)xc->xfertime);
		if (xc->fh)
			{
			fio_close(xc->fh);
			}

		if (xstatus != TSC_OK)
			{
			if (xstatus != TSC_RMT_CANNED && xstatus != TSC_NO_MEM)
				{
				for (tries = 5 + 1; --tries > 0; )
					{
					ComSendChar(xc->hCom, &xc->stP, CAN);
					}
				ComSendPush(xc->hCom, &xc->stP);
				}
			xfer_log_xfer(hSession,
						  TRUE,
						  sfname,
						  NULL,
						  xstatus);
			}

		#if FALSE
		if (attended && xstatus != TSC_USER_CANNED && xstatus != TSC_NO_MEM)
			{
			menu_bottom_line (BL_ESC, 0L);
			DosBeep(beepfreq, beeplen);
			menu_replybox((int)xc->msgrow, ENTER_RESP, 0, (int)transfer_status_msg((unsigned short)xstatus));
			}
		#endif

		if (xc->p_crc_tbl != NULL)
			{
			#if defined(DEADWOOD)
			resFreeDataBlock(xc->hSession, xc->p_crc_tbl);
			xc->p_crc_tbl = NULL;
			#else // defined(DEADWOOD
			//
			// We don't need to free xc->p_crc_tbl since it is pointing
			// to a static constant array. REV: 4/10/2002
			//
			xc->p_crc_tbl = NULL;
			#endif // defined(DEADWOOD)
			}

		free(xc);
		xc = NULL;
		}

	if (this_pckt)
		{
		free(this_pckt);
		this_pckt = NULL;
		}

	if (next_pckt)
		{
		free(next_pckt);
		next_pckt = NULL;
		}

	return((unsigned)xstatus);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * xsend_start
 *
 * DESCRIPTION:
 *	Waits up to one minute for a start request from the receiver at the
 *	other end of the line.
 *
 * ARGUMENTS:
 *	chktype -- Pointer to a variable to be set to the requested error
 *				correction checking method, CRC or Checksum
 *
 * RETURNS:
 *	Status code indicating result. Can be one of
 *		TSC_USER_CANNED if user interrupted by hitting the ESC key.
 *		TSC_NO_RESPONSE if 60 seconds elapses without receiving a start char.
 *		TSC_RMT_CANNED	if remote sends a control-C
 *		TSC_OK			if remote sends proper start char.
 *
 */
STATIC_FUNC int xsend_start(ST_MDMX *xc, BYTE *start_chars, int *start_char)
	{
	for ( ; ; )
		{
		switch(*start_char = getresponse(xc, 60))
			{
		case ABORTED:
			return(TSC_USER_CANNED);

		case NO_RESPONSE:
			return(TSC_NO_RESPONSE);

		case CARR_LOST:
			return(TSC_LOST_CARRIER);

		case ESC:
		case '\003':						/* control-C */
			return(TSC_RMT_CANNED);

		default:
			if (strchr(start_chars, *start_char))
				{
				return(TSC_OK);
				}

			/* ignore any other char. */
			break;
			}
		}
	return TSC_OK;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * getresponse
 *
 * DESCRIPTION:
 *	Waits a specified time for a response from the receiver. Can be forced
 *	to terminate early if user intervention is detected. No effort is made
 *	here to interpret the meaning of a response character. Any character
 *	received within the time limit will be returned.
 *
 * ARGUMENTS:
 *	time -- Number of seconds to wait for a response character.
 *
 * RETURNS:
 *	The response character if one was received or ABORTED or NO_RESPONSE or
 *	CARR_LOST.
 */
STATIC_FUNC int getresponse(ST_MDMX *xc, int time)
	{
	TCHAR rc = 0;
	long timer;

	DbgOutStr("getresponse ", 0,0,0,0,0);

#if FALSE
	if (kbd_check_flagkey(xc->flagkey, TRUE) > 0)
		{
		kbd_flush();
		return ABORTED;
		}
#endif
	if (xfer_user_interrupt(xc->hSession))
		{
		DbgOutStr("aborted\r\n", 0,0,0,0,0);
		return ABORTED;
		}

	// if ((rc = RemoteGet(xc->hSession)) != -1)
	if (mComRcvChar(xc->hCom, &rc) != 0)
		{
		DbgOutStr("returned %d\r\n", rc, 0,0,0,0);
		return(rc & 0x7F);
		}

	time *= 10;
	timer = (long)startinterval();
	while ((long)interval(timer) < (long)time)
		{
#if FALSE
		if (kbd_check_flagkey(xc->flagkey, TRUE) > 0)
			{
			kbd_flush();
			return ABORTED;
			}
#endif

		if (xfer_carrier_lost(xc->hSession))
			{
			DbgOutStr(" lost\r\n", 0,0,0,0,0);
			return CARR_LOST;
			}

		if (xfer_user_interrupt(xc->hSession))
			{
			DbgOutStr("aborted\r\n", 0,0,0,0,0);
			return ABORTED;
			}

		mdmx_progress(xc, 0);

		if (mComRcvChar(xc->hCom, &rc) != 0)
			{
			DbgOutStr("returned %d\r\n", rc, 0,0,0,0);
			return(rc & 0x7F);
			}

		xfer_idle(xc->hSession, XFER_IDLE_IO);

		}
	DbgOutStr(" none\r\n", 0,0,0,0,0);
	return(NO_RESPONSE);
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * make_file_pckt
 *
 * DESCRIPTION: sets up the initial filename pckt for Ymodem (only)
 *
 * ARGUMENTS:
 *	p		-- Pointer to the packet structure which receives the filename
 *				packet.
 *	fname	-- The file name as it should be placed in the packet.
 *	size	-- The size of the file as it should be placed in the packet.
 *
 * RETURNS:
 *	nothing
 */
STATIC_FUNC void make_file_pckt(ST_MDMX *xc,
								struct s_mdmx_pckt *p,
								char *fname,
								long size)
	{
	BYTE sizestr[20];
	BYTE *ptr;
	BYTE *cp;
	unsigned int crc;

	p->start_char = SOH;			   /* set start char to SOH   */
	p->pcktnum = 0; 				   /* set pcktnumber to 0	  */
	p->npcktnum = 0xff; 			   /* set npcktnumber to 0xff */
	ptr = p->bdata;

	/* initialize data area with zeros */
	memset(ptr, 0, SMALL_PACKET + 2);

	if (*fname)
		{
		StrCharCopy(ptr, fname);			 /* copy filename into buffer*/

		/* replace all back slashes with slashes */
		//while (strreplace(ptr, FstrBslashBslash(), "/"))
			// ;
		for (cp = ptr; *cp != '\0'; cp += 1)
			if (*cp == '\\') *cp = '/';

		// StrFmt(sizestr, "%ld", size);		  /* format the file size */
		wsprintf(sizestr, "%ld", (LONG)size);

		StrCharCopy(&ptr[StrCharGetByteCount(ptr)+1], sizestr);
		/* add it to buffer   */
		}

	/* calculate CRC value */
	ptr = &p->bdata[SMALL_PACKET];	/* set ptr to char after buffer */
									/* calculate CRC			*/
	crc = calc_crc(xc, (unsigned)0, p->bdata, SMALL_PACKET+2);
									/* set the CRC				*/
	*ptr++ = (BYTE)(crc / 0x100);
	*ptr = (BYTE)(crc % 0x100);
									/* set the packetsize		*/
	p->pcktsize = SMALL_PACKET + 5;
	p->byte_count = xc->mdmx_byte_cnt;
	}


/*********************** end of mdmx_snd.c **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xferdll.c ===
/*	File: D:\WACKER\xfer\xferdll.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#include <windows.h>

BOOL WINAPI XferEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	XferEntry
 *
 * DESCRIPTION:
 *	Currently, just initializes the C-Runtime library but may be used
 *	for other things later.
 *
 * ARGUMENTS:
 *	hInstDll	- Instance of this DLL
 *	fdwReason	- Why this entry point is called
 *	lpReserved	- reserved
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL WINAPI XferEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfer.hh ===
/*	File: D:\WACKER\xfer\xfer.hh (Created: 16-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 7/12/02 8:12a $
 */

#define FULL_HUNKS(n, s) ((n) / (s))
#define PART_HUNKS(n, s) ((long)(n) == 0L ? 0L : ((long)(n) - 1L) / (long)(s) + 1L)

/* XMODEM and YMODEM specific functions and data structures */

struct stXandYmodemParams
	{								/* nSize MUST BE THE FIRST ITEM */
	int			nSize;				/* the size of this data block */

#define	XP_ECP_AUTOMATIC	1
#define	XP_ECP_CRC			2
#define	XP_ECP_CHECKSUM		3
	int			nErrCheckType;		/* XMODEM - what type of error check */

	int			nPacketWait;		/* 1 to 60 seconds */

	int			nByteWait;			/* 1 to 60 seconds */

	int			nNumRetries;		/* 1 - 25 retries */
	};

typedef	struct stXandYmodemParams XFR_XY_PARAMS;

extern int xfrInitializeXandYmodem(const HSESSION hSession,
								VOID **ppData);

extern BOOL CALLBACK XandYmodemParamsDlg(HWND hDlg,
									UINT wMsg,
									WPARAM wPar,
									LPARAM lPar);

extern int xfrModifyXmodem(const HSESSION hSession,
							const HWND hwnd,
							VOID *pData);

extern int xfrModifyYmodem(const HSESSION hSession,
							const HWND hwnd,
							VOID *pData);

/* ZMODEM specific functions and data structures */

struct stZmodemParams
	{								/* nSize MUST BE THE FIRST ITEM */
	int			nSize;				/* the size of this data block */

	int			nAutostartOK;		/* TRUE if we allow autostarts */

	int			nFileExists;		/* defines follow */
#define	ZP_FE_SENDER	1			/* Follow sender A/O options */
#define	ZP_FE_DLG		2			/* Follow dialog box options */

	int			nCrashRecRecv;		/* defines follow */
#define ZP_CRR_NEG		1			/* Negotiate */
#define ZP_CRR_NEVER	2			/* Never recover */
#define	ZP_CRR_ALWAYS	3			/* Always recover */

	int			nOverwriteOpt;		/* defines follow */
#define ZP_OO_NONE		1			/* None */
#define	ZP_OO_N_L		2			/* Newer or longer */
#define	ZP_OO_CRC		3			/* CRC differs */
#define ZP_OO_APPEND	4			/* Append to file */
#define ZP_OO_ALWAYS	5			/* Overwrite always */
#define ZP_OO_NEWER		6			/* Newer */
#define	ZP_OO_L_D		7			/* Length or date differ */
#define ZP_OO_NEVER		8			/* Never overwrite */

	int			nCrashRecSend;		/* defines follow */
#define ZP_CRS_NEG		1			/* Negotiate */
#define	ZP_CRS_ONCE		2			/* One time */
#define	ZP_CRS_ALWAYS	3			/* Always */

	int			nXferMthd;			/* defines follow */
#define ZP_XM_STREAM	1			/* Streaming mode */
#define	ZP_XM_WINDOW	2			/* Windowed mode */

	int			nWinSize;			/* Window size 1K to 32K */
									/* TODO: check and document the format */

#if defined(UPPER_FEATURES)
	int			nBlkSize;			/* Block size 32 - 1024 bytes */
									/* TODO: check and document the format */
#endif // defined(UPPER_FEATURES)

	int			nCrcType;			/* defines follow */
#define	ZP_CRC_16		1
#define	ZP_CRC_32		2

	int			nRetryWait;			/* integer between 5 and 100 seconds */

	int			nEolConvert;		/* EOL conversion TRUE or FALSE */

	int			nEscCtrlCodes;		/* escape control codes, T or F */
	};

typedef	struct stZmodemParams XFR_Z_PARAMS;

extern int xfrInitializeZmodem(const HSESSION hSession,
								int nProtocol,
								VOID **ppData);

extern BOOL CALLBACK ZmodemParamsDlg(HWND hDlg,
									UINT wMsg,
									WPARAM wPar,
									LPARAM lPar);

extern int xfrModifyZmodem(const HSESSION hSession,
							const HWND hwnd,
							VOID *pData);

/* HyperProtocol specific functions and data structures */

struct stHyperProtocolParams
	{								/* nSize MUST BE THE FIRST ITEM */
	int			nSize;				/* the size of this data block */

#define	HP_CT_CHECKSUM		1
#define	HP_CT_CRC			2
	int			nCheckType;			/* the check type */

	int			nBlockSize;			/* 128 - 16384 bytes */

	int			nResyncTimeout;		/* 3-60 seconds */
	};

typedef	struct stHyperProtocolParams XFR_HP_PARAMS;

extern int xfrInitializeHyperProtocol(const HSESSION hSession,
								VOID **ppData);

extern BOOL CALLBACK HyperProtocolParamsDlg(HWND hDlg,
									UINT wMsg,
									WPARAM wPar,
									LPARAM lPar);

extern int xfrModifyHyperProtocol(const HSESSION hSession,
							const HWND hwnd,
							VOID *pData);

/* Kermit specific functions and data structures */

struct stKermitParams
	{								/* nSize MUST BE THE FIRST ITEM */
	int			nSize;				/* the size of this data block */

	int			nBytesPerPacket;	/* you can guess */
	int			nSecondsWaitPacket;
	int			nErrorCheckSize;
	int			nRetryCount;
	int			nPacketStartChar;
	int			nPacketEndChar;
	int			nNumberPadChars;
	int			nPadChar;
	};

typedef struct stKermitParams XFR_KR_PARAMS;

extern int xfrInitializeKermit(const HSESSION hSession,
								VOID **ppData);

extern BOOL CALLBACK KermitParamsDlg(HWND hDlg,
									UINT wMsg,
									WPARAM wPar,
									LPARAM lPar);

extern int xfrModifyKermit(const HSESSION hSession,
							const HWND hwnd,
							VOID *pData);

/* Generic functions */

extern int xfrInitializeParams(const HSESSION hSession,
								const int nProtocol,
								VOID **ppData);

extern int xfrModifyParams(const HSESSION hSession,
							const int nProtocol,
							const HWND hwnd,
							VOID *pData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfer_tsc.h ===
/* xfer_tsc.h -- a file containing the transfe status termination codes
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

/* Transfer Status Codes -- to indicate the final status of an individual
 *	  file transfer.
 * Note: There is a table called transfer_status_msg in transfer.c with an
 *		entry for each of these defines. If new constants are added here,
 *		the table should be expanded as well.
 */
#define 	TSC_OK			   0	// transfer completed normally
#define 	TSC_RMT_CANNED	   1	// remote system sent cancel request
#define 	TSC_USER_CANNED    2	// user hit abort key
#define 	TSC_LOST_CARRIER   3	// carrier lost during transfer
#define 	TSC_ERROR_LIMIT    4	// error limit exceeded
#define 	TSC_NO_RESPONSE    5	// remote system stopped responding
#define 	TSC_OUT_OF_SEQ	   6	// wrong number packet or resp. received
#define 	TSC_BAD_FORMAT	   7	// seemingly valid packet had bad format
#define 	TSC_TOO_MANY	   8	// user specified filename as dest, but
									//	  sender sent more than one file
#define 	TSC_DISK_FULL	   9	// no more room to put file
#define 	TSC_CANT_OPEN	  10	// couldn't find or open file
#define 	TSC_DISK_ERROR	  11	// hard err. or read/write error occurred
#define 	TSC_NO_MEM		  12	// not enough memory to complete transfer
#define 	TSC_FILE_EXISTS   13	// can't receive 'cause no permission to
									//		overwrite
#define 	TSC_COMPLETE	  14	// transfer session is complete
#define 	TSC_CANT_START	  15	// couldn't complete transfer setup, prob.
									//		bad option, disk error, etc.
#define 	TSC_OLDER_FILE	  16	// /N option but rcv'd file older
#define 	TSC_NO_FILETIME   17	// /N option but sender sent no file time
#define 	TSC_WONT_CANCEL   18	// sender failed to cancel transfer when
									//		requested to
#define 	TSC_GEN_FAILURE   19	// generic transfer failure message
#define 	TSC_NO_VSCAN	  20	// Virus scanning can't be loaded
#define 	TSC_VIRUS_DETECT  21	// Virus detected
#define		TSC_USER_SKIP	  22	// User skipped the file
#define 	TSC_REFUSE		  23	// User refused
#define     TSC_FILEINUSE     24    // File is opened and can't be renamed
#define 	TSC_MAX 		  25	// number of TSC codes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfr_srvc.h ===
/* xfr_srvc.h -- include file for transfer service routines
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 4/10/02 1:58p $
 */

extern void xfer_set_pointer(HSESSION hSession, void *pV);

extern void *xfer_get_pointer(HSESSION hSession);

/* These are flags that can be passed to xfer_idle to indicate why it */
/* has been called and what should be done, if anything. */
#define	XFER_IDLE_IO				0x00000001 
#define	XFER_IDLE_DISPLAY			0x00000002
extern void xfer_idle(HSESSION h, int nMode);

#if !defined(XFER_ABORT)
#define	XFER_ABORT		1
#endif
#if !defined(XFER_SKIP)
#define	XFER_SKIP		2
#endif
extern int	xfer_user_interrupt(HSESSION hSession);

extern int  xfer_user_abort(HSESSION hSession, int p);

extern int  xfer_carrier_lost(HSESSION hSession);

extern void xfer_purgefile(HSESSION hSession, TCHAR *fname);

extern int xfer_open_rcv_file(HSESSION hSession,
							 struct st_rcv_open *pstRcv,
							 unsigned long ulOverRide);

extern void xfer_build_rcv_name(HSESSION hSession,
							  struct st_rcv_open *pstRcv);

extern int xfer_close_rcv_file(HSESSION Hsession,
							  void *vhdl,
							  int nReason,
							  TCHAR *pszRemoteName,
							  TCHAR *pszOurName,
							  int nSave,
							  unsigned long lFilesize,
							  unsigned long lTime);

extern VOID FAR * xfer_get_params(HSESSION hSession, int nProtocol);

extern int xfer_set_comport(HSESSION hSession, int fSending, unsigned FAR *puiOldOptions);

extern int xfer_restore_comport(HSESSION hSession, unsigned uiOldOptions);

extern int	xfer_save_partial(HSESSION hSession);

extern int	xfer_nextfile(HSESSION hSession, TCHAR *filename);

extern void xfer_log_xfer(HSESSION hSession,
						  int sending,
						  TCHAR *theirname,
						  TCHAR *ourname,
						  int result);

extern int xfer_opensendfile(HSESSION hSession,
							 HANDLE *fp,
							 TCHAR *file_to_open,
							 long *size,
							 TCHAR *name_to_send,
							 void *ft);
							 // struct s_filetime FAR *ft);

extern void xfer_name_to_send(HSESSION hSession,
							  TCHAR *local_name,
							  TCHAR *name_to_send);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfr_dsp.h ===
/* xfr_dsp.h -- a file of transfer display routines
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

/* Transfer display functions */
extern void xferMsgProgress(HSESSION hSession,
							long stime,
							long ttime,
							long cps,
							long file_so_far,
							long total_so_far);

extern void xferMsgNewfile(HSESSION hSession,
						   int filen,
						   BYTE *theirname,
						   TCHAR *ourname);

extern void xferMsgFilesize(HSESSION hSession, long fsize);

extern void xferMsgStatus(HSESSION hSession, int status);

extern void xferMsgEvent(HSESSION hSession, int event);

extern void xferMsgErrorcnt(HSESSION hSession, int cnt);

extern void xferMsgFilecnt(HSESSION hSession, int cnt);

extern void xferMsgTotalsize(HSESSION hSession, long bytes);

extern void xferMsgClose(HSESSION hSession);

extern void xferMsgVirusScan(HSESSION hSession, int cnt);

extern void xferMsgChecktype(HSESSION hSession, int event);

extern void xferMsgPacketnumber(HSESSION hSession, long number);

extern void xferMsgLasterror(HSESSION hSession, int event);

extern void xferMsgPacketErrcnt(HSESSION hSession, int event);

extern void xferMsgProtocol(HSESSION hSession, int nProtocol);

extern void xferMsgMessage(HSESSION hSession, BYTE *pszMsg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfr_dsp.c ===
/* xfr_dsp.c  -- Transfer display functions
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 7/11/02 11:13a $
 */

#include <windows.h>
#pragma hdrstop

#define BYTE	char

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\xfdspdlg.h>
#include <tdll\xfer_msc.hh>
#include <tdll\htchar.h>
#include <tdll\assert.h>
#include "xfr_dsp.h"
#include "xfr_srvc.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgProgress
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession     -- the session handle
 *	stime        -- elapsed time (maybe)
 *	ttime        -- remaining time (maybe)
 *	cps          -- speed of transfer
 *	file_so_far  -- what it says
 *	total_so_far -- what it says
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgProgress(HSESSION hSession,
							long stime,
							long ttime,
							long cps,
							long file_so_far,
							long total_so_far)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		if (stime != -1)
			{
			pX->lElapsedTime = stime;
			pX->bElapsedTime = 1;
			}

		if (ttime != -1)
			{
			pX->lRemainingTime = ttime;
			pX->bRemainingTime = 1;
			}

		if (cps != -1)
			{
			pX->lThroughput = cps;
			pX->bThroughput = 1;
			}

		if (file_so_far != -1)
			{
			pX->lFileSoFar = file_so_far;
			pX->bFileSoFar = 1;
			}

		if (total_so_far != -1)
			{
			pX->lTotalSoFar = total_so_far;
			pX->bTotalSoFar = 1;
			}
		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgNewfile
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	filen     -- the file number
 *	theirname -- an ASCII copy of their name (TODO: convert to UNICODE)
 *	ourname   -- a copy of the filename as we used it
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgNewfile(HSESSION hSession,
						   int filen,
						   BYTE *theirname,
						   TCHAR *ourname)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);

	assert(pX);

	if (pX)
		{
		pX->wFileCnt = (WORD)filen;
		pX->bFileCnt = 1;

		if (theirname != NULL)
			{
			StrCharCopyN(pX->acTheirName, theirname, XFER_NAME_LENGTH);
			pX->bTheirName = 1;
			}

		//assert(pX->bTheirName == 1);

		if (ourname != NULL)
			{
			StrCharCopyN(pX->acOurName, ourname, XFER_NAME_LENGTH);
			pX->bOurName = 1;
			}

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgFilesize
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	fsize    -- the size of the current file
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgFilesize(HSESSION hSession, long fsize)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->lFileSize = (LONG)fsize;
		pX->bFileSize = 1;

		pX->lFileSoFar = 0;
		pX->bFileSoFar = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgStatus
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	status   -- a protocol specific status code
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgStatus(HSESSION hSession, int status)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wStatus = (WORD)status;
		pX->bStatus = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgEvent
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	event    -- a protocol specific event code
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgEvent(HSESSION hSession, int event)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wEvent = (WORD)event;
		pX->bEvent = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgErrorcnt
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	cnt      -- the new number of errors to display
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgErrorcnt(HSESSION hSession, int cnt)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wErrorCnt = (WORD)cnt;
		pX->bErrorCnt = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgFilecnt
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	cnt      -- the total number of files in the transfer
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgFilecnt(HSESSION hSession, int cnt)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wTotalCnt = (WORD)cnt;
		pX->bTotalCnt = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgTotalsize
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	bytes    -- the total size of all the files in the transfer operation
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgTotalsize(HSESSION hSession, long bytes)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->lTotalSize = (LONG)bytes;
		pX->bTotalSize = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgClose
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.  This function is actually called to indicate
 *	that a transfer is finished.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgClose(HSESSION hSession)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->nClose = TRUE;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgChecktype
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	ctype    -- indicates the current checksum type
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgChecktype(HSESSION hSession, int ctype)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wChecktype = (WORD)ctype;
		pX->bChecktype = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgPacketnumber
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	number   -- the current packet number
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgPacketnumber(HSESSION hSession, long number)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->lPacketNumber = number;
		pX->bPacketNumber = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrMsgLasterror
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	event    -- indicates the last error type for a specific protocol
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgLasterror(HSESSION hSession, int event)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wLastErrtype = (WORD)event;
		pX->bLastErrtype = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgPacketErrcnt
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	ecount   -- indicates the number of errors in the current packet
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgPacketErrcnt(HSESSION hSession, int ecount)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->wPcktErrCnt = (WORD)ecount;
		pX->bPcktErrCnt = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgProtocol
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	nProtocol -- which CSB protocol is being used
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgProtocol(HSESSION hSession, int nProtocol)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		switch (nProtocol)
			{
			default:
				pX->uProtocol = 0;
				break;
			case 0:
				pX->uProtocol = 1;
				break;
			case 1:
				pX->uProtocol = 2;
				break;
			}
		pX->bProtocol = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xferMsgMessage
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pszMsg   -- pointer to the CSP ASCII message string (TODO: convert)
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsgMessage(HSESSION hSession, BYTE *pszMsg)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		// _fmemset(pW->acMessage, 0, sizeof(pW->acMessage));
		// _fstrncpy(pW->acMessage, pszMsg, sizeof(pW->acMessage) - 1);
		StrCharCopyN(pX->acMessage, pszMsg, XFER_MESSAGE_LENGTH);
		pX->bMessage = 1;

		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}

#if FALSE

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to update various parts
 *	of the transfer display.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	Nothing.
 */
void xferMsg(HSESSION hSession)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		if (IsWindow(pX->hwndXfrDisplay))
			{
			PostMessage(pX->hwndXfrDisplay,
						WM_DLG_TO_DISPLAY,
						XFR_UPDATE_DLG, 0);
			}
		xfer_idle(hSession, XFER_IDLE_DISPLAY);
		}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfr_srvc.c ===
/* xfr_srcv.c -- transfer service routines
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 13 $
 *	$Date: 5/21/02 9:58a $
 */

#include <windows.h>
#pragma hdrstop

#define BYTE	char

#include <tdll\stdtyp.h>
#include <tdll\comdev.h>
#include <tdll\com.h>
#include <tdll\com.hh>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\file_msc.h>
#include <tdll\xfer_msc.hh>
#include <tdll\file_io.h>
#include <tdll\tdll.h>
#include <tdll\htchar.h>
#include <tdll\misc.h>
#include <tdll\globals.h>
#include <tdll\errorbox.h>
#include <term\res.h>

#include "itime.h"

#include "xfer.h"
#include "xfer.hh"

#include "xfer_tsc.h"
#include "xfr_srvc.h"


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*
 *                                                                            *
 *                             R E A D    M E                                 *
 *                                                                            *
 * Everybody keeps changing the TIME standard to whatever they feel might be  *
 * a little bit better for them.  So far I have found 3 different standards   *
 * in Microsoft functions.  This does not even count the fact that HyperP     *
 * uses its own format for time.                                              *
 *                                                                            *
 * Henceforth, all time values that are passed around in the program will be  *
 * based on the old UCT format of the number of seconds since Jan 1, 1970.    *
 *                                                                            *
 * Please use an unsigned long for these values.                              *
 *                                                                            *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_set_pointer
 *
 * DESCRIPTION:
 *	When a transfer is started, it is passed a parameter block.  This is
 *	where the address of that block gets stored.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pV       -- pointer to the parameter block
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfer_set_pointer(HSESSION hSession, void *pV)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pX->pXferStuff = pV;
		}
	}

void *xfer_get_pointer(HSESSION hSession)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		return (void *)pX->pXferStuff;
		}
	return (void *)0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_idle
 *
 * DESCRIPTION:
 *	This function got called in Windows to make sure that the transfer
 *	display (and other tasks) got some time every now and then during a
 *	transfer.  I don't know if this needs to be done under CHICAGO, with
 *	a pre-emptive multi-tasking design.  The call is still here until it
 *	can be determined one way or another.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	Nothing.
 *
 */

#define	IDLE_WAIT		150

void xfer_idle(HSESSION h, int nMode)
	{
	/*
	 * This is set up for the mode flags to be OR'ed together if necessary
	 */
	if (nMode & XFER_IDLE_IO)
		{
		HCOM   hComHandle = sessQueryComHdl(h);

		if (hComHandle && ComValidHandle(hComHandle) &&
			(hComHandle->pfPortConnected)(hComHandle->pvDriverData) == COM_PORT_OPEN);
			{
			HANDLE hComEvent = ComGetRcvEvent(hComHandle);

			if (hComEvent)
				{
				WaitForSingleObject(hComEvent, IDLE_WAIT);
				}
			}
		}

	if (nMode & XFER_IDLE_DISPLAY)
		{
		/*
		 * The documentation says that this caused the thread to yield,
		 * presumably back to the scheduler cycle.  It tries to let the
		 * display update if possible.
		 */
		Sleep(0);
		}

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_user_interrupt
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to determine if the user
 *	has hit any of the cancel or skip buttons in the display window.
 *
 * PARAMETERS:
 *	hSession -- the session handle.
 *
 * RETURNS:
 *	ZERO if nothing to report, otherwise a CANCEL or SKIP indicator.
 *
 */
int	xfer_user_interrupt(HSESSION hSession)
	{
	INT nRetVal;
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX == NULL)
		{
		// DbgOutStr("xfer_user_interrupt returns an error\r\n", 0,0,0,0,0);
		return FALSE;
		}

	switch (pX->nUserCancel)
		{
		case XFER_ABORT:
			nRetVal = XFER_ABORT;
			pX->nUserCancel = 0;		// Reset to default value
			// DbgOutStr("xfer_user_interrupt returns 1\r\n", 0,0,0,0,0);
			break;

		case XFER_SKIP:
			nRetVal = XFER_SKIP;
			pX->nUserCancel = 0;		// Reset to default value
			// DbgOutStr("xfer_user_interrupt returns 2\r\n", 0,0,0,0,0);
			break;

		default:
			// DbgOutStr("xfer_user_interrupt returns 0\r\n", 0,0,0,0,0);
			nRetVal = 0;
			break;
		}
	return nRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_user_abort
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
int  xfer_user_abort(HSESSION hSession, int p)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX == NULL)
		{
		// TODO: decide if we need CLoopClearOutput
		// CLoopClearOutput(sessQueryCLoopHdl(hSession));
		return TRUE;
		}

	switch (p)
		{
		case 0:
		case XFER_ABORT:
		case XFER_SKIP:
			pX->nUserCancel = p;
			break;
		default:
			pX->nUserCancel = 0;
			break;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_carrier_lost
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to determine if the
 *	session is still connected to something.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	TRUE if carrier has been lost, otherwise FALSE;
 *
 */
int xfer_carrier_lost(HSESSION hSession)
	{
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX == NULL)
		{
		// DbgOutStr("xfer_user_interrupt returns an error\r\n", 0,0,0,0,0);
		return FALSE;
		}

	return pX->nCarrierLost;	// Set by the COM the driver (ComActivatePort()
	                            // and ComDeactivatePort()) and the transfer
	                            // display (WM_INITDIALOG and XFER_LOST_CARRIER
	                            // messages to XfrDisplayDlg()). REV: 9/7/2001
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_purgefile
 *
 * DESCRIPTION:
 *	This function is called after a VIRUS has been detected.  It is supposed
 *	to make sure that whatever was written out to disk from the infected file
 *	gets seriously blasted.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	fname    -- the name of the file
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfer_purgefile(HSESSION hSession, TCHAR *fname)
	{

	/*
	 * Given the way buffering and deletion recovery can be done in modern
	 * systems, I am not real sure what should be done here.
	 */
	DeleteFile(fname);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrUniqueName
 *
 * DESCRIPTION:
 *	This function is called to build a NEW (currently unused) file name from
 *	an existing file name by using a sequential numbering operation.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pszSrc   -- the origional file name
 *	pszDst   -- where to put the new file name
 *
 * RETURNS:
 *	0 if everything is OK, otherwise a negative number.
 *
 */
static int xfrUniqueName(HSESSION hSession, LPTSTR pszSrc, LPTSTR pszDst)
	{
	int nRetVal = -1;
	TCHAR szSrc[MAX_PATH];
	TCHAR szName[MAX_PATH];
	TCHAR szTag[10];			// big enough to hold "0" to "9999"
	TCHAR *pszFName = NULL;
	TCHAR *pszExtension = NULL;
	TCHAR *pszScan = NULL;
	long  nComponentSize = 0L;
	int   nNameSpace;
	int   nTag = 0;
	int nSize = 0;

	// Let Operating system figure out full name. This will also set pszFName
	//	to point to the file name component of the path.
	nSize = GetFullPathName(pszSrc, MAX_PATH, szSrc, &pszFName);
	if (nSize)
		{
		if (pszFName)
			{
			// Copy name portion off for later manipulation and remove ext.
			StrCharCopy(szName, pszFName);
			mscStripExt(szName);

			// Isolate the dir portion of the path
			pszScan = StrCharPrev(szSrc, pszFName);
			if (pszScan)
				*pszScan = TEXT('\0');

			// Keep pointer to extension, if any, in original string
			pszExtension = StrCharFindLast(pszFName, TEXT('.'));
			}

		// Find maximum length of path component (this is platform dependent)

		// TODO:jkh, 12/19/94  Different drives may use different sizes
		if (!GetVolumeInformation(NULL, NULL, 0, NULL, &nComponentSize,
				NULL, NULL, 0))
			nComponentSize = 12;	// Safest size if call fails

		// Try attaching numeric tags to the name until name is unique
		nNameSpace = nComponentSize - StrCharGetByteCount(pszExtension);
		for (nTag = 0; nTag < 10000; ++nTag)
			{
			_itoa(nTag, szTag, 10);
			// make sure tag will fit on filename
			while (StrCharGetByteCount(szName) >
					nNameSpace - StrCharGetByteCount(szTag))
				{
				pszScan = StrCharLast(szName);
				*pszScan = TEXT('\0');
				}
			StrCharCopy(pszDst, szSrc); 	// start with dir portion
			StrCharCat(pszDst, TEXT("\\")); // separator
			StrCharCat(pszDst, szName); 	// original file name (truncated)
			StrCharCat(pszDst, szTag);		// numeric tag to make unique
			StrCharCat(pszDst, pszExtension); // Extension (if any)

			if (!mscIsDirectory(pszDst) && !GetFileSizeFromName(pszDst, 0))
				{
				nRetVal = 0;
				break;	/* Exit with good name */
				}
			}
		}

	return nRetVal;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrUniqueDateName
 *
 * DESCRIPTION:
 *	This function is called to build a NEW (currently unused) file name from
 *	an existing file name by using the current data/time.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pszSrc   -- the origional file name
 *	pszDst   -- where to put the new file name
 *
 * RETURNS:
 *	0 if everything is OK, otherwise a negative number.
 *
 */
static int xfrUniqueDateName(HSESSION hSession, LPTSTR pszSrc, LPTSTR pszDst)
	{
	int nRet = 0;
	int nTag;
	LPTSTR pszDir;
	LPTSTR pszExt;
	SYSTEMTIME stT;
	TCHAR acDatestr[8];
	TCHAR acFrm[16];
	TCHAR acSrc[FNAME_LEN];
	TCHAR acDst[FNAME_LEN];

	/* Get a pointer to the path portion only */
	StrCharCopy(acSrc, pszSrc);
	pszDir = acSrc;
	pszExt = StrCharFindLast(acSrc, TEXT('\\'));

	/* Get a pointer to the file name section */
	nTag = 0;
	while ((*pszExt != TEXT('.')) && (nTag < 8))
		acFrm[nTag++] = *pszExt++;
	acFrm[nTag] = TEXT('\0');
	if (StrCharGetByteCount(acFrm) == 0)
		StrCharCopy(acFrm, TEXT("D"));

	/* Get a pointer to the extension */
	pszExt = StrCharFindLast(pszDst, TEXT('.'));
	if (pszExt == NULL)
		pszExt = ".FIL";

	GetLocalTime(&stT);
	wsprintf(acDatestr, "%x%02d%02d%1d",
						stT.wMonth,
						stT.wDay,
						stT.wHour,
						stT.wMinute % 10);
	acFrm[8 - StrCharGetByteCount(acDatestr)] = TEXT('\0');

	wsprintf(acDst, "%s%s%s%s",
					pszDir,
					acFrm,
					acDatestr,
					pszExt);

	return xfrUniqueName(hSession, acDst, pszDst);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_modify_rcv_name
 *
 * DESCRIPTION:
 *	This function is called to modify the name as necessary based on the users
 *	parameters.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pszName  -- the file name
 *	lTime    -- our internal time format, see READ ME above
 *	lFlags   -- flags
 *	pfFlags  -- pointer to returned flags
 *
 * RETURNS:
 *	    0 -- everything was OK
 *	   -1 -- file error
 *	   -2 -- reject due to date
 *	   -4 -- no date, time provided
 *	   -6 -- unconditinally refuse file
 *	   -7 -- general failure
 *
 */
int xfer_modify_rcv_name(HSESSION hSession,
						LPTSTR pszName,
						unsigned long ulTime,
						long lFlags,
						int *pfFlags)
	{
	int nRetVal = 0;
	int nOpenFlags = 0;
	int isFile = 0;
	unsigned long locTime;
    TCHAR   szNewName[FNAME_LEN];
    DWORD   dwRetVal;

	isFile = GetFileSizeFromName(pszName, NULL);

	if (isFile == FALSE)
		{
		nOpenFlags = 0;
		}
	else
		{
		switch (lFlags)
			{
		case XFR_RO_APPEND:
			nOpenFlags = TRUE;
			break;

		case XFR_RO_ALWAYS:
			nOpenFlags = 0;
			break;

		case XFR_RO_NEWER:
			if (ulTime != 0)					// Let's check the time.
				{
				locTime = itimeGetFileTime(pszName);
				if (locTime != 0)
				   	if (locTime <= ulTime)	// File is newer, accept it.
						nOpenFlags = 0;
				   	else
				   		nRetVal = -2;		// Reject it due to date.
				else
					nRetVal = -1;	 		// File error...
				}
			else
				nRetVal = -4;				// No date, time supplied.
			break;

		case XFR_RO_REN_DATE:
			//
			// Build a new name, based upon the date of the new file.
			//
			nRetVal = xfrUniqueDateName(hSession, pszName, pszName);
			if (nRetVal < 0)
				nRetVal = -7;				// Ambiguous file name.
			nOpenFlags = 0;
			break;

		default:
		case XFR_RO_REN_SEQ:
			//
			// Build a new name, based upon a sequence number algorithm.
			//
			nRetVal = xfrUniqueName(hSession, pszName, szNewName);
			if (nRetVal < 0)
				nRetVal = -7;				// Ambiguous file name.
            else
                {
                dwRetVal = GetFileAttributes(pszName);
                if (dwRetVal != 0xFFFFFFFF &&
                    (dwRetVal & FILE_ATTRIBUTE_DIRECTORY) != 0)
                    {
                    nRetVal = -8;   // File is a directory
                    }
                else if (MoveFile(pszName, szNewName) == FALSE)
                    {
                    nRetVal = -8;   // File is opened
                    }
                }
			nOpenFlags = 0;
			break;

		case XFR_RO_NEVER:
			nRetVal = -6;
			break;
			}
		}

	if (nRetVal >= 0)
		*pfFlags = nOpenFlags;

	return nRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_makepaths
 *
 * DESCRIPTION:
 *	This function is called to make sure that a pathname exists.  It creates
 *	whatever portion of the pathname needs to be created.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pszPath  -- the path
 *
 * RETURNS:
 *	    0 -- everything was OK
 *	   -1 -- bad path format
 *	   -2 -- disk error of some sort
 *
 */
int xfer_makepaths(HSESSION hSession, LPTSTR pszPath)
	{
	TCHAR ach[256];
	TCHAR achFormat[256];
	TCHAR ach2[50];

	if (pszPath == 0)
		return -1;

	if (!mscIsDirectory(pszPath))
		{
		if (LoadString(glblQueryDllHinst(), IDS_GNRL_CREATE_PATH, achFormat,
				sizeof(achFormat) / sizeof(TCHAR)) == 0)
			{
			DbgShowLastError();
			return -3;
			}

		if (LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, ach2,
				sizeof(ach2) / sizeof(TCHAR)) == 0)
			{
			DbgShowLastError();
			return -4;
			}

		wsprintf(ach, achFormat, pszPath);

		if (TimedMessageBox(sessQueryHwnd(hSession), ach, ach2,
				            MB_YESNO | MB_TASKMODAL | MB_ICONEXCLAMATION,
					        sessQueryTimeout(hSession)) == IDYES)
			{
			if (mscCreatePath(pszPath) != 0)
				{
				assert(0);
				return -2;
				}
			}

		else
			{
			return -5;
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_create_rcv_file
 *
 * DESCRIPTION:
 *	This function is called to open the file for receiving.  It has the code
 *	to create the path to the file for those protocols that can transfer a
 *	path as well as a file name.
 *
 * PARAMETERS:
 *	hSession   -- the session handle
 *	pszName    -- the complete path name of the file
 *	lOpenFlags -- the flags to pass to fio_open
 *	              nowdays TRUE means APPEND, FALSE means overwrite
 *	phRet      -- where to return the file handle
 *
 * RETURNS:
 *	    0 -- everything was OK
 *	   -1 -- couldn't create the file
 *
 */
int xfer_create_rcv_file(HSESSION hSession,
						LPTSTR pszName,
						long lOpenFlags,
						HANDLE *phRet)
	{
	ST_IOBUF *hFile;
	LPTSTR pszStr;
	TCHAR acDir[FNAME_LEN];

	StrCharCopy(acDir, pszName);
	pszStr = StrCharLast(acDir);
	while ((*pszStr != TEXT('\\')) && (pszStr > acDir))
		pszStr = StrCharPrev(acDir, pszStr);

	if (pszStr == acDir)
		return -1;

	*pszStr = TEXT('\0');
	if (xfer_makepaths(hSession, acDir) < 0)
		return -1;

	if (lOpenFlags)
		{
		/* Open for appending */
		hFile = fio_open(pszName, FIO_APPEND | FIO_WRITE);
		}
	else
		{
		hFile = fio_open(pszName, FIO_CREATE | FIO_WRITE);
		}
	if (hFile == NULL)
		return -1;

	*phRet = hFile;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_open_rcv_file
 *
 * DESCRIPTION:
 *	This function is called to actually do the open of the receive file.  It
 *	calls a bunch of other stuff, fiddles with names, and eventually returns.
 *
 * PARAMETERS:
 *	hSesssion  -- the session handle
 *	pstRcv     -- pointer to the receive open structure
 *	ulOverRide -- if set, flags to use instead of contents of pstRcv
 *
 * RETURNS:
 *	 0 if A-OK
 *	-1 if error occurred
 *	-2 if rejected due to date
 *	-3 if rejected because it can't save file
 *	-4 if no date/time supplied when required
 *	-5 if unable to create needed directories
 *	-6 if file rejected unconditionally
 *	-7 if general failure
 *
 */
int xfer_open_rcv_file(HSESSION hSession,
					 struct st_rcv_open *pstRcv,
					 unsigned long ulOverRide)
	{
	unsigned long ulFlags = 0;
	int nOpenFlags;
	int nRetVal = 0;
#if FALSE
	// Lower Wacker does not support message logging
	int msgIndex = -1;
#endif
	XD_TYPE *pX;
	XFR_PARAMS *pP;

	pstRcv->bfHdl = NULL;
	pstRcv->lInitialSize = 0;

	xfer_build_rcv_name(hSession, pstRcv);

	/* Get the overwrite parameters */
	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
	    pP = (XFR_PARAMS *)pX->xfer_params;
	    if (pP)
		    {
		    ulFlags = pP->nRecOverwrite;
		    }
		}
	if (ulOverRide != 0)
		ulFlags = ulOverRide;

	nRetVal = xfer_modify_rcv_name(hSession,
									pstRcv->pszActualName,
									pstRcv->lFileTime,
									ulFlags,
									&nOpenFlags);

	if (nRetVal >= 0)
		{
		HANDLE lRet;
		unsigned long size;

		size = 0;
		// if (nOpenFlags & O_APPEND)
		if (nOpenFlags)
			{
			if (!GetFileSizeFromName(pstRcv->pszActualName, &size))
				{
				size = 0;
				}
			}

		nRetVal = xfer_create_rcv_file(hSession,
										pstRcv->pszActualName,
										nOpenFlags,
										&lRet);
		if (nRetVal >= 0)
			{
			pstRcv->bfHdl = lRet;

			// if (nOpenFlags & O_APPEND)
			if (nOpenFlags)
				{
				pstRcv->lInitialSize = size;
				}
			}
		}

#if FALSE
	// Lower Wacker does not support logging
	if (nRetVal < 0)
		{
		switch (nRetVal)
			{
		case -6:            // File was rejected unconditionally
			msgIndex = 23;	// "User refused"
			break;
		case -5:			// Were unable to create needed directories
			msgIndex = 11;	// "Fatal disk error"
			break;
		case -4:  			// No date, time supplied when required
			msgIndex = 17;	// "No file time available"
			break;
		case -3:			// File could not be saved
			msgIndex = 9;	// "Cannot writ file to disk"
			break;
		case -2:  			// File was rejected due to date
			msgIndex = 16;	// "File is too old"
			break;
		case -1:			// Some error occured
			msgIndex = 10;  // "Cannot open file"
			break;
		default:			// Failed
			msgIndex = 19;  // "General failure"
			break;
			}
		xfer_log_xfer(	hSession,
			   			FALSE,
			   			pstRcv->pszSuggestedName,
			   			pstRcv->pszActualName,
			   			msgIndex	);
		}
#endif

	return nRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_build_rcv_name
 *
 * DESCRIPTION:
 *	This function is called to help build the name of the file that the
 *	transfer receive code is going to dump the data into.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	pstRcv   -- pointer to the receive open structure (contains the name)
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfer_build_rcv_name(HSESSION hSession,
						  struct st_rcv_open *pstRcv)
	{
	int nSingle;
	XD_TYPE *pX;
	XFR_PARAMS *pP;
	XFR_RECEIVE *pR;
#if defined(INC_VSCAN)
	SSHDLMCH 	ssVscanMch;
#endif
	LPTSTR pszStr;
	TCHAR acBuffer[FNAME_LEN];

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pP = (XFR_PARAMS *)pX->xfer_params;
		if (pP)
			{
			/* Just continue on to the rest of the function */
			}
		else
			{
			assert(FALSE);
			return;
			}
		pR = pX->pXferStuff;
		if (pR)
			{
			/* Just continue on to the rest of the function */
			}
		else
			{
			assert(FALSE);
			return;
			}
		}
	else
		{
		assert(FALSE);
		return;
		}

	nSingle = !pP->fUseFilenames;
	nSingle |= (pP->nRecProtocol == XF_XMODEM);
	nSingle |= (pP->nRecProtocol == XF_XMODEM_1K);

	if (nSingle)
		{
		/* User specified a single file */
		StrCharCopy(acBuffer, pR->pszDir);
		pszStr = (LPTSTR)StrCharLast(acBuffer);
		if (*pszStr != TEXT('\\'))
			{
			pszStr += 1;
			*pszStr = TEXT('\\');
			pszStr += 1;
			*pszStr = TEXT('\0');
			}
		StrCharCat(acBuffer, pR->pszName);

		fileFinalizeName(
						acBuffer,					/* values to use */
						pstRcv->pszSuggestedName,	/* filler */
						pstRcv->pszActualName,		
						MAX_PATH);
		}
	else if (!pP->fUseDirectory)
		{
		/* Use directory flag is not set */
		//
		// Ignore all paths sent to us in this case.
		//
		pszStr = StrCharLast(pstRcv->pszSuggestedName);

		/* TODO: fix this up for wide characters */
		while (pszStr >= pstRcv->pszSuggestedName)
			{
			if ((*pszStr == TEXT('\\')) || (*pszStr == TEXT(':')))
				{
				StrCharCopy(pstRcv->pszSuggestedName, ++pszStr);
				break;
				}
			else
				{
				if (pszStr == pstRcv->pszSuggestedName)
					break;
				pszStr = (LPTSTR)StrCharPrev(pstRcv->pszSuggestedName, pszStr);
				}
			}

		fileFinalizeName(
					 pstRcv->pszSuggestedName,		/* values to use */
					 pR->pszDir,					/* filler */
					 pstRcv->pszActualName,
					 MAX_PATH);
		}
	else
		{
		/* I am not a all sure about this stuff */
		if ((pstRcv->pszSuggestedName[0] == TEXT('\\')) ||
			(pstRcv->pszSuggestedName[1] == TEXT(':')))
			{
			/* if full path given */
			StrCharCopy(pstRcv->pszActualName, pstRcv->pszSuggestedName);
			}
		else
			{
			/* else use our path 1st */
			StrCharCopy(pstRcv->pszActualName, pR->pszDir);
			if ((pR->pszName != NULL) &&
				(StrCharGetByteCount(pR->pszName) > 0))
				StrCharCat(pstRcv->pszActualName, pR->pszName);
			else
				StrCharCat(pstRcv->pszActualName, pstRcv->pszSuggestedName);

			fileFinalizeName(
						 pstRcv->pszActualName,		/* values to use */
						 pstRcv->pszSuggestedName,	/* filler */
						 pstRcv->pszActualName,
						 MAX_PATH);
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_close_rcv_file
 *
 * DESCRIPTION:
 *	This function is called at the end of a transfer.  It does various things
 *	such as setting the file time/date, the size, saving partial files, and
 *	logging the transfer.  A cleanup routine.
 *
 * PARAMETERS:
 *	hSession      -- the session handle
 *	fhdl          -- the actual file handle
 *	nReason       -- transfer status code
 *	pszRemoteName -- the file name as it was sent to us
 *	pszOurName    -- the file name we actually used to save the data
 *	nSave         -- partial save flag
 *	lFilesize     -- size to set the file to
 *	lTime         -- date/time value to use to set the file
 *
 * RETURNS:
 *	TRUE if the transfer was successful, otherwise FALSE.
 *
 */
int xfer_close_rcv_file(HSESSION Hsession,
					  void *vhdl,
					  int nReason,
					  TCHAR *pszRemoteName,
					  TCHAR *pszOurName,
					  int nSave,
					  unsigned long lFilesize,
					  unsigned long lTime)		/* Fix this later */
	{
	ST_IOBUF *fhdl = (ST_IOBUF *)vhdl;

	if (nReason == TSC_COMPLETE)
		nReason = TSC_OK;

	if (fio_close(fhdl) == 0)
		{
		/* Set the size */
		if (lFilesize > 0 && nReason == TSC_OK) /*lFilesize != 0 jmh 03-08-96 */
            SetFileSize(pszOurName, lFilesize);

		/* Set the date/time */
		if (lTime != 0)
			itimeSetFileTime(pszOurName, lTime);
		}
	else
		{
		nReason = TSC_DISK_ERROR;
		}

#if FALSE
	// Lower Wacker does not log transfers */
	xfer_log_xfer(hSession, FALSE, pszRemoteName, pszOurName, nReason);
#endif

	if (nReason == TSC_OLDER_FILE)
		nReason = TSC_OK;

	if (nReason != TSC_OK && pszOurName && *pszOurName)
		{
		if (nSave == FALSE)
			DeleteFile(pszOurName);
		}

	if (nReason == TSC_LOST_CARRIER)
        {
		nReason = TSC_OK;
        }

	return (nReason == TSC_OK);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_get_params
 *
 * DESCRIPTION:
 *	This function gets the protocol specific parameters for the transfer
 *	routines.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	nProtocol -- the protocol ID
 *
 * RETURNS:
 *	A pointer to the protocol block, or a NULL.
 *
 */
VOID FAR * xfer_get_params(HSESSION hSession, int nProtocol)
	{
	void *pVret = (void *)0;
	XD_TYPE *pX;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		int nLimit = SFID_PROTO_PARAMS_END - SFID_PROTO_PARAMS;
		if (nProtocol < nLimit)
			{
			if (pX->xfer_proto_params[nProtocol] == NULL)
				{
				int nRet = xfrInitializeParams(hSession,
					                           nProtocol,
											   &pX->xfer_proto_params[nProtocol]);
				assert(nRet == 0);
				}
			pVret = (VOID FAR *)pX->xfer_proto_params[nProtocol];
			}
		}
	return pVret;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_set_comport
 *
 * DESCRIPTION:
 *	This function is called to save the current com port settings so that the
 *	transfer code can go ahead and change them to whatever it likes.
 *
 * PARAMETERS:
 *	hSession      -- the session handle
 *	fSending      -- TRUE if sending, FALSE if receiving
 *	puiOldOptions -- where to store the old settings
 *
 * RETURNS:
 *	TRUE if everything was OK, otherwise FALSE
 *
 */
int xfer_set_comport(HSESSION hSession, int fSending, unsigned *puiOldOptions)
	{
	unsigned uiOptions = COM_OVERRIDE_8BIT;
	unsigned uiOldOptions;

	if (fSending)
		bitset(uiOptions, COM_OVERRIDE_SNDALL);
	else
		bitset(uiOptions, COM_OVERRIDE_RCVALL);

	/* TODO: find out how to decide which things need to be changed, BFMI */
	if (ComOverride(sessQueryComHdl(hSession),
					uiOptions,
					&uiOldOptions) != COM_OK)
		{
		return FALSE;
		}
	if (puiOldOptions != NULL)
		*puiOldOptions = uiOldOptions;
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_restore_comport
 *
 * DESCRIPTION:
 *	This function is called to restore the parameters that the previous call
 *	saved.
 *
 * PARAMETERS:
 *	hSession     -- the session handle
 *	uiOldOptions -- the old comm parameters
 *
 * RETURNS:
 *	TRUE if everything was OK, otherwise FALSE
 *
 */
int xfer_restore_comport(HSESSION hSession, unsigned uiOldOptions)
	{

	ComSndBufrWait(sessQueryComHdl(hSession), 10);

	// Let any trailing data get sent
	ComSndBufrWait(sessQueryComHdl(hSession), 10);
	if (ComOverride(sessQueryComHdl(hSession), uiOldOptions, NULL) != COM_OK)
		return FALSE;
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_save_partial
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to decide if it is
 *	OK to leave a partial file around if a transfer is aborted.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	TRUE if it is OK, otherwise FALSE
 *
 */
int xfer_save_partial(HSESSION hSession)
	{
	XD_TYPE *pX;
	XFR_PARAMS *pP;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pP = (XFR_PARAMS *)pX->xfer_params;
		if (pP)
			{
			return pP->fSavePartial;
			}
		}
	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_nextfile
 *
 * DESCRIPTION:
 *	This function is called by the transfer routines to get the name of the
 *	next file that is to be sent on over to the other side.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *	filename -- where to copy the file name
 *
 * RETURNS:
 *	TRUE if there was a filename available, otherwise FALSE
 *
 */
int xfer_nextfile(HSESSION hSession, TCHAR *filename)
	{
	XD_TYPE *pX;
	XFR_SEND *pS;
	LPTSTR pszStr;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pS = (XFR_SEND *)pX->pXferStuff;
		if (pS)
			{
			if (pS->nIndex < pS->nCount)
				{
				pszStr = pS->pList[pS->nIndex].pszName;
				StrCharCopy(filename, pszStr);
				pS->nIndex += 1;
				/*
				 * TODO: decide where the memory gets freed
				 */
				return TRUE;
				}
			}
		}
	return FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_log_xfer
 *
 * DESCRIPTION:
 *	This function is called after a file is sent or received to place that
 *	information in the log file.
 *
 * PARAMETERS:
 *	hSession  -- the session handle
 *	sending   -- TRUE if the file was sent, otherwise FALSE
 *	theirname -- the name that was given to the other system
 *	ourname   -- the name of the file on this system
 *	result    -- the final transfer status code
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfer_log_xfer(HSESSION hSession,
				  int sending,
				  TCHAR *theirname,
				  TCHAR *ourname,
				  int result)
	{
	/*
	 * Lower Wacker does not do transfer logging.  This is here mostly as a
	 * place holder and for the eventual conversion to Upper Wacker.
	 */
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_opensendfile
 *
 * DESCRIPTION:
 *	This function is called to open a file that is to be sent to another
 *	system.
 *
 * PARAMETERS:
 *	hSession     -- the session handle
 *	fp           -- where to store the open file handle
 *	file_to_open -- the name of the file to open (duh!)
 *	size         -- where to save the size of the file
 *	name_to_send -- what name to send to the other system
 *	ft           -- currently unused
 *
 * RETURNS:
 *	    0 if everything is OK
 *	   -1 if an error occurred
 *	   -2 if the file was not found
 *
 */
int xfer_opensendfile(HSESSION hSession,
					 HANDLE *fp,
					 TCHAR *file_to_open,
					 long *size,
					 TCHAR *name_to_send,
					 void *ft)
	{
	DWORD dwFoo;

	*fp = (HANDLE)0;

	/*
	 * Just try an open the file
	 */
	*fp = fio_open(file_to_open, FIO_READ);

	if (*fp == NULL)
		{
		*fp = (HANDLE)0;
		return -1;
		}

	/*
	 * Got the file open, get the size
	 */
	*size = GetFileSize(fio_gethandle((ST_IOBUF *)*fp), &dwFoo);

	/*
	 * TODO: do the date and time stuff
	 */

	/*
	 * Give them a file name
	 */
	if (name_to_send != NULL)
		xfer_name_to_send(hSession, file_to_open, name_to_send);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfer_name_to_send
 *
 * DESCRIPTION:
 *	This function is called to modify the file name into some sort of form
 *	that should be sent over to the other side.  Kind of sounds like an
 *	exchange of captured spys at Checkpoint Charlie.
 *
 * PARAMETERS:
 *	hSession     -- the session handle
 *	local_name   -- what the name is on this system
 *	name_to_send -- where to put the processed name
 *
 * RETURNS:
 *	Nothing.
 *
 */
void xfer_name_to_send(HSESSION hSession,
					  TCHAR *local_name,
					  TCHAR *name_to_send)
	{
	TCHAR *pszStr;
	XD_TYPE *pX;
	XFR_PARAMS *pP;

	if (local_name == NULL)
		return;
	if (name_to_send == NULL)
		return;

	pX = (XD_TYPE *)sessQueryXferHdl(hSession);
	if (pX)
		{
		pP = (XFR_PARAMS *)pX->xfer_params;
		if (pP)
			{
			if (pP->fIncPaths)
				{
				StrCharCopy(name_to_send, local_name);
				}
			}
		}
	/*
	 * Otherwise, just do this
	 */
	pszStr = StrCharFindLast(local_name, TEXT('\\'));
	if (*pszStr == TEXT('\\'))
		pszStr += 1;
	StrCharCopy(name_to_send, pszStr);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\x_hp_dlg.c ===
/*	File: C:\WACKER\XFER\x_hp_dlg.c (Created: 24-Jan-1994)
 *	created from:
 *	File: C:\WACKER\TDLL\genrcdlg.c (Created: 16-Dec-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1993,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/25/02 1:17p $
 */

#include <windows.h>
#include <commctrl.h>
#include <tdll\stdtyp.h>
#include <tdll\assert.h>
#include <tdll\mc.h>

#define	RESYNC		102
#define	RESYNC_UD	202

#define BLOCKS		104
#define	BLOCKS_UD	204

#define CMP_ON	106
#define CMP_OFF 107

#define CRC 	109
#define CSUM	110

#define	RMIN	3
#define RMAX	60

#define SMIN	128
#define SMAX	16384

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	int nOldHelp;
	/*
	 * Put in whatever else you might need to access later
	 */
	};

typedef	struct stSaveDlgStuff SDS;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	HyperProtocolParamsDlg
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
BOOL CALLBACK HyperProtocolParamsDlg(HWND hDlg,
									UINT wMsg,
									WPARAM wPar,
									LPARAM lPar)
	{
#if defined(UPPER_FEATURES)
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;


	switch (wMsg)
		{
	case WM_INITDIALOG:
		{
		RECT rc;
		int nLoop;
		DWORD dw;

		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			}

		/*
		 * We need to create a couple of UP/DOWN controls
		 */
		GetClientRect(GetDlgItem(hDlg, RESYNC), &rc);
		nLoop = rc.top - rc.bottom;
		dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
		dw |= UDS_ALIGNRIGHT;
		dw |= UDS_ARROWKEYS;
		dw |= UDS_SETBUDDYINT;
		hwndChild = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nLoop / 3) * 2,/* width */
								nLoop,			/* height */
								hDlg,			/* parent window */
								RESYNC_UD,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, RESYNC),
								RMAX,			/* upper limit */
								RMIN,			/* lower limit */
								5);				/* starting position */
		assert(hwndChild);

		GetClientRect(GetDlgItem(hDlg, BLOCKS), &rc);
		nLoop = rc.top - rc.bottom;
		dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
		dw |= UDS_ALIGNRIGHT;
		dw |= UDS_ARROWKEYS;
		dw |= UDS_SETBUDDYINT;
		hwndChild = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nLoop / 3) * 2,/* width */
								nLoop,			/* height */
								hDlg,			/* parent window */
								BLOCKS_UD,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, BLOCKS),
								SMAX,			/* upper limit */
								SMIN,			/* lower limit */
								2048);			/* starting position */
		assert(hwndChild);

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);
		}
		break;

	case WM_DESTROY:
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/*
			 * Do whatever saving is necessary
			 */

			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

#endif
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\x_kr_dlg.c ===
/*	File: C:\WACKER\xfer\x_kr_dlg.c (Created: 27-Jan-1994)
 *	created from:
 *	File: C:\WACKER\TDLL\genrcdlg.c (Created: 16-Dec-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1993,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/15/02 4:41p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>

#include "xfer.h"
#include "xfer.hh"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	LPARAM lPar;
	};

typedef	struct stSaveDlgStuff SDS;

#define	CMP_CHECK		102

#define	BPP_UDC		104
#define	SWP_UDC		106
#define	ECS_UDC		108
#define	RTY_UDC		110
#define	PSC_UDC		112
#define	PEC_UDC		114
#define	NPD_UDC		116
#define	PDC_UDC		118

struct stUpDownControls
	{
	int nId;
	int nMin;
	int nMax;
	int nDef;
	};

typedef struct stUpDownControls UDC;

#if defined(UPPER_FEATURES)
UDC aUDC[10] =
	{
	{BPP_UDC, 20,  94,   94},
	{SWP_UDC, 5,   60,   5},
	{ECS_UDC, 1,   3,    1},
	{RTY_UDC, 1,   25,   5},
	{PSC_UDC, 0,   255,  1},
	{PEC_UDC, 0,   255,  13},
	{NPD_UDC, 0,   99,   0},
	{PDC_UDC, 0,   255,  0},
	{0, 0, 0, 0}
	};
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	KermitParamsDlg
 *
 * DESCRIPTION:
 *	The dialog proc for changing Kermit parameters.
 *
 * ARGUMENTS:
 *	Standard Windows dialog manager parameters
 *
 * RETURNS:
 *	Standard Windows dialog manager
 *
 */
BOOL CALLBACK KermitParamsDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
#if defined(UPPER_FEATURES)
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;
	XFR_KR_PARAMS *pK;


	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			}

		pS->lPar = lPar;				/* Save for later use */

		pK = (XFR_KR_PARAMS *)lPar;		/* We also need it for now */

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		/*
		 * Build the Up/Down controls
		 */
		for (nId = 0; nId < 10; nId += 1)
			{
			RECT rc;
			HWND hwndTmp;
			DWORD dw;
			int nWide;

			if (aUDC[nId].nId != 0)
				{
				GetClientRect(GetDlgItem(hDlg, aUDC[nId].nId), &rc);
				nWide = rc.top - rc.bottom;
				dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
				dw |= UDS_ALIGNRIGHT;
				dw |= UDS_ARROWKEYS;
				dw |= UDS_SETBUDDYINT;
				hwndTmp = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nWide / 3) * 2,/* width */
								nWide,			/* height */
								hDlg,			/* parent window */
								aUDC[nId].nId + 100,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, aUDC[nId].nId),
								aUDC[nId].nMax,	/* upper limit */
								aUDC[nId].nMin,	/* lower limit */
								aUDC[nId].nDef);/* starting position */
				assert(hwndTmp);
				}
			}

		/*
		 * Set the controls to the correct values
		 */
		SetDlgItemInt(hDlg, BPP_UDC, pK->nBytesPerPacket, FALSE);
		SetDlgItemInt(hDlg, SWP_UDC, pK->nSecondsWaitPacket, FALSE);
		SetDlgItemInt(hDlg, ECS_UDC, pK->nErrorCheckSize, FALSE);
		SetDlgItemInt(hDlg, RTY_UDC, pK->nRetryCount, FALSE);
		SetDlgItemInt(hDlg, PSC_UDC, pK->nPacketStartChar, FALSE);
		SetDlgItemInt(hDlg, PEC_UDC, pK->nPacketEndChar, FALSE);
		SetDlgItemInt(hDlg, NPD_UDC, pK->nNumberPadChars, FALSE);
		SetDlgItemInt(hDlg, PDC_UDC, pK->nPadChar, FALSE);

		break;

	case WM_DESTROY:
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

			if (pS)
				{
				/*
				 * Do whatever saving is necessary
				 */
				pK = (XFR_KR_PARAMS *)pS->lPar;

				if (pK)
					{
					BOOL nTranslated = FALSE;
					int nVal = 0;

					nVal = GetDlgItemInt(hDlg, BPP_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nBytesPerPacket = nVal;
						}

					nVal = GetDlgItemInt(hDlg, SWP_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nSecondsWaitPacket = nVal;
						}

					nVal = GetDlgItemInt(hDlg, ECS_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nErrorCheckSize    = nVal;
						}

					nVal = GetDlgItemInt(hDlg, RTY_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nRetryCount = nVal;
						}
					
					nVal = GetDlgItemInt(hDlg, PSC_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nPacketStartChar = nVal;
						}
					
					nVal = GetDlgItemInt(hDlg, PEC_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nPacketEndChar = nVAl;
						}
					
					nVal = GetDlgItemInt(hDlg, NPD_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nNumberPadChars = nVal;
						}
					
					nVal = GetDlgItemInt(hDlg, PDC_UDC, &nTranslated, TRUE);
					if (nTranslated)
						{
						pK->nPadChar = nVal;
						}
					}

				/* Free the storeage */
				free(pS);
				pS = (SDS *)0;
				}

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

#endif
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfr_todo.c ===
/* xfr_todo.c -- a file used to handle unwriten needs
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

#include <windows.h>
#pragma hdrstop

#define BYTE	char

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\com.h>
#include "xfr_todo.h"

/*
 * This function is here to provide stubs for functions that have not yet
 * been ported over to WACKER.  By the time WACKER is functional, this file
 * should be empty.
 */

/* Replace the old CNFG structure */

int cnfgBitRate()
	{
	/*
	 * TODO: decide if we actually need this kind of stuff or can we skip it ?
	 */
	return 9600;
	}

int cnfgBitsPerChar(HSESSION h)
	{
	HCOM hC;
	int nRet = 7;
	/*
	 * TODO: decide if we actually need this kind of stuff or can we skip it ?
	 */
	// return 7;
	hC = sessQueryComHdl(h);

	if (hC)
		ComGetDataBits(hC, &nRet);

	return nRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\xfr_todo.h ===
/* xfr_todo.h -- a file used to handle unwriten needs
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:16p $
 */

/*
 * This function is here to provide stubs for functions that have not yet
 * been ported over to WACKER.  By the time WACKER is functional, this file
 * should be empty.
 */

/* Replace the old CNFG structure */
extern int cnfgBitRate(void);
int cnfgBitsPerChar(HSESSION h);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\x_entry.c ===
/*	File: D:\WACKER\xfer\x_entry.c (Created: 14-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 7/11/02 11:13a $
 */

#include <windows.h>
#pragma hdrstop

#include <term\res.h>
#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\globals.h>
#include <tdll\session.h>
#include <tdll\xfer_msc.h>
#include <tdll\htchar.h>
#include <xfer\xfr_dsp.h>

#include "hpr.h"
#include "krm.h"
#include "mdmx.h"
#include "zmodem.h"

#include "xfer.h"
#include "xfer.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 *
 * This module contains all of the entry points into this DLL.  It also
 * contains a detailed description (as much as necessary) about the service
 * that the entry point offers.
 *
 *=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	xfrGetProtocols
 *
 * DESCRIPTION:
 *	This function builds and returns a list of the available transfer
 *	protocols.  In this version, it just uses internal protocols.  Later
 *	versions may check for additional DLLs by name and query them for
 *	details.
 *
 *	The list that gets returned is a pointer to an array of structures of
 *	type XFR_PROTOCOL.  The end of the list is indicated by a 0 for the
 *	protocol and a 0 length name string.
 *
 * ARGUMENTS:
 *	hSession        -- the session handle
 *	ppList          -- pointer to the list pointer (for returning data)
 *
 * RETURNS:
 *	0 if everything is OK, otherwise an error code.
 *
 */

#define	NUM_PROTOCOLS	9

int WINAPI xfrGetProtocols(const HSESSION hSession,
							const XFR_PROTOCOL **ppList)
	{
	int nIdx;
	XFR_PROTOCOL *pS;

	/*
	 * For the time being, we only return a single protocol.
	 */

	pS = (XFR_PROTOCOL *)malloc(NUM_PROTOCOLS * sizeof(XFR_PROTOCOL));
	if (pS == (XFR_PROTOCOL *)0)
		return XFR_NO_MEMORY;

	nIdx = 0;

#if FALSE
	pS[nIdx].nProtocol = XF_HYPERP;
	StrCharCopyN(pS[nIdx].acName, TEXT("HyperProtocol"), PROTOCOL_NAME_LENGTH);
	nIdx += 1;
#endif

	pS[nIdx].nProtocol = XF_XMODEM_1K;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_X_1,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));
	nIdx += 1;

	pS[nIdx].nProtocol = XF_XMODEM;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_X,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));
	nIdx += 1;

	pS[nIdx].nProtocol = XF_YMODEM;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_Y,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));
	nIdx += 1;

	pS[nIdx].nProtocol = XF_YMODEM_G;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_Y_G,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));
	nIdx += 1;

	pS[nIdx].nProtocol = XF_ZMODEM;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_Z,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));
	nIdx += 1;

#if defined(INCL_ZMODEM_CRASH_RECOVERY)
	pS[nIdx].nProtocol = XF_ZMODEM_CR;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_Z_CR,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));

	nIdx += 1;
#endif  // defined(INCL_ZMODEM_CRASH_RECOVERY)

	pS[nIdx].nProtocol = XF_KERMIT;
	LoadString(glblQueryDllHinst(),
				IDS_XD_PROTO_K,
				pS[nIdx].acName,
				sizeof(pS[nIdx].acName) / sizeof(TCHAR));
	nIdx += 1;

	pS[nIdx].nProtocol = 0;		/* Indicates end of list */
	pS[nIdx].acName[0] = TEXT('\0');

	*ppList = pS;				/* Return the list */

	return (0);
	}

#if defined(DEADWOOD)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	xfrGetParameters
 *
 * DESCRIPTION:
 *	This function pops up a dialog to get specific transfer protocol
 *	parameters.  You get a different dialog and different parameters for
 *	each protocol.
 *
 * ARGUMENTS:
 *	hSession       -- the session handle
 *	nProtocol      -- the protocol id, returned from xfrGetProtocols
 *	hwnd           -- the parent window handle
 *	ppData         -- pointer to the data pointer (for returning data)
 *
 * NOTES:
 *	The ppData parameter is set up so that if there is a previous block
 *	of data for this protocol, it can be passed in.  If there is no data
 *	for this protocol, a NULL pointer is passed in and one is allocated and
 *	returned.  The returned value should always be used instead of the passed
 *	in value because at some time in the future, a parameter block mey need
 *	to expand and realloc some memory.
 *
 * RETURNS:
 *	0 if everything is OK, otherwise an error code.
 *
 */
int WINAPI xfrGetParameters(const HSESSION hSession,
							const int nProtocol,
							const HWND hwnd,
							VOID **ppData)
	{
	int nRet = 0;
	VOID *pD = *ppData;

	if (pD == (VOID *)0)
		{
		/* Caller did not supply an old parameter block, create one */
		nRet = xfrInitializeParams(hSession, nProtocol, &pD);
		if (nRet != 0)
			return nRet;
		}

	nRet = xfrModifyParams(hSession,
							nProtocol,
							hwnd,
							pD);

	if (nRet != 0)
		{
		/* Clean up on an error */
		free(pD);
		pD = (VOID *)0;
		}

	*ppData = pD;

	return (nRet);
	}
#endif //defined(DEADWOOD)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	xfrReceive
 *
 * DESCRIPTION:
 *	This function starts a receive operation for a specific protocol.
 *	Any more details are only related to the sepcific protocol.
 *
 * ARGUMENTS:
 *	hSession      -- the session handle
 *	pXferRec      -- pointer to the receive data block (build by RECEIVE dlg)
 *
 * RETURNS:
 *	0 if everything is OK, otherwise an error code.
 *
 */
int WINAPI xfrReceive(const HSESSION hSession,
						const XFR_RECEIVE *pXferRec)
	{
    if (pXferRec == NULL)
        {
        assert(FALSE);
        return -1;
        }

	switch (pXferRec->nProtocol)
		{
#if FALSE
		case XF_HYPERP:
			return hpr_rcv(hSession,
							TRUE,
							FALSE);	/* TODO: Get single_file flag !!!! */
#endif
		case XF_ZMODEM:
		case XF_ZMODEM_CR:
			return  zmdm_rcv(hSession,
							pXferRec->nProtocol,
							TRUE,
							FALSE);	/* TODO: Get single_file flag !!!! */

		case XF_XMODEM:
		case XF_XMODEM_1K:
			return mdmx_rcv(hSession,
							TRUE,
							pXferRec->nProtocol,
							TRUE);	/* TODO: Get single_file flag !!!! */
		case XF_YMODEM:
		case XF_YMODEM_G:
			return mdmx_rcv(hSession,
							TRUE,
							pXferRec->nProtocol,
							FALSE);	/* TODO: Get single_file flag !!!! */
		case XF_KERMIT:
			return krm_rcv(hSession,
							TRUE,
							FALSE);	/* TODO: Get single_file flag !!!! */
		case XF_CSB:
			break;
		default:
			break;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	xfrSend
 *
 * DESCRIPTION:
 *	This function starts a send operation for a specific protocol.
 *	Any more details are only related to the specific protocols.
 *
 * ARGUMENTS:
 *	hSession      -- the session handle
 *	pXferSend     -- pointer to the send data block (built by SEND dialog)
 *
 * RETURNS:
 *	0 if everything is OK, otherwise an error code.
 *
 */
int WINAPI xfrSend(const HSESSION hSession,
					const XFR_SEND *pXferSend)
	{

    if (pXferSend == NULL)
        {
        assert(FALSE);
        return -1;
        }

	switch (pXferSend->nProtocol)
		{
#if FALSE
		case XF_HYPERP:
			return hpr_snd(hSession,
							TRUE,			/* Attended ??? */
							pXferSend->nCount,
							pXferSend->lSize);
#endif
		case XF_ZMODEM:
        case XF_ZMODEM_CR:
			return zmdm_snd(hSession,
							pXferSend->nProtocol,
							TRUE,			/* Attended ??? */
							pXferSend->nCount,
							pXferSend->lSize);
		case XF_XMODEM:
		case XF_XMODEM_1K:
		case XF_YMODEM:
		case XF_YMODEM_G:
			return mdmx_snd(hSession,
							TRUE,			/* Attended ??? */
							pXferSend->nProtocol,
							pXferSend->nCount,
							pXferSend->lSize);
		case XF_KERMIT:
			return krm_snd(hSession,
							TRUE,			/* Attended ??? */
							pXferSend->nCount,
							pXferSend->lSize);
		case XF_CSB:
			break;
		default:
			break;
		}

	return (0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\x_params.c ===
/*	File: D:\WACKER\xfer\x_params.c (Created: 16-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 7/12/02 8:12a $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\globals.h>
#include <tdll\mc.h>
#include "xfer.h"
#include "xfer.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrInitializeParams
 *
 * DESCRIPTION:
 *	This function is called to initialize a transfer parameter block.  It
 *	calls the specific function that is for the specific protocol.
 *
 * ARGUEMENTS:
 *	hSession     -- the session handle
 *	nProtocol    -- indicates which protocol
 *  ppData       -- a pointer to a pointer for the return of the block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
int xfrInitializeParams(const HSESSION hSession,
						const int nProtocol,
						VOID **ppData)
	{
	int nRet;

	switch (nProtocol)
		{
		case XF_ZMODEM:
		case XF_ZMODEM_CR:
			nRet = xfrInitializeZmodem(hSession, nProtocol, ppData);
			break;

		case XF_XMODEM:
		case XF_XMODEM_1K:
		case XF_YMODEM:
		case XF_YMODEM_G:
			nRet = xfrInitializeXandYmodem(hSession, ppData);
			break;

#if FALSE
		case XF_HYPERP:
			nRet = xfrInitializeHyperProtocol(hSession, ppData);
			break;
#endif

		case XF_KERMIT:
			nRet = xfrInitializeKermit(hSession, ppData);
			break;

		case XF_CSB:

		default:
			nRet = XFR_BAD_PROTOCOL;
			break;
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrInitializeHyperProtocol
 *
 * DESCRIPTION:
 *	This function is called to initialize a HyperProtocol parameter block. It
 *	will allocate a block if necessary, initialize the block and return.
 *
 * ARGUEMENTS:
 *	hSession     -- the session handle
 *  ppData       -- a pointer to a pointer for the return of the block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
#if FALSE
int xfrInitializeHyperProtocol(const HSESSION hSession, VOID **ppData)
	{
	int nRet;
	XFR_HP_PARAMS *pH;

	nRet = 0;

	pH = (XFR_HP_PARAMS *)*ppData;	/* Get the current parameters */
	if (pH == NULL)
		{
		/* Allocate a new structure */
		pH = (XFR_HP_PARAMS *)malloc(sizeof(XFR_HP_PARAMS));
		if (pH == (XFR_HP_PARAMS *)0)
			nRet = XFR_NO_MEMORY;
		}

	if (nRet == 0)
		{
		/* Remember to set the size */
		pH->nSize           = sizeof(XFR_HP_PARAMS);

		pH->nCheckType      = HP_CT_CHECKSUM;
		pH->nBlockSize      = 2048;
		pH->nResyncTimeout  = 10;

		*ppData = (VOID FAR *)pH;
		}

	return nRet;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrInitializeZmodem
 *
 * DESCRIPTION:
 *	This function is called to initialize a ZMODEM parameter block.  It will
 *	allocate a block if necessary, initialize the block and return.
 *
 * ARGUEMENTS:
 *	hSession     -- the session handle
 *	nProtocol	 --	Zmodem or Zmodem with crash recovery
 *  ppData       -- a pointer to a pointer for the return of the block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
int xfrInitializeZmodem(const HSESSION hSession,
						int nProtocol,
						VOID **ppData)
	{
	int nRet;
	XFR_Z_PARAMS *pZ;

	nRet = 0;

	pZ = (XFR_Z_PARAMS *)*ppData;	/* Get the current parameters */
	if (pZ == NULL)
		{
		/* Allocate a new structure */
		pZ = (XFR_Z_PARAMS *)malloc(sizeof(XFR_Z_PARAMS));
		if (pZ == (XFR_Z_PARAMS *)0)
			{
			nRet = XFR_NO_MEMORY;
			}
		}

	if (nRet == 0)
		{
		/* Remember to set the size */
		pZ->nSize = sizeof(XFR_Z_PARAMS);

		pZ->nAutostartOK  = TRUE;
		pZ->nFileExists   = ZP_FE_DLG;
		if (nProtocol == XF_ZMODEM_CR)
			{
			pZ->nCrashRecRecv = ZP_CRR_ALWAYS;
			}
		else
			{
			pZ->nCrashRecRecv = ZP_CRR_NEVER;
			}
		pZ->nOverwriteOpt = ZP_OO_NONE;
		if (nProtocol == XF_ZMODEM_CR)
			{
			pZ->nCrashRecSend = ZP_CRS_ALWAYS;
			}
		else
			{
			pZ->nCrashRecSend = ZP_CRS_NEG;
			}
		pZ->nXferMthd     = ZP_XM_STREAM;
		pZ->nWinSize      = 15;		/* Set in KB */
		#if defined(UPPER_FEATURES)
		pZ->nBlkSize      = 6;		/* A wierd shift value */
		#endif // defined(UPPER_FEATURES)
		pZ->nCrcType      = ZP_CRC_16;
		pZ->nRetryWait    = 20;
		pZ->nEolConvert   = FALSE;
		pZ->nEscCtrlCodes = FALSE;

		*ppData = (VOID FAR *)pZ;
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrInitializeXandYmodem
 *
 * DESCRIPTION:
 *	This function is called to initialize a XMODEM parameter block.  It will
 *	allocate a block if necessary, initialize the block and return.
 *
 * ARGUEMENTS:
 *	hSession     -- the session handle
 *  ppData       -- a pointer to a pointer for the return of the block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
int xfrInitializeXandYmodem(const HSESSION hSession,
						VOID **ppData)
	{
	int nRet;
	XFR_XY_PARAMS *pX;

	nRet = 0;

	pX = (XFR_XY_PARAMS *)*ppData;	/* Get the current parameters */
	if (pX == NULL)
		{
		/* Allocate a new structure */
		pX = (XFR_XY_PARAMS *)malloc(sizeof(XFR_XY_PARAMS));
		if (pX == (XFR_XY_PARAMS *)0)
			nRet = XFR_NO_MEMORY;
		}

	if (nRet == 0)
		{
		/* Remember to set the size */
		pX->nSize = sizeof(XFR_XY_PARAMS);

		pX->nErrCheckType = XP_ECP_AUTOMATIC;
		pX->nPacketWait   = 20;
		pX->nByteWait	  = 5;
		pX->nNumRetries   = 10;

		*ppData = (VOID FAR *)pX;
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrModifyParams
 *
 * DESCRIPTION:
 *	This function is called to bring up a dialog box allowing the user to
 *	change any of the options for a specified protocol.
 *
 * ARGUEMENTS:
 *	hSession      -- a session handle
 *	nProtocol     -- speciofies the protocol
 *	hwnd          -- window to be parent window
 *	pData         -- pointer to the parameters data block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
int xfrModifyParams(const HSESSION hSession,
					const int nProtocol,
					const HWND hwnd,
					VOID *pData)
	{
	int nRet;

	if (pData == (VOID *)0)
		return XFR_BAD_POINTER;

	switch (nProtocol)
		{
#if defined(UPPER_FEATURES)
		case XF_ZMODEM:
			nRet = xfrModifyZmodem(hSession, hwnd, pData);
			break;

		case XF_XMODEM:
		case XF_XMODEM_1K:
			nRet = xfrModifyXmodem(hSession, hwnd, pData);
			break;

		case XF_YMODEM:
		case XF_YMODEM_G:
			nRet = xfrModifyYmodem(hSession, hwnd, pData);
			break;

		case XF_HYPERP:
			nRet = xfrModifyHyperProtocol(hSession, hwnd, pData);
			break;

		case XF_KERMIT:
			nRet = xfrModifyKermit(hSession, hwnd, pData);
			break;

		case XF_CSB:

#endif
		default:
			nRet = XFR_BAD_PROTOCOL;
			break;
		}

	return nRet;
	}

#if defined(UPPER_FEATURES)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrModifyXandYmodem
 *
 * DESCRIPTION:
 *	This function brings up the dialog box that allows the user to change
 *	the XMODEM protocol parameters.
 *
 * ARGUEMENTS:
 *	hSession      -- the session handle
 *	hwnd          -- the window to be the parent
 *	pData         -- pointer to the parameter data block
 *
 * RETURNS:
 */
int xfrModifyXmodem(const HSESSION hSession,
					const HWND hwnd,
					VOID *pData)
	{
	int nRet = 0;
	XFR_XY_PARAMS *pX;

	pX = (XFR_XY_PARAMS *)pData;

	DoDialog(glblQueryDllHinst(),
			"XmodemParameters",
			hwnd,				/* parent window */
			XandYmodemParamsDlg,
			(LPARAM)pX);

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrModifyYmodem
 *
 * DESCRIPTION:
 *	This function brings up the dialog box that allows the user to change
 *	the YMODEM protocol parameters.
 *
 * ARGUEMENTS:
 *	hSession      -- the session handle
 *	hwnd          -- the window to be the parent
 *	pData         -- pointer to the parameter data block
 *
 * RETURNS:
 */
int xfrModifyYmodem(const HSESSION hSession,
					const HWND hwnd,
					VOID *pData)
	{
	int nRet = 0;
	XFR_XY_PARAMS *pY;

	pY = (XFR_XY_PARAMS *)pData;

	DoDialog(glblQueryDllHinst(),
			"YmodemParameters",
			hwnd,				/* parent window */
			XandYmodemParamsDlg,
			(LPARAM)pY);

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrModifyZmodem
 *
 * DESCRIPTION:
 *	This function brings up the dialog box that allows the user to change
 *	the ZMODEM protocol parameters.
 *
 * ARGUEMENTS:
 *	hSession      -- the session handle
 *	hwnd          -- the window to be the parent
 *	pData         -- pointer to the parameter data block
 *
 * RETURNS:
 */
int xfrModifyZmodem(const HSESSION hSession,
					const HWND hwnd,
					VOID *pData)
	{
	int nRet = 0;
	XFR_Z_PARAMS *pZ;

	pZ = (XFR_Z_PARAMS *)pData;

	DoDialog(glblQueryDllHinst(),
			"ZmodemParameters",
			hwnd,				/* parent window */
			ZmodemParamsDlg,
			(LPARAM)pZ);

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrModifyHyperProtocol
 *
 * DESCRIPTION:
 *	This function brings up the dialog box that allows the user to change
 *	the HyperProtocol parameters.
 *
 * ARGUEMENTS:
 *	hSession      -- the session handle
 *	hwnd          -- the window to be the parent
 *	pData         -- pointer to the parameter data block
 *
 * RETURNS:
 */
#if FALSE
int xfrModifyHyperProtocol(const HSESSION hSession,
							const HWND hwnd,
							VOID *pData)
	{
	int nRet = 0;
	XFR_HP_PARAMS *pH;

	pH = (XFR_HP_PARAMS *)pData;

	DoDialog(glblQueryDllHinst(),
			"HyperParameters",
			hwnd,				/* parent window */
			HyperProtocolParamsDlg,
			(LPARAM)pH);

	return nRet;
	}
#endif

#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	xfrInitializeKermit
 *
 * DESCRIPTION:
 *	This function is called to initialize a HyperProtocol parameter block. It
 *	will allocate a block if necessary, initialize the block and return.
 *
 * ARGUEMENTS:
 *	hSession     -- the session handle
 *  ppData       -- a pointer to a pointer for the return of the block
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 */
int xfrInitializeKermit(const HSESSION hSession, VOID **ppData)
	{
	int nRet;
	XFR_KR_PARAMS *pK;

	nRet = 0;

	pK = (XFR_KR_PARAMS *)*ppData;	/* Get the current parameters */
	if (pK == NULL)
		{
		/* Allocate a new structure */
		pK = (XFR_KR_PARAMS *)malloc(sizeof(XFR_KR_PARAMS));
		if (pK == (XFR_KR_PARAMS *)0)
			nRet = XFR_NO_MEMORY;
		}

	if (nRet == 0)
		{
		/* Remember to set the size */
		pK->nSize              = sizeof(XFR_KR_PARAMS);
		pK->nBytesPerPacket    = 94;
		pK->nSecondsWaitPacket = 5;
		pK->nErrorCheckSize    = 1;
		pK->nRetryCount        = 5;
		pK->nPacketStartChar   = 1;
		pK->nPacketEndChar     = 13;
		pK->nNumberPadChars    = 0;
		pK->nPadChar           = 0;

		*ppData = (VOID FAR *)pK;
		}

	return nRet;
	}

#if defined(UPPER_FEATURES)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUEMENTS:
 *
 * RETURNS:
 */
int xfrModifyKermit(const HSESSION hSession,
					const HWND hwnd,
					VOID *pData)
	{
	int nRet = 0;
	XFR_KR_PARAMS *pKR;

	pKR = (XFR_KR_PARAMS *)pData;

	DoDialog(glblQueryDllHinst(),
			"KermitParameters",
			hwnd,				/* parent window */
			KermitParamsDlg,
			(LPARAM)pKR);

	return nRet;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\zmdm.c ===
/* zmdm.c -- Routines to handle zmodem for HyperACCESS
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 13 $
 *	$Date: 7/12/02 8:36a $
 */
/*
 *   Z M . C
 *    ZMODEM protocol primitives
 *    05-09-88  Chuck Forsberg Omen Technology Inc
 *
 * Entry point Functions:
 *	zsbhdr(type, hdr) send binary header
 *	zshhdr(type, hdr) send hex header
 *	zgethdr(hdr, eflag) receive header - binary or hex
 *	zsdata(buf, len, frameend) send data
 *	zrdata(buf, len) receive data
 *	stohdr(pos) store position data in Txhdr
 *	long rclhdr(hdr) recover position offset from header
 */

#include <windows.h>
#pragma hdrstop

#include <setjmp.h>

#define	BYTE	unsigned char

#include <tdll\stdtyp.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\file_io.h>
#include "xfr_srvc.h"
#include "xfr_todo.h"
#include "xfr_dsp.h"
#include "xfer_tsc.h"
#include "foo.h"


#include "zmodem.hh"
#include "zmodem.h"

#if defined(DEBUG_DUMPPACKET)
#include <stdio.h>
extern FILE* fpPacket;
void DbgDumpPacket(ZC* zc, BYTE* buf, int nLength);
#endif  // defined(DEBUG_DUMPPACKET)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * readline - added to get all this stuff to match up
 *
 */

/*----------------------------------------------------------------------+
 | zmdm_rl
 +----------------------------------------------------------------------*/
int zmdm_rl (ZC *zc, int timeout)
	{
	TCHAR c;
	int x;
	int n;
	long elapsed_time;

	elapsed_time = (long)startinterval();

	// if ((c = rdget(zc)) == (-1))
	if ((n = mComRcvChar(zc->hCom, &c)) == 0)
		{
		xfer_idle(zc->hSession, XFER_IDLE_IO);

		while (((long)interval(elapsed_time) <= (long)timeout) && (n == 0))
			{
            //
            // We don't want to keep attempting to receive data
            // if we have lost the connection. REV: 08/22/2001.
            //
		    if (xfer_carrier_lost(zc->hSession))
			    {
                return (ZCARRIER_LOST);
			    }

			x = xfer_user_interrupt(zc->hSession);

			switch (x)
				{
				case XFER_ABORT:
					zmdmr_update(zc, ZCAN);
					longjmp(zc->flagkey_buf, 1);
					break;

				case XFER_SKIP:
					/* This MUST only happen while receiving */
					stohdr(zc, zc->filesize);
					zshhdr(zc, ZRPOS, zc->Txhdr);
					zc->nSkip = TRUE;
					zc->file_bytes = zc->filesize;
					break;

				default:
					break;
				}

            //
            // We don't want to keep attempting to receive data
            // if we have lost the connection. REV: 08/22/2001.
            //
		    if (xfer_carrier_lost(zc->hSession))
			    {
                return (ZCARRIER_LOST);
			    }

			xfer_idle(zc->hSession, XFER_IDLE_IO);

			// c = rdget(zc);
			n = mComRcvChar(zc->hCom, &c);
			}

		if (n == 0)
            {
			c = TIMEOUT;
            }
		}

	return (c);
	}

/*----------------------------------------------------------------------+
 | zsbhdr - Send ZMODEM binary header hdr of type type.
 +----------------------------------------------------------------------*/
void zsbhdr(ZC *zc, int type, BYTE *hdr)
    {
	register int n;
	register unsigned short crc;

	xsendline(zc, &zc->stP, ZPAD);
	xsendline(zc, &zc->stP, ZDLE);

	if (zc->Crc32t = zc->Txfcs32)
		zsbh32(zc, hdr, type);
	else
		{
		xsendline(zc, &zc->stP, ZBIN);
		zsendline(zc, type);
		crc = updcrc(zc, type, 0);

		for (n=4; --n >= 0; ++hdr)
			{
			zsendline(zc, *hdr);
			crc = updcrc(zc, (0377& *hdr), crc);
			}
		crc = updcrc(zc, 0,crc);
		crc = updcrc(zc, 0,crc);
		zsendline(zc, (int)crc>>8);
		zsendline(zc, (int)crc);
		}
	if (type != ZDATA)
		flushmo(zc, &zc->stP);

	// xfer_idle(zc->hSession, XFER_IDLE_IO);
	}

/*----------------------------------------------------------------------+
 | zsbh32 - Send ZMODEM binary header hdr of type type.
 +----------------------------------------------------------------------*/
void zsbh32(ZC *zc, BYTE *hdr, int type)
	{
	register int n;
	register unsigned long crc;

	xsendline(zc, &zc->stP, ZBIN32);
	zsendline(zc, type);
	crc = 0xFFFFFFFFL;
	crc = UPDC32(zc, type, crc);

	for (n=4; --n >= 0; ++hdr)
		{
		crc = UPDC32(zc, (0377 & *hdr), crc);
		zsendline(zc, *hdr);
		}
	crc = ~crc;
	for (n=4; --n >= 0;)
		{
		zsendline(zc, (int)crc);
		crc >>= 8;
		}

	flushmo(zc, &zc->stP);

	// xfer_idle(zc->hSession, XFER_IDLE_IO);

	}

/*----------------------------------------------------------------------+
 | zshhdr - Send ZMODEM HEX header hdr of type type.
 +----------------------------------------------------------------------*/
void zshhdr(ZC *zc, int type, BYTE *hdr)
	{
	register int n;
	register unsigned short crc;

	sendline(zc, &zc->stP, ZPAD);
	sendline(zc, &zc->stP, ZPAD);
	sendline(zc, &zc->stP, ZDLE);
	sendline(zc, &zc->stP, ZHEX);

	zputhex(zc, type);
	zc->Crc32t = 0;

	crc = updcrc(zc, type, 0);
	for (n=4; --n >= 0; ++hdr)
		{
		zputhex(zc, *hdr);
		crc = updcrc(zc, (0377 & *hdr), crc);
		}
	crc = updcrc(zc, 0, crc);
	crc = updcrc(zc, 0,crc);
	zputhex(zc, crc>>8);
	zputhex(zc, crc);

	/* Make it printable on remote machine */
	sendline(zc, &zc->stP, 015);
	sendline(zc, &zc->stP, 0212);
	/*
	 * Uncork the remote in case a fake XOFF has stopped data flow
	 */
	if (type != ZFIN && type != ZACK)
		sendline(zc, &zc->stP, 021);
	flushmo(zc, &zc->stP);

	// xfer_idle(zc->hSession, XFER_IDLE_IO);
	}

/*----------------------------------------------------------------------+
 | zsdata - Send binary array buf of lengthl length, with ending ZDLE
 |			sequence frameend.
 +----------------------------------------------------------------------*/
void zsdata(ZC *zc, BYTE *buf, int length, int frameend)
	{
	register unsigned short crc;

	// xfer_idle(zc->hSession, XFER_IDLE_IO);

	if (zc->Crc32t)
		zsda32(zc, buf, length, frameend);
	else
		{
		crc = 0;
		for (;--length >= 0; ++buf)
			{
			zsendline(zc, *buf);
			crc = updcrc(zc, (0377 & *buf), crc);
			}
		xsendline(zc, &zc->stP, ZDLE);
		xsendline(zc, &zc->stP, (UCHAR)frameend);
		crc = updcrc(zc, frameend, crc);

		crc = updcrc(zc, 0, crc);
		crc = updcrc(zc, 0, crc);
		zsendline(zc, (int)crc>>8);
		zsendline(zc, (int)crc);
		}
	if (frameend == ZCRCW)
		{
		xsendline(zc, &zc->stP, XON);
		flushmo(zc, &zc->stP);
		}

	// xfer_idle(zc->hSession, XFER_IDLE_IO);
	}

/*----------------------------------------------------------------------+
 | zsda32
 +----------------------------------------------------------------------*/
void zsda32(ZC *zc, BYTE *buf, int length, int frameend)
	{
	register int c;
	register unsigned long crc;

	crc = 0xFFFFFFFFL;
	for (;--length >= 0; ++buf)
		{
		c = *buf & 0377;
		if (c & 0140)
			{
			zc->lastsent = c;
			xsendline(zc, &zc->stP, ((UCHAR)c));
			}
		else
			zsendline(zc, c);
		crc = UPDC32(zc, c, crc);
		}
	xsendline(zc, &zc->stP, ZDLE);
	xsendline(zc, &zc->stP, (UCHAR)frameend);
	crc = UPDC32(zc, frameend, crc);

	crc = ~crc;
	for (length=4; --length >= 0;)
		{
		zsendline(zc, (int)crc);
		crc >>= 8;
		}
	}

/*----------------------------------------------------------------------+
 | zrdata - Receive array buf of max length with ending ZDLE sequence and
 |			CRC.  Returns the ending character or error code.  NB: On
 |			errors may store length+1 bytes!
 +----------------------------------------------------------------------*/
int zrdata(ZC *zc, BYTE *buf, int length)
	{
	register int c;
	register unsigned short crc;
	register BYTE *end;
	register int d;

	if (zc->Rxframeind == ZBIN32)
		return zrdat32(zc, buf, length);

	crc = zc->Rxcount = 0;
	end = buf + length;

	//
	// Don't overrun the buffer.  We used to overrun the buffer when
	// *buf++ = (char)c; is executed at the botton of the loop when
	// buf == end. REV: 4/4/2002
	//
	while (buf < end)
		{
		if ((c = zdlread(zc)) & ~0377)
			{
crcfoo1:
			switch (c)
				{
				case GOTCRCE:
				case GOTCRCG:
				case GOTCRCQ:
				case GOTCRCW:
					crc = updcrc(zc, (d=c)&0377, crc);
					if ((c = zdlread(zc)) & ~0377)
						goto crcfoo1;
					crc = updcrc(zc, c, crc);
					if ((c = zdlread(zc)) & ~0377)
						goto crcfoo1;
					crc = updcrc(zc, c, crc);
					if (crc & 0xFFFF)
						{
						/* zperr(badcrc); */
#if defined(DEBUG_DUMPPACKET)
                        fprintf(fpPacket, "zrdata: Bad CRC 0x%04X\n", crc);
                        DbgDumpPacket(zc, end - length, length - (end - buf));
#endif  // defined(DEBUG_DUMPPACKET)
						zmdmr_update (zc, ERROR);
						return ERROR;
						}
					zc->Rxcount = (int)(length - (end - buf));
					return d;
				case GOTCAN:
					/* zperr("Sender Canceled"); */
					zmdmr_update (zc, ZCAN);
					return ZCAN;
				case TIMEOUT:
					/* zperr("TIMEOUT"); */
#if defined(DEBUG_DUMPPACKET)
                    fputs("zrdata: Timed-out\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
					zmdmr_update(zc, TIMEOUT);
					return c;
				default:
					/* zperr("Bad data subpacket"); */
#if defined(DEBUG_DUMPPACKET)
                    fprintf(fpPacket, "zrdata: Bad data subpacket c=%d\n", c);
#endif  // defined(DEBUG_DUMPPACKET)
					zmdmr_update(zc, ZBADFMT);
					return c;
				}
			}
		*buf++ = (char)c;
		crc = updcrc(zc, c, crc);
		}
	/* zperr("Data subpacket too long"); */
	DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
#if defined(DEBUG_DUMPPACKET)
    fputs("zrdata: Data subpacket too long\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
	zmdmr_update(zc, ZBADFMT);
	return ERROR;
	}

/*----------------------------------------------------------------------+
 | zrdat32
 +----------------------------------------------------------------------*/
int zrdat32(ZC *zc, BYTE *buf, int length)
	{
	register int c;
	register unsigned long crc;
	register BYTE *end;
	register int d;

	crc = 0xFFFFFFFFL;
	zc->Rxcount = 0;
	end = buf + length;

	while (buf <= end)
		{
		if ((c = zdlread(zc)) & ~0377)
			{
crcfoo:
			switch (c)
				{
				case GOTCRCE:
				case GOTCRCG:
				case GOTCRCQ:
				case GOTCRCW:
					d = c;
					c &= 0377;
					crc = UPDC32(zc, c, crc);
					if ((c = zdlread(zc)) & ~0377)
						goto crcfoo;
					crc = UPDC32(zc, c, crc);
					if ((c = zdlread(zc)) & ~0377)
						goto crcfoo;
					crc = UPDC32(zc, c, crc);
					if ((c = zdlread(zc)) & ~0377)
						goto crcfoo;
					crc = UPDC32(zc, c, crc);
					if ((c = zdlread(zc)) & ~0377)
						goto crcfoo;
					crc = UPDC32(zc, c, crc);
					if (crc != 0xDEBB20E3)
						{
						/* zperr(badcrc); */
						DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
#if defined(DEBUG_DUMPPACKET)
                        fprintf(fpPacket, "zrdat32: Bad 32-bit CRC 0x%08lX\n", crc);
                        DbgDumpPacket(zc, end - length, length - (end - buf));
#endif  // defined(DEBUG_DUMPPACKET)
						zmdmr_update (zc, ERROR);
						return ERROR;
						}
					zc->Rxcount = (int)(length - (end - buf));
					return d;
				case GOTCAN:
					/* zperr("Sender Canceled"); */
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					zmdmr_update (zc, ZCAN);
					return ZCAN;
				case TIMEOUT:
					/* zperr("TIMEOUT"); */
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
#if defined(DEBUG_DUMPPACKET)
                    fputs("zrdata: Timed-out\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
					zmdmr_update (zc, TIMEOUT);
					return c;
				default:
					/* zperr("Bad data subpacket"); */
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
#ifdef  DEBUG_DUMPPACKET
                    fputs("zrdat32: Bad data subpacket\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
					zmdmr_update (zc, ZBADFMT);
					return c;
				}
			}
		*buf++ = (char)c;
		crc = UPDC32(zc, c, crc);
		}
	/* zperr("Data subpacket too long"); */
	DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
#ifdef  DEBUG_DUMPPACKET
    fputs("zrdat32: Data subpacket too long\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
	zmdmr_update (zc, ZBADFMT);
	return ERROR;
	}

#if defined(DEBUG_DUMPPACKET)
void DbgDumpPacket(ZC *zc, BYTE *buf, int length)
    {
    int     nCount;
    int     jj;

    fputs("Here's the offending packet:\n", fpPacket);

    for (nCount = 0; nCount < length; nCount += 16)
        {
        for (jj = nCount; jj < nCount + 16 && jj < length; jj += 1)
            {
            fprintf(fpPacket, "%02X ", (unsigned int) buf[jj]);
            }
        fputs("\n", fpPacket);
        }
    }
#endif  // defined(DEBUG_DUMPPACKET)

/*----------------------------------------------------------------------+
 | zgethdr - Read a ZMODEM header to hdr, either binary or HEX.
 |			 On success, set Rxpos and return type of header.
 |			 Otherwise return negative on error.
 |			 Return ERROR instantly if ZCRCW sequence, for fast error recovery.
 +----------------------------------------------------------------------*/
int zgethdr(ZC *zc, BYTE *hdr, int eflag)
	{
	register int c;
	register int n;
	register int cancount;


	/* Max bytes before start of frame */
	// n = zc->Zrwindow + (int)cnfg.bit_rate;
	n = zc->Zrwindow + cnfgBitRate();

	zc->Rxframeind = ZHEX;

	zc->Rxtype = 0;

startover:
	cancount = 5;
again:
	/* Return immediate ERROR if ZCRCW sequence seen */
	switch (c = readline(zc, zc->Rxtimeout))
		{
        case ZCARRIER_LOST:
		case RCDO:
		case TIMEOUT:
			goto fifi;
		case CAN:
gotcan:
			if (--cancount <= 0)
				{
				c = ZCAN;
				goto fifi;
				}
			// switch (c = readline(h, 1))
			switch (c = readline(zc, zc->Rxtimeout))		// Mobidem
				{
				case TIMEOUT:
					goto again;
				case ZCRCW:
#if defined(DEBUG_DUMPPACKET)
                    fputs("zgethdr: ZCRCW ret from readline\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
					c = ERROR;
					/* **** FALL THRU TO **** */
				case RCDO:
					goto fifi;
				default:
					break;
				case CAN:
					if (--cancount <= 0)
						{
						c = ZCAN;
						goto fifi;
						}
					goto again;
				}
			/* **** FALL THRU TO **** */
		default:
agn2:
			if ( --n == 0)
				{
				/* zperr("Garbage count exceeded"); */
				DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
#if defined(DEBUG_DUMPPACKET)
                fputs("zgethdr: Garbage count exceeded\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
				return(ERROR);
				}
			goto startover;
		case ZPAD|0200:		/* This is what we want. */
			zc->Not8bit = c;
		case ZPAD:		/* This is what we want. */
			break;
		}
	cancount = 5;
splat:
	switch (c = noxrd7(zc))
		{
		case ZPAD:
			goto splat;
		case RCDO:
		case TIMEOUT:
			goto fifi;
		default:
			goto agn2;
		case ZDLE:		/* This is what we want. */
			break;
		}

	switch (c = noxrd7(zc))
		{
		case RCDO:
		case TIMEOUT:
			goto fifi;
		case ZBIN:
			zc->Rxframeind = ZBIN; 
			zc->Crc32 = FALSE;
			c =  zrbhdr(zc, hdr, eflag);
			break;
		case ZBIN32:
			zc->Crc32 = ZBIN32;
			zc->Rxframeind = ZBIN32;
			c =  zrbhdr32(zc, hdr, eflag);
			break;
		case ZHEX:
			zc->Rxframeind = ZHEX;
			zc->Crc32 = FALSE;
			c =  zrhhdr(zc, hdr, eflag);
			break;
		case CAN:
			goto gotcan;
		default:
			goto agn2;
		}
	zc->Rxpos = hdr[ZP3] & 0377;
	zc->Rxpos = (zc->Rxpos<<8) + (hdr[ZP2] & 0377);
	zc->Rxpos = (zc->Rxpos<<8) + (hdr[ZP1] & 0377);
	zc->Rxpos = (zc->Rxpos<<8) + (hdr[ZP0] & 0377);
fifi:
	switch (c)
		{
		case GOTCAN:
			c = ZCAN;
            break;

		case ZNAK:
		case ZCAN:
		case ERROR:
		case TIMEOUT:
		case RCDO:
        case ZCARRIER_LOST:
            break;

		default:
			break;
		}
	if (eflag == 'T')
		{
		zmdms_update(zc, c);
		}
	else if (eflag == 'R')
		{
		zmdmr_update(zc, c);
		}
	return c;
	}

/*----------------------------------------------------------------------+
 | zrbhdr - Receive a binary style header (type and position).
 +----------------------------------------------------------------------*/
int zrbhdr(ZC *zc, BYTE *hdr, int eflag)
	{
	register int c, n;
	register unsigned short crc;

	if ((c = zdlread(zc)) & ~0377)
		return c;
	zc->Rxtype = c;
	crc = updcrc(zc, c, 0);

	for (n=4; --n >= 0; ++hdr)
		{
		if ((c = zdlread(zc)) & ~0377)
			return c;
		crc = updcrc(zc, c, crc);
		*hdr = (char)c;
		}
	if ((c = zdlread(zc)) & ~0377)
		return c;
	crc = updcrc(zc, c, crc);
	if ((c = zdlread(zc)) & ~0377)
		return c;
	crc = updcrc(zc, c, crc);
	if (crc & 0xFFFF)
		{
		/* zperr(badcrc); */
		DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
		if (eflag == 'T')
			zmdms_update(zc, ERROR);
		else if (eflag == 'R')
            {
#if defined(DEBUG_DUMPPACKET)
            fprintf(fpPacket, "zrbhdr: Bad CRC 0x%04X\n", crc);
#endif  // defined(DEBUG_DUMPPACKET)
			zmdmr_update(zc, ERROR);
            }
		return ERROR;
		}
	return zc->Rxtype;
	}

/*----------------------------------------------------------------------+
 | zrbhdr32 - Receive a binary style header (type and position) with
 |			  32 bit FCS.
 +----------------------------------------------------------------------*/
int zrbhdr32(ZC *zc, BYTE *hdr, int eflag)
	{
	register int c, n;
	register unsigned long crc;

	if ((c = zdlread(zc)) & ~0377)
		return c;
	zc->Rxtype = c;
	crc = 0xFFFFFFFFL;
	crc = UPDC32(zc, c, crc);

	for (n=4; --n >= 0; ++hdr)
		{
		if ((c = zdlread(zc)) & ~0377)
			return c;
		crc = UPDC32(zc, c, crc);
		*hdr = (char)c;
		}
	for (n=4; --n >= 0;)
		{
		if ((c = zdlread(zc)) & ~0377)
			return c;
		crc = UPDC32(zc, c, crc);
		}
	if (crc != 0xDEBB20E3)
		{
		/* zperr(badcrc); */
		DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
		if (eflag == 'T')
			zmdms_update(zc, ERROR);
		else if (eflag == 'R')
            {
#if defined(DEBUG_DUMPPACKET)
            fprintf(fpPacket, "zrbhdr32: Bad CRC 0x%08lX\n", crc);
#endif  // defined(DEBUG_DUMPPACKET)
			zmdmr_update(zc, ERROR);
            }
		return ERROR;
		}
	return zc->Rxtype;
	}

/*----------------------------------------------------------------------+
 | zrhhdr - Receive a hex style header (type and postion).
 +----------------------------------------------------------------------*/
int zrhhdr(ZC *zc, BYTE *hdr, int eflag)
	{
	register int c;
	register unsigned short crc;
	register int n;

	if ((c = zgethex(zc)) < 0)
		return c;
	zc->Rxtype = c;
	crc = updcrc(zc, c, 0);

	for (n=4; --n >= 0; ++hdr)
		{
		if ((c = zgethex(zc)) < 0)
			return c;
		crc = updcrc(zc, c, crc);
		*hdr = (char)c;
		}
	if ((c = zgethex(zc)) < 0)
		return c;
	crc = updcrc(zc, c, crc);
	if ((c = zgethex(zc)) < 0)
		return c;
	crc = updcrc(zc, c, crc);
	if (crc & 0xFFFF)
		{
		/* zperr(badcrc); */
		DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
		if (eflag == 'T')
			zmdms_update(zc, ERROR);
		else if (eflag == 'R')
            {
#if defined(DEBUG_DUMPPACKET)
            fprintf(fpPacket, "zrhhdr: Bad CRC 0x%04X\n", crc);
#endif  // defined(DEBUG_DUMPPACKET)
			zmdmr_update(zc, ERROR);
            }
		return ERROR;
		}
	// switch ( c = readline(h, 1))
	switch ( c = readline(zc, zc->Rxtimeout))		// Mobidem
		{
		case 0215:
			zc->Not8bit = c;
			/* **** FALL THRU TO **** */
		case 015:
		 	/* Throw away possible cr/lf */
			// switch (c = readline(h, 1))
			switch (c = readline(zc, zc->Rxtimeout))		// Mobidem
				{
				case 012:
					zc->Not8bit |= c;
				}
		}
	return zc->Rxtype;
	}

/*----------------------------------------------------------------------+
 | zputhex - Send a byte as two hex digits.
 +----------------------------------------------------------------------*/
void zputhex(ZC *zc, int c)
	{
	static BYTE	digits[]	= "0123456789abcdef";

	sendline(zc, &zc->stP, digits[(c&0xF0)>>4]);
	sendline(zc, &zc->stP, digits[(c)&0xF]);
	}

/*----------------------------------------------------------------------+
 | zsendline - Send character c with ZMODEM escape sequence encoding.
 |			   Escape XON, XOFF.  Escape CR following @ (Telnet net escape).
 +----------------------------------------------------------------------*/
void zsendline(ZC *zc, int c)
	{

	/* Quick check for non control characters */
	if (c & 0140)
		{
		zc->lastsent = c;
		xsendline(zc, &zc->stP, ((UCHAR)c));
		}
	else
		{
		switch (c &= 0377)
			{
			case ZDLE:
				xsendline(zc, &zc->stP, ZDLE);
				xsendline(zc, &zc->stP, (UCHAR)(zc->lastsent = (c ^= 0100)));
				break;
			case 015:
			case 0215:
				if (!zc->Zctlesc && (zc->lastsent & 0177) != '@')
					goto sendit;
				/* **** FALL THRU TO **** */
			case 020:
			case 021:
			case 023:
			case 0220:
			case 0221:
			case 0223:
				xsendline(zc, &zc->stP, ZDLE);
				c ^= 0100;
	sendit:
				xsendline(zc, &zc->stP, (UCHAR)(zc->lastsent = c));
				break;
			default:
				if (zc->Zctlesc && ! (c & 0140))
					{
					xsendline(zc, &zc->stP, ZDLE);
					c ^= 0100;
					}
				xsendline(zc, &zc->stP, (UCHAR)(zc->lastsent = c));
			}
		}
	}

/*----------------------------------------------------------------------+
 | zgethex - Decode two lower case hex digits into an 8 bit byte value.
 +----------------------------------------------------------------------*/
int zgethex(ZC *zc)
	{
	register int c;

	c = zgeth1(zc);
	return c;
	}

/*----------------------------------------------------------------------+
 | zgeth1
 +----------------------------------------------------------------------*/
int zgeth1(ZC *zc)
	{
	register int c, n;

	if ((c = noxrd7(zc)) < 0)
		return c;
	n = c - '0';
	if (n > 9)
		n -= ('a' - ':');
	if (n & ~0xF)
        {
#if defined(DEBUG_DUMPPACKET)
        fprintf(fpPacket, "zgeth1: n = 0x%02X\n", n);
#endif  // defined(DEBUG_DUMPPACKET)
		return ERROR;
        }
	if ((c = noxrd7(zc)) < 0)
		return c;
	c -= '0';
	if (c > 9)
		c -= ('a' - ':');
	if (c & ~0xF)
        {
#if defined(DEBUG_DUMPPACKET)
        fprintf(fpPacket, "zgeth1: c = 0x%02X\n", c);
#endif  // defined(DEBUG_DUMPPACKET)
		return ERROR;
        }
	c += (n<<4);
	return c;
	}

/*----------------------------------------------------------------------+
 | zdlread - Read a byte, checking for ZMODEM escape encoding including
 |			 CAN*5 which represents a quick abort.
 +----------------------------------------------------------------------*/
int zdlread(ZC *zc)
	{
	register int c;

again:
	/* Quick check for non control characters */
	if ((c = readline(zc, zc->Rxtimeout)) & 0140)
		return c;
	switch (c)
		{
		case ZDLE:
			break;
		case 023:
		case 0223:
		case 021:
		case 0221:
			goto again;
		default:
			if (zc->Zctlesc && !(c & 0140))
				{
				goto again;
				}
			return c;
		}
again2:
	if ((c = readline(zc, zc->Rxtimeout)) < 0)
		return c;
	if (c == CAN && (c = readline(zc, zc->Rxtimeout)) < 0)
		return c;
	if (c == CAN && (c = readline(zc, zc->Rxtimeout)) < 0)
		return c;
	if (c == CAN && (c = readline(zc, zc->Rxtimeout)) < 0)
		return c;
	switch (c)
		{
		case CAN:
			return GOTCAN;
		case ZCRCE:
		case ZCRCG:
		case ZCRCQ:
		case ZCRCW:
			return (c | GOTOR);
		case ZRUB0:
			return 0177;
		case ZRUB1:
			return 0377;
		case 023:
		case 0223:
		case 021:
		case 0221:
			goto again2;
		default:
			if (zc->Zctlesc && ! (c & 0140))
				{
				goto again2;
				}
			if ((c & 0140) ==  0100)
				return (c ^ 0100);
			break;
		}
	return ERROR;
	}
/*----------------------------------------------------------------------+
 | noxrd7 - Read a character from the modem line with timeout.
 |			Eat parity, XON and XOFF characters.
 +----------------------------------------------------------------------*/
int noxrd7(ZC *zc)
	{
	register int c;

	for (;;)
		{
		if ((c = readline(zc, zc->Rxtimeout)) < 0)
			return c;
		switch (c &= 0177)
			{
			case XON:
			case XOFF:
				continue;
			default:
				if (zc->Zctlesc && !(c & 0140))
					continue;
			case '\r':
			case '\n':
			case ZDLE:
				return c;
			}
		}
	}

/*----------------------------------------------------------------------+
 | stohdr - Store long integer pos in Txhdr.
 +----------------------------------------------------------------------*/
void stohdr(ZC *zc, long pos)
	{
	zc->Txhdr[ZP0] = (char)(pos & 0377);
	zc->Txhdr[ZP1] = (char)((pos>>8) & 0377);
	zc->Txhdr[ZP2] = (char)((pos>>16) & 0377);
	zc->Txhdr[ZP3] = (char)((pos>>24) & 0377);
	}

/*----------------------------------------------------------------------+
 | rclhdr - Recover a long integer from a header.
 +----------------------------------------------------------------------*/
long rclhdr(BYTE *hdr)
	{
	register long l;

	l = (hdr[ZP3] & 0377);
	l = (l << 8) | (hdr[ZP2] & 0377);
	l = (l << 8) | (hdr[ZP1] & 0377);
	l = (l << 8) | (hdr[ZP0] & 0377);
	return l;
	}

static unsigned int z_errors [] = {
	TSC_DISK_FULL,			/* ZFULLDISK (-5) */
	TSC_LOST_CARRIER,		/* ZCARRIER_LOST (-4) */
	TSC_GEN_FAILURE,        /* RCDO (-3) */
	TSC_NO_RESPONSE,		/* TIMEOUT (-2) */
	TSC_BAD_FORMAT,			/* ERROR (-1) */
// mode to zmdm.h // REV: 4/24/2002
//#define ERROFFSET	5
	TSC_CANT_START,			/* ZRQINIT (0)	   */
	TSC_CANT_START,			/* ZRINIT (1)	   */
	TSC_CANT_START,			/* ZSINIT (2)	   */
	TSC_OK,					/* ZACK (3) 	   */
	TSC_GEN_FAILURE,		/* ZFILE (4)	   */
	TSC_OK, 				/* ZSKIP (5)	   */
	TSC_GEN_FAILURE,		/* ZNAK (6) 	   */
	TSC_RMT_CANNED,			/* ZABORT (7)	   */
	TSC_COMPLETE,			/* ZFIN (8) 	   */
	TSC_GEN_FAILURE,		/* ZRPOS (9)	   */
	TSC_GEN_FAILURE,		/* ZDATA (10)	   */
	TSC_OK,					/* ZEOF (11)	   */
	TSC_DISK_ERROR,			/* ZFERR (12)	   */
	TSC_GEN_FAILURE,		/* ZCRC (13)	   */
	TSC_OK,					/* ZCHALLENGE (14) */
	TSC_COMPLETE,			/* ZCOMPL (15)	   */
	TSC_USER_CANNED,		/* ZCAN (16)	   */
	TSC_OK, 				/* ZFREECNT (17)   */
	TSC_CANT_START,			/* ZCOMMAND (18)   */
	TSC_CANT_START,			/* ZSTDERR (19)    */
	TSC_BAD_FORMAT,			/* added for HA/5  */
	TSC_OK, 				/* sent ack (21)   */
	TSC_VIRUS_DETECT,		/* ZMDM_VIRUS (22) */
	TSC_REFUSE,	 			/* ZMDM_REFUSE (23)*/
	TSC_OLDER_FILE,			/* ZMDM_OLDER (24) */
    TSC_FILEINUSE,          /* ZMDM_INUSE (25) */
};
#define ERRSIZE 30

/*----------------------------------------------------------------------+
 | zmdm_error
 +----------------------------------------------------------------------*/
unsigned int zmdm_error(ZC *zc, int error)
	{
	error += ERROFFSET;

	if ((error > ERRSIZE) || (error < 0))
		return TSC_GEN_FAILURE;
	else
		return z_errors[error];
	}

/*----------------------------------------------------------------------+
 | zmdm_retval
 +----------------------------------------------------------------------*/
int zmdm_retval(ZC *zc, int flag, int error)
	{

	if (flag == TRUE)
		{
		zc->s_error = error;
		}

	return(zc->s_error);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * zmdms_progress
 *
 * DESCRIPTION:
 *	Updates display fields on screen to indicate the progress of the transfer.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void zmdms_progress(ZC *zc, int status)
	{
	long ttime, stime;
	long bytes_sent;
	long cps;
	// int	k_sent;
	long new_stime	  = -1L;
	long new_ttime	  = -1L;
	long new_cps	  = -1L;
	long file_so_far  = -1L;
	long total_so_far = -1L;

	if (zc->xfertimer == -1L)
		return;

	ttime = bittest(status, TRANSFER_DONE) ?
			zc->xfertime : (long)interval(zc->xfertimer);
	if ((stime = ttime / 10L) != zc->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		new_stime = stime;

		/* Display amount transferred */
		bytes_sent = zc->file_bytes + zc->total_bytes;

		file_so_far  = zc->file_bytes;
		total_so_far = bytes_sent;

		/* Display throughput and time remaining */
		if ((stime > 2 ||
			 ttime > 0 && bittest(status, FILE_DONE | TRANSFER_DONE)) &&
			(cps = ((zc->real_bytes + zc->actual_bytes) * 10L) / ttime) > 0)
			{
			new_cps = cps;

			if (bittest(status, TRANSFER_DONE))
				ttime = 0;
			else
				ttime = ((zc->nbytes - bytes_sent) / cps) +
						  zc->nfiles - zc->filen;

			new_ttime = ttime;
			}
		zc->displayed_time = stime;
		}

		xferMsgProgress(zc->hSession,
						new_stime,
						new_ttime,
						new_cps,
						file_so_far,
						total_so_far);

	}

/*----------------------------------------------------------------------+
 | zmdms_newfile
 +----------------------------------------------------------------------*/
void zmdms_newfile(ZC *zc, int filen, TCHAR *fname, long flength)
	{
	xferMsgNewfile(zc->hSession,
				   filen,
				   NULL,
				   fname);

	xferMsgFilesize(zc->hSession, flength);

	}

/*----------------------------------------------------------------------+
 | zmsma_update
 +----------------------------------------------------------------------*/
void zmdms_update(ZC *zc, int state)
	{
    int nErrorID;

	if (state == ZACK || state == ZMDM_ACKED )
		{
		return;
		}

	if (zc->pstatus > RCDO)
		{
		nErrorID = zc->pstatus + ERROFFSET - 1;
		}
	else if (zc->pstatus < RCDO )
		{
		nErrorID = zc->pstatus + ERROFFSET;
		}
	else
		{
		nErrorID = ERROR + ERROFFSET - 1;
		}

	zc->last_event = zc->pstatus;
	zc->pstatus = state;

	xferMsgStatus(zc->hSession, nErrorID);

	xferMsgEvent(zc->hSession, nErrorID);

	if (state == ERROR)
		{
		zc->errors += 1;
		xferMsgErrorcnt(zc->hSession, zc->errors);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * zmdmr_progress
 *
 * DESCRIPTION:
 *	Displays the progress of a filetransfer on screen by showing the number of
 *	bytes transferred and updating the vu meters if they have been initialized.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void zmdmr_progress(ZC *zc, int status)
	{
	long ttime, stime;
	long bytes_rcvd;
	long bytes_diff;
	// long k_rcvd;
	long cps;
	long new_stime	  = -1;
	long new_ttime	  = -1;
	long new_cps	  = -1;
	long file_so_far  = -1;
	long total_so_far = -1;

	if (zc == NULL || zc->xfertimer == -1L)
		return;
	ttime = bittest(status, TRANSFER_DONE) ?
			zc->xfertime : (long)interval(zc->xfertimer);

	if ((stime = ttime / 10L) != zc->displayed_time ||
			bittest(status, FILE_DONE | TRANSFER_DONE))
		{
		/* Display elapsed time */
		new_stime = stime;

		bytes_rcvd = zc->total_bytes + zc->file_bytes;
		if (bittest(status, FILE_DONE))
			if (zc->filesize != 0)
				if (zc->file_bytes != zc->filesize)
					{
					zmdmr_filesize(zc, zc->file_bytes);
					bytes_diff = zc->filesize- zc->file_bytes;
					zc->filesize -= bytes_diff;
					zc->nbytes -= bytes_diff;
					zmdmr_totalsize(zc, zc->nbytes);
					}

		/* Display amount received */
		file_so_far = zc->file_bytes;

		total_so_far = bytes_rcvd;

		/* Display throughput and time remaining */
		if (stime > 0 &&
				(cps = ((zc->actual_bytes + zc->real_bytes)*10L) / ttime) > 0)
			{
			new_cps = cps;

			/* calculate time to completion */
			if (zc->nbytes > 0L)
				{
				ttime = (zc->nbytes - bytes_rcvd) / cps;
				if (zc->nfiles > 1)
					ttime += (zc->nfiles - zc->filen);
				new_ttime = ttime;
				}
			else if (zc->filesize > 0L)
				{
				ttime = (zc->filesize - zc->file_bytes) / cps;
				new_ttime = ttime;
				}
			}

		xferMsgProgress(zc->hSession,
						new_stime,
						new_ttime,
						new_cps,
						file_so_far,
						total_so_far);
		}
	}

/*----------------------------------------------------------------------+
 | zmdmr_update
 +----------------------------------------------------------------------*/
void zmdmr_update(ZC *zc, int status)
	{
    int nErrorID;

	if (status == ZACK || status == ZMDM_ACKED )
		return;

	if (status == ZRPOS && zc->do_init)
		{
		nErrorID = 0;
		}
	else if (zc->pstatus > RCDO)
		{
		nErrorID = zc->pstatus + ERROFFSET - 1;
		}
	else if (zc->pstatus < RCDO )
		{
		nErrorID = zc->pstatus + ERROFFSET;
		}
	else
		{
		nErrorID = ERROR + ERROFFSET - 1;
		}

	zc->last_event = zc->pstatus;
	zc->pstatus = status;

	xferMsgStatus(zc->hSession, nErrorID);

	xferMsgEvent(zc->hSession, nErrorID);

	if (status == ERROR)
		{
		zc->errors += 1;
		xferMsgErrorcnt(zc->hSession, zc->errors);
		}
	}

/*----------------------------------------------------------------------+
 | zmdmr_filecnt
 +----------------------------------------------------------------------*/
void zmdmr_filecnt(ZC *zc, int cnt)
	{
	xferMsgFilecnt(zc->hSession, cnt);
	}

/*----------------------------------------------------------------------+
 | zmdmr_totalsize
 +----------------------------------------------------------------------*/
void zmdmr_totalsize(ZC *zc, long bytes)
	{
	if (zc->nfiles >= 1)
		{
		xferMsgTotalsize(zc->hSession, bytes);
		}
	}

/*----------------------------------------------------------------------+
 | zmdmr_newfile
 +----------------------------------------------------------------------*/
void zmdmr_newfile(ZC *zc, int filen, BYTE *theirname, TCHAR *ourname)
	{
	xferMsgNewfile(zc->hSession,
				   filen,
				   theirname,
				   ourname);

	}

/*----------------------------------------------------------------------+
 | zmdmr_filesize
 +----------------------------------------------------------------------*/
void zmdmr_filesize(ZC *zc, long fsize)
	{

	if (fsize <= 0L)
		return;

	xferMsgFilesize(zc->hSession, fsize);
	}

/* End of zmodem.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\zmdm_rcv.c ===
/* zmdm_rcv.c -- ZMODEM compatible file receiving routines for HyperACCESS
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 15 $
 *	$Date: 7/12/02 8:35a $
 */
#include <windows.h>
#pragma hdrstop

//#define DEBUGSTR

#include <setjmp.h>
#include <time.h>
#include <term\res.h>
#include <sys\types.h>
#include <sys\utime.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\xfer_msc.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>
#include <tdll\file_msc.h>
#include <tdll\htchar.h>

#define	BYTE	unsigned char

#include "itime.h"
#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "foo.h"

#include "zmodem.hh"
#include "zmodem.h"

/* * * * * * * * * * * * *
 *	Function Prototypes  *
 * * * * * * * * * * * * */

#if defined(DEBUG_DUMPPACKET)
#include <stdio.h>
FILE*   fpPacket;
#endif  // defined(DEBUG_DUMPPACKET)

int    procheader (ZC *zc, TCHAR *name);
int    putsec     (ZC *zc, BYTE *buf, int n);

int    isvalid    (TCHAR c, int base);
TCHAR *stoi       (TCHAR *ptr, int *val, int base);
TCHAR *stol       (TCHAR *ptr, long *val, int base);
int    IsAnyLower (TCHAR *s);
long   getfree    (void);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * zmdm_rcv
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
USHORT zmdm_rcv(HSESSION h, int method, int attended, int single_file)
	{
	ZC				*zc = NULL;
	BOOL			still_trying = TRUE;
	BOOL			override = FALSE;
	int				nJmpVal = 0;
	int				xstatus;
	unsigned int	uiOldOptions;
	int				tvar;
	TCHAR			ch;
	XFR_Z_PARAMS	*pZ;
	#if defined(DEADWOOD)
	DWORD			nLen;
	#endif // defined(DEADWOOD)

#if defined(DEBUG_DUMPPACKET)
    fpPacket = fopen("zpacket.dbg", "a");
    assert(fpPacket);
    fputs("----- Starting Zmodem rcv -----\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)

	(void)&single_file;

	xstatus = TSC_NO_MEM;

	zc = malloc(sizeof(ZC));
	if (zc == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}
	memset(zc, 0, sizeof(ZC));

	zc->nMethod = method;	// Zmodem, or Zmodem crash recovery
	// This makes it easy to override some settings when
	// Zmodem crash recovery is selected.
	if (method == XF_ZMODEM_CR)
		{
		zc->fSavePartial = TRUE;			// Leave partial files around
		zc->ulOverride   = XFR_RO_ALWAYS;	// Always overwrite existing file
		}
	else
		{
		// Use default settings otherwise.
		//
		zc->fSavePartial = xfer_save_partial(h);
		zc->ulOverride = (unsigned long)0;
		}

	zc->hSession  = h;
	zc->hCom      = sessQueryComHdl(h);
	zc->secbuf	  = NULL;
	zc->fname	  = NULL;
	zc->our_fname = NULL;
	zc->z_crctab  = NULL;
	zc->z_cr3tab  = NULL;

	/* allocate space for large packets since we don't necessarily know what
	 *	we'll be getting.
	 */
	zc->secbuf = malloc(1025 * sizeof(TCHAR));
	if (zc->secbuf == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	zc->fname = malloc(FNAME_LEN * sizeof(TCHAR));
	if (zc->fname == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	zc->our_fname = malloc(FNAME_LEN * sizeof(TCHAR));
	if (zc->our_fname == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	#if defined(DEADWOOD)
	resLoadDataBlock(glblQueryDllHinst(),
					IDT_CSB_CRC_TABLE,
					&zc->z_crctab,
					&nLen);
	assert(nLen != 0);
	#else // defined(DEADWOOD)
	zc->z_crctab = usCrc16Lookup;
	#endif // defined(DEADWOOD)

	if (zc->z_crctab == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	#if defined(DEADWOOD)
	resLoadDataBlock(glblQueryDllHinst(),
					IDT_CRC_32_TAB,
					&zc->z_cr3tab,
					&nLen);
	assert(nLen != 0);
	#else // defined(DEADWOOD)
	zc->z_cr3tab = ulCrc32Lookup;
	#endif // defined(DEADWOOD)
	if (zc->z_cr3tab == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	xstatus = TSC_OK;

	if (xfer_set_comport(h, FALSE, &uiOldOptions) != TRUE)
		{
		goto done;
		}
	else
		{
		override = TRUE;
		}

	zmdm_retval (zc, TRUE, ZACK);

	zc->file_bytes = 0L;
	zc->real_bytes = 0L;
	zc->total_bytes = 0L;
	zc->actual_bytes = 0L;
	zc->nSkip = FALSE;
	zc->fh = NULL;
	zc->pstatus = zc->last_event = -4;
	zc->xfertimer = -1L;
	zc->nfiles = 0;
	zc->filen = 0;
	zc->filesize = -1L;
	zc->nbytes = -1L;
	zc->errors = 0;

	// Capture the current execution environment into the flagkey_buf buffer.
	// The Trow() function will later use it to restore the execution
	// environment (i.e., the state of all system registers and the instruction
	// counter.
	//
	nJmpVal = setjmp(zc->flagkey_buf);
	if (nJmpVal != 0)
		{
		if (nJmpVal == 4)
			{
			xstatus = TSC_DISK_FULL;
			zmdm_retval(zc, TRUE, ZFERR);
			}
		else
			{
			xstatus = TSC_USER_CANNED;
			zmdm_retval(zc, TRUE, ZCAN);
			}
		zc->xfertime = (long)interval(zc->xfertimer);
		stohdr(zc, 0L);
		zshhdr(zc, ZCAN, zc->Txhdr);
		canit(zc);
		if (zc->fh)
			xfer_close_rcv_file(h,
								zc->fh,
								xstatus,
								zc->fname,
								zc->our_fname,
								zc->fSavePartial,
								zc->basesize + zc->filesize,
								0);
		zc->fh = NULL;
		// zmdm_retval(zc, TRUE, ZABORT);  jkh, 2/12/95   see above
		goto done;
		}

	pZ = (XFR_Z_PARAMS *)xfer_get_params(zc->hSession, zc->nMethod);
	assert(pZ);

	if (pZ == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	zc->Zctlesc = pZ->nEscCtrlCodes;
	zc->Rxtimeout = pZ->nRetryWait;
	if (zc->Rxtimeout <= 0)
		{
		zc->Rxtimeout = 10;
		}
	zc->Rxtimeout *= 10;

	zc->do_init = TRUE; // Always start right up since we may be autostarted

	zc->tryzhdrtype = ZRINIT;

	if (tryz(zc) == ZFILE)
		{
		// tzset();

		if (zc->xfertimer == (-1L))
			{
			zc->xfertimer = (long)startinterval();
			}

		// Receive files with Z-modem protocol.
		//
		switch (xstatus = rzfiles(zc))
			{
			case OK:
				xstatus = TSC_OK;
				break;
			case ZABORT:
				xstatus = TSC_USER_CANNED;
				do {
					// purgeline(zc);
					ComRcvBufrClear(zc->hCom);
					Sleep(100);
				} while (mComRcvBufrPeek(zc->hCom, &ch) != 0);
				// } while (rdchk(h) != ERROR);

				/* we try to eat any characters until the other end quits */
				break;
			case RCDO:			/* Not too sure about this one */
            case ZCARRIER_LOST:
				xstatus = TSC_LOST_CARRIER;
				break;
			case ERROR:
				canit(zc);
				/* fall through */
			case ZMDM_VIRUS:
				do {
					// purgeline(zc);
					ComRcvBufrClear(zc->hCom);
					Sleep(100);
				} while (mComRcvBufrPeek(zc->hCom, &ch) != 0);
				// } while (rdchk(zc) != ERROR);

				/* fall thru to the default case */
			default:
				xstatus = zmdm_error(zc, xstatus);
				break;
			}
		}
done:

	zmdmr_progress(zc, TRANSFER_DONE);

	if (override)
		{
		xfer_restore_comport(h, uiOldOptions);
		}

	// Fool around with the return code to get a useful status return
	if ((tvar = zmdm_retval(zc, FALSE, 0)) != ZACK)
		// Retrieve last error message
		{
		if (tvar == ZMDM_VIRUS)
			{
			do {
				// purgeline(zc);
				ComRcvBufrClear(zc->hCom);
				Sleep(100);
			} while (mComRcvBufrPeek(zc->hCom, &ch) != 0);
			// } while (rdchk(zc) != ERROR);
			}
		xstatus = zmdm_error(zc, tvar);
		}

	if (xstatus != TSC_OK)
		{
		if (zc->fh)
			{
			xfer_close_rcv_file(h,
								zc->fh,
								xstatus,
								zc->fname,
								zc->our_fname,
								zc->fSavePartial,
								zc->basesize + zc->filesize,
								0);
			}
		}

	if (zc->secbuf != NULL)
		{
		free(zc->secbuf);
		zc->secbuf = NULL;
		}
	if (zc->fname != NULL)
		{
		free(zc->fname);
		zc->fname = NULL;
		}
	if (zc->our_fname != NULL)
		{
		free(zc->our_fname);
		zc->our_fname = NULL;
		}
	if (zc->z_crctab != NULL)
		{
		#if defined(DEADWOOD)
		resFreeDataBlock(h, zc->z_crctab);
		zc->z_crctab = NULL;
		#else // defined(DEADWOOD
		//
		// We don't need to free zc->z_crctab since it is pointing
		// to a static constant array. REV: 4/10/2002
		//
		zc->z_crctab = NULL;
		#endif // defined(DEADWOOD)
		}
	if (zc->z_cr3tab)
		{
		#if defined(DEADWOOD)
		resFreeDataBlock(h, zc->z_cr3tab);
		zc->z_cr3tab = NULL;
		#else // defined(DEADWOOD
		//
		// We don't need to free zc->z_cr3tab since it is pointing
		// to a static constant array. REV: 4/10/2002
		//
		zc->z_cr3tab = NULL;
		#endif // defined(DEADWOOD)
		}

	if (zc != NULL)
		{
		free(zc);
		zc = NULL;
		}

	xferMsgClose(h);

#if defined(DEBUG_DUMPPACKET)
    fputs("------- Ending Zmodem rcv -----\n", fpPacket);
    fclose(fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)

	return((USHORT)xstatus);
	}

/*----------------------------------------------------------------------+
 | getfree - Calculates the free bytes on the current file system.
 |			 ~0 means many free bytes (unknown).
 +----------------------------------------------------------------------*/
long getfree(void)
{
	return(~0L);	/* many free bytes ... */
}

/*----------------------------------------------------------------------+
 | tryz - Initialize for ZMODEM receive attempt, try to activate ZMODEM
 |		  sender.  Handles ZSINIT frame.  Returns ZFILE if ZMODEM filename
 |		  received, -1 on error, ZCOMPL if transaction finished, else 0.
 +----------------------------------------------------------------------*/
int tryz(ZC *zc)
{
	register int c;
	register int n;
	int x;
	int retrys;

	for ( n = 10; --n >= 0; )
		{
		/* Set buffer length (0) and capability flags */
		stohdr(zc, 0L);

		/* Do we need an option to set the block size ? */

		zc->Txhdr[ZF0] = CANFC32|CANFDX|CANOVIO /* |CANBRK */ ;
		if (zc->Zctlesc)
			zc->Txhdr[ZF0] |= TESCCTL;
		if (n <= 8)
			zc->do_init = TRUE;
		if (zc->do_init)
			zshhdr(zc, zc->tryzhdrtype, zc->Txhdr);
		if (zc->tryzhdrtype == ZSKIP)	/* Don't skip too far */
			zc->tryzhdrtype = ZRINIT;	/* CAF 8-21-87 */

		retrys = 25;

again:

		switch (x = xfer_user_interrupt(zc->hSession))
			{
			case XFER_ABORT:
				zmdmr_update(zc, ZCAN);
				longjmp(zc->flagkey_buf, 1);
				break;

			case XFER_SKIP:
				/* This MUST only happen while receiving */
				stohdr(zc, zc->filesize);
#if defined(DEBUG_DUMPPACKET)
                fputs("tryz: User skipped. ZRPOS\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
				zshhdr(zc, ZRPOS, zc->Txhdr);
				zc->nSkip = TRUE;
				zc->file_bytes = zc->filesize;
				break;

			default:
				break;
			}

		if (xfer_carrier_lost(zc->hSession))
			{
            zmdm_retval(zc, TRUE, ZCARRIER_LOST);
			return ZCARRIER_LOST;
			}

		switch (zgethdr(zc, zc->Rxhdr, 'R'))
			{
			case ZRQINIT:
				zc->do_init = TRUE;
				continue;
			case ZEOF:
				zc->do_init = TRUE;
				continue;
			case TIMEOUT:
				continue;
			case ZFILE:
				zc->zconv = zc->Rxhdr[ZF0];
				zc->zmanag = zc->Rxhdr[ZF1];
				zc->ztrans = zc->Rxhdr[ZF2];
				zc->tryzhdrtype = ZRINIT;
				c = zrdata(zc, zc->secbuf, 1024);
				/* mode(3);  TODO: figure out what this was supposed to do */
				if (c == GOTCRCW)
					return ZFILE;
				if (--retrys <= 0)
					{
					zmdm_retval(zc, TRUE, ZNAK);
					return ZNAK;
					}
				zshhdr(zc, ZNAK, zc->Txhdr);
				goto again;
			case ZSINIT:
				zc->Zctlesc = TESCCTL & zc->Rxhdr[ZF0];
				if (zrdata(zc, zc->Attn, ZATTNLEN) == GOTCRCW)
					{
					stohdr(zc, 1L);
					zshhdr(zc, ZACK, zc->Txhdr);
					goto again;
					}
				if (--retrys <= 0)
					{
					zmdm_retval(zc, TRUE, ZNAK);
					return ZNAK;
					}
				zshhdr(zc, ZNAK, zc->Txhdr);
				goto again;
			case ZFREECNT:
				stohdr(zc, getfree());
				zshhdr(zc, ZACK, zc->Txhdr);
				goto again;
			case ZCOMMAND:
				zmdm_retval(zc, TRUE, ZCOMMAND);
				return ZCOMMAND;
			case ZCOMPL:
				goto again;
			default:
				zc->do_init = TRUE;
				continue;
			case ZFIN:
				zc->xfertime = (long)interval(zc->xfertimer);
				ackbibi(zc);
				return ZCOMPL;
			case ZCAN:
				zmdm_retval(zc, TRUE, ZABORT);
				return ZCAN;
			}
		}
	zmdm_retval(zc, TRUE, TIMEOUT);
	return TIMEOUT;
	}

/*----------------------------------------------------------------------+
 | rzfiles - Receive 1 or more files with ZMODEM protocol.
 +----------------------------------------------------------------------*/
int rzfiles(ZC *zc)
	{
	register int c;
	register int d;

	for (;;)
		{
		switch (c = rzfile(zc))
			{
			case ZEOF:
			case ZSKIP:
				switch (d = tryz(zc))
					{
					case ZCOMPL:
						return OK;
					default:
						return d;
					case ZFILE:
						break;
					}
				continue;
			case ERROR:
			default:
				return c;
			}
		}
	}

/*----------------------------------------------------------------------+
 | rzfile - Receive single file with ZMODEM protocol.
 |			NOTE: Assumes file name frame is in secbuf.
 +----------------------------------------------------------------------*/
int rzfile(ZC *zc)
	{
	register int c;
	register int n;
	int x;
	int		fBlocking = FALSE;
	long	lBlockStart = 0L;

	zc->Eofseen = FALSE;

	zc->file_bytes = 0L;
	zc->real_bytes = 0L;

	if (procheader(zc, (TCHAR *)zc->secbuf) == ERROR)
		{
		return (zc->tryzhdrtype = ZSKIP);
		}

	n = 20;

	for (;;)
		{
		// If we're blocking and we've timed out, reset for another ZRPOS
		if( fBlocking && (long)interval( lBlockStart ) > 100L )
			fBlocking = FALSE;

		// If we're not blocking already, set up for ZRPOS
		if( ! fBlocking )
			{
			DbgOutStr( "Sending ZRPOS to %ld", zc->file_bytes, 0, 0, 0, 0 );
			stohdr(zc, zc->file_bytes);
#if defined(DEBUG_DUMPPACKET)
            fprintf(fpPacket, "rzfile: ZRPOS to %ld\n", zc->file_bytes);
#endif  // defined(DEBUG_DUMPPACKET)
			zshhdr(zc, ZRPOS, zc->Txhdr);

			fBlocking = 1;
			lBlockStart = (long)startinterval( );
			DbgOutStr("Now blocked at t=%lu",lBlockStart,0,0,0,0);
			}
nxthdr:
		switch (x = xfer_user_interrupt(zc->hSession))
			{
			case XFER_ABORT:
				zmdmr_update(zc, ZCAN);
				longjmp(zc->flagkey_buf, 1);
				break;

			case XFER_SKIP:
				/* This MUST only happen while receiving */
				stohdr(zc, zc->filesize);
#if defined(DEBUG_DUMPPACKET)
                fputs("rzfile: User skipped (1). ZRPOS\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
				zshhdr(zc, ZRPOS, zc->Txhdr);
				zc->nSkip = TRUE;
				zc->file_bytes = zc->filesize;
				break;

			default:
				break;
			}

		if (xfer_carrier_lost(zc->hSession))
			{
            zmdm_retval(zc, TRUE, ZCARRIER_LOST);
			return ZCARRIER_LOST;
			}

		switch (c = zgethdr(zc, zc->Rxhdr, 'R'))
			{
			default:
				if (--n < 0)		/* A little fix from Delrina */
					{
					/* return ERROR; */
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					zmdm_retval(zc, TRUE, c);
					return c;
					}
				continue;
            case ZCARRIER_LOST:
                zmdm_retval(zc, TRUE, ZCARRIER_LOST);
                return c;
			case ZNAK:
			case TIMEOUT:
				if ( --n < 0)
					{
					/* return ERROR; */
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					zmdm_retval(zc, TRUE, TIMEOUT);
					return c;
					}
				continue;			/* Another fix from Delrina */
			case ZFILE:
				if( fBlocking )
                    {
					DbgOutStr( "rzfile: ZFILE && fBlocking!\n", 0, 0, 0, 0, 0 );
                    }
				else
					zrdata(zc, zc->secbuf, 1024);
				continue;
			case ZEOF:
				if (rclhdr(zc->Rxhdr) !=  zc->file_bytes)
					{
					/*
					 * Ignore eof if it's at wrong place - force
					 *  a timeout because the eof might have gone
					 *  out before we sent our zrpos.
					 */
					goto nxthdr;
					}
				if (closeit(zc))
					{
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					zc->tryzhdrtype = ZFERR;
					/* return ERROR; */
					return ZEOF;
					}
				zmdmr_progress(zc, FILE_DONE);

				return c;
			case ERROR:	/* Too much garbage in header search error */
				if ( --n < 0)
					{
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					zmdm_retval(zc, TRUE, ERROR);
					return ERROR;
					}
				if( ! fBlocking )
					zmputs(zc, zc->Attn);
				continue;
			case ZSKIP:
				closeit(zc);
				zmdmr_progress(zc, FILE_DONE);

				return c;
			case ZDATA:
				if( ! fBlocking )
					{
					if( rclhdr(zc->Rxhdr) != zc->file_bytes)
						{
						// DbgOutStr( "rzfile: ZDATA: n=%d\n", n, 0, 0, 0, 0 );
						if ( --n < 0)
							{
							DbgOutStr("ZMODEM error %s %d", TEXT(__FILE__), __LINE__,0,0,0);
#if defined(DEBUG_DUMPPACKET)
                            fprintf(fpPacket, "rzfile: ZDATA pos = 0x%08lX vs. 0x%08lX\n",
                                rclhdr(zc->Rxhdr), zc->file_bytes);
#endif  // defined(DEBUG_DUMPPACKET)
							zmdm_retval(zc, TRUE, ZBADFMT);
							return ERROR;
							}
						zmputs(zc, zc->Attn);  continue;
						}
					}
				else
					{
					// Did sender finally respond to our ZRPOS?
					if( rclhdr(zc->Rxhdr) == zc->file_bytes )
						{
						// DbgOutStr("Now unblocked after %lu t-sec\n",interval(lBlockStart),0,0,0,0);
						fBlocking = FALSE;
						}
					else
						{
						// Read the buffer and toss it
						c = zrdata(zc, zc->secbuf, 1024);
						continue;
						}
					}
moredata:
				zmdmr_update(zc, ZDATA);

				switch (x = xfer_user_interrupt(zc->hSession))
					{
					case XFER_ABORT:
						zmdmr_update(zc, ZCAN);
						longjmp(zc->flagkey_buf, 1);
						break;

					case XFER_SKIP:
						/* This MUST only happen while receiving */
						stohdr(zc, zc->filesize);
#if defined(DEBUG_DUMPPACKET)
                        fputs("rzfile: User skipped (2). ZRPOS\n", fpPacket);
#endif  // defined(DEBUG_DUMPPACKET)
						zshhdr(zc, ZRPOS, zc->Txhdr);
						zc->nSkip = TRUE;
						zc->file_bytes = zc->filesize;
						break;

					default:
						break;
					}

				if (xfer_carrier_lost(zc->hSession))
					{
					DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					zmdm_retval(zc, TRUE, ZCARRIER_LOST);
					return ZCARRIER_LOST;
					}

				switch (c = zrdata(zc, zc->secbuf, 1024))
					{
					case ZCAN:
						zmdm_retval(zc, TRUE, ZABORT);
						return c;
					case ERROR:	/* CRC error */
						if ( --n < 0)
							{
							DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
							zmdm_retval(zc, TRUE, ERROR);
							return ERROR;
							}
						zmputs(zc, zc->Attn);
						continue;
					case TIMEOUT:
						if ( --n < 0)
							{
							/* return ERROR; */
							DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
							zmdm_retval(zc, TRUE, c);
							return c;
							}
						continue;
					case GOTCRCW:
						n = 20;
						putsec(zc, zc->secbuf, zc->Rxcount);
						zc->file_bytes += zc->Rxcount;
						zc->real_bytes += zc->Rxcount;
						zmdmr_update(zc, ZMDM_ACKED);
						zmdmr_progress(zc, 0);
						stohdr(zc, zc->file_bytes);
						zshhdr(zc, ZACK, zc->Txhdr);
						sendline(zc, &zc->stP, XON);
						goto nxthdr;
					case GOTCRCQ:
						n = 20;
						putsec(zc, zc->secbuf, zc->Rxcount);
						zc->file_bytes += zc->Rxcount;
						zc->real_bytes += zc->Rxcount;
						zmdmr_update(zc, ZMDM_ACKED);
						zmdmr_progress(zc, 0);
						stohdr(zc, zc->file_bytes);
						zshhdr(zc, ZACK, zc->Txhdr);
						goto moredata;
					case GOTCRCG:
						n = 20;
						putsec(zc, zc->secbuf, zc->Rxcount);
						zc->file_bytes += zc->Rxcount;
						zc->real_bytes += zc->Rxcount;
						zmdmr_progress(zc, 0);
						goto moredata;
					case GOTCRCE:
						n = 20;
						putsec(zc, zc->secbuf, zc->Rxcount);
						zc->file_bytes += zc->Rxcount;
						zc->real_bytes += zc->Rxcount;
						zmdmr_progress(zc, 0);
						goto nxthdr;
					}
			} /* switch */
		} /* end for */
	}

/*----------------------------------------------------------------------+
 | zmputs - Send a string to the modem, processing for \336 (sleep 1 sec)
 |			and \335 (break signal).
 +----------------------------------------------------------------------*/
void zmputs(ZC *zc, char *s)
	{
	register c;

	while (*s)
		{
		switch (c = *s++)
			{
			case '\336':
				Sleep(1000);
				continue;
			case '\335':
				/* TODO: put in a call to sendbreak */
				// sendbreak(h);
				continue;
			default:
				sendline(zc, &zc->stP, (UCHAR)c);
			}
		}
	}


/*----------------------------------------------------------------------+
 | IsAnyLower - Returns TRUE if string s has lower case letters.
 +----------------------------------------------------------------------*/
int IsAnyLower(char *s)
	{
	for ( ; *s; ++s)
		// Don't use this stuff in a Chicago DLL
		// if (islower(*s))
		if ((*s >= 'a') && (*s <= 'z'))
			return TRUE;
	return FALSE;
	}

/*----------------------------------------------------------------------+
 | closeit - Close the receive dataset, return OK or ERROR
 +----------------------------------------------------------------------*/
int closeit(ZC *zc)
{
	// struct utimbuf timep;
	int reason;
	XFR_PARAMS *pX;

	reason = TSC_COMPLETE;		/* TODO: Get the real reason */
	if (zc->nSkip)
		{
		reason = TSC_USER_SKIP;
		}

	if (xfer_close_rcv_file(zc->hSession,
							zc->fh,
							reason,
							zc->fname,
							zc->our_fname,
							zc->fSavePartial,
							0,
							0) == ERROR)
		{
		return ERROR;
		}
	zc->fh = NULL;

	zc->actual_bytes += zc->real_bytes;
	zc->real_bytes = 0L;
	zc->total_bytes += zc->file_bytes;
	zc->file_bytes = 0L;
	zc->filesize = 0L;

	zc->nSkip = FALSE;

	pX = (XFR_PARAMS *)0;
	xfrQueryParameters(sessQueryXferHdl(zc->hSession), (VOID **)&pX);
	if ((pX != (XFR_PARAMS *)0) && (pX->fUseDateTime))
		{
		if (zc->Modtime)
			{
			// BYTE acName[FNAME_LEN];
			// zc->Modtime += timezone; /* Convert from GMT to local timezone */
			// timep.actime = time(NULL);
			// timep.modtime = zc->Modtime;
			// CharToOem(zc->our_fname, acName);
			// utime(acName, (void FAR *)&timep);
			itimeSetFileTime(zc->our_fname, zc->Modtime);
			}
		}

	// Disable this, it needs conversion and we only ever got complaints
	// about it anyway
	//if ((zc->Filemode & S_IFMT) == S_IFREG)
	//	far_chmod(zc->our_fname, (07777 & zc->Filemode));

	return OK;
	}

/*----------------------------------------------------------------------+
 | ackbibi - Ack a ZFIN packet, let byegones be byegones
 +----------------------------------------------------------------------*/
void ackbibi(ZC *zc)
	{
	register int n;

	stohdr(zc, 0L);
	for (n = 3; --n >= 0; )
		{
		// purgeline(zc);
		ComRcvBufrClear(zc->hCom);
		zshhdr(zc, ZFIN, zc->Txhdr);
		// switch (readline(h, 100))
		switch (readline(zc, zc->Rxtimeout))		// Mobidem
			{
			case 'O':
				// readline(h, 1);    /* Discard 2nd 'O' */
				readline(zc, zc->Rxtimeout); /* Discard 2nd 'O' */	// Mobidem
				return;
			case RCDO:
				return;
			case TIMEOUT:
			default:
				break;
			}
		}
	}

/*----------------------------------------------------------------------+
 | isvalid
 +----------------------------------------------------------------------*/
int isvalid(char c, int base)
	{
	if (c < '0')
		return FALSE;
	switch (base)
	{
	case 8:
		if (c > '7')
			return FALSE;
		break;
	case 10:
		if (c > '9')
			return FALSE;
		break;
	case 16:
		if (c <= '9')
			return TRUE;
		// Don't use this stuff in a Chicago DLL
		// if (toupper(c) < 'A')
		//	return FALSE;
		//if (toupper(c) > 'F')
		//	return FALSE;
		if ((c >= 'a') && (c <= 'f'))
			break;
		if ((c >= 'A') && (c <= 'F'))
			break;
		return FALSE;
	}
	return TRUE;
}

/*----------------------------------------------------------------------+
 | ourspace -- replacement for isspace
 +----------------------------------------------------------------------*/
int ourspace(char c)
	{
	if (c == 0x20)
		return TRUE;
	if ((c >= 0x9) && (c <= 0xD))
		return TRUE;
	return FALSE;
	}

/*----------------------------------------------------------------------+
 | stoi - string to integer.
 +----------------------------------------------------------------------*/
char *stoi(char *ptr, int *val, int base)
	{
	int cnt;

	if (ptr == NULL)
		return NULL;
	// Don't do this in a Chicago DLL
	// while ((*ptr) && (isspace(*ptr)))
	while ((*ptr) && ourspace(*ptr))
		ptr++;
	cnt = 0;
	while ((*ptr) && (isvalid(*ptr, base)))
		{
		cnt *= base;
		cnt += (*ptr++ - '0');
		}
	*val = cnt;
	return ptr;
}

/*----------------------------------------------------------------------+
 | stol - string to long.
 +----------------------------------------------------------------------*/
char *stol(char *ptr, long *val, int base)
	{
	long cnt;

	if (ptr == NULL)
		return NULL;
	// Don't do this in a Chicago DLL
	// while ((*ptr) && (isspace(*ptr)))
	while ((*ptr) && (ourspace(*ptr)))
		ptr++;
	cnt = 0;
	while ((*ptr) && (isvalid(*ptr, base)))
		{
		cnt *= base;
		cnt += (*ptr++ - '0');
		}
	*val = cnt;
	return ptr;
}

/*----------------------------------------------------------------------+
 | procheader - Process incoming file information header.
 +----------------------------------------------------------------------*/
int procheader(ZC *zc, TCHAR *name)
	{
	int zRecover = FALSE;
	int lconv = 0;
	int file_err;
	register char *p;
	int serial_number;
	int files_remaining;
	long bytes_remaining;
	long our_size;
	LONG lOptions = 0;
	XFR_Z_PARAMS *pZ;
	struct st_rcv_open stRcv;
	TCHAR loc_fname[FNAME_LEN];

	StrCharCopy(zc->fname, name);

	#if !defined(NT_EDITION)
	//
	// Removed uppercasing the filename per MS request. REV: 11/12/2001
	//
	CharUpper(zc->fname);
	#endif //!defined(NT_EDITION)

	zc->Thisbinary = FALSE;

	zc->filesize = 0L;
	zc->Filemode = 0;
	zc->Modtime = 0L;
	serial_number = 0;
	files_remaining = -1;
	bytes_remaining = -1L;

	p = name + 1 + StrCharGetByteCount(name);
	if (*p)
		{	/* file coming from Unix or DOS system */
		if (*p)
			p = stol(p, &zc->filesize, 10);
		if (*p)
			p = stol(p, &zc->Modtime, 8);
		if (*p)
			p = stoi(p, &zc->Filemode, 8);
		if (*p)
			p = stoi(p, &serial_number, 10);
		if (*p)
			p = stoi(p, &files_remaining, 10);
		if (*p)
			p = stol(p, &bytes_remaining, 10);

		if ((zc->nfiles == 0) && (files_remaining != -1))
			{
			zc->nfiles = files_remaining;
			zmdmr_filecnt (zc, zc->nfiles);
			}

		if ((zc->nbytes == (-1L)) && (bytes_remaining != (-1L)))
			{
			zc->nbytes = bytes_remaining;
			zmdmr_totalsize (zc, zc->nbytes);
			}

		}
	else
		{	   /* File coming from CP/M system */
		for (p = zc->fname; *p; ++p)	   /* change / to _ */
			if ( *p == '/')
				*p = '_';

		if ( *--p == '.')		/* zap trailing period */
			*p = 0;
		}

	StrCharCopy(zc->our_fname, zc->fname);
	StrCharCopy(loc_fname, zc->fname);

	stRcv.pszSuggestedName = loc_fname;
	stRcv.pszActualName = zc->our_fname;
	stRcv.lFileTime = zc->Modtime;

	xfer_build_rcv_name(zc->hSession, &stRcv);

	//zc->ssMch = stRcv.ssmchVscanHdl;

	lconv = 0;

	pZ = (XFR_Z_PARAMS *)xfer_get_params(zc->hSession, zc->nMethod);
	assert(pZ);

	if (pZ)
		{
		switch (pZ->nCrashRecRecv)
			{
			case ZP_CRR_ALWAYS:
				lconv = ZCRECOV;
				break;
			case ZP_CRR_NEVER:
				if ((lconv = zc->zconv) == ZCRECOV)
					lconv = 0;
				break;
			case ZP_CRR_NEG:
			default:
				lconv = zc->zconv;
				break;
			}
		}

	switch (lconv)
	{
	case ZCNL:
		zc->Thisbinary = FALSE;
		break;
	case ZCRECOV:
		/*
		 * This is a little complicated.  To do recovery, we need to check
		 * the following:
		 * 1. Does the file exist on OUR side.
		 * 2. Has the sender sent over a file size.
		 * 3. Is the size sent greater than the size of OUR file.
		 * If so, we fudge around a little with the file and let things rip.
		 */
		zRecover = TRUE;

		our_size = 0L;
		if (zRecover)
			{
			if (GetFileSizeFromName(stRcv.pszActualName, &our_size))
				zRecover = TRUE;
			else
				zRecover = FALSE;
			}

		if (zRecover)
			{
			/* Has the sender sent over a file size ? */
			if (zc->filesize <= 0)
				zRecover = FALSE;
			}

		if (zRecover)
			{
			/* This gets set up above after checking for existance */
			if (our_size != 0L)
				{
				if (our_size < zc->filesize)
					{
					/*
					 * We do this in the vain hope of avoiding problems with
					 * files terminated by ^Z and padded last blocks
					 *
					 * Given that we don't know if it is necessary, it might be
					 * possible to eliminate it
					 */
					our_size = (our_size - 1) & ~255L;
					}
				else
					{
                    return ERROR;
					//zRecover = FALSE;
					}
				}
			else
				{
				zRecover = FALSE;
				}
			}

		if (zRecover)
			{
			zc->file_bytes = our_size;
			}

		/* FALL THROUGH */
	case ZCBIN:
	default:
		zc->Thisbinary = TRUE;
		break;
	}

	if (zRecover)
		{
		lOptions = XFR_RO_APPEND;
		}
	else if (pZ && pZ->nFileExists == ZP_FE_SENDER)
		{
		switch (zc->zmanag & ZMMASK)
			{
			case ZMNEWL:
				/* TODO: complete this option */
				lOptions = 0;
				break;
			case ZMCRC:
				/* TODO: complete this option */
				lOptions = 0;
				break;
			case ZMAPND:
				lOptions = XFR_RO_APPEND;
				break;
			case ZMCLOB:
				lOptions = XFR_RO_ALWAYS;
				break;
			case ZMNEW:
				lOptions = XFR_RO_NEWER;
				break;
			case ZMDIFF:
				/* TODO: complete this option */
				lOptions = 0;
				break;
			case ZMPROT:
				lOptions = XFR_RO_NEVER;
				break;
			default:
				break;
			}
		}
	else
		{
		lOptions = zc->ulOverride;
		}

	StrCharCopy(zc->our_fname, zc->fname);
	StrCharCopy(loc_fname, zc->fname);

	stRcv.pszSuggestedName = loc_fname;
	stRcv.pszActualName = zc->our_fname;
	stRcv.lFileTime = zc->Modtime;

	/* TODO: pick up override options as necessary, like above */
	file_err = xfer_open_rcv_file(zc->hSession, &stRcv, lOptions);

	if (file_err != 0)
		{
		DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
		switch (file_err)
			{
        case -8:
            zmdm_retval(zc, TRUE, ZMDM_INUSE);
            break;
		case -6:            // File was rejected unconditionally
			zmdm_retval(zc, TRUE, ZMDM_REFUSE);
			break;
		case -5:			// Were unable to create needed directories
			zmdm_retval(zc, TRUE, ZFERR);
			break;
		case -4:  			// No date, time supplied when required
			zmdm_retval(zc, TRUE, ZFERR);
			break;
		case -3:			// File could not be saved
			zmdm_retval(zc, TRUE, ZFERR);
			break;
		case -2:  			// File was rejected due to date
			zmdm_retval(zc, TRUE, ZMDM_OLDER);
			break;
		case -1:			// Read/Write error occured
		default:
			zmdm_retval(zc, TRUE, ZFERR);
			break;
			}

		zc->total_bytes += zc->filesize;
		zc->filen += 1;
		zmdmr_newfile (zc, zc->filen, zc->fname, stRcv.pszActualName);
		return ERROR;
		}
	else
		{
		zmdm_retval(zc, TRUE, ZACK);
		}

	zc->fh = stRcv.bfHdl;
	zc->basesize = stRcv.lInitialSize;

	if (zRecover)
		{
        //jmh 04-02-96 Sure we opened it in "append" mode (which really
        // opens the file for write and seeks to the end), but we
        // might actually seek to a spot just before that due to the
        // possible padding of the file with ^Z's. 
        //
		fio_seek(zc->fh, zc->file_bytes, FIO_SEEK_SET);
		}

	zc->filen += 1;

	zmdmr_newfile (zc, zc->filen, zc->fname, stRcv.pszActualName);
	zmdmr_filesize(zc, zc->filesize);

	return OK;
	}

/*----------------------------------------------------------------------+
 | putsec - Putsec writes the n characters of buf to receive file.
 |			If not in binary mode, carriage returns, and all characters
 |			starting with CPMEOF are discarded.
 +----------------------------------------------------------------------*/
int putsec(ZC *zc, BYTE *buf, int n)
	{
	register BYTE *p;
	register int ii;

	if (n == 0)
		return OK;

	if (zc->Thisbinary)
		{
		// jkh, 2/11 Added error check
		if (fio_write(buf, 1, n, zc->fh) != n)
			longjmp(zc->flagkey_buf, 4);
		}
	else
		{
		if (zc->Eofseen)
			return OK;
		ii = FALSE;
		for (p=buf; --n>=0; ++p )
			{
			if ( *p == '\n')
				{
				/*
				 * If we get a <NL> that wasn't preceeded by a <CR>
				 */
				if (ii == FALSE)
					fio_putc('\r', zc->fh);
				}

			ii = (*p == '\r');

			if (*p == CPMEOF)
				{
				zc->Eofseen=TRUE;
				return OK;
				}
			fio_putc(*p, zc->fh);
			}
		}
	return OK;
	}

/* *********** end of zmdm_rcv.c *********** */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\x_xy_dlg.c ===
/*	File: C:\WACKER\xfer\x_xy_dlg.c (Created: 17-Jan-1993)
 *	created from:
 *	File: C:\WACKER\TDLL\genrcdlg.c (Created: 16-Dec-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 7/12/02 8:19a $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <tdll\stdtyp.h>
#include <tdll\assert.h>
#include <tdll\mc.h>

#include "xfer.h"
#include "xfer.hh"

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	LPARAM lPar;
	};

typedef	struct stSaveDlgStuff SDS;

#define AUTO_ERRCHK 	101
#define CRC_ERRCHK		102
#define CSUM_ERRCHK 	103

#define CMPRS_ON		105
#define CMPRS_OFF		106

#define BYTE_SECONDS	110
#define PACKET_WAIT 	112
#define PACKET_SECONDS	108

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	Generic Dialog
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
BOOL CALLBACK XandYmodemParamsDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
#if defined(UPPER_FEATURES)
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;
	XFR_XY_PARAMS *pP;


	switch (wMsg)
		{
	case WM_INITDIALOG:
		{
		RECT rc;
		DWORD dw;
		int nSize;
		HWND hwndUpDown;
		HWND hwndCtl;

		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			}

		pS->lPar = lPar;
		pP = (XFR_XY_PARAMS *)lPar;

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		hwndCtl = GetDlgItem(hDlg, AUTO_ERRCHK);
		if (hwndCtl)
			{
			switch(pP->nErrCheckType)
				{
				case XP_ECP_CRC:
					nSize = CRC_ERRCHK;
					break;

				case XP_ECP_CHECKSUM:
					nSize = CSUM_ERRCHK;
					break;

				case XP_ECP_AUTOMATIC:
				default:
					nSize = AUTO_ERRCHK;
					break;
				}
			SendMessage(GetDlgItem(hDlg, nSize),
						BM_SETCHECK, TRUE, 0L);
			}

		hwndCtl = GetDlgItem(hDlg, CMPRS_ON);
		if (hwndCtl)
			{
			nSize = CMPRS_OFF;
			SendMessage(GetDlgItem(hDlg, nSize),
						BM_SETCHECK, TRUE, 0L);
			}

		GetClientRect(GetDlgItem(hDlg, PACKET_SECONDS), &rc);
		nSize = rc.top - rc.bottom;
		dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
		dw |= UDS_ALIGNRIGHT;
		dw |= UDS_ARROWKEYS;
		dw |= UDS_SETBUDDYINT;
		hwndUpDown = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nSize / 3) * 2,/* width */
								nSize,			/* height */
								hDlg,			/* parent window */
								PACKET_SECONDS + 1,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, PACKET_SECONDS),
								60,				/* upper limit */
								1,				/* lower limit */
								pP->nPacketWait);/* starting position */
		assert(hwndUpDown);

		GetClientRect(GetDlgItem(hDlg, BYTE_SECONDS), &rc);
		nSize = rc.top - rc.bottom;
		dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
		dw |= UDS_ALIGNRIGHT;
		dw |= UDS_ARROWKEYS;
		dw |= UDS_SETBUDDYINT;
		hwndUpDown = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nSize / 3) * 2,/* width */
								nSize,			/* height */
								hDlg,			/* parent window */
								BYTE_SECONDS + 1,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, BYTE_SECONDS),
								60,				/* upper limit */
								1,				/* lower limit */
								pP->nByteWait);/* starting position */
		assert(hwndUpDown);

		GetClientRect(GetDlgItem(hDlg, PACKET_WAIT), &rc);
		nSize = rc.top - rc.bottom;
		dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
		dw |= UDS_ALIGNRIGHT;
		dw |= UDS_ARROWKEYS;
		dw |= UDS_SETBUDDYINT;
		hwndUpDown = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nSize / 3) * 2,/* width */
								nSize,			/* height */
								hDlg,			/* parent window */
								PACKET_WAIT + 1,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, PACKET_WAIT),
								25,				/* upper limit */
								1,				/* lower limit */
								pP->nNumRetries);/* starting position */
		assert(hwndUpDown);
		}

		break;

	case WM_DESTROY:
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);

			if (pS)
				{
				/*
				 * Do whatever saving is necessary
				 */

				pP = (XFR_XY_PARAMS *)pS->lPar;

				if (pP)
					{
					BOOL nTranslated = FALSE;
					int  nVal;

					nVal = XP_ECP_AUTOMATIC;

					if (GetDlgItem(hDlg, AUTO_ERRCHK))
						{
						if (IsDlgButtonChecked(hDlg, AUTO_ERRCHK)  == BST_CHECKED)
							{
							nVal = XP_ECP_AUTOMATIC;
							}
						else if (IsDlgButtonChecked(hDlg, CRC_ERRCHK) == BST_CHECKED)
							{
							nVal = XP_ECP_CRC;
							}
						else if (IsDlgButtonChecked(hDlg, CSUM_ERRCHK) == BST_CHECKED)
							{
							nVal = XP_ECP_CHECKSUM;
							}
						}

					pP->nErrCheckType = nVal;

					// TODO If we add compression, then add option here.
					//
					nTranslated = TRUE;

					if (GetDlgItem(hDlg, CMPRS_ON))
						{
						nTranslated = (IsDlgButtonChecked(hDlg, CMPRS_ON) == BST_CHECKED)
						}
					//pP->? = nVal;

					nVal = GetDlgItemInt(hDlg, PACKET_SECONDS, &nTranslated, TRUE);
					if (nTranslated && (nVal < 0 || nVal > 60))
						{
						nVal = 20;
						}
					pP->nPacketWait = nVal;

					nVal = GetDlgItemInt(hDlg, BYTE_SECONDS, &nTranslated, TRUE);
					if (nTranslated && (nVal < 0 || nVal > 60)))
						{
						nVal = 5;
						}
					pP->nByteWait = nVal;

					nVal = GetDlgItemInt(hDlg, PACKET_WAIT, &nTranslated, TRUE);
					if (nTranslated && (nVal < 0 || nVal > 25)))
						{
						nVal = 10;
						}
					pP->nNumRetries = nVal;

					}
				else
					{
					assert(FALSE);
					MessageBox(hDlg, "Invalid transfer protocol", NULL, MB_OK);
					}

				/* Free the storeage */
				free(pS);
				pS = (SDS *)0;
				}

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

#endif
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\x_zm_dlg.c ===
/*	File: C:\WACKER\XFER\x_zm_dlg.c (Created: 17-Dec-1993)
 *	created from:
 *	File: C:\HA5G\ha5g\genrcdlg.c (Created: 12-Sep-1990)
 *
 *	Copyright 1990,1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/15/02 4:40p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <term\res.h>
#include <tdll\stdtyp.h>
#include <tdll\assert.h>
#include <tdll\mc.h>

#include "xfer.h"
#include "xfer.hh"


#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	LPARAM lPar;
	HWND hwndWaitUpDown;
	};

typedef struct stSaveDlgStuff SDS;

/* These are the control ID numbers */

#define	AUTOSTART_CHECK			102

#define	USE_SENDER_PB			104
#define	USE_LOCAL_PB			105

#define	REC_NEGOTIATE_PB		107
#define	REC_NEVER_PB			108
#define	REC_ALWAYS_PB			109

#define	AO_COMBO				112

#define	SEND_NEGOTIATE_PB		114
#define	SEND_ONE_TIME_PB		115
#define	SEND_ALWAYS_PB			116

#define	STREAMING_PB			119
#define	WINDOWED_PB				120
#define	WINDOW_COMBO			121

#define	PACKET_COMBO			124

#define	WAIT_ROCKER				130
#define	ROCKER_ID				131
#define	WMAX					100

#define	BIT_16_PB				127
#define	BIT_32_PB				128

#define	EOL_PB					132

#define	ESC_CODE_PB				133

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ZmodemParamsDlg
 *
 * DESCRIPTION:
 *	This function is called to allow the user to modify the ZMODEM transfer
 *	protocol parameters.
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
BOOL CALLBACK ZmodemParamsDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
#if defined(UPPER_FEATURES)
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	int		nLoop;
	RECT    rc;
	DWORD	dw;
	SDS    *pD;
	XFR_Z_PARAMS *pZ;


	switch (wMsg)
		{
	case WM_INITDIALOG:
		/* Save the parameter block for the exit path */
		pD = (SDS *)malloc(sizeof(SDS));
		if (pD == (SDS *)0)
			{
			/* Error, bail out, pull rip cord */
			/* TODO: decide if we need an error message */
			EndDialog(hDlg, FALSE);
			}

		pD->lPar = lPar;
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pD);

		/* Get the parameter block to use now*/
		pZ = (XFR_Z_PARAMS *)lPar;

		/*
		 * Do the receiving stuff
		 */
		SendMessage(GetDlgItem(hDlg, AUTOSTART_CHECK),
					BM_SETCHECK, pZ->nAutostartOK, 0L);

		if (pZ->nFileExists == ZP_FE_SENDER)
			SendMessage(GetDlgItem(hDlg, USE_SENDER_PB),
						BM_SETCHECK, 1, 0L);
		else
			SendMessage(GetDlgItem(hDlg, USE_LOCAL_PB),
						BM_SETCHECK, 1, 0L);

		switch (pZ->nCrashRecRecv)
			{
			default:
			case ZP_CRR_NEG:
				SendMessage(GetDlgItem(hDlg, REC_NEGOTIATE_PB),
							BM_SETCHECK, 1, 0L);
				break;
			case ZP_CRR_NEVER:
				SendMessage(GetDlgItem(hDlg, REC_NEVER_PB),
							BM_SETCHECK, 1, 0L);
				break;
			case ZP_CRR_ALWAYS:
				SendMessage(GetDlgItem(hDlg, REC_ALWAYS_PB),
							BM_SETCHECK, 1, 0L);
				break;
			}

		/*
		 * Do the sending stuff
		 */

		for (nLoop = 0; nLoop < 8; nLoop += 1)
			{
			TCHAR acStr[64];

			LoadString(glblQueryDllHinst(),
						IDS_TM_SD_ONE + nLoop,
						acStr,
						sizeof(acStr) / sizeof(TCHAR));

			SendMessage(GetDlgItem(hDlg, AO_COMBO),
						CB_INSERTSTRING,
						(UINT)nLoop,
						(LONG)acStr);
			}
		SendMessage(GetDlgItem(hDlg, AO_COMBO),
					CB_SETCURSEL,
					pZ->nOverwriteOpt - 1,
					0L);

		if (pZ->nCrashRecSend == ZP_CRS_NEG)
			SendMessage(GetDlgItem(hDlg, SEND_NEGOTIATE_PB),
						BM_SETCHECK, 1, 0L);
		else
			SendMessage(GetDlgItem(hDlg, SEND_ALWAYS_PB),
						BM_SETCHECK, 1, 0L);

		/*
		 * Do the generic stuff
		 */
		for (nLoop = 0; nLoop < 16; nLoop += 1)
			{
			BYTE acBuffer[16];

			wsprintf(acBuffer, (LPSTR)"%d K", nLoop + 1);
			SendMessage(GetDlgItem(hDlg, WINDOW_COMBO),
						CB_INSERTSTRING,
						(UINT)nLoop,
						(LONG)((LPSTR)acBuffer));
			}
		SendMessage(GetDlgItem(hDlg, WINDOW_COMBO),
					CB_SETCURSEL, pZ->nWinSize, 0L);

		if (pZ->nXferMthd == ZP_XM_STREAM)
			{
			SendMessage(GetDlgItem(hDlg, STREAMING_PB),
						BM_SETCHECK, 1, 0L);
			EnableWindow(GetDlgItem(hDlg, WINDOW_COMBO), FALSE);
			}
		else
			{
			SendMessage(GetDlgItem(hDlg, WINDOWED_PB),
						BM_SETCHECK, 1, 0L);
			}

		for (nLoop = 0; nLoop < 6; nLoop += 1)
			{
			BYTE acBuffer[16];

			wsprintf(acBuffer, (LPSTR)"%d", (1 << (nLoop + 5)));
			SendMessage(GetDlgItem(hDlg, PACKET_COMBO),
						CB_INSERTSTRING,
						(UINT)nLoop,
						(LONG)((LPSTR)acBuffer));
			}
		SendMessage(GetDlgItem(hDlg, PACKET_COMBO),
					CB_SETCURSEL, pZ->nBlkSize, 0L);

		// SetDlgItemInt(hDlg, WAIT_ROCKER, pZ->nRetryWait, FALSE);
		GetClientRect(GetDlgItem(hDlg, WAIT_ROCKER), &rc);
		nLoop = rc.top - rc.bottom;
		dw = WS_CHILD | WS_BORDER | WS_VISIBLE;
		dw |= UDS_ALIGNRIGHT;
		dw |= UDS_ARROWKEYS;
		dw |= UDS_SETBUDDYINT;
		pD->hwndWaitUpDown = CreateUpDownControl(
								dw,				/* create window flags */
								rc.right,		/* left edge */
								rc.top,			/* top edge */
								(nLoop / 3) * 2,/* width */
								nLoop,			/* height */
								hDlg,			/* parent window */
								ROCKER_ID,
								(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
								GetDlgItem(hDlg, WAIT_ROCKER),
								WMAX,			/* upper limit */
								1,				/* lower limit */
								pZ->nRetryWait);/* starting position */
		assert(pD->hwndWaitUpDown);

#if 0
		/* Do we still use rockers ? */
		SendMessage(GetDlgItem(hDlg, WAIT_ROCKER),
					RS_SETMIN,
					0, (LONG)1);
		SendMessage(GetDlgItem(hDlg, WAIT_ROCKER),
					RS_SETMAX,
					0, (LONG)WMAX);
		SendMessage(GetDlgItem(hDlg, WAIT_ROCKER),
					RS_SETVALUE,
					0, (LONG)wFlag);
#endif

		if (pZ->nCrcType == ZP_CRC_32)
			SendMessage(GetDlgItem(hDlg, BIT_32_PB),
						BM_SETCHECK, 1, 0L);
		else
			SendMessage(GetDlgItem(hDlg, BIT_16_PB),
						BM_SETCHECK, 1, 0L);

		if (pZ->nEolConvert)
			SendMessage(GetDlgItem(hDlg, EOL_PB),
						BM_SETCHECK, 1, 0L);

		if (pZ->nEscCtrlCodes)
			SendMessage(GetDlgItem(hDlg, ESC_CODE_PB),
						BM_SETCHECK, 1, 0L);
		break;

	case WM_DESTROY:
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pD = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			assert(pD);

			pZ = (XFR_Z_PARAMS *)pD->lPar;
			assert(pZ);
			/*
			 * TODO: decide how we are going to handle confirmable changes
			 */

			/*
			 * Do the receive stuff
			 */
			pZ->nAutostartOK = (IsDlgButtonChecked(hDlg, AUTOSTART_CHECK) == BST_CHECKED);

			pZ->nFileExists = ZP_FE_DLG;
			if (IsDlgButtonChecked(hDlg, USE_SENDER_PB) == BST_CHECKED)
				{
				pZ->nFileExists = ZP_FE_SENDER;
				}

			if (IsDlgButtonChecked(hDlg, REC_NEGOTIATE_PB) == BST_CHECKED)
				{
				pZ->nCrashRecRecv = ZP_CRR_NEG;
				}
			else if (IsDlgButtonChecked(hDlg, REC_NEVER_PB) == BST_CHECKED)
				{
				pZ->nCrashRecRecv = ZP_CRR_NEVER;
				}
			else
				{
				pZ->nCrashRecRecv = ZP_CRR_ALWAYS;
				}

			/*
			 * Do the send stuff
			 */
			pZ->nOverwriteOpt = (LONG)SendMessage(GetDlgItem(hDlg, AO_COMBO),
										CB_GETCURSEL, 0, 0L);
			if (pZ->nOverwriteOpt == CB_ERR)
				{
				pZ->nOverwriteOpt = 1;
				}
			else
				{
				pZ->nOverwriteOpt += 1;			/* Zero vs. one base list */
				}

			pZ->nCrashRecSend = ZP_CRS_ALWAYS;
			if (IsDlgButtonChecked(hDlg, SEND_NEGOTIATE_PB) == BST_CHECKED)
				{
				pZ->nCrashRecSend = ZP_CRS_NEG;
				}
			else if (IsDlgButtonChecked(hDlg, SEND_ONE_TIME_PB) == BST_CHECKED)
				{
				pZ->nCrashRecSend = ZP_CRS_ONCE;
				}

			/*
			 * Do the generic stuff
			 */
			pZ->nWinSize = (LONG)SendMessage(GetDlgItem(hDlg, WINDOW_COMBO),
										CB_GETCURSEL, 0, 0L);
			if (pZ->nWinSize == CB_ERR)
				{
				pZ->nWinSize = 1;
				/* TODO: check the format */
				}

			if (IsDlgButtonChecked(hDlg, STREAMING_PB) == BST_CHECKED)
				{
				pZ->nXferMthd = ZP_XM_STREAM;
				}
			else
				{
				pZ->nXferMthd = ZP_XM_WINDOW;
				}

			pZ->nBlkSize = (LONG)SendMessage(GetDlgItem(hDlg, PACKET_COMBO),
										CB_GETCURSEL, 0, 0L);
			if (pZ->nBlkSize == CB_ERR)
				{
				/* TODO: check the format */
				pZ->nBlkSize = 1;
				}

			if (IsDlgButtonChecked(hDlg, BIT_32_PB) == BST_CHECKED)
				{
				pZ->nCrcType = ZP_CRC_32;
				}
			else
				{
				pZ->nCrcType = ZP_CRC_16;
				}

			/* TODO: remember that this used to be a rocker */
			pZ->nRetryWait = GetDlgItemInt(hDlg, WAIT_ROCKER, NULL, FALSE);
			if (pZ->nRetryWait < 5)
				pZ->nRetryWait = 5;
			if (pZ->nRetryWait > 100)
				pZ->nRetryWait = 100;

			pZ->nEolConvert = (IsDlgButtonChecked(hDlg, EOL_PB) == BST_CHECKED);

			pZ->nEscCtrlCodes = (IsDlgButtonChecked(hDlg, ESC_CODE_PB) == BST_CHECKED);

			free(pD);
			pD = (SDS *)0;
			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			/* Not much to do except free the memory */
			pD = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			free(pD);
			pD = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		case STREAMING_PB:
			if (IsDlgButtonChecked(hDlg, STREAMING_PB) == BST_CHECKED)
				{
				EnableWindow(GetDlgItem(hDlg, WINDOW_COMBO), FALSE);
				}
			break;

		case WINDOWED_PB:
			if (IsDlgButtonChecked(hDlg, WINDOWED_PB) == BST_CHECKED)
				{
				EnableWindow(GetDlgItem(hDlg, WINDOW_COMBO), TRUE);
				}
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

#endif
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\zmodem.hh ===
/*
 * xmodem.hh -- Include file for ZMODEM private stuff
 *
 * Copyright 1989 by Hilgraeve Inc. -- Monroe, MI
 * All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 7/12/02 8:20a $
 */

// These constants are used to turn on various types of debug display
// #define DEBUG_DUMPPACKET    // Log bad packet contents to a file

#if defined(ERROR)
#undef	ERROR
#endif
#if defined(CAN)
#undef	CAN
#endif

#define OK				0
#define FALSE			0
#define TRUE			1
#if defined(ERROR)
#undef	ERROR
#endif
#define ERROR		  (-1)
#define FILE_DONE		1
#define TRANSFER_DONE	2

/*
 * Max value for HOWMANY is 255.
 *   A larger value reduces system overhead but may evoke kernel bugs.
 *   133 corresponds to an XMODEM/CRC sector
 */
#ifndef HOWMANY
#define HOWMANY 133
#endif

/* Ward Christensen / CP/M parameters - Don't change these! */
#define ENQ 005
#define CAN ('X'&037)
#define XOFF ('s'&037)
#define XON ('q'&037)
#define SOH 1
#define STX 2
#define EOT 4
#define ACK 6
#define NAK 025
#define CPMEOF 032
#define WANTCRC 0103	/* send C not NAK to get crc not checksum */
#define TIMEOUT (-2)
#define RCDO (-3) /* Not too sure about this one */
#define ZCARRIER_LOST (-4)
#define ZFULLDISK (-5)
#define ERROFFSET 5
#define ERRORMAX 5
#define RETRYMAX 5
#define WCEOT (-10)
//#define PATHLEN 257	/* ready for 4.2 bsd ? */
#define PATHLEN MAX_PATH
#define UNIXFILE 0xF000	/* The S_IFMT file mask bit for stat */

/* Parameters for ZSINIT frame */

#define ZATTNLEN 32	/* Max length of attention string */

/* Control structure, allocated during transfers to hold control variables */
struct z_mdm_cntrl
	{
	HSESSION				hSession;			/* in case we actually need this */
	HCOM					hCom;				/* derived from above */

	int						nMethod;			/* Zmodem, or Zmodem wiht crash recovery? */
	int						fSavePartial;		/* Save partially received files? */
	unsigned long			ulOverride;			/* Override "file exists" overwrite options? */

	long					real_bytes;			/* real number of bytes, not virtual number */
	long					file_bytes;			/* number of bytes processed in current file */
	long					total_bytes;		/* number of bytes total in previous files */
	long					actual_bytes;		/* previous value includes skipped files */
	int						nSkip;				/* true if skipping a file */
	void					*flagkey;			/* used for detecting the user abort key */
	jmp_buf					flagkey_buf;		/* used for long jump after user abort */
	jmp_buf					intrjmp;
	ST_IOBUF				*fh;				/* handle for the current file */
	long					basesize;			/* used when appending to a file */
	long					xfertimer;			/* used for timing the transfers */
	long					xfertime;			/* ditto */
	int						nfiles;				/* total number of files to transfer */
	int						filen;				/* number of the current file */
	long					filesize;			/* size of the current file */
	long					nbytes;				/* total number of bytes to transfer */
	long					Rxtimeout;			/* Tenths of a second to wait for something */
	const long				*z_cr3tab; 			/* pointer to 32 bit checksum table */
	const unsigned short	*z_crctab;			/* pointer to 16 bit checksum table */
	int						Rxframeind; 		/* ZBIN ZBIN32, or ZHEX type of frame received */
	int						Rxtype; 			/* Type of header received */
	int						Rxcount;			/* Count of data bytes received */
	char					Rxhdr[4];			/* Received header */
	char					Txhdr[4];			/* Transmitted header */
	long					Rxpos; 				/* Received file position */
	long					Txpos; 				/* Transmitted file position */
	int						Txfcs32; 			/* TRUE means send binary frames with 32 bit FCS */
	int						Crc32t; 			/* Display flag indicating 32 bit CRC being sent */
	int						Crc32;				/* Display flag indicating 32 bit CRC being received */
	char					Attn[ZATTNLEN+1];	/* Attention string rx sends to tx on err */
	int						lastsent;			/* Last char we sent */
	int						Not8bit; 			/* Seven bits seen on header */
	long					displayed_time;

	int						Zctlesc;
	int						Zrwindow;
	BOOL					Eofseen;
	int						tryzhdrtype;
	BOOL					Thisbinary;
	int						Filemode;
	long					Modtime;
	int						do_init;
	TCHAR					zconv;				/* ZMODEM file conversion request */
	TCHAR					zmanag;				/* ZMODEM file management request */
	TCHAR					ztrans;				/* ZMODEM file transport request */
	TCHAR					*secbuf;
	TCHAR					*fname;
	TCHAR					*our_fname;

	stFB					stP;				/* used in foo com functions */

	TCHAR					*txbuf;
	int						Filesleft;
	long					Totalleft;
	int						blklen;
	int						blkopt;				/* do we override zmodem block length */
	int						Beenhereb4;
	BOOL					Wantfcs32;			/* Do we want 32 bit crc			   */
	int						Rxflags;
	unsigned				Rxbuflen;			/* receiver maximum buffer length */
	unsigned				Txwindow;
	unsigned				Txwcnt;				/* counter used to space ack requests */
	unsigned				Txwspac;			/* space between ZCRCQ requests */
	char					Myattn[1];
	int						errors;
	int						s_error;
	int						pstatus;
	int						last_event;

	int						Lskipnocor;
	long					Lastsync;			/* last offset to which we got a ZRPOS */
	long					Lrxpos;				/* receivers last reported offset */
	};

typedef struct z_mdm_cntrl ZC;

#define updcrc(x,cp,crc) (x->z_crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)
#define UPDC32(x,b,c) (x->z_cr3tab[((int)c ^ b) & 0xff] ^ ((c >> 8) & 0x00FFFFFF))

/* from zmdm.c */

void zsbhdr		(ZC *zc, int type, BYTE *hdr);
void zsbh32		(ZC *zc, BYTE *hdr, int type);
void zshhdr		(ZC *zc, int type, BYTE *hdr);
void zsdata		(ZC *zc, BYTE *buf, int length, int frameend);
void zsda32		(ZC *zc, BYTE *buf, int length, int frameend);

int  zrdata		(ZC *zc, BYTE *buf, int length);
int  zrdat32	(ZC *zc, BYTE *buf, int length);
int  zgethdr	(ZC *zc, BYTE *hdr, int eflag);
int  zrbhdr		(ZC *zc, BYTE *hdr, int eflag);
int  zrbhdr32 	(ZC *zc, BYTE *hdr, int eflag);
int  zrhhdr		(ZC *zc, BYTE *hdr, int eflag);

void zputhex	(ZC *zc, int c);
void zsendline	(ZC *zc, int c);
int  zgethex	(ZC *zc);
int  zgeth1		(ZC *zc);
int  zdlread	(ZC *zc);
int  noxrd7		(ZC *zc);
void stohdr		(ZC *zc, long pos);
long rclhdr		(BYTE *hdr);

int  zmdm_rl	(ZC *zc, int timeout);

/* Functions used to fiddle with the displays */

void zmdms_progress  (ZC *zc, int status);
void zmdms_newfile   (ZC *zc, int filen, TCHAR *fname, long flength);
void zmdms_update    (ZC *zc, int state);

void zmdmr_progress  (ZC *zc, int status);
void zmdmr_update    (ZC *zc, int status);
void zmdmr_filecnt   (ZC *zc, int cnt);
void zmdmr_totalsize (ZC *zc, long bytes);
void zmdmr_newfile   (ZC *zc, int filen, BYTE *theirname, TCHAR *ourname);
void zmdmr_filesize  (ZC *zc, long fsize);

unsigned int zmdm_error  (ZC *zc, int error);
		 int zmdm_retval (ZC *zc, int flag, int error);

/* from zmdm_rcv.c */

int  tryz 	(ZC *zc);
int  rzfiles	(ZC *zc);
int  rzfile	(ZC *zc);
void zmputs	(ZC *zc, char *s);
int  closeit	(ZC *zc);
void ackbibi	(ZC *zc);
/* void bttyout  (char c); */

/* from zmdm_snd.c */

int  wcs		  (ZC *zc, TCHAR FAR *oname);
int  wctxpn	  (ZC *zc, TCHAR FAR *name);
int  zfilbuf	  (ZC *zc);
void canit	  (ZC *zc);
int  getzrxinit (ZC *zc);
int  sendzsinit (ZC *zc);
int  zsendfile  (ZC *zc, char *buf, int blen);
int  zsendfdata (ZC *zc);
int  getinsync  (ZC *zc, int flag);
void saybibi	  (ZC *zc);

/* the following stuff is here as an attempt to match names into HA5 */

#define readline(h,x)	zmdm_rl(h,x)

#define xsendline(h,p,c)	fooComSendChar(h->hCom,p,c)
#define sendline(h,p,c)		fooComSendChar(h->hCom,p,c)
#define flushmo(h,p)		fooComSendPush(h->hCom,p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\zmdm_snd.c ===
/* zmdm_snd.c -- Routines to handle zmodem sending for HyperACCESS
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 20 $
 *	$Date: 7/12/02 8:32a $
 */

#include <windows.h>
#pragma hdrstop

#include <setjmp.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <term\res.h>
#include <tdll\globals.h>
#include <tdll\file_io.h>
#include <tdll\htchar.h>

#define	BYTE	unsigned char

#include "itime.h"
#include "xfr_dsp.h"
#include "xfr_todo.h"
#include "xfr_srvc.h"

#include "xfer.h"
#include "xfer.hh"
#include "xfer_tsc.h"

#include "foo.h"

#include "zmodem.hh"
#include "zmodem.h"

/*lint -e502*/				/* lint seems to want the ~ operator applied only
							 *	only to unsigned, we're using uchar
							 */

#define ZBUF_SIZE	1024

/* * * * * * * * * * * * * * * *
 *	local function prototypes  *
 * * * * * * * * * * * * * * * */

VOID long_to_octal(LONG lVal, TCHAR *pszStr);


/* * * * * * * *
 *	Functions  *
 * * * * * * * */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * zmdm_snd
 *
 * DESCRIPTION:
 *	Sends a file using ZMODEM protocol.  Does not support starting task
 *	at other end (sending a "rz\r" text string) or remote commands.
 *
 * ARGUMENTS:
 *	attended -- TRUE if user is probably in attendance. Controls the display
 *				of some messages.
 *
 * RETURNS:
 *	True if transfer completes successfully, FALSE otherwise.
 */
USHORT zmdm_snd(HSESSION h, int method, int attended, unsigned nfiles, long nbytes)
	{
	ZC           *zc = NULL;
	TCHAR	     sfname[FNAME_LEN];         // file name of file being sent
	BOOL         got_file = FALSE;          // controls when to complete batch op
	int 	     tries = 0;                 // number of retries for each packet
	unsigned     total_tries = 0;           // number of retries for entire transfer
	int 	     xstatus = TSC_OK;          // winds up with overall status of transfer
	int	         override = FALSE;          // set TRUE if comm. details changed to
	unsigned int uiOldOptions = 0;
	// int		    hld_send_cdelay;        //  accomodate xmodem
	// char	        hld_bits_per_char;      //	hld* vars. used to restore port after
	// char	        hld_parity_type;        //	transfer if override is used
	XFR_Z_PARAMS *pZ = NULL;
	#if defined(DEADWOOD)
	DWORD        nLen;
	#endif // defined(DEADWOOD)

	// tzset();

	if (xfer_set_comport(h, TRUE, &uiOldOptions) != TRUE)
		{
		goto done;
		}
	else
		{
		override = TRUE;
		}

	// RemoteClear();

	zc = malloc(sizeof(ZC));
	if (zc == NULL)
		{
		goto done;
		}
	memset(zc, 0, sizeof(ZC));

	zc->hSession = h;
	zc->hCom     = sessQueryComHdl(h);
	zc->nMethod = method;
	zc->fSavePartial = TRUE;
	zc->ulOverride = (unsigned long)0;

	zc->real_bytes = 0L;
	zc->file_bytes = 0L;
	zc->total_bytes = 0L;
	zc->actual_bytes = 0L;
	zc->nSkip = FALSE;

	zc->flagkey = NULL;
//	zc->flagkey_buf = NULL;
//	zc->intrjmp = NULL;
	zc->fh = NULL;
	
	zc->basesize = 0L;
	zc->xfertimer = -1L;
	zc->xfertime = -1L;
	zc->nfiles = nfiles;	/* make these available to display routines */
	zc->filen = 0;
	zc->filesize = -1L;
	zc->nbytes = nbytes;

	//zc->Rxtimeout = 0L;	// Set below.
	
	zc->z_crctab = NULL;
	#if defined(DEADWOOD)
	resLoadDataBlock(glblQueryDllHinst(),
					IDT_CSB_CRC_TABLE,
					&zc->z_crctab,
					&nLen);
	assert(nLen != 0);
	#else // defined(DEADWOOD)
	zc->z_crctab = usCrc16Lookup;
	#endif // defined(DEADWOOD)

	if (zc->z_crctab == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	zc->z_cr3tab = NULL;
	#if defined(DEADWOOD)
	resLoadDataBlock(glblQueryDllHinst(),
					IDT_CRC_32_TAB,
					&zc->z_cr3tab,
					&nLen);
	assert(nLen != 0);
	#else // defined(DEADWOOD)
	zc->z_cr3tab = ulCrc32Lookup;
	#endif // defined(DEADWOOD)

	if (zc->z_cr3tab == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}

	zc->Rxframeind = 0;			// Not used in file sends.

	//zc->Rxtype = 0;			// Not used in file sends.
	//memset(zc->Rxhdr, '\0', sizeof(zc->Rxhdr));	// Not used in file sends.

	//memset(zc->Txdr, '\0', sizeof(zc->Txdr));
	zc->Rxpos = 0L;
	zc->Txpos = 0L;
	//zc->Txfcs32 = TRUE;			// Set below.
	zc->Crc32t = TRUE;
	//zc->Crc32 = TRUE;				// Set below.
	
	memset(zc->Attn, '\0', sizeof(zc->Attn));

	zc->lastsent = 0;
	zc->Not8bit = 0;
	zc->displayed_time = 0L;
	//zc->Zctlesc = 0;				// Set below.
	zc->Zrwindow = 0;
	zc->Eofseen = FALSE;
	zc->tryzhdrtype = ZRQINIT;
	zc->Thisbinary = FALSE;
	zc->Filemode = 0;
	zc->Modtime = 0L;
	zc->do_init = FALSE;
	//zc->zconv = TEXT('\0');		// Should be set here?
	//zc->zmanag = TEXT('\0');		// Should be set here?
	//zc->ztrans = TEXT('\0');		// Should be set here?
	zc->secbuf = NULL;
	zc->fname = NULL;
	zc->our_fname = NULL;


	//memset(zc->stP, 0, sizeof(zc->stP);

	zc->txbuf = malloc(ZBUF_SIZE);
	if (zc->txbuf == NULL)
		{
		xstatus = TSC_NO_MEM;
		goto done;
		}
	TCHAR_Fill(zc->txbuf, TEXT('\0'), ZBUF_SIZE);

	//zc->Filesleft = 0;			// Set below.
	//zc->Totalleft = 0;			// Set below.
	zc->blklen = ZBUF_SIZE;
	zc->blkopt = 0;
	zc->Beenhereb4 = 0;
	//zc->Wantfcs32 = FALSE;		// Set below.
	zc->Rxflags = 0;
	//zc->Rxbuflen = (unsigned)0;	// Set below.
	zc->Txwindow = (unsigned)0;
	zc->Txwcnt = (unsigned)0;
	zc->Txwspac = (unsigned)0;
	zc->Myattn[0] = '\0';
	zc->errors = 0;
	zc->s_error = 0;
	zc->pstatus = -4;
	zc->last_event = -4;
	zc->Lskipnocor = FALSE;
	zc->Lastsync = zc->Rxpos;
	zc->Lrxpos = zc->Rxpos;
	
	// hp_report_xtime(0);	   /* make invalid in case transfer bombs */
	
	if (setjmp(zc->flagkey_buf) != 0)
		{
		stohdr(zc, 0L);
		zshhdr(zc, ZCAN, zc->Txhdr);
		canit(zc);
		if (zc->fh)
			{
			fio_close(zc->fh);
			}
		zc->fh = NULL;
		zmdm_retval(zc, TRUE, ZABORT);
		xstatus = TSC_USER_CANNED;
		canit(zc);
		goto done;
		}

	pZ = (XFR_Z_PARAMS *)xfer_get_params(zc->hSession, zc->nMethod);
	assert(pZ);

    if (pZ == NULL)
        {
        xstatus = TSC_NO_MEM;
        goto done;
        }

	zc->Zctlesc = pZ->nEscCtrlCodes;
	zc->Rxtimeout = pZ->nRetryWait;
	zc->Wantfcs32 = (pZ->nCrcType == ZP_CRC_32);

	if (zc->Rxtimeout <= 0)
		{
		zc->Rxtimeout = 10;
		}
	zc->Rxtimeout *= 10;

	zc->Txfcs32 = zc->Wantfcs32;
	zc->Rxbuflen = (unsigned)0;

	total_tries = 0;
	zc->Filesleft = zc->nfiles;
	zc->Totalleft = zc->nbytes;

	zmdmr_totalsize(zc, zc->nbytes);
	zmdmr_filecnt(zc, zc->nfiles);
	xferMsgErrorcnt(h, 0);

	got_file = TRUE;

	if (attended)
		{
		/* it might be necessary to start up the other end */
		sendline(zc, &zc->stP, 'r');
		sendline(zc, &zc->stP, 'z');
		sendline(zc, &zc->stP, '\r');
		flushmo(zc, &zc->stP);
		stohdr(zc, 0L);
		zshhdr(zc, ZRQINIT, zc->Txhdr);
		}
	else
		{
		stohdr(zc, 0L);
		}

	switch (xstatus = getzrxinit (zc))
	{
	case ZCAN:
        //
        // Set the last error to the TSC_USER_CANNED for
        // error reporting purposes. It seems as if the
        // errors are reversed in the error array, but
        // correcting them in the error array caused other
        // undesirable side effects.  REV: 02/23/2001
        //
		xstatus = zmdm_error(zc, ZABORT);
        break;

	case ZABORT:
        //
        // Set the last error to the TSC_RMT_CANNED for
        // error reporting purposes. It seems as if the
        // errors are reversed in the error array, but
        // correcting them in the error array caused other
        // undesirable side effects.  REV: 02/23/2001
        //
		xstatus = zmdm_error(zc, ZCAN);
        break;

	case TIMEOUT:
	case ZFERR:
	case ZBADFMT:
	case ERROR:
	case ZCARRIER_LOST:
		xstatus = zmdm_error(zc, xstatus);
		goto done;

	default:
		xstatus = zmdm_error(zc, xstatus);
		break;
	}

	while (got_file)
		{
		if ((got_file = xfer_nextfile(h, sfname)) == TRUE)
			{
			/* zc->total_bytes += zc->file_bytes; */
			/* zc->actual_bytes += zc->file_bytes; */
			/* zc->file_bytes = 0L; */
			++zc->filen;
			xstatus = wcs(zc, sfname);
			switch (xstatus)
				{
				case ZABORT:
                    //
                    // Set the last error to the TSC_USER_CANNED for
                    // error reporting purposes. It seems as if the
                    // errors are reversed in the error array, but
                    // correcting them in the error array caused other
                    // undesirable side effects.  REV: 02/23/2001
                    //
					xstatus = zmdm_error(zc, ZCAN);
					goto done;

				case ZCAN:
                    //
                    // Set the last error to the TSC_RMT_CANNED for
                    // error reporting purposes. It seems as if the
                    // errors are reversed in the error array, but
                    // correcting them in the error array caused other
                    // undesirable side effects.  REV: 02/23/2001
                    //
					xstatus = zmdm_error(zc, ZABORT);
					goto done;

				case TIMEOUT:
				case ZFERR:
				case ZCARRIER_LOST:
					xstatus = zmdm_error(zc, xstatus);
					goto done;

				case ERROR:
				case ZBADFMT:
				case ZCOMPL:
				case ZSKIP:
				default:
					xstatus = zmdm_error(zc, xstatus);
					break;

				case OK:
					xstatus = TSC_OK;
					break;

				} /* end switch */
			xfer_log_xfer(h, TRUE, sfname, NULL, xstatus);
			zmdms_progress(zc, FILE_DONE);
			zc->xfertime = (long)interval(zc->xfertimer);
			zc->total_bytes += zc->file_bytes;
			zc->actual_bytes += zc->real_bytes;
			zc->file_bytes = 0L;
			zc->real_bytes = 0L;
			} /* end if */

		} /* end while */

done:

	if (zc == NULL ||
		zc->txbuf == NULL ||
		zc->z_crctab == NULL ||
		zc->z_cr3tab == NULL)
		{
		xstatus = TSC_NO_MEM;
		}

	if (xstatus == TSC_OK)
		{
        if (zc != NULL)
            {
		    /* if we recorded a previous error, use it, else check this */
		    if (zc->filen == 0)
			    {
			    xstatus = TSC_CANT_START;
			    }
		    else if (zc->filen != zc->nfiles)
			    {
			    xstatus = TSC_GEN_FAILURE;
			    }
            }
        else
            {
			xstatus = TSC_GEN_FAILURE;
            }
		}

	if (got_file)
		{
		xfer_log_xfer(h, TRUE, sfname, NULL, xstatus);
		}

    if (zc != NULL)
        {
		if (xstatus != TSC_USER_CANNED && xstatus != TSC_RMT_CANNED &&
            xstatus != TSC_LOST_CARRIER && xstatus != TSC_GEN_FAILURE &&
			xstatus != TSC_NO_RESPONSE && xstatus != TSC_CANT_START)
			{
			saybibi(zc);
			}
	
        zmdms_progress(zc, TRANSFER_DONE);
        }

	if (override)
		{
		xfer_restore_comport(h, uiOldOptions);
		}

    if (zc != NULL)
        {
	    // hp_report_xtime((unsigned)zc->xfertime);

	    if (zc->errors > 99)
			{
		    xstatus = TSC_ERROR_LIMIT;
			}

	    if (zc->fh)
			{
		    fio_close(zc->fh);
			}

	    if (zc->txbuf != NULL)
		    {
		    free(zc->txbuf);
		    zc->txbuf = NULL;
		    }
	    if (zc->z_crctab != NULL)
			{
			#if defined(DEADWOOD)
		    resFreeDataBlock(h, zc->z_crctab);
			zc->z_crctab = NULL;
			#else // defined(DEADWOOD
			//
			// We don't need to free zc->z_crctab since it is pointing
			// to a static constant array. REV: 4/10/2002
			//
			zc->z_crctab = NULL;
			#endif // defined(DEADWOOD)
			}
	    if (zc->z_cr3tab)
			{
			#if defined(DEADWOOD)
		    resFreeDataBlock(h, zc->z_cr3tab);
			zc->z_cr3tab = NULL;
			#else // defined(DEADWOOD
			//
			// We don't need to free zc->z_cr3tab since it is pointing
			// to a static constant array. REV: 4/10/2002
			//
			zc->z_cr3tab = NULL;
			#endif // defined(DEADWOOD)
			}

        free(zc);
		zc = NULL;
        }

	xferMsgClose(h);

	return((unsigned)xstatus);
	}

/*----------------------------------------------------------------------+
 | wcs
 +----------------------------------------------------------------------*/
int wcs(ZC *zc, TCHAR FAR *oname)
	{
	int c = OK;
	TCHAR name[PATHLEN];

	StrCharCopyN(name, oname, PATHLEN);

	if ((xfer_opensendfile(zc->hSession,
						   &zc->fh,
						   oname,	/* full path name of file to open */
						   &zc->filesize,
						   NULL,	/* name to send not needed yet */
						   NULL)) != 0)
		{
		DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
		return ERROR;
		}

	zmdms_newfile(zc, zc->filen, oname, zc->filesize);

	zc->Eofseen = FALSE;

	switch (c = wctxpn(zc, name))
		{
		case ERROR:
			if (zc->fh != NULL)
				{
				fio_close(zc->fh);
				}
			DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
			break;

		default:
			break;
		}
	return c;
	}

/*----------------------------------------------------------------------+
 | long_to_octal
 +----------------------------------------------------------------------*/
VOID long_to_octal(LONG lVal, TCHAR *pszStr)
	{
	_ltoa(lVal, pszStr, 8);
	}

/*----------------------------------------------------------------------+
 | wctxpn - Generate and transmit pathname block consisting of pathname
 |			(null terminated), file length, mode time and file mode in
 |			octal as povided by the Unix fstat call.
 |			N.B.: modifies the passed name, may extend it!
 +----------------------------------------------------------------------*/
int wctxpn(ZC *zc, TCHAR FAR *name)
	{
	register char *p;
	register char *q;
	int           serial_number = 0;
	XFR_Z_PARAMS  *pZ;

	pZ = (XFR_Z_PARAMS *)xfer_get_params(zc->hSession, zc->nMethod);
	assert(pZ);

	if(pZ == NULL)
		{
		return ERROR;
		}

	#if defined(UPPER_FEATURES)
	/* TODO: fix the way blklen and txbuf don't work together correctly */
	zc->blklen = 1 << (pZ->nBlkSize + 5);
	#endif // defined(UPPER_FEATURES)

	xfer_name_to_send(zc->hSession, name, zc->txbuf);

	q = &zc->txbuf[StrCharGetByteCount(zc->txbuf) + 1];

	/*
	 * The ZMODEM spec says that file names must be send as lower case
	 */
	//MPT:12-11-97 spec-schmeck - this is the cause of microsoft bug #32233
	// Since this character could be the second byte of a DBCS character
	// we should just leave things alone. Otherwise, we end up changing
	// the wide character.
#if 0
	for (p = zc->txbuf; p < q; p++)
		{
		// Don't use this stuff in a Chicago DLL
		// if (isupper(*p))
		//	*p = (char)tolower(*p);
		if ((*p >= 'A') && (*p <= 'Z'))
			{
			*p |= 0x20;
			}
		}
#else
	//
	// Modified to lowercase filename characters only if they are not
	// DBCS characters. This way HyperTerminal will follow the Zmodem
	// specification for lowercase filenames. REV: 11/12/2001
	//
	for (p = zc->txbuf; p < q; p++)
		{
		if ((*p >= 'A') && (*p <= 'Z'))
			{
			//
			// Skip this character and the next if this is a DBCS
			// character, otherwise lowercase the character.
			//
			if (isDBCSChar(*p))
				{
				p++;
				}
			else
				{
				*p |= 0x20;
				}
			}
		}
#endif

	p = q;
	while (q < (zc->txbuf + ZBUF_SIZE))
		{
		*q++ = 0; /* could be speeded up somewhat */
		}

	if (*name)
		{
		long lDosTime;
		BYTE acTime[32];
		BYTE acMode[32];

		lDosTime = itimeGetFileTime(name);

		// lDosTime -= timezone;

		long_to_octal(lDosTime, acTime);
		long_to_octal(0L,       acMode);
		wsprintf(p, "%lu %s %s %d %d %ld",
				zc->filesize,
				acTime,
				acMode,
				serial_number,
				zc->Filesleft,
				zc->Totalleft);
		zc->Totalleft -= zc->filesize;
		}


	if (--zc->Filesleft <= 0)
		{
		zc->Totalleft = 0;
		}
	if (zc->Totalleft < 0)
		{
		zc->Totalleft = 0;
		}

	/* force 1k blocks if name won't fit in 128 byte block */
	if (zc->txbuf[125])
		zc->blklen=1024;
	else
		{	   /* A little goodie for IMP/KMD */
		zc->txbuf[127] = (char)((zc->filesize + 127) >>7);
		zc->txbuf[126] = (char)((zc->filesize + 127) >>15);
		}
	return zsendfile(zc, zc->txbuf, (int)(1+StrCharGetByteCount(p)+(p - zc->txbuf)));
	}

/*----------------------------------------------------------------------+
 | zfilbuf - Fill buffer with blklen chars.
 +----------------------------------------------------------------------*/
int zfilbuf(ZC *zc)
	{
	int n;
	int bsize;

	bsize = ZBUF_SIZE;

	if (zc->blklen <= ZBUF_SIZE)
		bsize = zc->blklen;

	n = fio_read(zc->txbuf, 1, bsize, zc->fh);

	if (n < bsize)
		{
		zc->Eofseen = TRUE;
		}
	return n;
	}

/*----------------------------------------------------------------------+
 | canit - Send cancel string to get the other end to shut up.
 +----------------------------------------------------------------------*/
void canit(ZC *zc)
	{
	int ii;

	for (ii = 0; ii < 10; ii++)
		{
		sendline(zc, &zc->stP, 24);
		}
	for (ii = 0; ii < 10; ii++)
		{
		sendline(zc, &zc->stP, 8);
		}
	flushmo(zc, &zc->stP);
	// purgeline(zc);
	ComRcvBufrClear(zc->hCom);
	}

/*----------------------------------------------------------------------+
 | getzrzinit - Get the receiver's init parameters.
 +----------------------------------------------------------------------*/
int getzrxinit(ZC *zc)
	{
	register int n;
	register int c = ERROR;
	int		 x;
	XFR_Z_PARAMS *pZ;

	pZ = (XFR_Z_PARAMS *)xfer_get_params(zc->hSession, zc->nMethod);
	assert(pZ);

	if (pZ == NULL)
		{
		return ERROR;
		}

	if (pZ->nXferMthd == ZP_XM_STREAM)
		{
		zc->Txwindow = (unsigned)0;
		}
	else
		{
		zc->Txwindow = (pZ->nWinSize + 1) * 1024;
		}

	for (n = 10; --n >= 0; )
		{
		switch (x = xfer_user_interrupt(zc->hSession))
			{
			case XFER_SKIP:
			case XFER_ABORT:
				zmdms_update(zc, ZCAN);
				longjmp(zc->flagkey_buf, 5);
				break;

			default:
				break;
			}

		if (xfer_carrier_lost(zc->hSession))
			{
			return ZCARRIER_LOST;
			}

		switch (c = zgethdr(zc, zc->Rxhdr, 'T'))
			{
			case ZCHALLENGE:	/* Echo receiver's challenge numbr */
				stohdr(zc, zc->Rxpos);
				zshhdr(zc, ZACK, zc->Txhdr);
				continue;

			case ZCOMMAND:		/* They didn't see out ZRQINIT */
				stohdr(zc, 0L);
				zshhdr(zc, ZRQINIT, zc->Txhdr);
				continue;

			case ZRINIT:
				zc->Rxflags = 0377 & zc->Rxhdr[ZF0];
				zc->Txfcs32 = (zc->Wantfcs32 && (zc->Rxflags & CANFC32));
				zc->Zctlesc |= zc->Rxflags & TESCCTL;
				zc->Rxbuflen = (0377 & zc->Rxhdr[ZP0])+((0377 & zc->Rxhdr[ZP1])<<8);
				if ( !(zc->Rxflags & CANFDX))
					{
					zc->Txwindow = (unsigned)0;
					}

				/* Set initial subpacket length */
				if (zc->blklen < 1024)
					{					  /* Command line override? */
					if (cnfgBitRate() > 2400)
						{
						zc->blklen = 1024;
						}
					else if (cnfgBitRate() > 1200)
						{
						zc->blklen = 512;
						}
					else if (cnfgBitRate() > 300)
						{
						zc->blklen = 256;
						}
					}
				if (zc->Rxbuflen && ((unsigned)zc->blklen > zc->Rxbuflen))
					{
					zc->blklen = zc->Rxbuflen;
					}
				if (zc->blkopt && (zc->blklen > zc->blkopt))
					{
					zc->blklen = zc->blkopt;
					}

				return (sendzsinit(zc));

			case TIMEOUT:
				continue;

			case ZCAN:
            case ZCARRIER_LOST:
			case ZABORT:
			case ZFERR:
				return c;

			case ZRQINIT:
				if (zc->Rxhdr[ZF0] == ZCOMMAND)
					{
					continue;
					}
			default:
				zshhdr(zc, ZNAK, zc->Txhdr);
				continue;
			}
		}

	if (c == TIMEOUT)
		{
		return TIMEOUT;
		}

	return ERROR;
	}

/*----------------------------------------------------------------------+
 | sendzsinit - Send send-init information.
 +----------------------------------------------------------------------*/
int sendzsinit(ZC *zc)
	{
	register int c;

	if (zc->Myattn[0] == '\0' && (!zc->Zctlesc || (zc->Rxflags & TESCCTL)))
		{
		return OK;
		}
	zc->errors = 0;
	for (;;)
		{
		stohdr(zc, 0L);
		if (zc->Zctlesc)
			{
			zc->Txhdr[ZF0] |= TESCCTL;
			zshhdr(zc, ZSINIT, zc->Txhdr);
			}
		else
			{
			zsbhdr(zc, ZSINIT, zc->Txhdr);
			}
		zsdata(zc, zc->Myattn, 1+StrCharGetByteCount(zc->Myattn), ZCRCW);
		c = zgethdr(zc, zc->Rxhdr, 'T');
		switch (c)
			{
			case ZRPOS:
				return c;

			case ZCAN:
			case ZABORT:
			case ZFERR:
			case TIMEOUT:
			case ZCARRIER_LOST:
				return c;
			case ZACK:
				return OK;
			default:
				if (++zc->errors > 99)
					{
					return ERROR;
					}
				xferMsgErrorcnt(zc->hSession, ++zc->errors);
				continue;
			}
		}
	}

/*----------------------------------------------------------------------+
 | zsendfile - Send file name and releated info.
 +----------------------------------------------------------------------*/
int zsendfile(ZC *zc, char *buf, int blen)
	{
	unsigned char chr;
	register int c;
	register unsigned long crc;
	XFR_Z_PARAMS *pZ;

	pZ = (XFR_Z_PARAMS *)xfer_get_params(zc->hSession, zc->nMethod);
	assert(pZ);

	if (pZ == NULL)
		{
		return ERROR;
		}

	for (;;)
		{
		zc->Txhdr[ZF0] = 0;
		if (zc->Txhdr[ZF0] == 0)
			{
			if (pZ->nCrashRecSend == ZP_CRS_ONCE ||
				pZ->nCrashRecSend == ZP_CRS_ALWAYS)
				{
				zc->Txhdr[ZF0] = ZCRESUM;
				}
			}
		if (zc->Txhdr[ZF0] == 0)
			{
			if (pZ->nCrashRecSend == ZP_CRS_NEG)
				{
				zc->Txhdr[ZF0] = ZCBIN;
				}
			}
		if (zc->Txhdr[ZF0] == 0)
			{
			if (pZ->nEolConvert)
				{
				zc->Txhdr[ZF0] = ZCNL;
				}
			}

		switch (pZ->nOverwriteOpt)
			{
			default:
			case ZP_OO_NONE:
				zc->Txhdr[ZF1] = 0;
				break;
			case ZP_OO_NEVER:
				zc->Txhdr[ZF1] = ZMPROT;
				break;
			case ZP_OO_L_D:
				zc->Txhdr[ZF1] = ZMDIFF;
				break;
			case ZP_OO_NEWER:
				zc->Txhdr[ZF1] = ZMNEW;
				break;
			case ZP_OO_ALWAYS:
				zc->Txhdr[ZF1] = ZMCLOB;
				break;
			case ZP_OO_APPEND:
				zc->Txhdr[ZF1] = ZMAPND;
				break;
			case ZP_OO_CRC:
				zc->Txhdr[ZF1] = ZMCRC;
				break;
			case ZP_OO_N_L:
				zc->Txhdr[ZF1] = ZMNEWL;
				break;
			}

		if (zc->Lskipnocor)
			{
			zc->Txhdr[ZF1] |= ZMSKNOLOC;
			}
		/* ZF2 is for ZTCRYPT (encryption) and ZTRLE and ZTLZW (compression) */
		zc->Txhdr[ZF2] = 0;
		/* ZF3 is for ZTSPARS (special sparse file option) */
		zc->Txhdr[ZF3] = 0;
		zsbhdr(zc, ZFILE, zc->Txhdr);
		zsdata(zc, buf, blen, ZCRCW);
		if (zc->xfertimer == (-1L))
			{
			zc->xfertimer = (long)startinterval();
			}

again:
		c = zgethdr(zc, zc->Rxhdr, 'T');
		switch (c)
			{
			case ZRINIT:
				while ((c = readline(zc, 300)) > 0)
					{
					if (c == ZPAD)
						{
						goto again;
						}
					}
				continue;

			default:
				continue;

			case TIMEOUT:
			case ZCARRIER_LOST:
			case ZCAN:
			case ZABORT:
			case ZFERR:
				DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
				return c;

			case ZFIN:
				return ERROR;

			case ZCRC:
				crc = 0xFFFFFFFFL;
				while (fio_read(&chr, 1, 1, zc->fh) && --zc->Rxpos)
					{
					crc = UPDC32(zc, (int)chr, crc);
					}
				crc = ~crc;
				fio_errclr(zc->fh);		/* Clear EOF */
				fio_seek(zc->fh, 1, FIO_SEEK_SET);
				stohdr(zc, crc);
				zsbhdr(zc, ZCRC, zc->Txhdr);
				goto again;

			case ZSKIP:
				zc->total_bytes += zc->filesize;
				fio_close(zc->fh);
				zc->fh = NULL;
				return c;

			case ZRPOS:
				/*
				 * Suppress zcrcw request otherwise triggered by
				 * lastyunc==bytcnt
				 */
				if (zc->Rxpos)
					{
					if (fio_seek(zc->fh, zc->Rxpos, FIO_SEEK_SET) == (-1))
						{
						DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
						return ERROR;
						}
					}
				zc->Lastsync = (zc->file_bytes = zc->Txpos = zc->Rxpos) -1;
				return zsendfdata(zc);
			}
		}
	}

/*----------------------------------------------------------------------+
 | zsendfdata - Send the data in the file.
 +----------------------------------------------------------------------*/
int zsendfdata(ZC *zc)
	{
	int 	c, e, n;
	int 	newcnt;
	long tcount = 0;
	TCHAR ch;
	int 		junkcount;		/* Counts garbage chars received by TX */
	static int	tleft = 6;		/* Counter for test mode */
	int			x;

	zc->Lrxpos = 0;
	junkcount = 0;
	zc->Beenhereb4 = 0;
somemore:

	if (setjmp(zc->intrjmp))
		{
waitack:
		junkcount = 0;
		c = getinsync(zc, 0);
gotack:
		switch (c)
			{
			default:
			case ZSKIP:
			case ZCAN:
			case ZFERR:
				DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
				if (zc->fh)
					fio_close(zc->fh);
				zc->fh = NULL;
				return c;

			case ZACK:
			case ZRPOS:
				break;

			case ZRINIT:
				return OK;
			}
		/*
		 * If the reverse channel can be tested for data,
		 *  this logic may be used to detect error packets
		 *  sent by the receiver, in place of setjmp/longjmp
		 *	rdchk() returns non 0 if a character is available
		 */
		// while (rdchk(zc) != ERROR)
		while (mComRcvBufrPeek(zc->hCom, &ch) != 0)
			{
			switch (readline(zc, 1))
				{
				case CAN:
				case ZPAD:
					c = getinsync(zc, 1);
					goto gotack;

				case XOFF:		/* Wait a while for an XON */
				case XOFF|0200:
					readline(zc, zc->Rxtimeout);
					break;

				default:
					break;
				}
			}
		}

	newcnt = zc->Rxbuflen;
	zc->Txwcnt = (unsigned)0;
	stohdr(zc, zc->Txpos);
	zsbhdr(zc, ZDATA, zc->Txhdr);

	do {
		switch (x = xfer_user_interrupt(zc->hSession))
			{
			case XFER_SKIP:
			case XFER_ABORT:
				zmdms_update(zc, ZCAN);
				longjmp(zc->flagkey_buf, 6);
				break;

			default:
				break;
			}

		if (xfer_carrier_lost(zc->hSession))
			{
			return ZCARRIER_LOST;
			}

		n = zfilbuf(zc);
		if (zc->Eofseen)
			{
			e = ZCRCE;
			}
		else if (junkcount > 3)
			{
			e = ZCRCW;
			}
		else if (zc->file_bytes == zc->Lastsync)
			{
			e = ZCRCW;
			}
		else if (zc->Rxbuflen && (newcnt -= n) <= 0)
			{
			e = ZCRCW;
			}
		else if (zc->Txwindow && (zc->Txwcnt += n) >= zc->Txwspac)
			{
			zc->Txwcnt = (unsigned)0;
			e = ZCRCQ;
			}
		else
			{
			e = ZCRCG;
			}

		zsdata(zc, zc->txbuf, n, e);
		zc->file_bytes = zc->Txpos += n;
		zc->real_bytes += n;

		zmdms_update(zc, ZRPOS);
		zmdms_progress(zc, 0);

		if (e == ZCRCW)
			{
			goto waitack;
			}
		/*
		 * If the reverse channel can be tested for data,
		 *  this logic may be used to detect error packets
		 *  sent by the receiver, in place of setjmp/longjmp
		 *	rdchk() returns non 0 if a character is available
		 */
		// while (rdchk(zc) != ERROR)
		while (mComRcvBufrPeek(zc->hCom, &ch) != 0)
			{
			switch (readline(zc, 1))
				{
				case CAN:
				case ZPAD:
					c = getinsync(zc, 1);
					if (c == ZACK)
						{
						break;
						}
					/* zcrce - dinna wanna starta ping-pong game */
					zsdata(zc, zc->txbuf, 0, ZCRCE);
					goto gotack;

				case XOFF:		/* Wait a while for an XON */
				case XOFF|0200:
					readline(zc, zc->Rxtimeout);
				default:
					if (ch != ZFREECNT)
						{
						++junkcount;
						}
					break;
				}
			}
		if (zc->Txwindow)
			{
			while ((unsigned)(tcount = zc->Txpos - zc->Lrxpos) >= zc->Txwindow)
				{
				if (e != ZCRCQ)
					{
					zsdata(zc, zc->txbuf, 0, e = ZCRCQ);
					}
				c = getinsync(zc, 1);
				if (c != ZACK)
					{
					zsdata(zc, zc->txbuf, 0, ZCRCE);
					goto gotack;
					}
				}
			}
		} while (!zc->Eofseen);

	for (;;)
		{
		stohdr(zc, zc->Txpos);
		zsbhdr(zc, ZEOF, zc->Txhdr);
		switch (c = getinsync(zc, 0))
			{
			case ZACK:
				continue;

			case ZRPOS:
				goto somemore;

			case ZRINIT:
				return OK;

			case ZSKIP:
			default:
				fio_close(zc->fh);
				zc->fh = NULL;
				return c;
			}
		}
	}

/*----------------------------------------------------------------------+
 | getinsync - Respond to receiver's complaint, get back in sync with receiver.
 +----------------------------------------------------------------------*/
int getinsync(ZC *zc, int flag)
	{
	register int c;

	flushmo(zc, &zc->stP);

	for (;;)
		{
		// xfer_idle(zc->hSession, XFER_IDLE_IO);
		c = zgethdr(zc, zc->Rxhdr, 'T');

		switch (c)
			{
			case ZCAN:
			case ZABORT:
			case ZFIN:
			case TIMEOUT:
				DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
				return c;

			case ZRPOS:
				/* ************************************* */
				/*	If sending to a buffered modem, you  */
				/*	 might send a break at this point to */
				/*	 dump the modem's buffer.            */

				fio_errclr(zc->fh);		/* In case file EOF seen */
				if (fio_seek(zc->fh, zc->Rxpos, FIO_SEEK_SET) == (-1))
                    {
                    DbgOutStr("ZMODEM error %s %d\r\n", TEXT(__FILE__), __LINE__,0,0,0);
					return ERROR;
                    }
				zc->Eofseen = FALSE;
				zc->file_bytes = zc->Lrxpos = zc->Txpos = zc->Rxpos;
				if (zc->Lastsync == zc->Rxpos)
					{
					if (++zc->Beenhereb4 > 4)
						{
						if (zc->blklen > 32)
							{
							zc->blklen /= 2;
							}
						}
					}
				zc->Lastsync = zc->Rxpos;
				zmdms_update(zc, ZRPOS);
				return c;

			case ZACK:
				zc->Lrxpos = zc->Rxpos;
				if (flag || zc->Txpos == zc->Rxpos)
					{
					return c;
					}
				break;

			case ZRINIT:
			case ZSKIP:
				fio_close(zc->fh);
				zc->fh = NULL;
				return c;

			case ERROR:
			default:
				zsbhdr(zc, ZNAK, zc->Txhdr);
				break;
			}
		}
	}

/*----------------------------------------------------------------------+
 | saybibi - Say "bibi" to the receiver, try to do it cleanly.
 +----------------------------------------------------------------------*/
void saybibi(ZC *zc)
	{
	for (;;)
		{
		stohdr(zc, 0L);						/* CAF Was zsbhdr - minor change */
		zshhdr(zc, ZFIN, zc->Txhdr);    		/*  to make debugging easier */
		switch (zgethdr(zc, zc->Rxhdr, 'T'))
			{
			case ZFIN:
				sendline(zc, &zc->stP, 'O');
				sendline(zc, &zc->stP, 'O');
				flushmo(zc, &zc->stP);
                return;

			case ZCAN:
			case TIMEOUT:
                return;

            case TSC_USER_CANNED:   // These cases should not occur, but
            case TSC_RMT_CANNED:    // this code is placed here to ignore
            case ZCARRIER_LOST:     // these cases should they occur.
            case ZMDM_CARRIER_LOST:
                assert(0);
                return;

            default:
				break;
			}
		}
	}

/*********************** end of zmdm_snd.c **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\bar.cpp ===
/******************************************************************************/
/* Bar.CPP: IMPLEMENTATION OF THE CStatBar (Status Bar) CLASS                 */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*    CStatBar::CStatBar                                                      */
/*    CStatBar::~CStatBar                                                     */
/*    CStatBar::Create                                                        */
/*    CStatBar::OnSetFont                                                     */
/*    CStatBar::DoPaint                                                       */
/*    CStatBar::DrawStatusText                                                */
/*    CStatBar::SetText                                                       */
/*    CStatBar::SetPosition                                                   */
/*    CStatBar::SetSize                                                       */
/*    CStatBar::ClearPosition                                                 */
/*    CStatBar::ClearSize                                                     */
/*    CStatBar::Reset                                                         */
/*    CStatBar::OnPaletteChanged                                                                                          */
/*                                                                            */
/*                                                                            */
/* Functions in this file                                                     */
/*                                                                            */
/*    ClearStatusBarSize                                                      */
/*    ClearStatusBarPosition                                                  */
/*    SetPrompt                                                               */
/*    SetPrompt                                                               */
/*    ShowStatusBar                                                           */
/*    IsStatusBarVisible                                                      */
/*    GetStatusBarHeight                                                      */
/*    InvalidateStatusBar                                                     */
/*    ClearStatusBarPositionAndSize                                           */
/*    ResetStatusBar                                                          */
/*    SetStatusBarPosition                                                    */
/*    SetStatusBarSize                                                        */
/*    SetStatusBarPositionAndSize                                             */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CStatBar, CStatusBar )

#include "memtrace.h"

CStatBar        *g_pStatBarWnd = NULL;

static UINT BASED_CODE indicators[] =
    {
    ID_SEPARATOR,           // status line indicator
    IDB_SBPOS,
    IDB_SBSIZE
    };

BEGIN_MESSAGE_MAP( CStatBar, CStatusBar )
                ON_WM_SYSCOLORCHANGE()
        ON_MESSAGE(WM_SETFONT, OnSetFont)
                ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
        ON_WM_NCDESTROY()
END_MESSAGE_MAP()

static int miSlackSpace;

/******************************************************************************/

CStatBar::CStatBar()
    {
    m_iBitmapWidth  = 0;
    m_iBitmapHeight = 0;
    miSlackSpace = 0;
    m_iSizeY = 0;
    }

CStatBar::~CStatBar()
        {
        // Ensure that the CControlBar doesn't assert trying access our parent
        // object (CPBFrame) during the destruction of our parent object.
        m_pDockSite = NULL;
        }

/******************************************************************************/

BOOL CStatBar::Create( CWnd* pParentWnd )
    {
    BOOL bRC = TRUE;
    int cxStatBar;  // width of a char in the status bar

    // Create the status Bar Window.
    bRC = CStatusBar::Create(pParentWnd);

    ASSERT (bRC != FALSE);

    if (bRC != FALSE)
        {
        // Set the Pane Indicators.
        bRC = SetIndicators( indicators, sizeof( indicators ) / sizeof( UINT ) );

        ASSERT( bRC != FALSE );

        if (bRC != FALSE)
            {
            TRY
                {
                // Load the Separator Strings
                VERIFY(m_cstringSizeSeparator.LoadString(IDS_SIZE_SEPARATOR));
                VERIFY(m_cstringPosSeparator.LoadString(IDS_POS_SEPARATOR));
                }
            CATCH(CMemoryException,e)
                {
                m_cstringSizeSeparator.Empty();
                m_cstringPosSeparator.Empty();
                }
            END_CATCH

            // Load the Position and Size Bitmaps
            VERIFY(m_posBitmap.LoadBitmap(IDB_SBPOS));
            VERIFY(m_sizeBitmap.LoadBitmap(IDB_SBSIZE));

            if ( (m_posBitmap.GetSafeHandle() != NULL) &&
                 (m_sizeBitmap.GetSafeHandle() != NULL)    )
                {
                //Calculate the size of the pane and set them

                CClientDC dc(this);

                /*DK* What font to select? */
                /*DK* What to do if in foreign Language, Size "0"? */

                cxStatBar = (dc.GetTextExtent(TEXT("0"), 1)).cx;
                BITMAP bmp;

                m_posBitmap.GetObject(sizeof (BITMAP), &bmp);

                m_iBitmapWidth  = bmp.bmWidth;
                m_iBitmapHeight = bmp.bmHeight;

                int iPaneWidth;
                UINT uiID, uiStyle;

                GetPaneInfo( 0, uiID, uiStyle, iPaneWidth) ;
                SetPaneInfo( 0, uiID, SBPS_NORMAL | SBPS_STRETCH, iPaneWidth );

                GetPaneInfo(1, uiID, uiStyle, iPaneWidth);

                if (iPaneWidth < bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar))
                    {
                    iPaneWidth = bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar);
                    SetPaneInfo(1, uiID, uiStyle, iPaneWidth);
                    }

                GetPaneInfo(2, uiID, uiStyle, iPaneWidth);

                if (iPaneWidth < bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar))
                    {
                    iPaneWidth = bmp.bmWidth + (SIZE_POS_PANE_WIDTH * cxStatBar);
                    SetPaneInfo(2, uiID, uiStyle, iPaneWidth);
                    }

                // force a height change
                CFont *pcFontTemp = GetFont();

                // initialize font height etc
                OnSetFont( (WPARAM)(HFONT)pcFontTemp->GetSafeHandle(), 0 );
                }
            else
                {
                bRC = FALSE;
                }
            }
        }
    return bRC;
    }

/******************************************************************************/

void CStatBar::OnNcDestroy( void )
    {
    m_posBitmap.DeleteObject();
    m_sizeBitmap.DeleteObject();

    m_posBitmap.m_hObject = NULL;
    m_sizeBitmap.m_hObject = NULL;

    m_cstringSizeSeparator.Empty();
    m_cstringPosSeparator.Empty();

    CStatusBar::OnNcDestroy();
    }

/******************************************************************************/

CSize CStatBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
    {
    CSize size = CStatusBar::CalcFixedLayout( bStretch, bHorz );

    size.cy = m_iSizeY;

    return size;
    }

/******************************************************************************/
/* Change the height of the status bar to allow the bitmaps to   be painted   */
/* in the panes. The height is set in the OnSetFont  OnSetFont method.  Save  */
/* the current border values, change  then call OnSetFont and then reset the  */
/* border values                                                              */
/*                                                                            */
/* This will increase the height of the whole status bar  until the next      */
/* OnSetFont (font change) for the status bar.                                */
/*                                                                            */
/* In Barcore.cpp, the Height of the status bar is set in the  OnSetFont      */
/* method as follows:                                                         */
/*                                                                            */
/*  Height =  = (tm.tmHeight - tm.tmInternalLeading) +                        */
/*              CY_BORDER*4 (which is 2 extra on top, 2                       */
/*              on bottom) - rectSize.Height();                               */
/*                                                                            */
/*  This is really                                                            */
/*    Height = Height of Font + Border between Font and                       */
/*             Pane edges + Border between Pane edges and                     */
/*             Status bar window.                                             */
/*                                                                            */
/*  tm.tmHeight - tm.tmInternalLeading is Font Height CY_BORDER*4 is border   */
/*  between font and pane edges rectSize.Height is Neg of Border between Pane */
/*  and SBar rectSize is set to 0, then the deflated by the border size.      */
/*  Deflating from 0 => negative, and  - negative gives us a positive amount. */
/*                                                                            */
/*  by default m_cyBottomBorder = m_cyTopBorder = 1                           */
/******************************************************************************/
/* We only change the border sizes temporarily for the calculation of the     */
/* status bar height.  We really don't want to change the border sizes, but   */
/* are just using them as a way to affect the size of the whole bar.          */
/******************************************************************************/

LRESULT CStatBar::OnSetFont(WPARAM wParam, LPARAM lParam)
    {

    CRect rect;

    int iTmpcyTopBorder    = m_cyTopBorder;
    int iTmpcyBottomBorder = m_cyBottomBorder;

    m_cyTopBorder = m_cyBottomBorder = 2;
    miSlackSpace = 0;

    // Can't do this in MFC 4
//    lResult = CStatusBar::OnSetFont(wParam, lParam); //initialize font height etc

    rect.SetRectEmpty();
    CalcInsideRect( rect, TRUE ); // will be negative size

    int iBorder = CY_BORDER * 4 - rect.Height();
    int iSize   = m_iSizeY - iBorder;
    int cyTallest = m_iBitmapHeight;
    CDC dc;

    if( dc.CreateIC( TEXT("DISPLAY"), NULL, NULL, NULL ) )
        {
        TEXTMETRIC tm;
                tm.tmHeight=0;
        CFont *font = CFont::FromHandle( (HFONT)wParam );
                if ( font )
                        {
                        CFont *oldFont = dc.SelectObject(font);

                if( dc.GetTextMetrics( &tm ) && tm.tmHeight > cyTallest )
                    cyTallest = tm.tmHeight;

                        if (oldFont)
                                dc.SelectObject(oldFont);
                        }
                dc.DeleteDC();
        }

    if (cyTallest > iSize)
        m_iSizeY     = cyTallest + iBorder;

    if (m_iBitmapHeight > iSize)
        miSlackSpace = m_iBitmapHeight - iSize;

    m_cyTopBorder    = iTmpcyTopBorder;
    m_cyBottomBorder = iTmpcyBottomBorder;

    return 1L;
    }

/******************************************************************************/
/* This routine is overloaded to allow us to paint the bitmaps in the panes.  */
/* If this routine was not here, it would work fine, but no bitmaps would     */
/* appear in the status indicator panes.                                      */
/******************************************************************************/

void CStatBar::DoPaint( CDC* pDC )
    {
    BOOL     bRC;
    CString  cstringText_Pane1;
    CString  cstringText_Pane2;
    CRect    rect_Pane1;
    CRect    rect_Pane2;
    CRgn     cRgn_Pane1;
    CRgn     cRgn_Pane2;
    CBitmap* pOldBitmap;
    UINT     uiStyle_Pane1;
    UINT     uiStyle_Pane2;
    UINT     uiID;
    int      iPaneWidth;
    HDC      hdc = pDC->GetSafeHdc();

    GetItemRect( 1, &rect_Pane1 );  // get pane rect
    GetItemRect( 2, &rect_Pane2 );  // get pane rect

    pDC->ExcludeClipRect( &rect_Pane1 ); // exclude pane rect from paint
    pDC->ExcludeClipRect( &rect_Pane2 ); // exclude pane rect from paint

    CStatusBar::DoPaint( pDC ); // Let Parent Class paint remainder of status bar

    CFont* pfntOld = pDC->SelectObject( GetFont() );

    GetPaneText( 1, cstringText_Pane1 );  // Get the Text for the Pane
    GetPaneText( 2, cstringText_Pane2 );  // The status bar holds the text for us.

    GetPaneInfo( 1, uiID, uiStyle_Pane1, iPaneWidth );
    GetPaneInfo( 2, uiID, uiStyle_Pane2, iPaneWidth );

    uiStyle_Pane1 = SBPS_NORMAL;
    uiStyle_Pane2 = SBPS_NORMAL;

    CDC srcDC; // select current bitmap into a compatible CDC

    bRC = srcDC.CreateCompatibleDC( pDC );

    ASSERT( bRC != FALSE );

    if (bRC != FALSE)
        {
        // Set the Text and Background Colors for a Mono to Color Bitmap
        // Conversion.  These are also set in DrawStatusText, so should not
        // have to reset them for the other bitmap/pane
        COLORREF crTextColor = pDC->SetTextColor( GetSysColor( COLOR_BTNTEXT ) );
        COLORREF crBkColor   = pDC->SetBkColor  ( GetSysColor( COLOR_BTNFACE ) );

        bRC = cRgn_Pane1.CreateRectRgnIndirect( rect_Pane1 );

        ASSERT( bRC != FALSE );

        if (bRC != FALSE)
            {
            pDC->SelectClipRgn( &cRgn_Pane1 ); // set clip region to pane rect

            pOldBitmap = srcDC.SelectObject( &m_posBitmap );

            rect_Pane1.InflateRect( -CX_BORDER, -CY_BORDER ); // deflate => don't paint on the borders

            pDC->BitBlt( rect_Pane1.left,    rect_Pane1.top,
                         rect_Pane1.Width(), rect_Pane1.Height(),
                         &srcDC, 0, 0, SRCCOPY ); // BitBlt to pane rect
            srcDC.SelectObject( pOldBitmap );

            rect_Pane1.InflateRect( CX_BORDER, CY_BORDER ); // Inflate back for drawstatustext

            // paint the borders and the text.
            DrawStatusText( hdc, rect_Pane1, cstringText_Pane1, uiStyle_Pane1,
                                                           m_iBitmapWidth + 1 );
            }

        cRgn_Pane2.CreateRectRgnIndirect(rect_Pane2);

        ASSERT( bRC != FALSE );

        if (bRC != FALSE)
            {
            pDC->SelectClipRgn(&cRgn_Pane2); // set clip region to pane rect

            pOldBitmap = srcDC.SelectObject(&m_sizeBitmap);
            rect_Pane2.InflateRect(-CX_BORDER, -CY_BORDER); // deflate => don't paint on the borders
            pDC->BitBlt(rect_Pane2.left, rect_Pane2.top, rect_Pane2.Width(),
                        rect_Pane2.Height(), &srcDC, 0, 0, SRCCOPY); // BitBlt to pane rect
            srcDC.SelectObject(pOldBitmap);
            rect_Pane2.InflateRect(CX_BORDER, CY_BORDER); // Inflate back for drawstatustext
            // DrawStatusText will paint the borders and the text.
            DrawStatusText(hdc, rect_Pane2, cstringText_Pane2, uiStyle_Pane2, m_iBitmapWidth+1);
            }
        pDC->SetTextColor( crTextColor );
        pDC->SetBkColor  ( crBkColor   );
        }
    if (pfntOld != NULL)
        pDC->SelectObject( pfntOld );
    }

/******************************************************************************/
/* Partially taken from BARCORE.CPP DrawStatusText method of CStatusBar.      */
/* Last parameter was added                                                   */
/*                                                                            */
/* This will allow us to output the text indented the space amount for our    */
/* bitmap.  Normally, this routine puts the text left alligned to the pane.   */
/******************************************************************************/

void PASCAL CStatBar::DrawStatusText( HDC    hDC,
                                      CRect const& rect,
                                      LPCTSTR lpszText,
                                      UINT   nStyle,
                                      int    iIndentText )
    {
    ASSERT(hDC != NULL);

    CBrush* cpBrushHilite;
    CBrush* cpBrushShadow;
    HBRUSH  hbrHilite = NULL;
    HBRUSH  hbrShadow = NULL;

    if (! (nStyle & SBPS_NOBORDERS))
        {
        if (nStyle & SBPS_POPOUT)
            {
            // reverse colors
            cpBrushHilite = GetSysBrush( COLOR_BTNSHADOW    );
            cpBrushShadow = GetSysBrush( COLOR_BTNHIGHLIGHT );
            }
        else
            {
            // normal colors
            cpBrushHilite = GetSysBrush( COLOR_BTNHIGHLIGHT );
            cpBrushShadow = GetSysBrush( COLOR_BTNSHADOW    );
            }

        hbrHilite = (HBRUSH)cpBrushHilite->GetSafeHandle();
        hbrShadow = (HBRUSH)cpBrushShadow->GetSafeHandle();
        }

    // background is already grey
    UINT nOpts           = ETO_CLIPPED;
    int nOldMode         = SetBkMode   ( hDC, OPAQUE );
    COLORREF crTextColor = SetTextColor( hDC, GetSysColor( COLOR_BTNTEXT ) );
    COLORREF crBkColor   = SetBkColor  ( hDC, GetSysColor( COLOR_BTNFACE ) );

    // Draw the hilites
    if (hbrHilite)
        {
        HGDIOBJ hOldBrush = SelectObject( hDC, hbrHilite );

        if (hOldBrush)
            {
            PatBlt( hDC, rect.right, rect.bottom, -(rect.Width() - CX_BORDER),
                                                        -CY_BORDER, PATCOPY );
            PatBlt( hDC, rect.right, rect.bottom, -CX_BORDER,
                                      -(rect.Height() - CY_BORDER), PATCOPY );
            SelectObject( hDC, hOldBrush );
            }
        }

    if (hbrShadow)
        {
        HGDIOBJ hOldBrush = SelectObject( hDC, hbrShadow );

        if (hOldBrush)
            {
            PatBlt( hDC, rect.left, rect.top, rect.Width(), CY_BORDER, PATCOPY );
            PatBlt( hDC, rect.left, rect.top,
                                   CX_BORDER, rect.Height(), PATCOPY );
            SelectObject( hDC, hOldBrush );
            }
        }

    // We need to adjust the rect for the ExtTextOut, and then adjust it back
    // just support left justified text
    if (lpszText != NULL && !(nStyle & SBPS_DISABLED))
        {
        CRect rectText( rect );

        rectText.InflateRect( -2 * CX_BORDER, -CY_BORDER );

        // adjust left edge for indented Text
        rectText.left += iIndentText;

            // align on bottom (since descent is more important than ascent)
        SetTextAlign( hDC, TA_LEFT | TA_BOTTOM );

        if (miSlackSpace > 0)
            rectText.InflateRect( 0, -(miSlackSpace / 2) );

        ExtTextOut( hDC, rectText.left, rectText.bottom,
                 nOpts, &rectText, lpszText, lstrlen( lpszText ), NULL );
        }

    SetTextColor( hDC, crTextColor );
    SetBkColor  ( hDC, crBkColor   );
    }

/******************************************************************************/

BOOL CStatBar::SetText(LPCTSTR szText)
    {
    BOOL bRC = TRUE;

    if (theApp.InEmergencyState())
        {
        bRC = FALSE;
        }
    else
        {
        bRC = SetPaneText(0, szText);
        }

    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::SetPosition(const CPoint& pos)
    {
    BOOL bRC = TRUE;
    int cch;
    TCHAR szBuf [20];

    cch = wsprintf(szBuf, TEXT("%d~%d"), pos.x, pos.y);

    for (int i = 0; i < cch; i++)
        if (szBuf[i] == TEXT('~'))
            {
            szBuf[i] = m_cstringPosSeparator[0];
            break;
            }

    ASSERT (cch != 0);

    if (cch != 0)
        {
        bRC = SetPaneText(1, szBuf);
        }
    else
        {
        bRC = FALSE;
        }

    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::SetSize(const CSize& size)
    {
    BOOL bRC = TRUE;
    int cch;
    TCHAR szBuf [20];

    cch = wsprintf( szBuf, TEXT("%d~%d"), size.cx, size.cy );

    for (int i = 0; i < cch; i++)
        if (szBuf[i] == TEXT('~'))
            {
            szBuf[i] = m_cstringSizeSeparator[0];
            break;
            }

    ASSERT (cch != 0);

    if (cch != 0)
        bRC = SetPaneText(2, szBuf);
    else
        bRC = FALSE;

    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::ClearPosition()
    {
    BOOL bRC = TRUE;
    bRC = SetPaneText(1, TEXT(""));  // clear the position
    return bRC;
    }

/******************************************************************************/

BOOL CStatBar::ClearSize()
    {
    BOOL bRC = TRUE;
    bRC = SetPaneText(2, TEXT(""));  // clear the size
    return bRC;
    }


/******************************************************************************/

BOOL CStatBar::Reset()
    {
    return ClearPosition() && ClearSize();
    }

/******************************************************************************/

void CStatBar::OnSysColorChange()
        {
        CStatusBar::OnSysColorChange();
        InvalidateRect(NULL,FALSE);
        }

/******************************************************************************/

void ClearStatusBarSize()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ClearSize();
    }

/******************************************************************************/

void ClearStatusBarPosition()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ClearPosition();
    }

/******************************************************************************/

void SetPrompt(LPCTSTR szPrompt, BOOL bRedrawNow)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->SetText(szPrompt);
    if (bRedrawNow)
        g_pStatBarWnd->UpdateWindow();
    }

/******************************************************************************/

void SetPrompt(UINT nStringID, BOOL bRedrawNow)
    {
        ASSERT(g_pStatBarWnd);
    CString str;
    VERIFY(str.LoadString(nStringID));

    g_pStatBarWnd->SetText(str);

    if (bRedrawNow)
        g_pStatBarWnd->UpdateWindow();
    }

/******************************************************************************/

void ShowStatusBar(BOOL bShow /* = TRUE */)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
    }

/******************************************************************************/

BOOL IsStatusBarVisible()
    {
        ASSERT(g_pStatBarWnd);
    return (g_pStatBarWnd->GetStyle() & WS_VISIBLE) != 0;
    }

/******************************************************************************/

int GetStatusBarHeight()
    {
        ASSERT(g_pStatBarWnd);
    CRect rect;
    g_pStatBarWnd->GetWindowRect(rect);
    return rect.Height();
    }

/******************************************************************************/

void InvalidateStatusBar(BOOL bErase /* = FALSE */)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->Invalidate(bErase);
    }

/******************************************************************************/

void ClearStatusBarPositionAndSize()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->ClearSize();
    g_pStatBarWnd->ClearPosition();
    }

/******************************************************************************/

void ResetStatusBar()
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->Reset();
    }

/******************************************************************************/

void SetStatusBarPosition(const CPoint& pos)
    {
        ASSERT(g_pStatBarWnd);
        if ( ::IsWindow(g_pStatBarWnd->m_hWnd) )
        g_pStatBarWnd->SetPosition(pos);
    }

/******************************************************************************/

void SetStatusBarSize(const CSize& size)
    {
        ASSERT(g_pStatBarWnd);
    if ( ::IsWindow( g_pStatBarWnd->m_hWnd) )
        g_pStatBarWnd->SetSize(size);
    }

/******************************************************************************/

void SetStatusBarPositionAndSize(const CRect& rect)
    {
        ASSERT(g_pStatBarWnd);
    g_pStatBarWnd->SetPosition(((CRect&)rect).TopLeft());
    g_pStatBarWnd->SetSize(rect.Size());
    }

/******************************************************************************/

LRESULT CStatBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
        LRESULT lRes = CStatusBar::OnSizeParent(wParam, lParam);

        return(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\xfer\zmodem.h ===
/* Zmodem.h -- exported constants, variables and functions for zmodem
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 8/27/01 9:14a $
 */
/*
 *   Z M O D E M . H     Manifest constants for ZMODEM
 *    application to application file transfer protocol
 *    05-23-87  Chuck Forsberg Omen Technology Inc
 */
#define ZPAD '*'	/* 052 Padding character begins frames */
#define ZDLE 030	/* Ctrl-X Zmodem escape - `ala BISYNC DLE */
#define ZDLEE (ZDLE^0100)	/* Escaped ZDLE as transmitted */
#define ZBIN 'A'	/* Binary frame indicator */
#define ZHEX 'B'	/* HEX frame indicator */
#define ZBIN32 'C'	/* Binary frame with 32 bit FCS */

/* Frame types (see array "frametypes" in zm.c) */

#define ZRQINIT	0	/* Request receive init */
#define ZRINIT	1	/* Receive init */
#define ZSINIT 2	/* Send init sequence (optional) */
#define ZACK 3		/* ACK to above */
#define ZFILE 4		/* File name from sender */
#define ZSKIP 5		/* To sender: skip this file */
#define ZNAK 6		/* Last packet was garbled */
#define ZABORT 7	/* Abort batch transfers */
#define ZFIN 8		/* Finish session */
#define ZRPOS 9		/* Resume data trans at this position */
#define ZDATA 10	/* Data packet(s) follow */
#define ZEOF 11		/* End of file */
#define ZFERR 12	/* Fatal Read or Write error Detected */
#define ZCRC 13		/* Request for file CRC and response */
#define ZCHALLENGE 14	/* Receiver's Challenge */
#define ZCOMPL 15	/* Request is complete */
#define ZCAN 16		/* Other end canned session with CAN*5 */
#define ZFREECNT 17	/* Request for free bytes on filesystem */
#define ZCOMMAND 18	/* Command from sending program */
#define ZSTDERR 19	/* Output to standard error, data follows */
#define ZBADFMT 20	/* Data packed format error */
#define ZMDM_ACKED	21
#define ZMDM_VIRUS	22
#define ZMDM_REFUSE 23 /* File was unconditinally refused */
#define ZMDM_OLDER  24 /* File refused because it was older */
#define ZMDM_INUSE  25  /* File is currently in use */
#define ZMDM_CARRIER_LOST 26 /* Lost carrier */

/* ZDLE sequences */

#define ZCRCE 'h'	/* CRC next, frame ends, header packet follows */
#define ZCRCG 'i'	/* CRC next, frame continues nonstop */
#define ZCRCQ 'j'	/* CRC next, frame continues, ZACK expected */
#define ZCRCW 'k'	/* CRC next, ZACK expected, end of frame */
#define ZRUB0 'l'	/* Translate to rubout 0177 */
#define ZRUB1 'm'	/* Translate to rubout 0377 */

/* zdlread return values (internal) */
/* -1 is general error, -2 is timeout */

#define GOTOR 0400
#define GOTCRCE (ZCRCE|GOTOR)	/* ZDLE-ZCRCE received */
#define GOTCRCG (ZCRCG|GOTOR)	/* ZDLE-ZCRCG received */
#define GOTCRCQ (ZCRCQ|GOTOR)	/* ZDLE-ZCRCQ received */
#define GOTCRCW (ZCRCW|GOTOR)	/* ZDLE-ZCRCW received */
#define GOTCAN	(GOTOR|030)	/* CAN*5 seen */

/* Byte positions within header array */

#define ZF0	3	/* First flags byte */
#define ZF1	2
#define ZF2	1
#define ZF3	0
#define ZP0	0	/* Low order 8 bits of position */
#define ZP1	1
#define ZP2	2
#define ZP3	3	/* High order 8 bits of file position */

/* Bit Masks for ZRINIT flags byte ZF0 */

#define CANFDX	01	/* Rx can send and receive true FDX */
#define CANOVIO	02	/* Rx can receive data during disk I/O */
#define CANBRK	04	/* Rx can send a break signal */
#define CANCRY	010	/* Receiver can decrypt */
#define CANLZW	020	/* Receiver can uncompress */
#define CANFC32	040	/* Receiver can use 32 bit Frame Check */
#define ESCCTL 0100	/* Receiver expects ctl chars to be escaped */
#define ESC8   0200	/* Receiver expects 8th bit to be escaped */

/* Bit Masks for ZSINIT flags byte ZF0 */

#define TESCCTL 0100	/* Transmitter expects ctl chars to be escaped */
#define TESC8   0200	/* Transmitter expects 8th bit to be escaped */

/* Parameters for ZFILE frame */
/* Conversion options one of these in ZF0 */

#define ZCBIN	1	/* Binary transfer - inhibit conversion */
#define ZCNL	2	/* Convert NL to local end of line convention */
#define ZCRESUM 3	/* Resume interrupted file transfer */
#define ZCRECOV 3	/* Some of the documentation uses this name */

/* Management include options, one of these ored in ZF1 */

#define ZMSKNOLOC	0200	/* Skip file if not present at rx */

/* Management options, one of these ored in ZF1 */

#define ZMMASK	037	/* Mask for the choices below */
#define ZMNEWL	1	/* Transfer if source newer or longer */
#define ZMCRC	2	/* Transfer if different file CRC or length */
#define ZMAPND	3	/* Append contents to existing file (if any) */
#define ZMCLOB	4	/* Replace existing file */
#define ZMNEW	5	/* Transfer if source newer */
	/* Number 5 is alive ... */
#define ZMDIFF	6	/* Transfer if dates or lengths different */
#define ZMPROT	7	/* Protect destination file */

/* Transport options, one of these in ZF2 */

#define ZTLZW	1	/* Lempel-Ziv compression */
#define ZTCRYPT	2	/* Encryption */
#define ZTRLE	3	/* Run Length encoding */

/* Extended options for ZF3, bit encoded */

#define ZXSPARS	64	/* Encoding for sparse file operations */

/* Parameters for ZCOMMAND frame ZF0 (otherwise 0) */
#define ZCACK1	1	/* Acknowledge, then do command */

#define DEFBYTL 	2000000000L

/* Function prototypes */

USHORT zmdm_snd(HSESSION h, int method, int attended, unsigned nfiles, long nbytes);

USHORT zmdm_rcv(HSESSION h, int method, int attended, int single_file);

/* End of ZMODEM.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\bmpstrm.h ===
#ifndef _BMPSTRM_H_
#define _BMPSTRM_H_

class CBmpStream : public IStream
{
protected:
    CBmpStream();
    ~CBmpStream();

public:
    static HRESULT Create(CBmpStream **ppvObject);

    HGLOBAL GetBuffer();
    VOID    SetBuffer(HGLOBAL hBuffer, DWORD dwSize, DWORD dwOffBits);
    VOID    FreeBuffer();
    HRESULT ReAllocBuffer(SIZE_T dwBytes);

public:
    // IUnknown 

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISequentialStream

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
    LONG             m_cRef;
    HGLOBAL          m_hBuffer;
    SIZE_T           m_nSize;
    SIZE_T           m_nPosition;
    BITMAPFILEHEADER m_Header;
};

#endif //_BMPSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\bmobject.h ===
#ifndef __BMOBJECT_H__
#define __BMOBJECT_H__

class CBmObjSequence;

// Get*Prop return type
enum GPT
    {
    invalid,    // Not a known property or disabled
    valid,      // Value is correct
    ambiguous   // Multiple selection with different values
    };

// Selection Object
class CFileBuffer;

class CBitmapObj : public CObject
    {
    DECLARE_DYNCREATE( CBitmapObj )

    public:

    CBitmapObj();

    ~CBitmapObj();

    void Clear();

    void InformDependants( UINT idChange );
    void AddDependant    ( CBitmapObj* newDependant );
    void RemoveDependant ( CBitmapObj* oldDependant );

    // Notification Callback
    void OnInform( CBitmapObj* pChangedSlob, UINT idChange );

    // Property Management
    BOOL SetIntProp (UINT idProp, int val);
    GPT  GetIntProp (UINT idProp, int& val);
    BOOL SetSizeProp(UINT nPropID, const CSize& val);

    BOOL MakeEmpty       ();
    BOOL Import          ( LPCTSTR szFileName );
    BOOL Export          ( LPCTSTR szFileName );

    // Specify the type of header to put on a resource
    typedef enum _PBResType
    {
        rtFile,
        rtDIB,
        rtPaintOLEObj,
        rtPBrushOLEObj,
    } PBResType;

    BOOL ReadResource    ( HGLOBAL hDib );
    BOOL ReadResource    ( CFile* pfile, PBResType rtType = rtFile );
    BOOL WriteResource   ( CFile* pfile, PBResType rtType = rtFile );

#ifdef PCX_SUPPORT
    BOOL ReadPCX         ( CFile* pfile );
    BOOL WritePCX        ( CFile* pfile );
    BOOL PackBuff        ( CFileBuffer *FileBuffer, BYTE *PtrDib, int byteWidth);
#endif


    BOOL CreateImg       ();
    BOOL SaveResource    ( BOOL bClear = TRUE );
    void ReLoadImage     ( CPBDoc* pbDoc );
    void UndoAction      ( CBmObjSequence* pSeq, UINT nActionID );
    void DeleteUndoAction( CBmObjSequence* pSeq, UINT nActionID );
    BOOL FinishUndo      ( const CRect* pRect );

    // Resource data access helpers...
    BOOL    Alloc(); // m_hThing of size m_lMemSize
    void    Free();                 // m_hThing and set m_lMemSize to zero
    void    Zap();  // frees memory and zeros out the file position
                    // information - used to completely empty a resobject

    CString GetDefExtension(int iStringId=0);

    BOOL SetupForIcon( HBITMAP& hBitmap, HBITMAP& hMaskBitmap );

    // Load m_hThing with the resource data from the res file
    inline  BOOL  IsDirty() const { return m_bDirty; }

    void SetDirty(BOOL bDirty = TRUE);

#ifdef  ICO_SUPPORT
    BOOL IsSaveIcon() { return(m_bSaveIcon); }
#endif

    struct IMG* m_pImg;

    // Properties...
    int  m_nWidth;
    int  m_nHeight;
    int  m_nColors;
    int  m_nSaveColors;
#ifdef ICO_SUPPORT
    BOOL m_bSaveIcon;
#endif

#ifdef PCX_SUPPORT
    BOOL m_bPCX;
#endif

    BOOL m_bCompressed;
    BOOL m_nShrink; // 0=crop, 1=shrink, 2=ask

    BOOL   m_bTempName;     // true if not save as m_strFileName yet
    BOOL   m_bDirty;        // true if changed

    HGLOBAL m_hThing;      // in memory resource (must be valid)
    DWORD   m_dwOffBits;     // offset of pixels in m_hThing; packed if 0
    LONG    m_lMemSize;      // size in bytes

    protected:

    CObList m_dependants;
    };

// Standard Slob Notifications
#define SN_DESTROY      0
#define SN_ALL          1

extern int mpncolorsbits[];

void PBGetDefDims(int& pnWidth, int& pnHeight);

#ifndef _WIN32
#define POINTS POINT
#endif

#endif // __BMOBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\cmpmsg.h ===
//////////////////////////////////////////////////////////////////////////
//
//                                CMPMSG.H
//
//  Owner:     HenryB
//  Created:   Dec 9, 1991
//  Revision:
//
//////////////////////////////////////////////////////////////////////////

//
// Composer Message Box routines
//

#define CMPNOSTRING     (WORD)(-1)              // empty/no string

// CmpCenterParent retrieves a window to which a modal dialog should
// be centered (relative center).
//
// NOTE: The return value may be temporary!
//
CWnd* CmpCenterParent();

//
// composer message box, same interface as windows, but you give
// string id's not strings
//
// example: CmpMessageBox( IDS_OUTOFMEMORY, IDS_ERROR, MB_OK );
//
int CmpMessageBox(  WORD    wTextStringID,      // string id of text
                    WORD    wCaptionID,         // string id of caption
                    UINT    nType );            // same as message box

//
// composer message box wrapper for parameterized strings
//
// example: CmpMessageBox2( IDS_NOCONVERT, IDS_ERROR, MB_OK, lpszFrom, lpszInto );
//
int CmpMessageBox2(  WORD    wTextStringID,     // string id of text
                     WORD    wCaptionID,        // string id of caption
                     UINT    nType,             // same as message box
                     LPCTSTR szParam1,           // string for %1 param
                     LPCTSTR szParam2 );         // string for %2 param

//
// composer message box, combines wsprintf, you continue to
// use string ids
//
// example:
//
// CmpMessageBoxPrintf( IDS_CANTOPEN, IDS_ERROR, MB_OK, lpszFileName );
//

extern "C" int CDECL
    CmpMessageBoxPrintf(WORD    wTextStrinID,   // string id of text (format)
                        WORD    wCaptionID,     // string id of caption
                        UINT    nType,          // same as message box
                        ... );                  // wsprintf arguments


int CmpMessageBoxString( CString&   s,
                         WORD       wCaptionID,
                         UINT       nType );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\cmpmsg.cpp ===
#include "stdafx.h"

#include <stdarg.h>

#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "cmpmsg.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

//
//
// CmpCenterParent retrieves a window to which a modal dialog should
// be centered (relative center).
//
// NOTE: The return value may be temporary!
//
CWnd* CmpCenterParent()
    {
    CWnd* pPopupWnd = AfxGetMainWnd();;

    ASSERT(pPopupWnd != NULL);

    if (pPopupWnd->IsKindOf(RUNTIME_CLASS(CMiniFrmWnd)))
        {
        // don't center relative to mini-frame windows
        CWnd* pParentWnd = pPopupWnd->GetParent();

        // instead use parent or main window...
        if (pParentWnd != NULL)
            pPopupWnd = pParentWnd;
        else
            pPopupWnd = theApp.m_pMainWnd;
        }

    return pPopupWnd;
    }

//
// composer message box, same interface as windows, but you give
// string id's not strings
//
// example: CmpMessageBox( IDS_OUTOFMEMORY, IDS_ERROR, MB_OK );
//
int CmpMessageBox(  WORD    wTextStringID,      // string id of text
                    WORD    wCaptionID,         // string id of caption
                    UINT    nType )             // same as message box
    {
    TCHAR FAR*   lpText;
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    if( wTextStringID == CMPNOSTRING )
        lpText = TEXT("");
    else
        {
        VERIFY( sText.LoadString( wTextStringID ) );

        lpText = (TCHAR FAR*)(const TCHAR *)sText;
        }

    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox(lpText, lpCaption, nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, lpText, lpCaption,nType | MB_TASKMODAL);
        }
    }

int CmpMessageBoxString( CString&   s,
                         WORD       wCaptionID,
                         UINT       nType )
    {
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox((const TCHAR *)s, lpCaption,nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, (const TCHAR *)s, lpCaption,nType | MB_TASKMODAL);
        }
    }

int CmpMessageBox2(  WORD    wTextStringID,
                     WORD    wCaptionID,
                     UINT    nType,
                     LPCTSTR szParam1,
                     LPCTSTR szParam2 )
    {
    TCHAR FAR*   lpText;
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    if( wTextStringID == CMPNOSTRING )
        lpText = TEXT("");
    else
        {
        AfxFormatString2( sText, wTextStringID, szParam1, szParam2);

        lpText = (TCHAR FAR*)(const TCHAR *)sText;
        }

    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox(lpText, lpCaption, nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, lpText, lpCaption,nType | MB_TASKMODAL);
        }
    }

//
// composer message box, combines wsprintf, you continue to
// use string ids
//
// example:
//
// CmpMessageBoxPrintf( IDS_CANTOPEN, IDS_ERROR, MB_OK, lpszFileName );
//

#define nLocalBuf 512

extern "C" int CDECL
    CmpMessageBoxPrintf(WORD    wTextStringID,  // string id of text (format)
                        WORD    wCaptionID,     // string id of caption
                        UINT    nType,          // same as message box
                        ... )                   // wsprintf arguments
    {
    TCHAR FAR*   lpText;
    TCHAR FAR*   lpCaption;
    CString     sText, sCaption;
    int         nBuf;
    TCHAR        szBuffer[nLocalBuf];

    va_list args;
    va_start( args, nType );

    if( wCaptionID == CMPNOSTRING )
        lpCaption = NULL;
    else
        {
        VERIFY( sCaption.LoadString( wCaptionID ) );

        lpCaption = (TCHAR FAR*)(const TCHAR *)sCaption;
        }

    if( wTextStringID == CMPNOSTRING )
        lpText = TEXT("");
    else
        {
        VERIFY( sText.LoadString( wTextStringID ) );

        lpText = (TCHAR FAR*)(const TCHAR *)sText;
        }

    nBuf = wvsprintf( szBuffer, lpText, args );

    ASSERT( nBuf < nLocalBuf );
    CWnd *pcWnd = AfxGetMainWnd();

    if (pcWnd != NULL)
        {
        return  pcWnd->MessageBox(szBuffer, lpCaption,nType | MB_TASKMODAL);
        }
    else
        {
        return  ::MessageBox(NULL, szBuffer, lpCaption,nType | MB_TASKMODAL);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\bmpstrm.cpp ===
//
// loadimag.cpp
//
// implementation of the CBmpStream class
//

#include "stdafx.h"
#include "bmpstrm.h"
#include "imaging.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

CBmpStream::CBmpStream()
{
    m_cRef = 1;

    m_hBuffer   = 0;
    m_nSize     = 0;
    m_nPosition = 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CBmpStream::~CBmpStream()
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CBmpStream::Create(CBmpStream **ppvObject)
{
    if (ppvObject == 0)
    {
	    return E_POINTER;
    }

    TRY
    {
        *ppvObject = new CBmpStream;
    }
    CATCH(CMemoryException, e)
    {
        *ppvObject = 0;
    }
    END_CATCH

    if (*ppvObject == 0)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HGLOBAL CBmpStream::GetBuffer()
{
    return m_hBuffer;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

VOID CBmpStream::SetBuffer(HGLOBAL hBuffer, DWORD dwSize, DWORD dwOffBits)
{
    m_hBuffer   = hBuffer;
    m_nSize     = dwSize;
    m_nPosition = 0;

    if (dwOffBits == 0)
    {
        PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

        if (pBuffer)
        {
            dwOffBits = FindDibOffBits(pBuffer);

            GlobalUnlock(m_hBuffer);
        }
    }

    m_Header.bfType      = MAKEWORD('B', 'M');
    m_Header.bfSize      = sizeof(BITMAPFILEHEADER) + dwSize;
    m_Header.bfReserved1 = 0;
    m_Header.bfReserved2 = 0;
    m_Header.bfOffBits   = sizeof(BITMAPFILEHEADER) + dwOffBits;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

VOID CBmpStream::FreeBuffer()
{
    if (m_hBuffer)
    {
        GlobalFree(m_hBuffer);

        m_hBuffer   = 0;
        m_nSize     = 0;
        m_nPosition = 0;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CBmpStream::ReAllocBuffer(SIZE_T dwBytes)
{
    HGLOBAL hBuffer;

    if (m_hBuffer == 0)
    {
        hBuffer = GlobalAlloc(GMEM_MOVEABLE, dwBytes);
    }
    else
    {
        hBuffer = GlobalReAlloc(m_hBuffer, dwBytes, 0);
    }

    if (hBuffer == 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    m_hBuffer = hBuffer;
    m_nSize = dwBytes;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::QueryInterface(REFIID riid, void **ppvObject)
{
    if (ppvObject == 0)
    {
	    return E_POINTER;
    }

    if (riid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObject = (IUnknown*) this;
	    return S_OK;
    }

    if (riid == IID_IStream)
    {
	    AddRef();
	    *ppvObject = (IStream *) this;
	    return S_OK;
    }

    *ppvObject = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CBmpStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CBmpStream::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    if (pcbRead)
    {
        *pcbRead = 0;
    }

    if (m_nPosition > sizeof(m_Header) + m_nSize)
    {
        return S_FALSE;
    }

    if (cb == 0)
    {
        return S_OK;
    }

    if (cb > sizeof(m_Header) + m_nSize - m_nPosition)
    {
        cb = (ULONG) (sizeof(m_Header) + m_nSize - m_nPosition);
    }

    if (m_nPosition < sizeof(m_Header))
    {
        ULONG nBytesToReadInHeader = min(cb, sizeof(m_Header) - m_nPosition);

        CopyMemory(pv, (PBYTE) &m_Header + m_nPosition, nBytesToReadInHeader);

        pv = (PBYTE) pv + nBytesToReadInHeader;

        cb -= nBytesToReadInHeader;

        m_nPosition += nBytesToReadInHeader;

        if (pcbRead)
        {
            *pcbRead += nBytesToReadInHeader;
        }
    }

    if (cb > 0)
    {
        PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

        if (pBuffer == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        CopyMemory(pv, pBuffer + m_nPosition - sizeof(m_Header), cb);

        GlobalUnlock(m_hBuffer);

        m_nPosition += cb;

        if (pcbRead)
        {
            *pcbRead += cb;
        }
    }

    return S_OK;
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    if (pcbWritten)
    {
        *pcbWritten = 0;
    }

    if (cb == 0)
    {
        return S_OK;
    }

    if (m_nSize + sizeof(m_Header) < m_nPosition + cb)
    {
        HRESULT hr = ReAllocBuffer(m_nPosition + cb - sizeof(m_Header));

        if (hr != S_OK)
        {
            return hr;
        }
    }

    if (m_nPosition < sizeof(m_Header))
    {
        ULONG nBytesToWriteInHeader = min(cb, sizeof(m_Header) - m_nPosition);

        CopyMemory((PBYTE) &m_Header + m_nPosition, pv, nBytesToWriteInHeader);

        pv = (PBYTE) pv + nBytesToWriteInHeader;

        cb -= nBytesToWriteInHeader;

        m_nPosition += nBytesToWriteInHeader;

        if (pcbWritten)
        {
            *pcbWritten += nBytesToWriteInHeader;
        }
    }

    if (cb > 0)
    {
        PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

        if (pBuffer == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        CopyMemory(pBuffer + m_nPosition - sizeof(m_Header), pv, cb);

        GlobalUnlock(m_hBuffer);

        m_nPosition += cb;

        if (pcbWritten)
        {
            *pcbWritten += cb;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    switch (dwOrigin)
    { 
        case STREAM_SEEK_SET: 
            m_nPosition = (SIZE_T) dlibMove.QuadPart; 
            break;

        case STREAM_SEEK_CUR: 
            m_nPosition += (SIZE_T) dlibMove.QuadPart; 
            break;

        case STREAM_SEEK_END: 
            m_nPosition = m_nSize - (SIZE_T) dlibMove.QuadPart; 
            break;

        default:
            return E_INVALIDARG;
    }

    if (plibNewPosition)
    {
        plibNewPosition->QuadPart = m_nPosition;
    }

    return S_OK;
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return ReAllocBuffer((SIZE_T) libNewSize.QuadPart);
}
        
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}
    
//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Revert()
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CBmpStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\bmobject.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgfile.h"
#include "colorsrc.h"
#include "undo.h"
#include "props.h"
#include "ferr.h"
#include "cmpmsg.h"
#include "loadimag.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CBitmapObj, CObject )

#include "memtrace.h"

/***************************************************************************/
// Map from the value in CBitmapObj::m_nColors to bits per pixel

int mpncolorsbits [] =
    {
    1, 4, 8, 24
    };

/***************************************************************************/

CBitmapObj::CBitmapObj() : CObject(), m_dependants()
    {
    m_bDirty      = FALSE;
    m_bTempName   = FALSE;
    m_hThing      = NULL;
    m_lMemSize    = 0L;
    m_pImg        = NULL;
    m_nWidth      = 0;
    m_nHeight     = 0;
    m_nColors     = 0;
    m_nSaveColors = -1;
#ifdef ICO_SUPPORT
    m_bSaveIcon   = FALSE;
#endif
#ifdef PCX_SUPPORT
    m_bPCX        = FALSE;
#endif
    m_bCompressed = FALSE;
    m_nShrink     = 0;
    m_dwOffBits   = 0;
    }

/***************************************************************************/

CBitmapObj::~CBitmapObj()
    {
    ASSERT_VALID(this);

    InformDependants( SN_DESTROY );

    if (m_hThing != NULL)
        {
        Free();
        }
    if (m_pImg)
        FreeImg(m_pImg);
    }

/***************************************************************************/

void CBitmapObj::AddDependant( CBitmapObj* newDependant )
    {
    POSITION pos = m_dependants.Find( newDependant );

    if (pos == NULL)
        m_dependants.AddTail( newDependant );
    }

/***************************************************************************/

void CBitmapObj::RemoveDependant( CBitmapObj* oldDependant )
    {
    POSITION pos = m_dependants.Find(oldDependant);

    if (pos != NULL)
        m_dependants.RemoveAt(pos);
    }

/***************************************************************************/

void CBitmapObj::InformDependants( UINT idChange )
    {
    POSITION pos = m_dependants.GetHeadPosition();

    while (pos != NULL)
        {
        CBitmapObj* pSlob = (CBitmapObj*)m_dependants.GetNext(pos);
        pSlob->OnInform(this, idChange);
        }
    }

/***************************************************************************/

void CBitmapObj::OnInform( CBitmapObj* pChangedSlob, UINT idChange )
    {
    if (idChange == SN_DESTROY)
        {
        POSITION pos = m_dependants.Find(pChangedSlob);

        if (pos != NULL)
            m_dependants.RemoveAt(pos);
        }
    }

/***************************************************************************/

void CBitmapObj::SetDirty(BOOL bDirty)
    {
    m_bDirty = bDirty;
    }

/*****************************************************************************/

void CBitmapObj::Zap()
    {
    m_bDirty = FALSE;
    }

/*****************************************************************************/

BOOL CBitmapObj::Alloc()  // m_hThing of size m_lMemSize
    {
    if (m_lMemSize == 0L)
        return FALSE;

    m_hThing = GlobalAlloc(GPTR, m_lMemSize);

    if (m_hThing == NULL)
        {
        theApp.SetMemoryEmergency( TRUE );
        return FALSE;
        }

    return TRUE;
    }

/*****************************************************************************/

void CBitmapObj::Free()             // m_hThing and set m_lMemSize to zero
    {
    if (m_hThing == NULL)
        {
        TRACE(TEXT("Warning: called Free on a CBitmapObj with no thing!\n"));
        return;
        }

    GlobalFree(m_hThing);

    m_hThing   = NULL;
    m_lMemSize = 0;
    }

/***************************************************************************/

CString CBitmapObj::GetDefExtension(int iStringId)
    {
    CString cStringExtension;

    if (iStringId != 0)
        {
        TRY
            {
            cStringExtension.LoadString( iStringId );
            }
        CATCH(CMemoryException,e)
            {
            cStringExtension.Empty();
            }
        END_CATCH
        }
    else
        {
        cStringExtension.Empty();
        }

    return cStringExtension;
    }

void PBGetDefDims(int &pnWidth, int &pnHeight)
{
    // Setup default parameters...
    // Don't use the whole screen, those bitmaps get HUGE
    //
    pnWidth  = GetSystemMetrics( SM_CXSCREEN )/2;
    pnHeight = GetSystemMetrics( SM_CYSCREEN )/2;

    // Check if this is a low memory machine and use a small default bitmap
    // size
    if (GetSystemMetrics(SM_SLOWMACHINE) & 0x0002)
    {
        pnWidth  = 640/2;
        pnHeight = 480/2;
    }
}

/*****************************************************************************/

BOOL CBitmapObj::MakeEmpty()
    {
    PBGetDefDims(m_nWidth, m_nHeight);

    if (theApp.m_sizeBitmap.cx
    &&  theApp.m_sizeBitmap.cy)
        {
        m_nWidth  = theApp.m_sizeBitmap.cx;
        m_nHeight = theApp.m_sizeBitmap.cy;
        }

    if (theApp.m_bEmbedded)
        {
       // make a nice size for embedded objects, lets try for 5 centimeters
        m_nWidth  = theApp.ScreenDeviceInfo.ixPelsPerDM / 2;
        m_nHeight = theApp.ScreenDeviceInfo.iyPelsPerDM / 2;
        }

    //
    // default to 256 colors if not monochrome
    //
    m_nColors = theApp.m_bMonoDevice? 0 : 2;
    m_bDirty  = TRUE;

    return TRUE;
    }

/*****************************************************************************/
// Create and setup an IMG for this resource

BOOL CBitmapObj::CreateImg()
    {
    ASSERT(! m_pImg);

    LONG cXPelsPerMeter = 0;
    LONG cYPelsPerMeter = 0;

    LPSTR lpbi = (LPSTR) GlobalLock(m_hThing); // NOTE: this is NULL for new resources!

    if (lpbi)
        {
        if (IS_WIN30_DIB( lpbi ))
            {
            PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) lpbi;
            m_bCompressed = pbmih->biCompression != BI_RGB;
            cXPelsPerMeter = pbmih->biXPelsPerMeter;
            cYPelsPerMeter = pbmih->biYPelsPerMeter;
            }

        m_nWidth  = (int)DIBWidth ( lpbi );
        m_nHeight = (int)DIBHeight( lpbi );
        m_nColors =   DIBNumColors( lpbi, FALSE );

        if (m_nColors <= 0 || m_nColors > 256)
            m_nColors  = 3;
        else
            if (m_nColors <= 2)
                m_nColors = 0;
            else
                if (m_nColors <= 16)
                    m_nColors  = 1;
                else
                    if (m_nColors <= 256)
                        m_nColors  = 2;
        }

    UINT nColors = (m_nColors? 0: 1);

    m_pImg = ::CreateImg( lpbi ? 0 : m_nWidth, lpbi ? 0 : m_nHeight,
                nColors, nColors, cXPelsPerMeter, cYPelsPerMeter, theApp.m_bPaletted );

    if (! m_pImg)
        {
        TRACE(TEXT("CreateImg failed\n"));

        theApp.SetMemoryEmergency();
        GlobalUnlock(m_hThing);
        return FALSE;
        }

    if (g_pColors)
    {
       g_pColors->ResetColors ((m_nColors==1)?16:256);
    }

    m_pImg->cxWidth  = m_nWidth;
    m_pImg->cyHeight = m_nHeight;

    if (! lpbi)
        {
        nColors = m_pImg->cPlanes * m_pImg->cBitCount;

        //FEATURE - Shouldn't this be " == 0 || == 1" ??
        //Half a page up negative values == TRUE color!

                //This shell game with the values isn't very good...

        if (nColors <= 1)
            m_nColors = 0;
        else
            if (nColors <= 4)
                m_nColors = 1;
            else
                if (nColors <= 8)
                    m_nColors = 2;
                else // 24-bit image
                    m_nColors = 3;
        }

    m_pImg->m_pBitmapObj = this;
    m_pImg->bDirty       = m_bDirty;

   if (lpbi)
        {
        // Load the bitmap/icon/cursor...
        HBITMAP hbm = DIBToDS( lpbi, m_dwOffBits, m_pImg->hDC );

        if (! hbm)
            {
            theApp.SetMemoryEmergency();
            GlobalUnlock(m_hThing);
            return FALSE;
            }

        m_pImg->hBitmap    = hbm;
        m_pImg->hBitmapOld = (HBITMAP)::SelectObject( m_pImg->hDC, hbm );
        }

        if ( theApp.m_bPaletted)
        // If LoadImage was used && paletted
                {
                // Create the Palette from the dib section instead.
        m_pImg->m_pPalette = PaletteFromDS(m_pImg->hDC);
                }

    theApp.m_pPalette = NULL;

    if (m_pImg->m_pPalette && theApp.m_bPaletted)
        {
        m_pImg->m_hPalOld = SelectPalette( m_pImg->hDC,
                                    (HPALETTE)m_pImg->m_pPalette->m_hObject,
                                              FALSE );
        RealizePalette( m_pImg->hDC );

        theApp.m_pPalette = m_pImg->m_pPalette;
        }
    else
        if (m_pImg->m_pPalette)
            {
            delete m_pImg->m_pPalette;
            m_pImg->m_pPalette = NULL;
            m_pImg->m_hPalOld  = NULL;
            }

    if (g_pColors)
        g_pColors->SetMono( ! m_nColors );

    GlobalUnlock(m_hThing);

    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::Export(const TCHAR* szFileName)
    {
    // If the file already exists and we aren't dirty, then don't bother
    // saving, just return...
    CFileStatus fStat;
    CString strFullName;

    MkFullPath( strFullName, (const TCHAR*)szFileName );

    if (CFile::GetStatus( strFullName, fStat ) && ! m_bDirty)
        return TRUE;

    CFile file;

    CFileException e;
    CFileSaver saver( szFileName );

    if (! saver.CanSave())
        return FALSE;

    theApp.SetFileError( IDS_ERROR_EXPORT, CFileException::none, szFileName );

    if (! OpenSubFile( file, saver, CFile::modeWrite
                                  | CFile::modeCreate
                                  | CFile::typeBinary, &e ))
        {
        theApp.SetFileError( IDS_ERROR_EXPORT, e.m_cause );
        return FALSE;
        }

    BOOL bWritten = FALSE;

    TRY
        {
#ifdef PCX_SUPPORT
        if (m_bPCX)
            bWritten = WritePCX( &file );
        else
#endif
            bWritten = WriteResource( &file );

        file.Close();
        }
    CATCH( CFileException, ex )
        {
        file.Abort();
        theApp.SetFileError( IDS_ERROR_EXPORT, ex->m_cause );
        return FALSE;
        }
    END_CATCH

    if (bWritten)
        bWritten = saver.Finish();
    else
                   saver.Finish();

    return bWritten;
    }

typedef union _BITMAPHEADER
{
        BITMAPINFOHEADER bmi;
        BITMAPCOREHEADER bmc;
} BITMAPHEADER, *LPBITMAPHEADER;

inline WORD PaletteSize(LPBITMAPHEADER lpHdr) {return(PaletteSize((LPSTR)lpHdr));}
inline WORD DIBNumColors(LPBITMAPHEADER lpHdr) {return(DIBNumColors((LPSTR)lpHdr));}
inline DWORD DIBWidth(LPBITMAPHEADER lpHdr) {return(DIBWidth((LPSTR)lpHdr));}
inline DWORD DIBHeight(LPBITMAPHEADER lpHdr) {return(DIBHeight((LPSTR)lpHdr));}

/*****************************************************************************/

BOOL CBitmapObj::WriteResource( CFile* pfile, PBResType rtType )
    {
    BOOL bPBrushOLEHeader = (rtType == rtPBrushOLEObj);
    BOOL bFileHeader = (rtType == rtFile)|| (rtType == rtPaintOLEObj) || bPBrushOLEHeader;

    if (m_pImg == NULL)
        {
        // The image has not been loaded, so we'll just copy the
        // original out to the file...
        ASSERT( m_hThing );

        if (! m_hThing)
            return FALSE;
        }
    else
        {
        // The image has been loaded and may have been edited, so
        // we'll convert it back to a dib to save...
        if (! m_hThing)
            SaveResource( FALSE );

        if (! m_hThing)
            return FALSE;
        }

    LPBITMAPHEADER lpDib    = (LPBITMAPHEADER)GlobalLock(m_hThing);
    DWORD dwLength = m_lMemSize;
    DWORD dwWriteLength = dwLength;
    DWORD dwHeadLength = 0;

        struct _BMINFO
        {
                BITMAPINFOHEADER hdr;
                RGBQUAD rgb[256];
        } bmInfo;

        LPBITMAPHEADER lpOldHdr = lpDib;
        LPBITMAPHEADER lpNewHdr = lpOldHdr;

        DWORD dwOldHdrLen = lpOldHdr->bmi.biSize + PaletteSize(lpOldHdr);
        DWORD dwNewHdrLen = dwOldHdrLen;

    if (bPBrushOLEHeader)
        {
                if (!IS_WIN30_DIB(lpDib))
                {
                        LPBITMAPCOREINFO lpCoreInfo = (LPBITMAPCOREINFO)(&lpOldHdr->bmc);
                        memset(&bmInfo.hdr, 0, sizeof(bmInfo.hdr));
                        bmInfo.hdr.biSize = sizeof(bmInfo.hdr);
                        bmInfo.hdr.biWidth  = lpCoreInfo->bmciHeader.bcWidth;
                        bmInfo.hdr.biHeight = lpCoreInfo->bmciHeader.bcHeight;
                        bmInfo.hdr.biPlanes   = lpCoreInfo->bmciHeader.bcPlanes;
                        bmInfo.hdr.biBitCount = lpCoreInfo->bmciHeader.bcBitCount;
                        bmInfo.hdr.biCompression = BI_RGB;

                        for (int i=DIBNumColors(lpOldHdr)-1; i>=0; --i)
                        {
                                bmInfo.rgb[i].rgbBlue  = lpCoreInfo->bmciColors[i].rgbtBlue;
                                bmInfo.rgb[i].rgbGreen = lpCoreInfo->bmciColors[i].rgbtGreen;
                                bmInfo.rgb[i].rgbRed   = lpCoreInfo->bmciColors[i].rgbtRed;
                                bmInfo.rgb[i].rgbReserved = 0;
                        }

                        lpNewHdr = (LPBITMAPHEADER)(&bmInfo);
                        dwNewHdrLen = lpNewHdr->bmi.biSize + PaletteSize(lpNewHdr);
                }

                dwWriteLength += dwNewHdrLen - dwOldHdrLen;
                dwLength      += dwNewHdrLen - dwOldHdrLen;

                if (bFileHeader)
                {
       #ifdef ICO_SUPPORT
                        if (IsSaveIcon())
                        {
                                dwHeadLength = sizeof(ICONFILEHEADER);
                                dwWriteLength += dwHeadLength;
                        }
                        else
       #endif
                        {
                                dwHeadLength = sizeof(BITMAPFILEHEADER);
                                dwWriteLength += dwHeadLength;

                                // PBrush rounded up to 32 bytes (I don't know why)
                                dwWriteLength = (dwWriteLength+31) & ~31;
                        }
                }

        pfile->Write( &dwWriteLength, sizeof( dwWriteLength ));
        }

    if (bFileHeader)
        {
                // Icon support is not in application anymore, right?
    #ifdef ICO_SUPPORT
        if (IsSaveIcon())
            {
            ICONFILEHEADER hdr;

            hdr.icoReserved      = 0;
            hdr.icoResourceType  = 1;
            hdr.icoResourceCount = 1;

            pfile->Write( &hdr, sizeof( ICONFILEHEADER ) );
            pfile->Seek( sizeof( ICONDIRENTRY ), CFile::current );
            }
        else
    #endif
            {
            BITMAPFILEHEADER hdr;

            hdr.bfType      = ((WORD)('M' << 8) | 'B');
            hdr.bfSize      = dwLength + sizeof( BITMAPFILEHEADER );
            hdr.bfReserved1 = 0;
            hdr.bfReserved2 = 0;
            hdr.bfOffBits   = (DWORD)sizeof(hdr)
                            + lpNewHdr->bmi.biSize
                            + PaletteSize(lpNewHdr);

            pfile->Write( &hdr, sizeof( hdr ));
            }
        }

        pfile->Write(lpNewHdr, dwNewHdrLen);

    BYTE* hp  = ((BYTE*)lpDib) + dwOldHdrLen;
        // We subtract the new header length because we have already translated
        // dwLength to the new size
    DWORD dwWrite   = dwLength - dwNewHdrLen;
    DWORD dwIconPos = pfile->GetPosition();;

    while (dwWrite > 0)
        {
        UINT cbWrite = (UINT)min( dwWrite, 16384 );

        pfile->Write( (LPVOID)hp, cbWrite );

        hp      += cbWrite;
        dwWrite -= cbWrite;
        }

        dwWriteLength -= dwHeadLength;
        if (dwWriteLength > dwLength)
        {
                // We rounded up to 32 bytes above, so this should always be < 32
                ASSERT(dwWriteLength-dwLength < 32);

                DWORD dwZeros[] =
                {
                        0, 0, 0, 0, 0, 0, 0, 0,
                } ;

                pfile->Write( dwZeros, dwWriteLength-dwLength );
        }

    ASSERT( dwWrite == 0 );

        // Icon support is not in application anymore, right?
   #ifdef ICO_SUPPORT
    if (IsSaveIcon())
        {
        DWORD nextPos = pfile->GetPosition();

        pfile->Seek( (bFileHeader? sizeof( ICONFILEHEADER ): 0), CFile::begin );

        ICONDIRENTRY dir;

        dir.nWidth       = (BYTE)DIBWidth    ( lpDib );
        dir.nHeight      = (BYTE)DIBHeight   ( lpDib ) / 2;
        dir.nColorCount  = (BYTE)DIBNumColors( lpDib );
        dir.bReserved    = 0;
        dir.wReserved1   = 0;
        dir.wReserved2   = 0;
        dir.icoDIBSize   = dwLength;
        dir.icoDIBOffset = dwIconPos;

        pfile->Write( &dir, sizeof( ICONDIRENTRY ) );
        pfile->Seek( nextPos, CFile::begin );
        }
    else
   #endif
        m_bDirty = FALSE;

    pfile->Flush();

    GlobalUnlock(m_hThing);

    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::Import( LPCTSTR szFileName )
    {
    CFile          file;
    CFileException e;

    theApp.SetFileError( IDS_ERROR_READLOAD, CFileException::none, szFileName );

    if (! file.Open( szFileName, CFile::modeRead | CFile::typeBinary, &e ))
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, e.m_cause );
        return FALSE;
        }

    BOOL bGoodFile = TRUE;


    TRY
        {
        bGoodFile = ReadResource( &file );
        file.Close();
        }
    CATCH(CFileException, ex)
        {
        file.Abort();
        bGoodFile = FALSE;
        }
    END_CATCH

    if (!bGoodFile)
        {
        HGLOBAL hDib;

        if (hDib = LoadDIBFromFile(szFileName, &theApp.m_guidFltTypeUsed))
            {
            bGoodFile = ReadResource(hDib);

            if (bGoodFile)
                {
                theApp.SetFileError(0, CFileException::none);
                }
            else
                {
                theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp);
                }
            }
        }

    return bGoodFile;
    }

/*****************************************************************************/

BOOL CBitmapObj::ReadResource( CFile* pfile, PBResType rtType )
    {

    BOOL bPBrushOLEHeader = (rtType == rtPBrushOLEObj);
    BOOL bFileHeader = (rtType == rtFile)
     || (rtType == rtPaintOLEObj)|| bPBrushOLEHeader;

    DWORD dwLength = pfile->GetLength();
    // special case zero length files.
    if (! dwLength)
        {
        if (m_hThing)
            Free();

        m_bDirty = TRUE;

        return TRUE;
        }

        if (bPBrushOLEHeader)
        {
                DWORD dwReadLen;

                if (pfile->Read( &dwReadLen, sizeof( dwReadLen )) != sizeof( dwReadLen )
                        || dwReadLen > dwLength)
                {
                        theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
                        return FALSE;
                }
                dwLength -= sizeof(dwReadLen);
        }

        m_dwOffBits = 0;

    if (bFileHeader)
        {
        BITMAPFILEHEADER hdr;

        if (pfile->Read( &hdr, sizeof( hdr )) != sizeof( hdr ))
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
            return FALSE;
            }


        if (hdr.bfType != ((WORD)('M' << 8) | 'B'))
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
            return FALSE;
            }


        dwLength -= sizeof( hdr );

        // Store the offset from the beginning of the BITMAPINFO
        if (hdr.bfOffBits)
        {
            m_dwOffBits = hdr.bfOffBits - sizeof(hdr);
        }
        else
        {
            m_dwOffBits = 0;
        }


       }

    if (m_hThing != NULL)
        Free();

    m_lMemSize = dwLength;

    if (! Alloc())
        return FALSE;

    ASSERT( m_hThing );

    PVOID lpvThing = GlobalLock(m_hThing);

    BYTE* hp = (BYTE*)lpvThing;

    while (dwLength > 0)
        {
        UINT cbRead = (UINT)min( dwLength, 16384 );

        if (pfile->Read( (void FAR*)hp, cbRead ) != cbRead)
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrReadFailed );
            GlobalUnlock(m_hThing);
            return FALSE;
            }

        dwLength -= cbRead;
        hp       += cbRead;
        }

    ASSERT( dwLength == 0 );

    //
    // Calculate the bits offset because the BITMAPFILEHEADER had 0
    //
    if (!m_dwOffBits)
    {
        m_dwOffBits = (DWORD)(FindDIBBits ((LPSTR)lpvThing, 0) -
	                      (LPSTR)lpvThing);
    }

    GlobalUnlock(m_hThing);
    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::ReadResource( HGLOBAL hDib )
    {
    LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) GlobalLock(hDib);

    DWORD dwSizeImage;

    if (lpbi == NULL || lpbi->biSize != sizeof(BITMAPINFOHEADER))
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, ferrNotValidBmp );
        return FALSE;
        }

    m_dwOffBits = lpbi->biSize + lpbi->biClrUsed * sizeof(RGBQUAD);

    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        m_dwOffBits += (1 << lpbi->biBitCount) * sizeof(RGBQUAD);

    if (lpbi->biSizeImage) 
    {
        lpbi->biSizeImage = abs(lpbi->biSizeImage);
        dwSizeImage = lpbi->biSizeImage;
    }
    else
    {
        dwSizeImage = abs(lpbi->biHeight) * ((lpbi->biWidth*lpbi->biBitCount+31)&~31)/8;
    }

    if (m_hThing != NULL)
        Free();

    m_lMemSize = m_dwOffBits + dwSizeImage;

    m_hThing = hDib;

    GlobalUnlock(hDib);

    return TRUE;
    }

/*****************************************************************************/

void CBitmapObj::ReLoadImage( CPBDoc* pbDoc )
    {
    FreeImg( m_pImg );
    CleanupImgUndo();
    CleanupImgRubber();
    m_pImg = NULL;

    if (CreateImg())
        {
        POSITION pos   = pbDoc->GetFirstViewPosition();
        CPBView* pView = (CPBView*)pbDoc->GetNextView( pos );

        if (pView)
            {
            pView->m_pImgWnd->SetImg( m_pImg );
            pbDoc->UpdateAllViews( pView );
            InvalImgRect( m_pImg, NULL );
            }
        }
    }

/*****************************************************************************/

void SwapBitmaps(HDC hDC1, int x1, int y1, int wid, int hgt,
        HDC hDC2, int x2, int y2, CPalette* pPalette)
{
#if 0
// We would like to just XOR 3 times to swap, but sometimes the middle of the
// palette is empty, so we cannot
    BitBlt(m_pImg->hDC, rect.left   , rect.top,
                        rect.Width(), rect.Height(), hDC, 0, 0, DSx);
    BitBlt(hDC, 0, 0, rect.Width(), rect.Height(), m_pImg->hDC,
                                           rect.left, rect.top, DSx);
    BitBlt(m_pImg->hDC, rect.left, rect.top, rect.Width(), rect.Height(),
                                                     hDC, 0, 0, DSx);
#else
        CDC dcTemp;

        CDC dc1, dc2;
        dc1.Attach(hDC1);
        dc2.Attach(hDC2);



        BOOL bSuccess = dcTemp.CreateCompatibleDC(&dc1);

        // Don't create a bitmap that is too large, or we will spend all our time
        // swapping
        int hgtTemp = 0x10000/wid;
        hgtTemp = min(hgt, max(1, hgtTemp));

        CBitmap bmTemp;
        bSuccess = bSuccess && bmTemp.CreateCompatibleBitmap(&dc1, wid, hgtTemp);
        bSuccess = bSuccess && dcTemp.SelectObject(&bmTemp)!=NULL;

        if (!bSuccess)
        {
                // Make sure the DC's do not get deleted
                dc1.Detach();
                dc2.Detach();
                return;
        }

        if (pPalette)
        {
                dcTemp.SelectPalette(pPalette, TRUE);
                dcTemp.RealizePalette();
        }

        int yTemp;
        for (yTemp=0; yTemp<hgt; yTemp+=hgtTemp)
        {
                hgtTemp = min(hgtTemp, hgt-yTemp);

                dcTemp.BitBlt(0, 0, wid, hgtTemp, &dc1, x1, y1+yTemp, SRCCOPY);
                dc1.BitBlt(x1, y1+yTemp, wid, hgtTemp, &dc2   , x2, y2+yTemp, SRCCOPY);
                dc2.BitBlt(x2, y2+yTemp, wid, hgtTemp, &dcTemp, 0 , 0, SRCCOPY);
        }

        // Make sure the DC's do not get deleted
        dc1.Detach();
        dc2.Detach();

        // Note that I explicitly delete the DC first, so I do not have to worry
        // about selecting old objects back in
        dcTemp.DeleteDC();
#endif
}

void CBitmapObj::UndoAction( CBmObjSequence* pSeq, UINT nActionID )
    {
    switch (nActionID)
        {
        default:
            break;

        case A_ImageChange:

            if (((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
            ||   (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
               && theImgBrush.m_pImg != NULL)
                {
                HideBrush();
                InvalImgRect( theImgBrush.m_pImg, NULL ); // hide tracker
                theImgBrush.m_pImg = NULL;
                }

            int     cb;
            CRect   rect;
            HBITMAP hImgBitmap;

            pSeq->RetrieveInt( cb );

            ASSERT(cb == sizeof( CRect ) + sizeof( hImgBitmap  ));

            pSeq->RetrieveRect( rect );

            int nCursor = pSeq->m_nCursor;

            pSeq->Retrieve( (BYTE*)&hImgBitmap, sizeof( hImgBitmap ) );

            // Wipe out the old handles since we're reusing them in the
            // new record and we don't what them deleted when this record
            // is removed!
            memset(&pSeq->ElementAt(nCursor), 0, sizeof( hImgBitmap ));

            // Perform undo using these parameters...

            SetupRubber(m_pImg);
            SetUndo(m_pImg); // For redo...
            HideBrush();

            ASSERT(m_pImg != NULL);

            HDC hDC = CreateCompatibleDC(m_pImg->hDC);

            if (hDC == NULL)
                {
                theApp.SetGdiEmergency();
                return;
                }

            HPALETTE hOldPalette = NULL;
            HBITMAP  hOldBitmap  = (HBITMAP)SelectObject(hDC, hImgBitmap);

            ASSERT(hOldBitmap != NULL);

            if (m_pImg->m_pPalette)
                {
                hOldPalette = SelectPalette( hDC, (HPALETTE)m_pImg->m_pPalette->m_hObject,
                                                   FALSE ); // Background ??
                RealizePalette( hDC );
                }

            // Three blits here swap the image and the undo bits, that
            // way the undo bits are set up for a redo!

            ASSERT(m_pImg->hDC != NULL);
            SwapBitmaps(m_pImg->hDC, rect.left, rect.top,
                rect.Width(), rect.Height(), hDC, 0, 0, m_pImg->m_pPalette);

            if (hOldPalette)
                SelectPalette( hDC, hOldPalette, FALSE ); // Background ??

            SelectObject(hDC, hOldBitmap);
            DeleteDC(hDC);

            InvalImgRect (m_pImg, &rect);
            CommitImgRect(m_pImg, &rect);

            // Record the redo information...

            theUndo.Insert((BYTE*)&hImgBitmap, sizeof (hImgBitmap));
            theUndo.InsertRect(rect);
            theUndo.InsertInt(sizeof (CRect) + sizeof (hImgBitmap));
            theUndo.InsertInt(A_ImageChange);
            theUndo.InsertPtr(m_pImg->m_pBitmapObj);
            theUndo.InsertByte(CUndoBmObj::opAction);

            break;
        }
    }

/*****************************************************************************/

void CBitmapObj::DeleteUndoAction(CBmObjSequence* pSeq, UINT nActionID)
    {
    switch (nActionID)
        {
        default:
            break;

        case A_ImageChange:
            CRect rect;
            HBITMAP hImgBitmap;

            pSeq->RetrieveRect(rect);
            pSeq->Retrieve((BYTE*)&hImgBitmap, sizeof (hImgBitmap));

            if (hImgBitmap != NULL)
                DeleteObject(hImgBitmap);
            break;
        }
    }

/*****************************************************************************/

BOOL CBitmapObj::FinishUndo(const CRect* pRect)
    {
    ASSERT( g_hUndoImgBitmap );

    CRect rect;
    if (pRect == NULL)
        rect.SetRect(0, 0, m_pImg->cxWidth, m_pImg->cyHeight);
    else
        rect = *pRect;

    HDC      hDC1 = NULL;
    HDC      hDC2 = NULL;
    HPALETTE hOldPalette  = NULL;
    HPALETTE hOldPalette2 = NULL;
    HBITMAP  hImgBitmap  = NULL;
    HBITMAP  hOldBitmap1;
    HBITMAP  hOldBitmap2;

    if (rect.left >= rect.right || rect.top >= rect.bottom)
        {
        // Not an error, just nothing to do...
        return TRUE;
        }

    hImgBitmap = CreateCompatibleBitmap( m_pImg->hDC, rect.Width(), rect.Height() );

    if (hImgBitmap == NULL)
        goto LError;

    if ((hDC1 = CreateCompatibleDC(m_pImg->hDC)) == NULL)
        goto LError;

    if ((hDC2 = CreateCompatibleDC(m_pImg->hDC)) == NULL)
        goto LError;

    if (m_pImg->m_pPalette)
        {
        hOldPalette = SelectPalette(hDC1, (HPALETTE)m_pImg->m_pPalette->m_hObject, FALSE );
        RealizePalette( hDC1 );

        hOldPalette2 = SelectPalette(hDC2, (HPALETTE)m_pImg->m_pPalette->m_hObject, FALSE );
        RealizePalette( hDC2 );
        }

    VERIFY((hOldBitmap1 = (HBITMAP)SelectObject(hDC1,       hImgBitmap)) != NULL);
    VERIFY((hOldBitmap2 = (HBITMAP)SelectObject(hDC2, g_hUndoImgBitmap)) != NULL);

    BitBlt(hDC1, 0, 0, rect.Width(), rect.Height(),
           hDC2,       rect.left   , rect.top, SRCCOPY);

    SelectObject(hDC1, hOldBitmap1);
    SelectObject(hDC2, hOldBitmap2);

    if (hOldPalette != NULL)
        {
        ::SelectPalette(hDC1, hOldPalette, FALSE ); // Background ??
        }
    if (hOldPalette2 != NULL)
        {
        ::SelectPalette(hDC2, hOldPalette2, FALSE ); // Background ??
        }

    DeleteDC(hDC1);
    DeleteDC(hDC2);

    theUndo.BeginUndo( IDS_UNDO_PAINTING );

    theUndo.Insert((BYTE*)&hImgBitmap , sizeof (hImgBitmap));
    theUndo.InsertRect(rect);
    theUndo.InsertInt(sizeof (CRect) + sizeof (hImgBitmap));
    theUndo.InsertInt(A_ImageChange);
    theUndo.InsertPtr(this);
    theUndo.InsertByte(CUndoBmObj::opAction);

    theUndo.EndUndo();

    // NOTE: At this point, we could free the undo bitmaps, but instead
    // they are left around for next time...

    return TRUE;

LError:

    if (hImgBitmap != NULL)
        DeleteObject(hImgBitmap);

    if (hDC1 != NULL)
        DeleteDC(hDC1);

    if (hDC2 != NULL)
        DeleteDC(hDC2);

    // REVIEW: Since we couldn't allocate something here, there will
    // be no way to undo the last operation...  What should we do?
    // Chances are, the system is so low on memory, a message box
    // giving an option might even fail.
    //
    // For now, let's just beep to try to tell the user that whatever
    // just happend can't be undone.  Also, free the image sized bitmaps
    // so the system has a little free memory.

    CleanupImgUndo();

    MessageBeep(0);

    #ifdef _DEBUG
    TRACE(TEXT("Not enough memory to undo image change!\n"));
    #endif

    return FALSE;
    }


/*****************************************************************************/

BOOL CBitmapObj::SetIntProp(UINT nPropID, int val)
    {
    CWaitCursor waitCursor; // these all take awhile!

    switch (nPropID)
        {
        case P_Width:
            return SetSizeProp( P_Size, CSize( val, m_nHeight ) );
            break;

        case P_Height:
            return SetSizeProp( P_Size, CSize( m_nWidth, val ) );
            break;

        case P_Colors:
            if (CImgTool::GetCurrentID() == IDMB_PICKTOOL
            ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
                {
                CommitSelection( TRUE );
                theImgBrush.m_pImg = NULL;
                }

            SetUndo( m_pImg );
            FinishUndo( NULL );

            // Perform the color-count conversion with DIBs
            DWORD dwSize;

            ::SelectObject( m_pImg->hDC, m_pImg->hBitmapOld );

            LPSTR lpDib = (LPSTR) DibFromBitmap( 
                m_pImg->hBitmap, BI_RGB, m_pImg->cPlanes * m_pImg->cBitCount,
                m_pImg->m_pPalette, NULL, dwSize, 
                m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter );

            ::SelectObject( m_pImg->hDC, m_pImg->hBitmap );

            if (lpDib == NULL)
                {
                theApp.SetGdiEmergency();
                return FALSE;
                }

            // Make a new palette appropriate for this colors setting
            CPalette* pNewPalette = NULL;

            int iPlanes = (val? 1: ::GetDeviceCaps( m_pImg->hDC, PLANES    ));
            int iBitCnt = (val? 1: ::GetDeviceCaps( m_pImg->hDC, BITSPIXEL ));
            int iColors = iPlanes * iBitCnt;

            val = 3;

            if (theApp.m_bPaletted)
                switch (iColors)
                    {
                    case 1:
                        pNewPalette = GetStd2Palette();
                        break;

                    case 4:
                        pNewPalette = GetStd16Palette();
                        break;

                    case 8:
                        pNewPalette = GetStd256Palette();
                        break;
                    }

            switch (iColors)
                {
                case 8:
                    val = 2;
                    break;

                case 4:
                    val = 1;
                    break;

                case 1:
                    val = 0;
                    break;
                }

            HBITMAP hTmpBitmap = CreateBitmap( 1, 1, iPlanes, iBitCnt, NULL );
            HBITMAP hNewBitmap = CreateBitmap( m_pImg->cxWidth,
                                               m_pImg->cyHeight,
                                               iPlanes, iBitCnt, NULL );
            if (! hTmpBitmap || ! hNewBitmap)
                {
                FreeDib( lpDib );

                if (hTmpBitmap)
                    ::DeleteObject( hTmpBitmap );

                if (hNewBitmap)
                    ::DeleteObject( hNewBitmap );

                if (pNewPalette)
                    delete pNewPalette;

                theApp.SetGdiEmergency();
                return FALSE;
                }

            HPALETTE hPalOld = NULL;

            ::SelectObject( m_pImg->hDC, hTmpBitmap );

            if (pNewPalette)
                {
                hPalOld = ::SelectPalette( m_pImg->hDC, (HPALETTE)pNewPalette->m_hObject, FALSE );
                ::RealizePalette( m_pImg->hDC );
                }

            int iLinesDone = SetDIBits( m_pImg->hDC, hNewBitmap, 0,
                                        m_pImg->cyHeight,
                                        FindDIBBits( lpDib ),
                                        (LPBITMAPINFO)lpDib, DIB_RGB_COLORS );
            FreeDib( lpDib );

            if (iLinesDone != m_pImg->cyHeight)
                {
                ::SelectObject( m_pImg->hDC, m_pImg->hBitmap );

                if (hPalOld)
                    {
                    ::SelectPalette( m_pImg->hDC, hPalOld, FALSE );
                    ::RealizePalette( m_pImg->hDC );

                    delete pNewPalette;
                    }

                ::DeleteObject( hTmpBitmap );
                ::DeleteObject( hNewBitmap );

                theApp.SetGdiEmergency();

                return FALSE;
                }
            m_pImg->cPlanes   = iPlanes;
            m_pImg->cBitCount = iBitCnt;

            m_nColors = val;

            ::SelectObject( m_pImg->hDC, hNewBitmap );
            ::DeleteObject( m_pImg->hBitmap );

            m_pImg->hBitmap = hNewBitmap;

            if (m_pImg->m_pPalette)
                {
                if (! pNewPalette)
                    {
                    ::SelectPalette( m_pImg->hDC, m_pImg->m_hPalOld, FALSE );
                    m_pImg->m_hPalOld = NULL;
                    }
                delete m_pImg->m_pPalette;
                }

            m_pImg->m_pPalette = pNewPalette;
             theApp.m_pPalette = pNewPalette;

            ::DeleteObject( hTmpBitmap );

            DirtyImg( m_pImg );
            InvalImgRect( m_pImg, NULL );

            // The rubber-banding bitmap is now invalid...
            if (m_pImg == pRubberImg)
                {
                TRACE(TEXT("Clearing rubber\n"));
                pRubberImg = NULL;
                SetupRubber( m_pImg );
                }

            if (g_pColors)
                g_pColors->SetMono( ! m_nColors );

            InformDependants( P_Image );
            break;
        }

    m_bDirty = TRUE;

    return TRUE;
    }

/*****************************************************************************/

GPT CBitmapObj::GetIntProp(UINT nPropID, int& val)
    {
    switch (nPropID)
        {
        case P_Colors:
            val = m_nColors;
            return valid;
            break;

        case P_Image:
            val = NULL;
            return valid; // Must return now since this is a fake prop...
        }

    return invalid;
    }


/*****************************************************************************/

BOOL CBitmapObj::SetSizeProp(UINT nPropID, const CSize& val)
    {
    ASSERT(m_pImg != NULL);

    if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
    ||  (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
        {
        CommitSelection(TRUE);
        theImgBrush.m_pImg = NULL;
        }

    switch (nPropID)
        {
        default:
            ASSERT(FALSE);

        case P_Size:
            if (val.cx == m_pImg->cxWidth && val.cy == m_pImg->cyHeight)
                return TRUE;

            if (val.cx < 1 || val.cy < 1)
                {
                CmpMessageBox(IDS_ERROR_BITMAPSIZE, AFX_IDS_APP_TITLE,
                              MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
                }

            CWaitCursor waitCursor;
            BOOL bStretch = FALSE;

            CSize curSize;
            GetImgSize(m_pImg, curSize);

            bStretch = m_nShrink;

            SetUndo(m_pImg);
            CRect undoRect(0, 0, m_pImg->cxWidth, m_pImg->cyHeight);

            if (! SetImgSize(m_pImg, (CSize)val, bStretch))
                {
                theApp.SetMemoryEmergency();
                return FALSE;
                }

            FinishUndo(&undoRect);

            DirtyImg(m_pImg);

            pRubberImg = NULL;
            SetupRubber(m_pImg);

            if (theUndo.IsRecording())
                {
                theUndo.OnSetIntProp(this, P_Width, m_nWidth);
                theUndo.OnSetIntProp(this, P_Height, m_nHeight);
                }

            int nOldWidth = m_nWidth;
            int nOldHeight = m_nHeight;

            m_nWidth = val.cx;
            m_nHeight = val.cy;

            if (m_nWidth != nOldWidth)
                InformDependants(P_Width);

            if (m_nHeight != nOldHeight)
                InformDependants(P_Height);

            InformDependants(P_Image);

            break;
        }

    return TRUE;
    }

/*****************************************************************************/

BOOL CBitmapObj::SaveResource( BOOL bClear )
    {
    if (m_pImg == NULL)
        return TRUE;

    if (bClear)
        {
        if (m_hThing && ! m_pImg->bDirty && ! m_bDirty)
            return TRUE; // nothing to save

        m_bDirty |= m_pImg->bDirty;

        if (m_pImg == theImgBrush.m_pImg)
            theImgBrush.m_pImg = NULL;

        if (m_pImg == pRubberImg)
            pRubberImg = NULL;

        HideBrush();
        }

    DWORD dwStyle = BI_RGB;
    int   iColors = m_nColors;

    if (m_nSaveColors >= 0)
        {
        iColors = m_nSaveColors;
        m_nSaveColors = -1;
        }

    if (m_bCompressed)
        {
        switch (iColors)
            {
            case 1:
                dwStyle = BI_RLE4;
                break;

            case 2:
                dwStyle = BI_RLE8;
                break;
            }
        }

    switch (iColors)
        {
        case 0:
            iColors = 1;
            break;

        case 1:
            iColors = 4;
            break;

        case 2:
            iColors = 8;
            break;

        case 3:
            iColors = 24;
            break;

        default:
            iColors = 0;
            break;
        }

    HBITMAP hBitmap     = m_pImg->hBitmap;
    HBITMAP hMaskBitmap = NULL;
    BOOL    bNewBitmap  = FALSE;
    HGLOBAL lpDIB;
    DWORD   dwSize;

        // Icon support is not in application anymore, right?
   #ifdef ICO_SUPPORT
    if (IsSaveIcon())
        {
        // build a mask based on the current background color
        // and make sure the bitmap is the icon size
        bNewBitmap = SetupForIcon( hBitmap, hMaskBitmap );

        if (iColors > 4 || iColors < 1)
            iColors = 4;
        }
   #endif

    ::SelectObject( m_pImg->hDC, m_pImg->hBitmapOld );

    lpDIB = DibFromBitmap( 
        hBitmap, dwStyle, (WORD)iColors, 
        theApp.m_pPalette, hMaskBitmap, dwSize, 
        m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter );

    ::SelectObject( m_pImg->hDC, m_pImg->hBitmap );

    if (bNewBitmap)
        {
        ::DeleteObject(     hBitmap );
        ::DeleteObject( hMaskBitmap );
        }

    if (lpDIB == NULL)
        {
        theApp.SetMemoryEmergency();

        return FALSE;
        }

    if (m_hThing != NULL)
        Free();

    // We packed the DIB, so the offset will always be right after the palette,
    // which is implied by this being 0
    m_dwOffBits = 0;
    m_hThing    = lpDIB;
    m_lMemSize  = dwSize;

    if (bClear)
        m_pImg->bDirty = FALSE;

    return TRUE;
    }

/*****************************************************************************/

// Icon support is not in application anymore, right?
BOOL CBitmapObj::SetupForIcon( HBITMAP& hBitmap, HBITMAP& hMaskBitmap )
    {
    CDC       dcIcon;
    CDC       dcMask;
    CBitmap   bmIcon;
    CBitmap   bmMask;
    CDC*      pdcBitmap = CDC::FromHandle( m_pImg->hDC );
    CSize     sizeIcon( ::GetSystemMetrics( SM_CXICON ),
                        ::GetSystemMetrics( SM_CYICON ) );
    BOOL      bNewBitmap = FALSE;

    if (dcIcon.CreateCompatibleDC( pdcBitmap )
    &&  dcMask.CreateCompatibleDC( pdcBitmap )
    &&  bmIcon.CreateCompatibleBitmap( pdcBitmap, sizeIcon.cx, sizeIcon.cy )
    &&  bmMask.CreateBitmap( sizeIcon.cx, sizeIcon.cy, 1, 1, NULL ))
        {
        CPalette* ppalOld = NULL;
        CBitmap*  pbmOldIcon = dcIcon.SelectObject( &bmIcon );
        CBitmap*  pbmOldMask = dcMask.SelectObject( &bmMask );

        if (theApp.m_pPalette)
            {
            ppalOld = dcIcon.SelectPalette( theApp.m_pPalette, FALSE );
            dcIcon.RealizePalette();
            }
        dcIcon.PatBlt( 0, 0, sizeIcon.cx, sizeIcon.cy, WHITENESS );

        CBrush brBackGround( crRight );

        if (brBackGround.GetSafeHandle() != NULL)
            {
            CRect rect( 0, 0, sizeIcon.cx, sizeIcon.cy );

            dcIcon.FillRect( &rect, &brBackGround );

            brBackGround.DeleteObject();
            }
        int iWidth  = min( sizeIcon.cx, m_pImg->cxWidth );
        int iHeight = min( sizeIcon.cy, m_pImg->cyHeight );

        dcIcon.BitBlt( 0, 0, iWidth, iHeight, pdcBitmap, 0, 0, SRCCOPY );

        COLORREF oldBkColor = dcIcon.SetBkColor( crRight );

        dcMask.BitBlt( 0, 0, sizeIcon.cx, sizeIcon.cy, &dcIcon, 0, 0, SRCCOPY );

        COLORREF cRefFGColorOld = dcMask.SetTextColor( RGB(   0,   0,   0 ) );
        COLORREF cRefBKColorOld = dcMask.SetBkColor  ( RGB( 255, 255, 255 ) );

        dcIcon.BitBlt( 0, 0, sizeIcon.cx, sizeIcon.cy, &dcMask, 0, 0, DSna );

        dcMask.SetTextColor( cRefFGColorOld );
        dcMask.SetBkColor  ( cRefBKColorOld );
        dcIcon.SetBkColor  ( oldBkColor );

        if (ppalOld != NULL)
            dcIcon.SelectPalette( ppalOld, FALSE );

        if (pbmOldIcon != NULL)
            dcIcon.SelectObject( pbmOldIcon );

        if (pbmOldMask != NULL)
            dcMask.SelectObject( pbmOldMask );

            hBitmap = (HBITMAP)bmIcon.Detach();
        hMaskBitmap = (HBITMAP)bmMask.Detach();
         bNewBitmap = TRUE;
        }

    if (dcIcon.GetSafeHdc() != NULL)
        dcIcon.DeleteDC();

    if (dcMask.GetSafeHdc() != NULL)
        dcMask.DeleteDC();

    if (bmIcon.GetSafeHandle() != NULL)
        bmIcon.DeleteObject();

    if (bmMask.GetSafeHandle() != NULL)
        bmMask.DeleteObject();

    return bNewBitmap;
    }

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\colorsrc.cpp ===
/******************************************************************************/
/*                                                                            */
/* Class Implementations for The Colors
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "bmobject.h"
#include "minifwnd.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "colorsrc.h"
#include "toolbox.h"
#include "props.h"
#include "ferr.h"
#include "imgdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CColors, CObject )

#include "memtrace.h"

/******************************************************************************/

// Color Palette

COLORREF colorColors16 [] =
{
   RGB(  0,   0,   0), // Black
    RGB(128, 128, 128), // Dark Gray
    RGB(128,   0,   0), // Dark Red
    RGB(128, 128,   0), // Pea Green
    RGB(  0, 128,   0), // Dark Green
    RGB(  0, 128, 128), // Slate
    RGB(  0,   0, 128), // Dark Blue
    RGB(128,   0, 128), // Lavender
    RGB(255, 255, 255), // White
    RGB(192, 192, 192), // Light Gray
    RGB(255,   0,   0), // Bright Red
    RGB(255, 255,   0), // Yellow
    RGB(  0, 255,   0), // Bright Green
    RGB(  0, 255, 255), // Cyan
    RGB( 64,   0, 255), //
    RGB(255,   0, 255), // Magenta


};

COLORREF colorColorsDef [] =
    {
       RGB(  0,   0,   0), // Black
       RGB(128, 128, 128), // Dark Gray
       RGB(128,   0,   0), // Dark Red
       RGB(128, 128,   0), // Pea Green
       RGB(  0, 128,   0), // Dark Green
       RGB(  0, 128, 128), // Slate
       RGB(  0,   0, 128), // Dark Blue
       RGB(128,   0, 128), // Lavender
       RGB(128, 128,  64), //
       RGB(  0,  64,  64), //
       RGB(  0, 128, 255), //
       RGB(  0,  64, 128), //
       RGB(128,   0, 255), //
       RGB(128,  64,   0), //

       RGB(255, 255, 255), // White
       RGB(192, 192, 192), // Light Gray
       RGB(255,   0,   0), // Bright Red
       RGB(255, 255,   0), // Yellow
       RGB(  0, 255,   0), // Bright Green
       RGB(  0, 255, 255), // Cyan
       RGB(  0,   0, 255), // Bright Blue
       RGB(255,   0, 255), // Magenta
       RGB(255, 255, 128), //
       RGB(  0, 255, 128), //
       RGB(128, 255, 255), //
       RGB(128, 128, 255), //
       RGB(255,   0, 128), //
       RGB(255, 128,  64), //
    };

COLORREF bwColorsDef [] =
    {
    RGB(0,0,0),
    RGB(9,9,9),
    RGB(18,18,18),
    RGB(27,27,27),
    RGB(37,37,37),
    RGB(46,46,46),
    RGB(55,55,55),
    RGB(63,63,63),
    RGB(73,73,73),
    RGB(82,82,82),
    RGB(92,92,92),
    RGB(101,101,101),
    RGB(110,110,110),
    RGB(119,119,119),

    RGB(255,255,255),
    RGB(250,250,250),
    RGB(242,242,242),
    RGB(212,212,212),
    RGB(201,201,201),
    RGB(191,191,191),
    RGB(182,182,182),
    RGB(159,159,159),
    RGB(128,128,128),
    RGB(173,173,173),
    RGB(164,164,164),
    RGB(155,155,155),
    RGB(146,146,146),
    RGB(137,137,137),
    };

CColors* g_pColors;

/******************************************************************************/

void SetDrawColor( int iColor )
    {
    if (! g_pColors)
        return;

    COLORREF cr = g_pColors->GetColor( iColor );

    theLeft = iColor;

    SetDrawColor(cr);
    }

void SetDrawColor( COLORREF cr )
    {
     crLeft = cr;

    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd) )
        g_pImgColorsWnd->InvalidateCurColors();

    if (   theImgBrush.m_pImg != NULL
    &&  (! theImgBrush.m_bFirstDrag || CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
    &&  ! g_bCustomBrush)
        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);

    CImgTool* pcImgTool = CImgTool::GetCurrent();

    if (pcImgTool)
        {
        CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());

        if (pFrame)
            {
            CPBView* pcbActiveView = DYNAMIC_DOWNCAST(CPBView, pFrame->GetActiveView());

            if (pcbActiveView)
                pcImgTool->OnUpdateColors( pcbActiveView->m_pImgWnd );
            }
        }
    }

/***************************************************************************/

void SetEraseColor(int iColor)
    {
    if (! g_pColors)
        return;

    COLORREF cr = g_pColors->GetColor( iColor );

    theRight = iColor;

    SetEraseColor(cr);
    }


void SetEraseColor(COLORREF cr)
    {
     crRight = cr;

    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
        g_pImgColorsWnd->InvalidateCurColors();

    if (   theImgBrush.m_pImg != NULL
    &&  (! theImgBrush.m_bFirstDrag || CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
    &&   ! g_bCustomBrush)
        {
        theImgBrush.RecalcMask(crRight);
        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);
        }

    CImgTool* pcImgTool = CImgTool::GetCurrent();

    if (pcImgTool != NULL)
        {
        CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());

        if (pFrame)
            {
            CPBView* pcbActiveView = DYNAMIC_DOWNCAST(CPBView, pFrame->GetActiveView());

            if (pcbActiveView)
                pcImgTool->OnUpdateColors( pcbActiveView->m_pImgWnd );
            }
        }
    }

/***************************************************************************/

void SetLeftColor(int nColor)
    {
    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        HideBrush();

    SetDrawColor(nColor);
    }

/***************************************************************************/

void SetRightColor(int nColor)
    {
    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        HideBrush();

    SetEraseColor(nColor);

    theImgBrush.RecalcMask(crRight);
    }

/***************************************************************************/

//extern COLORREF crTrans; // transparent color

void SetTransColor( int iColor )
    {
    if (! g_pColors)
        return;

    theTrans = iColor;

    SetTransColor(g_pColors->GetColor( iColor ));
    }

void SetTransColor( COLORREF cr )
    {
    crTrans = cr;

    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd) )
        g_pImgColorsWnd->InvalidateCurColors();

    if (   theImgBrush.m_pImg != NULL
    &&  (! theImgBrush.m_bFirstDrag || CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
    &&  ! g_bCustomBrush)
        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);

    CImgTool* pcImgTool = CImgTool::GetCurrent();

    if (pcImgTool)
        {
        CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());

        if (pFrame)
            {
            CPBView* pcbActiveView = DYNAMIC_DOWNCAST(CPBView, pFrame->GetActiveView());

            if (pcbActiveView)
                pcImgTool->OnUpdateColors( pcbActiveView->m_pImgWnd );
            }
        }
    }

/***************************************************************************/

void InvalColorWnd()
    {
    if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd&& IsWindow(g_pImgColorsWnd->m_hWnd) )
        g_pImgColorsWnd->Invalidate(TRUE);

    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) &&
        CImgTool::GetCurrent()->IsFilled())
        g_pImgToolWnd->InvalidateOptions( FALSE );
    }

/***************************************************************************/

int AddNewColor( IMG* pImg, COLORREF crNew )
    {
    int iColor = -1;

    if (! pImg->m_pPalette)
        return iColor;

    LOGPALETTE256* pLogPal = new LOGPALETTE256;

    if (! pLogPal)
        {
        theApp.SetMemoryEmergency();
        return iColor;
        }


    pLogPal->palVersion    = 0x300;
    pLogPal->palNumEntries = (WORD)pImg->m_pPalette->GetPaletteEntries(
                                             0, MAX_PALETTE_COLORS,
                                             &pLogPal->palPalEntry[0] );

    pImg->m_pPalette->GetPaletteEntries (0, pLogPal->palNumEntries,
                                             &pLogPal->palPalEntry[0] );

    PALETTEENTRY PalEntry;
    PalEntry.peRed   = GetRValue( crNew );
    PalEntry.peGreen = GetGValue( crNew );
    PalEntry.peBlue  = GetBValue( crNew );
    PalEntry.peFlags = 0;

    UINT uNearest = pImg->m_pPalette->GetNearestPaletteIndex( crNew );

    if  (pLogPal->palPalEntry[uNearest].peRed   != PalEntry.peRed
    ||   pLogPal->palPalEntry[uNearest].peGreen != PalEntry.peGreen
    ||   pLogPal->palPalEntry[uNearest].peBlue  != PalEntry.peBlue)
        {
        int  iUsePalEntry = pLogPal->palNumEntries;
        BOOL bAdd = FALSE;

        ::SelectPalette( pImg->hDC, pImg->m_hPalOld, FALSE );

        if (iUsePalEntry >= MAX_PALETTE_COLORS)
            {
            // this needs to keep track of the colors added somehow
            // and not always write over the last one. Done
            iUsePalEntry  = MAX_PALETTE_COLORS + pImg->m_nLastChanged--;


            // This is so highly unlikely that I shudder to think?
            if (pImg->m_nLastChanged <= -MAX_PALETTE_COLORS)
                pImg->m_nLastChanged  = -1;

            bAdd = TRUE;
            }
        else
            bAdd = pImg->m_pPalette->ResizePalette( iUsePalEntry + 1 );

        if (bAdd)
            bAdd = pImg->m_pPalette->SetPaletteEntries( iUsePalEntry,
                                                        1, &PalEntry );
        if (bAdd)
            iColor = iUsePalEntry;

        ::SelectPalette(  pImg->hDC,
                (HPALETTE)pImg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( pImg->hDC );
        }

    delete pLogPal;

    return iColor;
    }

/******************************************************************************/

CColors::CColors() : CObject()
    {
    ASSERT( sizeof( colorColorsDef ) == sizeof( bwColorsDef ) );

    m_nColorCount = 0;
    m_bMono       = theApp.m_bMonoDevice;
    m_colors      = new COLORREF[MAXCOLORS];
    m_monoColors  = new COLORREF[MAXCOLORS];

    if (m_colors && m_monoColors)
        ResetColors();
    }

/******************************************************************************/

CColors::~CColors()
    {
    if (m_colors     != NULL)
        delete m_colors;

    if (m_monoColors != NULL)
        delete m_monoColors;

    m_colors     = NULL;
    m_monoColors = NULL;
    }

/******************************************************************************/

void CColors::SetMono( BOOL bMono )
    {
    if ((  m_bMono &&   bMono)
    ||  (! m_bMono && ! bMono))
        return;

    m_bMono = bMono;

    InvalColorWnd();
    }

/******************************************************************************/

COLORREF CColors::GetColor( int nColor )
    {
    ASSERT(nColor >= 0 && nColor < m_nColorCount);
    return (m_bMono ? m_monoColors : m_colors)[nColor];
    }

/******************************************************************************/

void CColors::SetColor( int nColor, COLORREF color )
    {
    ASSERT( nColor >= 0 && nColor < m_nColorCount );

    int iRed   = GetRValue( color );
    int iGreen = GetGValue( color );
    int iBlue  = GetBValue( color );

    if (m_bMono)
        {
        long bwvalue = (30 * iRed   +
                        59 * iGreen +
                        11 * iBlue) / 100;
        m_monoColors[nColor] = RGB(bwvalue, bwvalue, bwvalue);
        }
    else
        {
        if (theApp.m_bPaletted)
            color = PALETTERGB( iRed, iGreen, iBlue );
        else
            color = RGB( iRed, iGreen, iBlue );

        m_colors[nColor] = color;
        }

    InvalColorWnd();
    }

void CColors::CmdEditColor()
    {
    EditColor( TRUE, FALSE );
    }

/***************************************************************************/

extern INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

UINT CALLBACK
MyAfxCommDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        if (hWnd == NULL)
                return 0;

        if (message == WM_SETFONT || message == WM_INITDIALOG)
                return (UINT) AfxDlgProc(hWnd, message, wParam, lParam);

        return 0;
}

/***************************************************************************/

static UINT_PTR CALLBACK /*LPCCHOOKPROC*/
EditColorHook(HWND hColorDlg, UINT nMessage, WPARAM wParam, LPARAM lParam)
{
// Are we initializing the dialog window?
if ( nMessage == WM_INITDIALOG )
        {
        // Reset the common dialog title
        CString strDialogTitle;
        strDialogTitle.LoadString(IDS_EDIT_COLORS);
        SetWindowText( hColorDlg, strDialogTitle );
        }
// Pass All Messages Along to Common Dialog
return MyAfxCommDlgProc(hColorDlg, nMessage, wParam, lParam );
}

void CColors::EditColor( BOOL bLeft, BOOL bTrans )
    {
    COLORREF* pColor;
    INT_PTR bRet;
    if (bTrans)
    {
       pColor = &crTrans;
    }
    else
    {
       pColor = bLeft? &crLeft: &crRight;
    }

    CColorDialog dlg( *pColor & 0xFFFFFF ); // Disregard palette-relative
    dlg.m_cc.Flags &= ~CC_SHOWHELP;  // Get rid of Help flag
    dlg.m_cc.lpfnHook = EditColorHook;

    bRet = dlg.DoModal();

    if (bRet != IDOK)
    {
       return;
    }
    COLORREF color = dlg.GetColor();

    BYTE iRed   = GetRValue( color );
    BYTE iGreen = GetGValue( color );
    BYTE iBlue  = GetBValue( color );

    if (theApp.m_bPaletted)
        *pColor = PALETTERGB( iRed, iGreen, iBlue );
    else
        *pColor =        RGB( iRed, iGreen, iBlue );

    int theColor;

    if (bTrans)
    {
       theColor = theTrans;
    }
    else
    {
       theColor = (bLeft? theLeft: theRight);
    }


    if (theColor != -1)
        {
        CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

        if (pDoc && pDoc->m_pBitmapObj->m_pImg)
            AddNewColor( pDoc->m_pBitmapObj->m_pImg, color );

        SetColor( theColor, color );
        }

    InvalColorWnd();
    }

/******************************************************************************/
#if 0 // poorly implemented, rarely used feature as of NT 5/ Memphis

void CColors::CmdLoadColors()
    {
    DWORD lFlags = 0;

    #ifndef _DEBUG
    lFlags = 0x00080000 /* OFN_EXPLORER */;
    #endif

        CString strFileTypes;
        strFileTypes.LoadString(IDS_PAL_FILETYPES);

    CFileDialog dlgFile( TRUE, TEXT(""), NULL, lFlags, strFileTypes, NULL );

        CString dlgtitle;
        dlgtitle.LoadString(IDS_LOAD_PALETTE_COLORS);
    dlgFile.m_ofn.lpstrTitle = dlgtitle;
    dlgFile.m_ofn.Flags  &= ~OFN_SHOWHELP;  // Get rid of Help flag
    dlgFile.m_ofn.Flags |= OFN_HIDEREADONLY;
    if (dlgFile.DoModal() != IDOK)
        return;

    CFile          file;
    CFileException ex;

    theApp.SetFileError( IDS_ERROR_OPEN, CFileException::none, dlgFile.GetPathName() );

    if (! file.Open( dlgFile.GetPathName(),
                     CFile::modeRead | CFile::typeBinary, &ex ))
        {
        theApp.SetFileError( IDS_ERROR_OPEN, ex.m_cause );
        return;
        }

    CHAR         cID[5];
    CHAR         cPalData[9];
    DWORD        dwRiffSize  = 0;
    DWORD        dwChunkSize = 0;
    COLORREF*    pColors     = NULL;
    int          iColors     = 0;
    int          index;

    if (file.Read(          cID         , sizeof( cID ) - 1 )      == (sizeof( cID         ) - 1)
    &&  file.Read( (void*)(&dwRiffSize ), sizeof( dwRiffSize ) )   ==  sizeof( dwRiffSize  )
    &&  file.Read(          cPalData    , sizeof( cPalData ) - 1 ) == (sizeof( cPalData    ) - 1)
    &&  file.Read( (void*)(&dwChunkSize), sizeof( dwChunkSize ) )  ==  sizeof( dwChunkSize ))
        {
        cID[4]      = '\0';
        cPalData[8] = '\0';

        BOOL bPal  = lstrcmpA( cID     , "RIFF" );
             bPal |= lstrcmpA( cPalData, "PAL data" );

        if (! bPal)
            {
            LPLOGPALETTE pLogPal = (LPLOGPALETTE) new BYTE[dwChunkSize];

            if (pLogPal)
                {
                if ((DWORD)file.Read( pLogPal, (UINT)dwChunkSize )
                                                  == dwChunkSize)
                    {
                    iColors = pLogPal->palNumEntries;

                    ASSERT( iColors == (int)((dwChunkSize - sizeof( LOGPALETTE )) / sizeof( PALETTEENTRY ) + 1) );

                    pColors = (COLORREF*)new BYTE[sizeof( COLORREF ) * iColors];

                    if (pColors)
                        {
                        for (index = 0; index < iColors; index++)
                            pColors[index] = RGB( pLogPal->palPalEntry[index].peRed,
                                                  pLogPal->palPalEntry[index].peGreen,
                                                  pLogPal->palPalEntry[index].peBlue );
                        }
                    else
                        {
                        theApp.SetMemoryEmergency();
                        iColors = 0;
                        }
                    }
                else
                    theApp.SetFileError( IDS_ERROR_OPEN, ferrReadFailed );

                delete [] (BYTE*)pLogPal;
                }
            else
                theApp.SetMemoryEmergency();
            }
        else
            theApp.SetFileError( IDS_ERROR_OPEN, ferrIllformedFile );
        }
    else
        theApp.SetFileError( IDS_ERROR_OPEN, ferrReadFailed );

    if (! iColors)
        return;

    if (theApp.m_bPaletted)
        {
        CPalette* ppalNew = CreatePalette( pColors, iColors );

        if (ppalNew)
            {
            CPBView*    pView      = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
            CPBDoc*     pDoc       = (pView? pView->GetDocument(): NULL);
            CBitmapObj* pBitmapObj = ( pDoc?  pDoc->m_pBitmapObj: NULL);

            if (pBitmapObj)
                {
                if (pBitmapObj->m_pImg != pView->m_pImgWnd->m_pImg)
                    CommitSelection( TRUE );

                if (pBitmapObj->SaveResource( FALSE )) // get packed dib
                    {
                    int   iAdds;
                    LPSTR lpDib        = (LPSTR)pBitmapObj->GetData();
                    IMG*  pImg         = pBitmapObj->m_pImg; // merge palettes can handle null pointers
                    CPalette* ppalMrgd = MergePalettes( ppalNew,
                                                        pImg->m_pPalette,
                                                        iAdds );
                    if (ppalMrgd) // got a new palette.
                        {
                        delete ppalNew;
                        ppalNew = ppalMrgd;
                        }

                    LPBITMAPINFO  lpDibInfo  = (LPBITMAPINFO)lpDib;
                    RGBQUAD*      prgbColors = &(lpDibInfo->bmiColors[0]);
                    unsigned short* puColors = (unsigned short*)prgbColors;
                    int           iDibColors = DIBNumColors( lpDib );

                    for (int iLoop = 0; iLoop < iDibColors; iLoop++, puColors++, prgbColors++)
                        *puColors = (unsigned short)ppalNew->GetNearestPaletteIndex(
                                           PALETTERGB( prgbColors->rgbRed,
                                                       prgbColors->rgbGreen,
                                                       prgbColors->rgbBlue ) );
                    CleanupImgUndo();
                    CleanupImgRubber();

                    ::SelectObject  ( pImg->hDC, pImg->hBitmapOld );
                    ::SelectPalette ( pImg->hDC, (HPALETTE)(ppalNew->m_hObject), FALSE );
                    ::RealizePalette( pImg->hDC );

                    int iLinesDone = SetDIBits( pImg->hDC, pImg->hBitmap, 0,
                                                pImg->cyHeight,
                                                FindDIBBits( lpDib ),
                                                lpDibInfo, DIB_PAL_COLORS );
                    if (iLinesDone != pImg->cyHeight)
                        theApp.SetGdiEmergency();

                    ::SelectObject( pImg->hDC, pImg->hBitmap );

                    if (pImg->m_pPalette)
                        delete pImg->m_pPalette;

                     pImg->m_pPalette = ppalNew;
                    theApp.m_pPalette = ppalNew;

                    ppalNew = NULL;

                    pRubberImg = NULL;

                    SetupRubber( pImg );

                    InvalImgRect( pImg, NULL );

                    for (index = 0; index < iColors; index++)
                        pColors[index] |= 0x02000000;
                    }
                }
            }
        else
            theApp.SetMemoryEmergency();

        if (ppalNew)
            delete ppalNew;
        }

    for (index = 0; index < m_nColorCount && index < iColors; index++)
        SetColor( index, pColors[index] );

    if (pColors)
        delete [] ((BYTE*)pColors);

    InvalColorWnd();
    }

/***************************************************************************/

void CColors::CmdSaveColors()
    {
    DWORD lFlags =  OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    #ifndef _DEBUG
    lFlags |= OFN_EXPLORER  ;
    #endif

        CString strFileTypes;
        strFileTypes.LoadString(IDS_PAL_FILETYPES);

        CString strDefName;
        strDefName.LoadString(IDS_PAL_UNTITLED);

    CFileDialog dlgFile( FALSE, TEXT("pal"), strDefName, lFlags, strFileTypes);

    dlgFile.m_ofn.lpstrDefExt = TEXT("pal");
    CString dlgtitle;
    dlgtitle.LoadString(IDS_SAVE_PALETTE_COLORS);
    dlgFile.m_ofn.lpstrTitle  = dlgtitle;
    dlgFile.m_ofn.Flags      &= ~OFN_SHOWHELP;  // Get rid of Help flag

    if (dlgFile.DoModal() != IDOK)
        return;

//  GetParent()->UpdateWindow(); // to erase the dialog box while we save...

    CFile           file;
    CFileException  ex;

    theApp.SetFileError( IDS_ERROR_OPEN, CFileException::none, dlgFile.GetPathName() );

    if (! file.Open( dlgFile.GetPathName(),
                     CFile::modeCreate | CFile::modeWrite | CFile::typeBinary,
                     &ex ))
    {
       theApp.SetFileError( IDS_ERROR_OPEN, ex.m_cause );
       return;
    }

    LOGPALETTE LogPal;

    LogPal.palVersion    = 0x300;
    LogPal.palNumEntries = GetColorCount();

    DWORD dwDataSize = sizeof( LogPal )
                     + (LogPal.palNumEntries - 1) * sizeof( COLORREF );
    TRY
        {
        DWORD dwRiff = dwDataSize + 12;

        file.Write( "RIFF", 4 );
        file.Write( &dwRiff, sizeof( DWORD ) );
        file.Write( "PAL data", 8 );

        file.Write( &dwDataSize, sizeof( DWORD ) );
        file.Write( &LogPal, sizeof( LogPal ) - sizeof( COLORREF ) );
        file.Write( (m_bMono? m_monoColors: m_colors),
                         LogPal.palNumEntries * sizeof( COLORREF ) );
        }
    CATCH( CFileException, pex )
        {
        theApp.SetFileError( IDS_ERROR_EXPORT, pex->m_cause );
        }
    END_CATCH
    }

/***************************************************************************/
#endif // unused code

void CColors::ResetColors(int nColors)
    {

    COLORREF *pColors;
    m_nColorCount = (int)min (nColors, sizeof(colorColorsDef) / sizeof(COLORREF));
    if (m_nColorCount == 16)
    {
       pColors = colorColors16;
    }
    else
    {
       pColors = colorColorsDef;
    }

    if (theApp.m_bPaletted)
        {
        int iRed;
        int iGreen;
        int iBlue;

        for (int i = 0; i < m_nColorCount; i++)
            {
            iRed   = GetRValue( pColors[i] );
            iGreen = GetGValue( pColors[i] );
            iBlue  = GetBValue( pColors[i] );

            m_colors[i] = PALETTERGB( iRed, iGreen, iBlue );
            }
        }
     else
        memcpy( m_colors,    pColors, m_nColorCount * sizeof(COLORREF) );
    memcpy( m_monoColors,    bwColorsDef, sizeof(    bwColorsDef ) );

    InvalColorWnd();
    if (g_pImgColorsWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
       g_pImgColorsWnd->UpdateWindow();
    SetDrawColor (  0 ); // position  0 in color palette is black
    SetEraseColor( m_nColorCount==16?8:14 ); // white
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\bar.h ===
/******************************************************************************/
/* Bar.H:   Defines the Interface to the CStatBar (Status Bar) CLASS          */
/*                                                                            */
/******************************************************************************/

#ifndef __BAR_H__
#define __BAR_H__

//below size does not include bitmap width
#define SIZE_POS_PANE_WIDTH 12    // Bitmap Width + 1 char separator + 5 digits + 1 char separator + 5 digits

// The 2 below defines were needed, since we had to duplicate the DrawStatusText
// method from the barcore.cpp file in the msvc\mfc\src directory
#define CX_BORDER 1   // from auxdata.h in the msvc\mfc\src directory
#define CY_BORDER 1   // from auxdata.h in the msvc\mfc\src directory

/******************************************************************************/

class CStatBar : public CStatusBar
    {
    DECLARE_DYNAMIC( CStatBar )

private:

    CBitmap m_posBitmap;
    CBitmap m_sizeBitmap;
    CString m_cstringSizeSeparator;
    CString m_cstringPosSeparator;
    int     m_iBitmapWidth;
    int     m_iBitmapHeight;
    int     m_iSizeY;

protected:

    virtual void DoPaint(CDC* pDC);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

    static  void PASCAL DrawStatusText( HDC hDC, CRect const& rect,
                                            LPCTSTR lpszText, UINT nStyle,
                                            int iIndentText = 0);

    afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
    afx_msg void    OnNcDestroy( void );
        afx_msg void    OnSysColorChange( void );

public:

    CStatBar();
    ~CStatBar();

    BOOL Create(CWnd* pParentWnd);

    BOOL SetText(LPCTSTR sz);

    BOOL SetPosition(const CPoint& pos);
    BOOL SetSize(const CSize& size);

    BOOL ClearPosition();
    BOOL ClearSize();

    BOOL Reset();

    DECLARE_MESSAGE_MAP()
    };

extern CStatBar *g_pStatBarWnd;

/******************************************************************************/
// NON-OBJECT Status bar API, Uses global object pointer to the StatBar object

void ShowStatusBar                ( BOOL bShow = TRUE );
BOOL IsStatusBarVisible           ();
void InvalidateStatusBar          ( BOOL bErase = FALSE );
void ClearStatusBarSize           ();
void ClearStatusBarPosition       ();
void ClearStatusBarPositionAndSize();
void ResetStatusBar               ();
void SetStatusBarPosition         ( const CPoint& pos );
void SetStatusBarSize             ( const CSize& size );
void SetStatusBarPositionAndSize  ( const CRect& rect );
void SetPrompt                    ( LPCTSTR, BOOL bRedrawNow = FALSE );
void SetPrompt                    ( UINT, BOOL bRedrawNow = FALSE );

/******************************************************************************/

#endif // __BAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\docking.h ===
// docking.h : interface of the CDocking class
//

class CDocking : public CObject
    {
    DECLARE_DYNAMIC( CDocking )

    // Constructors
    public:     /***********************************************************/

    CDocking();

    // Attributes

    BOOL    Create( CPoint ptDrop, CRect& rectCurrent, BOOL bDocked, CPBView::DOCKERS tool );
    void    Move  ( CPoint ptNew );
    BOOL    Move  ( CPoint ptNew, CRect& rectFrame );
    BOOL    Clear ( CRect* prectLast = NULL );

    protected:  /***********************************************************/

    BOOL    DrawFocusRect();

    int     m_iDockingX;
    int     m_iDockingY;
    BOOL    m_bStarted;
    BOOL    m_bDocked;
    BOOL    m_bDocking;
    CRect   m_rectDockingPort;
    CRect   m_rectDocked;
    CRect   m_rectFree;
    CPoint  m_ptLast;
    CPoint  m_ptDocking;

    CPBView::DOCKERS m_Tool;
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\docking.cpp ===
// docking.cpp : implementation of the CDocking class
//

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "imgwell.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "docking.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CDocking, CObject )

#include "memtrace.h"

/***************************************************************************/
// CDocking implementation

CDocking::CDocking()
    {
    m_bStarted   = FALSE;
    m_bDocking   = FALSE;
    m_iDockingX  = ::GetSystemMetrics( SM_CXICON );
    m_iDockingY  = ::GetSystemMetrics( SM_CYICON );
    m_iDockingX += m_iDockingX / 2;
    m_iDockingY += m_iDockingY / 2;
    }

/***************************************************************************/

BOOL CDocking::Create( CPoint ptDrop, CRect& rectCurrent, BOOL bDocked, CPBView::DOCKERS tool )
    {
    ASSERT( ! m_bStarted );

    m_Tool     = tool;
    m_bDocked  = bDocked;
    m_ptLast   = ptDrop;
    m_bDocking = ! bDocked;

    CRect rectTool;
    CRect rect = rectCurrent;
    CSize size = rectCurrent.Size();

    if (bDocked)
        {
        switch (tool)
            {
            case CPBView::toolbox:
            case CPBView::colorbox:
                rect.InflateRect( theApp.m_cxBorder, theApp.m_cyBorder );
                break;


            }

        rect.bottom += theApp.m_cyCaption;
        m_rectDocked = rectCurrent;
        m_rectFree   = rect;
        }
    else
        {
        switch (tool)
            {
            case CPBView::toolbox:
                g_pImgToolWnd->GetWindowRect( &rectTool );

                rect.right  = rect.left + rectTool.Width();
                rect.bottom = rect.top  + rectTool.Height();
                break;

            case CPBView::colorbox:
                g_pImgColorsWnd->GetWindowRect( &rectTool );

                rect.right  = rect.left + rectTool.Width();
                rect.bottom = rect.top  + rectTool.Height();
                break;

            }
        m_rectDocked = rect;
        m_rectFree   = rectCurrent;
        }

    CPBView* pView = (CPBView*)(((CFrameWnd*)AfxGetMainWnd())->GetActiveView());

    ASSERT( pView != NULL );

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        {
        m_ptDocking = pView->GetDockedPos( tool, size );
        m_bStarted  = DrawFocusRect();

        m_rectDockingPort.SetRect( m_ptDocking.x - m_iDockingX,
                                   m_ptDocking.y - m_iDockingY,
                                   m_ptDocking.x + m_iDockingX,
                                   m_ptDocking.y + m_iDockingY );
        }
    return m_bStarted;
    }

/***************************************************************************/

BOOL CDocking::Move( CPoint ptNew, CRect& rectFrame )
    {
    Move( ptNew );

    rectFrame = m_bDocked? m_rectDocked: m_rectFree;

    return m_bDocked;
    }

/***************************************************************************/

void CDocking::Move( CPoint ptNew )
    {
    ASSERT( m_bStarted );

    if (DrawFocusRect())
        {
        CPoint pt = ptNew - m_ptLast;

        m_rectDocked.OffsetRect( pt );
        m_rectFree.OffsetRect( pt );

        pt = m_bDocked? m_rectDocked.TopLeft(): m_rectFree.TopLeft();

        m_bDocked = m_rectDockingPort.PtInRect( pt );

        m_ptLast = ptNew;

        DrawFocusRect();
        }
    }

/***************************************************************************/

BOOL CDocking::Clear( CRect* prectLast )
    {
    ASSERT( m_bStarted );

    DrawFocusRect();
    m_bStarted = FALSE;

    if (prectLast)
       *prectLast = m_bDocked? m_rectDocked: m_rectFree;

    if (!m_bDocked)
        {
        CPBView* pView = (CPBView*)(((CFrameWnd*)AfxGetMainWnd())->GetActiveView());

        if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
            pView->SetFloatPos( m_Tool, m_rectFree );
        }

    return m_bDocked;
    }

/***************************************************************************/

BOOL CDocking::DrawFocusRect()
    {
    if (m_bDocking)
        return TRUE;

    BOOL bReturn = FALSE;

    HDC hdc = ::GetDC( NULL );

    if (hdc)
        {
        ::DrawFocusRect( hdc, (m_bDocked? &m_rectDocked: &m_rectFree) );
        ::ReleaseDC( NULL, hdc );

        bReturn = TRUE;
        }

    return bReturn;
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\debugres.h ===
//
//	DEBUGRES.H
//		IDs for debug resources.
//

#define IDMX_IDLECHECKMEMORY		6100
#define IDMX_ALLOCCHECKMEMORY		6101
#define IDMX_DELAYFREEMEMORY		6102
#define IDMX_MEMORYSTATUSBAR		6103
#define IDMX_MKDLG                  7000
#define IDMX_BINDDLG                7001
#define IDMX_TRYDLG                 7002
#define IDMX_NAMEMAP                7003
#define IDMX_LOADFILE               7004
#define IDMX_SAVEFILE               7005
#define IDMX_LISTPROPS              7006
#define IDMX_CMDWND                 7007
#define IDMX_TESTSYMMANONE          7008
#define IDMX_TESTSYMMANTWO          7009
#define IDMX_TESTSYMMANTHREE        7010
#define IDMX_TESTSYMMANFOUR         7011
#define IDMX_POPPROP                7012
#define IDMX_LOGUNDO                7013
#define IDMX_FLUSHUNDO              7014
#define IDMX_TESTSHOWSYMRES         7015
#define IDMX_TESTPARSE              7016
#define IDMX_SETHELP				7500
#define IDMX_MAKEDIRTY				7501
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\fixhelp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

extern BOOL g_fDisableStandardHelp ;

extern HHOOK g_HelpFixHook ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc);

void SetHelpFixHook(void) ;

void RemoveHelpFixHook(void) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\colorsrc.h ===
// colorsrc.h : main header file for the PBRUSH application
//

#ifndef __COLORSRC_H__
#define __COLORSRC_H__

/******************************************************************************/

class CColors : public CObject
    {
    DECLARE_DYNCREATE( CColors )

    public:

    CColors();
   ~CColors();

    enum { MAXCOLORS = 256 };

    private:

    COLORREF*   m_colors;
    COLORREF*   m_monoColors;
    int         m_nColorCount;
    BOOL        m_bMono;

    public:

    void        SetMono ( BOOL bMono = TRUE );
    COLORREF    GetColor( int nColor );
    void        SetColor( int nColor, COLORREF color );

    int         GetColorCount() const { return m_nColorCount; }
    BOOL        GetMonoFlag  () const { return m_bMono; }

    void        EditColor( BOOL bLeft, BOOL bTrans );
    void        ResetColors(int nColors=256);
    void        CmdEditColor();
    #if 0 // unused features
    void        CmdLoadColors();
    void        CmdSaveColors();
    #endif
    };

/******************************************************************************/

extern CColors* g_pColors;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\filtapi.h ===
/*----------------------------------------------------------------------------
	%%File: FILTAPI.H
	%%Unit: FILTER32
	%%Contact: rlittle@microsoft.com

	This header is distributed as part of the 32 bit Filter SDK.
	
	Changes to this header file should be sent to rlittle@microsoft.com
	or doneill@microsoft.com

	Revision History: (Current=1.03)

	1/12/96 Created
	1/23/96 Renamed grt values and synchronized with grfSupport values
	1/24/96 Extra SetFilterPref arguments (smueller)
	1/25/96 Correct packing (rlittle)
----------------------------------------------------------------------------*/

#ifndef FILTAPI_H
#define FILTAPI_H

// Definitions

#ifdef MAC
#include "macos\types.h"
#include "macos\files.h"

// Mac type equivalents

typedef Handle HANDLE;
typedef Handle HMETAFILE;
typedef Handle HENHMETAFILE;
typedef Rect RECT;
typedef long HDC;	// unused
typedef short FH;
#endif // MAC

#ifdef WIN16
typedef HANDLE HENHMETAFILE;	// win16 doesn't support enhanced metafiles
typedef HFILE FH;
#endif // WIN16

#ifdef WIN32
typedef HANDLE FH;
#endif // WIN32

// useful macros (mainly for Mac; windows.h defines most of these, so this
// will just be a failsafe.

typedef unsigned short ushort;
typedef unsigned long ulong;
typedef unsigned char uchar;
typedef int BOOL;

// these are the graphics definitions for Version 2 & Version 3

#ifdef WIN16
#define cchMaxGrName	124	   // max file path length for graphics filter
#else // !WIN16
#define cchMaxGrName    260	   // max file path length for graphics filter
#endif

#define cchMaxGrExt       4	   // chars + end-of-string mark ('\0')

#pragma pack(2)
typedef struct _FILESPEC {
	union 
		{
		struct 
			{
			ushort slippery: 1;	// True if file may disappear.
			ushort write : 1;	// True if open for write.
			ushort unnamed: 1;	// True if unnamed.
			ushort linked : 1;	// Linked to an FS FCB.
			ushort mark : 1;	// Generic mark bit.
			ushort unused : 11;
			};
		ushort wFlags;
		};
	union
		{
		char rgchExt[cchMaxGrExt];	// file extension, not used on MacPPC
		FH hfEmbed;					// embedded file handle
		};
		
	ushort wUnused;	
#ifdef MACPPC
	FSSpec fsSpec;
#else
	char szName[cchMaxGrName];		// fully qualified path
#endif // MACPPC
	ulong dcbFile;					// file position in hfEmbed
	
	/*** END VERSION 2 FIELDS
	 *** 
	 *** Fields above this point are IMMUTABLE.  They are guaranteed
	 *** to be in the above format for backwards compatibility with
	 *** existing Version 2 filters.
	 ***/
	 
	ulong dcbFileHigh;
	} FILESPEC;

// NOTE:  the client application will arbitrarily decide which type to
// send if the filter returns multiple support types

#define GrfSupportFromGrt(grt)		(ulong)(1 << ((grt) + 15))
#define grfSupportEMF	GrfSupportFromGrt(grtEMF)	// 0x00010000
#define grfSupportWMF	GrfSupportFromGrt(grtWMF)	// 0x00020000
#define grfSupportPNG	GrfSupportFromGrt(grtPNG)	// 0x00040000
#define grfSupportPICT	GrfSupportFromGrt(grtPICT)	// 0x00080000
#define grfSupportJFIF	GrfSupportFromGrt(grtJFIF)	// 0x00100000

// NOTE:  grfImport/grfExport are not mutually exclusive.  They can be
// OR'ed together for a filter that does both.  Values 2 and 4 cannot be
// used as they would be indistinguishable from version 2 return values.

#define grfImport		0x00000008
#define grfExport		0x00000010


// Version 2 support:

typedef struct _GRPI {	// GRaPhic Interface
	HMETAFILE hmf;	// metafile
	RECT   bbox;	// tightly bounds the image (in metafile units)
	ushort inch;	// metafile units per inch
} GRPI;


// Version 3 support:

#define grtEMF			0x01
#define grtWMF			0x02
#define grtPNG			0x03
#define grtPICT			0x04
#define grtJFIF			0x05

// NOTE: 
// if fPointer is fTrue, then the information is represented as
// a pointer to data rather than a handle to data.  This is not
// valid for HMETAFILE and HENHMETAFILE (as there is no pointer
// equivalent)

typedef struct _GRPIX { 	// GRaPhic Interface Extended
	ushort cbGrpix;	// size of this structure
	uchar grt;		// GRaphic Type
	ulong cbData;	// number of bytes in the graphic
	BOOL fPointer;
	union
		{
		HMETAFILE hmf;		// metafile 
		HENHMETAFILE hemf;	// enhanced metafile
		HANDLE hPng;		// handle to PNG bits
		void *pPng;			// pointer to PNG bits	(fPointer = fTrue)
		HANDLE hPict;		// handle to MacPict
		void *pPict;		// pointer to MacPict	(fPointer = fTrue)
		HANDLE hJpeg;		// handle to JPEG/JFIF
		void *pJpeg;		// pointer to JPEG/JFIF (fPointer = fTrue)
		};
	RECT bbox;			// tightly bounds the image (in metafile units)
	ulong inch;			// metafile units per inch
} GRPIX;


#ifndef WIN16

// Update the percent complete (if return value is fTrue, then
// abort the conversion) lPct is the percent
// pfnPctComplete MUST be called frequently (every 2 or 3 percent)

typedef BOOL (*PFN_PCTCOMPLETE)(long lPct, void *pvData);

#if defined(RISC)	// mips,alpha,ibm ppc,mac ppc
#define FILTAPI _cdecl
#else
#define FILTAPI PASCAL
#endif


// NOTE:  For version 3 handling, pgrpi should be cast as
//		  pgrpix = (GRPIX *)pgrpi

typedef int  (FILTAPI *PFNGetFilterInfo)(short, char *, HANDLE *, ulong);
typedef void (FILTAPI *PFNGetFilterPref)(HANDLE, HANDLE, HANDLE, ushort);
typedef int  (FILTAPI *PFNExportGr)(FILESPEC *, GRPI *, HANDLE);
typedef int  (FILTAPI *PFNExportEmbeddedGr)(FILESPEC *, GRPI *, HANDLE, ulong);
typedef int  (FILTAPI *PFNImportGr)(HDC, FILESPEC *, GRPI *, HANDLE);
typedef int  (FILTAPI *PFNImportEmbeddedGr)(HDC, FILESPEC *, GRPI *, HANDLE, ulong, char *);
typedef int  (FILTAPI *PFNRegisterPercentCallback)(HANDLE, PFN_PCTCOMPLETE, void *);
typedef int  (FILTAPI *PFNSetFilterPref)(HANDLE, char *, void *, ulong, ulong);

int  FILTAPI GetFilterInfo(short wVersion, char *pIni, 
						   HANDLE *phPrefMem, ulong lFlags);
						   
void FILTAPI GetFilterPref(HANDLE hInst, HANDLE hWnd, HANDLE hPrefMem, 
						   ushort wFlags);
						   
int  FILTAPI ExportGr(FILESPEC *pFileSpec, GRPI *pgrpi, HANDLE hPrefMem);

int  FILTAPI ExportEmbeddedGr(FILESPEC *pFileSpec, GRPI *pgrpi, HANDLE hPrefMem, ulong *pdwSize);

int  FILTAPI ImportGr(HDC hdcPrint, FILESPEC *pFileSpec, GRPI *pgrpi, 
					  HANDLE hPrefMem);
					  
int  FILTAPI ImportEmbeddedGr(HDC hdcPrint, FILESPEC *pFileSpec, GRPI *pgrpi, 
							  HANDLE hPrefMem, ulong ulSize, char *szMetaFileName);

int  FILTAPI RegisterPercentCallback(HANDLE hPrefMem, PFN_PCTCOMPLETE pfnPctComplete, void *pvData);

int  FILTAPI SetFilterPref(HANDLE hPrefMem, char *szOption, void *pvValue, ulong dwSize, ulong dwType);

#endif // WIN16


// Definitions of ordinal values for entry points
// backwards compatibility only
#define ordGetFilterInfo ((DWORD)1)
#define ordImportGr ((DWORD)2)


// SetFilterPref data types
// these exactly parallel a subset of Win32 registry value data types
#if !defined(REG_NONE) || !defined(REG_SZ) || !defined(REG_BINARY) || !defined(REG_DWORD)
#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // '\0' terminated string
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#endif


// ERROR RETURN VALUES
#define IE_NO_ERROR				0
#define IE_INTERNAL_ERROR		(-1)

#define IE_BASE				0x14B4
#define IE(err)				(IE_BASE + err)

// IMPORT/EXPORT ERRORS
#define IE_NOT_MY_FILE		IE(0x0001)	// generic not my file error
#define IE_TOO_BIG			IE(0x0002)	// bitmap or pict too big error
#define IE_DUMB_BITMAP		IE(0x0003)	// bitmap all white
#define IE_BAD_VCHAR		IE(0x0004)	// bad vchar in ImportString
#define IE_BAD_TOKEN		IE(0x0005)	// illegal wp token
#define IE_NO_VERIFY		IE(0x0006)	// failed to verify imported story
#define IE_UNKNOWN_TYPE		IE(0x0007)	// unknown file type
#define IE_NOT_WP_FILE		IE(0x0008)	// not a wp file
#define IE_BAD_FILE_DATA	IE(0x0009)	// current file data is bad
#define IE_IMPORT_ABORT		IE(0x000A)	// import abort alert
#define IE_MEM_FULL			IE(0x000B)	// ran out of memory during import
#define IE_MSNG_FONTS		IE(0x000C)	// system font not found
#define IE_META_TOO_BIG		IE(0x000D)	// metafile too big
#define IE_MEM_FAIL			IE(0x000F)	// couldn't lock memory during import
#define IE_NO_FILTER		IE(0x0012)	// expected filter not found

#define IE_UNSUPP_COMPR		IE(0x0029)	// unsupported compress style
#define IE_UNSUPP_VERSION	IE(0x002A)	// unsupported file version
#define IE_UNSUPP_COLOR		IE(0x002B)	// unsupported color style

#define IE_ERROR_NOMSG		IE(0x0037)	// dialog box cancel
#define IE_FILE_NOT_FOUND	IE(0x003C)	// file not found
#define IE_BUG				IE(0x0051)
#define IE_BAD_METAFILE		IE(0x0053)	// inconsistent metafile data
#define IE_BAD_METAFILE2	0xCCCC		// inconsistent metafile data

#define IE_BAD_PARAM		IE(0x0100)	// bad parameter passed by client
#define IE_UNSUPP_FORMAT	IE(0x0101)	// cannot provide/accept format
#define FA_DISK_ERROR		7015


// values for WPG-specific PRF fields (for GetFilterPref)
// backwards compatibility only
#define bBGIni			0	// do what the mstxtcnv.ini file says
#define bBGDiscard		1	// discard the background
#define bBGKeep			2	// keep the background

#define bCCNone			0
#define bCCOutline		1	// convert black to black, all others to white
#define bCCBlackWhite	2	// convert white to white, all others to black
#define bCCInvert		3	// invert all colours, except black and white
#define bCCOutline6		4	// true outline
#define bCCSilhouette	5	// everything to black
#define bCCInvert6		6	// invert all colours, including black<->white

#define bMRNone			0
#define bMRHorizontal	1	// flip image horizontally, across y-axis
#define bMRVertical		2	// flip image vertically, across x-axis

typedef struct _PRF
	{
	uchar fSilent;
	uchar bBackground;
	uchar bColorChange;
	uchar bMirror;	// formerly fMirror
	unsigned dgRotate;
	} PRF;
#pragma pack()

#endif // !FILTAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\ferr.h ===
// File Error Identifiers
//
// When adding error ids here, be sure to add an entry in the mpidserr
// table in mytlab.cpp to indicate what string to display to the user!

#define ferrFirst           1000

#define ferrIllformedGroup      1000
#define ferrReadFailed          1001
#define ferrIllformedFile       1002
#define ferrCantProcNewExeHdr   1003
#define ferrCantProcOldExeHdr   1004
#define ferrBadMagicNewExe      1005
#define ferrBadMagicOldExe      1006
#define ferrNotWindowsExe       1007
#define ferrExeWinVer3          1008
#define ferrNotValidRc          1009
#define ferrNotValidExe         1010
#define ferrNotValidRes         1011
#define ferrNotValidBmp         1012
#define ferrNotValidIco         1013
#define ferrNotValidCur         1014
#define ferrRcInvalidExt        1015
#define ferrFileAlreadyOpen     1016
#define ferrExeTooLarge         1017
#define ferrCantCopyOldToNew    1018
#define ferrReadLoad            1019
#define ferrExeAlloc            1020
#define ferrExeInUse            1021
#define ferrExeEmpty            1022
#define ferrGroup               1023
#define ferrResSave             1024
#define ferrSaveOverOpen        1025
#define ferrSaveOverReadOnly    1026
#define ferrCantDetermineType   1027
#define ferrSameName            1028
#define ferrSaveAborted         1029
#define ferrLooksLikeNtRes      1030
#define ferrCantSaveReadOnly    1031
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\fixhelp.cpp ===
// fixhelp.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

BOOL g_fDisableStandardHelp = FALSE ;

HHOOK g_HelpFixHook = (HHOOK) 0 ;

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam) ;

class CWordPadCWnd : public CWnd
{
public:

	LRESULT CallDWP(UINT nMsg, WPARAM wParam, LPARAM lParam)
   {
	    return DefWindowProc(nMsg, wParam, lParam) ;
   }
} ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc)
{
    //
    // Subclass the main window proc if we are supposed to
	// and if MFC has alread subclassed it
    //

    if (fFixWndProc)
    {
        if (GetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
	     {
              SetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC,
                               (LONG_PTR)HelpFixDialogProc);
	     }
    }

	//
    // Search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
	//

    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
        {
            SetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC,
                              (LONG_PTR)HelpFixControlProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		//
        // bypass MFC's handler, message will be sent to
		// parent of the control
		//

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		CWordPadCWnd* pWnd = (CWordPadCWnd *) CWnd::FromHandlePermanent(hwnd) ;

		//
        // bypass MFC's handler, message will be sent to window proc for
		// the dialog box
		//

		if (NULL != pWnd)
		{
            return pWnd->CallDWP(uMsg, wParam, lParam) ;
		}
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}


void SetHelpFixHook(void)
{
   g_HelpFixHook = ::SetWindowsHookEx(
                        WH_CALLWNDPROC,
                        (HOOKPROC) HelpFixHook,
                        NULL,
                        ::GetCurrentThreadId());
}

void RemoveHelpFixHook(void)
{
    ::UnhookWindowsHookEx(g_HelpFixHook) ;

    g_HelpFixHook = (HHOOK) 0 ;
}

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam)
{
    if (code < 0)
    {
        return ::CallNextHookEx(
                   g_HelpFixHook,
                   code,
                   wParam,
                   lParam) ;
    }

    CWPSTRUCT *pcwps = (CWPSTRUCT *) lParam ;

    if (pcwps->message == WM_INITDIALOG)
    {
        CWnd *pWnd = CWnd::FromHandlePermanent(pcwps->hwnd) ;

        if (pWnd != NULL)
        {
            FixHelp(pWnd, TRUE) ;
        }
    }

    return ::CallNextHookEx(
                g_HelpFixHook,
                code,
                wParam,
                lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\hlpcntxt.h ===
// The following identifiers are used to invoke help for
// particular controls or groups of controls in MSPAINT

// Help Contexts for "Image | Attributes..." dialog
#define IDH_PAINT_IMAGE_ATTR_WIDTH                              30000
#define IDH_PAINT_IMAGE_ATTR_HEIGHT                             30010
// #define      IDH_PAINT_IMAGE_ATTR_UNITS_GROUP                30020
#define IDH_PAINT_IMAGE_ATTR_UNITS_INCHES               30021
#define IDH_PAINT_IMAGE_ATTR_UNITS_CM                   30022
#define IDH_PAINT_IMAGE_ATTR_UNITS_PELS                 30023
// #define      IDH_PAINT_IMAGE_ATTR_COLORS_GROUP               30030
#define IDH_PAINT_IMAGE_ATTR_COLORS_BW                  30031
#define IDH_PAINT_IMAGE_ATTR_COLORS_COLORS              30032
#define IDH_PAINT_IMAGE_ATTR_DEFAULT                    30040
#define IDH_PAINT_IMAGE_ATTR_LASTSAVED                  30050
#define IDH_PAINT_IMAGE_ATTR_SIZE                       30051
#define IDH_PAINT_IMAGE_ATTR_USE_TRANSP                 30052
#define IDH_PAINT_IMAGE_ATTR_SEL_COLOR                  30053
#define IDH_PAINT_IMAGE_ATTR_PREVIEW                    30054

// Help Contexts for "Image | Flip and Rotate" dialog
// #define IDH_PAINT_IMAGE_FLIP_GROUP                           30100
#define IDH_PAINT_IMAGE_FLIP_HORIZ                              30101
#define IDH_PAINT_IMAGE_FLIP_VERT                               30102
#define IDH_PAINT_IMAGE_FLIP_ROTATE                             30103

// Help Contexts for "Image | Stretch and Skew" dialog
// #define IDH_PAINT_IMAGE_STRETCH_GROUP                        30200
#define IDH_PAINT_IMAGE_STRETCH_HORIZ                           30201
#define IDH_PAINT_IMAGE_STRETCH_VERT                    30202
// #define IDH_PAINT_IMAGE_SKEW_GROUP                           30210
#define IDH_PAINT_IMAGE_SKEW_HOR                                30211
#define IDH_PAINT_IMAGE_SKEW_VERT                               30212

// Help Contexts for "View | Zoom" dialog
#define IDH_PAINT_ZOOM_CURRENT                                  30300
#define IDH_PAINT_ZOOM_SET_GROUP                                30310

// Help Contexts for common things
#define IDH_COMM_GROUPBOX                                       30400
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\global.h ===
// global.h
//

#ifndef __GLOBAL_H__
#define __GLOBAL_H__

// hard-coded colors to be used instead of COLOR_BTNFACE, _BTNTEXT, etc.
//  - hese are for access via MyGetSysColor() - and GetSysBrush()
#define CMP_COLOR_HILITE    25  // RGB(255, 255, 255)
#define CMP_COLOR_LTGRAY    26  // RGB(192, 192, 192) - instead of BtnFace
#define CMP_COLOR_DKGRAY    27  // RGB(128, 128, 128)
#define CMP_COLOR_BLACK     28  // RGB(0, 0, 0) - instead of frame

// - these are for when all you need is a RGB value)
#define CMP_RGB_HILITE      RGB(255, 255, 255)
#define CMP_RGB_LTGRAY      RGB(192, 192, 192)  // instead of BtnFace
#define CMP_RGB_DKGRAY      RGB(128, 128, 128)
#define CMP_RGB_BLACK       RGB(0, 0, 0)        // instead of frame

#define HID_BASE_BUTTON    0x00070000UL        // IDMB and IDMY

extern CBrush*  GetHalftoneBrush();
extern CBrush*  GetSysBrush(UINT nSysColor);
extern void     ResetSysBrushes();
extern COLORREF MyGetSysColor(UINT nSysColor);

// Remove the drive and directory from a file name...
//
CString StripPath(const TCHAR* szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
//
CString StripName(const TCHAR* szFilePath);

// Remove the name part of a file path.  Return just the drive and directory, and name.
//
CString StripExtension(const TCHAR* szFilePath);

// Get only the extension of a file path.
//
CString GetExtension(const TCHAR* szFilePath);

// Get the name of a file path.
//
CString GetName(const TCHAR* szFilePath);

// Return the path to szFilePath relative to szDirectory.  (E.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(const TCHAR* szFilePath, const TCHAR* szDirectory = NULL);

void PreTerminateList( CObList* pList );

#endif // __GLOBAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\global.cpp ===
#include "stdafx.h"


#include <direct.h>

#include <tchar.h>
#include "global.h"

#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG

#include "memtrace.h"

/***************************************************************************/

//
// This function returns a pointer to a monochrome GDI brush with
// alternating "black" and "white" pixels.  This brush should NOT
// be deleted!
//
CBrush* GetHalftoneBrush()
    {
    static CBrush NEAR halftoneBrush;

    if (halftoneBrush.m_hObject == NULL)
        {
        static WORD NEAR rgwHalftone [] =
            {
            0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555
            };

        CBitmap bitmap;

        if (!bitmap.CreateBitmap(8, 8, 1, 1, rgwHalftone))
            return NULL;

        if (!halftoneBrush.CreatePatternBrush(&bitmap))
            return NULL;
        }

    return &halftoneBrush;
    }

/////////////////////////////////////////////////////////////////////////////
//
// The following code manages a cache of GDI brushes that correspond to
// the system defined colors.  The cache is flushed when the user changes
// any of the system colors using the control panel.  Using GetSysBrush()
// to get a system colored brush will be more efficient than creating the
// brush yourself.
//
void ResetSysBrushes()
    {
    //NOTE: we don't include our extensions to the "system" brushes, because
    //  often the brush handle is used as hbrBackground for a Window class!
    for (UINT nBrush = 0; nBrush < nSysBrushes + nOurBrushes; nBrush++)
        if (theApp.m_pbrSysColors[nBrush])
            {
            delete theApp.m_pbrSysColors[nBrush];
            theApp.m_pbrSysColors[nBrush] = NULL;
            }
    }

COLORREF MyGetSysColor(UINT nSysColor)
    {
    if (nSysColor < nSysBrushes)
        return ::GetSysColor( nSysColor );

    static COLORREF NEAR rgColors[nOurBrushes] =
        {
        CMP_RGB_HILITE, CMP_RGB_LTGRAY, CMP_RGB_DKGRAY, CMP_RGB_BLACK,
        };

    ASSERT((int)nSysColor - CMP_COLOR_HILITE >= 0);
    ASSERT((int)nSysColor - CMP_COLOR_HILITE < nOurBrushes);

    return rgColors[nSysColor - CMP_COLOR_HILITE];
    }

CBrush* GetSysBrush(UINT nSysColor)
    {
    ASSERT(nSysColor < nSysBrushes + nOurBrushes);

    if (! theApp.m_pbrSysColors[nSysColor])
        {
        COLORREF cr = MyGetSysColor(nSysColor);

        theApp.m_pbrSysColors[nSysColor] = new CBrush;

        if (theApp.m_pbrSysColors[nSysColor])
            {
            if (! theApp.m_pbrSysColors[nSysColor]->CreateSolidBrush( cr ))
                {
                TRACE( TEXT("GetSysBrush failed!\n") );
                theApp.SetGdiEmergency();

                delete theApp.m_pbrSysColors[nSysColor];
                theApp.m_pbrSysColors[nSysColor] = NULL;
                }
            }
        else
            theApp.SetMemoryEmergency();
        }

    return theApp.m_pbrSysColors[nSysColor];
    }


//
//      PreTerminateList
//              Helper function for deleting all objects in a list, and then
//              truncating the list.  Help stop leaks by using this, so your
//              objects don't get left in memory.
//

void PreTerminateList( CObList* pList )
    {
    if (pList == NULL || pList->IsEmpty())
        return;

    while (! pList->IsEmpty())
        {
        CObject* pObj = pList->RemoveHead();
        delete pObj;
        }
    }

/////////////////////////////////////////////////////////////////////////////


void MySplitPath (const TCHAR *szPath, TCHAR *szDrive, TCHAR *szDir, TCHAR *szName, TCHAR *szExt)
    {
       // Found this in tchar.h
       _tsplitpath (szPath, szDrive, szDir, szName, szExt);
    }

// Remove the drive and directory from a file name...
//
CString StripPath(const TCHAR* szFilePath)
    {
    TCHAR szName [_MAX_FNAME + _MAX_EXT];
    TCHAR szExt [_MAX_EXT];
    MySplitPath(szFilePath, NULL, NULL, szName, szExt);
    lstrcat(szName, szExt);
    return CString(szName);
    }

// Remove the name part of a file path.  Return just the drive and directory.
//
CString StripName(const TCHAR* szFilePath)
    {
    TCHAR szPath [_MAX_DRIVE + _MAX_DIR];
    TCHAR szDir [_MAX_DIR];
    MySplitPath(szFilePath, szPath, szDir, NULL, NULL);
    lstrcat(szPath, szDir);
    return CString(szPath);
    }

// Remove the name part of a file path.  Return just the drive and directory, and name.
//
CString StripExtension(const TCHAR* szFilePath)
    {
    TCHAR szPath [_MAX_DRIVE + _MAX_DIR + _MAX_FNAME];
    TCHAR szDir [_MAX_DIR];
    TCHAR szName [_MAX_FNAME];
    MySplitPath(szFilePath, szPath, szDir, szName, NULL);
    lstrcat(szPath, szDir);
    lstrcat(szPath, szName);
    return CString(szPath);
    }

// Get the extension of a file path.
//
CString GetExtension(const TCHAR* szFilePath)
    {
    TCHAR szExt [_MAX_EXT];
    MySplitPath(szFilePath, NULL, NULL, NULL, szExt);
    return CString(szExt);
    }

// Get the name of a file path.
//
CString GetName(const TCHAR* szFilePath)
    {
    TCHAR szName [_MAX_FNAME];
    MySplitPath(szFilePath, NULL, NULL, szName, NULL);
    return CString(szName);
    }


// Return the path to szFilePath relative to szDirectory.  (E.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
// If szDirectory is NULL, the current directory is used.
//
CString GetRelativeName(const TCHAR* szFilePath, const TCHAR* szDirectory /*= NULL*/)
    {
    CString strDir;

    if ( szDirectory == NULL )
        {
        GetCurrentDirectory(_MAX_DIR, strDir.GetBuffer(_MAX_DIR) );
        strDir.ReleaseBuffer();
        strDir += (TCHAR)TEXT('\\');
        szDirectory = strDir;
        }

    int cchDirectory = lstrlen(szDirectory);
    if (_tcsnicmp(szFilePath, szDirectory, cchDirectory) == 0)
        return CString(szFilePath + cchDirectory);
    else if ( szFilePath[0] == szDirectory[0] &&
              szFilePath[1] == TEXT(':') && szDirectory[1] == TEXT(':') )    // Remove drive if same.
        return CString(szFilePath + 2);

    return CString(szFilePath);
    }
#if 0
/////////////////////////////////////////////////////////////////////////////
//  Taken from windows system code.  Contains intl support.
/* Returns: 0x00 if no matching char,
 *      0x01 if menmonic char is matching,
 *      0x80 if first char is matching
 */

#define CH_PREFIX TEXT('&')

int FindMnemChar(LPTSTR lpstr, TCHAR ch, BOOL fFirst, BOOL fPrefix)

    {
    register TCHAR chc;
    register TCHAR chnext;
    TCHAR      chFirst;

    while (*lpstr == TEXT(' '))
        lpstr++;

    ch = (TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)ch);
    chFirst = (TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)(*lpstr));

    #ifndef DBCS
    if (fPrefix)
        {
        while (chc = *lpstr++)
            {
            if (((TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)chc) == CH_PREFIX))
                {
                chnext = (TCHAR)(DWORD)CharLower((LPTSTR)(DWORD)(BYTE)*lpstr);

                if (chnext == CH_PREFIX)
                    lpstr++;
                  else
                      if (chnext == ch)
                          return(0x01);
                      else
                          {
                          return(0x00);
                            }
                }
            }
        }
    #else
    #ifdef JAPAN
    if (fPrefix)
        {
        WORD wvch, xvkey;

        // get OEM-dependent virtual key code
        if ((wvch = VkKeyScan((BYTE)ch)) != -1)
        wvch &= 0xFF;

        while (chc = *lpstr++)
            {
            if (IsDBCSLeadByte(chc))
                {
                lpstr++;
                continue;
                }

            if ( (chc == CH_PREFIX) ||
               (KanjiMenuMode == KMM_ENGLISH && chc == CH_ENGLISHPREFIX) ||
               (KanjiMenuMode == KMM_KANJI   && chc == CH_KANJIPREFIX))
                {
                chnext = (TCHAR)CharLower((LPTSTR)(DWORD)(BYTE)*lpstr);

                if (chnext == CH_PREFIX)
                    lpstr++;
                else
                    if (chnext == ch)
                        return(0x01);

                // Compare should be done with virtual key in Kanji menu mode
                // in order to accept Digit shortcut key and save English
                // windows applications!
                xvkey = VkKeyScan((BYTE)chnext);

                if (xvkey != 0xFFFF && (xvkey & 0xFF) == wvch)
                    return(0x01);
                else
                    return(0x00);
                }
            }
        }
    #else
    #ifdef KOREA
    if( fPrefix )
        {
        WORD  wHangeul;
        register TCHAR  chnext2;

        if( KanjiMenuMode != KMM_KANJI )
            {
            while (chc = *lpstr++)
                {
                if (IsDBCSLeadByte(chc))
                    {
                    lpstr++;
                    continue;
                    }
                if ( (chc == CH_PREFIX) ||
                     (KanjiMenuMode == KMM_ENGLISH && chc == CH_ENGLISHPREFIX))
                    {
                    chnext = (TCHAR)CharLower((LPTSTR)(DWORD)(BYTE)*lpstr);

                    if (chnext == CH_PREFIX)
                        lpstr++;
                    else
                        if (chnext == ch)
                            return(0x01);
                        else
                            return(0x00);
                    }
                }
            }
        else
            { //KMM_KANJI
            if( ch >= TEXT('0') && ch <= TEXT('9') )
                wHangeul = 0x0a3b0 | ( (BYTE)ch & 0x0f );   // junja 0 + offset
            else
                if( ch >= TEXT('a') && ch <= TEXT('z') )
                    wHangeul = TranslateHangeul( ch );
                else
                    return(0x00);

            while (chc = *lpstr++)
                {
                if (IsDBCSLeadByte(chc))
                    {
                    lpstr++;
                    continue;
                    }
                if(chc == CH_KANJIPREFIX)
                    {
                    chnext = *lpstr++;
                    chnext2 = *lpstr;

                    if(chnext == HIBYTE(wHangeul) && chnext2 == LOBYTE(wHangeul))
                        return(0x01);
                    else
                        return(0x00);
                    }
                }
            }
    #endif  //KOREA
    #endif  //JAPAN
    #endif  //!DBCS

    if (fFirst && (ch == chFirst))
        return(0x80);

    return(0x00);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\image.h ===
//***************************************************************************
//
//	IMAGE.h
//
// Proposed new interface!
//
//		Include file for the Image API Library.
//    This is the external containing header data required
//    by the outside world.
//
//	Revision History
//		17-Nov-95	TerryJ		Original
//    04-Jan-96   TerryJ      Code cleaned up. Memory mode added.
//    16-Jan-96   TerryJ      Registry validation capacity added.
//    
//
//***************************************************************************

#ifndef  _IMAGEFILELIB_H
#define  _IMAGEFILELIB_H

#include "msffdefs.h"   //include platform dependent defs

#ifdef _MAC
#include <Macname1.h>
#include "Types.h"
#include "Files.h"
#include <Macname2.h>
#endif // _MAC

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif   // __cplusplus

/***********
| IFLMODE:	Open modes
\***********/
typedef enum
   {
   IFLM_READ	    =0x00,
   IFLM_WRITE	    =0x01,
   IFLM_MEMORY     =0x80,    // OR to operate in memory
   IFLM_EXTRACT_ALPHA  =0x40,    // OR to extract separate image and alpha channel info
   IFLM_CHUNKY_ALPHA   =0x20,    //OR to extract RGBA chunky data
   } IFLMODE;

/***********
| IFLCLASS:	Image classes
\***********/
typedef enum
   {
   IFLCL_BILEVEL     = 0,   // 1 BPP
   IFLCL_GRAY        = 1,   // 2,4,6,8 BPP
   IFLCL_GRAYA       =11,   // 16 BPP chunky 
   IFLCL_PALETTE     = 2,   // 2,4,6,8 BPP
   IFLCL_RGB         = 3,   // 24 BPP chunky
   IFLCL_RGBPLANAR   = 4,   // 24 BPP in 8 bit planes
   IFLCL_RGBA        = 5,   // 32 BPP chunky
   IFLCL_RGBAPLANAR  = 6,   // 32 BPP in four 8 bit planes
   IFLCL_CMYK        = 7,
   IFLCL_YCC         = 8,
   IFLCL_CIELAB      = 9,
   IFLCL_NONE        =10   // no class set! (error)
   } IFLCLASS;

typedef enum
   {
   IFLTF_NONE     =0,
   IFLTF_STRIPS   =1,
   IFLTF_TILES    =2
   } IFLTILEFORMAT;

/***********
| IFLCOMMAND:	 Commands to IFL_Control
\***********/
typedef enum
   {
   IFLCMD_GETERROR      =0,   // get error code
   IFLCMD_GETLINESIZE   =1,   // compute line size
   IFLCMD_PALETTE       =2,   // get or set palette or map
   IFLCMD_SETPACKMODE   =3,   // set mode for packing/unpacking pixels
   IFLCMD_RESOLUTION    =7,   // get dots per meter
   IFLCMD_GETNUMIMAGES  =10,  // get the number of images
   IFLCMD_IMAGESEEK     =11,  // seek to the next image
   IFLCMD_DELETE        =12,  // delete current image
   IFLCMD_TILEFORMAT    =13,  // set/get the tiling format
   IFLCMD_YCCINFO       =14,  // set/get YCC information
   IFLCMD_YCCRGBCONVERT =15,  // set/get YCC/RGB conversion state
   IFLCMD_COLORIMETRY   =16,  // set/get Colorimetry info
   IFLCMD_CMYKINFO      =17,  // set/get CMYK specific data

   IFLCMD_BKGD_IDX      =18,  // set/get background color by index
   IFLCMD_BKGD_RGB      =19,  // set/get background color
   IFLCMD_TRANS_IDX     =20,  // set/get transparency color index
   IFLCMD_TRANS_RGB     =21,  // set/get transparency color
   IFLCMD_TRANS_MASK_INFO     =22,  // set/get transparency mask info
   IFLCMD_TRANS_MASK          =23,  // set/get transparency mask
   IFLCMD_ALPHA_PALETTE_INFO  =24,  // set/get alpha palette info
   IFLCMD_ALPHA_PALETTE       =25,  // set/get alpha palette
   IFLCMD_ALPHA_CHANNEL_INFO  =26,  // set/get alpha channel info
   IFLCMD_ALPHA_CHANNEL       =27,  // set/get alpha channel
   IFLCMD_GAMMA_VALUE         =28,  // set/get gamma value

   IFLCMD_FIRST_TEXT          =29,  // get first text string
   IFLCMD_NEXT_TEXT           =30,  // get next text strings.
   IFLCMD_DATETIME_STRUCT     =31,  // retrieve date/time as a structure.

   IFLCMD_TIFF          =0x4000,    // TIFF specific commands
   IFLCMD_TIFFTAG       =0x4001,
   IFLCMD_TIFFTAGDATA   =0x4002,
   IFLCMD_PCX           =0x4200,    // PCX specific commands
   IFLCMD_BMP           =0x4400,    // BMP specific commands
   IFLCMD_BMP_VERSION   =0x4401,    // Windows os2 1.2 os2 2.0 versions
   IFLCMD_TGA           =0x4800,    // TGA specific commands
   IFLCMD_GIF           =0x4E00,    // GIF specific commands
   IFLCMD_GIF_WHITE_IS_ZERO =0x4E01,   // White == 0 in GIF file
   IFLCMD_JPEG          =0x5700,    // WPG specific commands
   IFLCMD_JPEGQ         =0x5701,    // Quality
   IFLCMD_PCD           =0x5800,    // Kodak PCD specific commands
   IFLCMD_PCDGETTRANSFORM  =0x5801,
   IFLCMD_PCDSETTRANSFORM  =0x5802,
   IFLCMD_PCDSETCLASS      =0x5803,
   IFLCMD_PNG           =0x5900,    // PNG specific commands
   IFLCMD_PNG_SET_FILTER   =0x590A, // Set PNG filter type
   IFLCMD_PNG_sBIT         =0x590B, // set/get PNG sBIT chunk

   IFLCMD_GETDATASIZE      =0x8000  // OR with this to get the size
   } IFLCOMMAND;

typedef IFLCOMMAND IFLCMD;    // this is done as backwards 
                              // compatibility and may be able
                              // to be eliminated eventually

/***********
| IFLDESC:	 Available description strings (use as bitfields)
\***********/
typedef enum
   {
   IFLDESC_NONE          =0,   // no descriptions supported
   IFLDESC_DESCRIPTION   =1,   // image description field (TIFF TGA PNG)
   IFLDESC_SOFTWARENAME  =2,   // software name (TIFF TGA)  Software (PNG)
   IFLDESC_ARTISTNAME    =4,   // artist name (TIFF TGA)    Author (PNG)
   IFLDESC_DOCUMENTNAME  =8,   // the document name field   Title (PNG)
   IFLDESC_DATETIME      =16,  // the date/time field
   IFLDESC_COPYRIGHT     =32,  // copyright notice (PNG)
   IFLDESC_DISCLAIMER    =64,  // Legal disclaimer (PNG)
   IFLDESC_WARNING       =128, // content warning (PNG)
   IFLDESC_SOURCE        =256, // source device (PNG)
   IFLDESC_COMMENT       =512, // misc comment (PNG)
   } IFLDESC;

/***********
| IFLPACKMODE:	 Packing modes
\***********/
typedef enum
   {
   IFLPM_PACKED         =0,
   IFLPM_UNPACKED       =1,
   IFLPM_LEFTJUSTIFIED  =2,
   IFLPM_NORMALIZED     =3,
   IFLPM_RAW            =4
   } IFLPACKMODE;

/***********
| IFLSEQUENCE:	Line sequences
\***********/
typedef enum
   {
   IFLSEQ_TOPDOWN    =0,         // most
   IFLSEQ_BOTTOMUP   =1,         // BMP and TGA compressed
   IFLSEQ_GIF_INTERLACED =2,     // for GIF
   IFLSEQ_ADAM7_INTERLACED = 3   // for PNG
   } IFLSEQUENCE;

/***********
| IFLERROR:	Possible errors
\***********/
typedef enum
   {
   IFLERR_NONE          =0,   // no error
   IFLERR_HANDLELIMIT   =1,   // too many open files
   IFLERR_PARAMETER     =2,   // programmer error
   IFLERR_NOTSUPPORTED  =3,   // feature not supported by format
   IFLERR_NOTAVAILABLE  =4,   // item not available
   IFLERR_MEMORY        =5,   // insufficient memory
   IFLERR_IMAGE         =6,   // bad image data (decompression error)
   IFLERR_HEADER        =7,   // header has bad fields
   IFLERR_IO_OPEN       =8,   // error on open()
   IFLERR_IO_CLOSE      =9,   // error on close()
   IFLERR_IO_READ       =10,  // error on read()
   IFLERR_IO_WRITE      =11,  // error on write()
   IFLERR_IO_SEEK       =12,  // error on lseek()
   } IFLERROR;

 typedef enum    // new error messages to go here. This error
                  // info is maintained here rather than IFLERROR
                  // to retain backwards compatibility
 
   {
   IFLEXTERR_NONE,
   IFLEXTERR_NO_DLL,             // open
   IFLEXTERR_NO_LIBRARY,         // open: no library specified
   IFLEXTERR_BAD_DLL,            // DLL doesn't have right entry points
   IFLEXTERR_CANNOT_IMPORT,      // open
   IFLEXTERR_CANNOT_EXPORT,      // open
   IFLEXTERR_CANNOT_COMPRESS,    // open
   IFLEXTERR_BAD_FORMAT,         // read
   IFLEXTERR_UNKNOWN_VARIANT,    // open/read: for example, JFIFs and
                                 // BMPs have many variants - some may
                                 // not be supported
   IFLEXTERR_SHARING_VIOLATION,        // read
   IFLEXTERR_NO_BACKGROUND_COLOR,      // read: no background color specified
                                       // when doing transparencies
   IFLEXTERR_BACKGROUND_NOT_SUPPORTED, // background colors not supported
                                       // (currently) by this format
   IFLEXTERR_NO_FILE,            // file doesn't exist
   IFLEXTERR_END_OF_FILE,        // read
   IFLEXTERR_MEMORY,             // insufficient memory
   IFLEXTERR_DESC_CANNOT_GET,    // file is write mode: can't get descriptions
   IFLEXTERR_DESC_CANNOT_SET,    // file is read mode: can't set descriptions
   IFLEXTERR_NO_PATH_IN_REGISTRY,   // the filter path isn't in the registry
   IFLEXTERR_NOT_IFL_HANDLE,     // the pointer passed isn't an IFLHANDLE
   IFLEXTERR_REGISTRY_DAMAGED,   // entry in registry not correct format
   IFLEXTERR_BAD_COMPRESSION,    // error in data compression; cannot read.
   } IFLEXTERROR;


/***********
| IFLCOMPRESSION:	Compression options
\***********/
typedef enum
   {
   IFLCOMP_NONE      =0,   // no compression
   IFLCOMP_DEFAULT   =1,   // whatever is defined for the format
   IFLCOMP_RLE       =2,   // various RLE schemes (PACKBITS in TIFF)
   IFLCOMP_CCITT1D   =3,   // TIFF modified G3
   IFLCOMP_CCITTG3   =4,   // TIFF raw G3
   IFLCOMP_CCITTG4   =5,   // TIFF G4
   IFLCOMP_LZW       =6,   // Lempel-Zif
   IFLCOMP_LZWHPRED  =7,   // LZW with TIFF horizontal differencing
   IFLCOMP_JPEG      =8    // JPEG compression
   } IFLCOMPRESSION;

/***********
| Date Time structure for IFL
\***********/
typedef struct
   {
   short Year;
   short Month;
   short Day;
   short Hour;
   short Minute;
   short Second;
   } IFL_DATETIME;

/***********
| RGB color structure for IFL
\***********/
typedef struct  // rgb color values
   {
   BYTE  bRed;
   BYTE  bGreen;
   BYTE  bBlue;
   } IFLCOLORRGB;

typedef struct  // new color struct capable of 16 bit values. 
   {            
   WORD  wRed;
   WORD  wGreen;
   WORD  wBlue;
   }  IFLCOLOR;

/***********
| Types for multiple images
\***********/
typedef enum
   {
   IFLIT_PRIMARY     =0,
   IFLIT_THUMBNAIL   =1,
   IFLIT_MASK        =2
   } IFLIMAGETYPE;

/***********
| Bitmap types
\***********/
typedef enum
   {
   IFLBV_WIN_3    =0x10,   // Windows 3.x
   IFLBV_OS2_1    =0x20,   // OS2 1.2
   IFLBV_OS2_2S   =0x40,   // OS2 2.0 single image
   IFLBV_OS2_2M   =0x41    // OS2 2.0 multiple image
   } IFLBMPVERSION;


/***********
| Capabilities Type, for interpreting Registry info
\***********/
typedef enum
   {
   IFLCAP_NOT_AVAILABLE =0x0000,    // if option not available
      
      // ** compression options **
   IFLCAP_COMPNONE      =0x0001,
   IFLCAP_COMPRLE       =0x0002,
   IFLCAP_COMPG3        =0x0004,
   IFLCAP_COMPG4        =0x0008,
   IFLCAP_COMPLZW       =0x0010,
   IFLCAP_COMPLZWPRED   =0x0020,
   IFLCAP_COMPJPEG      =0x0040,
   IFLCAP_COMPDEFAULT   =0x0080,

      // ** bit plane options **     // note that for RGB, RGB QUAD
   IFLCAP_1BPP          =0x0001,     //  and RGBA bit plane depth must
   IFLCAP_2BPP          =0x0002,     //  be multiplied by 3, 4 and 4
   IFLCAP_3BPP          =0x0004,     //  respectively for the full
   IFLCAP_4BPP          =0x0008,     //  pixel depth size.
   IFLCAP_5BPP          =0x0010,
   IFLCAP_6BPP          =0x0020,
   IFLCAP_7BPP          =0x0040,
   IFLCAP_8BPP          =0x0080,
   IFLCAP_8BPP_QUAD     =0x0100,
   IFLCAP_12BPP         =0x0200,
   IFLCAP_16BPP         =0x0400,

      // ** Transparency options
   IFLCAP_NO_TRANS      =0x0000,
   IFLCAP_1BITMASK      =0x0001,
   IFLCAP_ALPHACHANNEL  =0x0002,
   IFLCAP_ALPHAPALETTE  =0x0004,
   IFLCAP_TRANSCOLOR    =0x0008,

   } IFLCAPABILITIES;


/***********
| Alpha/Transparency info structs
\***********/

typedef struct
   {
   DWORD dwWidth;
   DWORD dwHeight;
   }  IFL_TRANS_MASK_INFO;

typedef struct
   {
   DWORD dwWidth;
   DWORD dwHeight;
   WORD wBitsPerPixel;
   }  IFL_ALPHA_CHANNEL_INFO;

typedef struct
   {
   char  *szKey;
   char  *szText;
   } IFL_COMMENT_STRING;

typedef struct
   {
   unsigned char bPNGType;
   unsigned char bGrayBits;
   unsigned char bRedBits;
   unsigned char bGreenBits;
   unsigned char bBlueBits;
   unsigned char bAlphaBits;
   } IFLPNGsBIT;


/***********
| Handle types
| Use FILTERHANDLE to access filters
\***********/

typedef void far * IFLHANDLE;  // handle is a void pointer to hide the
                                 // details of the file handle from other
                                 // programmers. 

/* -------- new stuff   ---------------------- */

typedef enum
   {
   IFLT_UNKNOWN,     // unknown or unsupported file type
   IFLT_GIF,
   IFLT_BMP,
   IFLT_JPEG,
   IFLT_TIFF,
   IFLT_PNG,
   IFLT_PCD,
   IFLT_PCX,
   IFLT_TGA,
   IFLT_PICT
   } IFLTYPE;


/***********
| IFL virtual (memory) mode types
\***********/

// internal virtual (memory) file i/o routine pointers
typedef int	   (__cdecl _vopen)  (LPSTR, int, int);
typedef int    (__cdecl _vclose) (int);
typedef int	   (__cdecl _vread)  (int, LPVOID, int);
typedef int	   (__cdecl _vwrite) (int, LPVOID, int);
typedef long   (__cdecl _vlseek) (int, long, int);

// structure used to hold virtual (memory) i/o functions
// when using IFLM_MEMORY mode.
typedef struct ImageIOFuncs    
   {                           
   _vopen  *vopen;             
   _vclose *vclose;
   _vread  *vread;
   _vwrite *vwrite;
   _vlseek *vlseek;

   LPVOID  userdata;
   } IFLIOF, far * LPIFLIOF;

// structure used to hold virtual (memory) memory info
// when using IFLM_MEMORY mode.
typedef struct ImageMemStruct  
   {                           
   long    pos;                
   long    alloced;
   long    length;
   LPVOID  data;
   } IFLIOM, far * LPIFLIOM;


/***********
| IFL function prototypes
\***********/
IFLERROR HILAPI iflOpen(IFLHANDLE iflh, LPSTR FileName, IFLMODE Mode);
IFLERROR HILAPI iflClose(IFLHANDLE iflh);
IFLERROR HILAPI iflRead(IFLHANDLE iflh, LPBYTE Buffer, int NumLines);
IFLERROR HILAPI iflWrite(IFLHANDLE iflh, LPBYTE Buffer, int NumLines);
IFLERROR HILAPI iflSeek(IFLHANDLE iflh, int Line);
IFLERROR HILAPI iflControl(IFLHANDLE iflh, IFLCMD Command, short sParam, long lParam, LPVOID pParam);

   // new commands (general)

IFLERROR HILAPI iflImageType(LPSTR FileName, IFLTYPE *ImageType);
IFLTYPE  HILAPI iflTypeFromExtension (char far * Filename);
void            iflGetLibName(IFLTYPE fileType, LPSTR libName);
IFLERROR HILAPI iflFilterCap(IFLTYPE ImageType, IFLCLASS ImageClass,
                             WORD *Color, WORD *Compression,
                             WORD *Transparency);
IFLERROR HILAPI iflInstalledFilterQuery(IFLTYPE filterType,
                                        BOOL    *bImports,
                                        BOOL    *bExports);
IFLERROR HILAPI iflExtensionCount(IFLTYPE filterType,
                                  short   *sCount);
IFLERROR HILAPI iflExtensionQuery(IFLTYPE filterType,
                                  short   sExtNum,
                                  LPSTR   szExtension);
IFLERROR HILAPI iflFormatNameQuery(IFLTYPE filterType,
                                  LPSTR   szFormatName,
                                  short   sFormatNameSize);
IFLEXTERROR HILAPI iflGetExtendedError(IFLHANDLE iflh);

   // description manipulation

IFLERROR HILAPI iflGetDesc(IFLHANDLE iflh, IFLDESC DescType, LPSTR *pDescription);
IFLERROR HILAPI iflPutDesc(IFLHANDLE iflh, IFLDESC DescType, LPSTR Description);
IFLERROR HILAPI iflSupportedDesc(IFLHANDLE iflh, IFLDESC *Supports);

   // handle manipulation

IFLHANDLE HILAPI iflCreateReadHandle( IFLTYPE        ImageType);
IFLHANDLE HILAPI iflCreateWriteHandle(int           Width,         // Width of image in pixels
                                     int            Height,        // Height of image in pixels
                                     IFLCLASS       ImageClass,    // image class
                                     int            BitsPerSample, // Number of bits per sample
                                     IFLCOMPRESSION Compression,   // defined above
                                     IFLTYPE        ImageType      // Type of image (GIF, PCX, etc)
                                     );
IFLERROR HILAPI iflFreeHandle(IFLHANDLE iflh);

   // background manipulation
IFLERROR HILAPI iflGetBackgroundColor(IFLHANDLE iflh, IFLCOLOR *clBackColor);
IFLERROR HILAPI iflSetBackgroundColor(IFLHANDLE iflh, IFLCOLOR clBackColor);
IFLERROR HILAPI iflSetBackgroundColorByIndex(IFLHANDLE iflh, short iColorIndex);

   // accessors and manipulators

#ifdef _MAC
IFLERROR HILAPI iflSetMacCreator(OSType OSCreator);
#endif // _MAC
IFLCLASS    HILAPI iflGetClass(IFLHANDLE iflh);
int         HILAPI iflGetHeight(IFLHANDLE iflh);
int         HILAPI iflGetWidth(IFLHANDLE iflh);
int         HILAPI iflGetRasterLineCount(IFLHANDLE iflh);
IFLSEQUENCE HILAPI iflGetSequence(IFLHANDLE iflh);
IFLERROR    HILAPI iflSetSequence(IFLHANDLE iflh, IFLSEQUENCE iflsSeq);
IFLCOMPRESSION HILAPI iflGetCompression(IFLHANDLE iflh);
int         HILAPI iflGetBitsPerChannel(IFLHANDLE iflh);
int         HILAPI iflGetBitsPerPixel(IFLHANDLE iflh);
IFLTYPE     HILAPI iflGetImageType(IFLHANDLE iflh);

#ifdef __cplusplus
}
#endif   // __cplusplus

#endif   // _IMAGEFILELIB_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imageatt.cpp ===
// imageatt.cpp : implementation file
//

#include "stdafx.h"
#include "pbrush.h"
#include "imageatt.h"
#include "hlpcntxt.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "imgsuprt.h" // for InvalColorWnd()
#include "image.h"
#ifndef UNICODE
#include <sys\stat.h>
#endif
#include <wchar.h>
#include <tchar.h>
#include <winnls.h>
#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

#define FIXED_FLOATPT_MULTDIV 1000
#define DECIMAL_POSITIONS 2

/************************* CImageAttr dialog *******************************/
/*

There are a few things to note about the way this object/dialog functions.
It  tries not to convert the currently displayed value unless it notices the
user has modified it.  In all other cases, it works with PIXELS, the value
passed in. If the user modified the width or height,  it does 1 conversion and
then works with pixels.

For the conversion to display the different unit values, it uses the saved
pixel value.

The reason for all of this is due to only n decimal place of accuracy in the
display

The member Vars m_lWidth  and m_lHeight are in the current units (store in
the member variable m_eUnitsCurrent).

The member Vars m_lWidthPixels and m_lHeightPixels are always in Pixels and
these are what are used to convert for the display when changing the units.
*/

CImageAttr::CImageAttr(CWnd* pParent /*=NULL*/)
           : CDialog(CImageAttr::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CImageAttr)
    m_cStringWidth  = TEXT("");
    m_cStringHeight = TEXT("");
        //}}AFX_DATA_INIT

    m_eUnitsCurrent = (eUNITS)theApp.m_iCurrentUnits;

    bEditFieldModified = FALSE;

    m_bMonochrome   = FALSE;

    m_ulHeightPixels = 0;
    m_ulWidthPixels  = 0;
    m_ulHeight       = 0;
    m_ulWidth        = 0;
    m_cXPelsPerMeter = 0;
    m_cYPelsPerMeter = 0;
    }

/***************************************************************************/

void CImageAttr::DoDataExchange(CDataExchange* pDX)
    {
    // saving must be done before the generic dodataexchange below.

    if (! pDX->m_bSaveAndValidate)  // saving to dialog
        {
        FixedFloatPtToString( m_cStringWidth,  m_ulWidth  );
        FixedFloatPtToString( m_cStringHeight, m_ulHeight );
        }

    CDialog::DoDataExchange( pDX );

    //{{AFX_DATA_MAP(CImageAttr)
    DDX_Text(pDX, IDC_WIDTH, m_cStringWidth);
    DDV_MaxChars(pDX, m_cStringWidth, 5);
    DDX_Text(pDX, IDC_HEIGHT, m_cStringHeight);
    DDV_MaxChars(pDX, m_cStringHeight, 5);
        //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate) // retrieving from dialog
        {
        m_ulWidth  = StringToFixedFloatPt( m_cStringWidth  );
        m_ulHeight = StringToFixedFloatPt( m_cStringHeight );
        }
    }

/***************************************************************************/

ULONG CImageAttr::StringToFixedFloatPt( CString& sString )
    {
    ULONG iInteger = 0;
    ULONG iDecimal = 0;

    TCHAR chDecimal[2] = TEXT("."); // default to period in case GetLocaleInfo
                           // messes up somehow
    GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, chDecimal, 2);
    if (! sString.IsEmpty())
        {
        int     iPos = sString.Find( chDecimal[0] );
        LPTSTR szTmp = sString.GetBuffer( 1 );

        iInteger = FIXED_FLOATPT_MULTDIV * Atoi( szTmp );

        if (iPos++ >= 0)
            {
            LPTSTR szDecimal = szTmp + iPos;

            if (lstrlen( szDecimal ) > DECIMAL_POSITIONS)
                szDecimal[DECIMAL_POSITIONS] = 0;

            iDecimal = Atoi( szDecimal ) * 10;

            for (int i = lstrlen( szDecimal ); i < DECIMAL_POSITIONS; ++i)
                iDecimal *= 10;
            }
        }

    return ( iInteger + iDecimal );
    }

/***************************************************************************/

void CImageAttr::FixedFloatPtToString( CString& sString, ULONG ulFixedFloatPt )
    {
    ULONG iInteger =  (ulFixedFloatPt + 5) / FIXED_FLOATPT_MULTDIV;
    ULONG iDecimal = ((ulFixedFloatPt + 5) % FIXED_FLOATPT_MULTDIV) / 10;

    TCHAR chDecimal[2] = TEXT("."); // default to period in case GetLocaleInfo
                           // messes up somehow
    GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, chDecimal, 2);
    LPTSTR psz = sString.GetBufferSetLength( 24 );

    if (iDecimal)
        wsprintf( psz, TEXT("%u%s%02u"), iInteger, chDecimal,iDecimal );
    else
        wsprintf( psz,    TEXT("%u"), iInteger );

    sString.ReleaseBuffer();
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CImageAttr, CDialog)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CImageAttr)
    ON_BN_CLICKED(IDC_INCHES, OnInches)
    ON_BN_CLICKED(IDC_CENTIMETERS, OnCentimeters)
    ON_BN_CLICKED(IDC_PIXELS, OnPixels)
    ON_EN_CHANGE(IDC_HEIGHT, OnChangeHeight)
    ON_EN_CHANGE(IDC_WIDTH, OnChangeWidth)
    ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
    ON_BN_CLICKED(IDC_USE_TRANS, OnUseTrans)
    ON_BN_CLICKED(IDC_SELECT_COLOR, OnSelectColor)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CImageAttr message handlers **********************/

static DWORD ImageAttrHelpIds[] =
        {
        IDC_WIDTH_STATIC,       IDH_PAINT_IMAGE_ATTR_WIDTH,
        IDC_WIDTH,                      IDH_PAINT_IMAGE_ATTR_WIDTH,
        IDC_HEIGHT_STATIC,      IDH_PAINT_IMAGE_ATTR_HEIGHT,
        IDC_HEIGHT,                     IDH_PAINT_IMAGE_ATTR_HEIGHT,
        IDC_UNITS_GROUP,        IDH_COMM_GROUPBOX,
        IDC_INCHES,                     IDH_PAINT_IMAGE_ATTR_UNITS_INCHES,
        IDC_CENTIMETERS,        IDH_PAINT_IMAGE_ATTR_UNITS_CM,
        IDC_PIXELS,                     IDH_PAINT_IMAGE_ATTR_UNITS_PELS,
        IDC_COLORS_GROUP,       IDH_COMM_GROUPBOX,
        IDC_MONOCHROME,         IDH_PAINT_IMAGE_ATTR_COLORS_BW,
        IDC_COLORS,                     IDH_PAINT_IMAGE_ATTR_COLORS_COLORS,
        IDC_DEFAULT,            IDH_PAINT_IMAGE_ATTR_DEFAULT,
        IDC_FILEDATE_STATIC,    IDH_PAINT_IMAGE_ATTR_LASTSAVED,
        IDC_FILESIZE_STATIC,    IDH_PAINT_IMAGE_ATTR_SIZE,
        IDC_USE_TRANS,          IDH_PAINT_IMAGE_ATTR_USE_TRANSP,
        IDC_SELECT_COLOR,       IDH_PAINT_IMAGE_ATTR_SEL_COLOR,
        IDC_TRANS_PAINT,        IDH_PAINT_IMAGE_ATTR_PREVIEW,
        0, 0
        };

/***************************************************************************/

LONG
CImageAttr::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)ImageAttrHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CImageAttr::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)ImageAttrHelpIds);
return lResult;
}

/***************************************************************************/

void CImageAttr::PaintTransBox( COLORREF cr )
{
        CWnd * pWnd = GetDlgItem(IDC_TRANS_PAINT);
        CDC  * pDC  = pWnd->GetDC();

        RECT rect;
        pWnd->GetClientRect( &rect );

        CBrush newBrush( m_crTrans & 0xFFFFFF); // disregard palette-relative
        pDC->FillRect (&rect, &newBrush);
    //  CBrush * pOldBrush = pDC->SelectObject( &newBrush );
    //  pDC->Rectangle( &rect );
    //  DeleteObject( pDC->SelectObject( pOldBrush ) );

        pWnd->ReleaseDC( pDC );
}

/***************************************************************************/
#define MAX_SEP_LEN 6
#define MAX_INT_LEN 16
// convert a number into a string with commas in the right place
CString CImageAttr::ReformatSizeString(DWORD dwNumber)
        {

        NUMBERFMT nmf;
        CString strRet;
        TCHAR szSep[MAX_SEP_LEN];
        TCHAR szDec[MAX_SEP_LEN];
        CString sNumber;
        TCHAR szInt[MAX_INT_LEN];
        ZeroMemory (&nmf, sizeof(nmf));
        //
        // Fill in the NUMBERFMT with defaults for the user locale,
        // except for "fractional digits" being 0
        //
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_ILZERO,
                       szInt, MAX_INT_LEN);
        nmf.LeadingZero = _ttol (szInt);
        nmf.Grouping = 3;
        nmf.lpDecimalSep = (LPTSTR)szDec;
        nmf.lpThousandSep = (LPTSTR)szSep;
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,  nmf.lpDecimalSep,
                       MAX_SEP_LEN);
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_STHOUSAND,  nmf.lpThousandSep,
                       MAX_SEP_LEN);
        GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_INEGNUMBER,
                       szInt,MAX_INT_LEN);
        nmf.NegativeOrder = _ttol (szInt);

        _ltot(dwNumber, sNumber.GetBuffer(20), 10);
        sNumber.ReleaseBuffer();
        int nChar = GetNumberFormat (LOCALE_USER_DEFAULT, 0, sNumber,
                                     &nmf, (LPTSTR)NULL, 0);
        if (nChar)
        {
           GetNumberFormat (LOCALE_USER_DEFAULT, 0, sNumber,
                            &nmf, strRet.GetBuffer(nChar), nChar);
           strRet.ReleaseBuffer();
           return strRet;
        }
        return CString(TEXT("0"));
}

/***************************************************************************/

void CImageAttr::UpdateResolutionString()
{
    CString cstrResolution;

    if (m_cXPelsPerMeter == 0 || m_cYPelsPerMeter == 0)
    {
        VERIFY(cstrResolution.LoadString(IDS_RESOLUTION_NA));
    }
    else
    {
        CString cstrResolutionFormat;

        VERIFY(cstrResolutionFormat.LoadString(IDS_RESOLUTION));

        cstrResolution.Format(cstrResolutionFormat, 
            MulDiv(m_cXPelsPerMeter, 254, 10000), 
            MulDiv(m_cYPelsPerMeter, 254, 10000));
    }

    CWnd *pResolution = GetDlgItem(IDC_RESOLUTION_STATIC);

    pResolution->SetWindowText(cstrResolution);
}

/***************************************************************************/

BOOL CImageAttr::OnInitDialog()
{
    CDialog::OnInitDialog();
    CWnd * pFileDate = GetDlgItem(IDC_FILEDATE_STATIC);
    CWnd * pFileSize = GetDlgItem(IDC_FILESIZE_STATIC);
    CString cstrFileDate;
    CString cstrFileSize;

    if (((CPBApp *)AfxGetApp())->m_sCurFile.IsEmpty())
    {
        VERIFY(cstrFileDate.LoadString(IDS_FILEDATE_NA));
        VERIFY(cstrFileSize.LoadString(IDS_FILESIZE_NA));

        pFileDate->SetWindowText(cstrFileDate);
        pFileSize->SetWindowText(cstrFileSize);
    }
    else
    {
        DWORD dwSize = 0L;
        CString fn = ((CPBApp *)AfxGetApp())->m_sCurFile;
        HANDLE hFile;
        CString date;
        CString time;
        SYSTEMTIME sysTime;
        FILETIME   ftSaved;
        FILETIME   ftLocal;
        int dSize;
        //
        // Open a handle to the file, use GetFileTime to
        // get the FILETIME, convert to a SYSTEMTIME and
        // call GetDateFormat and GetTimeFormat
        //
        hFile = ::CreateFile (fn,GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,OPEN_EXISTING,
                            0,NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            // If your bitmap is bigger than 2GB, too bad.
            dwSize = ::GetFileSize (hFile, NULL);
            ::GetFileTime (hFile, NULL, NULL, &ftSaved);
            ::FileTimeToLocalFileTime (&ftSaved, &ftLocal);
            ::FileTimeToSystemTime (&ftLocal, &sysTime);
            dSize = ::GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysTime, NULL,
                                NULL, 0);
            ::GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysTime, NULL,
                        date.GetBuffer (dSize), dSize);
            dSize = ::GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS, &sysTime, NULL,
                                  NULL, 0);
            ::GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS, &sysTime, NULL,
                                  time.GetBuffer (dSize), dSize);
            date.ReleaseBuffer();
            time.ReleaseBuffer();

            VERIFY(cstrFileDate.LoadString(IDS_FILEDATE));
            VERIFY(cstrFileSize.LoadString(IDS_FILESIZE));
            TCHAR szFileDate[96];
            TCHAR szFileSize[64];

            // Display the date, followed by the time
            date+=TEXT(" ");
            date+=time;
            ::wsprintf( szFileDate, cstrFileDate, date );
            ::wsprintf( szFileSize, cstrFileSize, ReformatSizeString(dwSize) );
            ::CloseHandle (hFile);
            pFileDate->SetWindowText(szFileDate);
            pFileSize->SetWindowText(szFileSize);
        }
        else
        {
            VERIFY(cstrFileDate.LoadString(IDS_FILEDATE_NA));
            VERIFY(cstrFileSize.LoadString(IDS_FILESIZE_NA));
            pFileDate->SetWindowText(cstrFileDate);
            pFileSize->SetWindowText(cstrFileSize);
        }
    }

    UpdateResolutionString();

    int idButton = IDC_PIXELS;

    if (m_eUnitsCurrent != ePIXELS)
        idButton = (m_eUnitsCurrent == eINCHES)? IDC_INCHES: IDC_CENTIMETERS;

    CheckRadioButton( IDC_INCHES, IDC_PIXELS, idButton );
    CheckRadioButton( IDC_MONOCHROME, IDC_COLORS,
                      (m_bMonochrome? IDC_MONOCHROME: IDC_COLORS) );

    //
    // We enable the transparent color UI only if modifying a GIF
    //
    GetDlgItem (IDC_USE_TRANS )->EnableWindow (WiaImgFmt_GIF == theApp.m_guidFltTypeUsed );

    CheckDlgButton( IDC_USE_TRANS, g_bUseTrans);

    CWnd* pSelectColorButton = GetDlgItem(IDC_SELECT_COLOR);
    pSelectColorButton->EnableWindow(g_bUseTrans);

    m_crTrans = crTrans;

    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CImageAttr::OnOK()
    {
    ConvertWidthHeight();

    theApp.m_iCurrentUnits = m_eUnitsCurrent;
    m_bMonochrome = (GetCheckedRadioButton( IDC_MONOCHROME, IDC_COLORS )
                                         == IDC_MONOCHROME);
    if (g_bUseTrans = IsDlgButtonChecked( IDC_USE_TRANS ))
    {
       crTrans = m_crTrans;
    }
    InvalColorWnd();

    CDialog::OnOK();
    }

/***************************************************************************/

void CImageAttr::OnDefault()
    {
    int nWidth, nHeight;

    PBGetDefDims(nWidth, nHeight);

    SetWidthHeight( nWidth, nHeight, 0, 0 );
    }

/***************************************************************************/

void CImageAttr::SetWidthHeight(ULONG nWidthPixels, ULONG nHeightPixels, ULONG cXPelsPerMeter, ULONG cYPelsPerMeter)
    {
    m_ulWidthPixels  = nWidthPixels  * FIXED_FLOATPT_MULTDIV;
    m_ulHeightPixels = nHeightPixels * FIXED_FLOATPT_MULTDIV;
    m_cXPelsPerMeter = cXPelsPerMeter;
    m_cYPelsPerMeter = cYPelsPerMeter;

    if (m_cXPelsPerMeter == 0)
        {
        m_cXPelsPerMeter = theApp.ScreenDeviceInfo.ixPelsPerDM * 10;
        }
        
    if (m_cYPelsPerMeter == 0)
        {
        m_cYPelsPerMeter = theApp.ScreenDeviceInfo.iyPelsPerDM * 10;
        }

    PelsToCurrentUnit();

    // only call updatedata if dialog exists...
    if (m_hWnd && ::IsWindow( m_hWnd ))
        {
        UpdateData( FALSE );
        UpdateResolutionString();
        }
    }

/***************************************************************************/

void  CImageAttr::ConvertWidthHeight(void)
    {
    // if user modified the edit field Width/Height then get new data and
    // convert to pixel format.  Else use stored pixel format.
    if (bEditFieldModified)
        {
        UpdateData( TRUE );

        switch (m_eUnitsCurrent)
            {
            case eINCHES:
                 m_ulWidthPixels  = MulDiv(m_ulWidth,  m_cXPelsPerMeter * 254, 10000);
                 m_ulHeightPixels = MulDiv(m_ulHeight, m_cYPelsPerMeter * 254, 10000);
                 break;

            case eCM:
                 m_ulWidthPixels  = MulDiv(m_ulWidth,  m_cXPelsPerMeter, 100);
                 m_ulHeightPixels = MulDiv(m_ulHeight, m_cYPelsPerMeter, 100);
                 break;

            case ePIXELS:
            default: // ePIXELS and all other assumed to be pixel
                 m_ulWidthPixels  = m_ulWidth;
                 m_ulHeightPixels = m_ulHeight;
                 break;
            }

        bEditFieldModified = FALSE;
        }
    }

/***************************************************************************/

void CImageAttr::PelsToCurrentUnit()
    {
    switch (m_eUnitsCurrent)
        {
        case eINCHES:
            m_ulWidth  = MulDiv(m_ulWidthPixels,  10000, m_cXPelsPerMeter * 254);
            m_ulHeight = MulDiv(m_ulHeightPixels, 10000, m_cYPelsPerMeter * 254);
            break;

        case eCM:
            m_ulWidth  = MulDiv(m_ulWidthPixels,  100, m_cXPelsPerMeter);
            m_ulHeight = MulDiv(m_ulHeightPixels, 100, m_cYPelsPerMeter);
            break;

        case ePIXELS:
        default:
            //Pixels cannot be partial
            //make sure whole number when converted to string (truncate! now).
            m_ulWidth  = (m_ulWidthPixels  / FIXED_FLOATPT_MULTDIV) * FIXED_FLOATPT_MULTDIV;
            m_ulHeight = (m_ulHeightPixels / FIXED_FLOATPT_MULTDIV) * FIXED_FLOATPT_MULTDIV;
            break;
        }
    }

/***************************************************************************/

CSize CImageAttr::GetWidthHeight(void)
    {
    return CSize( (int)(( m_ulWidthPixels + (FIXED_FLOATPT_MULTDIV / 2)) / FIXED_FLOATPT_MULTDIV),
                  (int)((m_ulHeightPixels + (FIXED_FLOATPT_MULTDIV / 2)) / FIXED_FLOATPT_MULTDIV));
    }

/***************************************************************************/

void CImageAttr::OnInches()
    {
    SetNewUnits( eINCHES );
    }

/***************************************************************************/

void CImageAttr::OnCentimeters()
    {
    SetNewUnits( eCM );
    }

/***************************************************************************/

void CImageAttr::OnPixels()
    {
    SetNewUnits( ePIXELS );
    }

/***************************************************************************/

void CImageAttr::SetNewUnits( eUNITS NewUnit )
    {
    if (NewUnit == m_eUnitsCurrent)
        return;

    // must call getwidthheight before  setting to new mode
    ConvertWidthHeight(); // get in a common form of pixels.

    m_eUnitsCurrent = NewUnit;

    PelsToCurrentUnit();

    UpdateData( FALSE );
    }

/***************************************************************************/

void CImageAttr::OnChangeHeight()
    {
    bEditFieldModified = TRUE;
    }

/***************************************************************************/

void CImageAttr::OnChangeWidth()
    {
    bEditFieldModified = TRUE;
    }

/************************ CZoomViewDlg dialog ******************************/

CZoomViewDlg::CZoomViewDlg(CWnd* pParent /*=NULL*/)
             : CDialog(CZoomViewDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CZoomViewDlg)
    //}}AFX_DATA_INIT

    m_nCurrent = 0;
    }

/***************************************************************************/

void CZoomViewDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CZoomViewDlg)
    //}}AFX_DATA_MAP
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CZoomViewDlg, CDialog)
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CZoomViewDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CZoomViewDlg message handlers **********************/

static DWORD ZoomViewHelpIds[] =
        {
        IDC_CURRENT_ZOOM_STATIC,        IDH_PAINT_ZOOM_CURRENT,
        IDC_CURRENT_ZOOM,                       IDH_PAINT_ZOOM_CURRENT,
        IDC_ZOOM_GROUP,                         IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_100,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_200,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_400,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_600,                           IDH_PAINT_ZOOM_SET_GROUP,
        IDC_ZOOM_800,                           IDH_PAINT_ZOOM_SET_GROUP,
        0, 0
        };

/***************************************************************************/

LONG
CZoomViewDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)ZoomViewHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CZoomViewDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)ZoomViewHelpIds);
return lResult;
}

/***************************************************************************/

BOOL CZoomViewDlg::OnInitDialog()
    {
    CDialog::OnInitDialog();

    TCHAR* pZoom = TEXT("100%");
    UINT nButton = IDC_ZOOM_100;

    if (m_nCurrent < 8)
        if (m_nCurrent < 6)
            if (m_nCurrent < 4)
                if (m_nCurrent < 2)
                    ;
                else
                    {
                    pZoom = TEXT("200%");
                    nButton = IDC_ZOOM_200;
                    }
            else
                {
                pZoom = TEXT("400%");
                nButton = IDC_ZOOM_400;
                }
        else
            {
            pZoom = TEXT("600%");
            nButton = IDC_ZOOM_600;
            }
    else
        {
        pZoom = TEXT("800%");
        nButton = IDC_ZOOM_800;
        }

    SetDlgItemText( IDC_CURRENT_ZOOM, pZoom );
    CheckRadioButton( IDC_ZOOM_100, IDC_ZOOM_800, nButton );

    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CZoomViewDlg::OnOK()
    {
    m_nCurrent = GetCheckedRadioButton( IDC_ZOOM_100, IDC_ZOOM_800 ) - IDC_ZOOM_100;

    if (m_nCurrent < 1)
        m_nCurrent  = 1;
    else
        m_nCurrent *= 2;

    CDialog::OnOK();
    }

/************************ CFlipRotateDlg dialog ****************************/

CFlipRotateDlg::CFlipRotateDlg(CWnd* pParent /*=NULL*/)
               : CDialog(CFlipRotateDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CFlipRotateDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_bHorz  = TRUE;
    m_bAngle = FALSE;
    m_nAngle = 90;
    }

/***************************************************************************/

void CFlipRotateDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFlipRotateDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CFlipRotateDlg, CDialog)
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CFlipRotateDlg)
    ON_BN_CLICKED(IDC_BY_ANGLE, OnByAngle)
    ON_BN_CLICKED(IDC_HORIZONTAL, OnNotByAngle)
    ON_BN_CLICKED(IDC_VERTICAL, OnNotByAngle)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CFlipRotateDlg message handlers **********************/

static DWORD FlipRotateHelpIds[] =
        {
        IDC_PAINT_FLIP_GROUP,   IDH_COMM_GROUPBOX,
        IDC_HORIZONTAL,                 IDH_PAINT_IMAGE_FLIP_HORIZ,
        IDC_VERTICAL,                   IDH_PAINT_IMAGE_FLIP_VERT,
        IDC_BY_ANGLE,                   IDH_PAINT_IMAGE_FLIP_ROTATE,
        IDC_90_DEG,                             IDH_PAINT_IMAGE_FLIP_ROTATE,
        IDC_180_DEG,                    IDH_PAINT_IMAGE_FLIP_ROTATE,
        IDC_270_DEG,                    IDH_PAINT_IMAGE_FLIP_ROTATE,
        0, 0
        };

/***************************************************************************/

LONG
CFlipRotateDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)FlipRotateHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CFlipRotateDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)FlipRotateHelpIds);
return lResult;
}

/***************************************************************************/

BOOL CFlipRotateDlg::OnInitDialog()
    {
    CDialog::OnInitDialog();

    CheckRadioButton( IDC_90_DEG, IDC_270_DEG, IDC_90_DEG );

    UINT uButton = (m_bAngle? IDC_BY_ANGLE: (m_bHorz? IDC_HORIZONTAL: IDC_VERTICAL));

    CheckRadioButton( IDC_HORIZONTAL, IDC_BY_ANGLE, uButton );

    if (uButton != IDC_BY_ANGLE)
        OnNotByAngle();

    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CFlipRotateDlg::OnByAngle()
    {
    GetDlgItem( IDC_90_DEG  )->EnableWindow( TRUE );
    GetDlgItem( IDC_180_DEG )->EnableWindow( TRUE );
    GetDlgItem( IDC_270_DEG )->EnableWindow( TRUE );
    }

/***************************************************************************/

void CFlipRotateDlg::OnNotByAngle()
    {
    GetDlgItem( IDC_90_DEG  )->EnableWindow( FALSE );
    GetDlgItem( IDC_180_DEG )->EnableWindow( FALSE );
    GetDlgItem( IDC_270_DEG )->EnableWindow( FALSE );
    }

/***************************************************************************/

void CFlipRotateDlg::OnOK()
    {
    UINT uButton = GetCheckedRadioButton( IDC_HORIZONTAL, IDC_BY_ANGLE );

    m_bHorz  = (uButton == IDC_HORIZONTAL);
    m_bAngle = (uButton == IDC_BY_ANGLE);

    switch (GetCheckedRadioButton( IDC_90_DEG, IDC_270_DEG ))
        {
        case IDC_90_DEG:
            m_nAngle = 90;
            break;

        case IDC_180_DEG:
            m_nAngle = 180;
            break;

        case IDC_270_DEG:
            m_nAngle = 270;
            break;
        }

    CDialog::OnOK();
    }

/************************* CStretchSkewDlg dialog **************************/

CStretchSkewDlg::CStretchSkewDlg(CWnd* pParent /*=NULL*/)
                : CDialog(CStretchSkewDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CStretchSkewDlg)
    m_wSkewHorz = 0;
    m_wSkewVert = 0;
    m_iStretchVert = 100;
    m_iStretchHorz = 100;
    //}}AFX_DATA_INIT

    //m_bStretchHorz = TRUE;
    //m_bSkewHorz    = TRUE;
    }

/***************************************************************************/

void CStretchSkewDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStretchSkewDlg)
    DDX_Text(pDX, IDC_STRETCH_VERT_PERCENT, m_iStretchVert);
    DDV_MinMaxInt(pDX, m_iStretchVert, 1, 500);
    DDX_Text(pDX, IDC_STRETCH_HORZ_PERCENT, m_iStretchHorz);
    DDV_MinMaxInt(pDX, m_iStretchHorz, 1, 500);
    DDX_Text(pDX, IDC_SKEW_HORZ_DEGREES, m_wSkewHorz);
    DDV_MinMaxInt(pDX, m_wSkewHorz, -89, 89);
    DDX_Text(pDX, IDC_SKEW_VERT_DEGREES, m_wSkewVert);
    DDV_MinMaxInt(pDX, m_wSkewVert, -89, 89);

    //}}AFX_DATA_MAP
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CStretchSkewDlg, CDialog)
        ON_MESSAGE(WM_HELP, OnHelp)
        ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
    //{{AFX_MSG_MAP(CStretchSkewDlg)
    /*
    ON_BN_CLICKED(IDC_SKEW_HORZ, OnSkewHorz)
    ON_BN_CLICKED(IDC_SKEW_VERT, OnSkewVert)
    ON_BN_CLICKED(IDC_STRETCH_HORZ, OnStretchHorz)
    ON_BN_CLICKED(IDC_STRETCH_VERT, OnStretchVert)
    */
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/************************ CStretchSkewDlg message handlers **********************/

static DWORD StretchSkewHelpIds[] =
        {
        IDC_STRETCH_GROUP,                      IDH_COMM_GROUPBOX,
        IDC_STRETCH_HORZ_ICON,          IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_HORZ,                       IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_HORZ_PERCENT,       IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_HORZ_SUFFIX,        IDH_PAINT_IMAGE_STRETCH_HORIZ,
        IDC_STRETCH_VERT_ICON,          IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_STRETCH_VERT,                       IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_STRETCH_VERT_PERCENT,       IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_STRETCH_VERT_SUFFIX,        IDH_PAINT_IMAGE_STRETCH_VERT,
        IDC_SKEW_GROUP,                         IDH_COMM_GROUPBOX,
        IDC_SKEW_HORZ_ICON,                     IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_HORZ,                          IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_HORZ_DEGREES,          IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_HORZ_SUFFIX,           IDH_PAINT_IMAGE_SKEW_HOR,
        IDC_SKEW_VERT_ICON,                     IDH_PAINT_IMAGE_SKEW_VERT,
        IDC_SKEW_VERT,                          IDH_PAINT_IMAGE_SKEW_VERT,
        IDC_SKEW_VERT_DEGREES,          IDH_PAINT_IMAGE_SKEW_VERT,
        IDC_SKEW_VERT_SUFFIX,           IDH_PAINT_IMAGE_SKEW_VERT,
        0, 0
        };

/***************************************************************************/

LONG
CStretchSkewDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("mspaint.hlp"),
                  HELP_WM_HELP, (ULONG_PTR)(LPTSTR)StretchSkewHelpIds);
return lResult;
}

/***************************************************************************/

LONG
CStretchSkewDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
LONG lResult = 0;
::WinHelp((HWND)wParam, TEXT("mspaint.hlp"),
                  HELP_CONTEXTMENU,(ULONG_PTR)(LPVOID)StretchSkewHelpIds);
return lResult;
}

/***************************************************************************/


BOOL CStretchSkewDlg::OnInitDialog()
    {
    CDialog::OnInitDialog();

    CheckRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT, IDC_STRETCH_HORZ );
    CheckRadioButton( IDC_SKEW_HORZ   , IDC_SKEW_VERT   , IDC_SKEW_HORZ    );

   /* GetDlgItem( IDC_STRETCH_HORZ_PERCENT )->EnableWindow(   m_iStretchHorz );
    GetDlgItem( IDC_STRETCH_VERT_PERCENT )->EnableWindow( ! m_iStretchHorz );
    GetDlgItem( IDC_SKEW_HORZ_DEGREES )->EnableWindow(   m_bSkewHorz );
    GetDlgItem( IDC_SKEW_VERT_DEGREES )->EnableWindow( ! m_bSkewHorz );
*/
    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CStretchSkewDlg::OnStretchHorz()
    {
    m_bStretchHorz = TRUE;

    GetDlgItem( IDC_STRETCH_HORZ_PERCENT )->EnableWindow( TRUE  );
    GetDlgItem( IDC_STRETCH_VERT_PERCENT )->EnableWindow( FALSE );
    CheckRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT, IDC_STRETCH_HORZ );
    }

/***************************************************************************/

void CStretchSkewDlg::OnStretchVert()
    {
    m_bStretchHorz = FALSE;

    GetDlgItem( IDC_STRETCH_HORZ_PERCENT )->EnableWindow( FALSE );
    GetDlgItem( IDC_STRETCH_VERT_PERCENT )->EnableWindow( TRUE  );
    CheckRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT, IDC_STRETCH_VERT );
    }

/***************************************************************************/

void CStretchSkewDlg::OnSkewHorz()
    {
    m_bSkewHorz = TRUE;

    GetDlgItem( IDC_SKEW_HORZ_DEGREES )->EnableWindow( TRUE  );
    GetDlgItem( IDC_SKEW_VERT_DEGREES )->EnableWindow( FALSE );
    CheckRadioButton( IDC_SKEW_HORZ, IDC_SKEW_VERT, IDC_SKEW_HORZ );
    }

/***************************************************************************/

void CStretchSkewDlg::OnSkewVert()
    {
    m_bSkewHorz = FALSE;

    GetDlgItem( IDC_SKEW_HORZ_DEGREES )->EnableWindow( FALSE );
    GetDlgItem( IDC_SKEW_VERT_DEGREES )->EnableWindow( TRUE  );
    CheckRadioButton( IDC_SKEW_HORZ, IDC_SKEW_VERT, IDC_SKEW_VERT );
    }

/***************************************************************************/

void CStretchSkewDlg::OnOK()
    {
    if (GetCheckedRadioButton( IDC_STRETCH_HORZ, IDC_STRETCH_VERT )
                            == IDC_STRETCH_HORZ)
        m_iStretchVert = 0;
    else
        m_iStretchHorz = 0;

    if (GetCheckedRadioButton( IDC_SKEW_HORZ, IDC_SKEW_VERT )
                            == IDC_SKEW_HORZ)
        m_wSkewVert = 0;
    else
        m_wSkewHorz = 0;

    CDialog::OnOK();
    }

/***************************************************************************/

void CImageAttr::OnUseTrans()
{
   CWnd* pSelectColorButton = GetDlgItem(IDC_SELECT_COLOR);
   pSelectColorButton->EnableWindow(IsDlgButtonChecked(IDC_USE_TRANS));
}

extern INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

static UINT_PTR CALLBACK /*LPCCHOOKPROC*/
SelectColorHook(HWND hColorDlg, UINT nMessage, WPARAM wParam, LPARAM lParam)
{
// Are we initializing the dialog window?
if ( nMessage == WM_INITDIALOG )
        {
        // Reset the common dialog title
        CString strDialogTitle;
        VERIFY(strDialogTitle.LoadString(IDS_SELECT_COLOR));
        SetWindowText( hColorDlg, strDialogTitle );
        }
// Pass All Messages Along to Common Dialog
return (UINT)AfxDlgProc(hColorDlg, nMessage, wParam, lParam );
}

void CImageAttr::OnSelectColor()
{
   // for default color selection, disregard palette-relative
    CColorDialog dlg( m_crTrans & 0xFFFFFF, CC_FULLOPEN );
        dlg.m_cc.lpfnHook = SelectColorHook;

    if (dlg.DoModal() != IDOK)
        return;

        PaintTransBox( m_crTrans = dlg.GetColor() );
}

void CImageAttr::OnPaint()
{
        CPaintDC dc(this); // device context for painting

        if (m_crTrans != TRANS_COLOR_NONE)    // not default
                PaintTransBox( m_crTrans );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imageatt.h ===
// imageatt.h : header file
//
#include "imgdlgs.h"

typedef enum
    {
        ePIXELS = 0,
        eINCHES = 1,
        eCM     = 2
    } eUNITS;

/*************************** CImageAttr dialog *****************************/

class CImageAttr : public CDialog
    {
    // Construction
    public:

    CImageAttr(CWnd* pParent = NULL);   // standard constructor

    void SetWidthHeight(ULONG nWidthPixels, ULONG nHeightPixels, ULONG cXPelsPerMeter, ULONG cYPelsPerMeter);
    CSize GetWidthHeight(void);
    // Dialog Data
    //{{AFX_DATA(CImageAttr)
        enum { IDD = IDD_IMAGE_ATTRIBUTES };
        CString m_cStringWidth;
        CString m_cStringHeight;
        //}}AFX_DATA

    BOOL   m_bMonochrome;

    // Implementation
    protected:
    eUNITS m_eUnitsCurrent;
    BOOL   bEditFieldModified;

    ULONG   m_ulHeightPixels;
    ULONG   m_ulWidthPixels;
    ULONG   m_ulHeight;
    ULONG   m_ulWidth;
    ULONG   m_cXPelsPerMeter;
    ULONG   m_cYPelsPerMeter;

    COLORREF m_crTrans;
    void PaintTransBox ( COLORREF  );

    void  FixedFloatPtToString( CString& sString, ULONG ulFixedFloatPt );
    ULONG StringToFixedFloatPt( CString& sString );
    void  ConvertWidthHeight( void );
    void  PelsToCurrentUnit( void );
    void  SetNewUnits( eUNITS NewUnit );

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CImageAttr)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        afx_msg void OnInches();
        afx_msg void OnCentimeters();
        afx_msg void OnPixels();
        afx_msg void OnChangeHeight();
        afx_msg void OnChangeWidth();
        afx_msg void OnDefault();
        afx_msg void OnUseTrans();
        afx_msg void OnSelectColor ();
        afx_msg void OnPaint();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    CString ReformatSizeString (DWORD dwNumber);
    void UpdateResolutionString();
    };

/*************************** CZoomViewDlg dialog ***************************/

class CZoomViewDlg : public CDialog
    {
    // Construction
    public:

    CZoomViewDlg(CWnd* pParent = NULL); // standard constructor

    // Dialog Data

    UINT m_nCurrent;

    //{{AFX_DATA(CZoomViewDlg)
        enum { IDD = IDD_VIEW_ZOOM };
        //}}AFX_DATA

    // Implementation
    protected:

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CZoomViewDlg)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

/************************* CFlipRotateDlg dialog ***************************/

class CFlipRotateDlg : public CDialog
    {
    // Construction
    public:

    CFlipRotateDlg(CWnd* pParent = NULL);       // standard constructor

    // Dialog Data

    BOOL m_bHorz;
    BOOL m_bAngle;
    UINT m_nAngle;

    //{{AFX_DATA(CFlipRotateDlg)
    enum { IDD = IDD_FLIP_ROTATE };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // Implementation
    protected:

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CFlipRotateDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
        afx_msg void OnByAngle();
        afx_msg void OnNotByAngle();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

/********************** CStretchSkewDlg dialog *****************************/

class CStretchSkewDlg : public CDialog
    {
    // Construction
    public:

    CStretchSkewDlg(CWnd* pParent = NULL);      // standard constructor

    // Check that the direction was specified and subtract 100 to make it
    // equivalent to the 0 based system
 //   GetStretchHorz() { return(m_bStretchHorz ? m_iStretchHorz - 100 : 0); }
 //   GetStretchVert() { return(m_bStretchHorz ? 0 : m_iStretchVert - 100); }
    int GetStretchHorz() {return (m_iStretchHorz-100);}
    int GetStretchVert() {return (m_iStretchVert-100);}


    // Check that the direction was specified
  //  GetSkewHorz() { return(m_bSkewHorz ? m_wSkewHorz : 0); }
   // GetSkewVert() { return(m_bSkewHorz ? 0 : m_wSkewVert); }
    int GetSkewHorz() { return(m_wSkewHorz); }
    int GetSkewVert() { return(m_wSkewVert); }

    private:

    // Dialog Data
    //{{AFX_DATA(CStretchSkewDlg)
        enum { IDD = IDD_STRETCH_SKEW };

    int    m_wSkewHorz;
    int    m_wSkewVert;
    int     m_iStretchVert;
    int     m_iStretchHorz;
        //}}AFX_DATA

    // Implementation
    protected:

    BOOL    m_bStretchHorz;
    BOOL    m_bSkewHorz;

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        virtual LONG OnHelp(WPARAM wParam, LPARAM lParam);
        virtual LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

    // Generated message map functions
    //{{AFX_MSG(CStretchSkewDlg)
    // TODO
    // these are commented out of the message map. delete them?
    virtual void OnOK();
    virtual BOOL OnInitDialog();
        afx_msg void OnSkewHorz();
        afx_msg void OnSkewVert();
        afx_msg void OnStretchHorz();
        afx_msg void OnStretchVert();
        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imaging.cpp ===
#include "stdafx.h"
#include "resource.h"

#include <process.h>

#include "bar.h"
#include "pbrush.h"
#include "imaging.h"

//////////////////////////////////////////////////////////////////////////
//
// Trace
//

#ifdef DBG

void AFX_CDECL Trace(PCTSTR pszFormat, ...)
{
    va_list argList;
    va_start(argList, pszFormat);

    CString strMessage;
    strMessage.FormatV(pszFormat, argList);

    OutputDebugString(strMessage);

    va_end(argList);
}

#else //DBG

inline void AFX_CDECL Trace(PCTSTR pszFormat, ...)
{
}

#endif DBG

//////////////////////////////////////////////////////////////////////////
//
//
//

CImagingMgr::~CImagingMgr()
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CWIAMgr::CWIAMgr()
{
    HRESULT hr;

    m_pEventCallback = new CEventCallback();

    if (m_pEventCallback)
    {
        hr = m_pEventCallback->Register();

        if (hr != S_OK)
        {
            m_pEventCallback.Release();
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CWIAMgr::SelectSource(
    HWND hWndParent,
    LONG lFlags
)
{
    HRESULT hr = S_FALSE;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr;

    hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_ALL|CLSCTX_NO_FAILURE_LOG);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // clear the current selection (if any)

    m_bstrDeviceID.Empty();

    // display the device selection dialog

    hr = pWiaDevMgr->SelectDeviceDlgID(
        hWndParent,
        StiDeviceTypeDefault,
        lFlags,
        &m_bstrDeviceID
    );

    theApp.RestoreWaitCursor();

    if (hr != S_OK)
    {
        Trace(_T("SelectDeviceDlgID HRESULT=%08x\n"), hr);
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CWIAMgr::Select(
    LPCTSTR pDeviceId
)
{
    m_bstrDeviceID = pDeviceId;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT ReadPropertyLong(IWiaItem *pWiaItem, PROPID propid, LONG *lResult)
{
    if (!lResult)
    {
        return E_POINTER;
    }

    HRESULT hr = S_FALSE;

    CComQIPtr<IWiaPropertyStorage> pWiaPropertyStorage(pWiaItem);

    if (pWiaPropertyStorage == 0)
    {
        return E_NOINTERFACE;
    }

    PROPSPEC PropSpec;

    PropSpec.ulKind = PRSPEC_PROPID;
    PropSpec.propid = propid;

    PROPVARIANT PropVariant;

    PropVariantInit(&PropVariant);

    hr = pWiaPropertyStorage->ReadMultiple(1, &PropSpec, &PropVariant);

    if (hr != S_OK)
    {
        Trace(_T("ReadMultiple HRESULT=%08x\n"), hr);
        return hr;
    }

    switch (PropVariant.vt)
    {
        case VT_I1:   *lResult = (LONG) PropVariant.cVal;    break;
        case VT_UI1:  *lResult = (LONG) PropVariant.bVal;    break;
        case VT_I2:   *lResult = (LONG) PropVariant.iVal;    break;
        case VT_UI2:  *lResult = (LONG) PropVariant.uiVal;   break;
        case VT_I4:   *lResult = (LONG) PropVariant.lVal;    break;
        case VT_UI4:  *lResult = (LONG) PropVariant.ulVal;   break;
        case VT_INT:  *lResult = (LONG) PropVariant.intVal;  break;
        case VT_UINT: *lResult = (LONG) PropVariant.uintVal; break;
        case VT_R4:   *lResult = (LONG) (PropVariant.fltVal + 0.5); break;
        case VT_R8:   *lResult = (LONG) (PropVariant.dblVal + 0.5); break;
        default:      hr = S_FALSE; break;
    }

    PropVariantClear(&PropVariant);

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CWIAMgr::Acquire(
    HWND     hWndParent,
    HGLOBAL *phDib
)
{
    ASSERT(phDib != 0);

    HRESULT hr;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr;

    hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_ALL|CLSCTX_NO_FAILURE_LOG);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Create the device object.
    // Select the device first if
    //   no device has been selected before or
    //   we fail to create the device with the selected ID

    CComPtr<IWiaItem> pRootItem;

    if (!m_bstrDeviceID ||
        !SUCCEEDED(pWiaDevMgr->CreateDevice(m_bstrDeviceID, &pRootItem)))
    {
        // clear the current selection (if any)

        m_bstrDeviceID.Empty();

        // display the device selection dialog

        hr = pWiaDevMgr->SelectDeviceDlg(
            hWndParent,
            StiDeviceTypeDefault,
            0,
            &m_bstrDeviceID,
            &pRootItem
        );

        theApp.RestoreWaitCursor();

        if (hr != S_OK)
        {
            Trace(_T("SelectDeviceDlg HRESULT=%08x\n"), hr);
            return hr;
        }

#ifndef USE_SELECTSOURCE_MENUITEM

        // forget the current selection

        m_bstrDeviceID.Empty();

#endif //!USE_SELECTSOURCE_MENUITEM

        if (!SUCCEEDED(hr)) 
        {
            Trace(_T("CreateDevice HRESULT=%08x\n"), hr);
            return hr;
        }
    }

    // display the image selection dialog and let the user
    // select the item to be transferred

    CComPtrArray<IWiaItem> ppIWiaItem;

    hr = pRootItem->DeviceDlg(
        hWndParent,
        WIA_DEVICE_DIALOG_SINGLE_IMAGE,
        WIA_INTENT_NONE,
        &ppIWiaItem.ItemCount(),
        &ppIWiaItem
    );

    theApp.RestoreWaitCursor();

    if (hr != S_OK)
    {
        Trace(_T("DeviceDlg HRESULT=%08x\n"), hr);
        return hr;
    }

    if (ppIWiaItem.ItemCount() == 0)
    {
        Trace(_T("DeviceDlg returned 0 items\n"));
        return E_FAIL;
    }

    // set the image transfer properties; we want a DIB memory transfer

    TYMED tymed      = (TYMED) TYMED_CALLBACK;
    GUID  guidFormat = WiaImgFmt_MEMORYBMP;

    PROPSPEC    PropSpec[2]    = { 0 };
    PROPVARIANT PropVariant[2] = { 0 };

    PropSpec[0].ulKind   = PRSPEC_PROPID;
    PropSpec[0].propid   = WIA_IPA_TYMED;
    PropVariant[0].vt    = VT_I4;
    PropVariant[0].lVal  = tymed;

    PropSpec[1].ulKind   = PRSPEC_PROPID;
    PropSpec[1].propid   = WIA_IPA_FORMAT;
    PropVariant[1].vt    = VT_CLSID;
    PropVariant[1].puuid = &guidFormat;

    CComQIPtr<IWiaPropertyStorage> pWiaPropertyStorage(ppIWiaItem[0]);

    if (pWiaPropertyStorage == 0)
    {
        return E_NOINTERFACE;
    }

    hr = pWiaPropertyStorage->WriteMultiple(
        1,
        &(PropSpec[0]),
        &(PropVariant[0]),
        WIA_IPA_FIRST
    );

    if (hr != S_OK)
    {
        Trace(_T("WriteMultiple HRESULT=%08x\n"), hr);
        return hr;
    }

    hr = pWiaPropertyStorage->WriteMultiple(
        1,
        &(PropSpec[1]),
        &(PropVariant[1]),
        WIA_IPA_FIRST
    );

    if (hr != S_OK)
    {
        Trace(_T("WriteMultiple HRESULT=%08x\n"), hr);
        return hr;
    }

    // now, determine the transfer buffer size

    // 64k transfer size and double buffering seem to work fine;
    // a smaller buffer considerably slows down the memory transfer
    // and a larger buffer doesn't give much speed increase.
    // If the device minimum is larger than 64k though, use that size...

    LONG lBufferSize;

    hr = ReadPropertyLong(ppIWiaItem[0], WIA_IPA_MIN_BUFFER_SIZE, &lBufferSize);

    if (hr != S_OK || lBufferSize < 64*1024)
    {
        lBufferSize = 64*1024;
    }

    // setup the progress dialog 

    CComPtr<IWiaProgressDialog> pProgress;

    hr = CoCreateInstance( 
        CLSID_WiaDefaultUi, 
        0, 
        CLSCTX_INPROC_SERVER, 
        IID_IWiaProgressDialog, 
        (void**) &pProgress
    );

    if (hr != S_OK)
    {
        pProgress = new CProgressDialog;
    }

    LONG nDeviceType;

    hr = ReadPropertyLong(pRootItem, WIA_DIP_DEV_TYPE, &nDeviceType);
    
    if (hr != S_OK)
    {
        nDeviceType = 0;
    }

    LONG lAnimFlag;

    switch (GET_STIDEVICE_TYPE(nDeviceType))
    {
        case StiDeviceTypeScanner:
            lAnimFlag = WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE;
            break;

        case StiDeviceTypeDigitalCamera:
            lAnimFlag = WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE;
            break;

        case StiDeviceTypeStreamingVideo:
            lAnimFlag = WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE;
            break;

        default:
            lAnimFlag = WIA_PROGRESSDLG_NO_ANIM;
            break;
    }

    pProgress->Create(hWndParent, lAnimFlag);

    CString strDownloading;
    strDownloading.LoadString(IDS_DOWNLOAD_IMAGE);

    USES_CONVERSION;
    pProgress->SetTitle(T2CW(strDownloading));

    pProgress->SetMessage(L"");

    pProgress->Show();

    // init the data callback interface

    CDataCallback *pDataCallback = new CDataCallback(pProgress);

    if (!pDataCallback)
    {
        theApp.SetMemoryEmergency(TRUE);
        return E_OUTOFMEMORY;
    }

    CComQIPtr<IWiaDataCallback> pIWiaDataCallback(pDataCallback);

    ASSERT(pIWiaDataCallback != 0);

    // initiate the transfer

    CComQIPtr<IWiaDataTransfer> pIWiaDataTransfer(ppIWiaItem[0]);

    if (pIWiaDataTransfer == 0)
    {
        return E_NOINTERFACE;
    }

    WIA_DATA_TRANSFER_INFO WiaDataTransferInfo = { 0 };

    WiaDataTransferInfo.ulSize        = sizeof(WIA_DATA_TRANSFER_INFO);
    WiaDataTransferInfo.ulBufferSize  = 2 * lBufferSize;
    WiaDataTransferInfo.bDoubleBuffer = TRUE;

    // This *easy* solution will cause the mspaint UI to freeze during
    // image transfer; this is possibly too long time to remain frozen.
    // So we will create a worker thread to do the data transfer.
    //
    //hr = pIWiaDataTransfer->idtGetBandedData(
    //    &WiaDataTransferInfo,
    //    pIWiaDataCallback
    //);

    EnableWindow(hWndParent, FALSE);

    hr = GetBandedData(CGetBandedDataThreadData(
        pIWiaDataTransfer,
        &WiaDataTransferInfo,
        pIWiaDataCallback
    ));

    EnableWindow(hWndParent, TRUE);

    // check if the user has pressed cancel

    if (pProgress)
    {
        BOOL bCancelled;

        if (pProgress->Cancelled(&bCancelled) == S_OK && bCancelled)
        {
            hr = S_FALSE;
        }

        pProgress->Destroy();
    }

    if (hr != S_OK)
    {
        Trace(_T("idtGetBandedData HRESULT=%08x\n"), hr);
        return hr;
    }

    // return the results

    pDataCallback->PrintTimes();

    *phDib = pDataCallback->GetBuffer();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CWIAMgr::CGetBandedDataThreadData::CGetBandedDataThreadData(
    IWiaDataTransfer       *pIWiaDataTransfer,
    WIA_DATA_TRANSFER_INFO *pWiaDataTransferInfo,
    IWiaDataCallback       *pIWiaDataCallback
) :
    m_pIWiaDataTransfer(pIWiaDataTransfer),
    m_pWiaDataTransferInfo(pWiaDataTransferInfo),
    m_pIWiaDataCallback(pIWiaDataCallback)
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CWIAMgr::CGetBandedDataThreadData::Marshal()
{
    HRESULT hr;

    // marshal the IWiaDataTransfer interface

    ASSERT(m_pIWiaDataTransfer != 0);

    hr = CoMarshalInterThreadInterfaceInStream(
        IID_IWiaDataTransfer,
        m_pIWiaDataTransfer,
        &m_pIWiaDataTransferStream
    );

    if (hr != S_OK)
    {
        Trace(_T("CoMarshalInterThreadInterfaceInStream HRESULT=%08x\n"), hr);
        return hr;
    }

    m_pIWiaDataTransfer.Release();

    // marshal the IWiaDataCallback interface

    ASSERT(m_pIWiaDataCallback != 0);

    hr = CoMarshalInterThreadInterfaceInStream(
        IID_IWiaDataCallback,
        m_pIWiaDataCallback,
        &m_pIWiaDataCallbackStream
    );

    if (hr != S_OK)
    {
        Trace(_T("CoMarshalInterThreadInterfaceInStream HRESULT=%08x\n"), hr);
        return hr;
    }

    m_pIWiaDataCallback.Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CWIAMgr::CGetBandedDataThreadData::Unmarshal()
{
    HRESULT hr;

    // unmarshal the IWiaDataTransfer interface

    ASSERT(m_pIWiaDataTransferStream != 0);

    hr = CoGetInterfaceAndReleaseStream(
        m_pIWiaDataTransferStream,
        IID_IWiaDataTransfer,
        (void **) &m_pIWiaDataTransfer
    );

    // CoGetInterfaceAndReleaseStream should already have
    // released the stream pointer, so set it to zero so that
    // ~CGetBandedDataThreadData will not try to release it again

    m_pIWiaDataTransferStream.Detach();

    if (hr != S_OK)
    {
        Trace(_T("CoGetInterfaceAndReleaseStream HRESULT=%08x\n"), hr);
        return hr;
    }

    // unmarshal the IWiaDataCallback interface

    ASSERT(m_pIWiaDataCallbackStream != 0);

    hr = CoGetInterfaceAndReleaseStream(
        m_pIWiaDataCallbackStream,
        IID_IWiaDataCallback,
        (void **) &m_pIWiaDataCallback
    );

    m_pIWiaDataCallbackStream.Detach();

    if (hr != S_OK)
    {
        Trace(_T("CoGetInterfaceAndReleaseStream HRESULT=%08x\n"), hr);
        return hr;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CWIAMgr::GetBandedData(CGetBandedDataThreadData &ThreadData)
{
    // marshal the interface pointers before passing them to another thread

    HRESULT hr = ThreadData.Marshal();

    if (hr != S_OK)
    {
        return hr;
    }

    // fire up the new thread

    unsigned nThreadId;

    HANDLE hThread = (HANDLE) _beginthreadex(
        0,
        0,
        GetBandedDataThread,
        &ThreadData,
        0,
        &nThreadId
    );

    if (hThread == 0)
    {
        Trace(_T("CreateThread LastError=%08x\n"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // enter a msg loop while waiting for the thread to complete;
    // this will keep the mspaint UI alive

    while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) == WAIT_OBJECT_0+1)
    {
        MSG msg;

        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        theApp.RestoreWaitCursor();
    }

    // if we reach here, the thread must have ended; get the result

    DWORD dwExitCode = S_FALSE;

    GetExitCodeThread(hThread, &dwExitCode);

    CloseHandle(hThread);

    ASSERT(sizeof(DWORD) >= sizeof(HRESULT));
    return (HRESULT) dwExitCode;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

unsigned WINAPI CWIAMgr::GetBandedDataThread(PVOID pVoid)
{
    // Init COM for this thread

    HRESULT hr = CoInitialize(0);

    if (hr != S_OK)
    {
        Trace(_T("CoInitialize HRESULT=%08x\n"), hr);
        return (unsigned) hr;
    }

    CGetBandedDataThreadData *pThreadData = (CGetBandedDataThreadData *) pVoid;

    ASSERT(pThreadData != 0);

    if (pThreadData != 0)
    {
        // unmarshal the interface pointers before calling idtGetBandedData

        hr = pThreadData->Unmarshal();

        if (hr == S_OK)
        {
            hr = pThreadData->m_pIWiaDataTransfer->idtGetBandedData(
                pThreadData->m_pWiaDataTransferInfo,
                pThreadData->m_pIWiaDataCallback
            );
        }
    }

    CoUninitialize();

    ASSERT(sizeof(unsigned) >= sizeof(HRESULT));
    return (unsigned) hr;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

int CWIAMgr::NumDevices(HWND /*hWndParent*/)
{
    return m_pEventCallback ? m_pEventCallback->GetNumDevices() : 0;
}

#ifdef USE_TWAIN

//////////////////////////////////////////////////////////////////////////
//
//
//

CTwainMgr::CTwainMgr()
{
    m_TwainState = State_1_Pre_Session;

    // fill in the m_AppId struct with defaults

    m_AppId.Id = 0;
    m_AppId.Version.MajorNum = 1;
    m_AppId.Version.MinorNum = 0;
    m_AppId.Version.Language = TWLG_USA;
    m_AppId.Version.Country  = TWCY_USA;
    strcpy(m_AppId.Version.Info,  "FileDescription");
    m_AppId.ProtocolMajor   = TWON_PROTOCOLMAJOR;
    m_AppId.ProtocolMinor   = TWON_PROTOCOLMINOR;
    m_AppId.SupportedGroups = DG_IMAGE | DG_CONTROL;
    strcpy(m_AppId.Manufacturer,  "CompanyName");
    strcpy(m_AppId.ProductFamily, "ProductVersion");
    strcpy(m_AppId.ProductName,   "ProductName");

    // reset m_SrcId

    m_SrcId.Id = 0;
    m_SrcId.ProductName[0] = '\0';

    // Load TWAIN DLL

    m_hTwainDll = LoadLibrary(_T("TWAIN_32.DLL"));

    if (m_hTwainDll)
    {
        // Get the entry point

        m_DSM_Entry = (DSMENTRYPROC) GetProcAddress(m_hTwainDll, "DSM_Entry");

        if (m_DSM_Entry)
        {
            m_TwainState = State_2_Source_Manager_Loaded;
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CTwainMgr::~CTwainMgr()
{
    // Free the library if loaded

    if (m_TwainState >= State_1_Pre_Session)
    {
        FreeLibrary(m_hTwainDll);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CTwainMgr::SelectSource(
    HWND hWndParent,
    LONG /*lFlags*/
)
{
    HRESULT   hr = S_FALSE;
    TW_UINT16 rc = TWRC_FAILURE;

    if (m_TwainState >= State_2_Source_Manager_Loaded)
    {
        __try
        {
            if (m_TwainState == State_2_Source_Manager_Loaded)
            {
                // Open the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_OPENDSM,
                    (TW_MEMREF) &hWndParent
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_3_Source_Manager_Open;
            }

            // pop up the selection dialog

            rc = m_DSM_Entry(
                &m_AppId,
                0,
                DG_CONTROL,
                DAT_IDENTITY,
                MSG_USERSELECT,
                (TW_MEMREF) &m_SrcId
            );

            ASSERT(rc == TWRC_SUCCESS || rc == TWRC_CANCEL);

            if (rc == TWRC_SUCCESS)
            {
                hr = S_OK;
            }
        }
        __finally
        {
            if (m_TwainState == State_3_Source_Manager_Open)
            {
                // Close the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_CLOSEDSM,
                    (TW_MEMREF) &hWndParent
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_2_Source_Manager_Loaded;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CTwainMgr::Select(
    LPCTSTR pDeviceId
)
{
#ifdef UNICODE
    WideCharToMultiByte(CP_ACP, 0, pDeviceId, -1,
        m_SrcId.ProductName, sizeof(m_SrcId.ProductName), 0, 0);
#else //UNICODE
    lstrcpyn(m_SrcId.ProductName, pDeviceId, sizeof(m_SrcId.ProductName));
#endif //UNICODE

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
CTwainMgr::Acquire(
    HWND     hWndParent,
    HGLOBAL *phDib
)
{
    ASSERT(phDib);

    HRESULT   hr = S_FALSE;
    TW_UINT16 rc = TWRC_FAILURE;

    if (m_TwainState >= State_2_Source_Manager_Loaded)
    {
        __try
        {
            if (m_TwainState == State_2_Source_Manager_Loaded)
            {
                // Open the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_OPENDSM,
                    (TW_MEMREF) &hWndParent
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_3_Source_Manager_Open;
            }

#ifdef USE_SELECTSOURCE_MENUITEM

            if (m_SrcId.ProductName[0] == '\0')
            {
                // if no data source is selected yet, get the default

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_GETDEFAULT,
                    (TW_MEMREF) &m_SrcId
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }
            }

#else //USE_SELECTSOURCE_MENUITEM

            rc = m_DSM_Entry(
                &m_AppId,
                0,
                DG_CONTROL,
                DAT_IDENTITY,
                MSG_USERSELECT,
                (TW_MEMREF) &m_SrcId
            );

            ASSERT(rc == TWRC_SUCCESS || rc == TWRC_CANCEL);

            if (rc != TWRC_SUCCESS)
            {
                __leave;
            }

#endif //USE_SELECTSOURCE_MENUITEM

            if (m_TwainState == State_3_Source_Manager_Open)
            {
                // open the data source

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_OPENDS,
                    (TW_MEMREF) &m_SrcId
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_4_Source_Open;
            }

            // set the desired transfer options;
            // we want to transfer a single 8-bit RGB image

            SetCapability(CAP_XFERCOUNT, TWTY_INT16, 1);
            SetCapability(ICAP_PIXELTYPE, TWTY_UINT32, TWPT_RGB);
            SetCapability(ICAP_BITDEPTH, TWTY_UINT32, 8);

            if (m_TwainState == State_4_Source_Open)
            {
                // enable the data source

                TW_USERINTERFACE twUI;

                twUI.ShowUI  = TRUE;
                twUI.hParent = hWndParent;

                rc = m_DSM_Entry(
                    &m_AppId,
                    &m_SrcId,
                    DG_CONTROL,
                    DAT_USERINTERFACE,
                    MSG_ENABLEDS,
                    (TW_MEMREF) &twUI
                );

                theApp.RestoreWaitCursor();

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_5_Source_Enabled;
            }

            if (m_TwainState == State_5_Source_Enabled)
            {
                // Disable the parent window

                EnableWindow(hWndParent, FALSE);

                // Enter the message loop to transfer the image

                MSG   msg;
                BOOL  bDone = FALSE;

                while (!bDone && GetMessage(&msg, 0, 0, 0))
                {
                    // process the event through TWAIN

                    TW_EVENT twEvent;

                    twEvent.pEvent    = &msg;
                    twEvent.TWMessage = MSG_NULL;

                    rc = m_DSM_Entry(
                        &m_AppId,
                        &m_SrcId,
                        DG_CONTROL,
                        DAT_EVENT,
                        MSG_PROCESSEVENT,
                        (TW_MEMREF) &twEvent
                    );

                    if (twEvent.TWMessage == MSG_CLOSEDSREQ)
                    {
                        bDone = TRUE;
                        hr = S_FALSE;
                    }
                    else if (twEvent.TWMessage == MSG_XFERREADY)
                    {

                        m_TwainState = State_6_Transfer_Ready;

                        TW_PENDINGXFERS twPendingXfers;

                        do
                        {
                            m_TwainState = State_7_Transferring;

                            rc = m_DSM_Entry(
                                &m_AppId,
                                &m_SrcId,
                                DG_IMAGE,
                                DAT_IMAGENATIVEXFER,
                                MSG_GET,
                                (TW_MEMREF) phDib
                            );

                            if (rc != TWRC_XFERDONE)
                            {
                                if (*phDib)
                                {
                                    GlobalFree(*phDib);
                                }

                                __leave;
                            }

                            hr = S_OK;

                            // End the transfer

                            rc = m_DSM_Entry(
                                &m_AppId,
                                &m_SrcId,
                                DG_CONTROL,
                                DAT_PENDINGXFERS,
                                MSG_ENDXFER,
                                (TW_MEMREF) &twPendingXfers
                            );

                            if (rc != TWRC_SUCCESS)
                            {
                                __leave;
                            }

                            m_TwainState = State_6_Transfer_Ready;

                        } while (twPendingXfers.Count != 0);

                        m_TwainState = State_5_Source_Enabled;

                        //exit after a single image transfer

                        bDone = TRUE;
                    }

                    if (rc == TWRC_NOTDSEVENT)
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
        }
        __finally
        {
            // enable the parent window upon exiting the message loop

            EnableWindow(hWndParent, TRUE);

            ASSERT(m_TwainState <= State_6_Transfer_Ready);

            if (m_TwainState == State_6_Transfer_Ready)
            {
                TW_PENDINGXFERS twPendingXfers;

                rc = m_DSM_Entry(
                    &m_AppId,
                    &m_SrcId,
                    DG_CONTROL,
                    DAT_PENDINGXFERS,
                    MSG_RESET,
                    (TW_MEMREF) &twPendingXfers
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_5_Source_Enabled;
            }

            if (m_TwainState == State_5_Source_Enabled)
            {
                TW_USERINTERFACE twUI;

                rc = m_DSM_Entry(
                    &m_AppId,
                    &m_SrcId,
                    DG_CONTROL,
                    DAT_USERINTERFACE,
                    MSG_DISABLEDS,
                    (TW_MEMREF) &twUI
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_4_Source_Open;
            }

            if (m_TwainState == State_4_Source_Open)
            {
                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_CLOSEDS,
                    (TW_MEMREF) &m_SrcId
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_3_Source_Manager_Open;
            }

            if (m_TwainState == State_3_Source_Manager_Open)
            {
                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_CLOSEDSM,
                    (TW_MEMREF) &hWndParent
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_2_Source_Manager_Loaded;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

int CTwainMgr::NumDevices(HWND hWndParent)
{
    return 1; // this is too slow, better lie...

    int nNumDevices = 0;

    TW_UINT16 rc = TWRC_FAILURE;

    // m_TwainState >= State_2 guarantees m_DSM_Entry != 0

    if (m_TwainState >= State_2_Source_Manager_Loaded)
    {
        __try
        {
            if (m_TwainState == State_2_Source_Manager_Loaded)
            {
                // Open the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_OPENDSM,
                    (TW_MEMREF) &hWndParent
                );

                if (rc != TWRC_SUCCESS)
                {
                    __leave;
                }

                m_TwainState = State_3_Source_Manager_Open;
            }

            // Enumerate the devices one by one

            TW_IDENTITY SrcId;

            rc = m_DSM_Entry(
                &m_AppId,
                0,
                DG_CONTROL,
                DAT_IDENTITY,
                MSG_GETFIRST,
                (TW_MEMREF) &SrcId
            );

            while (rc == TWRC_SUCCESS)
            {
                ++nNumDevices;

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_IDENTITY,
                    MSG_GETNEXT,
                    (TW_MEMREF) &SrcId
                );
            }
        }
        __finally
        {
            if (m_TwainState == State_3_Source_Manager_Open)
            {
                // Close the data source manager

                rc = m_DSM_Entry(
                    &m_AppId,
                    0,
                    DG_CONTROL,
                    DAT_PARENT,
                    MSG_CLOSEDSM,
                    (TW_MEMREF) &hWndParent
                );

                ASSERT(rc == TWRC_SUCCESS);

                m_TwainState = State_2_Source_Manager_Loaded;
            }
        }
    }

    return nNumDevices;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

TW_UINT16
CTwainMgr::SetCapability(
    TW_UINT16 Cap,
    TW_UINT16 ItemType,
    TW_UINT32 Item
)
{
    TW_UINT16 rc = TWRC_FAILURE;

    TW_CAPABILITY twCapability;

    twCapability.Cap        = Cap;
    twCapability.ConType    = TWON_ONEVALUE;
    twCapability.hContainer = 0;

    twCapability.hContainer = GlobalAlloc(
        GMEM_MOVEABLE | GMEM_ZEROINIT,
        sizeof(TW_ONEVALUE)
    );

    if (twCapability.hContainer) 
    {
        pTW_ONEVALUE pVal = (pTW_ONEVALUE) GlobalLock(twCapability.hContainer);

        if (pVal) 
        {
            pVal->ItemType = ItemType;
            pVal->Item     = Item;

            GlobalUnlock(twCapability.hContainer);

            rc = m_DSM_Entry(
                &m_AppId,
                &m_SrcId,
                DG_CONTROL,
                DAT_CAPABILITY,
                MSG_SET,
                (TW_MEMREF) &twCapability
            );
        }

        GlobalFree(twCapability.hContainer);
    }

    return rc;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

TW_UINT16
CTwainMgr::GetCapability(
    TW_UINT16   Cap,
    pTW_UINT16  pItemType,
    pTW_UINT32  pItem
)
{
    TW_CAPABILITY twCapability;

    twCapability.Cap        = Cap;
    twCapability.ConType    = TWON_DONTCARE16;
    twCapability.hContainer = 0;

    TW_UINT16 rc = m_DSM_Entry(
        &m_AppId,
        &m_SrcId,
        DG_CONTROL,
        DAT_CAPABILITY,
        MSG_GET,
        (TW_MEMREF) &twCapability
    );

    if (twCapability.hContainer) 
    {
        pTW_ONEVALUE pVal = (pTW_ONEVALUE) GlobalLock(twCapability.hContainer);

        if (pVal) 
        {
            if (pItemType) 
            {
                *pItemType = pVal->ItemType;
            }

            if (pItem) 
            {
                *pItem = pVal->Item;
            }
        }

        GlobalFree(twCapability.hContainer);
    }

    return rc;
}

#endif //USE_TWAIN

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT 
WiaGetNumDevices(
    IWiaDevMgr *_pWiaDevMgr,
    ULONG      *pulNumDevices
)
{
    HRESULT hr;

    // Validate and initialize output parameters

    if (pulNumDevices == 0)
    {
        return E_POINTER;
    }

    *pulNumDevices = 0;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr = _pWiaDevMgr;

    if (pWiaDevMgr == 0)
    {
        hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_ALL|CLSCTX_NO_FAILURE_LOG);

        if (!SUCCEEDED(hr))
        {
            return hr;
        }
    }

    // Get a list of all the WIA devices on the system

    CComPtr<IEnumWIA_DEV_INFO> pIEnumWIA_DEV_INFO;

    hr = pWiaDevMgr->EnumDeviceInfo(
        0,
        &pIEnumWIA_DEV_INFO
    );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Get the number of WIA devices

    ULONG celt;

    hr = pIEnumWIA_DEV_INFO->GetCount(&celt);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    *pulNumDevices = celt;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

CEventCallback::CEventCallback()
{
    m_cRef = 0;
    m_nNumDevices = 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

HRESULT CEventCallback::Register()
{
    HRESULT hr;

    // Create a connection to the local WIA device manager

    CComPtr<IWiaDevMgr> pWiaDevMgr;

    hr = pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_ALL|CLSCTX_NO_FAILURE_LOG);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Get the count of all the WIA devices on the system

    hr = WiaGetNumDevices(pWiaDevMgr, &m_nNumDevices);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    // Register the callback interface

    hr = pWiaDevMgr->RegisterEventCallbackInterface(
        0,
        0,
        &WIA_EVENT_DEVICE_CONNECTED,
        this,
        &m_pConnectEventObject
    );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pWiaDevMgr->RegisterEventCallbackInterface(
        0,
        0,
        &WIA_EVENT_DEVICE_DISCONNECTED,
        this,
        &m_pDisconnectEventObject
    );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

ULONG CEventCallback::GetNumDevices() const
{
    return m_nNumDevices;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CEventCallback::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
        return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown *) this;
        return S_OK;
    }

    if (iid == IID_IWiaEventCallback)
    {
        AddRef();
        *ppvObj = (IWiaEventCallback *) this;
        return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CEventCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CEventCallback::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CEventCallback::ImageEventCallback(
    LPCGUID pEventGuid,
    BSTR    bstrEventDescription,
    BSTR    bstrDeviceID,
    BSTR    bstrDeviceDescription,
    DWORD   dwDeviceType,
    BSTR    bstrFullItemName,
    ULONG  *pulEventType,
    ULONG   ulReserved
)
{
    return WiaGetNumDevices(0, &m_nNumDevices);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CDataCallback::CDataCallback(IWiaProgressDialog *pProgress)
{
    m_cRef        = 0;
    m_hBuffer     = 0;
    m_lBufferSize = 0;
    m_lDataSize   = 0;
    m_pProgress   = pProgress;

#ifdef DBG
    m_hDumpFile = CreateFile(_T("wiadump.bin"), GENERIC_WRITE, 
        FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    m_TimeDeviceBegin.QuadPart  = 0;
    m_TimeDeviceEnd.QuadPart    = 0;
    m_TimeProcessBegin.QuadPart = 0;
    m_TimeProcessEnd.QuadPart   = 0;
    m_TimeClientBegin.QuadPart  = 0;
    m_TimeClientEnd.QuadPart    = 0;
#endif //DBG
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CDataCallback::~CDataCallback()
{
    if (m_hBuffer)
    {
        GlobalFree(m_hBuffer);
    }

#ifdef DBG
    CloseHandle(m_hDumpFile);
#endif //DBG
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HGLOBAL CDataCallback::GetBuffer()
{
    HGLOBAL hBuffer = m_hBuffer;

    m_hBuffer     = 0;
    m_lBufferSize = 0;
    m_lDataSize   = 0;

    return hBuffer;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CDataCallback::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
        return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*) this;
        return S_OK;
    }

    if (iid == IID_IWiaDataCallback)
    {
        AddRef();
        *ppvObj = (IWiaDataCallback *) this;
        return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CDataCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CDataCallback::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CDataCallback::BandedDataCallback(
    LONG  lReason,
    LONG  lStatus,
    LONG  lPercentComplete,
    LONG  lOffset,
    LONG  lLength,
    LONG  lReserved,
    LONG  lResLength,
    PBYTE pbBuffer
)
{
    HRESULT hr;

    Trace(
        _T("DataCallback: Reason=%d Stat=%d %%=%d Offset=%d Length=%d Buf=%p\n"),
        lReason, lStatus, lPercentComplete, lOffset, lLength, pbBuffer
    );

    // check if the user has pressed cancel

    BOOL bCancelled;

    if (m_pProgress && m_pProgress->Cancelled(&bCancelled) == S_OK && bCancelled)
    {
        return S_FALSE;
    }

    switch (lReason)
    {
        case IT_MSG_DATA_HEADER:
        {
            // allocate memory for the image if the size is given in the header

            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER) pbBuffer;

            if (pHeader && pHeader->lBufferSize)
            {
                hr = ReAllocBuffer(pHeader->lBufferSize);

                if (hr != S_OK)
                {
                    return S_FALSE;
                }
            }
        
            break;
        }

        case IT_MSG_DATA:
        {
            QueryStartTimes(lStatus, lPercentComplete);

            UpdateStatus(lStatus, lPercentComplete);

            // if the buffer is not allocated yet and this is the first block, 
            // try to allocate a buffer according to the bitmap header info

            if (m_lBufferSize == 0 && lOffset == 0)
            {
                LONG lBufferSize = FindDibSize(pbBuffer);

                if (lBufferSize)
                {
                    hr = ReAllocBuffer(lBufferSize);

                    if (hr != S_OK)
                    {
                        return S_FALSE;
                    }
                }
            }

            // if the transfer goes past the buffer, try to expand it

            if (lOffset + lLength > m_lBufferSize)
            {
                hr = ReAllocBuffer(lOffset + 2*lLength);

                if (hr != S_OK)
                {
                    return S_FALSE;
                }
            }

            // keep track of data size

            if (lOffset + lLength > m_lDataSize)
            {
                m_lDataSize = lOffset + lLength;
            }

            // copy the transfer buffer

            PBYTE pBuffer = (PBYTE) GlobalLock(m_hBuffer);

            if (pBuffer)
            {
                CopyMemory(pBuffer + lOffset, pbBuffer, lLength);

                GlobalUnlock(m_hBuffer);
            }

#ifdef DBG
            DWORD nWritten;
            SetFilePointer(m_hDumpFile, lOffset, 0, FILE_BEGIN);
            WriteFile(m_hDumpFile, pbBuffer, lLength, &nWritten, 0);
#endif //DBG

            QueryStopTimes(lStatus, lPercentComplete);

            break;
        }

        case IT_MSG_STATUS:
        {
            // update the progress bar position

            QueryStartTimes(lStatus, lPercentComplete);

            UpdateStatus(lStatus, lPercentComplete);

            QueryStopTimes(lStatus, lPercentComplete);

            break;
        }

        case IT_MSG_TERMINATION:
        {
            PVOID pBuffer = GlobalLock(m_hBuffer);

            if (pBuffer)
            {
                FixDibHeader(pBuffer, m_lDataSize);

                GlobalUnlock(m_hBuffer);
            }

            break;
        }

        case IT_MSG_NEW_PAGE:
        {
            // mspaint should not get this message, but...

            PVOID pBuffer = GlobalLock(m_hBuffer);

            if (pBuffer)
            {
                FixDibHeader(pBuffer, m_lDataSize);

                GlobalUnlock(m_hBuffer);
            }

            break;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT CDataCallback::ReAllocBuffer(LONG lBufferSize)
{
    // try to allocate the new buffer

    Trace(_T("Allocating %d bytes for image data\n"), lBufferSize);

    HGLOBAL hBuffer;

    if (m_hBuffer == 0)
    {
        hBuffer = (PBYTE) GlobalAlloc(GMEM_MOVEABLE, lBufferSize);
    }
    else
    {
        hBuffer = (PBYTE) GlobalReAlloc(m_hBuffer, lBufferSize, 0);
    }

    if (hBuffer == 0)
    {
        theApp.SetMemoryEmergency(TRUE);
        return S_FALSE;
    }

    // store this new buffer

    m_hBuffer = hBuffer;

    m_lBufferSize = lBufferSize;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

inline ULONG LineWidth(ULONG nWidth, ULONG nBitCount)
{
    return (((nWidth * nBitCount) + 31) & ~31) >> 3;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

ULONG FindDibSize(LPCVOID pDib)
{
    ULONG nHeaderSize = *(PDWORD)pDib;

    // Do we recognize the header?

    if (nHeaderSize != sizeof(BITMAPCOREHEADER) &&
        nHeaderSize != sizeof(BITMAPINFOHEADER) &&
        nHeaderSize != sizeof(BITMAPV4HEADER)   &&
        nHeaderSize != sizeof(BITMAPV5HEADER))
    {
        return 0;
    }

    // Start the calculation with the header size

    ULONG nDibSize = nHeaderSize;

    // is this an old style BITMAPCOREHEADER?

    if (nHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        PBITMAPCOREHEADER pbmch = (PBITMAPCOREHEADER) pDib;

        // Add the color table size

        if (pbmch->bcBitCount <= 8)
        {
            nDibSize += sizeof(RGBTRIPLE) * (1 << pbmch->bcBitCount);
        }

        // Add the bitmap size

        nDibSize += LineWidth(pbmch->bcWidth, pbmch->bcBitCount) * pbmch->bcHeight;
    }
    else
    {
        // this is at least a BITMAPINFOHEADER

        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) pDib;

        // Add the color table size

        if (pbmih->biClrUsed != 0)
        {
            nDibSize += sizeof(RGBQUAD) * pbmih->biClrUsed;
        }
        else if (pbmih->biBitCount <= 8)
        {
            nDibSize += sizeof(RGBQUAD) * (1 << pbmih->biBitCount);
        }

        // Add the bitmap size

        if (pbmih->biSizeImage != 0)
        {
            nDibSize += pbmih->biSizeImage;
        }
        else
        {
            // biSizeImage must be specified for compressed bitmaps

            if (pbmih->biCompression != BI_RGB &&
                pbmih->biCompression != BI_BITFIELDS)
            {
                return 0;
            }

            nDibSize += LineWidth(pbmih->biWidth, pbmih->biBitCount) * abs(pbmih->biHeight);
        }

        // Consider special cases

        if (nHeaderSize == sizeof(BITMAPINFOHEADER))
        {     
            // If this is a 16 or 32 bit bitmap and BI_BITFIELDS is used, 
            // bmiColors member contains three DWORD color masks.
            // For V4 or V5 headers, this info is included the header

            if (pbmih->biCompression == BI_BITFIELDS)
            {
                nDibSize += 3 * sizeof(DWORD);
            }
        }
        else if (nHeaderSize >= sizeof(BITMAPV5HEADER))
        {
            // If this is a V5 header and an ICM profile is specified,
            // we need to consider the profile data size
            
            PBITMAPV5HEADER pbV5h = (PBITMAPV5HEADER) pDib;

            // if there is some padding before the profile data, add it

            if (pbV5h->bV5ProfileData > nDibSize)
            {
                nDibSize = pbV5h->bV5ProfileData;
            }

            // add the profile data size

            nDibSize += pbV5h->bV5ProfileSize;
        }
    }

    return nDibSize;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

ULONG FindDibOffBits(LPCVOID pDib)
{
    ULONG nHeaderSize = *(PDWORD)pDib;

    // Do we recognize the header?

    if (nHeaderSize != sizeof(BITMAPCOREHEADER) &&
        nHeaderSize != sizeof(BITMAPINFOHEADER) &&
        nHeaderSize != sizeof(BITMAPV4HEADER)   &&
        nHeaderSize != sizeof(BITMAPV5HEADER))
    {
        return 0;
    }

    // Start the calculation with the header size

    ULONG nOffBits = nHeaderSize;

    // is this an old style BITMAPCOREHEADER?

    if (nHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        PBITMAPCOREHEADER pbmch = (PBITMAPCOREHEADER) pDib;

        // Add the color table size

        if (pbmch->bcBitCount <= 8)
        {
            nOffBits += sizeof(RGBTRIPLE) * (1 << pbmch->bcBitCount);
        }
    }
    else
    {
        // this is at least a BITMAPINFOHEADER

        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) pDib;

        // Add the color table size

        if (pbmih->biClrUsed != 0)
        {
            nOffBits += sizeof(RGBQUAD) * pbmih->biClrUsed;
        }
        else if (pbmih->biBitCount <= 8)
        {
            nOffBits += sizeof(RGBQUAD) * (1 << pbmih->biBitCount);
        }

        // Consider special cases

        if (nHeaderSize == sizeof(BITMAPINFOHEADER))
        {     
            // If this is a 16 or 32 bit bitmap and BI_BITFIELDS is used, 
            // bmiColors member contains three DWORD color masks.
            // For V4 or V5 headers, this info is included the header

            if (pbmih->biCompression == BI_BITFIELDS)
            {
                nOffBits += 3 * sizeof(DWORD);
            }
        }
        else if (nHeaderSize >= sizeof(BITMAPV5HEADER))
        {
            // If this is a V5 header and an ICM profile is specified,
            // we need to consider the profile data size
            
            PBITMAPV5HEADER pbV5h = (PBITMAPV5HEADER) pDib;

            // if the profile data comes before the pixel data, add it

            if (pbV5h->bV5ProfileData <= nOffBits)
            {
                nOffBits += pbV5h->bV5ProfileSize;
            }
        }
    }

    return nOffBits;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void FixDibHeader(LPVOID pDib, DWORD dwSize)
{
    ULONG nHeaderSize = *(PDWORD)pDib;

    // Do we recognize the header?

    if (