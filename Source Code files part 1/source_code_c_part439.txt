TM_SIMPLESTRING_UNSPECIFIED; 
    } else if (tzi.StandardDate.wMonth>12 || tzi.StandardDate.wDay>5 || 
               tzi.StandardDate.wDay<1 || tzi.StandardDate.wDayOfWeek>6) {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_INVALID_TZ_DATE, &wszStandardDate, 
                      tzi.StandardDate.wMonth, tzi.StandardDate.wDay, tzi.StandardDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    } else {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_VALID_TZ_DATE, &wszStandardDate, 
                      tzi.StandardDate.wMonth, tzi.StandardDate.wDay, tzi.StandardDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    }

    // Construct a string representing the "DaylightDate" field of the TimeZoneInformation: 
    if (0==tzi.DaylightDate.wMonth) {
        wszDaylightDate = pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED; 
    } else if (tzi.DaylightDate.wMonth>12 || tzi.DaylightDate.wDay>5 || 
               tzi.DaylightDate.wDay<1 || tzi.DaylightDate.wDayOfWeek>6) {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_INVALID_TZ_DATE, &wszDaylightDate, 
                      tzi.DaylightDate.wMonth, tzi.DaylightDate.wDay, tzi.DaylightDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    } else {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_VALID_TZ_DATE, &wszDaylightDate, 
                      tzi.DaylightDate.wMonth, tzi.DaylightDate.wDay, tzi.DaylightDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    }

    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_TIMEZONE_INFO, 
               wszTimeZoneId,    tzi.Bias, 
               tzi.StandardName, tzi.StandardBias, wszStandardDate, 
               tzi.DaylightName, tzi.DaylightBias, wszDaylightDate); 

    hr=S_OK;
error:
    // Free our localized strings: 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (NULL != *(rgStrings[dwIndex].ppwsz)) { LocalFree(*(rgStrings[dwIndex].ppwsz)); }
    }
    if (NULL != wszDaylightDate) { 
        LocalFree(wszDaylightDate); 
    }
    if (NULL != wszStandardDate) { 
        LocalFree(wszStandardDate); 
    }
    if (FAILED(hr) && E_INVALIDARG!=hr) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT PrintRegLine(IN  HANDLE  hOut, 
                     IN  DWORD   dwValueNameOffset, 
                     IN  LPWSTR  pwszValueName, 
                     IN  DWORD   dwValueTypeOffset, 
                     IN  LPWSTR  pwszValueType, 
                     IN  DWORD   dwValueDataOffset, 
                     IN  LPWSTR  pwszValueData)
{
    DWORD    dwCurrentOffset = 0; 
    HRESULT  hr;
    LPWSTR   pwszCurrent; 
    LPWSTR   pwszEnd; 
    WCHAR    pwszLine[1024]; 
    WCHAR    wszNULL[] = L"<NULL>"; 

    if (NULL == pwszValueName) { pwszValueName = &wszNULL[0]; } 
    if (NULL == pwszValueType) { pwszValueType = &wszNULL[0]; } 
    if (NULL == pwszValueData) { pwszValueData = &wszNULL[0]; } 

    pwszEnd = pwszLine + ARRAYSIZE(pwszLine);  // point to the end of the line buffer
    pwszCurrent = &pwszLine[0];                // point to the beginning of the line buffer

    //
    // Use the safe string functions to populate the line buffer
    //

    hr = StringCchCopy(pwszCurrent, pwszEnd-pwszCurrent, pwszValueName);
    _JumpIfError(hr, error, "StringCchCopy"); 
    pwszCurrent += wcslen(pwszCurrent); 

    // Insert enough spaces to align the "type" field with the type offset
    for (DWORD dwIndex = pwszCurrent-pwszLine; dwIndex < dwValueTypeOffset; dwIndex++) { 
	hr = StringCchCopy(pwszCurrent, pwszEnd-pwszCurrent, L" "); 
	_JumpIfError(hr, error, "StringCchCopy"); 
	pwszCurrent++; 
    }
    
    hr = StringCchCopy(pwszCurrent, pwszEnd-pwszCurrent, pwszValueType);
    _JumpIfError(hr, error, "StringCchCopy"); 
    pwszCurrent += wcslen(pwszCurrent); 
    
    // Insert enoughs spaces to align the "data" field with the data offset
    for (DWORD dwIndex = pwszCurrent-pwszLine; dwIndex < dwValueDataOffset; dwIndex++) { 
	hr = StringCchCopy(pwszCurrent, pwszEnd-pwszCurrent, L" "); 
	_JumpIfError(hr, error, "StringCchCopy"); 
	pwszCurrent++; 
    }

    hr = StringCchCopy(pwszCurrent, pwszEnd-pwszCurrent, pwszValueData);
    _JumpIfError(hr, error, "StringCchCopy"); 
    pwszCurrent += wcslen(pwszCurrent); 
    
    hr = StringCchCopy(pwszCurrent, pwszEnd-pwszCurrent, L"\n");
    _JumpIfError(hr, error, "StringCchCopy"); 

    // Finally, display the reg line
    PrintStr(hOut, &pwszLine[0]); 

    hr = S_OK;
 error:
    return hr; 
}


HRESULT DumpReg(CmdArgs * pca)
{
    BOOL          fFreeRegData        = FALSE;  // Used to indicate whether we've dymanically allocated pwszRegData
    BOOL          fLoggedFailure      = FALSE; 
    DWORD         dwMaxValueNameLen   = 0;      // Size in TCHARs.
    DWORD         dwMaxValueDataLen   = 0;      // Size in bytes.
    DWORD         dwNumValues         = 0; 
    DWORD         dwRetval            = 0;
    DWORD         dwType              = 0;
    DWORD         dwValueNameLen      = 0;      // Size in TCHARs.
    DWORD         dwValueDataLen      = 0;      // Size in bytes.
    HANDLE        hOut                = NULL;
    HKEY          hKeyConfig          = NULL;
    HKEY          HKLM                = HKEY_LOCAL_MACHINE; 
    HKEY          HKLMRemote          = NULL; 
    HRESULT       hr                  = E_FAIL;
    LPWSTR        pwszValueName       = NULL; 
    LPBYTE        pbValueData         = NULL; 
    LPWSTR        pwszSubkeyName      = NULL; 
    LPWSTR        pwszComputerName    = NULL; 
    LPWSTR        pwszRegType         = NULL; 
    LPWSTR        pwszRegData         = NULL; 
    unsigned int  nArgID              = 0;
    WCHAR         rgwszKeyName[1024];

    // Variables to display formatted output:
    DWORD    dwCurrentOffset     = 0;
    DWORD    dwValueNameOffset   = 0;
    DWORD    dwValueTypeOffset   = 0; 
    DWORD    dwValueDataOffset   = 0; 

    // Localized strings: 
    LPWSTR  pwsz_VALUENAME            = NULL;
    LPWSTR  pwsz_VALUETYPE            = NULL; 
    LPWSTR  pwsz_VALUEDATA            = NULL;
    LPWSTR  pwsz_REGTYPE_BINARY       = NULL; 
    LPWSTR  pwsz_REGTYPE_DWORD        = NULL; 
    LPWSTR  pwsz_REGTYPE_SZ           = NULL; 
    LPWSTR  pwsz_REGTYPE_MULTISZ      = NULL; 
    LPWSTR  pwsz_REGTYPE_EXPANDSZ     = NULL; 
    LPWSTR  pwsz_REGTYPE_UNKNOWN      = NULL; 
    LPWSTR  pwsz_REGDATA_UNPARSABLE   = NULL; 

    // Load the strings we'll need
    struct LocalizedStrings { 
        UINT     id; 
        LPWSTR  *ppwsz; 
    } rgStrings[] = { 
        { IDS_W32TM_VALUENAME,           &pwsz_VALUENAME }, 
        { IDS_W32TM_VALUETYPE,           &pwsz_VALUETYPE }, 
        { IDS_W32TM_VALUEDATA,           &pwsz_VALUEDATA },
	{ IDS_W32TM_REGTYPE_BINARY,      &pwsz_REGTYPE_BINARY }, 
        { IDS_W32TM_REGTYPE_DWORD,       &pwsz_REGTYPE_DWORD }, 
        { IDS_W32TM_REGTYPE_SZ,          &pwsz_REGTYPE_SZ }, 
        { IDS_W32TM_REGTYPE_MULTISZ,     &pwsz_REGTYPE_MULTISZ }, 
        { IDS_W32TM_REGTYPE_EXPANDSZ,    &pwsz_REGTYPE_EXPANDSZ }, 
        { IDS_W32TM_REGTYPE_UNKNOWN,     &pwsz_REGTYPE_UNKNOWN }, 
        { IDS_W32TM_REGDATA_UNPARSABLE,  &pwsz_REGDATA_UNPARSABLE }
    }; 
       
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, rgStrings[dwIndex].id, rgStrings[dwIndex].ppwsz)) {
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "WriteMsg"); 
        }
    }
    
    hr = StringCchCopy(&rgwszKeyName[0], ARRAYSIZE(rgwszKeyName), wszW32TimeRegKeyRoot); 
    _JumpIfError(hr, error, "StringCchCopy"); 
    
    if (true==FindArg(pca, L"subkey", &pwszSubkeyName, &nArgID)) { 
        MarkArgUsed(pca, nArgID); 

        if (NULL == pwszSubkeyName) { 
            LocalizedWPrintfCR(IDS_W32TM_ERRORDUMPREG_NO_SUBKEY_SPECIFIED);
            fLoggedFailure = TRUE;
            hr = E_INVALIDARG; 
            _JumpError(hr, error, "command line parsing");
        }
	
	hr = StringCchCat(&rgwszKeyName[0], ARRAYSIZE(rgwszKeyName), L"\\"); 
	_JumpIfError(hr, error, "StringCchCopy"); 
	
        hr = StringCchCat(&rgwszKeyName[0], ARRAYSIZE(rgwszKeyName), pwszSubkeyName); 
	_JumpIfError(hr, error, "StringCchCopy"); 
    }

    if (true==FindArg(pca, L"computer", &pwszComputerName, &nArgID)) { 
        MarkArgUsed(pca, nArgID); 
        
        dwRetval = RegConnectRegistry(pwszComputerName, HKEY_LOCAL_MACHINE, &HKLMRemote);
        if (ERROR_SUCCESS != dwRetval) { 
            hr = HRESULT_FROM_WIN32(dwRetval); 
            _JumpErrorStr(hr, error, "RegConnectRegistry", L"HKEY_LOCAL_MACHINE");
        }

        HKLM = HKLMRemote;
    }
    
    hr = VerifyAllArgsUsed(pca); 
    _JumpIfError(hr, error, "VerifyAllArgsUsed"); 
        

    dwRetval = RegOpenKeyEx(HKLM, rgwszKeyName, 0, KEY_QUERY_VALUE, &hKeyConfig);
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpErrorStr(hr, error, "RegOpenKeyEx", rgwszKeyName); 
    }
    
    dwRetval = RegQueryInfoKey
        (hKeyConfig,
         NULL,                // class buffer
         NULL,                // size of class buffer
         NULL,                // reserved
         NULL,                // number of subkeys
         NULL,                // longest subkey name
         NULL,                // longest class string
         &dwNumValues,        // number of value entries
         &dwMaxValueNameLen,  // longest value name
         &dwMaxValueDataLen,  // longest value data
         NULL, 
         NULL
         );
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval);
        _JumpErrorStr(hr, error, "RegQueryInfoKey", rgwszKeyName);
    } else if (0 == dwNumValues) { 
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS); 
        _JumpErrorStr(hr, error, "RegQueryInfoKey", rgwszKeyName);
    }

    dwMaxValueNameLen += sizeof(WCHAR);  // Include space for NULL character
    pwszValueName = (LPWSTR)LocalAlloc(LPTR, dwMaxValueNameLen * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszValueName);

    pbValueData = (LPBYTE)LocalAlloc(LPTR, dwMaxValueDataLen);
    _JumpIfOutOfMemory(hr, error, pbValueData); 
        
    dwValueNameOffset  = 0;
    dwValueTypeOffset  = dwValueNameOffset + dwMaxValueNameLen + 3; 
    dwValueDataOffset += dwValueTypeOffset + 20;  
     
    // Print table header:
    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle");
    }

    PrintStr(hOut, L"\n"); 
    PrintRegLine(hOut, dwValueNameOffset, pwsz_VALUENAME, dwValueTypeOffset, pwsz_VALUETYPE, dwValueDataOffset, pwsz_VALUEDATA); 

    // Next line:
    dwCurrentOffset = dwValueNameOffset; 
    for (DWORD dwIndex = dwCurrentOffset; dwIndex < (dwValueDataOffset + wcslen(pwsz_VALUEDATA) + 3); dwIndex++) { 
        PrintStr(hOut, L"-"); 
    }
    PrintStr(hOut, L"\n\n"); 
    
    for (DWORD dwIndex = 0; dwIndex < dwNumValues; dwIndex++) { 
	
        dwValueNameLen = dwMaxValueNameLen;
        dwValueDataLen = dwMaxValueDataLen; 

        memset(reinterpret_cast<LPBYTE>(pwszValueName), 0, dwMaxValueNameLen * sizeof(WCHAR)); 
        memset(pbValueData, 0, dwMaxValueDataLen);

        dwRetval = RegEnumValue
            (hKeyConfig,       // handle to key to query
             dwIndex,          // index of value to query
             pwszValueName,    // value buffer
             &dwValueNameLen,  // size of value buffer  (in TCHARs)
             NULL,             // reserved
             &dwType,          // type buffer
             pbValueData,      // data buffer
             &dwValueDataLen   // size of data buffer
             ); 
        if (ERROR_SUCCESS != dwRetval) { 
            hr = HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegEnumValue", wszW32TimeRegKeyConfig);
        }

        _Verify(dwValueNameLen <= dwMaxValueNameLen, hr, error);
        _Verify(dwValueDataLen <= dwMaxValueDataLen, hr, error); 

        {

            switch (dwType) { 
            
            case REG_DWORD:  
                { 
                    WCHAR  rgwszDwordData[20]; 

		    // Ensure that the returned data buffer is large enough to contain a DWORD:
		    _Verify(dwValueDataLen >= sizeof(long), hr, error); 

                    _ltow(*(reinterpret_cast<long *>(pbValueData)), rgwszDwordData, 10);
                    pwszRegType = pwsz_REGTYPE_DWORD; 
                    pwszRegData = &rgwszDwordData[0]; 
                }
                break;

            case REG_MULTI_SZ:
                {
		    DWORD  cbMultiSzData    = 0; 
                    WCHAR  wszDelimiter[]   = { L'\0', L'\0', L'\0' };
                    LPWSTR pwsz; 

		    // calculate the size of the string buffer needed to contain the string data for this MULTI_SZ
                    for (pwsz = (LPWSTR)pbValueData; L'\0' != *pwsz; pwsz += wcslen(pwsz)+1) { 
			cbMultiSzData += sizeof(WCHAR)*(wcslen(pwsz)+1); 
			cbMultiSzData += sizeof(WCHAR)*2; // include space for delimiter
		    }
		    cbMultiSzData += sizeof(WCHAR); // include space for NULL-termination char
		    
		    // allocate the buffer
		    pwszRegData = (LPWSTR)LocalAlloc(LPTR, cbMultiSzData); 
		    _JumpIfOutOfMemory(hr, error, pwszRegData); 
		    fFreeRegData = TRUE; 

                    for (pwsz = (LPWSTR)pbValueData; L'\0' != *pwsz; pwsz += wcslen(pwsz)+1) { 
                        hr = StringCbCat(pwszRegData, cbMultiSzData, wszDelimiter); 
			_JumpIfError(hr, error, "StringCbCat"); 			

                        hr = StringCbCat(pwszRegData, cbMultiSzData, pwsz); 
			_JumpIfError(hr, error, "StringCbCat"); 

                        wszDelimiter[0] = L',';  wszDelimiter[1] = L' '; 
                    }

                    pwszRegType = pwsz_REGTYPE_MULTISZ; 
                }
                break;

            case REG_EXPAND_SZ:
                {
                    pwszRegType = pwsz_REGTYPE_EXPANDSZ; 
                    pwszRegData = reinterpret_cast<WCHAR *>(pbValueData); 
                }
                break;

            case REG_SZ: 
                { 
                    pwszRegType = pwsz_REGTYPE_SZ; 
                    pwszRegData = reinterpret_cast<WCHAR *>(pbValueData); 
                } 
                break; 

	    case REG_BINARY:
		{
		    DWORD   ccRegData = (2*dwValueDataLen);

		    pwszRegType = pwsz_REGTYPE_BINARY; 
		    // Allocate 2 characters per each byte of the binary data.  
		    pwszRegData = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(ccRegData+1)); 
		    _JumpIfOutOfMemory(hr, error, pwszRegData); 
		    fFreeRegData = TRUE; 

		    LPBYTE pb = pbValueData; 
		    for (LPWSTR pwsz = pwszRegData; pwsz < pwsz+ccRegData; ) { 
			hr = StringCchPrintf(pwsz, ccRegData+1, L"%02X", *pb); 
			_JumpIfError(hr, error, "StringCchPrintf"); 

			pwsz      += 2; 
			ccRegData -= 2; 
			pb++;
		    }
		}
		break;

	    default:
                // Unrecognized reg type...
                pwszRegType = pwsz_REGTYPE_UNKNOWN; 
                pwszRegData = pwsz_REGDATA_UNPARSABLE; 
            }

            PrintRegLine(hOut, dwValueNameOffset, pwszValueName, dwValueTypeOffset, pwszRegType, dwValueDataOffset, pwszRegData); 
	    
	    if (fFreeRegData) { 
		LocalFree(pwszRegData); 
		fFreeRegData = FALSE; 
	    }
	    pwszRegData = NULL; 
        }
    }
   
    PrintStr(hOut, L"\n"); 
    hr = S_OK; 

 error:
    // Free our localized strings: 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (NULL != *(rgStrings[dwIndex].ppwsz)) { LocalFree(*(rgStrings[dwIndex].ppwsz)); }
    }
    if (NULL != hKeyConfig)    { RegCloseKey(hKeyConfig); }
    if (NULL != HKLMRemote)    { RegCloseKey(HKLMRemote); } 
    if (NULL != pwszValueName) { LocalFree(pwszValueName); } 
    if (NULL != pbValueData)   { LocalFree(pbValueData); } 
    if (fFreeRegData && NULL != pwszRegData) { 
	LocalFree(pwszRegData);
    }
    if (FAILED(hr) && !fLoggedFailure) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\timemonitor.h ===
//--------------------------------------------------------------------
// TimeMonitor - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// Monitor time servers
//

#ifndef TIME_MONITOR_H
#define TIME_MONITOR_H

// forward decalrations
struct CmdArgs;

void PrintHelpTimeMonitor(void);
HRESULT TimeMonitor(CmdArgs * pca);

#endif //TIME_MONITOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\timemonitor.cpp ===
//--------------------------------------------------------------------
// TimeMonitor - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// Monitor time servers
//

#include "pch.h" // precompiled headers

//####################################################################

struct ComputerRecord {
    WCHAR * wszName;
    bool bIsPdc;

    // DNS
    in_addr * rgiaLocalIpAddrs;
    in_addr * rgiaRemoteIpAddrs;
    unsigned int nIpAddrs;
    HRESULT hrIPs;

    // ICMP
    HRESULT hrIcmp;
    DWORD dwIcmpDelay;

    // NTP
    NtTimeOffset toOffset;
    HRESULT hrNtp;
    NtpRefId refid;
    unsigned int nStratum;
    ComputerRecord * pcrReferer;
    WCHAR * wszReferer;
    unsigned int nTimeout; 

    // SERVICE
    bool bDoingService;
    HRESULT hrService;
    DWORD dwStartType;
    DWORD dwCurrentState;
};

struct NameHolder {
    WCHAR * wszName;
    bool bIsDomain;
    NameHolder * pnhNext;
};

enum AlertType {
    e_MaxSpreadAlert,
    e_MinServersAlert,
};

struct AlertRecord {
    AlertType eType;
    unsigned int nParam1;
    DWORD dwError;
    AlertRecord * parNext;
};

struct ThreadSharedContext {
    ComputerRecord ** rgpcrList;
    unsigned int nComputers;
    volatile unsigned int nNextComputer;
    volatile unsigned int nFinishedComputers;
};

struct ThreadContext {
    HANDLE hThread;
    volatile unsigned int nCurRecord;
    ThreadSharedContext * ptsc;
};


MODULEPRIVATE const DWORD gc_dwTimeout=1000;

//####################################################################
//--------------------------------------------------------------------
MODULEPRIVATE inline void ClearLine(void) {
    wprintf(L"                                                                      \r");
}


//--------------------------------------------------------------------
MODULEPRIVATE void FreeComputerRecord(ComputerRecord * pcr) {
    if (NULL==pcr) {
        return;
    }
    if (NULL!=pcr->wszName) {
        LocalFree(pcr->wszName);
    }
    if (NULL!=pcr->rgiaLocalIpAddrs) {
        LocalFree(pcr->rgiaLocalIpAddrs);
    }
    if (NULL!=pcr->rgiaRemoteIpAddrs) {
        LocalFree(pcr->rgiaRemoteIpAddrs);
    }
    if (NULL!=pcr->wszReferer) {
        LocalFree(pcr->wszReferer);
    }
    LocalFree(pcr);
};

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AnalyzeComputer(ComputerRecord * pcr) {
    HRESULT hr;
    NtpPacket npPacket;
    NtTimeEpoch teDestinationTimestamp;

    DebugWPrintf1(L"%s:\n", pcr->wszName);

    // look up Ip addrs if necessary
    if (0==pcr->nIpAddrs) {
        hr=MyGetIpAddrs(pcr->wszName, &pcr->rgiaLocalIpAddrs, &pcr->rgiaRemoteIpAddrs, &pcr->nIpAddrs, NULL);
        pcr->hrIPs=hr;
        _JumpIfError(hr, error, "MyGetIpAddrs");
    }

    // do an ICMP ping
    DebugWPrintf0(L"  ICMP: ");
    hr=MyIcmpPing(&(pcr->rgiaRemoteIpAddrs[0]), gc_dwTimeout, &pcr->dwIcmpDelay);
    pcr->hrIcmp=hr;
    // Some machines do not have ping servers, but still serve time.  We can still try an NTP ping
    // if this fails.  
    _IgnoreIfError(hr, "MyIcmpPing");

    // do an NTP ping
    DebugWPrintf0(L"    NTP: ");
    hr=MyNtpPing(&(pcr->rgiaRemoteIpAddrs[0]), pcr->nTimeout, &npPacket, &teDestinationTimestamp);
    pcr->hrNtp=hr;
    _JumpIfError(hr, error, "MyNtpPing");

    {
        // calculate the offset
        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teTransmitTimestamp);
        NtTimeOffset toLocalClockOffset=
            (teReceiveTimestamp-teOriginateTimestamp)
            + (teTransmitTimestamp-teDestinationTimestamp);
        toLocalClockOffset/=2;
        pcr->toOffset=toLocalClockOffset;

        // new referer?
        if (pcr->refid.value!=npPacket.refid.value || pcr->nStratum!=npPacket.nStratum) {
            // clean out the old values
            if (NULL!=pcr->wszReferer) {
                LocalFree(pcr->wszReferer);
                pcr->wszReferer=NULL;
            }
            pcr->pcrReferer=NULL;
            pcr->refid.value=npPacket.refid.value;
            pcr->nStratum=npPacket.nStratum;
        }
    }
    
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI AnalysisThread(void * pvContext) {
    ThreadContext * ptc=(ThreadContext *)pvContext;

    while (true) {
        ptc->nCurRecord=InterlockedIncrement((LONG *)&(ptc->ptsc->nNextComputer))-1;
        if (ptc->nCurRecord<ptc->ptsc->nComputers) {
            AnalyzeComputer(ptc->ptsc->rgpcrList[ptc->nCurRecord]);
            ptc->ptsc->nFinishedComputers++; // atomic
        } else {
            break;
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolveReferer(ComputerRecord ** rgpcrList, unsigned int nComputers, unsigned int nCur) {
    HRESULT hr;
    unsigned int nIndex;
    HOSTENT * phe;
    int nChars;

    // see if it is nobody
    if (0==rgpcrList[nCur]->refid.value || 1>=rgpcrList[nCur]->nStratum) {
        // no referer
    } else if (NULL==rgpcrList[nCur]->wszReferer && NULL==rgpcrList[nCur]->pcrReferer) {
        // referer not yet determined

        // first, see if it is someone we are checking
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            if (rgpcrList[nIndex]->nIpAddrs>0 && 
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_addr==rgpcrList[nCur]->refid.value) {
                rgpcrList[nCur]->pcrReferer=rgpcrList[nIndex];
            }
        }

        // if we still don't know, do a reverse DNS lookup
        if (NULL==rgpcrList[nCur]->pcrReferer) {
            phe=gethostbyaddr((char *)&(rgpcrList[nCur]->refid.value), 4, AF_INET);
            if (NULL==phe) {
                // not worth aborting over.
                _IgnoreLastError("gethostbyaddr");
            } else {

                // save the result as a unicode string
                nChars=MultiByteToWideChar(CP_ACP, 0, phe->h_name, -1, NULL, 0);
                if (0==nChars) {
                    _JumpLastError(hr, error, "MultiByteToWideChar(1)");
                }
                rgpcrList[nCur]->wszReferer=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*nChars);
                _JumpIfOutOfMemory(hr, error, rgpcrList[nCur]->wszReferer);
                nChars=MultiByteToWideChar(CP_ACP, 0, phe->h_name, -1, rgpcrList[nCur]->wszReferer, nChars);
                if (0==nChars) {
                    _JumpLastError(hr, error, "MultiByteToWideChar(2)");
                }

            } // <- end if lookup successful
        } // <- end if need to to reverse DNS lookup
    } // <- end if need to determine referer

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ParseCmdLineForComputerNames(CmdArgs * pca, NameHolder ** ppnhList) {
    HRESULT hr;
    NameHolder * pnhTemp;
    WCHAR * wszComputerList;
    WCHAR * wszDomainName;
    unsigned int nComputerIndex;
    unsigned int nDomainIndex;

    // must be cleaned up
    NameHolder * pnhList=NULL;

    NameHolder ** ppnhTail=&pnhList;

    // check for list of computers
    while (FindArg(pca, L"computers", &wszComputerList, &nComputerIndex)) {
        // allocate
        pnhTemp=(NameHolder *)LocalAlloc(LPTR, sizeof(NameHolder));
        _JumpIfOutOfMemory(hr, error, pnhTemp);
        // link to tail of list
        *ppnhTail=pnhTemp;
        ppnhTail=&(pnhTemp->pnhNext);
        // remember the arg we found
        pnhTemp->bIsDomain=false;
        pnhTemp->wszName=wszComputerList;
        // mark arg as used
        MarkArgUsed(pca, nComputerIndex);
    }

    // check for domain
    while (FindArg(pca, L"domain", &wszDomainName, &nDomainIndex)) {
        // allocate
        pnhTemp=(NameHolder *)LocalAlloc(LPTR, sizeof(NameHolder));
        _JumpIfOutOfMemory(hr, error, pnhTemp);
        // link to tail of list
        *ppnhTail=pnhTemp;
        ppnhTail=&(pnhTemp->pnhNext);
        // remember the arg we found
        pnhTemp->bIsDomain=true;
        pnhTemp->wszName=wszDomainName;
        // mark arg as used
        MarkArgUsed(pca, nDomainIndex);
    }

    // put in the default domain if nothing specified
    if (NULL==pnhList) {
        // allocate
        pnhTemp=(NameHolder *)LocalAlloc(LPTR, sizeof(NameHolder));
        _JumpIfOutOfMemory(hr, error, pnhTemp);
        // link to tail of list
        *ppnhTail=pnhTemp;
        ppnhTail=&(pnhTemp->pnhNext);
        // add default
        pnhTemp->bIsDomain=true;
        pnhTemp->wszName=L"";
    }

    // successful
    hr=S_OK;
    *ppnhList=pnhList;
    pnhList=NULL;

error:
    while (NULL!=pnhList) {
        pnhTemp=pnhList;
        pnhList=pnhTemp->pnhNext;
        LocalFree(pnhTemp);
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT BuildComputerList(NameHolder * pnhList, ComputerRecord *** prgpcrList, unsigned int * pnComputers, unsigned int nTimeout)
{
    HRESULT hr;
    unsigned int nComputers=0;
    unsigned int nDcs;
    unsigned int nPrevComputers;
    unsigned int nIndex;

    // must be cleaned up
    ComputerRecord ** rgpcrList=NULL;
    DcInfo * rgdiDcList=NULL;
    ComputerRecord ** rgpcrPrev=NULL;


    // for each set of names in our list
    while (NULL!=pnhList) {

        if (pnhList->bIsDomain) {

            // get the dc list
            if (L'\0'==pnhList->wszName[0]) {
                LocalizedWPrintf2(IDS_W32TM_STATUS_GETTING_DC_LIST_FOR_DEFAULT_DOMAIN, L"\r");
            } else {
                LocalizedWPrintf2(IDS_W32TM_STATUS_GETTING_DC_LIST_FOR, L" %s...\r", pnhList->wszName);
            }
            DebugWPrintf0(L"\n");
            hr=GetDcList(pnhList->wszName, false, &rgdiDcList, &nDcs);
            ClearLine();
            if (FAILED(hr)) {
                LocalizedWPrintf2(IDS_W32TM_ERRORTIMEMONITOR_GETDCLIST_FAILED, L" 0x%08X.\n", hr);
            }
            _JumpIfError(hr, error, "GetDcList");

            // allow for previous list
            nPrevComputers=nComputers;
            rgpcrPrev=rgpcrList;
            rgpcrList=NULL;

            nComputers+=nDcs;

            // allocate memory
            rgpcrList=(ComputerRecord **)LocalAlloc(LPTR, nComputers*sizeof(ComputerRecord *));
            _JumpIfOutOfMemory(hr, error, rgpcrList);
            for (nIndex=nPrevComputers; nIndex<nComputers; nIndex++) {
                rgpcrList[nIndex]=(ComputerRecord *)LocalAlloc(LPTR, sizeof(ComputerRecord));
                _JumpIfOutOfMemory(hr, error, rgpcrList[nIndex]);
            }

            // move the computers from the previous list
            if (0!=nPrevComputers) {
                for (nIndex=0; nIndex<nPrevComputers; nIndex++) {
                    rgpcrList[nIndex]=rgpcrPrev[nIndex];
                }
                LocalFree(rgpcrPrev);
                rgpcrPrev=NULL;
            }

            // steal the data from the DC list
            for (nIndex=0; nIndex<nDcs; nIndex++) {
                rgpcrList[nIndex+nPrevComputers]->wszName=rgdiDcList[nIndex].wszDnsName;
                rgpcrList[nIndex+nPrevComputers]->nIpAddrs=rgdiDcList[nIndex].nIpAddresses;
                rgpcrList[nIndex+nPrevComputers]->rgiaLocalIpAddrs=rgdiDcList[nIndex].rgiaLocalIpAddresses;
                rgpcrList[nIndex+nPrevComputers]->rgiaRemoteIpAddrs=rgdiDcList[nIndex].rgiaRemoteIpAddresses;
                rgpcrList[nIndex+nPrevComputers]->bIsPdc=rgdiDcList[nIndex].bIsPdc;
                rgdiDcList[nIndex].wszDnsName=NULL;
                rgdiDcList[nIndex].rgiaLocalIpAddresses=NULL;
                rgdiDcList[nIndex].rgiaRemoteIpAddresses=NULL;
            }
        } else {

            // allow for previous list
            nPrevComputers=nComputers;
            rgpcrPrev=rgpcrList;
            rgpcrList=NULL;

            // count the number of computers in the computer list
            WCHAR * wszTravel=pnhList->wszName;
            nComputers=1;
            while (NULL!=(wszTravel=wcschr(wszTravel, L','))) {
                nComputers++;
                wszTravel++;
            }

            nComputers+=nPrevComputers;

            // allocate memory
            rgpcrList=(ComputerRecord **)LocalAlloc(LPTR, nComputers*sizeof(ComputerRecord *));
            _JumpIfOutOfMemory(hr, error, rgpcrList);
            for (nIndex=nPrevComputers; nIndex<nComputers; nIndex++) {
                rgpcrList[nIndex]=(ComputerRecord *)LocalAlloc(LPTR, sizeof(ComputerRecord));
                _JumpIfOutOfMemory(hr, error, rgpcrList[nIndex]);
            }

            // move the computers from the previous list
            if (0!=nPrevComputers) {
                for (nIndex=0; nIndex<nPrevComputers; nIndex++) {
                    rgpcrList[nIndex]=rgpcrPrev[nIndex];
                }
                LocalFree(rgpcrPrev);
                rgpcrPrev=NULL;
            }

            // fill in each record
            wszTravel=pnhList->wszName;
            for (nIndex=nPrevComputers; nIndex<nComputers; nIndex++) {
                WCHAR * wszComma=wcschr(wszTravel, L',');
                if (NULL!=wszComma) {
                    wszComma[0]=L'\0';
                }
                if (L'*'==wszTravel[0]) {
                    rgpcrList[nIndex]->bIsPdc=true;
                    wszTravel++;
                }
                rgpcrList[nIndex]->wszName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszTravel)+1));
                _JumpIfOutOfMemory(hr, error, rgpcrList[nIndex]->wszName);
                wcscpy(rgpcrList[nIndex]->wszName, wszTravel);
                wszTravel=wszComma+1;
            }
        }

        pnhList=pnhList->pnhNext;
    }

    // Fill in shared computer data:
    for (nIndex=0; nIndex<nComputers; nIndex++) { 
        rgpcrList[nIndex]->nTimeout = nTimeout; 
    }

    // success
    hr=S_OK;
    *pnComputers=nComputers;
    *prgpcrList=rgpcrList;
    rgpcrList=NULL;

error:
    if (NULL!=rgpcrPrev) {
        for (nIndex=0; nIndex<nPrevComputers; nIndex++) {
            FreeComputerRecord(rgpcrPrev[nIndex]);
        }
        LocalFree(rgpcrPrev);
    }
    if (NULL!=rgdiDcList) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&(rgdiDcList[nIndex]));
        }
        LocalFree(rgdiDcList);
    }
    if (NULL!=rgpcrList) {
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            FreeComputerRecord(rgpcrList[nIndex]);
        }
        LocalFree(rgpcrList);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeAlertRecords(AlertRecord * parList) {
    while (NULL!=parList) {
        AlertRecord * parTemp=parList;
        parList=parList->parNext;
        LocalFree(parTemp);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ParseCmdLineForAlerts(CmdArgs * pca, AlertRecord ** pparList) {
    HRESULT hr;
    WCHAR * rgwszAlertParams[10];
    WCHAR * wszAlert;
    unsigned int nAlertIndex;
    AlertRecord * parTemp;
    unsigned int nIndex;

    // must be cleaned up
    AlertRecord * parList=NULL;

    AlertRecord ** pparTail=&parList;

    // check for list of computers
    while (FindArg(pca, L"alert", &wszAlert, &nAlertIndex)) {

        // parse out comma separates params
        nIndex=0;
        rgwszAlertParams[0]=wszAlert;
        while (nIndex<10 && NULL!=(rgwszAlertParams[nIndex]=wcschr(rgwszAlertParams[nIndex], L','))) {
            rgwszAlertParams[nIndex][0]=L'\0';
            rgwszAlertParams[nIndex]++;
            rgwszAlertParams[nIndex+1]=rgwszAlertParams[nIndex];
            nIndex++;
        }
        
        // is it "maxspread"
        if (0==_wcsicmp(wszAlert, L"maxspread")) {
            // quick validy check on params
            if (NULL==rgwszAlertParams[0] || NULL==rgwszAlertParams[1] || NULL!=rgwszAlertParams[2]) {
                LocalizedWPrintf2(IDS_W32TM_ERRORPARAMETER_INCORRECT_NUMBER_FOR_ALERT, L" '%s'.\n", wszAlert);
                hr=E_INVALIDARG;
                _JumpError(hr, error, "command line parsing");
            }
            // allocate
            parTemp=(AlertRecord *)LocalAlloc(LPTR, sizeof(AlertRecord));
            _JumpIfOutOfMemory(hr, error, parTemp);
            // link to tail of list
            *pparTail=parTemp;
            pparTail=&(parTemp->parNext);
            // remember the args we found
            parTemp->eType=e_MaxSpreadAlert;
            parTemp->nParam1=wcstoul(rgwszAlertParams[0],NULL,0);
            parTemp->dwError=wcstoul(rgwszAlertParams[1],NULL,0);

        // is it "minservers
        } else if (0==_wcsicmp(wszAlert, L"minservers")) {
            // quick validy check on params
            if (NULL==rgwszAlertParams[0] || NULL==rgwszAlertParams[1] || NULL!=rgwszAlertParams[2]) {
                LocalizedWPrintf2(IDS_W32TM_ERRORPARAMETER_INCORRECT_NUMBER_FOR_ALERT, L" '%s'.\n", wszAlert);
                hr=E_INVALIDARG;
                _JumpError(hr, error, "command line parsing");
            }
            // allocate
            parTemp=(AlertRecord *)LocalAlloc(LPTR, sizeof(AlertRecord));
            _JumpIfOutOfMemory(hr, error, parTemp);
            // link to tail of list
            *pparTail=parTemp;
            pparTail=&(parTemp->parNext);
            // remember the args we found
            parTemp->eType=e_MinServersAlert;
            parTemp->nParam1=wcstoul(rgwszAlertParams[0],NULL,0);
            parTemp->dwError=wcstoul(rgwszAlertParams[1],NULL,0);
        } else {
            wprintf(L"Alert '%s' unknown.\n", wszAlert);
            hr=E_INVALIDARG;
            _JumpError(hr, error, "command line parsing");
        }

        if (!(parTemp->dwError&0x80000000)) { // check sign bit
            wprintf(L"Retval not negative for alert '%s'.\n", wszAlert);
            hr=E_INVALIDARG;
            _JumpError(hr, error, "command line parsing");
        }

        // mark arg as used
        MarkArgUsed(pca, nAlertIndex);

    } // <- end FindArg loop

    // success
    hr=S_OK;
    *pparList=parList;
    parList=NULL;

error:
    if (NULL!=parList) {
        FreeAlertRecords(parList);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CheckForAlerts(ComputerRecord ** rgpcrList, unsigned int nComputers, AlertRecord * parList) {
    HRESULT hr;
    unsigned int nIndex;
    
    for (; NULL!=parList; parList=parList->parNext) {

        if (e_MaxSpreadAlert==parList->eType) {

            // see how big the spread is
            NtTimeOffset toMax;
            NtTimeOffset toMin;
            bool bFirst=true;
            for (nIndex=0; nIndex<nComputers; nIndex++) {
                if (S_OK==rgpcrList[nIndex]->hrIPs && 
                    S_OK==rgpcrList[nIndex]->hrIcmp &&
                    S_OK==rgpcrList[nIndex]->hrNtp) {
                    if (bFirst) {
                        toMin=toMax=rgpcrList[nIndex]->toOffset;
                        bFirst=false;
                    } else {
                        if (toMin>rgpcrList[nIndex]->toOffset) {
                            toMin=rgpcrList[nIndex]->toOffset;
                        }
                        if (toMax<rgpcrList[nIndex]->toOffset) {
                            toMax=rgpcrList[nIndex]->toOffset;
                        }
                    }
                }
            }
            if (bFirst) {
                // no valid data!
                // ignore this alert
                continue;
            }
            unsigned __int64 qwSpread=(unsigned __int64)(toMax.qw-toMin.qw);
            if (qwSpread>((unsigned __int64)(parList->nParam1))*10000000) {
                DWORD dwFraction=(DWORD)(qwSpread%10000000);
                qwSpread/=10000000;
                wprintf(L"** ALERT: Current spread %I64u.%07us is greater than maximum\n"
                        L"          spread %us. Returning 0x%08X\n",
                        qwSpread, dwFraction, parList->nParam1, parList->dwError);
                hr=parList->dwError;
                _JumpError(hr, error, "maxspread alert evaluation");
            }

        } else if (e_MinServersAlert==parList->eType) {

            // see how many usable servers there are
            unsigned int nServers=0;
            for (nIndex=0; nIndex<nComputers; nIndex++) {
                if (S_OK==rgpcrList[nIndex]->hrIPs && 
                    S_OK==rgpcrList[nIndex]->hrIcmp &&
                    S_OK==rgpcrList[nIndex]->hrNtp) {
                    nServers++;
                }
            }
            if (nServers<parList->nParam1) {
                wprintf(L"** ALERT: Current usable servers (%u) is less than the minimum\n"
                        L"          usable servers (%u). Returning 0x%08X\n",
                        nServers, parList->nParam1, parList->dwError);
                hr=parList->dwError;
                _JumpError(hr, error, "e_MinServersAlert alert evaluation");
            }

        } else {
            // unknown alert type
            _MyAssert(false);
        }
    } // <- end alert checking loop

    hr=S_OK;
error:
    return hr;
}

//####################################################################
//--------------------------------------------------------------------
void PrintHelpTimeMonitor(void) {
    UINT idsText[] = { 
        IDS_W32TM_MONITORHELP_LINE1,  IDS_W32TM_MONITORHELP_LINE2,
        IDS_W32TM_MONITORHELP_LINE3,  IDS_W32TM_MONITORHELP_LINE4,
        IDS_W32TM_MONITORHELP_LINE5,  IDS_W32TM_MONITORHELP_LINE6,
        IDS_W32TM_MONITORHELP_LINE7,  IDS_W32TM_MONITORHELP_LINE8,
        IDS_W32TM_MONITORHELP_LINE9,  IDS_W32TM_MONITORHELP_LINE10,
        IDS_W32TM_MONITORHELP_LINE11, IDS_W32TM_MONITORHELP_LINE12,
        IDS_W32TM_MONITORHELP_LINE13, IDS_W32TM_MONITORHELP_LINE14,
        IDS_W32TM_MONITORHELP_LINE15, IDS_W32TM_MONITORHELP_LINE16,
        IDS_W32TM_MONITORHELP_LINE17, IDS_W32TM_MONITORHELP_LINE18,
        IDS_W32TM_MONITORHELP_LINE19, IDS_W32TM_MONITORHELP_LINE20,
        IDS_W32TM_MONITORHELP_LINE21, IDS_W32TM_MONITORHELP_LINE22,
        IDS_W32TM_MONITORHELP_LINE23, IDS_W32TM_MONITORHELP_LINE24,
        IDS_W32TM_MONITORHELP_LINE25
    };  

    for (int n=0; n<ARRAYSIZE(idsText); n++) {
        LocalizedWPrintf(idsText[n]); 
    }
}

//--------------------------------------------------------------------
HRESULT TimeMonitor(CmdArgs * pca) {
    HRESULT hr;

    unsigned int nComputers;
    unsigned int nIndex;
    unsigned int nThreads;
    unsigned int nTimeout; 
    ComputerRecord * pcrOffsetsFrom;
    WCHAR * wszNumThreads;
    WCHAR * wszTimeout; 
    ThreadSharedContext tscContext;

    // must be cleaned up
    ComputerRecord ** rgpcrList=NULL;
    NameHolder * pnhList=NULL;
    AlertRecord * parList=NULL;
    bool bSocketLayerOpen=false;
    ThreadContext * rgtcThreads=NULL;

    // init winsock
    hr=OpenSocketLayer();
    _JumpIfError(hr, error, "OpenSocketLayer");
    bSocketLayerOpen=true;

    //
    // parse command line
    //

    hr=ParseCmdLineForComputerNames(pca, &pnhList);
    _JumpIfError(hr, error, "ParseTimeMonCmdLineForComputerNames");


    hr=ParseCmdLineForAlerts(pca, &parList);
    _JumpIfError(hr, error, "ParseCmdLineForAlerts");

    // get number of threads to use
    if (FindArg(pca, L"threads", &wszNumThreads, &nThreads)) {
        MarkArgUsed(pca, nThreads);
        nThreads=wcstoul(wszNumThreads, NULL, 0);
        if (nThreads<1 || nThreads>50) {
            LocalizedWPrintf2(IDS_W32TM_ERRORTIMEMONITOR_INVALID_NUMBER_THREADS, L" (%u).\n", nThreads);
            hr=E_INVALIDARG;
            _JumpError(hr, error, "command line parsing");
        }
    } else {
        nThreads=3;
    }

    // get timeout to use for NTP ping
    if (FindArg(pca, L"timeout", &wszTimeout, &nTimeout)) { 
        MarkArgUsed(pca, nTimeout); 
        nTimeout=wcstoul(wszTimeout, NULL, 0); 
	nTimeout*=1000; 
    } else { 
        nTimeout = gc_dwTimeout; 
    }

    // all args should be parsed
    if (pca->nArgs!=pca->nNextArg) {
        LocalizedWPrintf(IDS_W32TM_ERRORGENERAL_UNEXPECTED_PARAMS);
        for(; pca->nArgs!=pca->nNextArg; pca->nNextArg++) {
            wprintf(L" %s", pca->rgwszArgs[pca->nNextArg]);
        }
        wprintf(L"\n");
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }

    //
    // build list of computers to analyze
    //

    hr=BuildComputerList(pnhList, &rgpcrList, &nComputers, nTimeout);
    _JumpIfError(hr, error, "BuildComputerList");


    //
    // Do Analysis
    //

    // analyze each of the computers
    if (nThreads>nComputers) {
        nThreads=nComputers;
    }
    if (nThreads<=1) {
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            ClearLine();
            wprintf(L"Analyzing %s (%u of %u)...\r", rgpcrList[nIndex]->wszName, nIndex+1, nComputers);
            DebugWPrintf0(L"\n");
            hr=AnalyzeComputer(rgpcrList[nIndex]);
            // errors are saved in the ComputerRecord and reported later
        }
    } else {

        // get ready to use threads
        DWORD dwThreadID;
        tscContext.nComputers=nComputers;
        tscContext.rgpcrList=rgpcrList;
        tscContext.nNextComputer=0;
        tscContext.nFinishedComputers=0;
        rgtcThreads=(ThreadContext *)LocalAlloc(LPTR, nThreads*sizeof(ThreadContext));
        _JumpIfOutOfMemory(hr, error, rgtcThreads);
        for (nIndex=0; nIndex<nThreads; nIndex++) {
            rgtcThreads[nIndex].ptsc=&tscContext;
            rgtcThreads[nIndex].nCurRecord=-1;
            rgtcThreads[nIndex].hThread=CreateThread(NULL, 0, AnalysisThread, &(rgtcThreads[nIndex]), 0, &dwThreadID);
            if (NULL==rgtcThreads[nIndex].hThread) {
                _JumpLastError(hr, error, "CreateThread");
            }
        }

        // wait for the threads to finish
        while (tscContext.nFinishedComputers<nComputers) {
            wprintf(L"Analyzing:");
            for (nIndex=0; nIndex<nThreads && nIndex<16; nIndex++) {
                unsigned int nCurRecord=rgtcThreads[nIndex].nCurRecord;
                if (nCurRecord<nComputers) {
                    wprintf(L" %2u", nCurRecord+1);
                } else {
                    wprintf(L" --");
                }
            }
            wprintf(L" (%u of %u)\r", tscContext.nFinishedComputers, nComputers);
            Sleep(250);
        }
    }

    // resolve referers
    for (nIndex=0; nIndex<nComputers; nIndex++) {
        ClearLine();
        wprintf(L"resolving referer %u.%u.%u.%u (%u of %u)...\r", 
            rgpcrList[nIndex]->refid.rgnIpAddr[0], 
            rgpcrList[nIndex]->refid.rgnIpAddr[1], 
            rgpcrList[nIndex]->refid.rgnIpAddr[2], 
            rgpcrList[nIndex]->refid.rgnIpAddr[3], 
            nIndex+1, nComputers);
        DebugWPrintf0(L"\n");
        hr=ResolveReferer(rgpcrList, nComputers, nIndex);
        _JumpIfError(hr, error, "ResolveReferer"); // only fatal errors are returned
    }


    ClearLine();
    
    // if there is a PDC, base the offsets from that
    pcrOffsetsFrom=NULL;
    for (nIndex=0; nIndex<nComputers; nIndex++) {
        if (rgpcrList[nIndex]->bIsPdc) {
            pcrOffsetsFrom=rgpcrList[nIndex];
            unsigned int nSubIndex;
            NtTimeOffset toPdc=rgpcrList[nIndex]->toOffset;
            for (nSubIndex=0; nSubIndex<nComputers; nSubIndex++) {
                rgpcrList[nSubIndex]->toOffset-=toPdc;
            }
            break;
        }
    }

    //
    // print the results
    //

    for (nIndex=0; nIndex<nComputers; nIndex++) {

        // print who we are looking at
        wprintf(L"%s%s", rgpcrList[nIndex]->wszName, rgpcrList[nIndex]->bIsPdc?L" *** PDC ***":L"");
        if (0==rgpcrList[nIndex]->nIpAddrs) {
            if (HRESULT_FROM_WIN32(WSAHOST_NOT_FOUND)==rgpcrList[nIndex]->hrIPs) {
                wprintf(L" [error WSAHOST_NOT_FOUND]\n");
            } else {
                wprintf(L" [error 0x%08X]\n", rgpcrList[nIndex]->hrIPs);
            }
            // don't bother with anything else if this doesn't work
            continue;
        } else {
            wprintf(L" [%u.%u.%u.%u]:\n", 
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b1,
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b2,
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b3,
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b4
                );
        }

        // display an ICMP ping
        wprintf(L"    ICMP: ");
        if (FAILED(rgpcrList[nIndex]->hrIcmp)) {
            if (HRESULT_FROM_WIN32(IP_REQ_TIMED_OUT)==rgpcrList[nIndex]->hrIcmp) {
                wprintf(L"error IP_REQ_TIMED_OUT - no response in %ums\n", gc_dwTimeout);
            } else {
                wprintf(L"error 0x%08X\n",rgpcrList[nIndex]->hrIcmp);
            }
	    
	    // NOTE: we could still have successfully done an NTP ping, even if an ICMP
	    //       ping fails, as some servers disable ICMP.  
        } else {
            wprintf(L"%ums delay.\n", rgpcrList[nIndex]->dwIcmpDelay);
        }

        // display an NTP ping
        wprintf(L"    NTP: ");
        if (FAILED(rgpcrList[nIndex]->hrNtp)) {
            if (HRESULT_FROM_WIN32(WSAECONNRESET)==rgpcrList[nIndex]->hrNtp) {
                wprintf(L"error WSAECONNRESET - no server listening on NTP port\n");
            } else if (HRESULT_FROM_WIN32(ERROR_TIMEOUT)==rgpcrList[nIndex]->hrNtp) {
		wprintf(L"error ERROR_TIMEOUT - no response from server in %ums\n", rgpcrList[nIndex]->nTimeout); 
            } else {
                wprintf(L"error 0x%08X\n" ,rgpcrList[nIndex]->hrNtp);
            }
        } else {

            // display the offset
            DWORD dwSecFraction;
            NtTimeOffset toLocalClockOffset=rgpcrList[nIndex]->toOffset;
            WCHAR * wszSign;

            if (toLocalClockOffset.qw<0) {
                toLocalClockOffset=-toLocalClockOffset;
                wszSign=L"-";
            } else {
                wszSign=L"+";
            }
            dwSecFraction=(DWORD)(toLocalClockOffset.qw%10000000);
            toLocalClockOffset/=10000000;
            wprintf(L"%s%I64u.%07us offset from %s\n", wszSign, toLocalClockOffset.qw, dwSecFraction,
                ((NULL!=pcrOffsetsFrom)?pcrOffsetsFrom->wszName:L"local clock"));

            // deterine and display the referer
            WCHAR * wszReferer;
            WCHAR wszRefName[7];
            if (0==rgpcrList[nIndex]->refid.value) {
                wszReferer=L"unspecified / unsynchronized";
            } else if (1>=rgpcrList[nIndex]->nStratum) {
                wszReferer=wszRefName;
                wszRefName[0]=L'\'';
                wszRefName[1]=rgpcrList[nIndex]->refid.rgnName[0];
                wszRefName[2]=rgpcrList[nIndex]->refid.rgnName[1];
                wszRefName[3]=rgpcrList[nIndex]->refid.rgnName[2];
                wszRefName[4]=rgpcrList[nIndex]->refid.rgnName[3];
                wszRefName[5]=L'\'';
                wszRefName[6]=0;
            } else if (NULL!=rgpcrList[nIndex]->pcrReferer) {
                wszReferer=rgpcrList[nIndex]->pcrReferer->wszName;
            } else if (NULL!=rgpcrList[nIndex]->wszReferer) {
                wszReferer=rgpcrList[nIndex]->wszReferer;
            } else {
                wszReferer=L"(unknown)";
            }
            wprintf(L"        RefID: %s [%u.%u.%u.%u]\n",
                wszReferer,
                rgpcrList[nIndex]->refid.rgnIpAddr[0],
                rgpcrList[nIndex]->refid.rgnIpAddr[1],
                rgpcrList[nIndex]->refid.rgnIpAddr[2],
                rgpcrList[nIndex]->refid.rgnIpAddr[3]
                );

            // BUGBUG: change not approved for beta2, checkin to beta 3:
            // wprintf(L"        Stratum: %d\n", rgpcrList[nIndex]->nStratum);
        }
    } // <- end ComputerRecord display loop

    hr=CheckForAlerts(rgpcrList, nComputers, parList);
    _JumpIfError(hr, error, "CheckForAlerts");


    hr=S_OK;
error:
    if (NULL!=rgpcrList) {
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            FreeComputerRecord(rgpcrList[nIndex]);
        }
        LocalFree(rgpcrList);
    }
    while (NULL!=pnhList) {
        NameHolder * pnhTemp=pnhList;
        pnhList=pnhList->pnhNext;
        LocalFree(pnhTemp);
    }
    if (true==bSocketLayerOpen) {
        CloseSocketLayer();
    }
    if (NULL!=parList) {
        FreeAlertRecords(parList);
    }

    if (NULL!=rgtcThreads) {
        // clean up threads
        tscContext.nNextComputer=tscContext.nComputers; // indicate to stop
        for (nIndex=0; nIndex<nThreads; nIndex++) {
            if (NULL!=rgtcThreads[nIndex].hThread) {
                WaitForSingleObject(rgtcThreads[nIndex].hThread, INFINITE);
                CloseHandle(rgtcThreads[nIndex].hThread);
            }
        }
        LocalFree(rgtcThreads);
    }

    if (S_OK!=hr) {
        wprintf(L"Exiting with error 0x%08X\n", hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\w32tm.cpp ===
//--------------------------------------------------------------------
// w32tm - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-8-99
//
// Command line utility
//

#include "pch.h" // precompiled headers


//####################################################################
// module private

HINSTANCE g_hThisModule = NULL;

//--------------------------------------------------------------------
MODULEPRIVATE void PrintHelp(void) {
    UINT idsText[] = { 
        IDS_W32TM_GENERALHELP_LINE1, 
        IDS_W32TM_GENERALHELP_LINE2, 
        IDS_W32TM_GENERALHELP_LINE3, 
        IDS_W32TM_GENERALHELP_LINE4, 
        IDS_W32TM_GENERALHELP_LINE5, 
        IDS_W32TM_GENERALHELP_LINE6, 
        IDS_W32TM_GENERALHELP_LINE7 
    };  

    for (int n=0; n<ARRAYSIZE(idsText); n++)
        LocalizedWPrintf(idsText[n]); 

    PrintHelpTimeMonitor();
    PrintHelpOtherCmds();
}

//####################################################################
// module public

//--------------------------------------------------------------------
// If we are running from the command line, business as usual.
// If we are running under SCM, this is our control dispatcher thread
//  and we need to hook up to the SCM asap.
extern "C" int WINAPI WinMain
(HINSTANCE   hinstExe, 
 HINSTANCE   hinstExePrev, 
 LPSTR       pszCommandLine,
 int         nCommandShow)
{
    g_hThisModule = hinstExe; 

    HRESULT hr;
    CmdArgs caArgs;
    int      nArgs     = 0; 
    WCHAR  **rgwszArgs = NULL; 

    hr = InitializeConsoleOutput(); 
    _JumpIfError(hr, error, "InitializeConsoleOutput"); 

    rgwszArgs = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    if (nArgs < 0 || NULL == rgwszArgs) {
        _JumpError(HRESULT_FROM_WIN32(GetLastError()), error, "GetCommandLineW"); 
    }

    // must be cleaned up
    DebugWPrintf0(L""); // force init of debug window

    // analyze args
    caArgs.nArgs=nArgs;
    caArgs.nNextArg=1;
    caArgs.rgwszArgs=rgwszArgs;

    // check for help command
    if (true==CheckNextArg(&caArgs, L"?", NULL) || caArgs.nNextArg==caArgs.nArgs) {
        PrintHelp();

    // check for service command
    } else if (true==CheckNextArg(&caArgs, L"service", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=RunAsService();
        _JumpIfError(hr, error, "RunAsService");

    // check for test command
    } else if (true==CheckNextArg(&caArgs, L"testservice", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=RunAsTestService();
        _JumpIfError(hr, error, "RunAsTestService");
       
    // check for monitor command
    } else if (true==CheckNextArg(&caArgs, L"monitor", NULL)) {
        hr=TimeMonitor(&caArgs);
        _JumpIfError(hr, error, "TimeMonitor");

    // check for register command
    } else if (true==CheckNextArg(&caArgs, L"register", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=RegisterDll();
        _JumpIfError(hr, error, "RegisterDll");

    // check for unregister command
    } else if (true==CheckNextArg(&caArgs, L"unregister", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=UnregisterDll();
        _JumpIfError(hr, error, "UnregisterDll");

    // check for sysexpr command
    } else if (true==CheckNextArg(&caArgs, L"sysexpr", NULL)) {
        hr=SysExpr(&caArgs);
        _JumpIfError(hr, error, "SysExpr");

    // check for ntte command
    } else if (true==CheckNextArg(&caArgs, L"ntte", NULL)) {
        hr=PrintNtte(&caArgs);
        _JumpIfError(hr, error, "PrintNtte");

    // check for ntte command
    } else if (true==CheckNextArg(&caArgs, L"ntpte", NULL)) {
        hr=PrintNtpte(&caArgs);
        _JumpIfError(hr, error, "PrintNtpte");

    // check for resync command
    } else if (true==CheckNextArg(&caArgs, L"resync", NULL)) {
        hr=ResyncCommand(&caArgs);
        _JumpIfError(hr, error, "ResyncCommand");

    // check for stripchart command
    } else if (true==CheckNextArg(&caArgs, L"stripchart", NULL)) {
        hr=Stripchart(&caArgs);
        _JumpIfError(hr, error, "Stripchart");

    // check for config command
    } else if (true==CheckNextArg(&caArgs, L"config", NULL)
        || true==CheckNextArg(&caArgs, L"configure", NULL)) {
        hr=Config(&caArgs);
        _JumpIfError(hr, error, "Config");

    // check for testif command
    } else if (true==CheckNextArg(&caArgs, L"testif", NULL)) {
        hr=TestInterface(&caArgs);
        _JumpIfError(hr, error, "TestInterface");

    // check for tz command
    } else if (true==CheckNextArg(&caArgs, L"tz", NULL)) {
        hr=ShowTimeZone(&caArgs);
        _JumpIfError(hr, error, "ShowTimeZone");

    // dump configuration information in registry:
    } else if (true==CheckNextArg(&caArgs, L"dumpreg", NULL)) { 
        hr=DumpReg(&caArgs);
        _JumpIfError(hr, error, "DumpReg");

    // command is unknown
    } else {
	DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_COMMAND_UNKNOWN, caArgs.rgwszArgs[caArgs.nNextArg]);
        hr=E_INVALIDARG;
        _JumpError(hr, error, "(command line processing)");
    }

    hr=S_OK;
error:
    DebugWPrintfTerminate();
    return hr;  
}

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp) { 
    throw SeException(u); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\w32tmrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w32tm.rc
//

#define IDD_SERVICECTRL                 101

#define IDC_STATUS                      1001
#define IDC_SC_STOP                     1002
#define IDC_SC_PAUSE                    1003
#define IDC_SC_CONTINUE                 1004
#define IDC_SC_INTERROGATE              1005
#define IDC_SC_PARAMCHANGE              1006
#define IDC_SC_NETBINDADD               1007
#define IDC_SC_NETBINDREMOVE            1008
#define IDC_SC_NETBINDENABLE            1009
#define IDC_SC_NETBINDDISABLE           1010
#define IDC_SC_DEVICEEVENT              1011
#define IDC_SC_HARDWAREPROFILECHANGE    1012
#define IDC_SC_POWEREVENT               1013
#define IDC_SC_SHUTDOWN                 1014

#define IDS_W32TM_GENERALHELP_LINE1                              1001 
#define IDS_W32TM_GENERALHELP_LINE2                              1002
#define IDS_W32TM_GENERALHELP_LINE3                              1003
#define IDS_W32TM_GENERALHELP_LINE4                              1004
#define IDS_W32TM_GENERALHELP_LINE5                              1005
#define IDS_W32TM_GENERALHELP_LINE6                              1006
#define IDS_W32TM_GENERALHELP_LINE7                              1007
#define IDS_W32TM_GENERALHELP_LINE8                              1008
#define IDS_W32TM_GENERALHELP_LINE9                              1009
#define IDS_W32TM_GENERALHELP_LINE10                             1010

#define IDS_W32TM_MONITORHELP_LINE1                              1101
#define IDS_W32TM_MONITORHELP_LINE2                              1102
#define IDS_W32TM_MONITORHELP_LINE3                              1103
#define IDS_W32TM_MONITORHELP_LINE4                              1104
#define IDS_W32TM_MONITORHELP_LINE5                              1105
#define IDS_W32TM_MONITORHELP_LINE6                              1106
#define IDS_W32TM_MONITORHELP_LINE7                              1107
#define IDS_W32TM_MONITORHELP_LINE8                              1108
#define IDS_W32TM_MONITORHELP_LINE9                              1109
#define IDS_W32TM_MONITORHELP_LINE10                             1110
#define IDS_W32TM_MONITORHELP_LINE11                             1111
#define IDS_W32TM_MONITORHELP_LINE12                             1112
#define IDS_W32TM_MONITORHELP_LINE13                             1113
#define IDS_W32TM_MONITORHELP_LINE14                             1114
#define IDS_W32TM_MONITORHELP_LINE15                             1115
#define IDS_W32TM_MONITORHELP_LINE16                             1116
#define IDS_W32TM_MONITORHELP_LINE17                             1117
#define IDS_W32TM_MONITORHELP_LINE18                             1118
#define IDS_W32TM_MONITORHELP_LINE19                             1119
#define IDS_W32TM_MONITORHELP_LINE20                             1120
#define IDS_W32TM_MONITORHELP_LINE21                             1121
#define IDS_W32TM_MONITORHELP_LINE22                             1122
#define IDS_W32TM_MONITORHELP_LINE23                             1123
#define IDS_W32TM_MONITORHELP_LINE24                             1124
#define IDS_W32TM_MONITORHELP_LINE25                             1125

#define IDS_W32TM_ERRORRESYNC_NO_TIME_DATA                       1300
#define IDS_W32TM_ERRORRESYNC_STALE_DATA                         1301
#define IDS_W32TM_ERRORRESYNC_SHUTTING_DOWN                      1302
#define IDS_W32TM_ERRORRESYNC_CHANGE_TOO_BIG                     1303
 
#define IDS_W32TM_ERRORGENERAL_COMMAND_SUCCESSFUL                1400
#define IDS_W32TM_ERRORGENERAL_ERROR_OCCURED                     1401
#define IDS_W32TM_ERRORGENERAL_INVALID_LOCALTIME                 1402
#define IDS_W32TM_ERRORGENERAL_MISSING_PARAM                     1403
#define IDS_W32TM_ERRORGENERAL_NOINTERFACE                       1404
#define IDS_W32TM_ERRORGENERAL_TOO_MANY_PARAMS                   1405
#define IDS_W32TM_ERRORGENERAL_UNEXPECTED_PARAMS                 1406

#define IDS_W32TM_ERRORPARAMETER_COMPUTER_MISSING                1500
#define IDS_W32TM_ERRORPARAMETER_INCORRECT_NUMBER_FOR_ALERT      1501
#define IDS_W32TM_ERRORPARAMETER_UNKNOWN_PARAMETER_SYNCFROMFLAGS 1502

#define IDS_W32TM_ERRORCONFIG_NO_CHANGE_SPECIFIED                1600
#define IDS_W32TM_ERRORDUMPREG_NO_SUBKEY_SPECIFIED               1601
#define IDS_W32TM_ERRORTIMEMONITOR_GETDCLIST_FAILED              1602
#define IDS_W32TM_ERRORTIMEMONITOR_INVALID_NUMBER_THREADS        1603

#define IDS_W32TM_ERRORTIMEZONE_INVALID                          1704

#define IDS_W32TM_STATUS_SENDING_RESYNC_TO                       1800
#define IDS_W32TM_STATUS_CALLING_GETNETLOGONBITS_ON              1801
#define IDS_W32TM_STATUS_CALLING_JOINCONFIG                      1802
#define IDS_W32TM_STATUS_CALLING_UNJOINCONFIG	                 1803
#define IDS_W32TM_STATUS_GETTING_DC_LIST_FOR_DEFAULT_DOMAIN      1804
#define IDS_W32TM_STATUS_GETTING_DC_LIST_FOR                     1805
#define IDS_W32TM_STATUS_REGISTER_SUCCESSFUL                     1806

#define IDS_W32TM_WARN_IGNORE_SOFT                               1900

// Do not declare resource IDs greater than this number: 
#define W32TM_RESOURCEID_MAX 7999

#define IDC_STATIC                        -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\activesocket.h ===
//////////////////////////////////////////////////////////////////////
// ActiveSocket.h : Declaration of CActiveSocket class which implements
// our WMI class SCW_ActiveSocket
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 5/15/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"
//#include "IPUtil.h"


/*

Class description
    
    Naming: 

        CActiveSocket stands for Active Socket.
    
    Base class: 
        
        CIPSecBase, because it is a class representing a WMI object - its WMI 
        class name is SCW_ActiveSocket
    
    Purpose of class:

        (1) SCW_ActiveSocket provides helper information for active sockets.
    
    Design:

        (1) it implements IIPSecObjectImpl.
    
    Use:

        (1) We probably will never directly use this class. All its use is driven by
            IIPSecObjectImpl.

*/

class ATL_NO_VTABLE CActiveSocket :
    public CIPSecBase
{
protected:
    CActiveSocket(){}
    virtual ~CActiveSocket () {}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

private:

    typedef enum _SCW_Protocol
    {
        PROTO_NONE  = 0,
        PROTO_TCP   = 1,
        PROTO_UDP   = 2,
        PROTO_IP    = 4,
        PROTO_ICMP  = 8,
    } SCW_Protocol, *PSCW_Protocol;

	HRESULT CreateWbemObjFromSocket (
        IN  SCW_Protocol        dwProtocol,
        IN  DWORD               dwPort,
        OUT IWbemClassObject ** ppObj
        );

    //
    // this is from netstat.c's same named function
    //

    HRESULT DoConnectionsWithOwner ();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\activesocket.cpp ===
// ActiveSocket.cpp: implementation for the WMI class SCW_ActiveSocket
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "ActiveSocket.h"
#include "NetSecProv.h"

//#include "IPUtil.h"



/*
Routine Description: 

Name:

    CActiveSocket::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

    Failure:


Notes:
    

*/
	
STDMETHODIMP 
CActiveSocket::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
	//
	// Make sure that WinSocket is initialized
	//

	//ULONG uResult = ::WSAStartup( 0x0101, &WsaData );
	//if ( Result == SOCKET_ERROR )
	//{
        //
        // $consider: we need to supply our custom error info
        //

    //    return WBEM_E_FAILED;
	//}

    //
    // get the filter name from the query
    // this key chain is not good because it doesn't have any info as what to look for
    // in the where clause
    //

    m_srpKeyChain.Release();    

    HRESULT hr = CNetSecProv::GetKeyChainFromQuery(pszQuery, g_pszProtocol, &m_srpKeyChain);
    if (FAILED(hr))
    {
        return hr;
    }

    CComVariant varProtocol;
    CComVariant varPort;

    //
    // we will tolerate those queries that have not filter name in the where clause, 
    // so ignore the return result
    //

    hr = m_srpKeyChain->GetKeyPropertyValue(g_pszProtocol, &varProtocol);

    if (SUCCEEDED(hr))
    {
        hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPort, &varPort);
    }

    //
    // 
    //

    //
    // since we are querying, it's ok to return not found
    //

    if (WBEM_E_NOT_FOUND == hr)
    {
        hr = WBEM_S_NO_MORE_DATA;
    }
    else if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CActiveSocket::DeleteInstance

Functionality:

    Not supported. SCW_ActiveSocket is a read only class.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx    - COM interface pointer supplied by WMI that we need to 
              pass around for various WMI API's.

    pSink   - COM interface pointer supplied by WMI that we use to 
              notify WMI with our result.

Return Value:

    WBEM_E_NOT_SUPPORTED


Notes:
    

*/

STDMETHODIMP 
CActiveSocket::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}



/*
Routine Description: 

Name:

    CActiveSocket::PutInstance

Functionality:

    Not supported. SCW_ActiveSocket is a read only class.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst   - The object.
    
    pCtx    - COM interface pointer supplied by WMI that we need to 
              pass around for various WMI API's.

    pSink   - COM interface pointer supplied by WMI that we use to 
              notify WMI with our result.

Return Value:

    WBEM_E_NOT_SUPPORTED


Notes:
    

*/

STDMETHODIMP 
CActiveSocket::PutInstance (
    IN IWbemClassObject     * pInst,
    IN IWbemContext         * pCtx,
    IN IWbemObjectSink      * pSink 
    )
{
    return WBEM_E_NOT_SUPPORTED;
}



/*
Routine Description: 

Name:

    CActiveSocket::PutInstance

Functionality:

    This is a single instance Get. The key chain must already have the key.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:
    
    pCtx    - COM interface pointer supplied by WMI that we need to 
              pass around for various WMI API's.

    pSink   - COM interface pointer supplied by WMI that we use to 
              notify WMI with our result.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes.

Notes:
    

*/

STDMETHODIMP 
CActiveSocket::GetInstance ( 
    IWbemContext    * pCtx,     // [in]
    IWbemObjectSink * pSink  // [in]
    )
{
	//
	// Make sure that WinSocket is initialized
	//

	//ULONG uResult = ::WSAStartup( 0x0101, &WsaData );
	//if ( Result == SOCKET_ERROR )
	//{
        //
        // $consider: we need to supply our custom error info
        //

    //    return WBEM_E_FAILED;
	//}

    CComVariant varProtocol;
    CComVariant varPort;

    //
    // we will tolerate those queries that have not filter name in the where clause, 
    // so ignore the return result
    //

    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszProtocol, &varProtocol);

    if (hr == WBEM_S_FALSE)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPort, &varPort);
    }

    if (hr == WBEM_S_FALSE)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    if (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromSocket((SCW_Protocol)(varProtocol.lVal), varPort.lVal, &srpObj);

        if (SUCCEEDED(hr))
        {
            hr = pSink->Indicate(1, &srpObj);
        }
    }
    
    //
    // since we try to find the single instance, it's an error not to find it.
    //

    
    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr; 
}



/*
Routine Description: 

Name:

    CActiveSocket::CreateWbemObjFromSocket

Functionality:

    Private helper.
    
    Given socket information, we will create an SCW_ActiveSocket instance representing the socket.

Virtual:
    
    No.

Arguments:

    Proto   - the protocol (one of the two key properties)

    Port    - the port number (the other key property)

    ppObj   - Receives the object interface pointer.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes.

Notes:
    

*/

HRESULT 
CActiveSocket::CreateWbemObjFromSocket (
    IN SCW_Protocol         Proto,
    IN DWORD                Port,
    OUT IWbemClassObject ** ppObj
    )
{
    if (ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppObj = NULL;

    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\authmm.cpp ===
// AuthMM.cpp: implementation for the WMI class Nsp_MMAuthSettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "IPSecBase.h"
#include "AuthMM.h"
#include "NetSecProv.h"

//extern CCriticalSection g_CS;

const DWORD DefMMAuthMethodFlag = 1;
const MM_AUTH_ENUM DefMMAuthMethod = IKE_SSPI;



/*
Routine Description: 

Name:

    CAuthMM::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

        (1) WBEM_NO_ERROR if instances are returned;

        (2) WBEM_S_NO_MORE_DATA if no instances are returned.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.

Notes:
    

*/

STDMETHODIMP 
CAuthMM::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    //
    // get the authentication method name from the query    
    // the given key chain doesn't know anything about where clause property
    // should be authenticaion, so make another one ourselves.
    //

    m_srpKeyChain.Release();    

    HRESULT hr = CNetSecProv::GetKeyChainFromQuery(pszQuery, g_pszAuthMethodID, &m_srpKeyChain);

    if (FAILED(hr))
    {
        return hr;
    }

    CComVariant var;

    //
    // if the name is missing, it will return WBEM_S_FALSE, which is fine with us
    // because we are querying.
    //

    hr = m_srpKeyChain->GetKeyPropertyValue(g_pszAuthMethodID, &var);

    LPCWSTR pszID = (var.vt == VT_BSTR) ? var.bstrVal : NULL;
    var.Clear();

    DWORD dwResumeHandle = 0;
    PMM_AUTH_METHODS pMMAuth = NULL;

    //
    // let's enumerate all MM auth methods
    //

    hr = ::FindMMAuthMethodsByID(pszID, &pMMAuth, &dwResumeHandle);

    while (SUCCEEDED(hr) && pMMAuth)
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromMMAuthMethods(pMMAuth, &srpObj);

        //
        // we created a method object, then give it to WMI
        //

        if (SUCCEEDED(hr))
        {
            pSink->Indicate(1, &srpObj);
        }
        
        ::SPDApiBufferFree(pMMAuth);
        pMMAuth = NULL;

        hr = ::FindMMAuthMethodsByID(pszID, &pMMAuth, &dwResumeHandle);
    }

    //
    // since we are querying, it's ok to return not found
    //

    if (WBEM_E_NOT_FOUND == hr)
    {
        hr = WBEM_S_NO_MORE_DATA;
    }
    else if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CAuthMM::DeleteInstance

Functionality:

    Will delete the wbem object (which causes to delete the IPSec main mode auth method).

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        Success code. Use SUCCEEDED(hr) to test.

    Failure:

        (1) WBEM_E_NOT_FOUND if the auth method can't be found. Depending on
            the context, this may not be an error

        (2) Other various errors indicated by the returned error codes.


Notes:
    

*/

STDMETHODIMP 
CAuthMM::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    CComVariant varID;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszAuthMethodID, &varID);

    if (FAILED(hr))
    {
        return hr;
    }
    else if (varID.vt != VT_BSTR || varID.bstrVal == NULL || varID.bstrVal[0] == L'\0')
    {
        return WBEM_E_NOT_FOUND;
    }

    DWORD dwResumeHandle = 0;

    PMM_AUTH_METHODS pMMAuth = NULL;

    hr = ::FindMMAuthMethodsByID(varID.bstrVal, &pMMAuth, &dwResumeHandle);

    if (SUCCEEDED(hr))
    {
        //
        // currently, we don't do rollback for delete
        //

        hr = DeleteAuthMethods(pMMAuth->gMMAuthID);

        ::SPDApiBufferFree(pMMAuth);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CAuthMM::PutInstance

Functionality:

    Put an authentication method into SPD whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CAuthMM::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pInst == NULL || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    bool bPreExist = false;

    //
    // for those policies that are created by ourselves (bPreExist == true)
    // we have our own way of allocating the buffer, need to free it in our corresponding way
    //

    PMM_AUTH_METHODS pMMAuth = NULL;
    HRESULT hr = GetMMAuthMethodsFromWbemObj(pInst, &pMMAuth, &bPreExist);

    //
    // if policy is successfully returned, then use it
    //

    if (SUCCEEDED(hr))
    {
        hr = AddAuthMethods(bPreExist, pMMAuth);

        if (SUCCEEDED(hr))
        {
            //
            // release the auth method structure
            //

            hr = OnAfterAddMMAuthMethods(pMMAuth->gMMAuthID);
        }
    }

    if (pMMAuth != NULL)
    {
        //
        // do something to allow this action to be rollback
        //

        FreeAuthMethods(&pMMAuth, bPreExist);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CAuthMM::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        (1) WBEM_E_NOT_FOUND if the auth method can't be found. Depending on
            the context, this may not be an error

        (2) Other various errors indicated by the returned error codes.


Notes:
    

*/

STDMETHODIMP 
CAuthMM::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    //
    // main mode auth method is uniquely identified by its ID
    //

    CComVariant varID;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszAuthMethodID, &varID);

    if (FAILED(hr))
    {
        return hr;
    }
    else if (varID.vt != VT_BSTR || varID.bstrVal == NULL || varID.bstrVal[0] == L'\0')
    {
        return WBEM_E_NOT_FOUND;
    }

    //
    // need to find the method by its ID. If found, then create a wbem object
    // to represent the method.
    //

    PMM_AUTH_METHODS pMMAuth = NULL;

    DWORD dwResumeHandle = 0;
    hr = ::FindMMAuthMethodsByID(varID.bstrVal, &pMMAuth, &dwResumeHandle);

    if (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromMMAuthMethods(pMMAuth, &srpObj);

        if (SUCCEEDED(hr))
        {
            hr = pSink->Indicate(1, &srpObj);
        }

        ::SPDApiBufferFree(pMMAuth);
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


/*
Routine Description: 

Name:

    CAuthMM::OnAfterAddMMAuthMethods

Functionality:

    Post-adding handler to be called after successfully added a main mode auth method to SPD.

Virtual:
    
    No.

Arguments:

    gMethodID   - The newly added method's guid.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: if rollback object is successfully created.

        (2) WBEM_S_FALSE: if there is no rollback guid information.

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:
    
    (1) Currently, we don't require a rollback object to be created for each 
        object added to SPD. Only a host that support rollback will deposit
        rollback guid information and only then can we create a rollback object.

*/

HRESULT 
CAuthMM::OnAfterAddMMAuthMethods (
    IN GUID gMethodID
    )
{
    //
    // will create an Nsp_RollbackMMAuth
    //

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = SpawnRollbackInstance(pszNspRollbackMMAuth, &srpObj);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // convert the guid into a string version
    //

    CComBSTR bstrMethodGuid;
    bstrMethodGuid.m_str = ::SysAllocStringLen(NULL, GUID_STRING_LENGTH);

    if (bstrMethodGuid.m_str)
    {
        int iRet = ::StringFromGUID2(gMethodID, bstrMethodGuid.m_str, GUID_STRING_LENGTH);
        if (iRet == 0)
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (SUCCEEDED(hr))
    {
        //
        // get the rollback guid
        //

        //::UpdateGlobals(m_srpNamespace, m_srpCtx);
        //if (g_varRollbackGuid.vt != VT_NULL && g_varRollbackGuid.vt != VT_EMPTY)
        //{
        //    hr = srpObj->Put(g_pszTokenGuid, 0, &g_varRollbackGuid, CIM_EMPTY);
        //}
        //else
        //{

        CComVariant varRollbackNull = pszEmptyRollbackToken;
        hr = srpObj->Put(g_pszTokenGuid, 0, &varRollbackNull, CIM_EMPTY);

        //}

        //
        // we can create a rollback object
        //

        if (SUCCEEDED(hr))
        {
            //
            // $undone:shawnwu, Currently, we only support rolling back added objects, not removed objects
            // Also, we don't cache the previous instance data yet.
            //

            VARIANT var;

            var.vt = VT_I4;
            var.lVal = Action_Add;
            hr = srpObj->Put(g_pszAction, 0, &var, CIM_EMPTY);

            if (SUCCEEDED(hr))
            {
                //
                // ******Warning******
                // don't clear this var. It's bstr will be released by bstrMethodGuid itself!
                //

                var.vt = VT_BSTR;
                var.bstrVal = bstrMethodGuid.m_str;
                hr = srpObj->Put(g_pszAuthMethodID, 0, &var, CIM_EMPTY);

                //
                // after this, I don't care what you do with the var any more.
                //

                var.vt = VT_EMPTY;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_srpNamespace->PutInstance(srpObj, WBEM_FLAG_CREATE_OR_UPDATE, m_srpCtx, NULL);
        if (SUCCEEDED(hr))
        {
            hr = WBEM_NO_ERROR;
        }
    }
    else if (SUCCEEDED(hr))
    {
        //
        // we don't have rollback guid
        //

        hr = WBEM_S_FALSE;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CAuthMM::CreateWbemObjFromMMAuthMethods

Functionality:

    Given a SPD's main mode auth method, we will create a wbem object representing it.

Virtual:
    
    No.

Arguments:

    pMMAuth     - The SPD's main mode auth method object.

    ppObj       - Receives the wbem object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:

*/

HRESULT 
CAuthMM::CreateWbemObjFromMMAuthMethods (
    IN  PMM_AUTH_METHODS     pMMAuth,
    OUT IWbemClassObject  ** ppObj
    )
{
    if (pMMAuth == NULL || ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppObj = NULL;

    HRESULT hr = SpawnObjectInstance(ppObj);

    if (SUCCEEDED(hr))
    {
        //
        // translate the ID guid into a bstr for the wbem object
        //

        CComVariant var;
        var.vt = VT_BSTR;
        var.bstrVal = ::SysAllocStringLen(NULL, Guid_Buffer_Size);

        if (var.bstrVal != NULL)
        {
            //
            // it's a key property, so, we must have this property set
            //

            if (::StringFromGUID2(pMMAuth->gMMAuthID, var.bstrVal, Guid_Buffer_Size) > 0)
            {
                hr = (*ppObj)->Put(g_pszAuthMethodID, 0, &var, CIM_EMPTY);
            }
            else
            {
                hr = WBEM_E_BUFFER_TOO_SMALL;
            }

            //
            // previous var is bstr, we have to clear it for re-use
            //

            var.Clear();

            var.vt = VT_I4;
            var.lVal = pMMAuth->dwNumAuthInfos;
            hr = (*ppObj)->Put(g_pszNumAuthInfos, 0, &var, CIM_EMPTY);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        //
        // need to fill up the wbem object's properties (those safearray)
        //

        if (SUCCEEDED(hr))
        {
            //
            // prepare to create the safearrays
            //

            CComVariant varMethod, varInfo;
            varMethod.vt    = VT_ARRAY | VT_I4;
            varInfo.vt      = VT_ARRAY | VT_BSTR;

            SAFEARRAYBOUND rgsabound[1];
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = pMMAuth->dwNumAuthInfos;

            varMethod.parray    = ::SafeArrayCreate(VT_I4, 1, rgsabound);
            varInfo.parray      = ::SafeArrayCreate(VT_BSTR, 1, rgsabound);

            //
            // for readability
            //

            PIPSEC_MM_AUTH_INFO pMMAuthInfo = pMMAuth->pAuthenticationInfo;

            long lIndecies[1];
            DWORD dwIndex;

            //
            // if arrays are successfully created, then, we are ready to populate the arrays
            //

            if (varMethod.parray == NULL || varInfo.parray == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                //
                // put all the method values into the array. If everything is fine, give the var to the wbem object
                //

                for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pMMAuth->dwNumAuthInfos; dwIndex++)
                {
                    //
                    // the element of the safearray to put
                    //

                    lIndecies[0] = dwIndex;

                    hr = ::SafeArrayPutElement(varMethod.parray, lIndecies, &(pMMAuthInfo[dwIndex].AuthMethod) );

                    if (SUCCEEDED(hr))
                    {
                        //
                        // now, we need to transform the pAuthInfo into a bstr
                        //

                        BSTR bstrInfo = NULL;
                        DWORD dwLength = 0;
                        switch (pMMAuthInfo[dwIndex].AuthMethod)
                        {
                        case IKE_PRESHARED_KEY:

                            //
                            // pAuthInfo is wchar array
                            //

                            dwLength = pMMAuthInfo[dwIndex].dwAuthInfoSize/sizeof(WCHAR);
                            bstrInfo = ::SysAllocStringLen(NULL, dwLength + 1);
                            if (bstrInfo)
                            {
                                //
                                // convert it to a bstr from the wchar array (no 0 terminator!)
                                //

                                ::wcsncpy(bstrInfo, (LPCWSTR)(pMMAuthInfo[dwIndex].pAuthInfo), dwLength);
                                bstrInfo[dwLength] = L'\0';
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                            break;
                        case IKE_RSA_SIGNATURE: 

                            //
                            // pAuthInfo is ansi char array
                            //

                            dwLength = pMMAuthInfo[dwIndex].dwAuthInfoSize;
                            bstrInfo = ::SysAllocStringLen(NULL, dwLength + 1);
                            if (bstrInfo)
                            {   
                                //
                                // convert it to a bstr from the ansi char array.
                                // remember, pAuthInfo has no 0 terminator!
                                //

                                for (DWORD d = 0; d < dwLength; d++)
                                {
                                    bstrInfo[d] = (WCHAR)(char)(pMMAuthInfo[dwIndex].pAuthInfo[d]);
                                }
                                bstrInfo[dwLength] = L'\0';
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                            break;
                        case IKE_SSPI:

                            //
                            // pAuthInfo must be NULL
                            //

                            break;
                        default:    
                            
                            //
                            // IPSec only supports these three values at this point
                            //

                            hr = WBEM_E_NOT_SUPPORTED;
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = ::SafeArrayPutElement(varInfo.parray, lIndecies, bstrInfo);
                            if (bstrInfo)
                            {
                                ::SysFreeString(bstrInfo);
                            }
                        }
                    }
                }

                //
                // every element has been successfully put
                //

                if (SUCCEEDED(hr))
                {
                    hr = (*ppObj)->Put(g_pszAuthMethod, 0, &varMethod, CIM_EMPTY);
                    hr = (*ppObj)->Put(g_pszAuthInfo, 0, &varInfo, CIM_EMPTY);
                }
            }
        }
    }

    //
    // we may have created the object, but some mid steps have failed,
    // so let's release the object.
    //

    if (FAILED(hr) && *ppObj != NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CAuthMM::GetMMAuthMethodsFromWbemObj

Functionality:

    Will try to get the MM Auth methods if such method already exists.
    Otherwise, we will create a new one.

Virtual:
    
    No.

Arguments:

    pInst       - The wbem object object.

    ppMMAuth    - Receives the main mode auth method.

    pbPreExist  - Receives the information whether this object memory is allocated by SPD or not.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:

*/

HRESULT 
CAuthMM::GetMMAuthMethodsFromWbemObj (
    IN  IWbemClassObject * pInst,
    OUT PMM_AUTH_METHODS * ppMMAuth,
    OUT bool             * pbPreExist
    )
{
    if (pInst == NULL || ppMMAuth == NULL || pbPreExist == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppMMAuth = NULL;
    *pbPreExist = false;

    //
    // we have to have method id.
    //

    CComVariant var;
    GUID gMMAuthID = GUID_NULL;

    HRESULT hr = pInst->Get(g_pszAuthMethodID, 0, &var, NULL, NULL);

    if (FAILED(hr) || var.vt != VT_BSTR || var.bstrVal == NULL)
    {
        hr = WBEM_E_INVALID_OBJECT;
    }
    else
    {
        hr = ::CLSIDFromString(var.bstrVal, &gMMAuthID);
    }

    //
    // Do we already have a method with this method ID?
    //

    if (SUCCEEDED(hr))
    {
        DWORD dwResumeHandle = 0;
        hr = ::FindMMAuthMethodsByID(var.bstrVal, ppMMAuth, &dwResumeHandle);
    }

    //
    // clear it for later use
    //

    var.Clear();  
    
    //
    // if we have a method already, 
    //

    if (SUCCEEDED(hr))
    {
        //
        // already exist
        //

        *pbPreExist = true;
    }
    else if (hr == WBEM_E_NOT_FOUND)
    {
        //
        // The method doesn't exist yet. We need to create one.
        // First, need to know the number of AuthMethodInfos, we must have this
        // to know how to allocate!
        //

        hr = pInst->Get(g_pszNumAuthInfos, 0, &var, NULL, NULL);
        if (SUCCEEDED(hr) && var.vt == VT_I4)
        {
            hr = AllocAuthMethods(var.lVal, ppMMAuth);
        }
        else if (SUCCEEDED(hr))
        {
            //
            // we don't want to overwrite other errors. That is why
            // we test it against success here!
            //

            hr = WBEM_E_INVALID_OBJECT;
        }

        if (SUCCEEDED(hr))
        {
            (*ppMMAuth)->gMMAuthID = gMMAuthID;
        }
    }

    //
    // put our properties (inside the wbem object) into the AUTH_INFOs
    //

    if (SUCCEEDED(hr))
    {
        //
        // set all elements of the pAuthenticationInfo array
        //

        CComVariant varMethods, varInfos;
        hr = pInst->Get(g_pszAuthMethod, 0, &varMethods, NULL, NULL);

        if (SUCCEEDED(hr))
        {
            hr = pInst->Get(g_pszAuthInfo, 0, &varInfos, NULL, NULL);
        }

        //
        // both must be arrays
        //

        if ( (varMethods.vt & VT_ARRAY) != VT_ARRAY || (varInfos.vt & VT_ARRAY) != VT_ARRAY)
        {
            hr = WBEM_E_INVALID_OBJECT;
        }

        if (SUCCEEDED(hr))
        {
            //
            // populate the method object using these arrays
            //

            hr = UpdateAuthInfos(pbPreExist, &varMethods,  &varInfos, *ppMMAuth);
        }
    }

    if (FAILED(hr) && *ppMMAuth != NULL)
    {
        //
        // FreeAuthMethods will reset ppMMAuth to NULL.
        //

        FreeAuthMethods(ppMMAuth, (*pbPreExist == false));
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


/*
Routine Description: 

Name:

    CAuthMM::UpdateAuthInfos

Functionality:

    Private helper: will populate the pAuthMethods's pAuthenticationInfo
    using the in parameters.

Virtual:
    
    No.

Arguments:

    pbPreExist      - The flag that indicates whether the method was allocated
                      by ourselves or not. This flag may be changed when this function
                      returns as a result of modifying IPSec allocated buffers.

    pVarMethods     - the AuthMethod member of each IPSEC_MM_AUTH_INFO.

    pVarSizes       - the dwAuthInfoSize member of each IPSEC_MM_AUTH_INFO.

    pAuthMethods    - What is to be poluated. It must contain the correct dwNumAuthInfos value
                      and valid and consistent pAuthenticationInfo.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:

    (1) pAuthMethods contains information as it is passed in. Don't blindly
        overwrite it. Only update those that are present by the other parameters
    
    (2) IPSec only support the following methods (pVarMethods' values):
        IKE_PRESHARED_KEY=1,IKE_RSA_SIGNATURE=3, IKE_SSPI=5
        This leaves IKE_DSS_SIGNATURE=2 and IKE_RSA_ENCRYPTION=4 not supported
        
        For IKE_PRESHARED_KEY, pAuthInfo is a wchar array, but no null terminator, dwAuthInfoSize
        is the byte size (not the count of wchars)

        For IKE_RSA_SIGNATURE, pAuthInfo is a blob of ASNI chars encoded issuer name of root certs.
        dwAuthInfoSize is the byte size (in this case, the same as the count of chars)
        
        For IKE_SSPI, pAuthInfo = NULL, dwAuthInfoSize = 0

    Warning: at this point, we don't support modifying existing methods.

*/

HRESULT 
CAuthMM::UpdateAuthInfos (
    IN OUT bool             * pbPreExist,
    IN     VARIANT          * pVarMethods,
    IN     VARIANT          * pVarInfos,
    IN OUT PMM_AUTH_METHODS   pAuthMethods
    )
{
    if (NULL == pbPreExist  || 
        NULL == pVarMethods || 
        NULL == pVarInfos   || 
        NULL == pAuthMethods )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // do a defensive checking: all these safearrays must have the same size
    //

    //
    // lower bound and upper bound of the array
    //

    long lLB, lUB;  
    HRESULT hr = ::CheckSafeArraySize(pVarMethods, pAuthMethods->dwNumAuthInfos, &lLB, &lUB);
    
    //
    // we don't need the bounds for methods, so OK to overwrite lLB and lUP for them
    //

    if (SUCCEEDED(hr))
    {
        hr = ::CheckSafeArraySize(pVarInfos, pAuthMethods->dwNumAuthInfos, &lLB, &lUB);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // if a brand new method
    //

    if (*pbPreExist == false)
    {
        //
        // need to create the get the entire array from the parameters
        //

        DWORD* pdwMethods = new DWORD[pAuthMethods->dwNumAuthInfos];
        if (pdwMethods == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            hr = ::GetDWORDSafeArrayElements(pVarMethods, pAuthMethods->dwNumAuthInfos, pdwMethods);
        }

        VARIANT varInfo;
		varInfo.vt = VT_BSTR;
        long lIndexes[1];

        //
        // Safearray's index is not necessarily 0-based. Pay attention to this.
        // For each method, we need to set the PIPSEC_MM_AUTH_INFO.
        //

        for (long l = lLB; SUCCEEDED(hr) && l <= lUB; l++)
        {
            lIndexes[0] = l;

            //
            // for IKE_PRESHARED_KEY=1, IKE_RSA_SIGNATURE=3, IKE_SSPI=5, set the appropriate blob pAuthInfo
            //

            if (pdwMethods[l - lLB] != IKE_PRESHARED_KEY && 
                pdwMethods[l - lLB] != IKE_RSA_SIGNATURE && 
                pdwMethods[l - lLB] != IKE_SSPI)
            {
                hr = WBEM_E_VALUE_OUT_OF_RANGE;
                break;
            }

            //
            // for readability
            //

            PIPSEC_MM_AUTH_INFO pTheInfo = &(pAuthMethods->pAuthenticationInfo[l - lLB]);

            //
            // set the AuthMethod
            //

            pTheInfo->AuthMethod = (MM_AUTH_ENUM)(pdwMethods[l - lLB]);

            //
            // IKE_SSPI, pAuthInfo must be NULL
            //

            if (IKE_SSPI == pTheInfo->AuthMethod)
            {
                pTheInfo->dwAuthInfoSize = 0;
                pTheInfo->pAuthInfo = NULL;
            }
            else
            {
                //
                // for other supported IKE (IKE_PRESHARED_KEY/IKE_RSA_SIGNATURE)
                // the pAuthInfo is a is a string (unicode/ansi).
                //

                hr = ::SafeArrayGetElement(pVarInfos->parray, lIndexes, &(varInfo.bstrVal));

                if (SUCCEEDED(hr) && varInfo.vt == VT_BSTR)
                {
                    hr = SetAuthInfo(pTheInfo, varInfo.bstrVal);
                }

			    ::VariantClear(&varInfo);
		        varInfo.vt = VT_BSTR;
            }

        }

        delete [] pdwMethods;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CAuthMM::UpdateAuthInfos

Functionality:

    Private helper: will populate the pAuthMethods's pAuthenticationInfo
    using the in parameters.

Virtual:
    
    No.

Arguments:

    pInfo       - Receives the IPSEC_MM_AUTH_INFO information from the bstr

    bstrInfo    - The string.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:

    (1) This function is made so complicated to the fact that IPSEC_MM_AUTH_INFO's
        pAuthInfo is a string (unicode or ansi), but it doesn't have contain the
        0 terminator. Pay close attention to that.

Warning: 

    (1) This only works for custom allocated auth info. Don't call this function
        with IPSec returned auth info. The reason for this limit is due the fact
        that we are not supporting modifying existing SPD objects at this time.

    (2) Only works for those two IKE enums that needs this conversion:
        IKE_PRESHARED_KEY and IKE_RSA_SIGNATURE
*/

HRESULT 
CAuthMM::SetAuthInfo (
    IN OUT PIPSEC_MM_AUTH_INFO  pInfo,
    IN     BSTR                 bstrInfo
    )
{
    if (pInfo == NULL || bstrInfo == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    DWORD dwLength = wcslen(bstrInfo);

    if (IKE_PRESHARED_KEY == pInfo->AuthMethod)
    {  
        //
        // IKE_PRESHARED_KEY, pAuthInfo will be an array of wchars (no 0 terminator)
        //

        //
        // size must not count the 0 terminator, pAuthInfo is an array of wchars
        //

        pInfo->dwAuthInfoSize = dwLength * sizeof(WCHAR);

        //
        // pAuthInfo must not have the 0 terminator
        //

        pInfo->pAuthInfo = new BYTE[pInfo->dwAuthInfoSize];

        if (pInfo->pAuthInfo)
        {
            ::wcsncpy((LPWSTR)(pInfo->pAuthInfo), bstrInfo, dwLength);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if (IKE_RSA_SIGNATURE == pInfo->AuthMethod)
    {
        //
        // IKE_RSA_SIGNATURE, pAuthInfo will be an array of ansi chars (no 0 terminator)
        //

        LPSTR pMultiBytes = NULL;

        //
        // convert bstr into an ansi char array
        //

        //
        // first, get the buffer size needed for the conversion
        //

        long lMultiByteSize = ::WideCharToMultiByte(CP_ACP, 
                                                    0, 
                                                    bstrInfo, 
                                                    dwLength,
                                                    pMultiBytes,
                                                    0, 
                                                    NULL, 
                                                    NULL);
        if (lMultiByteSize > 1)
        {
            //
            // convert to a temporary buffer because the conversion needs a null terminator
            // must release this memory
            //

            pMultiBytes = new char[lMultiByteSize];
            if (pMultiBytes)
            {
                lMultiByteSize = ::WideCharToMultiByte(CP_ACP, 
                                                        0, 
                                                        bstrInfo, 
                                                        dwLength,
                                                        pMultiBytes,
                                                        lMultiByteSize, 
                                                        NULL, NULL);

                //
                // lMultiByteSize includes the null terminator
                //

                if (lMultiByteSize > 1)
                {
                    //
                    // size must not count the 0 terminator, pAuthInfo is an array of ansi chars
                    //

                    pInfo->dwAuthInfoSize = lMultiByteSize;

                    //
                    // pAuthInfo must not have the 0 terminator
                    //

                    pInfo->pAuthInfo = new BYTE[lMultiByteSize];

                    if (pInfo->pAuthInfo)
                    {
                        //
                        // copy the bytes
                        //

                        memcpy(pInfo->pAuthInfo, pMultiBytes, lMultiByteSize);
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    //
                    // $undone:shawnwu, should get system error (GetLastErr)
                    //

                    hr = WBEM_E_FAILED;
                }

                delete [] pMultiBytes;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            //
            // $undone:shawnwu, should get system error (GetLastErr)
            //

            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        pInfo->pAuthInfo = NULL;
        hr = WBEM_E_NOT_SUPPORTED;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CAuthMM::AllocAuthMethods

Functionality:

    Private helper: will allocate heap memory for a MM_AUTH_METHODS with
    the given number of IPSEC_MM_AUTH_INFO.

Virtual:
    
    No.

Arguments:

    dwNumInfos  - The count of IPSEC_MM_AUTH_INFO of the MM_AUTH_METHODS.

    ppMMAuth    - Receives the heap allocated MM_AUTH_METHODS.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) WBEM_E_INVALID_PARAMETER: if ppMMAuth == NULL.

        (2) WBEM_E_OUT_OF_MEMORY.


Notes:

*/

HRESULT 
CAuthMM::AllocAuthMethods (
    IN DWORD              dwNumInfos,
    IN PMM_AUTH_METHODS * ppMMAuth
    )
{
    if (ppMMAuth == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    *ppMMAuth = new MM_AUTH_METHODS;

    if (*ppMMAuth != NULL)
    {
        //
        // Set these members to default.
        //

        (*ppMMAuth)->gMMAuthID = GUID_NULL;
        (*ppMMAuth)->dwFlags = DefMMAuthMethodFlag;

        //
        // We don't update this to the parameter value of dwNumInfos until we can allocate the IPSEC_MM_AUTH_INFO's
        //

        (*ppMMAuth)->dwNumAuthInfos = 0;

        if (dwNumInfos > 0)
        {
            //
            // IPSEC_MM_AUTH_INFO's are allocated by AllocAuthInfos function.
            //

            hr = AllocAuthInfos(dwNumInfos, &((*ppMMAuth)->pAuthenticationInfo));
            if (SUCCEEDED(hr))
            {
                (*ppMMAuth)->dwNumAuthInfos = dwNumInfos;
            }
        }
        else
        {
            (*ppMMAuth)->pAuthenticationInfo = NULL;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CAuthMM::AllocAuthInfos

Functionality:

    Private helper: will allocate heap buffer for the given count of IPSEC_MM_AUTH_INFO.

Virtual:
    
    No.

Arguments:

    dwNumInfos  - The count of IPSEC_MM_AUTH_INFO.

    ppAuthInfos - Receives the heap allocated PIPSEC_MM_AUTH_INFO.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) WBEM_E_INVALID_PARAMETER: if ppMMAuth == NULL.

        (2) WBEM_E_OUT_OF_MEMORY.


Notes:

*/

HRESULT 
CAuthMM::AllocAuthInfos (
    IN  DWORD                 dwNumInfos, 
    OUT PIPSEC_MM_AUTH_INFO * ppAuthInfos
    )
{
    if (ppAuthInfos == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;
    *ppAuthInfos = new IPSEC_MM_AUTH_INFO[dwNumInfos];

    if (*ppAuthInfos != NULL)
    {
        //
        // set its members to defaults
        //

        (*ppAuthInfos)->AuthMethod = DefMMAuthMethod;
        (*ppAuthInfos)->dwAuthInfoSize = 0;
        (*ppAuthInfos)->pAuthInfo = NULL;
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CAuthMM::FreeAuthMethods

Functionality:

    Private helper: will free memory allocated for the PMM_AUTH_METHODS.

Virtual:
    
    No.

Arguments:

    ppMMAuth     - The heap buffer for PMM_AUTH_METHODS. Will be set to NULL upon return.

    bCustomAlloc - Flag about who allocated the buffer. bCustomAlloc == true if we allocate it
                   and bCustomAlloc == false if SPD allocated it.

Return Value:

    None.

Notes:

    Don't use delete to free heap allocated MM_AUTH_METHODS. Our allocation method is totally
    different from SPD's and SPD may change its allocation schema in the future. 

*/

void 
CAuthMM::FreeAuthMethods (
    IN OUT PMM_AUTH_METHODS * ppMMAuth, 
    IN     bool               bCustomAlloc
    )
{
    if (ppMMAuth == NULL || *ppMMAuth == NULL)
    {
        return;
    }

    if (bCustomAlloc == false)
    {
        ::SPDApiBufferFree(*ppMMAuth);
    }
    else
    {
        //
        // we allocated IPSEC_MM_AUTH_INFO for pAuthenticationInfo in the standard C++ embedding
        // pointer's allocation, i.e., we don't allocated a flat buffer. Instead, the pointers inside
        // IPSEC_MM_AUTH_INFO are separately allocated.
        //

        FreeAuthInfos( (*ppMMAuth)->dwNumAuthInfos, &((*ppMMAuth)->pAuthenticationInfo) );
        delete *ppMMAuth;
    }
    
    *ppMMAuth = NULL;
}


/*
Routine Description: 

Name:

    CAuthMM::FreeAuthInfos

Functionality:

    Private helper: will free memory allocated for the array of IPSEC_MM_AUTH_INFO.

Virtual:
    
    No.

Arguments:

    dwNumInfos   - The number of IPSEC_MM_AUTH_INFO of the given ppAuthInfos. Since ppAuthInfos
                   is an array, we need this count to know the count of the array.

    ppAuthInfos  - The array of IPSEC_MM_AUTH_INFO to free. Will be set to NULL upon return.

Return Value:

    None.

Notes:

    Use this method only to free those authentication methods allocated by our
    own allocation method AllocAuthMethods. For SPD allocated IPSEC_MM_AUTH_INFO's,
    don't use this function. Instead, use SPD's SPDApiBufferFree to free the entire
    buffer and you should never need to worry about IPSEC_MM_AUTH_INFO.

*/

void 
CAuthMM::FreeAuthInfos (
    IN      DWORD                 dwNumInfos,
    IN OUT  PIPSEC_MM_AUTH_INFO * ppAuthInfos
    )
{
    if (ppAuthInfos == NULL || *ppAuthInfos == NULL)
    {
        return;
    }

    for (DWORD dwIndex = 0; dwIndex < dwNumInfos; ++dwIndex)
    {
        //
        // this is LPBYTE, an array
        //

        delete [] (*ppAuthInfos)[dwIndex].pAuthInfo;
    }

    delete [] *ppAuthInfos;
    *ppAuthInfos = NULL;
}


/*
Routine Description: 

Name:

    CAuthMM::Rollback

Functionality:

    Static function to rollback those main mode auth methods added by us with
    the given token.

Virtual:
    
    No.

Arguments:

    pNamespace        - The namespace for ourselves.

    pszRollbackToken  - The token used to record our the action when we add
                        the methods.

    bClearAll         - Flag whether we should clear all auth methods. If it's true,
                        then we will delete all main mode auth methods regardless whether they
                        are added by us or not. This is a dangerous flag.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: rollback objects are found and they are deleted.

        (2) WBEM_S_FALSE: no rollback objects are found.

    Failure:

        Various error codes indicating the cause of the failure.


Notes:

    We will continue the deletion even if some failure happens. That failure will be
    returned, though.

    $undone:shawnwu, should we really support ClearAll?

*/

HRESULT 
CAuthMM::Rollback (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszRollbackToken,
    IN bool               bClearAll
    )
{
    if (pNamespace == NULL || pszRollbackToken == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //if (bClearAll)
    //{
    //    return ClearAllAuthMethods(pNamespace);
    //}

    //
    // we need to find all those main mode auth methods' rollback objects with matching token
    //

    CComPtr<IEnumWbemClassObject> srpEnum;
    HRESULT hr = ::GetClassEnum(pNamespace, pszNspRollbackMMAuth, &srpEnum);

    //
    // go through all found classes. srpEnum->Next will return WBEM_S_FALSE if instance
    // is not found.
    //

    CComPtr<IWbemClassObject> srpObj;
    ULONG nEnum = 0;
    hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);

    bool bHasInst = (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj != NULL);

    DWORD dwStatus;
    HRESULT hrError = WBEM_NO_ERROR;

    while (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj)
    {
        //
        // See if this obj has our matching token (guid).
        //
        // I tried a query with the given token as part of the where clause.
        // that query doesn't return the properly screened objects. That might be a limitation
        // of non-dynamic classes of WMI.
        //

        CComVariant varTokenGuid;
        hr = srpObj->Get(g_pszTokenGuid, 0, &varTokenGuid, NULL, NULL);

        //
        // if we successfully got the token guid from the object, and
        // if that token matches (case-insensitively) with our given token, then this is
        // the right object we can use to delete a main mode auth method.
        //

        if (SUCCEEDED(hr) && 
            varTokenGuid.vt         == VT_BSTR && 
            varTokenGuid.bstrVal    != NULL &&
            (_wcsicmp(pszRollbackToken, pszRollbackAll) == 0 || _wcsicmp(pszRollbackToken, varTokenGuid.bstrVal) == 0 )
            )
        {
            CComVariant varAuthMethodID;

            //
            // Ask SPD to delete the main mode auth method using the method's ID.
            //

            hr = srpObj->Get(g_pszAuthMethodID,  0, &varAuthMethodID, NULL, NULL);

            GUID guidAuthMethodGuid = GUID_NULL;
            if (SUCCEEDED(hr) && varAuthMethodID.vt == VT_BSTR)
            {
                ::CLSIDFromString(varAuthMethodID.bstrVal, &guidAuthMethodGuid);
            }

            if (SUCCEEDED(hr))
            {
                hr = DeleteAuthMethods(guidAuthMethodGuid);
            }

            //
            // Clear the rollback object itself if the main mode method has been deleted.
            //

            if (SUCCEEDED(hr))
            {
                CComVariant varPath;

                if (SUCCEEDED(srpObj->Get(L"__RelPath", 0, &varPath, NULL, NULL)) && varPath.vt == VT_BSTR)
                {
                    hr = pNamespace->DeleteInstance(varPath.bstrVal, 0, NULL, NULL);

                }
            }

            //
            // we are tracking the first error
            //

            if (FAILED(hr) && SUCCEEDED(hrError))
            {
                hrError = hr;
            }
        }

        //
        // ready it for re-use
        //

        srpObj.Release();
        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
    }

    if (!bHasInst)
    {
        return WBEM_S_FALSE;
    }
    else
    {
        //
        // any failure code will be returned regardless of the final hr
        //

        if (FAILED(hrError))
        {
            return hrError;
        }
        else
        {
            return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
        }
    }
}


/*
Routine Description: 

Name:

    CAuthMM::ClearAllAuthMethods

Functionality:

    Static function to delete all auth methods in SPD. This is a very dangerous action!

Virtual:
    
    No.

Arguments:

    pNamespace  - The namespace for ourselves.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        Various error codes indicating the cause of the failure.


Notes:

    We will continue the deletion even if some failure happens. That failure will be
    returned, though.

    $undone:shawnwu, should we really support this?

*/

HRESULT 
CAuthMM::ClearAllAuthMethods (
    IN IWbemServices * pNamespace
    )
{
    DWORD dwResumeHandle = 0;
    DWORD dwReturned = 0;
    DWORD dwStatus;

    PMM_AUTH_METHODS *ppMMAuthMethods = NULL;

    HRESULT hr = WBEM_NO_ERROR;
    HRESULT hrError = WBEM_NO_ERROR;

    //
    // get each main mode auth method's ID, which is what deletion needs.
    //

    dwStatus = ::EnumMMAuthMethods(NULL, ppMMAuthMethods, 1, &dwReturned, &dwResumeHandle);

    while (ERROR_SUCCESS == dwStatus && dwReturned > 0)
    {
        hr = DeleteAuthMethods((*ppMMAuthMethods)->gMMAuthID);
        
        //
        // we will track the first error
        //

        if (FAILED(hr) && SUCCEEDED(hrError))
        {
            hrError = hr;
        }

        FreeAuthMethods(ppMMAuthMethods, true);
        *ppMMAuthMethods = NULL;

        dwReturned = 0;
        dwStatus = ::EnumMMAuthMethods(NULL, ppMMAuthMethods, 1, &dwReturned, &dwResumeHandle);
    }

    //
    // Let's clear up all past action information for mm methods rollback objects deposited in the WMI depository
    //

    hr = ::DeleteRollbackObjects(pNamespace, pszNspRollbackMMAuth);

    if (FAILED(hr) && SUCCEEDED(hrError))
    {
        hrError = hr;
    }

    return SUCCEEDED(hrError) ? WBEM_NO_ERROR : hrError;
}


/*
Routine Description: 

Name:

    CAuthMM::AddAuthMethods

Functionality:

    Add the given main mode auth method.

Virtual:
    
    No.

Arguments:

    bPreExist - Flag whether the main mode auth method already exists in SPD

    pMMAuth   - The main mode method to add.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        WBEM_E_FAILED.

Notes:

*/

HRESULT 
CAuthMM::AddAuthMethods (
    IN bool             bPreExist,
    IN PMM_AUTH_METHODS pMMAuth
    )
{
    DWORD dwResult;

    if (!bPreExist)
    {
        dwResult = ::AddMMAuthMethods(NULL, 1, pMMAuth);
    }
    else
    {
        dwResult = ::SetMMAuthMethods(NULL, pMMAuth->gMMAuthID, pMMAuth);
    }

    //
    // $undone:shawnwu, need better error code for failures.
    //

    return (dwResult == ERROR_SUCCESS) ? WBEM_NO_ERROR : WBEM_E_FAILED;
}


/*
Routine Description: 

Name:

    CAuthMM::AddAuthMethods

Functionality:

    Add the given main mode auth method.

Virtual:
    
    No.

Arguments:

    pMMAuth   - The main mode method to add.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        WBEM_E_VETO_DELETE.

Notes:

*/

HRESULT 
CAuthMM::DeleteAuthMethods (
    IN GUID gMMAuthID
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    DWORD dwResult = ::DeleteMMAuthMethods(NULL, gMMAuthID);

    if (ERROR_SUCCESS != dwResult)
    {
        hr = WBEM_E_VETO_DELETE;
    }

    //
    // $undone:shawnwu, need better error code for failures.
    //

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\authmm.h ===
//////////////////////////////////////////////////////////////////////
// AuthMM.h : Declaration of CAuthMM class which implements
// our WMI class Nsp_MMAuthSettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"


/*

Class description
    
    Naming: 

        CAuthMM stands for Main Mode Authentication Method.
    
    Base class: 
        
        CIPSecBase, because it is a class representing a WMI object - its WMI 
        class name is Nsp_MMAuthSettings
    
    Purpose of class:

        (1) Nsp_MMAuthSettings is the WMI class for SPD's MM_AUTH_METHODS.
    
    Design:

        (1) it implements IIPSecObjectImpl.

        (2) Since there is one authentication method class, we don't need another layer
            of common class. As a result, this class is much bigger so that it can handle
            (2.1) Allocation/Deallocation.
            (2.2) Rollback support.
            (2.3) All creation/remove semantics.

    
    Use:

        (1) Other than rollback, we probably will never directly use this class. 
            All its use is driven by IIPSecObjectImpl.

        (2) When you need to rollback all previously added main mode authentication
            methods, just call Rollback.


*/

class ATL_NO_VTABLE CAuthMM :
    public CIPSecBase
{
protected:
    CAuthMM(){}
    virtual ~CAuthMM(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );


    static 
    HRESULT Rollback(
        IN IWbemServices    * pNamespace,
        IN LPCWSTR            pszRollbackToken,
        IN bool               bClearAll
        );

private:

    static 
    HRESULT ClearAllAuthMethods (
        IN IWbemServices    * pNamespace
        );

    HRESULT CreateWbemObjFromMMAuthMethods (
        IN  PMM_AUTH_METHODS    pMMAuth,
        OUT IWbemClassObject ** ppObj
        );

    HRESULT GetMMAuthMethodsFromWbemObj (
        IN  IWbemClassObject  * pInst,
        OUT PMM_AUTH_METHODS  * ppMMAuth,
        OUT bool              * pbPreExist
        );

    HRESULT UpdateAuthInfos (
        IN OUT bool             * pPreExist,
        IN     VARIANT          * pVarMethods,
        IN     VARIANT          * pVarInfos,
        IN OUT PMM_AUTH_METHODS   pAuthMethods
        );

    HRESULT SetAuthInfo (
        IN OUT PIPSEC_MM_AUTH_INFO  pInfo,
        IN     BSTR                 bstrInfo
        );

    static 
    HRESULT AllocAuthMethods(
        IN  DWORD              dwNumInfos,
        OUT PMM_AUTH_METHODS * ppMMAuth
        );

    static 
    HRESULT AllocAuthInfos(
        IN  DWORD                 dwNumInfos,
        OUT PIPSEC_MM_AUTH_INFO * ppAuthInfos
        );

    static 
    void FreeAuthMethods(
        IN OUT PMM_AUTH_METHODS * ppMMAuth,
        IN     bool               bPreExist
        );

    static 
    void FreeAuthInfos(
        IN      DWORD                  dwNumInfos,
        IN OUT  PIPSEC_MM_AUTH_INFO  * ppAuthInfos
        );

    static 
    HRESULT AddAuthMethods(
        IN bool             bPreExist,
        IN PMM_AUTH_METHODS pMMAuth
        );

    static 
    HRESULT DeleteAuthMethods(
        IN GUID     gMMAuthID
        );

    HRESULT OnAfterAddMMAuthMethods(
        IN GUID gMethodID
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\config.h ===
//////////////////////////////////////////////////////////////////////
// Config.h : Declaration of CIPSecConfig class which implements our WMI class
// Nsp_IPConfigSettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"


/*

Class description
    
    Naming: 

        CIPSecConfig stands for IPSec Configuration Settings.
    
    Base class: 
        
        CIPSecBase, because it is a class representing a WMI object - its WMI 
        class name is Nsp_IPConfigSettings
    
    Purpose of class:

        (1) not clear at this point.
    
    Design:

        (1) Not implemented at this time.

    
    Use:


*/

class ATL_NO_VTABLE CIPSecConfig :
    public CIPSecBase
{

protected:
    CIPSecConfig(){}
    virtual ~CIPSecConfig(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );


private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\config.cpp ===
// Config.cpp: implementation for the WMI class Nsp_IPConfigSettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "Config.h"


/*
Routine Description: 

Name:

    CIPSecConfig::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

    Failure:


Notes:
    

*/

STDMETHODIMP 
CIPSecConfig::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    return WBEM_E_NOT_SUPPORTED;
}


/*
Routine Description: 

Name:

    CIPSecConfig::DeleteInstance

Functionality:

    Will delete the wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    WBEM_E_NOT_SUPPORTED

Notes:
    

*/

STDMETHODIMP 
CIPSecConfig::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}



/*
Routine Description: 

Name:

    CIPSecConfig::PutInstance

Functionality:

    Put a configuration object whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    
    This object is not fully defined at this point. No implementation yet.

*/

STDMETHODIMP 
CIPSecConfig::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}


/*
Routine Description: 

Name:

    CIPSecConfig::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    WBEM_E_NOT_SUPPORTED


Notes:
    

*/

STDMETHODIMP 
CIPSecConfig::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\exceptionport.h ===
//////////////////////////////////////////////////////////////////////
// ExceptionPort.h : Declaration of CExceptionPort class which implements
// our WMI class Nsp_ExceptionPorts
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"


/*

Class description
    
    Naming: 

        CExceptionPort stands for Exception Ports.
    
    Base class: 
        
        (1) CComObjectRootEx for threading model and IUnknown.

        (2) IIPSecObjectImpl which implements the common interface for all C++ classes
            representing WMI classes.

        (3) CIPSecBase, because it is a class representing a WMI object - its WMI 
            class name is Nsp_ExceptionPorts
    
    Purpose of class:

        (1) Not known at this point.
    
    Design:

        (1) Not implemented at this time.

    
    Use:

  */


class ATL_NO_VTABLE CExceptionPort :
    public CIPSecBase
{
protected:
    CExceptionPort(){}
    virtual ~CExceptionPort(){}

public:


    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\exceptionport.cpp ===
// ExceptionPort.cpp: implementation for the WMI class Nsp_ExceptionPorts
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "ExceptionPort.h"



/*
Routine Description: 

Name:

    CExceptionPort::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

    Failure:


Notes:
    

*/

STDMETHODIMP 
CExceptionPort::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    return WBEM_E_NOT_SUPPORTED;
}


/*
Routine Description: 

Name:

    CExceptionPort::DeleteInstance

Functionality:

    Will delete the wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:


Notes:
    

*/

STDMETHODIMP 
CExceptionPort::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}



/*
Routine Description: 

Name:

    CExceptionPort::PutInstance

Functionality:

    Put an exception port object whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CExceptionPort::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}


/*
Routine Description: 

Name:

    CExceptionPort::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    WBEM_E_NOT_SUPPORTED


Notes:
    

*/

STDMETHODIMP 
CExceptionPort::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filter.cpp ===
// Filter.cpp: implementation of the base class for various filter classes
// of the security WMI provider for Network Security Provider
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "NetSecProv.h"
#include "FilterTr.h"
#include "FilterTun.h"
#include "FilterMM.h"

//extern CCriticalSection g_CS;

//-----------------------------------------------------------------------------
// CIPSecFilter is another abstract class that implements our WMI class called
// Nsp_FilterSettings. All this abstract class does is to declare some
// common members.
//-----------------------------------------------------------------------------


/*
Routine Description: 

Name:

    CIPSecFilter::MakeULongIPAddr

Functionality:

    A helper to make ULONG valued IP address out of a string valued IP address.

Virtual:
    
    No.

Arguments:

    pszAddr - The string format IP address.

    pulAddr - Receives the IP address in ULONG.

Return Value:

    Success:    WBEM_NO_ERROR

    Failure:

        (1) WBEM_E_INVALID_PARAMETER if pulAddr == NULL or pszAddr is NULL or empty string.

        (2) WBEM_E_INVALID_SYNTAX if the string is not representing a valid IP address.

Notes:

*/

HRESULT 
CIPSecFilter::MakeULongIPAddr (
    IN  LPCWSTR pszAddr,
    OUT ULONG* pulAddr
    )const
{
    if (pulAddr == NULL || pszAddr == NULL || *pszAddr == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    LPCWSTR pszCur = pszAddr;
    *pulAddr = _wtol(pszCur);

    //
    // move to the next section
    //

    while (*pszCur != L'\0' && *pszCur != L'.')
    {
        ++pszCur;
    }

    if (*pszCur != L'.')
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    //
    // skip the period
    //

    ++pszCur;

    //
    // shifting the current section to the result.
    //

    DWORD dwShiftBits = 8;
    *pulAddr += (_wtol(pszCur) << dwShiftBits);

    //
    // move to the next section
    //

    while (*pszCur != L'\0' && *pszCur != L'.')
    {
        ++pszCur;
    }

    if (*pszCur != L'.')
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    //
    // skip the period
    //

    ++pszCur;
    dwShiftBits += 8;

    //
    // shifting the current section to the result.
    //

    *pulAddr += (_wtol(pszCur) << dwShiftBits);

    //
    // move to the next section
    //

    while (*pszCur != L'\0' && *pszCur != L'.')
    {
        ++pszCur;
    }

    if (*pszCur != L'.')
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    //
    // skip the period
    //

    ++pszCur;
    dwShiftBits += 8;

    //
    // shifting the current section to the result.
    //

    *pulAddr += (_wtol(pszCur) << dwShiftBits);

    return WBEM_NO_ERROR;
}


/*
Routine Description: 

Name:

    CIPSecFilter::MakeStringIPAddr

Functionality:

    A helper to make a string valued IP address out of an ULONG valued IP address.

    The reserve of MakeULongIPAddr.

Virtual:
    
    No.

Arguments:

    pulAddr     - Receives the IP address in ULONG.

    pbstrAddr   - Receives the string format IP address.

Return Value:

    Success:    WBEM_NO_ERROR

    Failure:

        (1) WBEM_E_INVALID_PARAMETER if pulAddr == NULL or pbstrAddr is NULL or empty string.

        (2) WBEM_E_OUT_OF_MEMORY.

Notes:

*/

HRESULT 
CIPSecFilter::MakeStringIPAddr (
    IN  ULONG ulAddr,
    OUT BSTR* pbstrAddr
    )const
{
    if (pbstrAddr == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrAddr = ::SysAllocStringLen(NULL, IP_ADDR_LENGTH + 1);
    if (*pbstrAddr == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // now, make the address in string representation
    //
    
    wsprintf(*pbstrAddr, 
             L"%d.%d.%d.%d", 
             (ulAddr & 0xFF),
             ((ulAddr >> 8) & 0xFF),
             ((ulAddr >> 16) & 0xFF), 
             ((ulAddr >> 24) & 0xFF) 
             );

    return WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CIPSecFilter::OnAfterAddFilter

Functionality:

    Post-adding handler to be called after successfully added a filter to SPD.

Virtual:
    
    No.

Arguments:

    pszFilterName   - The name of the filter.

    ftType          - The type of the filter.

    pCtx            - The COM interface pointer given by WMI and needed for various WMI API's.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: if rollback object is successfully created.

        (2) WBEM_S_FALSE: if there is no rollback guid information.

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:
    
    (1) Currently, we don't require a rollback object to be created for each 
        object added to SPD. Only a host that support rollback will deposit
        rollback guid information and only then can we create a rollback object.

*/

HRESULT 
CIPSecFilter::OnAfterAddFilter (
    IN LPCWSTR          pszFilterName,
    IN EnumFilterType   ftType,
    IN IWbemContext   * pCtx 
    )
{
    //
    // will create an Nsp_RollbackFilter
    //

    if ( pszFilterName == NULL  || 
        *pszFilterName == L'\0' || 
        ftType < FT_Tunnel      || 
        ftType > FT_MainMode )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = SpawnRollbackInstance(pszNspRollbackFilter, &srpObj);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // won't consider a failure if there is no rollback guid, i.e., this action is not
    // part of a transaction block
    //

    if (SUCCEEDED(hr))
    {

        //
        // $undone:shawnwu, this approach to pulling the globals are not good.
        // Instead, we should implement it as an event handler. 
        //

        //::UpdateGlobals(m_srpNamespace, pCtx);
        //if (g_varRollbackGuid.vt != VT_NULL && g_varRollbackGuid.vt != VT_EMPTY)
        //{
        //    hr = srpObj->Put(g_pszTokenGuid, 0, &g_varRollbackGuid, CIM_EMPTY);
        //}
        //else
        //{

        CComVariant varRollbackNull = pszEmptyRollbackToken;
        hr = srpObj->Put(g_pszTokenGuid, 0, &varRollbackNull, CIM_EMPTY);

        //}

        if (SUCCEEDED(hr))
        {
            //
            // ******Warning****** 
            // don't clear this var. It's bstr will be released by bstrFilterGuid itself!
            //

            VARIANT var;
            var.vt = VT_BSTR;
            var.bstrVal = ::SysAllocString(pszFilterName);
            if (var.bstrVal != NULL)
            {
                hr = srpObj->Put(g_pszFilterName, 0, &var, CIM_EMPTY);
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            //
            // after this, I don't care what you do with the var any more.
            //

            var.vt = VT_EMPTY;

            if (SUCCEEDED(hr))
            {
                //
                //$undone:shawnwu, we don't cache the previous instance data yet.
                //

                var.vt = VT_I4;
                var.lVal = Action_Add;
                hr = srpObj->Put(g_pszAction, 0, &var, CIM_EMPTY);
                
                if (SUCCEEDED(hr))
                {
                    var.vt = VT_I4;
                    var.lVal = ftType;

                    //
                    // type info is critical. So, we will flag it as an error if Put fails.
                    //

                    hr = srpObj->Put(g_pszFilterType, 0, &var, CIM_EMPTY);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_srpNamespace->PutInstance(srpObj, WBEM_FLAG_CREATE_OR_UPDATE, pCtx, NULL);
        if (SUCCEEDED(hr))
        {
            hr = WBEM_NO_ERROR;
        }
    }
    else if (SUCCEEDED(hr))
    {
        //
        // we don't have rollback guid
        //

        hr = WBEM_S_FALSE;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CIPSecFilter::Rollback

Functionality:

    Static function to rollback those filters added by us with the given token.

Virtual:
    
    No.

Arguments:

    pNamespace        - The namespace for ourselves.

    pszRollbackToken  - The token used to record our the action when we add
                        the filters.

    bClearAll         - Flag whether we should clear all filters. If it's true,
                        then we will delete all the filters regardless whether they
                        are added by us or not. This is a dangerous flag.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: rollback objects are found and they are deleted.

        (2) WBEM_S_FALSE: no rollback objects are found.

    Failure:

        Various error codes indicating the cause of the failure.


Notes:

    We will continue the deletion even if some failure happens. That failure will be
    returned, though.

    $undone:shawnwu, should we really support ClearAll?

*/

HRESULT 
CIPSecFilter::Rollback (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszRollbackToken,
    IN bool               bClearAll
    )
{
    if (pNamespace == NULL || pszRollbackToken == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //if (bClearAll)
    //{
    //    return ClearAllFilters(pNamespace);
    //}

    HRESULT hrError = WBEM_NO_ERROR;

    CComPtr<IEnumWbemClassObject> srpEnum;

    //
    // this will only enumerate all rollback filter object without testing the 
    // the token guid. This limitation is due to a mysterious error 
    // for any queries containing the where clause. That might be a limitation
    // of non-dynamic classes of WMI
    //

    HRESULT hr = ::GetClassEnum(pNamespace, pszNspRollbackFilter, &srpEnum);

    //
    // go through all found classes. srpEnum->Next will return WBEM_S_FALSE if instance
    // is not found.
    //
    
    CComPtr<IWbemClassObject> srpObj;
    ULONG nEnum = 0;
    hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);

    bool bHasInst = (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj != NULL);

    //
    // as long as we have a filter rollback instance.
    //

    while (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj != NULL)
    {
        CComVariant varTokenGuid;
        hr = srpObj->Get(g_pszTokenGuid, 0, &varTokenGuid, NULL, NULL);

        //
        // need to compare the token guid ourselves. 
        // if the rollback token is pszRollbackAll, then we will remove all filters
        //

        if (SUCCEEDED(hr) && 
            varTokenGuid.vt == VT_BSTR && 
            varTokenGuid.bstrVal != NULL &&
            (_wcsicmp(pszRollbackToken, pszRollbackAll) == 0 || _wcsicmp(pszRollbackToken, varTokenGuid.bstrVal) == 0 )
            )
        {
            //
            // See what type of filter this rollback object is for and delete the appropriate filter accordingly.
            //

            CComVariant varFilterName;
            CComVariant varFilterType;
            hr = srpObj->Get(g_pszFilterName,  0, &varFilterName, NULL, NULL);

            if (SUCCEEDED(hr) && varFilterName.vt == VT_BSTR)
            {
                hr = srpObj->Get(g_pszFilterType, 0, &varFilterType, NULL, NULL);
                if (varFilterType.vt != VT_I4)
                {
                    hr = WBEM_E_INVALID_OBJECT;
                }
            }

            //
            // know the filter type from the filter rollback object, call the appropriate
            // filter's rollback function.
            //

            if (SUCCEEDED(hr))
            {
                DWORD dwResumeHandle = 0;
                DWORD dwReturned = 0;
                DWORD dwStatus;
                if (varFilterType.lVal == FT_Tunnel)
                {
                    PTUNNEL_FILTER pFilter = NULL;
                    hr = RollbackFilters(pFilter, varFilterName.bstrVal);
                }
                else if (varFilterType.lVal == FT_Transport)
                {
                    PTRANSPORT_FILTER pFilter = NULL;
                    hr = RollbackFilters(pFilter, varFilterName.bstrVal);
                }
                else if (varFilterType.lVal == FT_MainMode)
                {
                    PMM_FILTER pFilter = NULL;
                    hr = RollbackFilters(pFilter, varFilterName.bstrVal);
                }
            }

            //
            // if the filters have been deleted, then remove the action instance
            //

            if (SUCCEEDED(hr))
            {
                CComVariant varPath;
                hr = srpObj->Get(L"__RelPath", 0, &varPath, NULL, NULL);
                if (SUCCEEDED(hr) && varPath.vt == VT_BSTR)
                {
                    hr = pNamespace->DeleteInstance(varPath.bstrVal, 0, NULL, NULL);
                }

            }

            //
            // we are tracking the first error
            //

            if (FAILED(hr) && SUCCEEDED(hrError))
            {
                hrError = hr;
            }
        }

        //
        // ready it for re-use
        //

        srpObj.Release();
        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
    }

    if (!bHasInst)
    {
        return WBEM_S_FALSE;
    }
    else
    {
        //
        // any failure code will be returned regardless of the final hr
        //

        if (FAILED(hrError))
        {
            return hrError;
        }
        else
        {
            return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
        }
    }
}


/*
Routine Description: 

Name:

    CIPSecFilter::ClearAllFilters

Functionality:

    Static function to delete all filters in SPD. This is a very dangerous action!

Virtual:
    
    No.

Arguments:

    pNamespace  - The namespace for ourselves.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        Various error codes indicating the cause of the failure.


Notes:

    We will continue the deletion even if some failure happens. That failure will be
    returned, though.

    $undone:shawnwu, should we really support this?

*/

HRESULT 
CIPSecFilter::ClearAllFilters (
    IN IWbemServices * pNamespace
    )
{
    if (pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DWORD dwResumeHandle = 0;
    DWORD dwReturned = 0;
    DWORD dwStatus;

    HRESULT hr = WBEM_NO_ERROR;
    HRESULT hrError = WBEM_NO_ERROR;

    HANDLE hFilter = NULL;

    //
    // tunnel filter
    //

    PTUNNEL_FILTER *ppTunFilter = NULL;

    //
    // enum tunnel filters. For each found one, please make sure it's freed.
    // We don't worry about specific filters, they are taken care of by SPD automatically.
    //

    dwStatus = ::EnumTunnelFilters(NULL, ENUM_GENERIC_FILTERS, GUID_NULL, ppTunFilter, 1, &dwReturned, &dwResumeHandle);

    while (ERROR_SUCCESS == dwStatus && dwReturned > 0)
    {
        hr = CTunnelFilter::DeleteFilter(*ppTunFilter);

        //
        // we will track the first error
        //

        if (FAILED(hr) && SUCCEEDED(hrError))
        {
            hrError = hr;
        }

        //
        // free the buffer, its allocated by SPD (true)
        //

        FreeFilter(ppTunFilter, true);
        *ppTunFilter = NULL;

        dwReturned = 0;
        dwStatus = ::EnumTunnelFilters(NULL, ENUM_GENERIC_FILTERS, GUID_NULL, ppTunFilter, 1, &dwReturned, &dwResumeHandle);
    }

    //
    // transport filters
    //

    PTRANSPORT_FILTER *ppTransFilter = NULL;
    
    //
    // restart enumerating another type of filters, reset the flags!
    //

    dwResumeHandle = 0;
    dwReturned = 0;

    //
    // enum transport filters.
    // We don't worry about specific filters, they are taken care of by SPD automatically.
    //

    dwStatus = ::EnumTransportFilters(NULL, ENUM_GENERIC_FILTERS, GUID_NULL, ppTransFilter, 1, &dwReturned, &dwResumeHandle);

    if (ERROR_SUCCESS == dwStatus && dwReturned > 0)
    {
        hr = CTransportFilter::DeleteFilter(*ppTransFilter);

        //
        // we will track the first error
        //

        if (FAILED(hr) && SUCCEEDED(hrError))
        {
            hrError = hr;
        }

        //
        // free the buffer, its allocated by SPD (true)
        //

        FreeFilter(ppTransFilter, true);

        *ppTransFilter = NULL;

        dwReturned = 0;
        dwStatus = ::EnumTransportFilters(NULL, ENUM_GENERIC_FILTERS, GUID_NULL, ppTransFilter, 1, &dwReturned, &dwResumeHandle);
    }

    PMM_FILTER *ppMMFilter = NULL;

    //
    // restart enumerating another type of filters, reset the flags!
    //

    dwResumeHandle = 0;
    dwReturned = 0;

    //
    // enum main mode filters.
    // We don't worry about specific filters, they are taken care of by SPD automatically.
    //

    dwStatus = ::EnumMMFilters(NULL, ENUM_GENERIC_FILTERS, GUID_NULL, ppMMFilter, 1, &dwReturned, &dwResumeHandle);

    if (ERROR_SUCCESS == dwStatus && dwReturned > 0)
    {
        hr = CMMFilter::DeleteFilter(*ppMMFilter);

        //
        // we will track the first error
        //

        if (FAILED(hr) && SUCCEEDED(hrError))
        {
            hrError = hr;
        }

        //
        // free the buffer, its allocated by SPD (true)
        //

        FreeFilter(ppMMFilter, true);
        *ppMMFilter = NULL;

        dwReturned = 0;
        dwStatus = ::EnumMMFilters(NULL, ENUM_GENERIC_FILTERS, GUID_NULL, ppMMFilter, 1, &dwReturned, &dwResumeHandle);
    }

    //
    // now clear up all filter rollback objects deposited in the WMI depository
    //

    hr = ::DeleteRollbackObjects(pNamespace, pszNspRollbackFilter);

    //
    // we will track the first error
    //

    if (FAILED(hr) && SUCCEEDED(hrError))
    {
        hrError = hr;
    }
    
    return SUCCEEDED(hrError) ? WBEM_NO_ERROR : hrError;
}



/*
Routine Description: 

Name:

    CIPSecFilter::DeleteFilter

Functionality:

    All three overrides of DeleteFilter does the same thing: delete the filter.

    This override delegate the action to tunnel filter.

Virtual:
    
    No.

Arguments:

    pFilter    - The tunnel filter to be deleted.

Return Value:

    See CTunnelFilter::DeleteFilter

Notes:


*/

HRESULT 
CIPSecFilter::DeleteFilter (
    IN PTUNNEL_FILTER pFilter
    )
{
    return CTunnelFilter::DeleteFilter(pFilter);
}



/*
Routine Description: 

Name:

    CIPSecFilter::DeleteFilter

Functionality:

    All three overrides of DeleteFilter does the same thing: delete the filter.

    This override delegate the action to Transport filter.

Virtual:
    
    No.

Arguments:

    pFilter    - The Transport filter to be deleted.

Return Value:

    See CTransportFilter::DeleteFilter

Notes:


*/

HRESULT 
CIPSecFilter::DeleteFilter (
    IN PTRANSPORT_FILTER pFilter
    )
{
    return CTransportFilter::DeleteFilter(pFilter);
}



/*
Routine Description: 

Name:

    CIPSecFilter::DeleteFilter

Functionality:

    All three overrides of DeleteFilter does the same thing: delete the filter.

    This override delegate the action to main mode filter.

Virtual:
    
    No.

Arguments:

    pFilter    - The main mode filter to be deleted.

Return Value:

    See CMMFilter::DeleteFilter

Notes:


*/

HRESULT 
CIPSecFilter::DeleteFilter (
    IN PMM_FILTER pFilter
    )
{
    return CMMFilter::DeleteFilter(pFilter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filter.h ===
//////////////////////////////////////////////////////////////////////
// Filter.h : Declaration of filter base class for the Network
// Security WMI provider for SCE
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 4/16/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "IpSecBase.h"

//
// We have three different types of filters. This enum gives numeric
// representation for each of them.
//

enum EnumFilterType
{
    FT_Tunnel = 1,
    FT_Transport = 2,
    FT_MainMode = 3,
};


/*

Class CIPSecFilter
    
    Naming: 

        CIPSecFilter stands for Filters for IPSec.
    
    Base class: 
        
        CIPSecBase.
    
    Purpose of class:

        (1) We have three different types of filters: 
            (1.1) Nsp_TunnelFilterSettings;
            (1.2) Nsp_TransportFilterSettings;
            (1.3) Nsp_MMFilterSettings;

            They share some common properties. This is the class that captures the common
            properties and functionalities.

        The class corresponds to the WMI class called Nsp_FilterSettings (an abstract class).
    
    Design:

        (1) Provide easy code maintenance by writing numerous template functions that work
            for all types of filters.

        (2) Since all filter's rollback object is the same, it provides a static function
            called Rollback to rollback filter related previous actions.

        (3) Provide filter memory allocation and deallocation routines.

        (4) Provide filter enumeration functions (FindFilterByName).

        (5) Provide similar implementation (as template functions) for Querying, Deleting
            (QueryFilterObject, DeleteFilterObject)

        (6) Provide common property population routine 
            (PopulateWbemPropertiesFromFilter/PopulateFilterPropertiesFromWbemObj).

        (7) This class is for inheritance use. Only sub-classes can use it except its Rollback function,
            which can be called directly. By this reason, all functions (except Rollback) are protected.
           
    
    Use:

        (1) Just call the needed function.

    Notes:

        (1) Much effort has been put into create this base class to eliminate duplicate code by
            using template functions. 
        

*/

class CIPSecFilter : public CIPSecBase
{

protected:

    CIPSecFilter(){}
    virtual ~CIPSecFilter(){}

public:

    static HRESULT Rollback (
        IN IWbemServices    * pNamespace, 
        IN LPCWSTR            pszRollbackToken, 
        IN bool               bClearAll
        );

    //
    // some more template functions.
    //

    
    /*
    Routine Description: 

    Name:

        CIPSecFilter::QueryFilterObject

    Functionality:

        Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
        Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

    Virtual:
    
        No.

    Arguments:

        pNotUsed    - The template parameter. Not used.

        pszQuery    - The query.

        pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

        pSink       - COM interface pointer to notify WMI of any created objects.

    Return Value:

        Success:

            (1) WBEM_NO_ERROR if filters are found and successfully returned to WMI.

            (2) WBEM_S_NO_MORE_DATA if no filter is found.

        Failure:

            Various errors may occur. We return various error code to indicate such errors.


    Notes:
    

    */

    template < class Filter > 
    HRESULT QueryFilterObject (
        IN Filter          * pNotUsed,
        IN LPCWSTR           pszQuery,
        IN IWbemContext	   * pCtx,
        IN IWbemObjectSink * pSink
	    )
    {
        //
        // get the filter name from the query
        // this key chain is not good because it doesn't have any info as what to look for
        // in the where clause
        //

        m_srpKeyChain.Release();    

        HRESULT hr = CNetSecProv::GetKeyChainFromQuery(pszQuery, g_pszFilterName, &m_srpKeyChain);
        if (FAILED(hr))
        {
            return hr;
        }

        CComVariant varFilterName;

        //
        // we will tolerate those queries that have not filter name in the where clause, 
        // But ISceKeyChain returns WBEM_S_FALSE for those properties that it can't found.
        // Any failure is still a critical failure.
        //

        hr = m_srpKeyChain->GetKeyPropertyValue(g_pszFilterName, &varFilterName);
        if (FAILED(hr))
        {
            return hr;
        }

        //
        // pszFilterName == NULL means to get all filters
        //

        LPCWSTR pszFilterName = (varFilterName.vt == VT_BSTR) ? varFilterName.bstrVal : NULL;

        //
        // $undone:shawnwu Should we also return specific filters (ENUM_SPECIFIC_FILTERS)?
        //

        DWORD dwLevels[] = {ENUM_GENERIC_FILTERS};

        for (int i = 0; i < sizeof(dwLevels) / sizeof(*dwLevels); i++)
        {
            DWORD dwResumeHandle = 0;
            Filter* pFilter = NULL;

            hr = FindFilterByName(pszFilterName, dwLevels[i], GUID_NULL, &pFilter, &dwResumeHandle);

            while (SUCCEEDED(hr) && pFilter != NULL)
            {
                CComPtr<IWbemClassObject> srpObj;

                //
                // with the found filter, create a wbem object for WMI
                //

                hr = CreateWbemObjFromFilter(pFilter, &srpObj);
                if (SUCCEEDED(hr))
                {
                    pSink->Indicate(1, &srpObj);
                }
        
                ::SPDApiBufferFree(pFilter);
                pFilter = NULL;

                hr = FindFilterByName(pszFilterName, dwLevels[i], GUID_NULL, &pFilter, &dwResumeHandle);
            }
        }

        //
        // since we are querying, it's ok to return not found
        //

        if (WBEM_E_NOT_FOUND == hr)
        {
            hr = WBEM_S_NO_MORE_DATA;
        }
        else if (SUCCEEDED(hr))
        {
            hr = WBEM_NO_ERROR;
        }

        return hr;
    }

    /*
    Routine Description: 

    Name:

        CIPSecFilter::DeleteFilterObject

    Functionality:

        Delete the filter wbem object (and thus cause the IPSec filter to be deleted).

    Virtual:
    
        No.

    Arguments:

        pNotUsed    - Template parameter, not used.

        pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

        pSink       - COM interface pointer to notify WMI of deletion results.

    Return Value:

        Success:

            WBEM_NO_ERROR;

        Failure:

            (1) WBEM_E_NOT_FOUND if the filter can't be found. 
                Depending on your calling context, this may not be a real error.

            (2) Various other errors may occur. We return various error code to indicate such errors.


    Notes:
    

    */

    template < class Filter > 
    HRESULT DeleteFilterObject (
        IN Filter           * pNotUsed,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        )
    {

        CComVariant varFilterName;

        HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszFilterName, &varFilterName);

        if (FAILED(hr))
        {
            return hr;
        }
        else if (varFilterName.vt != VT_BSTR || varFilterName.bstrVal == NULL || varFilterName.bstrVal[0] == L'\0')
        {
            return WBEM_E_NOT_FOUND;
        }

        DWORD dwResumeHandle = 0;
        Filter * pFilter = NULL;

        hr = FindFilterByName(varFilterName.bstrVal, ENUM_GENERIC_FILTERS, GUID_NULL, &pFilter, &dwResumeHandle);

        if (SUCCEEDED(hr) && pFilter != NULL)
        {
            hr = DeleteFilter(pFilter);
            FreeFilter(&pFilter, true);
        }

        return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
    }

    
    /*
    Routine Description: 

    Name:

        CIPSecFilter::GetWbemObject

    Functionality:

        Create a wbem object by the given key properties (already captured by our key chain object).

    Virtual:
    
        No.

    Arguments:

        pNotUsed    - Template parameter, not used.

        pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

        pSink       - COM interface pointer to notify WMI of any created object.

    Return Value:

        Success:

            WBEM_NO_ERROR;

        Failure:

            (1) WBEM_E_NOT_FOUND if the filter can't be found. This should be an error since you
                are trying to find a particular error.

            (2) Various other errors may occur. We return various error code to indicate such errors.


    Notes:
    

    */
    
    template < class Filter > 
    HRESULT GetWbemObject (
        IN Filter           * pNotUsed,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        )
    {
        //
        // We must already know the filter name. It will return WBEM_S_FALSE
        // if filter name can't be found
        //

        CComVariant varFilterName;
        HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszFilterName, &varFilterName);

        if (SUCCEEDED(hr) && varFilterName.vt == VT_BSTR && varFilterName.bstrVal != NULL && varFilterName.bstrVal[0] != L'\0')
        {
            Filter * pFilter = NULL;
            DWORD dwResumeHandle = 0;

            hr = FindFilterByName(varFilterName.bstrVal, ENUM_GENERIC_FILTERS, GUID_NULL, &pFilter, &dwResumeHandle);

            if (SUCCEEDED(hr) && WBEM_S_NO_MORE_DATA != hr)
            {
                CComPtr<IWbemClassObject> srpObj;
                hr = CreateWbemObjFromFilter(pFilter, &srpObj);

                if (SUCCEEDED(hr))
                {
                    hr = pSink->Indicate(1, &srpObj);
                }

                ::SPDApiBufferFree(pFilter);
            }
            else if (WBEM_S_NO_MORE_DATA == hr)
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }

        return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
    }

protected:

    static HRESULT ClearAllFilters (
        IN IWbemServices* pNamespace
        );

    HRESULT MakeULongIPAddr (
        IN  LPCWSTR pszAddr, 
        OUT ULONG* pulAddr
        )const;

    HRESULT MakeStringIPAddr (
        IN  ULONG ulAddr, 
        OUT BSTR* pbstrAddr
        )const;

    //
    // the following three functions are for the template function to work.
    // See sub-classes' real implemenation for detail. You need never to do
    // anything with these three dummies.
    //

    virtual HRESULT CreateWbemObjFromFilter (
        IN  PMM_FILTER          pMMFilter,  
        OUT IWbemClassObject ** ppObj
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual HRESULT CreateWbemObjFromFilter (
        IN  PTRANSPORT_FILTER   pTrFilter, 
        OUT IWbemClassObject ** ppObj
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
     
     virtual HRESULT CreateWbemObjFromFilter (
        IN  PTUNNEL_FILTER      pTunnelFilter,
        OUT IWbemClassObject ** ppObj
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // used by our template function. See IPSec's EnumMMFilters for details.
    //

    static DWORD EnumFilters (
        IN  DWORD        dwLevel, 
        IN  GUID         gFilterID,  
        OUT PMM_FILTER * ppFilter, 
        OUT DWORD      * pdwNumFilters,
        OUT DWORD      * pdwResumeHandle
        )
    {
        return ::EnumMMFilters(NULL, dwLevel, gFilterID, ppFilter, 1, pdwNumFilters, pdwResumeHandle);
    }


    //
    // used by our template function. See IPSec's EnumTransportFilters for details.
    //

    static DWORD EnumFilters (
        IN  DWORD               dwLevel, 
        IN  GUID                gFilterID, 
        OUT PTRANSPORT_FILTER * ppFilter, 
        OUT DWORD             * pdwNumFilters,
        OUT DWORD             * pdwResumeHandle
        )
    {
        return ::EnumTransportFilters(NULL, dwLevel, gFilterID, ppFilter, 1, pdwNumFilters, pdwResumeHandle);
    }


    //
    // used by our template function. See IPSec's EnumTunnelFilters for details.
    //

    static DWORD EnumFilters (
        IN  DWORD             dwLevel, 
        IN  GUID              gFilterID, 
        OUT PTUNNEL_FILTER  * ppFilter, 
        OUT DWORD           * pdwNumFilters,
        OUT DWORD           * pdwResumeHandle
        )
        {
            return ::EnumTunnelFilters(NULL, dwLevel, gFilterID, ppFilter, 1, pdwNumFilters, pdwResumeHandle);
        }


    //
    // called after filter is added. This is a place to do post-add actions
    //

    HRESULT OnAfterAddFilter (
        IN LPCWSTR          pszFilterName, 
        IN EnumFilterType   ftType, 
        IN IWbemContext   * pCtx
        );


    //
    // The following three versions of DeleteFilter are used by our template function.
    //
    
    static HRESULT DeleteFilter (
        IN PTUNNEL_FILTER pFilter
        );

    static HRESULT DeleteFilter (
        IN PTRANSPORT_FILTER pFilter
        );

    static HRESULT DeleteFilter (
        IN PMM_FILTER pFilter
        );


    //
    // some more template functions.
    //

    
    /*
    Routine Description: 

    Name:

        CIPSecFilter::AllocFilter

    Functionality:

        Allocate a filter.

    Virtual:
    
        No.

    Arguments:

        ppFilter    - Receives the heap allocated filter.

    Return Value:

        Success:    WBEM_NO_ERROR

        Failure:

            (1) WBEM_E_INVALID_PARAMETER if ppFilter == NULL.

            (2) WBEM_E_OUT_OF_MEMORY.

    Notes:

        (1) We set the filter's name to NULL because it is a pointer member.

        (2) Use FreeFilter to free a filter allocated by this function.

    */

    template < class Filter >
    HRESULT 
    AllocFilter (
        OUT Filter ** ppFilter
        )const
    {
        if (ppFilter == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppFilter = (Filter*) new BYTE[sizeof(Filter)];
        if (*ppFilter != NULL)
        {
            (*ppFilter)->pszFilterName = NULL;
            return WBEM_NO_ERROR;
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }


    /*
    Routine Description: 

    Name:

        CIPSecFilter::FreeFilter

    Functionality:

        Release filter memroy based on whether it is allocated by us or not.

    Virtual:
    
        No.

    Arguments:

        ppFilter  - Point to the filter to be deallocated.

        bPreExist - flag to indicate whether this is a pre-exist filter (allocated
                    by IPSec API) or a filter allocated by ourselves.

    Return Value:

        None. But upon return, the ppFilter is guaranteed to be NULL.

    Notes:

    */

    template<class Filter>
    static void FreeFilter (
        IN OUT Filter ** ppFilter, 
        IN     bool      bPreExist
        )
    {
        if (ppFilter == NULL || *ppFilter == NULL)
        {
            return;
        }

        if (bPreExist)
        {
            ::SPDApiBufferFree(*ppFilter);
        }
        else
        {
            delete [] (*ppFilter)->pszFilterName;
            delete [] (BYTE*)(*ppFilter);
        }

        *ppFilter = NULL;
    }


    /*
    Routine Description: 

    Name:

        CIPSecFilter::RollbackFilters

    Functionality:

        Undo (a) particular filter(s) added by us (tiggered by SCE's configure).

    Virtual:
    
        No.

    Arguments:

        pNotUsed        - simply a type parameter.

        pszFilterName   - Name of the filter(s) that is to be undone. Empty name means all filter
                          of the type added by us are to be removed.

    Return Value:

        Success:
            
            WBEM_NO_ERROR;

        Failure:
            
            WBEM_E_NOT_FOUND if filters are not found. This may not be an error at all depending on
            your calling context.

            Other errors may be returned as well.

    Notes:

    */

    template<class Filter>
    static HRESULT RollbackFilters (
        IN Filter* pNotUsed,
        IN LPCWSTR pszFilterName
        )
    {
        DWORD dwResumeHandle = 0;

        Filter* pGenericFilter = NULL;

        //
        // We never need to remove specific filters because they are expanded by IPSec's SPD. Once the
        // generic filter is removed, all expanded specific filters will be removed by SPD.
        //

        HRESULT hrRunning = FindFilterByName(pszFilterName, ENUM_GENERIC_FILTERS, GUID_NULL, &pGenericFilter, &dwResumeHandle);

        HRESULT hr = SUCCEEDED(hrRunning) ? WBEM_NO_ERROR : WBEM_E_NOT_FOUND;

        while (SUCCEEDED(hrRunning) && pGenericFilter)
        {
            hrRunning = DeleteFilter(pGenericFilter);

            //
            // try to return the first DeleteFilter error
            //

            if (FAILED(hrRunning) && SUCCEEDED(hr))
            {
                hr = hrRunning;
            }

            //
            // These filters are all allocated by IPSec API's. Pass true is the correct flag.
            //

            FreeFilter(&pGenericFilter, true);
            pGenericFilter = NULL;

            hrRunning = FindFilterByName(pszFilterName, ENUM_GENERIC_FILTERS, GUID_NULL, &pGenericFilter, &dwResumeHandle);
        }

        return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
    }


    /*
    Routine Description: 

    Name:

        CIPSecFilter::FindFilterByName

    Functionality:

        Given (or not given) a name of the filter, find the filter.

    Virtual:
    
        No.

    Arguments:

        pszFilterName   - Name of the filter(s) that is to be undone. Empty name means all filter
                          of the type added by us are to be removed.

        dwLevel         - Whether this is to find specific or generic filter. You should really only
                          be interested in generic filters.

        gFilterID       - the guid of the filter.

        ppFilter        - Receives the filter.

        pdwResumeHandle - For current and next round of FindFilterByName. First call should be 0.

    Return Value:

        Success:
            
            WBEM_NO_ERROR;

        Failure:
            
            (1) WBEM_E_NOT_FOUND if filters are not found. This may not be an error at all depending on
                your calling context.

            (2) WBEM_E_INVALID_PARAMETER if ppFilter == NULL or pdwResumeHandle == NULL.

    Notes:

    */

    template <class Filter>
    static HRESULT FindFilterByName (
        IN     LPCWSTR    pszFilterName,
        IN     DWORD      dwLevel,
        IN     GUID       gFilterID,
        OUT    Filter  ** ppFilter,
        IN OUT DWORD    * pdwResumeHandle
        )
    {
        if (ppFilter == NULL || pdwResumeHandle == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppFilter = NULL;

        DWORD dwNumFilters = 0;
        DWORD dwResumeHandle = 0;

        DWORD dwResult = EnumFilters(dwLevel, gFilterID, ppFilter, &dwNumFilters, pdwResumeHandle);

        HRESULT hr = WBEM_E_NOT_FOUND;

        while ((dwResult == ERROR_SUCCESS) && dwNumFilters > 0)
        {
            if (pszFilterName == NULL || *pszFilterName == L'\0' || _wcsicmp(pszFilterName, (*ppFilter)->pszFilterName) == 0)
            {
                hr = WBEM_NO_ERROR;
                break;
            }
            else
            {
                ::SPDApiBufferFree(*ppFilter);
                *ppFilter = NULL;
            }

            dwNumFilters = 0;
            dwResult = EnumFilters(dwLevel, gFilterID, ppFilter, &dwNumFilters, pdwResumeHandle);
        }

        return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
    };


    /*
    Routine Description: 

    Name:

        CIPSecFilter::PopulateWbemPropertiesFromFilter

    Functionality:

        Given a filter, populate the given wbem object with its properties. This function only
        populates those properties of the Nsp_FilterSettings class.

    Virtual:
    
        No.

    Arguments:

        Filter          - The given filter

        pObj            - The wbem object whose properties are to be filled with this filter.

    Return Value:

        Success:
            
            WBEM_NO_ERROR;

        Failure:
            
            (1) WBEM_E_NOT_FOUND if filters are not found. This may not be an error at all depending on
                your calling context.

            (2) WBEM_E_INVALID_PARAMETER if pFilter == NULL or pObj == NULL.

    Notes:

    */
    
    template <class Filter>
    HRESULT PopulateWbemPropertiesFromFilter (
        IN  Filter            * pFilter,
        OUT IWbemClassObject  * pObj
        )const
    {
        if (pFilter == NULL || pObj == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        //
        // fill in properties. This is quite tedious. Basically, we don't continue as soon
        // as some property can be pushed to the wbem object. Just make sure that no VARIANT
        // is leaked.
        //

        CComVariant var;
        var = pFilter->pszFilterName;
        HRESULT hr = pObj->Put(g_pszFilterName, 0, &var, CIM_EMPTY);
        var.Clear();

        if (SUCCEEDED(hr))
        {
            var.vt = VT_I4;
            var.lVal = pFilter->InterfaceType;
            hr = pObj->Put(g_pszInterfaceType, 0, &var, CIM_EMPTY);

            if (SUCCEEDED(hr))
            {
                var.lVal = pFilter->dwDirection;
                hr = pObj->Put(g_pszDirection, 0, &var, CIM_EMPTY);
            }

            var.Clear();

            var.vt = VT_BOOL;
            if (SUCCEEDED(hr))
            {
                var.boolVal = pFilter->bCreateMirror ? VARIANT_TRUE : VARIANT_FALSE;
                hr = pObj->Put(g_pszCreateMirror, 0, &var, CIM_EMPTY);
            }
            var.Clear();

            //
            // deal with source address
            //

            CComBSTR bstrAddr;
            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pFilter->SrcAddr.uIpAddr, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = pObj->Put(g_pszSrcAddr, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pFilter->SrcAddr.uSubNetMask, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = pObj->Put(g_pszSrcSubnetMask, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            if (SUCCEEDED(hr))
            { 
                var = pFilter->SrcAddr.AddrType;
                hr = pObj->Put(g_pszSrcAddrType, 0, &var, CIM_EMPTY);
                var.Clear();
            }

            //
            // deal with destination address
            //

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pFilter->DesAddr.uIpAddr, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = pObj->Put(g_pszDestAddr, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pFilter->DesAddr.uSubNetMask, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = pObj->Put(g_pszDestSubnetMask, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            if (SUCCEEDED(hr))
            {
                var = pFilter->DesAddr.AddrType;
                pObj->Put(g_pszDestAddrType, 0, &var, CIM_EMPTY);
                var.Clear();
            }
        }

        return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
    }


    /*
    Routine Description: 

    Name:

        CIPSecFilter::PopulateFilterPropertiesFromWbemObj

    Functionality:

        Given a wbem object, populate the given filter with appropriate data. This function only
        populates those properties of the Nsp_FilterSettings class.

    Virtual:
    
        No.

    Arguments:

        pInst           - The wbem object.

        ppFilter        - Receives a heap allocated filter. Depending on whether the filter already
                          exists or not, this allocation may be done by us (*pbPreExist == false).
                          Make sure to call the FreeFilter to free the heap object.

        pbPreExist      - Receives information whether this heap object is a pre-exist filter
                          (meaning that IPSec APIs allocated it).

    Return Value:

        Success:
            
            WBEM_NO_ERROR;

        Failure:
            
            (1) WBEM_E_NOT_FOUND if filters are not found. This may not be an error at all depending on
                your calling context.

            (2) WBEM_E_INVALID_PARAMETER if pFilter == NULL or pInst == NULL or pbPreExist == NULL.

    Notes:

    */

    template <class Filter>
    HRESULT PopulateFilterPropertiesFromWbemObj (
        IN  IWbemClassObject *  pInst,
        OUT Filter           ** ppFilter,
        OUT bool             *  pbPreExist
        )const
    {
        if (pInst == NULL || ppFilter == NULL || pbPreExist == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppFilter = NULL;
        *pbPreExist = false;

        DWORD dwResumeHandle = 0;

        //
        // this var will be re-used again and again. Each should be Clear'ed before reuse
        // if the type is a bstr or ref counted object.
        //

        CComVariant var;

        //
        // try to find out if the filter already exists
        //

        HRESULT hr = pInst->Get(g_pszFilterName, 0, &var, NULL, NULL);

        if (SUCCEEDED(hr) && var.vt == VT_BSTR && var.bstrVal != NULL)
        {
            //
            // see if this is a filter we already have
            //

            hr = FindFilterByName(var.bstrVal, ENUM_GENERIC_FILTERS, GUID_NULL, ppFilter, &dwResumeHandle);

            if (SUCCEEDED(hr) && *ppFilter != NULL)
            {
                *pbPreExist = true;
            }
            else
            {
                //
                // can't find it, fine. We will create a new one.
                //

                hr = AllocFilter(ppFilter);

                if (SUCCEEDED(hr))
                {
                    hr = ::CoCreateGuid(&((*ppFilter)->gFilterID));
                    if (SUCCEEDED(hr))
                    {
                        //
                        // give it the name
                        //

                        DWORD dwSize = wcslen(var.bstrVal) + 1;
                        (*ppFilter)->pszFilterName = new WCHAR[dwSize];

                        if (NULL == (*ppFilter)->pszFilterName)
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                        else
                        {
                            ::memcpy((*ppFilter)->pszFilterName, var.bstrVal, dwSize * sizeof(WCHAR));
                        }
                    }
                }
            }
        }
        else if (SUCCEEDED(hr))
        {
            //
            // we can take this object as a good one because it does even have a name,
            // which is the key proeprty of a filter.
            //

            hr = WBEM_E_INVALID_OBJECT;
        }

        //
        // we get the filter and now we need to update the properties.
        // This is a tedious and error prone operation. It's all repeatitive code.
        // Pay very close attention.
        // For those properties that the wbem object doesn't have values, we will give our
        // predetermined defaults. For that reason, we won't return the Get function's
        // errors to the caller. $undone:shawnwu, is this perfectly fine?
        //

        if (SUCCEEDED(hr))
        {
            hr = pInst->Get(g_pszInterfaceType, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_I4)
            {
                (*ppFilter)->InterfaceType = IF_TYPE(var.lVal);
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->InterfaceType = INTERFACE_TYPE_ALL;
            }
            var.Clear();

            hr = pInst->Get(g_pszCreateMirror, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BOOL)
            {
                (*ppFilter)->bCreateMirror = (var.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->bCreateMirror = TRUE;
            }
            var.Clear();

            (*ppFilter)->dwFlags = 0;

            hr = pInst->Get(g_pszDirection, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_I4)
            {
                (*ppFilter)->dwDirection = var.lVal;
            }
            else
            {   
                //
                // default
                //

                (*ppFilter)->dwDirection = FILTER_DIRECTION_OUTBOUND;
            }
            var.Clear();

            //
            // deal with src address
            //

            (*ppFilter)->SrcAddr.gInterfaceID = GUID_NULL;
            hr = pInst->Get(g_pszSrcAddr, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                if (_wcsicmp(var.bstrVal, g_pszIP_ADDRESS_ME) == 0)
                {
                    (*ppFilter)->SrcAddr.uIpAddr = IP_ADDRESS_ME;
                }
                else
                {
                    //
                    // must be a specific address
                    //

                    hr = MakeULongIPAddr(var.bstrVal, &((*ppFilter)->SrcAddr.uIpAddr));
                }
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->SrcAddr.uIpAddr = IP_ADDRESS_ME;
            }
            var.Clear();

            //
            // src subnet mask
            //

            hr = pInst->Get(g_pszSrcSubnetMask, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                if (_wcsicmp(var.bstrVal, g_pszIP_ADDRESS_MASK_NONE) == 0)
                {
                    (*ppFilter)->SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
                }
                else
                {
                    //
                    // must be a specific mask
                    //

                    hr = MakeULongIPAddr(var.bstrVal, &((*ppFilter)->SrcAddr.uSubNetMask));
                }
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
            }

            var.Clear();

            //
            // src address type
            //

            hr = pInst->Get(g_pszSrcAddrType, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_I4)
            {
                (*ppFilter)->SrcAddr.AddrType = ADDR_TYPE(var.lVal);
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->SrcAddr.AddrType = IP_ADDR_UNIQUE;
            }
            var.Clear();

            //
            // deal with destination address
            // dest address
            //

            hr = pInst->Get(g_pszDestAddr, 0, &var, NULL, NULL);
            (*ppFilter)->DesAddr.gInterfaceID = GUID_NULL;
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                if (_wcsicmp(var.bstrVal, g_pszSUBNET_ADDRESS_ANY) == 0)
                {
                    (*ppFilter)->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
                }
                else
                {
                    //
                    // must be a specific address
                    //

                    hr = MakeULongIPAddr(var.bstrVal, &((*ppFilter)->DesAddr.uIpAddr));
                }
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
            }
            var.Clear();

            //
            // dest subnet mask
            //

            hr = pInst->Get(g_pszDestSubnetMask, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                if (_wcsicmp(var.bstrVal, g_pszSUBNET_MASK_ANY) == 0)
                {
                    (*ppFilter)->DesAddr.uSubNetMask = SUBNET_MASK_ANY;
                }
                else
                {
                    //
                    // must be a specific mask
                    //

                    hr = MakeULongIPAddr(var.bstrVal, &((*ppFilter)->DesAddr.uSubNetMask));
                }
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->DesAddr.uSubNetMask = SUBNET_MASK_ANY;
            }

            var.Clear();

            //
            // dest address type
            //

            hr = pInst->Get(g_pszDestAddrType, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_I4)
            {
                (*ppFilter)->DesAddr.AddrType = ADDR_TYPE(var.lVal);
            }
            else
            {
                //
                // default
                //

                (*ppFilter)->DesAddr.AddrType = IP_ADDR_SUBNET;
            }
            var.Clear();

            //
            // Since we are not tracking any Get funtion's return code,
            // better clean it up and say we are fine.
            //

            hr = WBEM_NO_ERROR;
        }

        return hr;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filtermm.cpp ===
// FilterMM.cpp: implementation for the WMI class Nsp_MMFilterSettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "FilterMM.h"
#include "NetSecProv.h"


/*
Routine Description: 

Name:

    CMMFilter::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pszQuery    - The query.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        (1) WBEM_NO_ERROR if instances are returned;

        (2) WBEM_S_NO_MORE_DATA if no instances are returned.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.


Notes:
    

*/

STDMETHODIMP 
CMMFilter::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    PMM_FILTER pFilter = NULL;
    return QueryFilterObject(pFilter, pszQuery, pCtx, pSink);
}



/*
Routine Description: 

Name:

    CMMFilter::DeleteInstance

Functionality:

    Will delete the wbem object, which causes to delete the IPSec main mode filter.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    See template function comments for detail.


Notes:
    

*/

STDMETHODIMP 
CMMFilter::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    PMM_FILTER pFilter = NULL;

    return DeleteFilterObject(pFilter, pCtx, pSink);
}



/*
Routine Description: 

Name:

    CMMFilter::PutInstance

Functionality:

    Put a main mode filter into SPD whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CMMFilter::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pInst == NULL || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    bool bPreExist = false;

    //
    // for those filters that are created by ourselves (bPreExist == true)
    // we have our own way of allocating the filter, need to free it in our corresponding way
    //

    PMM_FILTER pMMFilter = NULL;
    HRESULT hr = GetMMFilterFromWbemObj(pInst, &pMMFilter, &bPreExist);

    //
    // if filter is successfully returned, then add it to SPD
    //

    if (SUCCEEDED(hr) && pMMFilter)
    {
        hr = AddFilter(bPreExist, pMMFilter);

        //
        // if everything is fine, then deposit this filter information
        // Nsp_RollbackFilter
        //

        if (SUCCEEDED(hr))
        {
            hr = OnAfterAddFilter(pMMFilter->pszFilterName, FT_MainMode, pCtx);
        }

        FreeFilter(&pMMFilter, bPreExist);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CMMFilter::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    See template function comments for detail.


Notes:
    

*/

STDMETHODIMP 
CMMFilter::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    PMM_FILTER pFilter = NULL;
    return GetWbemObject(pFilter, pCtx, pSink);
}


/*
Routine Description: 

Name:

    CMMFilter::CreateWbemObjFromFilter

Functionality:

    Given a SPD's main mode filter, we will create a wbem object representing it.

Virtual:
    
    No.

Arguments:

    pMMFilter   - The SPD's main mode filter object.

    ppObj       - Receives the wbem object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:

*/

HRESULT 
CMMFilter::CreateWbemObjFromFilter (
    IN  PMM_FILTER          pMMFilter,
    OUT IWbemClassObject ** ppObj
    )
{
    if (pMMFilter == NULL || ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // create a wbem object of this class that can be used to fill in properties
    //

    *ppObj = NULL;
    HRESULT hr = SpawnObjectInstance(ppObj);

    if (SUCCEEDED(hr))
    {
        //
        // fill in the base properties
        //

        hr = PopulateWbemPropertiesFromFilter(pMMFilter, *ppObj);
    }

    if (SUCCEEDED(hr))
    {
        //
        // for various IPSec APIs, it takes a pServerName parameter. If we pass NULL,
        // it is assumed to be local machine
        //

        PIPSEC_MM_POLICY pMMPolicy = NULL;
        DWORD dwResult = ::GetMMPolicyByID(NULL, pMMFilter->gPolicyID, &pMMPolicy);
        HRESULT hr = (dwResult == ERROR_SUCCESS) ? WBEM_NO_ERROR : WBEM_E_NOT_AVAILABLE;

        PMM_AUTH_METHODS pMMAuth = NULL;

        if (SUCCEEDED(hr))
        {
            dwResult = ::GetMMAuthMethods(NULL, pMMFilter->gMMAuthID, &pMMAuth);
            hr = (dwResult == ERROR_SUCCESS) ? WBEM_NO_ERROR : WBEM_E_NOT_AVAILABLE;
        }

        if (SUCCEEDED(hr))
        {
            //
            // Set the main mode policy name
            //

            CComVariant var;
            var = pMMPolicy->pszPolicyName;
            hr = (*ppObj)->Put(g_pszMMPolicyName, 0, &var, CIM_EMPTY);

            //
            // var is now a bstr, clear it before re-use
            //

            var.Clear();

            if (SUCCEEDED(hr))
            {

                //
                // Set the main mode authenticaion name (StringFromGUID2)
                //

                var.vt = VT_BSTR;
                var.bstrVal = ::SysAllocStringLen(NULL, Guid_Buffer_Size);
                if (var.bstrVal != NULL)
                {
                    //
                    // translate the guid into a bstr variant
                    //

                    if (::StringFromGUID2(pMMAuth->gMMAuthID, var.bstrVal, Guid_Buffer_Size) > 0)
                    {
                        hr = (*ppObj)->Put(g_pszMMAuthName, 0, &var, CIM_EMPTY);
                    }
                    var.Clear();
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // fill in base class CIPSecFilter's members
                    //

                    var.vt = VT_I4;
                    var.lVal = FT_MainMode;
                    hr = (*ppObj)->Put(g_pszFilterType, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }
  
        }
        ::SPDApiBufferFree(pMMPolicy);
        ::SPDApiBufferFree(pMMAuth);
    }


    //
    // we may have created the object, but some mid steps have failed,
    // so let's release the object.
    //

    if (FAILED(hr) && *ppObj != NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CMMFilter::GetMMFilterFromWbemObj

Functionality:

    Will try to get the MM filter if this filter already exists.
    Otherwise, we will create a new one.

Virtual:
    
    No.

Arguments:

    pInst       - The wbem object object.

    ppMMFilter  - Receives the main mode filter.

    pbPreExist  - Receives the information whether this object memory is allocated by SPD or not.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:

*/

HRESULT 
CMMFilter::GetMMFilterFromWbemObj (
    IN  IWbemClassObject * pInst,
    OUT PMM_FILTER       * ppMMFilter,
    OUT bool             * pbPreExist
    )
{
    if (pInst == NULL || ppMMFilter == NULL || pbPreExist == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppMMFilter = NULL;
    *pbPreExist = false;

    //
    // Fill in the common filter properties. This function does most of the dirty work.
    // It tries to find the filter and fill in the common properties.
    //

    HRESULT hr = PopulateFilterPropertiesFromWbemObj(pInst, ppMMFilter, pbPreExist);

    if (SUCCEEDED(hr))
    {
        //
        // get the policy associated with this filter. We must have a policy
        //

        DWORD dwResumeHandle = 0;
        CComVariant var;
        hr = pInst->Get(g_pszMMPolicyName, 0, &var, NULL, NULL);

        if (SUCCEEDED(hr) && var.vt == VT_BSTR)
        {
            //
            // need to free this buffer
            //

            PIPSEC_MM_POLICY pMMPolicy = NULL;

            //
            // if policy is not found, it's a critical error
            //

            hr = FindPolicyByName(var.bstrVal, &pMMPolicy, &dwResumeHandle);

            if (SUCCEEDED(hr))
            {
                (*ppMMFilter)->gPolicyID = pMMPolicy->gPolicyID;

                //
                // Done with the filter, release the buffer
                //

                ::SPDApiBufferFree(pMMPolicy);
                var.Clear();

                //
                // now get the auth methods (the authentication guid), we must make sure that
                // this is a valid method (being able to find it validates it)!
                //

                hr = pInst->Get(g_pszMMAuthName, 0, &var, NULL, NULL);
                if (SUCCEEDED(hr) && var.vt == VT_BSTR)
                {
                    //
                    // need to free this buffer
                    //

                    PMM_AUTH_METHODS pMMAuth = NULL;
                    dwResumeHandle = 0;
                    hr = ::FindMMAuthMethodsByID(var.bstrVal, &pMMAuth, &dwResumeHandle);

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Since we can find the main mode auth method, we know it's valid.
                        // so, go ahead set the object's mm auth id
                        //

                        ::CLSIDFromString(var.bstrVal, &((*ppMMFilter)->gMMAuthID));

                        //
                        // release the buffer
                        //

                        ::SPDApiBufferFree(pMMAuth);
                    }
                }
            }
        }
        else
        {
            hr = WBEM_E_INVALID_OBJECT;
        }
    }

    if (FAILED(hr) && *ppMMFilter != NULL)
    {
        //
        // FreeFilter will reset ppMMFilter to NULL
        //

        FreeFilter(ppMMFilter, *pbPreExist);
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CMMFilter::AddFilter

Functionality:

    Will try to add the main mode filter to SPD. The end result may be to modify
    an existing filter (if it already exists).

Virtual:
    
    No.

Arguments:

    bPreExist   - Whether this object memory is allocated by SPD or not.

    pMMFilter   - The main mode filter to add.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CMMFilter::AddFilter (
    IN bool         bPreExist,
    IN PMM_FILTER   pMMFilter
    )
{
    HANDLE hFilter = NULL;
    DWORD dwResult = ERROR_SUCCESS;

    HRESULT hr = WBEM_NO_ERROR;

    if (bPreExist)
    {
        //
        // if we are told that this filter already exists, we will try to modify it only.
        //

        dwResult = ::OpenMMFilterHandle(NULL, pMMFilter, &hFilter);

        if (dwResult == ERROR_SUCCESS)
        {
            dwResult = ::SetMMFilter(hFilter, pMMFilter);
        }
    }
    else
    {
        dwResult = ::AddMMFilter(NULL, 1, pMMFilter, &hFilter);
    }

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // $undone:shawnwu, we really need better error information
        // other than WBEM_E_FAILED. No one has come up with info as
        // how we can do that with WMI yet.
        //

        hr = ::IPSecErrorToWbemError(dwResult);
    }

    if (hFilter != NULL)
    {
        ::CloseMMFilterHandle(hFilter);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CMMFilter::DeleteFilter

Functionality:

    Will try to delete the main mode filter from SPD. 

Virtual:
    
    No.

Arguments:

    pMMFilter   - The main mode filter to delete.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: if the object is successfully deleted.

        (2) WBEM_S_FALSE: if the object doesn't exist.

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CMMFilter::DeleteFilter (
    IN PMM_FILTER pMMFilter
    )
{
    if (pMMFilter == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;
    HANDLE hMMFilter = NULL;

    DWORD dwStatus = ::OpenMMFilterHandle(NULL, pMMFilter, &hMMFilter);
    if (ERROR_SUCCESS == dwStatus)
    {
        dwStatus = ::DeleteMMFilter(hMMFilter);
        if (dwStatus != ERROR_SUCCESS)
        {
            //
            // $undone:shawnwu, we really need better error information
            // other than WBEM_E_FAILED. No one has come up with info as
            // how we can do that with WMI yet.
            //

            hr = ::IPSecErrorToWbemError(dwStatus);
        }
        else
        {
            //
            // once it is successfully deleted, we don't have to close it any more.
            //

            hMMFilter = NULL;
        }

    }
    else if (ERROR_IPSEC_MM_FILTER_NOT_FOUND == dwStatus)
    {
        hr = WBEM_S_FALSE;
    }
    else
    {
        //
        // $undone:shawnwu, we really need better error information
        // other than WBEM_E_FAILED. No one has come up with info as
        // how we can do that with WMI yet.
        //

        hr = ::IPSecErrorToWbemError(dwStatus);
    }
    
    if (hMMFilter != NULL)
    {
        ::CloseMMFilterHandle(hMMFilter);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filtertr.cpp ===
// FilterTr.cpp: implementation for the WMI class Nsp_TransportFilterSettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "FilterTr.h"
#include "NetSecProv.h"


/*
Routine Description: 

Name:

    CTransportFilter::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pszQuery    - The query.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        (1) WBEM_NO_ERROR if instances are returned;

        (2) WBEM_S_NO_MORE_DATA if no instances are returned.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.

Notes:
    

*/

STDMETHODIMP 
CTransportFilter::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    PTRANSPORT_FILTER pFilter = NULL;
    return QueryFilterObject(pFilter, pszQuery, pCtx, pSink);
}



/*
Routine Description: 

Name:

    CTransportFilter::DeleteInstance

Functionality:

    Will delete the wbem object, which causes to delete the IPSec transport filter.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    See template function comments for detail.


Notes:
    

*/

STDMETHODIMP 
CTransportFilter::DeleteInstance
( 
IWbemContext *pCtx,     // [in]
IWbemObjectSink *pSink  // [in]
)
{
    PTRANSPORT_FILTER pFilter = NULL;

    return DeleteFilterObject(pFilter, pCtx, pSink);
}




/*
Routine Description: 

Name:

    CTransportFilter::PutInstance

Functionality:

    Put a transport filter into SPD whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CTransportFilter::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pInst == NULL || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    bool bPreExist = false;

    //
    // for those filters that are created by ourselves (bPreExist == true)
    // we have our own way of allocating the filter, need to free it in our corresponding way
    //

    PTRANSPORT_FILTER pTrFilter = NULL;
    HRESULT hr = GetTransportFilterFromWbemObj(pInst, &pTrFilter, &bPreExist);

    //
    // if filter is successfully returned, then add it to SPD
    //

    if (SUCCEEDED(hr) && pTrFilter != NULL)
    {
        hr = AddFilter(bPreExist, pTrFilter);

        if (SUCCEEDED(hr))
        {
            //
            // deposit our information of the added filter
            //

            hr = OnAfterAddFilter(pTrFilter->pszFilterName, FT_Transport, pCtx);
        }

        //
        // release the filter
        //        
        
        FreeFilter(&pTrFilter, bPreExist);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CTransportFilter::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    See template function comments for detail.


Notes:
    

*/

STDMETHODIMP 
CTransportFilter::GetInstance ( 
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pSink
    )
{
    PTRANSPORT_FILTER pFilter = NULL;
    return GetWbemObject(pFilter, pCtx, pSink);
}


/*
Routine Description: 

Name:

    CTransportFilter::CreateWbemObjFromFilter

Functionality:

    Given a SPD's main mode filter, we will create a wbem object representing it.

Virtual:
    
    No.

Arguments:

    pTrFilter   - The SPD's transport filter object.

    ppObj       - Receives the wbem object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CTransportFilter::CreateWbemObjFromFilter (
    IN  PTRANSPORT_FILTER    pTrFilter,
    OUT IWbemClassObject  ** ppObj
    )
{
    if (pTrFilter == NULL || ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // create a wbem object of this class that can be used to fill in properties
    //

    *ppObj = NULL;
    HRESULT hr = SpawnObjectInstance(ppObj);

    if (SUCCEEDED(hr))
    {
        //
        // fill in the base properties
        //

        hr = PopulateWbemPropertiesFromFilter(pTrFilter, *ppObj);
    }

    if (SUCCEEDED(hr))
    {
        //
        // for various IPSec APIs, it takes a pServerName parameter. If we pass NULL,
        // it is assumed to be local machine
        //

        PIPSEC_QM_POLICY pQMPolicy = NULL;
        
        DWORD dwResult = ::GetQMPolicyByID(NULL, pTrFilter->gPolicyID, &pQMPolicy);
        HRESULT hr = (dwResult == ERROR_SUCCESS) ? WBEM_NO_ERROR : WBEM_E_NOT_AVAILABLE;

        //
        // if policy is found, then populate the other transport filter properties
        // that rely on the policy.
        //

        if (SUCCEEDED(hr))
        {
            hr = PopulateTransportWbemProperties(pTrFilter, pQMPolicy, *ppObj);
        }
        ::SPDApiBufferFree(pQMPolicy);
    }

    //
    // we may have created the object, but some mid steps have failed,
    // so let's release the object.
    //

    if (FAILED(hr) && *ppObj != NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CTransportFilter::GetTransportFilterFromWbemObj

Functionality:

    Will try to get the transport filter if this filter already exists.
    Otherwise, we will create a new one.

Virtual:
    
    No.

Arguments:

    pInst       - The wbem object object.

    ppTrFilter  - Receives the transport filter.

    pbPreExist  - Receives the information whether this object memory is allocated by SPD or not.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:


*/

HRESULT 
CTransportFilter::GetTransportFilterFromWbemObj (
    IN  IWbemClassObject  * pInst,
    OUT PTRANSPORT_FILTER * ppTrFilter,
    OUT bool              * pbPreExist
    )
{
    //
    // Fill in the common filter properties. This function does most of the dirty work.
    // It tries to find the filter and fill in the common properties.
    //

    HRESULT hr = PopulateFilterPropertiesFromWbemObj(pInst, ppTrFilter, pbPreExist);

    //
    // Tranport filter specific properties
    //

    if (SUCCEEDED(hr))
    {
        hr = PopulateTransportFilterProperties(*ppTrFilter, pInst);
    }

    if (FAILED(hr) && *ppTrFilter != NULL)
    {
        //
        // FreeFilter will reset ppTrFilter to NULL
        //

        FreeFilter(ppTrFilter, *pbPreExist);
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CTransportFilter::AddFilter

Functionality:

    Will try to add the Transport filter to SPD. The end result may be to modify
    an existing filter (if it already exists).

Virtual:
    
    No.

Arguments:

    bPreExist   - Whether this object memory is allocated by SPD or not.

    pTrFilter   - The Transport filter to add.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CTransportFilter::AddFilter (
    IN bool              bPreExist,
    IN PTRANSPORT_FILTER pTrFilter
    )
{
    HANDLE hFilter = NULL;
    DWORD dwResult = ERROR_SUCCESS;

    HRESULT hr = WBEM_NO_ERROR;

    if (bPreExist)
    {
        //
        // if we are told that this filter already exists, we will try to modify it only.
        //

        dwResult = ::OpenTransportFilterHandle(NULL, pTrFilter, &hFilter);
        if (dwResult == ERROR_SUCCESS)
        {
            dwResult = ::SetTransportFilter(hFilter, pTrFilter);
        }
        
    }
    else
    {
        dwResult = ::AddTransportFilter(NULL, 1, pTrFilter, &hFilter);
    }

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // $undone:shawnwu, we really need better error information
        // other than WBEM_E_FAILED. No one has come up with info as
        // how we can do that with WMI yet.
        //

        hr = ::IPSecErrorToWbemError(dwResult);
    }


    if (hFilter != NULL)
    {
        ::CloseTransportFilterHandle(hFilter);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CTransportFilter::DeleteFilter

Functionality:

    Will try to delete the transport filter from SPD. 

Virtual:
    
    No.

Arguments:

    pTrFilter   - The transport filter to delete.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: if the object is successfully deleted.

        (2) WBEM_S_FALSE: if the object doesn't exist.

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CTransportFilter::DeleteFilter (
    IN PTRANSPORT_FILTER pTrFilter
    )
{
    if (pTrFilter == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HANDLE hFilter = NULL;
    HRESULT hr = WBEM_NO_ERROR;

    DWORD dwResult = ::OpenTransportFilterHandle(NULL, pTrFilter, &hFilter);

    if (dwResult == ERROR_SUCCESS && hFilter != NULL)
    {
        dwResult = ::DeleteTransportFilter(hFilter);
        if (dwResult != ERROR_SUCCESS)
        {
            hr = ::IPSecErrorToWbemError(dwResult);
        }
        else
        {
            //
            // once it is successfully deleted, we don't have to close it any more.
            //

            hFilter = NULL;
        }
    }
    else if (ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND == dwResult)
    {
        hr = WBEM_S_FALSE;
    }
    else
    {
        //
        // $undone:shawnwu, we really need better error information
        // other than WBEM_E_FAILED. No one has come up with info as
        // how we can do that with WMI yet.
        //

        hr = ::IPSecErrorToWbemError(dwResult);
    }

    if (hFilter != NULL)
    {
        ::CloseTransportFilterHandle(hFilter);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filtertr.h ===
//////////////////////////////////////////////////////////////////////
// FilterTr.h : Declaration of CTransportFilter class which implements
// our WMI class Nsp_TransportFilterSettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "Filter.h"

/*

Class CTransportFilter
    
    Naming: 

        CTransportFilter stands for Transport Filter.
    
    Base class: 
        
        CIPSecFilter.
    
    Purpose of class:

        The class implements the common interface (IIPSecObjectImpl) for our provider
        for the WMI class called Nsp_TransportFilterSettings (a concrete class).
    
    Design:

        (1) Just implements IIPSecObjectImpl, plus several helpers. Extremely simple design.

        (2) Due to the factor that transport filters share some common properties with tunnel 
            filters (not vise versa), this class again has some static template functions
            that work for both types.
           
    
    Use:

        (1) You will never create an instance directly yourself. It's done by ATL CComObject<xxx>.

        (2) If you need to add a transport filter that is already created, call AddFilter.
            If you need to delete a transport filter, then call DeleteFilter.

        (3) For tunnel filters, it can call the static template functions of this class for
            populating the common properties.
        
        (4) All other use is always through IIPSecObjectImpl.
        
    Notes:


*/

class ATL_NO_VTABLE CTransportFilter :
    public CIPSecFilter
{

protected:
    CTransportFilter(){}
    virtual ~CTransportFilter(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );


    //
    // methods common to all filter classes
    //

    static HRESULT AddFilter (
        IN bool               bPreExist, 
        IN PTRANSPORT_FILTER  pTrFilter
        );

    static HRESULT DeleteFilter (
        IN PTRANSPORT_FILTER pTrFilter
        );

public:


    //
    // some tempalte functions.
    //


    /*
    Routine Description: 

    Name:

        CTransportFilter::PopulateTransportFilterProperties

    Functionality:

        Given a wbem object representing either a transport filter (Nsp_TransportFilterSettings)
        or a tunnel filter (Nsp_TunnelFilterSettings), we will set the corresponding values of the
        given filter struct.

    Virtual:
    
        No.

    Arguments:

        pFilter - Point to the filter to test.

        pInst   - The wbem object.

    Return Value:

        Either true (the filter has to have a quick mode policy) or false.

    Notes:

    */
    
    template <class Filter>
    static HRESULT PopulateTransportFilterProperties (
        OUT Filter           * pFilter, 
        IN  IWbemClassObject * pInst
        )
    {
        if (pFilter == NULL || pInst == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CComVariant var;
        HRESULT hr = pInst->Get(g_pszInboundFlag, 0, &var, NULL, NULL);

        //
        // deal with inbound filter flag
        //

        if (SUCCEEDED(hr))
        {
            pFilter->InboundFilterFlag = FILTER_FLAG(var.lVal);
        }
        else
        {
            //
            // default to blocking
            //

            pFilter->InboundFilterFlag = BLOCKING;
        }

        var.Clear();

        //
        // dealing with out-bound filter flag.
        //

        hr = pInst->Get(g_pszOutboundFlag, 0, &var, NULL, NULL);
        if (SUCCEEDED(hr) && var.vt == VT_I4)
        {
            pFilter->OutboundFilterFlag = FILTER_FLAG(var.lVal);
        }
        else
        {
            //
            // default to blocking
            //

            pFilter->OutboundFilterFlag = BLOCKING;
        }
        var.Clear();

        if (pFilter->InboundFilterFlag  != PASS_THRU && 
            pFilter->InboundFilterFlag  != BLOCKING  &&
            pFilter->OutboundFilterFlag != PASS_THRU && 
            pFilter->OutboundFilterFlag != BLOCKING )
        {
            //
            // if need policy (not pass through nor blocking)
            //

            CComVariant var;
            hr = pInst->Get(g_pszQMPolicyName, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                DWORD dwResumeHandle = 0;

                //
                // need to free this buffer
                //

                PIPSEC_QM_POLICY pQMPolicy = NULL;

                //
                // if the policy can't be found, it's a serious error
                //

                hr = FindPolicyByName(var.bstrVal, &pQMPolicy, &dwResumeHandle);

                if (SUCCEEDED(hr))
                {
                    pFilter->gPolicyID = pQMPolicy->gPolicyID;

                    //
                    // release the buffer
                    //

                    ::SPDApiBufferFree(pQMPolicy);
                }
                else
                {
                    //
                    // the wbem object contains the policy name that we can't find.
                    // $consider: if we can pass our own custom error info, this should
                    // say: the named policy can't be found for the filter!
                    //

                    hr = WBEM_E_INVALID_OBJECT;
                }
            }
            else
            {
                hr = WBEM_E_INVALID_OBJECT;
            }
        }
        else
        {
            pFilter->gPolicyID = GUID_NULL;
        }

        if (FAILED(hr))
        {
            return hr;
        }

        //
        // the weight is for us to set. SPD does that.
        //

        pFilter->dwWeight = 0;

        hr = pInst->Get(g_pszProtocol, 0, &var, NULL, NULL);
        pFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;

        if (SUCCEEDED(hr) && var.vt == VT_I4)
        {
            pFilter->Protocol.dwProtocol = DWORD(var.lVal);
        }
        else
        {
            pFilter->Protocol.dwProtocol = 0;
        }

        var.Clear();

        hr = pInst->Get(g_pszSrcPort, 0, &var, NULL, NULL);

        //
        // this is the only port type.
        //

        pFilter->SrcPort.PortType = PORT_UNIQUE;

        if (SUCCEEDED(hr) && var.vt == VT_I4)
        {
            pFilter->SrcPort.wPort = WORD(var.lVal);
        }
        else
        {
            pFilter->SrcPort.wPort = 0;
        }

        var.Clear();

        hr = pInst->Get(g_pszDestPort, 0, &var, NULL, NULL);

        //
        // this is the only port type
        //

        pFilter->DesPort.PortType = PORT_UNIQUE;

        if (SUCCEEDED(hr) && var.vt == VT_I4)
        {
            pFilter->DesPort.wPort = WORD(var.lVal);
        }
        else
        {
            pFilter->DesPort.wPort = 0;
        }
        
        return hr;
    };

    template<class Filter>
    static HRESULT PopulateTransportWbemProperties(Filter* pFilter, PIPSEC_QM_POLICY pQMPolicy, IWbemClassObject* pInst)
    {
        if (pFilter == NULL || pQMPolicy == NULL || pInst == NULL)
            return WBEM_E_INVALID_PARAMETER;

        CComVariant var;
        // get the main mode policy name
        var = pQMPolicy->pszPolicyName;
        // it's just a non-key property, it may be missing, so ignore the return result
        pInst->Put(g_pszQMPolicyName, 0, &var, CIM_EMPTY);
        var.Clear();

        var.vt = VT_I4;
        var.lVal = pFilter->InboundFilterFlag;
        pInst->Put(g_pszInboundFlag, 0, &var, CIM_EMPTY);
        var.lVal = pFilter->OutboundFilterFlag;
        pInst->Put(g_pszOutboundFlag, 0, &var, CIM_EMPTY);
        var.lVal = pFilter->Protocol.dwProtocol;
        pInst->Put(g_pszProtocol, 0, &var, CIM_EMPTY);
        var.lVal = pFilter->SrcPort.wPort;
        pInst->Put(g_pszSrcPort, 0, &var, CIM_EMPTY);
        var.lVal = pFilter->DesPort.wPort;
        pInst->Put(g_pszDestPort, 0, &var, CIM_EMPTY);

        return WBEM_NO_ERROR;
    }

private:

    virtual HRESULT CreateWbemObjFromFilter (
        IN  PTRANSPORT_FILTER   pTrFilter, 
        OUT IWbemClassObject ** ppObj
        );

    HRESULT GetTransportFilterFromWbemObj (
        IN  IWbemClassObject    * pObj, 
        OUT PTRANSPORT_FILTER   * ppTrFilter, 
        OUT bool                * bExistFilter
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filtermm.h ===
//////////////////////////////////////////////////////////////////////
// FilterMM.h : Declaration of CMMFilter class which implements
// our WMI class Nsp_MMFilterSettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "Filter.h"


/*

Class CMMFilter
    
    Naming: 

        CMMFilter stands for Main Mode Filter.
    
    Base class: 
        
        CIPSecFilter.
    
    Purpose of class:

        The class implements the common interface (IIPSecObjectImpl) for our provider
        for the WMI class called Nsp_MMFilterSettings (a concrete class).
    
    Design:

        (1) Just implements IIPSecObjectImpl, plus several helpers. Extremely simple design.
           
    
    Use:

        (1) You will never create an instance directly yourself. It's done by ATL CComObject<xxx>.

        (2) If you need to add a MM filter that is already created, call AddFilter.
            If you need to delete a MM filter, then call DeleteFilter.
        
        (3) All other use is always through IIPSecObjectImpl.
        
    Notes:


*/

 
class ATL_NO_VTABLE CMMFilter :
    public CIPSecFilter
{
protected:
    CMMFilter(){}
    virtual ~CMMFilter(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    //
    // methods common to all filter classes
    //

    static HRESULT AddFilter (
        IN bool         bPreExist, 
        IN PMM_FILTER   pMMFilter
        );

    static HRESULT DeleteFilter (
        IN PMM_FILTER pMMFilter
        );

private:

    virtual HRESULT CreateWbemObjFromFilter (
        IN  PMM_FILTER          pMMFilter, 
        OUT IWbemClassObject ** ppObj
        );

    HRESULT GetMMFilterFromWbemObj (
        IN  IWbemClassObject    * pObj, 
        OUT PMM_FILTER          * ppMMFilter, 
        OUT bool                * bExistFilter
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filtertun.cpp ===
// FilterTun.cpp: implementation for the WMI class Nsp_TunnelFilterSettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "FilterTr.h"
#include "FilterTun.h"
#include "NetSecProv.h"


/*
Routine Description: 

Name:

    CTunnelFilter::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pszQuery    - The query.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        (1) WBEM_NO_ERROR if instances are returned;

        (2) WBEM_S_NO_MORE_DATA if no instances are returned.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.

Notes:
    

*/

STDMETHODIMP 
CTunnelFilter::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    PTUNNEL_FILTER pFilter = NULL;
    return QueryFilterObject(pFilter, pszQuery, pCtx, pSink);
}



/*
Routine Description: 

Name:

    CTunnelFilter::DeleteInstance

Functionality:

    Will delete the wbem object (which causes to delete the IPSec tunnel filter.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    See template function comments for detail.


Notes:
    

*/

STDMETHODIMP 
CTunnelFilter::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    PTUNNEL_FILTER pFilter = NULL;

    return DeleteFilterObject(pFilter, pCtx, pSink);
}




/*
Routine Description: 

Name:

    CTunnelFilter::PutInstance

Functionality:

    Put a tunnel filter into SPD whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CTunnelFilter::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pInst == NULL || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
  
    bool bPreExist = false;

    //
    // for those filters that are created by ourselves (bPreExist == true)
    // we have our own way of allocating the filter, need to free it in our corresponding way
    //

    PTUNNEL_FILTER pTunnelFilter = NULL;
    HRESULT hr = GetTunnelFilterFromWbemObj(pInst, &pTunnelFilter, &bPreExist);

    //
    // if filter is successfully returned, then add it to SPD
    //

    if (SUCCEEDED(hr) && pTunnelFilter != NULL)
    {
        hr = AddFilter(bPreExist, pTunnelFilter);
        if (SUCCEEDED(hr))
        {
            //
            // deposit our information of the added filter
            //

            hr = OnAfterAddFilter(pTunnelFilter->pszFilterName, FT_Tunnel, pCtx);
        }

        //
        // release the filter
        //

        FreeFilter(&pTunnelFilter, bPreExist);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CTunnelFilter::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    See template function comments for detail.


Notes:
    

*/

STDMETHODIMP 
CTunnelFilter::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    PTUNNEL_FILTER pFilter = NULL;
    return GetWbemObject(pFilter, pCtx, pSink);
}


/*
Routine Description: 

Name:

    CTunnelFilter::CreateWbemObjFromFilter

Functionality:

    Given a SPD's tunnel filter, we will create a wbem object representing it.

Virtual:
    
    No.

Arguments:

    pTunnelFilter  - The SPD's tunnel filter object.

    ppObj          - Receives the wbem object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CTunnelFilter::CreateWbemObjFromFilter (
    IN  PTUNNEL_FILTER      pTunnelFilter,
    OUT IWbemClassObject ** ppObj
    )
{
    if (pTunnelFilter == NULL || ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // create a wbem object of this class that can be used to fill in properties
    //

    *ppObj = NULL;
    HRESULT hr = SpawnObjectInstance(ppObj);

    if (SUCCEEDED(hr))
    {
        //
        // fill in the base properties
        //

        hr = PopulateWbemPropertiesFromFilter(pTunnelFilter, *ppObj);
    }

    if (SUCCEEDED(hr))
    {
        //
        // for various IPSec APIs, it takes a pServerName parameter. If we pass NULL,
        // it is assumed to be local machine
        //

        PIPSEC_QM_POLICY pQMPolicy = NULL;

        DWORD dwResult = ::GetQMPolicyByID(NULL, pTunnelFilter->gPolicyID, &pQMPolicy);
        HRESULT hr = (dwResult == ERROR_SUCCESS) ? WBEM_NO_ERROR : WBEM_E_NOT_AVAILABLE;

        //
        // if policy is found, then populate the other transport filter properties
        // that are shared by tunnel filters.
        //

        if (SUCCEEDED(hr))
        {
            hr = CTransportFilter::PopulateTransportWbemProperties(pTunnelFilter, pQMPolicy, *ppObj);

            //
            // need to populate tunnel filter specific properties
            //

            //
            // deal with tunnel src address
            //

            CComBSTR bstrAddr;
            CComVariant var;

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pTunnelFilter->SrcTunnelAddr.uIpAddr, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = (*ppObj)->Put(g_pszTunnelSrcAddr, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            //
            // deal with tunnel dest subnet mask
            //

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pTunnelFilter->SrcTunnelAddr.uSubNetMask, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = (*ppObj)->Put(g_pszTunnelSrcSubnetMask, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            //
            // deal with tunnel src address type
            //

            if (SUCCEEDED(hr))
            {
                var = pTunnelFilter->SrcTunnelAddr.AddrType;
                hr = (*ppObj)->Put(g_pszTunnelSrcAddrType, 0, &var, CIM_EMPTY);
                var.Clear();
            }

            //
            // deal with tunnel dest address
            //

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pTunnelFilter->DesTunnelAddr.uIpAddr, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = (*ppObj)->Put(g_pszTunnelDestAddr, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            //
            // deal with tunnel dest subnet mask
            //

            if (SUCCEEDED(hr))
            {
                hr = MakeStringIPAddr(pTunnelFilter->DesTunnelAddr.uSubNetMask, &bstrAddr);
                if (SUCCEEDED(hr))
                {
                    var = bstrAddr.Detach();
                    hr = (*ppObj)->Put(g_pszTunnelDestSubnetMask, 0, &var, CIM_EMPTY);
                    var.Clear();
                }
            }

            //
            // deal with tunnel dest address type
            //

            if (SUCCEEDED(hr))
            {
                var = pTunnelFilter->DesTunnelAddr.AddrType;
                hr = (*ppObj)->Put(g_pszTunnelDestAddrType, 0, &var, CIM_EMPTY);
                var.Clear();
            }

        }
        ::SPDApiBufferFree(pQMPolicy);
    }

    //
    // we may have created the object, but some mid steps have failed,
    // so let's release the object.
    //

    if (FAILED(hr) && *ppObj != NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


/*
Routine Description: 

Name:

    CTunnelFilter::GetTunnelFilterFromWbemObj

Functionality:

    Will try to get the tunnel filter if this filter already exists.
    Otherwise, we will create a new one.

Virtual:
    
    No.

Arguments:

    pInst           - The wbem object object.

    ppTunnelFilter  - Receives the tunnel filter.

    pbPreExist      - Receives the information whether this object memory is allocated by SPD or not.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:


*/

HRESULT 
CTunnelFilter::GetTunnelFilterFromWbemObj (
    IN  IWbemClassObject * pInst,
    OUT PTUNNEL_FILTER   * ppTunnelFilter,
    OUT bool             * pbPreExist
    )
{

    //
    // Fill in the common filter properties. This function does most of the dirty work.
    // It tries to find the filter and fill in the common properties.
    //

    HRESULT hr = PopulateFilterPropertiesFromWbemObj(pInst, ppTunnelFilter, pbPreExist);

    //
    // we get the filter and now we need to update the properties
    //

    if (SUCCEEDED(hr))
    {
        //
        // get the policy
        //

        CComVariant var;
        hr = pInst->Get(g_pszQMPolicyName, 0, &var, NULL, NULL);
        if (SUCCEEDED(hr) && var.vt == VT_BSTR)
        {
            DWORD dwResumeHandle = 0;

            //
            // need to free this buffer
            //

            PIPSEC_QM_POLICY pQMPolicy = NULL;
            hr = FindPolicyByName(var.bstrVal, &pQMPolicy, &dwResumeHandle);

            if (SUCCEEDED(hr))
            {
                (*ppTunnelFilter)->gPolicyID = pQMPolicy->gPolicyID;

                //
                // release the buffer
                //

                ::SPDApiBufferFree(pQMPolicy);
            }

            var.Clear();

            //
            // Tunnel filter specific properties include some properties shared with transport filters,
            // that work is all done by PopulateTransportFilterProperties.
            //

            hr = CTransportFilter::PopulateTransportFilterProperties(*ppTunnelFilter, pInst);

            //
            // deal with tunnel src address
            //

            hr = pInst->Get(g_pszTunnelSrcAddr, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                hr = MakeULongIPAddr(var.bstrVal, &((*ppTunnelFilter)->SrcTunnelAddr.uIpAddr));
            }
            var.Clear();

            //
            // deal with tunnel src subnet mask
            //

            hr = pInst->Get(g_pszTunnelSrcSubnetMask, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                hr = MakeULongIPAddr(var.bstrVal, &((*ppTunnelFilter)->SrcTunnelAddr.uSubNetMask));
            }
            var.Clear();

            //
            // deal with tunnel src address type
            //

            hr = pInst->Get(g_pszTunnelSrcAddrType, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_I4)
            {
                (*ppTunnelFilter)->SrcTunnelAddr.AddrType = ADDR_TYPE(var.lVal);
            }
            var.Clear();

            //
            // deal with tunnel dest address
            //

            hr = pInst->Get(g_pszTunnelDestAddr, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                hr = MakeULongIPAddr(var.bstrVal, &((*ppTunnelFilter)->DesTunnelAddr.uIpAddr));
            }
            var.Clear();

            //
            // deal with tunnel dest subnet mask
            //

            hr = pInst->Get(g_pszTunnelDestSubnetMask, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_BSTR)
            {
                hr = MakeULongIPAddr(var.bstrVal, &((*ppTunnelFilter)->DesTunnelAddr.uSubNetMask));
            }
            var.Clear();

            //
            // deal with tunnel dest address type
            //

            hr = pInst->Get(g_pszTunnelDestAddrType, 0, &var, NULL, NULL);
            if (SUCCEEDED(hr) && var.vt == VT_I4)
            {
                (*ppTunnelFilter)->DesTunnelAddr.AddrType = ADDR_TYPE(var.lVal);
            }
            var.Clear();

        }
        else
            hr = WBEM_E_INVALID_OBJECT;
    }

    if (FAILED(hr) && *ppTunnelFilter != NULL)
    {
        FreeFilter(ppTunnelFilter, *pbPreExist);
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CTunnelFilter::AddFilter

Functionality:

    Will try to add the tunnel filter to SPD. The end result may be to modify
    an existing filter (if it already exists).

Virtual:
    
    No.

Arguments:

    bPreExist   - Whether this object memory is allocated by SPD or not.

    pTuFilter   - The Transport filter to add.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CTunnelFilter::AddFilter (
    IN bool             bPreExist,
    IN PTUNNEL_FILTER   pTuFilter
    )
{
    HANDLE hFilter = NULL;
    DWORD dwResult = ERROR_SUCCESS;

    HRESULT hr = WBEM_NO_ERROR;

    if (bPreExist)
    {
        //
        // if we are told that this filter already exists, we will try to modify it only.
        //

        dwResult = ::OpenTunnelFilterHandle(NULL, pTuFilter, &hFilter);
        if (dwResult == ERROR_SUCCESS)
        {
            dwResult = ::SetTunnelFilter(hFilter, pTuFilter);
        }
    }
    else
    {
        dwResult = ::AddTunnelFilter(NULL, 1, pTuFilter, &hFilter);
    }

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // $undone:shawnwu, we really need better error information
        // other than WBEM_E_FAILED. No one has come up with info as
        // how we can do that with WMI yet.
        //

        hr = ::IPSecErrorToWbemError(dwResult);
    }

    if (hFilter != NULL)
    {
        ::CloseTunnelFilterHandle(hFilter);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CMMFilter::DeleteFilter

Functionality:

    Will try to delete the tunnel filter from SPD. 

Virtual:
    
    No.

Arguments:

    pTunnelFilter   - The tunnel filter to delete.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: if the object is successfully deleted.

        (2) WBEM_S_FALSE: if the object doesn't exist.

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CTunnelFilter::DeleteFilter (
    IN PTUNNEL_FILTER pTunnelFilter
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    HANDLE hFilter = NULL;

    DWORD dwResult = ::OpenTunnelFilterHandle(NULL, pTunnelFilter, &hFilter);

    if (dwResult == ERROR_SUCCESS && hFilter != NULL)
    {
        dwResult = ::DeleteTunnelFilter(hFilter);
        if (dwResult != ERROR_SUCCESS)
        {
            hr = ::IPSecErrorToWbemError(dwResult);
        }
        else
        {
            //
            // once it is successfully deleted, we don't have to close it any more.
            //

            hFilter = NULL;
        }
    }
    else if (ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND == dwResult)
    {
        hr = WBEM_S_FALSE;
    }
    else
    {
        //
        // $undone:shawnwu, we really need better error information
        // other than WBEM_E_FAILED. No one has come up with info as
        // how we can do that with WMI yet.
        //

        hr = ::IPSecErrorToWbemError(dwResult);
    }

    if (hFilter != NULL)
    {
        ::CloseTunnelFilterHandle(hFilter);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\filtertun.h ===
//////////////////////////////////////////////////////////////////////
// FilterTun.h : Declaration of CTunnelFilter class which implements
// our WMI class Nsp_TunnelFilterSettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "Filter.h"

/*

Class CTunnelFilter
    
    Naming: 

        CTunnelFilter stands for Tunnel Filter.
    
    Base class: 
        
        CIPSecFilter.
    
    Purpose of class:

        The class implements the common interface (IIPSecObjectImpl) for our provider
        for the WMI class called Nsp_TunnelFilterSettings (a concrete class).
    
    Design:

        (1) Just implements IIPSecObjectImpl, plus several helpers. Extremely simple design.

        (2) Due to the factor that transport filters share some common properties with tunnel 
            filters (not vise versa), this class again has some static template functions
            that work for both types.
           
    
    Use:

        (1) You will never create an instance directly yourself. It's done by ATL CComObject<xxx>.

        (2) If you need to add a transport filter that is already created, call AddFilter.
            If you need to delete a transport filter, then call DeleteFilter.

        (3) Call the static template functions of CTransportFilter class for
            populating the common properties.
        
        (4) All other use is always through IIPSecObjectImpl.
        
    Notes:


*/

class ATL_NO_VTABLE CTunnelFilter :
    public CIPSecFilter
{

protected:

    CTunnelFilter(){}
    virtual ~CTunnelFilter(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );


    //
    // methods common to all filter classes
    //

    static HRESULT AddFilter (
        IN bool            bPreExist, 
        IN PTUNNEL_FILTER  pTrFilter
        );

    static HRESULT DeleteFilter (
        IN PTUNNEL_FILTER pTrFilter
        );

private:

    virtual HRESULT CreateWbemObjFromFilter (
        IN  PTUNNEL_FILTER      pTunnelFilter,
        OUT IWbemClassObject ** ppObj
        );

    HRESULT GetTunnelFilterFromWbemObj (
        IN  IWbemClassObject  * pInst,
        OUT PTUNNEL_FILTER    * ppTunnelFilter,
        OUT bool              * pbPreExist
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\globals.cpp ===
//////////////////////////////////////////////////////////////////////
// globals.cpp : Implementation for the globals
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 2/21/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#include "globals.h"

LPCWSTR pszRollbackAll          = L"RollbackAll";
LPCWSTR pszEmptyRollbackToken   = L"EmptyRollbackToken";
LPCWSTR pszCreateDefaultPolicy  = L"CreateDefaultPolicy";
LPCWSTR pszGetDefaultPolicyName = L"GetDefaultPolicyName";

//
// these are WMI class names to support IPSec
//

LPCWSTR pszNspGeneral               = L"Nsp_GeneralSettings";
LPCWSTR pszNspTcp                   = L"Nsp_TcpSettings";
LPCWSTR pszNspIPConfigure           = L"Nsp_IPConfigSettings";
LPCWSTR pszNspFilter                = L"Nsp_FilterSettings";
LPCWSTR pszNspTransportFilter       = L"Nsp_TransportFilterSettings";
LPCWSTR pszNspTunnelFilter          = L"Nsp_TunnelFilterSettings"; 
LPCWSTR pszNspMMFilter              = L"Nsp_MMFilterSettings";

LPCWSTR pszNspQMPolicy              = L"Nsp_QMPolicySettings";
LPCWSTR pszNspMMPolicy              = L"Nsp_MMPolicySettings";
LPCWSTR pszNspMMAuth                = L"Nsp_MMAuthSettings";
LPCWSTR pszNspExceptionPorts        = L"Nsp_ExceptionPorts";
LPCWSTR pszNspRollbackFilter        = L"Nsp_RollbackFilter";
LPCWSTR pszNspRollbackPolicy        = L"Nsp_RollbackPolicy";
LPCWSTR pszNspRollbackMMAuth        = L"Nsp_RollbackMMAuth";
LPCWSTR pszNspTranxManager          = L"Nsp_TranxManager";

//
// These are WMI class names to support SCW (Security Configuration Wizard)
//

LPCWSTR pszScwActiveSocket          = L"SCW_ActiveSocket";

//
// these are WMI class property names for IPSec
//

LPCWSTR g_pszFilterName             = L"FilterName";
LPCWSTR g_pszDirection              = L"Direction";
LPCWSTR g_pszFilterType             = L"FilterType";
LPCWSTR g_pszInterfaceType          = L"InterfaceType";
//LPCWSTR g_pszGenericFilter          = L"GenericFilter";
LPCWSTR g_pszCreateMirror           = L"CreateMirror";
LPCWSTR g_pszSrcAddr                = L"SrcAddr";
LPCWSTR g_pszSrcSubnetMask          = L"SrcSubnetMask";
LPCWSTR g_pszSrcAddrType            = L"SrcAddrType";
LPCWSTR g_pszDestAddr               = L"DestAddr";
LPCWSTR g_pszDestSubnetMask         = L"DestSubnetMask";
LPCWSTR g_pszDestAddrType           = L"DestAddrType";
                                    
LPCWSTR g_pszMMPolicyName           = L"MMPolicyName";
LPCWSTR g_pszMMAuthName             = L"MMAuthName";

LPCWSTR g_pszInboundFlag            = L"InboundFilterFlag";
LPCWSTR g_pszOutboundFlag           = L"OutboundFilterFlag";
LPCWSTR g_pszProtocol               = L"Protocol";
LPCWSTR g_pszSrcPort                = L"SrcPort";
LPCWSTR g_pszDestPort               = L"DestPort";
LPCWSTR g_pszQMPolicyName           = L"QMPolicyName";
LPCWSTR g_pszTunnelSrcAddr          = L"TunnelSrcAddr";
LPCWSTR g_pszTunnelSrcSubnetMask    = L"TunnelSrcSubnetMask";
LPCWSTR g_pszTunnelSrcAddrType      = L"TunnelSrcAddrType";
LPCWSTR g_pszTunnelDestAddr         = L"TunnelDestAddr";
LPCWSTR g_pszTunnelDestSubnetMask   = L"TunnelDestSubnetMask";
LPCWSTR g_pszTunnelDestAddrType     = L"TunnelDestAddrType";

LPCWSTR g_pszPolicyName             = L"PolicyName";
LPCWSTR g_pszPolicyFlag             = L"Flag";
LPCWSTR g_pszOfferCount             = L"OfferCount";
LPCWSTR g_pszKeyLifeTime            = L"KeyLifeTime";
LPCWSTR g_pszKeyLifeTimeKBytes      = L"KeyLifeTimeKBytes";

LPCWSTR g_pszSoftSAExpTime          = L"SoftSAExpTime";
LPCWSTR g_pszQMLimit                = L"QMLimit";
LPCWSTR g_pszDHGroup                = L"DHGroup";
LPCWSTR g_pszEncryptID              = L"EncryptID";
LPCWSTR g_pszHashID                 = L"HashID";

LPCWSTR g_pszPFSRequired            = L"PFSRequired";
LPCWSTR g_pszPFSGroup               = L"PFSGroup";
LPCWSTR g_pszNumAlgos               = L"NumAlgos";
LPCWSTR g_pszAlgoOp                 = L"AlgoOp";
LPCWSTR g_pszAlgoID                 = L"AlgoID";
LPCWSTR g_pszAlgoSecID              = L"AlgoSecID";

LPCWSTR g_pszAuthMethodID           = L"AuthMethodID";
LPCWSTR g_pszNumAuthInfos           = L"NumAuthInfos";

LPCWSTR g_pszAuthMethod             = L"AuthMethod";
LPCWSTR g_pszAuthInfoSize           = L"AuthInfoSize";
LPCWSTR g_pszAuthInfo               = L"AuthInfo";

LPCWSTR g_pszTokenGuid              = L"TokenGuid";
LPCWSTR g_pszAction                 = L"Action";
LPCWSTR g_pszPreviousData           = L"PreviousData";
LPCWSTR g_pszFilterGuid             = L"FilterGuid";
LPCWSTR g_pszPolicyType             = L"PolicyType";

LPCWSTR g_pszRollback               = L"Rollback";
LPCWSTR g_pszClearAll               = L"ClearAll";

LPCWSTR g_pszEncryption             = L"Encryption";

//
// constant strings for SPD data
//

LPCWSTR g_pszIP_ADDRESS_ME          = L"IP_ADDRESS_ME";
LPCWSTR g_pszIP_ADDRESS_MASK_NONE   = L"IP_ADDRESS_MASK_NONE";
LPCWSTR g_pszSUBNET_ADDRESS_ANY     = L"SUBNET_ADDRESS_ANY";
LPCWSTR g_pszSUBNET_MASK_ANY        = L"SUBNET_MASK_ANY";

//
// these are WMI class property names for SCW
//

LPCWSTR g_pszPort                   = L"Port";
//LPCWSTR g_pszProtocol               = L"Protocol";
LPCWSTR g_pszAddress                = L"Address";
LPCWSTR g_pszForeignAddress         = L"ForeignAddress";
LPCWSTR g_pszForeignPort            = L"ForeignPort";
LPCWSTR g_pszState                  = L"State";		//Listening, Established, TIME_WAIT
LPCWSTR g_pszProcessID              = L"ProcessID";
LPCWSTR g_pszImageName              = L"ImageName";
LPCWSTR g_pszImageTitleBar          = L"ImageTitleBar";
LPCWSTR g_pszNTService              = L"NTService";


//
// these are default quick mode policy names
//

LPCWSTR g_pszDefQMPolicyNegNone     = L"SSR_DEFAULT_QM_POLICY_NEG_NONE";
LPCWSTR g_pszDefQMPolicyNegRequest  = L"SSR_DEFAULT_QM_POLICY_NEG_REQUEST";
LPCWSTR g_pszDefQMPolicyNegRequire  = L"SSR_DEFAULT_QM_POLICY_NEG_REQUIRE";
LPCWSTR g_pszDefQMPolicyNegMax      = L"SSR_DEFAULT_QM_POLICY_NEG_MAX";



/*
Routine Description: 

Name:

    CheckImpersonationLevel

Functionality:

    Check the impersonation level of the thread to see if the level is at least SecurityImpersonation.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    Success:

        WBEM_NO_ERROR if the impersonation level is at least SecurityImpersonation.

    Failure:

        (1) WBEM_E_ACCESS_DENIED.

        (2) WBEM_E_FAILED if somehow the thread token can't opened or the token information
            can't be queried.

Notes:

    Make sure that you call this function at the begining of each provider's public interface function.

    $undone:shawnwu, is there a performance concern?
*/

HRESULT 
CheckImpersonationLevel ()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if (SUCCEEDED(::CoImpersonateClient()))
    {
        //
        // Now, let's check the impersonation level.  First, get the thread token
        //

        HANDLE hThreadTok;
        DWORD dwImp, dwBytesReturned;

        if(!::OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok ))
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
            if(::GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwImp, sizeof(DWORD), &dwBytesReturned))
            {
                //
                // Is the impersonation level Impersonate?
                //

                if (dwImp >= SecurityImpersonation) 
                {
                    hr = WBEM_NO_ERROR;
                }
                else 
                {
                    hr = WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }

            ::CloseHandle(hThreadTok);
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CheckSafeArraySize

Functionality:

    Check to see if the variant has really what the caller wants: a safearray with given count of elements.

Virtual:
    
    No.

Arguments:

    pVar    - The variant.

    lCount  - The claimed size of the variant's array.

    plLB    - Receives the lower bound of the variant's array.

    plUB    - Receives the upper bound of the variant's array.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        (1) WBEM_E_VALUE_OUT_OF_RANGE if the claimed size for the variant doesn't match
            what it really holds.

        (2) WBEM_E_INVALID_PARAMETER if input parameters are not valid.

Notes:

*/

HRESULT 
CheckSafeArraySize (
    IN  VARIANT * pVar,
    IN  long      lCount,
    OUT long    * plLB,
    OUT long    * plUB
    )
{
    //
    // we must have a valid variant, and its type must be an array,
    // and its array value must not be null.
    //

    if (pVar == NULL || 
        (pVar->vt & VT_ARRAY) != VT_ARRAY || 
        pVar->parray == NULL ||
        plLB == NULL || 
        plUB == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *plLB = 0;
    *plUB = 0;

    HRESULT hr = ::SafeArrayGetLBound(pVar->parray, 1, plLB);
    if (SUCCEEDED(hr))
    {
        hr = ::SafeArrayGetUBound(pVar->parray, 1, plUB);
    }

    if (SUCCEEDED(hr) && lCount != (*plUB - *plLB + 1) )
    {
        hr = WBEM_E_VALUE_OUT_OF_RANGE;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


/*
Routine Description: 

Name:

    GetDWORDSafeArrayElements

Functionality:

    Get all DWORD safearray elements from the variant to the provided DWORD array buffer.

Virtual:
    
    No.

Arguments:

    pVar        - The variant.

    lCount      - The count the caller wants.

    ppValArray  - Receives the wanted number of DWORD from the variant.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        (1) WBEM_E_VALUE_OUT_OF_RANGE if the claimed size for the variant doesn't match
            what it really holds.

        (2) WBEM_E_INVALID_PARAMETER if input parameters are not valid.

Notes:

    (1) Caller should call CheckSafeArraySize to make sure that this variant does have
        that many elements.

    (2) Caller is resonsible for making sure that pValArray has enough room for the dwords

*/

HRESULT 
GetDWORDSafeArrayElements (
    IN  VARIANT * pVar,
    IN  long      lCount,
    OUT DWORD   * pValArray
    )
{
    //
    // sanity check
    //

    if (pVar == NULL || 
        (pVar->vt & VT_ARRAY) != VT_ARRAY || 
        pVar->parray == NULL ||
        (lCount > 0 && pValArray == NULL) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    long lLB;
    HRESULT hr = ::SafeArrayGetLBound(pVar->parray, 1, &lLB);

    long lIndexes[1];

    //
    // get the values from the safearray. Since safearray's index may not be 0-based,
    // we have to start from its lower bound. But our out parameter (array) is 0-based.
    // Be aware of this offset!
    //

    for (long l = lLB; l < lLB + lCount; l++)
    {
        lIndexes[0] = l;

        hr = ::SafeArrayGetElement(pVar->parray, lIndexes, &(pValArray[l - lLB]));

        //
        // we don't try to continue if we can't get one of them
        //

        if (FAILED(hr))
        {
            break;
        }
    }

    return hr;
}




/*
Routine Description: 

Name:

    FindMMAuthMethodsByID

Functionality:

    Given a guid, we will try to find all the main mode auth methods using the resume handle,
    which is a opaque data.

Virtual:
    
    No.

Arguments:

    pszGuid         - The Main Mode Authentication Method's ID. This should be represent a guid.

    ppAuthMethod    - Receives the MM_AUTH_METHODS data.

    pdwResumeHandle - In-bound: the current handle for this call. Out-bound: the next handle for the call. 

Return Value:

    Success:

        Various success codes. Use SUCCEEDED(hr) to test.

    Failure:

        Various error codes. 

Notes:
    

*/

HRESULT 
FindMMAuthMethodsByID (
    IN LPCWSTR             pszGuid,
    OUT PMM_AUTH_METHODS * ppAuthMethod,
    IN OUT DWORD         * pdwResumeHandle
    )
{
    GUID gID = GUID_NULL;

    //
    // We allow pssGuid to be invalid, in that case, we simply return any mm auth method.
    //

    HRESULT hr = WBEM_NO_ERROR;

    *ppAuthMethod = NULL;

    if (pszGuid != NULL && *pszGuid != L'\0')
    {
        hr = ::CLSIDFromString((LPWSTR)pszGuid, &gID);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwCount = 0;

        //
        // Enumerate all mm auth methods in a hope to find a matching one.
        //

        DWORD dwResult = ::EnumMMAuthMethods(NULL, ppAuthMethod, 1, &dwCount, pdwResumeHandle);

        hr = WBEM_E_NOT_FOUND;

        while (dwResult == ERROR_SUCCESS && dwCount > 0)
        {
            if (gID == GUID_NULL || (*ppAuthMethod)->gMMAuthID == gID)
            {
                hr = WBEM_NO_ERROR;
                break;
            }
            else
            {
                //
                // not this one, then release this one and find the next
                //

                ::SPDApiBufferFree(*ppAuthMethod);

                *ppAuthMethod = NULL;
                dwCount = 0;

                dwResult = ::EnumMMAuthMethods(NULL, ppAuthMethod, 1, &dwCount, pdwResumeHandle);
            }
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    GetClassEnum

Functionality:

    A helper function to create a class numeration object for the given name.

Virtual:
    
    No.

Arguments:

    pNamespace      - The namespace where the enum object is requested.

    pszClassName    - The class we want to enumerate.

    ppEnum          - Receives the enumerator. 

Return Value:

    Other than WBEM_E_INVALID_PARAMETER and WBEM_E_OUT_OF_MEMORY, 
    it returns whatever pNamespace->ExecQuery returns. 

Notes:
    

*/

HRESULT 
GetClassEnum (
    IN IWbemServices           * pNamespace,
    IN LPCWSTR                   pszClassName,
    OUT IEnumWbemClassObject  ** ppEnum
    )
{
    if ( NULL == pNamespace   || 
         NULL == ppEnum       || 
         NULL == pszClassName || 
         L'\0' == *pszClassName )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppEnum = NULL;


    //
    // format the query
    //

    LPCWSTR pszQueryFmt = L"SELECT * FROM %s";

    DWORD dwLength = wcslen(pszQueryFmt) + wcslen(pszClassName) + 1;

    CComBSTR bstrQuery;
    bstrQuery.m_str = ::SysAllocStringLen(NULL, dwLength);

    if (bstrQuery.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    swprintf(bstrQuery.m_str, pszQueryFmt, pszClassName);

    //
    // execute the query
    //

    return pNamespace->ExecQuery(L"WQL", 
                                 bstrQuery,
                                 WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                 NULL, 
                                 ppEnum
                                 );
}



/*
Routine Description: 

Name:

    DeleteRollbackObjects

Functionality:

    Given the class name for rollback objects, we will delete all such rollback objects from WMI.

Virtual:
    
    No.

Arguments:

    pNamespace      - The namespace the objects belong.

    pszClassName    - The name of the class of the objects to be deleted.

Return Value:

    Success:
        
        WBEM_NO_ERROR

    Failure:

        Various error codes.

Notes:
    
    If during deletion we see an error, the deletion will continue, but we will return the first
    such error.

*/

HRESULT 
DeleteRollbackObjects (
    IN IWbemServices  * pNamespace,
    IN LPCWSTR          pszClassName
    )
{
    if ( NULL == pNamespace     || 
         NULL == pszClassName   || 
         L'\0' == *pszClassName )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CComPtr<IEnumWbemClassObject> srpEnum;

    HRESULT hr = ::GetClassEnum(pNamespace, pszClassName, &srpEnum);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // go through all found classes
    //

    CComPtr<IWbemClassObject> srpObj;
    ULONG nEnum = 0;

    //
    // This will keep track of the first error
    //

    HRESULT hrError = WBEM_NO_ERROR;

    //
    // srpEnum->Next returns WBEM_S_FALSE once the end has reached.
    //

    hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);

    while (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj)
    {
        CComVariant varPath;

        if (SUCCEEDED(srpObj->Get(L"__RelPath", 0, &varPath, NULL, NULL)) && varPath.vt == VT_BSTR)
        {
            //
            // now delete the instance
            //

            hr = pNamespace->DeleteInstance(varPath.bstrVal, 0, NULL, NULL);
            if (FAILED(hr) && SUCCEEDED(hrError))
            {
                hrError = hr;
            }
        }

        //
        // so that we can reuse it
        //

        srpObj.Release();

        //
        // next object
        //

        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
    }

    //
    // make our return code easy since we are not going to pass different success codes
    //

    if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    //
    // we will return the first error
    //

    return FAILED(hrError) ? hrError : hr;
}


/*
Routine Description: 

Name:

    IPSecErrorToWbemError

Functionality:

    Translate IPSec error into Wbem error

Virtual:
    
    No.

Arguments:

    dwErr   - Error code from IPSec APIs

Return Value:

    various Wbem error code

Notes:
    
    WMI team simply can't give us enough information as how we can provide our own error text.
    This is not a good translation. Need more support from WMI team in order for us to support
    custom error information.

*/

HRESULT IPSecErrorToWbemError (
    IN DWORD dwErr
    )
{
    //
    // this is the last resort, not a good code at all
    //

    HRESULT hr = WBEM_E_FAILED;
    switch (dwErr)
    {
    case ERROR_IPSEC_QM_POLICY_EXISTS:
    case ERROR_IPSEC_MM_POLICY_EXISTS:
    case ERROR_IPSEC_MM_FILTER_EXISTS:
    case ERROR_IPSEC_TRANSPORT_FILTER_EXISTS:
    case ERROR_IPSEC_MM_AUTH_EXISTS:
    case ERROR_IPSEC_TUNNEL_FILTER_EXISTS:

        hr = WBEM_E_ALREADY_EXISTS;
        break;

    case ERROR_IPSEC_QM_POLICY_NOT_FOUND:
    case ERROR_IPSEC_MM_POLICY_NOT_FOUND:
    case ERROR_IPSEC_MM_FILTER_NOT_FOUND:
    case ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND:
    case ERROR_IPSEC_MM_AUTH_NOT_FOUND:
    case ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND:
    case ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND:
    case ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND:
    case ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND:
        hr = WBEM_E_NOT_FOUND;
        break;

    case ERROR_IPSEC_QM_POLICY_IN_USE:
    case ERROR_IPSEC_MM_POLICY_IN_USE:
    case ERROR_IPSEC_MM_AUTH_IN_USE:
        hr = WBEM_E_OVERRIDE_NOT_ALLOWED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\ipsecbase.cpp ===
// IPSecBase.cpp: implementation of the base class for various Network
// security WMI provider for IPSec
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "NetSecProv.h"
#include "IPSecBase.h"
#include "NspTCP.h"
#include "Config.h"
#include "Filter.h"
#include "FilterTr.h"
#include "FilterTun.h"
#include "FilterMM.h"
#include "PolicyQM.h"
#include "PolicyMM.h"
#include "AuthMM.h"
#include "ExceptionPort.h"
#include "ActiveSocket.h"

const DWORD IP_ADDR_LENGTH = 16;

const DWORD GUID_STRING_LENGTH = 39;

//---------------------------------------------------------------------------
// CIPSecBase is an abstract class. But it does implement some common
// functionality for all our classes for WMI classes we provide
//---------------------------------------------------------------------------



/*
Routine Description: 

Name:

    CIPSecBase::InitMembers

Functionality:

    Initializing the members. Just cache some interface pointers.

Virtual:
    
    No.

Arguments:

    pCtx            - COM interface pointer given by WMI. We need to pass this around for various WMI API's.

    pNamespace      - COM interface pointer representing our namespace.

    pKeyChain       - COM interface pointer representing the key chain created by ourselves.

    pszWmiClassName - The name of the WMI class this class is created to represent.

Return Value:

    WBEM_NO_ERROR 

Notes:
    
    This is really an internal function. We don't bother to check validity of the parameters.
*/

HRESULT 

CIPSecBase::InitMembers (
    IN IWbemContext   * pCtx,
    IN IWbemServices  * pNamespace,
    IN IIPSecKeyChain * pKeyChain,
    IN LPCWSTR          pszWmiClassName
    )
{
    if (pCtx != NULL)
    {
        m_srpCtx = pCtx;
    }

    m_srpNamespace = pNamespace;

    m_srpKeyChain.Release();

    m_srpKeyChain = pKeyChain;

    //
    // This Empty call is not really necessary unless the caller has mistakenly called it more than once
    //

    m_bstrWMIClassName.Empty();

    m_bstrWMIClassName = pszWmiClassName;

    return WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CIPSecBase::CreateObject

Functionality:

    Will create various C++ classes and return the IIPSecObjectImpl interface to the caller.

    IIPSecObjectImpl is our common interface for all C++ classes representing WMI classes.

Virtual:
    
    No.

Arguments:

    pNamespace  - COM interface pointer representing our namespace.

    pCtx        - COM interface pointer given by WMI. We need to pass this around for various WMI API's.

    pKeyChain   - COM interface pointer representing the key chain created by ourselves.

    ppObjImp    - COM interface pointer representing our object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes. 

Notes:
    

*/

HRESULT 
CIPSecBase::CreateObject (
    IN  IWbemServices     * pNamespace,
    IN  IIPSecKeyChain    * pKeyChain,
    IN  IWbemContext      * pCtx,
    OUT IIPSecObjectImpl ** ppObjImp
)
{
    //
    // We can't take a blank class name. Since the caller is asking
    // for a class, the out parameter can't be NULL either.
    //

    if (ppObjImp == NULL || pKeyChain == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CComBSTR bstrClsName;
    HRESULT hr = pKeyChain->GetClassName(&bstrClsName);

    if (FAILED(hr))
    {
        return hr;
    }
    
    *ppObjImp = NULL;

    hr = WBEM_E_NOT_SUPPORTED;

    CIPSecBase* pObj = NULL;

    //
    // based on the class name, we will call the same static (template) function
    // CreateIPSecObject for all the classes that implement our WMI classes. 
    // This CreateIPSecObject function will create the appropriate C++ class
    // and return back its IIPSecObjectImpl interface.
    // The first parameter is simply a template parameter, not used otherwise.
    //
    
    if (_wcsicmp(bstrClsName, pszNspTcp) == 0)
    {
        CNspTCP * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspIPConfigure) == 0)
    {
        CIPSecConfig * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspTransportFilter) == 0)
    {
        CTransportFilter * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspTunnelFilter) == 0)
    {
        CTunnelFilter * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspMMFilter) == 0)
    {
        CMMFilter * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspQMPolicy) == 0)
    {
        CQMPolicy * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspMMPolicy) == 0)
    {
        CMMPolicy * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspMMAuth) == 0)
    {
        CAuthMM * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
    else if (_wcsicmp(bstrClsName, pszNspExceptionPorts) == 0)
    {
        CExceptionPort * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
    }
	else if (_wcsicmp(bstrClsName, pszScwActiveSocket) == 0)
	{
        CActiveSocket * pNotUsed = NULL;
        hr = CreateIPSecObject(pNotUsed, pNamespace, pKeyChain, bstrClsName, pCtx, ppObjImp);
	}

    //else if (_wcsicmp(bstrClsName, pszNspRollbackFilter) == 0)
    //{
    //}
    //else if (_wcsicmp(bstrClsName, pszNspRollbackPolicy) == 0)
    //{
    //}


    if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CIPSecBase::SpawnObjectInstance

Functionality:

    Will create a WMI class object (representing this class) that can be used to fill in properties.

Virtual:
    
    No.

Arguments:

    ppObj  - Out parameter that receives the successfully spawned object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes. 

Notes:
    

*/

HRESULT 
CIPSecBase::SpawnObjectInstance (
    OUT IWbemClassObject ** ppObj
    )
{
    if (ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    *ppObj = NULL;

    HRESULT hr = WBEM_NO_ERROR;

    //
    // m_srpClassForSpawning is class definition, which can be used to spawn such instances
    // that can be used to fill in properties.
    //

    if (m_srpClassDefinition == NULL)
    {
        //
        // GetObject needs a bstr!
        //

        hr = m_srpNamespace->GetObject(m_bstrWMIClassName, 0, m_srpCtx, &m_srpClassDefinition, NULL);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_srpClassDefinition->SpawnInstance(0, ppObj);
    }

    //
    // We trust SpawnInstance's return value. If it is successful, it must give us a valid object pointer.
    //

    if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CIPSecBase::SpawnRollbackInstance

Functionality:

    Will create a WMI class object that can be used to fill in properties. This class object
    represents a rollback object of the given name. This is just a helper.

Virtual:
    
    No.

Arguments:

    pszClassName    - The rollback instance's class name. It is not true that the rollback class's name
                      and the class's name are in a 1 - 1 correspondence.

    ppObj           - Out parameter that receives the successfully spawned object. 

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes. 

Notes:
    

*/

HRESULT 
CIPSecBase::SpawnRollbackInstance (
    IN LPCWSTR              pszClassName,
    OUT IWbemClassObject ** ppObj
    )
{
    if (ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppObj = NULL;

    HRESULT hr = WBEM_NO_ERROR;

    CComPtr<IWbemClassObject> srpSpawnObj;

    CComBSTR bstrClsName(pszClassName);

    //
    // get the definition of the requested class, this definition object
    // will be able to spawn an instance.
    //

    hr = m_srpNamespace->GetObject(bstrClsName, 0, m_srpCtx, &srpSpawnObj, NULL);

    if (SUCCEEDED(hr))
    {
        hr = srpSpawnObj->SpawnInstance(0, ppObj);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\globals.h ===
//////////////////////////////////////////////////////////////////////
// globals.h : Declaration of some global const and functions
// Copyright (c)1997-2001 Microsoft Corporation
//
// some global definitions
// Original Create Date: 2/21/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "precomp.h"
#include "netseccore.h"

extern CComModule _Module;

#include <atlcom.h>

#include "resource.h"       // main symbols

extern LPCWSTR pszRollbackAll;
extern LPCWSTR pszEmptyRollbackToken;
extern LPCWSTR pszCreateDefaultPolicy;
extern LPCWSTR pszGetDefaultPolicyName;


const DWORD Guid_Buffer_Size = 64;

using namespace std;

//
// these are the WMI class names
//

extern LPCWSTR pszNspGeneral;
extern LPCWSTR pszNspTcp;
extern LPCWSTR pszNspIPConfigure;
extern LPCWSTR pszNspFilter;
extern LPCWSTR pszNspTransportFilter;
extern LPCWSTR pszNspTunnelFilter;
extern LPCWSTR pszNspMMFilter;
extern LPCWSTR pszNspQMPolicy;
extern LPCWSTR pszNspMMPolicy;
extern LPCWSTR pszNspMMAuth;       
extern LPCWSTR pszNspExceptionPorts;
extern LPCWSTR pszNspRollbackFilter; 
extern LPCWSTR pszNspRollbackPolicy;
extern LPCWSTR pszNspRollbackMMAuth;
extern LPCWSTR pszNspTranxManager;

//
// the following are names of classes for SCW
//

extern LPCWSTR pszScwActiveSocket;

//
// these are the WMI class property names
//

extern LPCWSTR g_pszFilterName;
extern LPCWSTR g_pszDirection;
extern LPCWSTR g_pszFilterType;
extern LPCWSTR g_pszInterfaceType;
//extern LPCWSTR g_pszGenericFilter;
extern LPCWSTR g_pszCreateMirror;
extern LPCWSTR g_pszSrcAddr;
extern LPCWSTR g_pszSrcSubnetMask;
extern LPCWSTR g_pszSrcAddrType;
extern LPCWSTR g_pszDestAddr;
extern LPCWSTR g_pszDestSubnetMask;
extern LPCWSTR g_pszDestAddrType;

extern LPCWSTR g_pszMMPolicyName;
extern LPCWSTR g_pszMMAuthName;

extern LPCWSTR g_pszInboundFlag;
extern LPCWSTR g_pszOutboundFlag;
extern LPCWSTR g_pszProtocol;
extern LPCWSTR g_pszSrcPort;
extern LPCWSTR g_pszDestPort;
extern LPCWSTR g_pszQMPolicyName;
extern LPCWSTR g_pszTunnelSrcAddr;
extern LPCWSTR g_pszTunnelSrcSubnetMask;
extern LPCWSTR g_pszTunnelSrcAddrType;
extern LPCWSTR g_pszTunnelDestAddr;
extern LPCWSTR g_pszTunnelDestSubnetMask;
extern LPCWSTR g_pszTunnelDestAddrType;

extern LPCWSTR g_pszPolicyName;
extern LPCWSTR g_pszPolicyFlag;
extern LPCWSTR g_pszOfferCount;
extern LPCWSTR g_pszSoftSAExpTime;
extern LPCWSTR g_pszKeyLifeTime;
extern LPCWSTR g_pszKeyLifeTimeKBytes;
extern LPCWSTR g_pszQMLimit;
extern LPCWSTR g_pszDHGroup;
extern LPCWSTR g_pszEncryptID;
extern LPCWSTR g_pszHashID;

extern LPCWSTR g_pszPFSRequired;
extern LPCWSTR g_pszPFSGroup;
extern LPCWSTR g_pszNumAlgos;
extern LPCWSTR g_pszAlgoOp;
extern LPCWSTR g_pszAlgoID;
extern LPCWSTR g_pszAlgoSecID;

extern LPCWSTR g_pszAuthMethodID;
extern LPCWSTR g_pszNumAuthInfos;
extern LPCWSTR g_pszAuthMethod;
extern LPCWSTR g_pszAuthInfoSize;
extern LPCWSTR g_pszAuthInfo;

extern LPCWSTR g_pszTokenGuid;
extern LPCWSTR g_pszAction;
extern LPCWSTR g_pszPreviousData;
extern LPCWSTR g_pszFilterGuid;
extern LPCWSTR g_pszFilterType;
extern LPCWSTR g_pszPolicyType;

extern LPCWSTR g_pszRollback;
extern LPCWSTR g_pszClearAll;

extern LPCWSTR g_pszEncryption;

//
// constant string for SPD data
//

extern LPCWSTR g_pszIP_ADDRESS_ME;
extern LPCWSTR g_pszIP_ADDRESS_MASK_NONE;
extern LPCWSTR g_pszSUBNET_ADDRESS_ANY;
extern LPCWSTR g_pszSUBNET_MASK_ANY;

//
// these are WMI class property names for SCW
//

extern LPCWSTR g_pszPort;
//extern LPCWSTR g_pszProtocol;
extern LPCWSTR g_pszAddress;
extern LPCWSTR g_pszForeignAddress;
extern LPCWSTR g_pszForeignPort;
extern LPCWSTR g_pszState;		//Listening, Established, TIME_WAIT
extern LPCWSTR g_pszProcessID;
extern LPCWSTR g_pszImageName;
extern LPCWSTR g_pszImageTitleBar;
extern LPCWSTR g_pszNTService;

//
// these are default quick mode policy names
//

extern LPCWSTR g_pszDefQMPolicyNegNone;
extern LPCWSTR g_pszDefQMPolicyNegRequest;
extern LPCWSTR g_pszDefQMPolicyNegRequire;
extern LPCWSTR g_pszDefQMPolicyNegMax;


//
// This defines what action has taken place
//

enum ActionEnum
{
    Action_Add          = 0,
    Action_Delete       = 1,
    Action_CallMethod   = 2,
};


//
// Some global helper functions
//

HRESULT CheckImpersonationLevel();

HRESULT CheckSafeArraySize(VARIANT* pVar, long lCount, long* plLB, long* plUP);

HRESULT GetDWORDSafeArrayElements (
                                  VARIANT   * pVar, 
                                  long        lCount, 
                                  DWORD     * pValArray
                                  );


HRESULT FindMMAuthMethodsByID (
                              IN     LPCWSTR             pszGuid,
                              OUT    PMM_AUTH_METHODS  * ppAuthMethod,
                              IN OUT DWORD             * pdwResumeHandle
                              );

HRESULT GetClassEnum (
                     IN  IWbemServices          * pNamespace,
                     IN  LPCWSTR                  pszClassName,
                     OUT IEnumWbemClassObject  ** pEnum
                     );

HRESULT DeleteRollbackObjects (
                              IN IWbemServices  * pNamespace,
                              IN LPCWSTR          pszClassName
                              );

HRESULT IPSecErrorToWbemError (
                              IN DWORD dwErr
                              );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\ipsecbase.h ===
//////////////////////////////////////////////////////////////////////
// IPSecBase.h : Declaration of the base classes for the Network
// security WMI provider for SCE
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/6/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"

extern CComVariant g_varRollbackGuid;

extern const DWORD IP_ADDR_LENGTH;

extern const DWORD GUID_STRING_LENGTH;

interface ISceKeyChain;


/*

Class description
    
    Naming: 

        CIPSecBase stands for Base for IPSec.
    
    Base class: 
        
        (1) CComObjectRootEx for threading model and IUnknown.

        (2) IIPSecObjectImpl which implements the common interface for all C++ classes
            representing WMI classes.
    
    Purpose of class:

        (1) Allow our provider class (CNetSecProv) to easily create our objects that has 
            implementation for the various WMI classes they represent.

        (2) Being a base for all our C++ classes that has implementation for various WMI
            classes. 
    
    Design:

        (1) CreateObject function allows the caller to get an IIPSecObjectImpl object. 
            IIPSecObjectImpl is the uniform interface this provider uses. Everything
            the provider does for WMI goes through this IIPSecObjectImpl.
           
        (2) To provide base class support for its sub-classes, this class implements
            the following facilities:

                (a) It caches all the necessary COM interfaces coming from WMI.

                (b) It knows the key chain object (which holds key property information
                    chain object may be about the WMI object the C++ is trying to represent).
                    This key given by the provider, but sometimes the sub-class needs
                    to modify the key chain according its own unique need.

                (c) Provide helper for spawn an instance (SpawnObjectInstance) that can be 
                    used to fill in properties.

                (d) Provide helper for spawn a rollback instance (SpawnRollbackInstance) 
                    that can be used to fill in properties.

                (e) Provide helper for finding policies by name (FindPolicyByName).

    
    Use:

        (1) For provider (CNetSecProv), all it needs to call is CreateObject. Since that is 
            a static function, it doesn't need to create an instance for the need.

        (2) For sub-classes, just call the needed function. Of course, all static functions
            are available for the sub-classes' static functions.

    Notes:

        (1) It contains several template functions. This reduces the duplicate code.

        (2) InitMembers is really just intended for private use. But since it is used inside
            a template function, we have to make it public. Since unrelated classes can never
            create this class (its constructor is protected!), this should not be a problem
            because the method is not part of the interface this class gives out (IIPSecObjectImpl),
            so no body but its sub-classes can call it.

        

*/

class ATL_NO_VTABLE CIPSecBase :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IIPSecObjectImpl
{

protected:

    CIPSecBase(){}
    virtual ~CIPSecBase(){}

BEGIN_COM_MAP(CIPSecBase)
    COM_INTERFACE_ENTRY(IIPSecObjectImpl)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CIPSecBase )
DECLARE_REGISTRY_RESOURCEID(IDR_NETSECPROV)

public:

    //
    // IIPSecObjectImpl methods:
    // This is an abstract class.
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        ) = 0;

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) = 0;

    STDMETHOD(ExecuteMethod) ( 
        IN BSTR               bstrMethod,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) = 0;

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) = 0;


    static HRESULT CreateObject (
        IN  IWbemServices     * pNamespace,
        IN  IIPSecKeyChain    * pKeyChain,
        IN  IWbemContext      * pCtx,
        OUT IIPSecObjectImpl ** ppObjImp
        );

    //
    // some template functions
    //

    
    /*
    Routine Description: 

    Name:

        CIPSecBase::FindPolicyByName

    Functionality:

        Enumerate all policies. If the name is given, then we will give the policy.
        If the name is empty, then we will just give back the current one and advance
        the enumeration handle (pdwResumeHandle).

    Virtual:
    
        No.

    Arguments:

        pszName         - The name of the policy. Optional.

        ppPolicy        - Receives the policy. This can be PIPSEC_MM_POLICY or PIPSEC_QM_POLICY.
                          Caller needs to free this by calling SPDApiBufferFree(*ppPolicy);

        pdwResumeHandle - In-bound: the current handle, out-bound: the next handle.

    Return Value:

        Success:

            WBEM_NO_ERROR

        Failure:

            (1) WBEM_E_INVALID_PARAMETER if ppPolicy == NULL or pdwResumeHandle == NULL.

            (2) WBEM_E_NOT_FOUND if the policy is not found.

    Notes:
    
        (1) Main Mode and Quick Mode polices have slightly different data strctures. Perfect
            place to write this template function to reduce duplicate code.
    
        (2) Caller needs to free any policy returned by calling SPDApiBufferFree; Don't just
            delete/free it. This is a good place, if time allowed, to write a wrapper to 
            automatically call SPDApiBufferFree inside its destructor.


    */

    template <class Policy>
    static HRESULT FindPolicyByName (
        IN      LPCWSTR    pszName          OPTIONAL,
        OUT     Policy  ** ppPolicy,
        IN OUT  DWORD    * pdwResumeHandle
        )
    {
        if (ppPolicy == NULL || pdwResumeHandle == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppPolicy = NULL;

        DWORD dwCount = 0;

        //
        // get the current policy (determined by pdwResumeHandle)
        //

        DWORD dwResult = EnumPolicies(NULL, ppPolicy, &dwCount, pdwResumeHandle);

        while (dwResult == ERROR_SUCCESS && dwCount > 0)
        {
            if (pszName == NULL || *pszName == L'\0' || _wcsicmp((*ppPolicy)->pszPolicyName, pszName) == 0)
            {
                //
                // if no name is given or the names match (case-insentively), this is it.
                //

                return WBEM_NO_ERROR;
            }
            else
            {
                //
                // names are given but they don't match
                //

                //
                // Free the current policy
                //

                ::SPDApiBufferFree(*ppPolicy);
                *ppPolicy = NULL;
                dwCount = 0;

                //
                // get the next
                //

                dwResult = EnumPolicies(NULL, ppPolicy, &dwCount, pdwResumeHandle);
            }
        }

        return WBEM_E_NOT_FOUND;
    };

    HRESULT InitMembers (
        IN IWbemContext   * pCtx,
        IN IWbemServices  * pNamespace,
        IN IIPSecKeyChain * pKeyChain,
        IN  LPCWSTR         pszWmiClassName
        );


protected:

    //
    // some template functions
    //

    /*
    Routine Description: 

    Name:

        CIPSecBase::CreateIPSecObject 

    Functionality:

        Private helper to create an IIPSecObjectImpl object (our C++ classes that 
        implement their corresponding WMI classes). Normally, to do this needs a
        class name. However, the class name is captured inside the key chain.

    Virtual:
    
        No.

    Arguments:

        pSub            - The template type. Not used otherwise.

        pNamespace      - COM interface pointer for the namespace (given by WMI).

        pKeyChain       - COM interface pointer representing the query's key properties.

        pszWmiClassName - The name of the WMI class this class is created to represent.

        pCtx            - COM interface pointer given by WMI that needs to be passed around
                          for various WMI API's.

        ppObjImp        - Receives the object.

    Return Value:

        Success:

            WBEM_NO_ERROR

        Failure:

            (1) WBEM_E_INVALID_PARAMETER if pNamespace == NULL or pKeyChain == NULL or ppObjImp == NULL.

            (2) WBEM_E_NOT_SUPPORTED if the class that supports the WMI class name is not properly 
                implemented for IID_IIPSecObjectImpl interface.

    Notes:

    */

    template <class Sub>
    static HRESULT CreateIPSecObject (
        IN  Sub               * pSub,
        IN  IWbemServices     * pNamespace,
        IN  IIPSecKeyChain    * pKeyChain,
        IN  LPCWSTR             pszWmiClassName,
        IN  IWbemContext      * pCtx,
        OUT IIPSecObjectImpl ** ppObjImp
        )
    {
        //
        // pSub is just used for type
        //

        if (NULL == pNamespace  ||
            NULL == pKeyChain   ||
            NULL == ppObjImp)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppObjImp = NULL;

        //
        // This is a confusing ATL CComObject creation sequence. Basically,
        // CComObject will create the proper class and wrapped it with
        // its implementation for the IUnknown. Our C++ classes (like CMMFilter)
        // is never the leaf in ATL world. In other word, you never create
        // classes like CMMFilter directly. Instead, the most derived class
        // is CComObject< >. Take a while to get used too.
        //

        CComObject<Sub> *pTheSubClass;
        HRESULT hr = CComObject< Sub >::CreateInstance(&pTheSubClass);

        if (SUCCEEDED(hr))
        {
            hr = pTheSubClass->QueryInterface(IID_IIPSecObjectImpl, (void**)ppObjImp);

            if (S_OK == hr)
            {
                hr = pTheSubClass->InitMembers(pCtx, pNamespace, pKeyChain, pszWmiClassName);
            }
            else
            {
                hr = WBEM_E_NOT_SUPPORTED;
            }
        }

        return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
    }

    /*
    Routine Description: 

    Name:

        CIPSecBase::EnumPolicies

    Functionality:

        Helper for FindPolicyByName because different mode's enumeration functions have different names.
        In order for our template function to work, it has been wrapped up.

        See EnumMMPolicies for details.
        
    */

    static DWORD EnumPolicies (
        IN      LPCWSTR             pszServer, 
        OUT     PIPSEC_MM_POLICY  * ppPolicy, 
        OUT     DWORD             * pdwCount, 
        IN OUT  DWORD             * pdwResumeHandle
        )
    {
        //
        // bad IPSec API prototype causes this casting
        //

        return ::EnumMMPolicies((LPWSTR)pszServer, ppPolicy, 1, pdwCount, pdwResumeHandle);
    }

    /*
    Routine Description: 

    Name:

        CIPSecBase::EnumPolicies

    Functionality:

        Helper for FindPolicyByName because different mode's enumeration functions have different names.
        In order for our template function to work, it has been wrapped up.

        See EnumQMPolicies for details.
        
    */

    static DWORD EnumPolicies (
        IN      LPCWSTR             pszServer, 
        OUT     PIPSEC_QM_POLICY  * ppPolicy, 
        OUT     DWORD             * pdwCount, 
        IN OUT  DWORD             * pdwResumeHandle
        )
    {
        //
        // bad IPSec API prototype causes this casting
        //

        return ::EnumQMPolicies((LPWSTR)pszServer, ppPolicy, 1, pdwCount, pdwResumeHandle);
    }

    HRESULT SpawnObjectInstance (
        OUT IWbemClassObject **ppObj
        );

    HRESULT SpawnRollbackInstance (
        IN  LPCWSTR             pszClassName,
        OUT IWbemClassObject ** ppObj
        );


    CComPtr<IWbemServices> m_srpNamespace;
    CComPtr<IWbemContext> m_srpCtx;
    CComPtr<IIPSecKeyChain> m_srpKeyChain;

    CComBSTR m_bstrWMIClassName;

private:

    CComPtr<IWbemClassObject> m_srpClassDefinition;
};



/*
// implementation for the WMI class called Nsp_RollbackFilterSettings
class CNspRollbackFilter
{
    [key]   string  FilterGUID;
            string  StorePath;
            string  FilterName;
            uint32  dwFilterType;  // tunnel, transport, Mainmode
            string  PolicyGUID;
            string  AuthGUID;
};

// implementation for the WMI class called Nsp_RollbackPolicySettings
class CNspRollbackPolicy
{
    [key]   string  PolicyGUID;
            uint32  dwPolicyType;  // MMPolicy, MMAuth, QMPolicy
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\ipsecparser.h ===
// ipsecparser.h: path and query parser provided by IPSec provider
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "globals.h"

//
// trivial wrapper just to ease the memory management and initialization
//

class CPropValuePair
{
public:
    CPropValuePair::CPropValuePair() : pszKey(NULL)
    {
        ::VariantInit(&varVal);
    }
    CPropValuePair::~CPropValuePair()
    {
        delete [] pszKey;
        ::VariantClear(&varVal);
    }

    LPWSTR pszKey;
    VARIANT varVal;
};


/*

Class description

    Naming: 
        CIPSecPathParser stands for SCE Path Parser.

    Base class: 
        CComObjectRootEx for threading model and IUnknown.
        CComCoClass for class factory support.
        IIPSecPathParser and IIPSecKeyChain for custom interfaces.

    Purpose of class:
        (1) We wish to simplify path parsing. This is our effort of creation IPSec path parser
            that can be externally CoCreateInstance'd.
        (2) To support a more friendly and uniform interface, both IPSec path parser and IPSec query 
            let client use the service via IIPSecKeyChain.

    Design:
        (1) See IIPSecPathParser and IIPSecKeyChain. Almost everything is captured by these two interfaces.
        (2) This is not a directly instantiatable class. See Use section for creation steps.
        (3) Since paths only contains class name and key properties, we opt to use a less fancier data
            structure - vector to store the properties' (name,value) pair. The nature of key properties
            being normally limited in number should offer you comfort in using this data structure.
        (4) Class name and namespace are cached in separate string members.

    Use:
        (1) For external users:

            (a) CoCreateInstance of our class (CLSID_IPSecPathParser) and request for IID_IIPSecPathParser.
            (b) Call ParsePath to parse the path string.
            (c) QI IIPSecKeyChain and use the key chain to access the results.

        (2) For internal users:

            (a) CComObject<CIPSecPathParser>::CreateInstance(&pPathParser);
            (b) QI for IIPSecPathParser.
            (c) ParsePath
            (d) QI IIPSecKeyChain and use the key chain to access the results.
            See CRequestObject's use for sample.

    Notes:
        (1) This class is not intended to be further derived. It is a final class. It's 
            destructor is thus not virtual!
        (2) Refer to MSDN and ATL COM programming for the use of ATL.
        (3) The caller can't cache the interface pointer (IIPSecKeyChain) and do another parsing (which
            is allowed) and expect the previous IIPSecKeyChain interface to work for the previous parsing.

*/

class ATL_NO_VTABLE CIPSecPathParser 
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CIPSecPathParser, &CLSID_IPSecPathParser>,
      public IIPSecPathParser,
      public IIPSecKeyChain
{
public:

BEGIN_COM_MAP(CIPSecPathParser)
    COM_INTERFACE_ENTRY(IIPSecPathParser)
    COM_INTERFACE_ENTRY(IIPSecKeyChain)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CIPSecPathParser )
DECLARE_REGISTRY_RESOURCEID(IDR_NETSECPROV)

protected:
    CIPSecPathParser();
    ~CIPSecPathParser();

public:

    //
    // IIPSecPathParser
    //

    STDMETHOD(ParsePath) ( 
                IN LPCWSTR strObjectPath
                );
    
    //
    // IIPSecKeyChain
    //

    STDMETHOD(GetKeyPropertyCount) ( 
                OUT DWORD *pCount
                );
    
    STDMETHOD(GetNamespace) ( 
                OUT BSTR *pbstrNamespace
                );

    STDMETHOD(GetClassName) ( 
                OUT BSTR *pbstrClassName
                );
    
    STDMETHOD(GetKeyPropertyValue) ( 
                IN LPCWSTR pszKeyPropName,
                OUT VARIANT *pvarValue
                );
    
    STDMETHOD(GetKeyPropertyValueByIndex) ( 
                IN DWORD dwIndex,
                OUT BSTR* pbstrKeyPropName, 
                OUT VARIANT *pvarValue
                );

private:
    void Cleanup();

    std::vector<CPropValuePair*> m_vecKeyValueList;

    LPWSTR m_pszClassName;
    LPWSTR m_pszNamespace;

};

/*

Class description

    Naming: 

        CIPSecQueryParser stands for IPSec Query Parser.

    Base class: 

        (1) CComObjectRootEx for threading model and IUnknown.
        (2) CComCoClass for class factory support.
        (3) IIPSecQueryParser and IIPSecKeyChain for custom interfaces.

    Purpose of class:

        (1) We wish to simplify query parsing. This is our effort of creation IPSec query parser
            that can be externally CoCreateInstance'd.
        (2) To support a more friendly and uniform interface, both IPSec path parser and IPSec query 
            let client use the service via IIPSecKeyChain.

    Design:

        (1) See IIPSecQueryParser and IIPSecKeyChain. Almost everything is captured by these two interfaces.
        (2) This is not a directly instantiatable class. See Use section for creation steps.
        (3) Parsing a query is a very complicated matter. WMI support of complicated queries are limited
            too. We are very pragmatic about it: we only cares about the class names (actually, WMI limits
            its queries to unary - one class name only) and one important property - let's call it the querying
            property (m_bstrQueryingPropName). For IPSec use, that querying property is almost always 
            the store path.
        (4) Class names are cached in string list member m_vecClassList.
        (5) The query property values (in string) will be cached in a string list member - m_vecQueryingPropValueList.

    Use:

        (1) For external users:
            (a) CoCreateInstance of our class (CLSID_IPSecQueryParser) and request for IID_IIPSecQueryParser.
            (b) Call ParseQuery to parse the query.
            (c) QI IIPSecKeyChain and use the key chain to access the results.

        (2) For internal users:
            (a) CComObject<CIPSecPathParser>::CreateInstance(&pPathParser);
            (b) QI for IIPSecQueryParser.
            (c) Call ParseQuery to parse the query.
            (d) QI IIPSecKeyChain and use the key chain to access the results.
            See CRequestObject's use for sample.

    Notes:

        (1) This class is not intended to be further derived. It is a final class. It's 
            destructor is thus not virtual!
        (2) Refer to MSDN and ATL COM programming for the use of ATL.

*/

class ATL_NO_VTABLE CIPSecQueryParser 
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CIPSecQueryParser, &CLSID_IPSecQueryParser>,
      public IIPSecQueryParser,
      public IIPSecKeyChain
{
public:

BEGIN_COM_MAP(CIPSecQueryParser)
    COM_INTERFACE_ENTRY(IIPSecQueryParser)
    COM_INTERFACE_ENTRY(IIPSecKeyChain)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CIPSecQueryParser )
DECLARE_REGISTRY_RESOURCEID(IDR_NETSECPROV)

protected:
    CIPSecQueryParser();
    ~CIPSecQueryParser();

public:

    //
    // IIPSecQueryParser
    //

    STDMETHOD(ParseQuery) ( 
                 IN LPCWSTR strQuery,
                 IN LPCWSTR strQueryPropName
                 );
    
    STDMETHOD(GetClassCount) (
                 OUT DWORD* pdwCount
                 )
        {
            if (pdwCount == NULL)
            {
                return E_INVALIDARG;
            }

            *pdwCount = m_vecClassList.size();
            return S_OK;
        }

    STDMETHOD(GetClassName) (
                IN int     iIndex,
                OUT BSTR * pbstrClassName
                );
    
    STDMETHOD(GetQueryingPropertyValueCount) (
                 OUT DWORD* pdwCount
                 )
        {
            if (pdwCount == NULL)
            {
                return E_INVALIDARG;
            }

            *pdwCount = m_vecQueryingPropValueList.size();
            return S_OK;
        }

    STDMETHOD(GetQueryingPropertyValue) (
                IN int     iIndex,
                OUT BSTR * pbstrQPValue
                );

    //
    // IIPSecKeyChain
    //

    STDMETHOD(GetKeyPropertyCount) ( 
                OUT DWORD *pCount
                )
        {
            if (pCount == NULL)
            {
                return E_INVALIDARG;
            }
            *pCount = m_vecQueryingPropValueList.size() > 0 ? 1 : 0;
            return S_OK;
        }
    
    STDMETHOD(GetNamespace) ( 
                OUT BSTR *pbstrNamespace
                )
        {
            *pbstrNamespace = NULL;
            return WBEM_E_NOT_SUPPORTED;
        }

    STDMETHOD(GetClassName) ( 
                OUT BSTR *pbstrClassName
                )
        {
            //
            // since we only support single class query, this must be it
            //

            return GetClassName(0, pbstrClassName);
        }
    
    STDMETHOD(GetKeyPropertyValue) ( 
                IN LPCWSTR    pszKeyPropName,
                OUT VARIANT * pvarValue
                );
    
    STDMETHOD(GetKeyPropertyValueByIndex) ( 
                IN  DWORD     dwIndex,
                OUT BSTR    * pbstrKeyPropName,
                OUT VARIANT * pvarValue
                )
        {
            if (pbstrKeyPropName == NULL || pvarValue == NULL)
            {
                return E_INVALIDARG;
            }

            *pbstrKeyPropName = NULL;
            ::VariantInit(pvarValue);

            return WBEM_E_NOT_SUPPORTED;
        }


private:

    void Cleanup();

    HRESULT ExtractClassNames (
                              SWbemRpnEncodedQuery *pRpn
                              );

    HRESULT ExtractQueryingProperties (
                                      SWbemRpnEncodedQuery *pRpn, 
                                      LPCWSTR strQueryPropName
                                      );

    HRESULT GetQueryPropFromToken (
                                  SWbemRpnQueryToken *pRpnQueryToken, 
                                  LPCWSTR strQueryPropName
                                  );

    std::vector<LPWSTR> m_vecClassList;
    std::vector<LPWSTR> m_vecQueryingPropValueList;

    CComBSTR m_bstrQueryingPropName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\iputil.cpp ===
//////////////////////////////////////////////////////////////////////
// IPUtil.cpp : Implementation for the socket related util functions
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 5/16/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#include "IPUtil.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>

#include <Mgmtapi.h>



//
// for active socket
//

//
// The following section is copied from \nt\net\tcpip\commands\common2\snmpinfo.c
// that implements the common helper functions inside declared inside \nt\net\tcpip\commands\common2\common2.h,
// which is now copied into our header ActiveSocket.h
//


ulong verbose = 0;

//
// Definitions
//

#define MAX_ID_LENGTH           50
#define MAX_RETRY_COUNT         10

// Interface ID values

#define ID_IF_INDEX             1
#define ID_IF_DESC              2
#define ID_IF_TYPE              3
#define ID_IF_MTU               4
#define ID_IF_SPEED             5
#define ID_IF_PHYSADDR          6
#define ID_IF_ADMINSTATUS       7
#define ID_IF_OPERSTATUS        8
#define ID_IF_LASTCHANGE        9
#define ID_IF_INOCTETS          10
#define ID_IF_INUCASTPKTS       11
#define ID_IF_INNUCASTPKTS      12
#define ID_IF_INDISCARDS        13
#define ID_IF_INERRORS          14
#define ID_IF_INUKNOWNPROTOS    15
#define ID_IF_OUTOCTETS         16
#define ID_IF_OUTUCASTPKTS      17
#define ID_IF_OUTNUCASTPKTS     18
#define ID_IF_OUTDISCARDS       19
#define ID_IF_OUTERRORS         20
#define ID_IF_OUTQLEN           21

// IP ID Values

#define ID_IP_FORWARDING        1
#define ID_IP_DEFAULTTTL        2
#define ID_IP_INRECEIVES        3
#define ID_IP_INHDRERRORS       4
#define ID_IP_INADDRERRORS      5
#define ID_IP_FORWDATAGRAMS     6
#define ID_IP_INUNKNOWNPROTOS   7
#define ID_IP_INDISCARDS        8
#define ID_IP_INDELIVERS        9
#define ID_IP_OUTREQUESTS       10
#define ID_IP_OUTDISCARDS       11
#define ID_IP_OUTNOROUTES       12
#define ID_IP_REASMTIMEOUTS     13
#define ID_IP_REASMREQDS        14
#define ID_IP_REASMOKS          15
#define ID_IP_REASMFAILS        16
#define ID_IP_FRAGOKS           17
#define ID_IP_FRAGFAILS         18
#define ID_IP_FRAGCREATES       19
#define ID_IP_ADDRTABLE         20
#define ID_IP_ROUTETABLE        21
#define ID_IP_ARPTABLE          22
#define ID_IP_ROUTINGDISCARDS   23

// IPAddr ID Values

#define ID_IPADDR_ADDR          1
#define ID_IPADDR_INDEX         2
#define ID_IPADDR_MASK          3
#define ID_IPADDR_BCASTADDR     4
#define ID_IPADDR_REASMSIZE     5

// Route ID values

#define ID_ROUTE_DEST           1
#define ID_ROUTE_IFINDEX        2
#define ID_ROUTE_METRIC1        3
#define ID_ROUTE_METRIC2        4
#define ID_ROUTE_METRIC3        5
#define ID_ROUTE_METRIC4        6
#define ID_ROUTE_NEXTHOP        7
#define ID_ROUTE_TYPE           8
#define ID_ROUTE_PROTO          9
#define ID_ROUTE_AGE            10
#define ID_ROUTE_MASK           11
#define ID_ROUTE_METRIC5        12

// ARP ID Values

#define ID_ARP_IFINDEX          1
#define ID_ARP_PHYSADDR         2
#define ID_ARP_NETADDR          3
#define ID_ARP_TYPE             4

// ICMP ID Values

#define ID_ICMP_INMSGS                  1
#define ID_ICMP_INERRORS                2
#define ID_ICMP_INDESTUNREACHES         3
#define ID_ICMP_INTIMEEXCDS             4
#define ID_ICMP_INPARMPROBS             5
#define ID_ICMP_INSRCQUENCHS            6
#define ID_ICMP_INREDIRECTS             7
#define ID_ICMP_INECHOS                 8
#define ID_ICMP_INECHOREPS              9
#define ID_ICMP_INTIMESTAMPS            10
#define ID_ICMP_INTIMESTAMPREPS         11
#define ID_ICMP_INADDRMASKS             12
#define ID_ICMP_INADDRMASKREPS          13
#define ID_ICMP_OUTMSGS                 14
#define ID_ICMP_OUTERRORS               15
#define ID_ICMP_OUTDESTUNREACHES        16
#define ID_ICMP_OUTTIMEEXCDS            17
#define ID_ICMP_OUTPARMPROBS            18
#define ID_ICMP_OUTSRCQUENCHS           19
#define ID_ICMP_OUTREDIRECTS            20
#define ID_ICMP_OUTECHOS                21
#define ID_ICMP_OUTECHOREPS             22
#define ID_ICMP_OUTTIMESTAMPS           23
#define ID_ICMP_OUTTIMESTAMPREPS        24
#define ID_ICMP_OUTADDRMASKS            25
#define ID_ICMP_OUTADDRMASKREPS         26

// TCP ID Values

#define ID_TCP_RTOALGORITHM     1
#define ID_TCP_RTOMIN           2
#define ID_TCP_RTOMAX           3
#define ID_TCP_MAXCONN          4
#define ID_TCP_ACTIVEOPENS      5
#define ID_TCP_PASSIVEOPENS     6
#define ID_TCP_ATTEMPTFAILS     7
#define ID_TCP_ESTABRESETS      8
#define ID_TCP_CURRESTABS       9
#define ID_TCP_INSEGS           10
#define ID_TCP_OUTSEGS          11
#define ID_TCP_RETRANSSEGS      12
#define ID_TCP_CONNTABLE        13
#define ID_TCP_INERRS           14
#define ID_TCP_OUTRSTS          15

// TCP CONN ID Values

#define ID_TCPCONN_STATE        1
#define ID_TCPCONN_LOCALADDR    2
#define ID_TCPCONN_LOCALPORT    3
#define ID_TCPCONN_REMOTEADDR   4
#define ID_TCPCONN_REMOTEPORT   5

// UDP ID Values

#define ID_UDP_INDATAGRAMS      1
#define ID_UDP_NOPORTS          2
#define ID_UDP_INERRORS         3
#define ID_UDP_OUTDATAGRAMS     4
#define ID_UDP_CONNTABLE        5

// UDP CONN ID Values

#define ID_UDPCONN_LOCALADDR    1
#define ID_UDPCONN_LOCALPORT    2


//
// Structure Definitions
//

typedef struct _OIDdef {
    ulong  Length;
    ulong  Val[MAX_ID_LENGTH];
    ulong  EntElemOffset;
    ulong  BackOffset;
} OIDdef;


//
// Local Function Prototypes
//

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size );

void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );

void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );

void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid );

void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid );

void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );

void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid );

void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );

void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );

void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );

void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );

//
// Global Variables
//

// These are used to create object id's


OIDdef PreambleDef   = { 6, { 1,  3,  6, 1, 2, 1 },  0, 0 };
OIDdef IfInfoDef     = { 4, { 2,  2,  1, 1       },  9, 2 };
OIDdef IPInfoDef     = { 2, { 4,  1              },  7, 1 };
OIDdef IPAddrInfoDef = { 4, { 4,  20, 1, 1       },  9, 2 };
OIDdef RouteInfoDef  = { 4, { 4,  21, 1, 1       },  9, 2 };
OIDdef ARPInfoDef    = { 4, { 4,  22, 1, 1       },  9, 2 };
OIDdef ICMPInfoDef   = { 2, { 5,  1,             },  7, 1 };
OIDdef TCPInfoDef    = { 2, { 6,  1              },  7, 1 };
OIDdef TCPConnDef    = { 4, { 6, 13,  1, 1       },  9, 2 };
OIDdef UDPInfoDef    = { 2, { 7,  1              },  7, 1 };
OIDdef UDPConnDef    = { 4, { 7,  5,  1, 1       },  9, 2 };

// These are used to hold the addresses of the functions we use in inetmib1.dll

FARPROC   gQueryAddr;
FARPROC   gInitAddr;


//
// Exported Functions
//


//*****************************************************************************
//
// Name:        GetTable
//
// Description: Gets a consistent table from snmp.  Consistency is achieved by
//              reading the table, reading the table a second time and
//              comparing the two.  If they match, we are done.  If they don't
//              match, we read the table again and compare again.  Repeating
//              until we have a match, or our retry count exceeds a threshold.
//
// Parameters:  ulong Type: type of table to get.
//              ulong *pResult: pointer to location to receive the result code.
//
// Returns:     void *: NULL if some error, otherwise pointer to table.
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Removed while loop and pList1.
//*****************************************************************************

void *GetTable( ulong Type, ulong *pResult )
{
    GenericTable   *pList2;
    ulong   Result;
    ulong   RetryCount = 0;
    ulong   Size;

    if( verbose ){
        fprintf(stderr, "GetTable: type = %d\n", Type );
    }

    if ( Type > TYPE_UDPCONN )
    {
        *pResult = ERROR_INVALID_PARAMETER;
        return ( NULL );
    }

    // Allocate memory for the list heads

    switch ( Type )
    {
    case TYPE_IF:
        Size = sizeof( IfEntry ) + MAX_IFDESCR_LEN;
        break;

    case TYPE_IP:
        Size = sizeof( IpEntry );
        break;

    case TYPE_IPADDR:
        Size = sizeof( IpAddrEntry );
        break;

    case TYPE_ROUTE:
        Size = sizeof( RouteEntry );
        break;

    case TYPE_ARP:
        Size = sizeof( ArpEntry );
        break;

    case TYPE_ICMP:
        Size = sizeof( IcmpEntry );
        break;

    case TYPE_TCP:
        Size = sizeof( TcpEntry );
        break;

    case TYPE_TCPCONN:
        Size = sizeof( TcpConnEntry );
        break;

    case TYPE_UDP:
        Size = sizeof( UdpEntry );
        break;

    case TYPE_UDPCONN:
        Size = sizeof( UdpConnEntry );
        break;

    }

    // Don't need pList1 - MohsinA, 18-Feb-97.

    pList2 = (GenericTable *)SNMP_malloc( Size );
    if ( pList2 == NULL )
    {
        *pResult = ERROR_NOT_ENOUGH_MEMORY;
        return ( NULL );
    }

    InitializeListHead( &pList2->ListEntry );

    // Read the table into List2

    Result = ReadTable( pList2, Type, Size );
    if ( Result != NO_ERROR )
    {
        FreeTable( pList2 );
        *pResult = Result;
        return ( NULL );
    }


    // Useless while loop removed. - MohsinA, 18-Feb-97.

    *pResult = NO_ERROR;
    return ( pList2 );
}


//*****************************************************************************
//
// Name:        FreeTable
//
// Description: Free all entries in the list, including the list head.
//
// Parameters:  GenericTable *pList: pointer to head of list.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void FreeTable( GenericTable *pList )
{
    GenericTable  *pTmp;
    LIST_ENTRY    *pTmpList;

    while ( !IsListEmpty( &pList->ListEntry ) )
    {
        pTmpList = RemoveHeadList( &pList->ListEntry );
        pTmp = CONTAINING_RECORD( pTmpList,
                                  GenericTable,
                                  ListEntry );
        SNMP_free( pTmp );
    }

    SNMP_free( pList );
}


//*****************************************************************************
//
// Name:        MapSnmpErrorToNt
//
// Description: Given an Snmp error, return the 'equivalent' Nt error.
//
// Parameters:  ulong ErrCode: Snmp error code.
//
// Returns:     ulong: Nt error code.
//
// History:
//  01/05/93    JayPh   Created.
//
//*****************************************************************************

ulong MapSnmpErrorToNt( ulong ErrCode )
{
    switch ( ErrCode )
    {
    case SNMP_ERRORSTATUS_NOERROR:
        return ( NO_ERROR );

    case SNMP_ERRORSTATUS_TOOBIG:
        return ( ERROR_INVALID_PARAMETER );

    case SNMP_ERRORSTATUS_NOSUCHNAME:
        return ( ERROR_INVALID_PARAMETER );

    case SNMP_ERRORSTATUS_BADVALUE:
        return ( ERROR_INVALID_PARAMETER );

    case SNMP_ERRORSTATUS_READONLY:
        return ( ERROR_INVALID_ACCESS );

    case SNMP_ERRORSTATUS_GENERR:
        return ( ERROR_INVALID_PARAMETER );

    }
    return ( ERROR_INVALID_PARAMETER );
}


//
// Internal Functions
//

//*****************************************************************************
//
// Name:        ReadTable
//
// Description: Queries the MIB and builds a table representing the data we are
//              interested in.
//
// Parameters:  GenericTable *pList: address of unitialized head of the entry
//                      list.
//              ulong Type: type of table we want.
//              ulong Size: size of a table entry.
//
// Returns:     ulong: NO_ERROR if no error, and table is built.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size )
{
    AsnInteger          GetNextReq = ASN_RFC1157_GETNEXTREQUEST;
    RFC1157VarBind      item;
    RFC1157VarBindList  VarBinds = { &item, 1 };
    AsnObjectIdentifier oidBackup;
    AsnInteger          ErrorStatus = 0;
    AsnInteger          ErrorIndex = 0;
    UINT              *pId;
    GenericTable       *pTable;
    ulong               LastField = 0;
    uchar              *pTmp;
    ulong               i;
    OIDdef             *pOid;
    UINT               BreakLoop = FALSE;

    if( verbose ){
        fprintf(stderr,"ReadTable: type = %d\n", Type);
    }

    // Walk SNMP database, building local table.

    pId = (UINT *)SNMP_malloc( (sizeof( ulong ) * MAX_ID_LENGTH) );
    if ( pId == NULL )
    {
        return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    item.name.ids = pId;

    // Build OID from preamble and table-specific suffix

    // Copy preamble

    for ( i = 0; i < PreambleDef.Length; i++ )
    {
        *pId++ = PreambleDef.Val[i];
    }

    // Get pointer to table-specific info

    switch ( Type )
    {
    case TYPE_IF:
        pOid = &IfInfoDef;
        break;

    case TYPE_IP:
        pOid = &IPInfoDef;
        break;

    case TYPE_IPADDR:
        pOid = &IPAddrInfoDef;
        break;

    case TYPE_ROUTE:
        pOid = &RouteInfoDef;
        break;

    case TYPE_ARP:
        pOid = &ARPInfoDef;
        break;

    case TYPE_ICMP:
        pOid = &ICMPInfoDef;
        break;

    case TYPE_TCP:
        pOid = &TCPInfoDef;
        break;

    case TYPE_TCPCONN:
        pOid = &TCPConnDef;
        break;

    case TYPE_UDP:
        pOid = &UDPInfoDef;
        break;

    case TYPE_UDPCONN:
        pOid = &UDPConnDef;
        break;

    }

    // Copy table-specific info

    for ( i = 0; i < pOid->Length; i++ )
    {
        *pId++ = pOid->Val[i];
    }

    item.name.idLength = PreambleDef.Length + pOid->Length;
    item.value.asnType = ASN_NULL;

    pTable = pList;

    // Walk the mib until the table-specific termination condition is met.

    while( 1 )
    {
        // Get next

        SnmpExtensionQuery( SNMP_PDU_GETNEXT, &VarBinds, &ErrorStatus, &ErrorIndex );

        if( verbose )
        {
            int   q;

            fprintf(stderr,"value=%8d oid= ", item.value.asnValue.number );

            //
            // Print the object name
            //

            LPSTR String = NULL;
            int err = SnmpMgrOidToStr ( &item.name, &String );

            if( SNMPAPI_ERROR != err ){
                fprintf(stderr," %s ", String );
            }
            SnmpUtilMemFree( String );

            if ( (verbose > 1) ){

                //
                // Print the oid, in ``1.3.6.1.2.1'' style.
                //

                for ( q = 0; q < (int) item.name.idLength; q++ ){

                    // Must align the output to read huge tables.

                    if( q < 6 ){
                        fprintf( stderr,"%d.", item.name.ids[q]);
                    }else if( q < 9 ){
                        fprintf( stderr,"%2d.", item.name.ids[q]);
                    }else{
                        fprintf( stderr,"%3d.", item.name.ids[q]);
                    }
                }
            }
            fprintf(stderr,"\n");

        }


        if ( ErrorStatus != 0 )
        {
            SnmpUtilVarBindFree( &item );
            return ( MapSnmpErrorToNt( ErrorStatus ) );
        }

        // We want to break out of this while loop if the defining part of the
        // OID changes

        if ( item.name.idLength < ( PreambleDef.Length + pOid->Length ) )
        {
            break;
        }

        for ( i = PreambleDef.Length;
              i < PreambleDef.Length + pOid->Length - pOid->BackOffset;
              i++ )
        {
            if ( item.name.ids[i] != pOid->Val[i - PreambleDef.Length] )
            {
                BreakLoop = TRUE;
                break;
            }
        }

        if ( BreakLoop )
        {
            break;
        }

        // We want to ignore certain entries.  EG: the TCP statistics will also
        // return the TCP connection table, which we don't want (there is a
        // separate Type code for that).

        switch ( Type )
        {
        case TYPE_IP:
            if ( ( item.name.ids[pOid->EntElemOffset] == ID_IP_ADDRTABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ROUTETABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ARPTABLE ) )
            {
                continue;
            }
            break;

        case TYPE_TCP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_TCP_CONNTABLE )
            {
                continue;
            }
            break;

        case TYPE_UDP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_UDP_CONNTABLE )
            {
                continue;
            }
            break;

        }

        // Entry handling:
        //
        // There are 3 cases to consider:
        // 1. If the list is empty, OR at the end of the list AND the
        //    CurrField == LastField.
        //   Then add a new entry to the list.
        // 2. CurrField != LastField.
        //   Then reset pointer to start of the list.
        // 3. Otherwise
        //   Then go to next entry in the list.

        if ( ( pTable == pList ) ||
             ( ( pTable->ListEntry.Flink == &pList->ListEntry ) &&
               ( item.name.ids[pOid->EntElemOffset] == LastField ) ) )
        {
            // Add new entry to table

            pTable = (GenericTable *)SNMP_malloc( Size );
            if ( pTable == NULL )
            {
                SnmpUtilVarBindFree( &item );
                return ( ERROR_NOT_ENOUGH_MEMORY );
            }

            InsertTailList( &pList->ListEntry, &pTable->ListEntry );
        }
        else if ( item.name.ids[pOid->EntElemOffset] != LastField )
        {
            // Reset pointer to start of list

            pTable = CONTAINING_RECORD( pList->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }
        else
        {
            // Move pointer to next entry in list

            pTable = CONTAINING_RECORD( pTable->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }

        LastField = item.name.ids[pOid->EntElemOffset];

        // Save info in our list.  pTable points to desired entry.

        switch ( Type )
        {
        case TYPE_IF:
            SaveData_IF( pTable, item, pOid );
            break;

        case TYPE_IP:
            SaveData_IP( pTable, item, pOid );
            break;

        case TYPE_IPADDR:
            SaveData_IPAddr( pTable, item, pOid );
            break;

        case TYPE_ROUTE:
            SaveData_ROUTE( pTable, item, pOid );
            break;

        case TYPE_ARP:
            SaveData_ARP( pTable, item, pOid );
            break;

        case TYPE_ICMP:
            SaveData_ICMP( pTable, item, pOid );
            break;

        case TYPE_TCP:
            SaveData_TCP( pTable, item, pOid );
            break;

        case TYPE_TCPCONN:
            SaveData_TCPCONN( pTable, item, pOid );
            break;

        case TYPE_UDP:
            SaveData_UDP( pTable, item, pOid );
            break;

        case TYPE_UDPCONN:
            SaveData_UDPCONN( pTable, item, pOid );
            break;

        }

        SnmpUtilOidCpy( &oidBackup, &(item.name));
        SnmpUtilVarBindFree( &item );
        item.name.idLength = oidBackup.idLength;
        item.name.ids = oidBackup.ids;
    }

    SnmpUtilVarBindFree( &item );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        SaveData_IF
//
// Description: Saves an element of the data in the interface table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IfEntry  *pIf = ( IfEntry *)pEntry;
    uchar    *pTmp;
    ulong     i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IF_INDEX:
        pIf->Info.if_index = item.value.asnValue.number;
        break;

    case ID_IF_DESC:
        pIf->Info.if_descrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_descrlen; i++ )
        {
            pIf->Info.if_descr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_TYPE:
        pIf->Info.if_type = item.value.asnValue.number;
        break;

    case ID_IF_MTU:
        pIf->Info.if_mtu = item.value.asnValue.number;
        break;

    case ID_IF_SPEED:
        pIf->Info.if_speed = item.value.asnValue.number;
        break;

    case ID_IF_PHYSADDR:
        pIf->Info.if_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_physaddrlen; i++ )
        {
            pIf->Info.if_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_ADMINSTATUS:
        pIf->Info.if_adminstatus = item.value.asnValue.number;
        break;

    case ID_IF_OPERSTATUS:
        pIf->Info.if_operstatus = item.value.asnValue.number;
        break;

    case ID_IF_LASTCHANGE:
        pIf->Info.if_lastchange = item.value.asnValue.number;
        break;

    case ID_IF_INOCTETS:
        pIf->Info.if_inoctets = item.value.asnValue.number;
        break;

    case ID_IF_INUCASTPKTS:
        pIf->Info.if_inucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INNUCASTPKTS:
        pIf->Info.if_innucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INDISCARDS:
        pIf->Info.if_indiscards = item.value.asnValue.number;
        break;

    case ID_IF_INERRORS:
        pIf->Info.if_inerrors = item.value.asnValue.number;
        break;

    case ID_IF_INUKNOWNPROTOS:
        pIf->Info.if_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IF_OUTOCTETS:
        pIf->Info.if_outoctets = item.value.asnValue.number;
        break;

    case ID_IF_OUTUCASTPKTS:
        pIf->Info.if_outucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTNUCASTPKTS:
        pIf->Info.if_outnucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTDISCARDS:
        pIf->Info.if_outdiscards = item.value.asnValue.number;
        break;

    case ID_IF_OUTERRORS:
        pIf->Info.if_outerrors = item.value.asnValue.number;
        break;

    case ID_IF_OUTQLEN:
        pIf->Info.if_outqlen = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IP
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IpEntry  *pIp = (IpEntry *)pEntry;
    uchar    *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IP_FORWARDING:
        pIp->Info.ipsi_forwarding = item.value.asnValue.number;
        break;

    case ID_IP_DEFAULTTTL:
        pIp->Info.ipsi_defaultttl = item.value.asnValue.number;
        break;

    case ID_IP_INRECEIVES:
        pIp->Info.ipsi_inreceives = item.value.asnValue.number;
        break;

    case ID_IP_INHDRERRORS:
        pIp->Info.ipsi_inhdrerrors = item.value.asnValue.number;
        break;

    case ID_IP_INADDRERRORS:
        pIp->Info.ipsi_inaddrerrors = item.value.asnValue.number;
        break;

    case ID_IP_FORWDATAGRAMS:
        pIp->Info.ipsi_forwdatagrams = item.value.asnValue.number;
        break;

    case ID_IP_INUNKNOWNPROTOS:
        pIp->Info.ipsi_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IP_INDISCARDS:
        pIp->Info.ipsi_indiscards = item.value.asnValue.number;
        break;

    case ID_IP_INDELIVERS:
        pIp->Info.ipsi_indelivers = item.value.asnValue.number;
        break;

    case ID_IP_OUTREQUESTS:
        pIp->Info.ipsi_outrequests = item.value.asnValue.number;
        break;

    case ID_IP_OUTDISCARDS:
        pIp->Info.ipsi_outdiscards = item.value.asnValue.number;
        break;

    case ID_IP_OUTNOROUTES:
        pIp->Info.ipsi_outnoroutes = item.value.asnValue.number;
        break;

    case ID_IP_REASMTIMEOUTS:
        pIp->Info.ipsi_reasmtimeout = item.value.asnValue.number;
        break;

    case ID_IP_REASMREQDS:
        pIp->Info.ipsi_reasmreqds = item.value.asnValue.number;
        break;

    case ID_IP_REASMOKS:
        pIp->Info.ipsi_reasmoks = item.value.asnValue.number;
        break;

    case ID_IP_REASMFAILS:
        pIp->Info.ipsi_reasmfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGOKS:
        pIp->Info.ipsi_fragoks = item.value.asnValue.number;
        break;

    case ID_IP_FRAGFAILS:
        pIp->Info.ipsi_fragfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGCREATES:
        pIp->Info.ipsi_fragcreates = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IPAddr
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid )
{
    IpAddrEntry  *pIpAddr = (IpAddrEntry *)pEntry;
    uchar        *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IPADDR_ADDR:
        pTmp = (uchar *)&(pIpAddr->Info.iae_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_INDEX:
        pIpAddr->Info.iae_index = item.value.asnValue.number;
        break;

    case ID_IPADDR_MASK:
        pTmp = (uchar *)&(pIpAddr->Info.iae_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_BCASTADDR:
        pIpAddr->Info.iae_bcastaddr = item.value.asnValue.number;
        break;

    case ID_IPADDR_REASMSIZE:
        pIpAddr->Info.iae_reasmsize = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ROUTE
//
// Description: Saves an element of the data in the ROUTE table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid )
{
    RouteEntry  *pRoute = (RouteEntry *)pEntry;
    uchar       *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ROUTE_DEST:
        pTmp = (uchar *)&(pRoute->Info.ire_dest);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_IFINDEX:
        pRoute->Info.ire_index = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC1:
        pRoute->Info.ire_metric1 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC2:
        pRoute->Info.ire_metric2 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC3:
        pRoute->Info.ire_metric3 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC4:
        pRoute->Info.ire_metric4 = item.value.asnValue.number;
        break;

    case ID_ROUTE_NEXTHOP:
        pTmp = (uchar *)&(pRoute->Info.ire_nexthop);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_TYPE:
        pRoute->Info.ire_type = item.value.asnValue.number;
        break;

    case ID_ROUTE_PROTO:
        pRoute->Info.ire_proto = item.value.asnValue.number;
        break;

    case ID_ROUTE_AGE:
        pRoute->Info.ire_age = item.value.asnValue.number;
        break;

    case ID_ROUTE_MASK:
        pTmp = (uchar *)&(pRoute->Info.ire_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_METRIC5:
        pRoute->Info.ire_metric5 = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ARP
//
// Description: Saves an element of the data in the ARP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    ArpEntry  *pArp = (ArpEntry *)pEntry;
    uchar     *pTmp;
    ulong      i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ARP_IFINDEX:
        pArp->Info.inme_index = item.value.asnValue.number;
        break;

    case ID_ARP_PHYSADDR:
        pArp->Info.inme_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pArp->Info.inme_physaddrlen; i++ )
        {
            pArp->Info.inme_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_ARP_NETADDR:
        pTmp = (uchar *)&(pArp->Info.inme_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ARP_TYPE:
        pArp->Info.inme_type = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ICMP
//
// Description: Saves an element of the data in the ICMP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid )
{
    IcmpEntry  *pIcmp = (IcmpEntry *)pEntry;
    uchar      *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ICMP_INMSGS:
        pIcmp->InInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_INERRORS:
        pIcmp->InInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_INDESTUNREACHES:
        pIcmp->InInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMEEXCDS:
        pIcmp->InInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_INPARMPROBS:
        pIcmp->InInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_INSRCQUENCHS:
        pIcmp->InInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_INREDIRECTS:
        pIcmp->InInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOS:
        pIcmp->InInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOREPS:
        pIcmp->InInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPS:
        pIcmp->InInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPREPS:
        pIcmp->InInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKS:
        pIcmp->InInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKREPS:
        pIcmp->InInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTMSGS:
        pIcmp->OutInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTERRORS:
        pIcmp->OutInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTDESTUNREACHES:
        pIcmp->OutInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMEEXCDS:
        pIcmp->OutInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTPARMPROBS:
        pIcmp->OutInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTSRCQUENCHS:
        pIcmp->OutInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTREDIRECTS:
        pIcmp->OutInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOS:
        pIcmp->OutInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOREPS:
        pIcmp->OutInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPS:
        pIcmp->OutInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPREPS:
        pIcmp->OutInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKS:
        pIcmp->OutInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKREPS:
        pIcmp->OutInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCP
//
// Description: Saves an element of the data in the TCP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    TcpEntry  *pTcp = (TcpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCP_RTOALGORITHM:
        pTcp->Info.ts_rtoalgorithm = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMIN:
        pTcp->Info.ts_rtomin = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMAX:
        pTcp->Info.ts_rtomax = item.value.asnValue.number;
        break;

    case ID_TCP_MAXCONN:
        pTcp->Info.ts_maxconn = item.value.asnValue.number;
        break;

    case ID_TCP_ACTIVEOPENS:
        pTcp->Info.ts_activeopens = item.value.asnValue.number;
        break;

    case ID_TCP_PASSIVEOPENS:
        pTcp->Info.ts_passiveopens = item.value.asnValue.number;
        break;

    case ID_TCP_ATTEMPTFAILS:
        pTcp->Info.ts_attemptfails = item.value.asnValue.number;
        break;

    case ID_TCP_ESTABRESETS:
        pTcp->Info.ts_estabresets = item.value.asnValue.number;
        break;

    case ID_TCP_CURRESTABS:
        pTcp->Info.ts_currestab = item.value.asnValue.number;
        break;

    case ID_TCP_INSEGS:
        pTcp->Info.ts_insegs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTSEGS:
        pTcp->Info.ts_outsegs = item.value.asnValue.number;
        break;

    case ID_TCP_RETRANSSEGS:
        pTcp->Info.ts_retranssegs = item.value.asnValue.number;
        break;

    case ID_TCP_INERRS:
        pTcp->Info.ts_inerrs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTRSTS:
        pTcp->Info.ts_outrsts = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCPCONN
//
// Description: Saves an element of the data in the TCP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    TcpConnEntry  *pTcp = (TcpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCPCONN_STATE:
        pTcp->Info.tct_state = item.value.asnValue.number;
        break;

    case ID_TCPCONN_LOCALADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_LOCALPORT:
        pTcp->Info.tct_localport = item.value.asnValue.number;
        break;

    case ID_TCPCONN_REMOTEADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_remoteaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_REMOTEPORT:
        pTcp->Info.tct_remoteport = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDP
//
// Description: Saves an element of the data in the UDP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    UdpEntry  *pUdp = (UdpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDP_INDATAGRAMS:
        pUdp->Info.us_indatagrams = item.value.asnValue.number;
        break;

    case ID_UDP_NOPORTS:
        pUdp->Info.us_noports = item.value.asnValue.number;
        break;

    case ID_UDP_INERRORS:
        pUdp->Info.us_inerrors = item.value.asnValue.number;
        break;

    case ID_UDP_OUTDATAGRAMS:
        pUdp->Info.us_outdatagrams = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDPCONN
//
// Description: Saves an element of the data in the UDP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    UdpConnEntry  *pUdp = (UdpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDPCONN_LOCALADDR:
        pTmp = (uchar *)&(pUdp->Info.ue_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_UDPCONN_LOCALPORT:
        pUdp->Info.ue_localport = item.value.asnValue.number;
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\ipsecparser.cpp ===
// ipsecparser.cpp: interface for the IPSec provider implemented parser (query and path)
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "ipsecparser.h"

// IIPSecPathParser

/*
Routine Description: 

Name:

    CIPSecPathParser::CIPSecPathParser

Functionality:
    
    Constructor. Initialize pointer members.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please initialize them here.

*/

CIPSecPathParser::CIPSecPathParser ()
    : 
    m_pszNamespace(NULL), 
    m_pszClassName(NULL)
{
}

/*
Routine Description: 

Name:

    CIPSecPathParser::~CIPSecPathParser

Functionality:
    
    Destructor. Do clean up (free memory).

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please consider do clean up in the Cleanup function.

*/

CIPSecPathParser::~CIPSecPathParser()
{
    Cleanup();
}

/*
Routine Description: 

Name:

    CIPSecPathParser::ParsePath

Functionality:
    
    Parsing given path and store results in our members.

Virtual:
    
    Yes.
    
Arguments:

    pszObjectPath - the path to be parsed.

Return Value:

    Success: S_OK
    
    Failure: various error code. Any such error indicates the failure to parse the path.
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for syntax error

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecPathParser::ParsePath ( 
    IN LPCWSTR pszObjectPath
    )
{
    if (pszObjectPath == NULL || *pszObjectPath == L'\0')
    {
        return E_INVALIDARG;
    }

    //
    // just in case, this object has already parsed before. This allows repeated use of the same
    // CIPSecPathParser for parsing different paths. 
    //

    Cleanup();

    //
    // Ask WMI for their path parser
    //

    CComPtr<IWbemPath> srpPathParser;
    HRESULT hr = ::CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER, IID_IWbemPath, (void**) &srpPathParser);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // This is the parsing function.
    //

    hr = srpPathParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL | WBEMPATH_TREAT_SINGLE_IDENT_AS_NS, pszObjectPath);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the results...
    //

    ULONG uBufSize = 0;
    DWORD dwCount = 0;

    //
    // get namespace count
    //

    hr = srpPathParser->GetNamespaceCount(&dwCount);

    if (dwCount > 0)
    {
        //
        // get the length needed for the namespace
        //

        hr = srpPathParser->GetNamespaceAt(0, &uBufSize, NULL);

        if (FAILED(hr))
        {
            return hr;
        }

        //
        // we will free this memory.
        //

        m_pszNamespace = new WCHAR[uBufSize];

        if (m_pszNamespace == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // will ignore the result
        //

        hr = srpPathParser->GetNamespaceAt(0, &uBufSize, m_pszNamespace);
    }

    //
    // get the buffer size needed for the class name
    //

    uBufSize = 0;
    hr = srpPathParser->GetClassName(&uBufSize, NULL);

    if (SUCCEEDED(hr))
    {
        //
        // we will free this memory.
        //

        m_pszClassName = new WCHAR[uBufSize];

        if (m_pszClassName == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // WMI path parser don't have a documented behavior as when the class name
        // will be missing.
        //

        hr = srpPathParser->GetClassName(&uBufSize, m_pszClassName);
    }
    else    
    {   
        //
        // this clearly don't have a class name, then the namespace should be the class name.
        // for some reason, Query parser doesn't give us class name in case of singleton
        // and the class name ends up in the namespace member. Obviously, in this case, there is no
        // key properties.
        //

        //
        // must have a namespace
        //

        if (m_pszNamespace)
        {
            //
            // prepare to switch m_pszClassName to point to what the namesapce does.
            //

            delete [] m_pszClassName;
            m_pszClassName = m_pszNamespace;

            m_pszNamespace = NULL;

            //
            // we can return because there is no key property
            //

            return S_OK;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // get key properties
    //

    CComPtr<IWbemPathKeyList> srpKeyList;
    hr = srpPathParser->GetKeyList(&srpKeyList);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // now get the Key and value pairs
    //

    ULONG uKeyCount = 0;
    hr = srpKeyList->GetCount(&uKeyCount);
    if (FAILED(hr) || uKeyCount == 0)
    {
        return hr;
    }

    for (ULONG i = 0; i < uKeyCount; i++)
    {
        //
        // this pKeyVal will cache the (name, value) pair
        //

        CPropValuePair* pKeyVal = NULL;
        uBufSize = 0;

        //
        // now get the size of buffer needed
        //

        CComVariant var;
        ULONG uCimType = CIM_EMPTY;

        hr = srpKeyList->GetKey2(i,
                                0,
                                &uBufSize,
                                NULL,
                                &var,
                                &uCimType);

        if (SUCCEEDED(hr))
        {
            //
            // our vector will manage the memory used by pKeyVal
            //

            pKeyVal = new CPropValuePair;
            if (pKeyVal == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            //
            // need the name buffer
            //

            pKeyVal->pszKey = new WCHAR[uBufSize];

            //
            // variant member of pKeyVal needs to be initialized as well.
            //

            ::VariantInit(&(pKeyVal->varVal));

            //
            // secondary allocation fails, need to free the first level pointer
            //

            if (pKeyVal->pszKey == NULL)
            {
                delete pKeyVal;
                pKeyVal = NULL;
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = srpKeyList->GetKey2(i,
                                    0,
                                    &uBufSize,
                                    pKeyVal->pszKey,
                                    &(pKeyVal->varVal),
                                    &uCimType);
        }

        if (SUCCEEDED(hr))
        {
            m_vecKeyValueList.push_back(pKeyVal);
        }
        else
        {
            //
            // for any failure, we need to free the resource already partially allocated
            // for the pKeyVal. This pKeyVal is pointing to our class, which knows how to free its members,
            // this delete is enough.
            //

            delete pKeyVal;
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    return hr;
}
        
/*
Routine Description: 

Name:

    CIPSecPathParser::GetKeyPropertyCount

Functionality:
    
    Get the key proeprty count contained in the path.

Virtual:
    
    Yes.
    
Arguments:

    pCount - receives the count.

Return Value:

    Success: S_OK
    
    Failure: E_INVALIDARG.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecPathParser::GetKeyPropertyCount ( 
    OUT DWORD *pCount
    )
{
    if (pCount == NULL)
    {
        return E_INVALIDARG;
    }

    *pCount = m_vecKeyValueList.size();
    return S_OK;
}

/*
Routine Description: 

Name:

    CIPSecPathParser::GetNamespace

Functionality:
    
    Get the namespace.

Virtual:
    
    Yes.
    
Arguments:

    pbstrNamespace - receives the namespace string.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for syntax error

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecPathParser::GetNamespace ( 
    OUT BSTR *pbstrNamespace
    )
{
    if (pbstrNamespace == NULL)
    {
        return E_INVALIDARG;
    }

    if (m_pszNamespace)
    {
        *pbstrNamespace = ::SysAllocString(m_pszNamespace);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrNamespace) ? S_OK : E_OUTOFMEMORY;
}

/*
Routine Description: 

Name:

    CIPSecPathParser::GetClassName

Functionality:
    
    Get the class name.

Virtual:
    
    Yes.
    
Arguments:

    pbstrClassName - receives the class name string.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for syntax error

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecPathParser::GetClassName ( 
    OUT BSTR *pbstrClassName
    )
{
    if (pbstrClassName == NULL)
    {
        return E_INVALIDARG;
    }

    if (m_pszClassName)
    {
        *pbstrClassName = ::SysAllocString(m_pszClassName);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrClassName) ? S_OK : E_OUTOFMEMORY;
}
        
/*
Routine Description: 

Name:

    CIPSecPathParser::GetKeyPropertyValue

Functionality:
    
    Get the named property's value

Virtual:
    
    Yes.
    
Arguments:

    pszKeyPropName  - The key property's name whose value is to be retrieved.

    pvarValue       - receives the value.

Return Value:

    Success: S_OK if the property value is properly retrieved.
             WBEM_S_FALSE if the property value can't be found.
    
    Failure:
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (5) Or errors from VariantCopy

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecPathParser::GetKeyPropertyValue ( 
    IN LPCWSTR pszKeyPropName,
    OUT VARIANT *pvarValue    
    )
{
    if (pszKeyPropName == NULL || *pszKeyPropName == L'\0' || pvarValue == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // set the variant to a valid empty initial state
    //

    ::VariantInit(pvarValue);

    //
    // assume we can't find the property
    //

    HRESULT hr = WBEM_S_FALSE;

    std::vector<CPropValuePair*>::iterator it;

    //
    // find the property (case-insensitive name comparison) and copy the value
    //

    for (it = m_vecKeyValueList.begin(); it != m_vecKeyValueList.end(); it++)
    {
        if (_wcsicmp((*it)->pszKey, pszKeyPropName) == 0)
        {
            hr = ::VariantCopy(pvarValue, &((*it)->varVal));
            break;
        }
    }

    return hr;
}
        
/*
Routine Description: 

Name:

    CIPSecPathParser::GetKeyPropertyValueByIndex

Functionality:
    
    Get the indexed property name and value.

Virtual:
    
    Yes.
    
Arguments:
    
    dwIndex           - the (name, value) pair's index.

    pbstrKeyPropName  - receives key property's name.

    pvarValue         - receives the value. In caller not interested, this can be NULL.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property
        (4) Or errors from VariantCopy

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP CIPSecPathParser::GetKeyPropertyValueByIndex ( 
    IN DWORD dwIndex,
    OUT BSTR* pbstrKeyPropName,
    OUT VARIANT *pvarValue  OPTIONAL
    )
{
    if (dwIndex >= m_vecKeyValueList.size() || pbstrKeyPropName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // assume we can't find it
    //

    HRESULT hr = E_UNEXPECTED;

    //
    // initialize the out parameters
    //

    *pbstrKeyPropName = NULL;

    if (pvarValue)
    {
        ::VariantInit(pvarValue);
    }

    CPropValuePair *pKV = m_vecKeyValueList[dwIndex];

    if (pKV)
    {
        *pbstrKeyPropName = ::SysAllocString(pKV->pszKey);

        if (pbstrKeyPropName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr) && pvarValue)
        {
            hr = ::VariantCopy(pvarValue, &(pKV->varVal));

            //
            // don't want to return partial results
            //

            if (FAILED(hr))
            {
                ::SysFreeString(*pbstrKeyPropName);
                *pbstrKeyPropName = NULL;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CIPSecPathParser::Cleanup

Functionality:
    
    Free memory resources.

Virtual:
    
    No.
    
Arguments:
    
    None.

Return Value:

    None.

Notes:
    Consider adding your clean up code here should you need to add members.

*/

void CIPSecPathParser::Cleanup()
{
    //
    // empty the vector. Since the vector manages the (name, value) pair,
    // its contents need to be deleted!
    //

    std::vector<CPropValuePair*>::iterator it;
    for (it = m_vecKeyValueList.begin(); it != m_vecKeyValueList.end(); ++it)
    {
        delete *it;
    }
    m_vecKeyValueList.empty();

    //
    // This function may be called not just inside the destructor,
    // so, properly reset the pointer values after free its memory.
    //

    delete [] m_pszNamespace;
    m_pszNamespace = NULL;

    delete [] m_pszClassName;
    m_pszClassName = NULL;
}

//================================================================================================
// implementations for CIPSecQueryParser
//================================================================================================

/*
Routine Description: 

Name:

    CIPSecQueryParser::CIPSecQueryParser

Functionality:
    
    Constructor. All members are classes. They initialize automatically.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please initialize them here.

*/

CIPSecQueryParser::CIPSecQueryParser()
{
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::~CIPSecQueryParser

Functionality:
    
    Destructor. do clean up.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please initialize them here.

*/

CIPSecQueryParser::~CIPSecQueryParser()
{
    Cleanup();
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::GetClassName

Functionality:
    
    Get the class's name for the given index.

Virtual:
    
    Yes.
    
Arguments:

    iIndex          - The index of the class. Currently, this is not used because WMI only
                      support unary query - query that spans over one class. What we won't
                     design our interface into that.
    
    pbstrClassName  - Receives the class name.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property
        (4) Or errors from VariantCopy

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecQueryParser::GetClassName (
    IN int      iIndex,       
    OUT BSTR  * pbstrClassName
    )
{
    if (pbstrClassName == NULL || iIndex >= m_vecClassList.size())
    {
        return E_INVALIDARG;
    }

    if (m_vecClassList[iIndex])
    {
        *pbstrClassName = ::SysAllocString(m_vecClassList[iIndex]);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrClassName) ? S_OK : E_OUTOFMEMORY;
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::GetGetQueryingPropertyValue

Functionality:
    
    Get querying property's value given the index.

Virtual:
    
    Yes.
    
Arguments:

    iIndex          - Since the same querying property may have multiple values in the where clause
                      this is to get the iIndex-th value of the querying property. If you have a query 
                      like this: 

                        select * from Foo where FooVal = 1 AND BarVal = 5 OR FooVal = 2 AND BarVal = 6

                      you will end up only with FooVal's. The reason for this limitation is that WMI
                      doesn't have a full support on it (parser is maturing) and it's way too complicated
                      for our IPSec parser. For users who needs that kind of support, please use WMI's query
                      parser directly.
    
    pbstrQPValue    - Receives the querying property's value in string format.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecQueryParser::GetQueryingPropertyValue (
    IN int      iIndex,
    OUT BSTR  * pbstrQPValue
    )
{
    if (pbstrQPValue == NULL || iIndex >= m_vecQueryingPropValueList.size())
    {
        return E_INVALIDARG;
    }

    if (m_vecQueryingPropValueList[iIndex])
    {
        *pbstrQPValue = ::SysAllocString(m_vecQueryingPropValueList[iIndex]);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrQPValue) ? S_OK : E_OUTOFMEMORY;
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::Cleanup

Functionality:
    
    free the resources held by our members.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    (1) Consider add clean up code here should you need to add more members.

*/

void CIPSecQueryParser::Cleanup()
{
    //
    // both vectors are storing heap strings, need to delete the contents!
    //

    std::vector<LPWSTR>::iterator it;

    for (it = m_vecClassList.begin(); it != m_vecClassList.end(); it++)
    {
        delete [] (*it);
    }
    m_vecClassList.empty();

    for (it = m_vecQueryingPropValueList.begin(); it != m_vecQueryingPropValueList.end(); it++)
    {
        delete [] (*it);
    }
    m_vecQueryingPropValueList.empty();

    m_bstrQueryingPropName.Empty();
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::ParseQuery

Functionality:
    
    Given the property name we are looking for, this function will parsing the query.

Virtual:
    
    Yes.
    
Arguments:

    strQuery          - The query to be parsed.
    
    strQueryPropName  - The querying property (the property we are looking for in the query).

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property
        (4) Other errors from WMI query parser.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP CIPSecQueryParser::ParseQuery ( 
    IN LPCWSTR strQuery,
    IN LPCWSTR strQueryPropName
    )
{
    if (strQuery == NULL || *strQuery == L'\0')
    {
        return E_INVALIDARG;
    }

    CComPtr<IWbemQuery> srpQuery;

    //
    // Get the WMI query object
    //

    HRESULT hr = ::CoCreateInstance(CLSID_WbemQuery, 0, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void**) &srpQuery);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set up the query parser to use
    //

    ULONG uFeatures[] = {WMIQ_LF1_BASIC_SELECT, WMIQ_LF2_CLASS_NAME_IN_QUERY};

    hr = srpQuery->SetLanguageFeatures(0, sizeof(uFeatures)/sizeof(*uFeatures), uFeatures);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // we are ready to parse, so, cleanup
    //

    Cleanup();

    //
    // parse the query
    //

    hr = srpQuery->Parse(L"WQL", strQuery, 0);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the parsing results
    //

    //
    // need to free memory. Don't do it ourselves. Ask query to free it!
    //

    SWbemRpnEncodedQuery *pRpn = 0;
    hr = srpQuery->GetAnalysis(WMIQ_ANALYSIS_RPN_SEQUENCE, 0, (LPVOID *) &pRpn);

    if (SUCCEEDED(hr))
    {
        //
        // Need the class name from the results
        //

        hr = ExtractClassNames(pRpn);

        //
        // need the querying property values
        //

        if (SUCCEEDED(hr) && strQueryPropName && *strQueryPropName != L'\0')
        {
            m_bstrQueryingPropName = strQueryPropName;
            hr = ExtractQueryingProperties(pRpn, strQueryPropName);
        }

        srpQuery->FreeMemory(pRpn);
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::ExtractClassNames

Functionality:
    
    Private helper to get the class name(s) from the query results.

Virtual:
    
    No.
    
Arguments:

    pRpn    - The query result.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

HRESULT CIPSecQueryParser::ExtractClassNames (
    SWbemRpnEncodedQuery *pRpn
    )
{
    if (pRpn == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iLen = 0;
    LPWSTR pszClassName = NULL;

    //
    // get the from clause, i.e., the class names
    //

    if (pRpn->m_uFromTargetType & WMIQ_RPN_FROM_UNARY)
    {
        //
        // only one class
        //

        //
        // copy the class name and push it to our list
        //

        iLen = wcslen(pRpn->m_ppszFromList[0]);
        pszClassName = new WCHAR[iLen + 1];

        if (pszClassName != NULL)
        {
            //
            // won't overrun buffer, see size above
            //

            wcscpy(pszClassName, pRpn->m_ppszFromList[0]);
            m_vecClassList.push_back(pszClassName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (pRpn->m_uFromTargetType & WMIQ_RPN_FROM_CLASS_LIST)
    {
        //
        // multiple classes. Won't happen for the time being. But we want to be ready
        // for WMI parser's enhancement.
        //

        for (ULONG uIndex = 0; uIndex < pRpn->m_uFromListSize; uIndex++)
        {
            iLen = wcslen(pRpn->m_ppszFromList[uIndex]);
            pszClassName = new WCHAR[iLen + 1];
            if (pszClassName != NULL)
            {
                //
                // won't overrun buffer, see size above
                //
                wcscpy(pszClassName, pRpn->m_ppszFromList[uIndex]);
                m_vecClassList.push_back(pszClassName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::ExtractQueryingProperties

Functionality:
    
    Private helper to get the class name(s) from the query results.

Virtual:
    
    No.
    
Arguments:

    pRpn              - The query result.

    strQueryPropName  - the querying property's name

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.
    (2) We only care about one querying property. Each subexpression will only have one querying property.
        Plus, if the subexpressions are AND'ed together, we will skip the rest subexpressions until we
        sees an OR again.
    (3) We can't support NOT very well. For example, how can we answer:

            select * from where NOT (IPSecStorePath = "c:\\test.inf")

        Fundamentally, we can't do that because we don't know the score of files not equal "c:\\test.inf".

*/

//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
HRESULT CIPSecQueryParser::ExtractQueryingProperties (
    IN SWbemRpnEncodedQuery * pRpn,
    IN LPCWSTR                strQueryPropName
    )
{
    if (pRpn == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    SWbemRpnQueryToken *pQueryToken = NULL;

    //
    // flags if we should ignore the next token
    //

    bool bSkip = false;

    for (ULONG uIndex = 0; uIndex < pRpn->m_uWhereClauseSize; uIndex++)
    {
        pQueryToken = pRpn->m_ppRpnWhereClause[uIndex];

        switch (pQueryToken->m_uTokenType)
        {
            case WMIQ_RPN_TOKEN_EXPRESSION:

                //
                // there is a subexpression, potentially a querying property here
                //

                if (!bSkip)
                {
                    hr = GetQueryPropFromToken(pQueryToken, strQueryPropName);
                }

                //
                // if hr == S_FALSE, then it means it doesn't find any Store path
                // see it's use in case WMIQ_RPN_TOKEN_AND bellow
                //

                if (FAILED(hr))
                {
                    return hr;
                }
                break;

            case WMIQ_RPN_TOKEN_OR:

                //
                // we see an OR, next tokens should NOT been skipped
                //

                bSkip = false;
                break;

            case WMIQ_RPN_TOKEN_AND:

                //
                // see comments about S_FALSE in case WMIQ_RPN_TOKEN_EXPRESSION above
                //

                bSkip = (hr == S_FALSE) ? false : true;

                //
                // fall through
                //

            case WMIQ_RPN_TOKEN_NOT:
            default:

                //
                // don't support parsing these tokens, so skip
                //

                bSkip = true;
                break;
        }
    }

    return S_OK;
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::GetQueryPropFromToken

Functionality:
    
    Private helper analyze the token and get the querying property's value if found.

Virtual:
    
    No.
    
Arguments:

    pRpnQueryToken    - The token to analyze.

    strQueryPropName  - the querying property's name

Return Value:

    Success: S_OK if a querying property's value is successfully retrieved.
             S_FALSE if no querying property name if found in the token.
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.
        (3) Other errors only defined by WMI, such as WBEM_E_INVALID_SYNTAX, WBEM_E_NOT_SUPPORTED.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.
    (2) We only care about one querying property. Each subexpression will only have one querying property.
        Plus, if the subexpressions are AND'ed together, we will skip the rest subexpressions until we
        sees an OR again.
    (3) We can't support NOT very well. For example, how can we answer:

            select * from where NOT (IPSecStorePath = "c:\\test.inf")

        Fundamentally, we can't do that because we don't know the score of files not equal "c:\\test.inf".

*/

HRESULT 
CIPSecQueryParser::GetQueryPropFromToken (
    IN SWbemRpnQueryToken * pRpnQueryToken,
    IN LPCWSTR              strQueryPropName
    )
{
    HRESULT hr = S_OK;

    //
    // we only support <propertyName> = <value> and
    // <value> should be string
    //

    if (pRpnQueryToken->m_uOperator             != WMIQ_RPN_OP_EQ ||
        pRpnQueryToken->m_uConstApparentType    != VT_LPWSTR        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // must have left identifier, we don't support it if it doesn't have one.
    //

    if (pRpnQueryToken->m_pLeftIdent == NULL)
    {
        hr = WBEM_E_NOT_SUPPORTED;
    }
    else 
    {
        SWbemQueryQualifiedName *pLeft = pRpnQueryToken->m_pLeftIdent;

        //
        // no left, invalid
        //

        if (pLeft == NULL)
        {
            return WBEM_E_INVALID_SYNTAX;
        }

        if (pLeft->m_uNameListSize != 1)
        {
            return WBEM_E_NOT_SUPPORTED;
        }

        // if the right is StoreName, then this is what we need
        if (_wcsicmp(strQueryPropName, pLeft->m_ppszNameList[0]) == 0)
        {
            int iLen = wcslen(pRpnQueryToken->m_Const.m_pszStrVal);
            LPWSTR pName = new WCHAR[iLen + 1];

            if (pName)
            {
                //
                // won't overrun the buffer
                //

                wcscpy(pName, pRpnQueryToken->m_Const.m_pszStrVal);
                m_vecQueryingPropValueList.push_back(pName);
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {   
            //
            // no match for querying property name
            //

            hr = S_FALSE;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CIPSecQueryParser::GetQueryPropFromToken

Functionality:
    
    Get key proeprty value parsed from the query. Due to our query limitation, the property name
    should really be the querying property name.

Virtual:
    
    Yes.
    
Arguments:

    pszKeyPropName  - The key property name.

    pvarValue       - receives the value.

Return Value:

    Success: S_OK if a key property's value is successfully retrieved.
             WBEM_S_FALSE if the property can't be found.
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.
        (3) Other errors only defined by WMI, such as WBEM_E_INVALID_SYNTAX, WBEM_E_NOT_SUPPORTED.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CIPSecQueryParser::GetKeyPropertyValue ( 
    IN LPCWSTR    pszKeyPropName,
    OUT VARIANT * pvarValue
    )
{
    if (pvarValue == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // ready to say that we can't find it
    //

    HRESULT hr = WBEM_S_FALSE;
    ::VariantInit(pvarValue);

    //
    // If you are asking for the querying property's value, we certainly can give you one.
    //

    if ((LPCWSTR)m_bstrQueryingPropName != NULL && _wcsicmp(pszKeyPropName, m_bstrQueryingPropName) == 0)
    {
        CComBSTR bstrVal;

        if (SUCCEEDED(GetQueryingPropertyValue(0, &bstrVal)))
        {
            //
            // hand it over to the out parameter
            //

            pvarValue->vt = VT_BSTR;
            pvarValue->bstrVal = bstrVal.Detach();

            hr = S_OK;
        }
        else
        {
            hr = WBEM_S_FALSE;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\iputil.h ===
//////////////////////////////////////////////////////////////////////
// IPUtil.h : Declaration of some global helper function for sockets
// Copyright (c)1997-2001 Microsoft Corporation
//
// some global definitions
// Original Create Date: 5/16/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

//
// for active socket
//

//#include <ntspider.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// the following section is copied from net\tcpip\commands\common2\common2.h

//
// Include Files
//

#include "ipexport.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "tcpinfo.h"

#undef SOCKET
//#include "..\common\tcpcmd.h"

// 
// the following section is to replace the above include file
// begin tcpcmd.h
//

//#ifndef TCPCMD_INCLUDED
//#define TCPCMD_INCLUDED



#define NOGDI
#define NOMINMAX

//
// added by shawnwu
//
//#include <winsock.h>
//

//#include <windef.h>
//#include <winbase.h>
//#include <winsock2.h>
//#include <ws2tcpip.h>
//#ifndef WIN16
//#endif // WIN16
//#include <direct.h>
//#include <io.h>
//#include <stdlib.h>
//#include <stdio.h>
//#include <time.h>
//#include <string.h>
//#include <nls.h>

//
// global variable declarations
//
extern int   optind;
extern int   opterr;
extern char *optarg;


//
// function prototypes
//

char *
GetFileFromPath(
        char *);

HANDLE
OpenStream(
        char *);

int
lwccmp(
        char *,
        char *);

long
netnumber(
        char *);

long
hostnumber(
        char *);

void
blkfree(
        char **);

struct sockaddr_storage *
resolve_host(
        char *,
        int *);

int
resolve_port(
        char *,
        char *);

char *
tempfile(
        char *);

char *
udp_alloc(
        unsigned int);

void
udp_close(
        SOCKET);

void
udp_free(
        char *);

SOCKET
udp_open(
        int,
        int *);

int
udp_port(void);

int
udp_port_used(
        int,
        int);

int
udp_read(
        SOCKET,
        char *,
        int,
        struct sockaddr_storage *,
        int *,
        int);

int
udp_write(
        SOCKET,
        char *,
        int,
        struct sockaddr_storage *,
        int);

void
gate_ioctl(
        HANDLE,
        int,
        int,
        int,
        long,
        long);

void
get_route_table(void);

int
tcpcmd_send(
    SOCKET  s,        // socket descriptor
    char          *buf,      // data buffer
    int            len,      // length of data buffer
    int            flags     // transmission flags
    );

void
s_perror(
        char *yourmsg,  // your message to be displayed
        int  lerrno     // errno to be converted
        );


void fatal(char *    message);

//#ifndef WIN16
//struct netent *getnetbyname(IN char *name);
//unsigned long inet_network(IN char *cp);
//#endif // WIN16

#define perror(string)  s_perror(string, (int)GetLastError())

#define HZ              1000
#define TCGETA  0x4
#define TCSETA  0x10
#define ECHO    17
#define SIGPIPE 99

#define MAX_RETRANSMISSION_COUNT 8
#define MAX_RETRANSMISSION_TIME 8    // in seconds


// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
//__inline
//ULONG
//FASTCALL
//net_long(
//    ULONG x)
//{
//    register ULONG byteswapped;

//    byteswapped = ((x & 0x00ff00ff) << 8) | ((x & 0xff00ff00) >> 8);

//    return (byteswapped << 16) | (byteswapped >> 16);
//}

//#endif //TCPCMD_INCLUDED

//
// end for tcpcmd.h
// 

//
// Definitions
//

#define MAX_ID_LENGTH		50

// Table Types

#define TYPE_IF		0
#define TYPE_IP		1
#define TYPE_IPADDR	2
#define TYPE_ROUTE	3
#define TYPE_ARP	4
#define TYPE_ICMP	5
#define TYPE_TCP	6
#define TYPE_TCPCONN	7
#define TYPE_UDP	8
#define TYPE_UDPCONN	9


//
// Structure Definitions
//

typedef struct _GenericTable {
    LIST_ENTRY  ListEntry;
} GenericTable;

typedef struct _IfEntry {
    LIST_ENTRY  ListEntry;
    IFEntry     Info;
} IfEntry;

typedef struct _IpEntry {
    LIST_ENTRY  ListEntry;
    IPSNMPInfo  Info;
} IpEntry;

typedef struct _IpAddrEntry {
    LIST_ENTRY   ListEntry;
    IPAddrEntry  Info;
} IpAddrEntry;

typedef struct _RouteEntry {
    LIST_ENTRY    ListEntry;
    IPRouteEntry  Info;
} RouteEntry;

typedef struct _ArpEntry {
    LIST_ENTRY         ListEntry;
    IPNetToMediaEntry  Info;
} ArpEntry;

typedef struct _IcmpEntry {
    LIST_ENTRY  ListEntry;
    ICMPStats   InInfo;
    ICMPStats   OutInfo;
} IcmpEntry;

typedef struct _TcpEntry {
    LIST_ENTRY  ListEntry;
    TCPStats    Info;
} TcpEntry;

typedef struct _TcpConnEntry {
    LIST_ENTRY         ListEntry;
    TCPConnTableEntry  Info;
} TcpConnEntry;

typedef struct _UdpEntry {
    LIST_ENTRY  ListEntry;
    UDPStats    Info;
} UdpEntry;

typedef struct _UdpConnEntry {
    LIST_ENTRY  ListEntry;
    UDPEntry    Info;
} UdpConnEntry;


//
// Function Prototypes
//

void *GetTable( ulong Type, ulong *pResult );
void FreeTable( GenericTable *pList );
ulong MapSnmpErrorToNt( ulong ErrCode );
ulong InetEqual( uchar *Inet1, uchar *Inet2 );
ulong PutMsg(ulong Handle, ulong MsgNum, ... );
uchar *LoadMsg( ulong MsgNum, ... );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: IPSec WMI provider for SCE
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Original Create Date: 2/19/2001
//  Original Author: shawnwu
//***************************************************************************

#include <objbase.h>
#include "netsecprov.h"
#include "netseccore_i.c"
#include "resource.h"
#include "ipsecparser.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_NetSecProv, CNetSecProv)
    OBJECT_ENTRY(CLSID_IPSecPathParser, CIPSecPathParser)
    OBJECT_ENTRY(CLSID_IPSecQueryParser, CIPSecQueryParser)
END_OBJECT_MAP()

LPCWSTR lpszIPSecProvMof = L"Wbem\\NetProv.mof";

//
//LPCWSTR lpszIPSecRsopMof = L"Wbem\\NetRsop.mof";
//


/*
Routine Description: 

Name:

    DllMain

Functionality:

    Entry point for DLL.

Virtual:
    
    N/A.

Arguments:

    hInstance   - Handle to the instance.

    ulReason    - indicates reason of being called.

    pvReserved  - 

Return Value:

    Success:

        TRUE

    Failure:

        FALSE

Notes:

    See MSDN for standard DllMain 

*/

extern "C"
BOOL 
WINAPI DllMain (
    IN HINSTANCE hInstance, 
    IN ULONG     ulReason, 
    IN LPVOID    pvReserved
    )
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }
#endif
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        OutputDebugString(L"IPSecProv.dll loaded.\n");
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (ulReason == DLL_PROCESS_DETACH)
    {
        OutputDebugString(L"IPSecProv.dll unloaded.\n");
        _Module.Term();
    }
    return TRUE;
}


/*
Routine Description: 

Name:

    DllGetClassObject

Functionality:

    This method creates an object of a specified CLSID and 
    retrieves an interface pointer to this object. 

Virtual:
    
    N/A.

Arguments:

    rclsid      - Class ID (guid ref).

    REFIID      - Interface ID (guid ref).

    ppv         - Receives the class factory interface pointer.

Return Value:

    Success:

        S_OK

    Failure:

        Other error code.

Notes:

    See MSDN for standard CComModule::DllGetClassObject 

*/

STDAPI 
DllGetClassObject (
    IN  REFCLSID rclsid, 
    IN  REFIID   riid, 
    OUT PPVOID   ppv
    )
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}


/*
Routine Description: 

Name:

    DllCanUnloadNow

Functionality:

    Called periodically by COM in order to determine if the
    DLL can be freed.

Virtual:
    
    N/A.

Arguments:

    None.

Return Value:

    S_OK if it's OK to unload, otherwise, S_FALSE

Notes:

    See MSDN for standard DllCanUnloadNow 

*/

STDAPI 
DllCanUnloadNow ()
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }
#endif
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}


/*
Routine Description: 

Name:

    DllRegisterServer

Functionality:

    Called to register our dll. We also compile the mof file(s).

Virtual:
    
    N/A.

Arguments:

    None.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes indicating the problem.

Notes:

    See MSDN for standard DllRegisterServer 

*/

STDAPI 
DllRegisterServer ()
{

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
    {
        return hRes;
    }
#endif

    HRESULT hr = _Module.RegisterServer(TRUE);

    //
    // now compile the MOF files, will ignore if such compilation fails
    //

    if (SUCCEEDED(hr))
    {
        //
        // is this arbitrary?
        //

        const int WBEM_MOF_FILE_LEN = _MAX_FNAME;  

        //
        // potentially append L'\\'
        //

        WCHAR szMofFile[MAX_PATH + 1 + WBEM_MOF_FILE_LEN];

        szMofFile[0] = L'\0';

        UINT uSysDirLen = ::GetSystemDirectory( szMofFile, MAX_PATH );

        if (uSysDirLen > 0 && uSysDirLen < MAX_PATH) 
        {
            if (szMofFile[uSysDirLen] != L'\\')
            {
                szMofFile[uSysDirLen] = L'\\';   
                
                //
                // we are not going to overrun buffer because of the extra 1 for szMofFile
                //

                szMofFile[uSysDirLen + 1] = L'\0';
                ++uSysDirLen;
            }

            HRESULT hrIgnore = WBEM_NO_ERROR;

            //
            // this protects buffer overrun
            //

            if (wcslen(lpszIPSecProvMof) < WBEM_MOF_FILE_LEN)
            {
                wcscpy(szMofFile + uSysDirLen, lpszIPSecProvMof);

                hrIgnore = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
                if (SUCCEEDED(hrIgnore))
                {
                    CComPtr<IMofCompiler> srpMof;
                    hrIgnore = ::CoCreateInstance (CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void **)&srpMof);

                    if (SUCCEEDED(hrIgnore))
                    {
                        WBEM_COMPILE_STATUS_INFO  stat;

                        hrIgnore = srpMof->CompileFile( szMofFile, NULL,NULL,NULL,NULL, 0,0,0, &stat);

                        //
                        // compile RSOP mof
                        // this protects buffer overrun
                        //if (wcslen(lpszIPSecRsopMof) < WBEM_MOF_FILE_LEN)
                        //{
                        //    wcscpy(szMofFile + uSysDirLen, lpszIPSecRsopMof);

                        //    hrIgnore = srpMof->CompileFile( szMofFile, NULL,NULL,NULL,NULL, 0,0,0, &stat);
                        //}
                        //
                    }

                    ::CoUninitialize();
                }
            }
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    DllUnregisterServer

Functionality:

    Called to un-register our dll. There is no equivalence in MOF compilation.

Virtual:
    
    N/A.

Arguments:

    None.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes indicating the problem.

Notes:

    See MSDN for standard DllUnregisterServer.

    $undone:shawnwu, should we also delete all classes registered by our MOF?

*/

STDAPI 
DllUnregisterServer ()
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\netsecprov.h ===
//////////////////////////////////////////////////////////////////////
// NetSecProv.h : Declaration of the CNetSecProv
// Copyright (c)1997-2001 Microsoft Corporation
//
// this is the Network Security WMI provider for SCE
// Original Create Date: 2/19/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"

using namespace std;

typedef LPVOID * PPVOID;

//
// forward declaration to use these two interface inside function declaration
//

interface ISceKeyChain;

interface IIPSecObjectImpl;


/*

Class CCriticalSection
    
    Naming: 

        CCriticalSection stands for Critical Section.
    
    Base class: 
        
        None.
    
    Purpose of class:

        Wrapper of Critical section object. This trivial helper at least do two
        things:

            (1) Critical section initialization and deletion will be automatic.

            (2) Helps to easily create a unique global stack variable of a critical 
                section. Don't need to worry about creation time any more.
    
    Design:

        Trivial. Just the initialization inside constructor and deletion inside
        destructor, plus a pair of Enter and Leave functions.
           
    
    Use:

        (1) Create an instance if you need to do so. Otherwise, just reference the
            already created one.

        (2) Call Enter just as you would do with EnterCriticalSection when you need
            protected access to global objects.

        (3) Call Leave just as you would do with LeaveCriticalSection when you are
            done with the protected global objects.
        
    Notes:



class CCriticalSection
{
public:
    CCriticalSection()
    {
        ::InitializeCriticalSection(&m_cs);
    }

    ~CCriticalSection()
    {
        ::DeleteCriticalSection(&m_cs);
    }

    void Enter()
    {
        ::EnterCriticalSection(&m_cs);
    }

    void Leave()
    {
        ::LeaveCriticalSection(&m_cs);
    }

private:

    CRITICAL_SECTION m_cs;
};
*/


//
// Two helper functions
//

//
// $undone:shawnwu, need work on refining this pulling implementation.
// We should do a pushing to enhance performance of the globals
//

// void UpdateGlobals(IWbemServices* pNamespace, IWbemContext* pCtx);

//
// To support testing. Since IPSec's operations may render the system
// totally unusable, during development, we will be so much better off
// if we can do (thus test) everything except the last step, which is
// to put/delete object to/from SPD.
//


/*

Class CDefWbemService
    
    Naming: 

        CDefWbemService stands for Default Wbem Service.
    
    Base class: 
        
        (1) CComObjectRootEx: for threading model and IUnknown.

        (2) IWbemServices: the purpose of the class. We don't want to 
            the real provider to have so many dummy functions to confuse
            ourselves. We thus implement all of those that we don't want
            to implement in our final provider class.
    
    Purpose of class:

        Implements all functions (to not supported) so that the its derived class
        is no longer crowded by all these functions. This cleans up our real 
        provider's implmentation.
    
    Design:

        (1) return WBEM_E_NOT_SUPPORTED for all the functions of IWbemServices.

        (2) Inherit from CComObjectRootEx to get the threading model and IUnknown.
           
    
    Use:

        (1) This is only for our provider class to inherit. You will never use it 
            directly other than deriving from it.
        
    Notes:


*/

class ATL_NO_VTABLE CDefWbemService 
    : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IWbemServices
{
public:

DECLARE_NOT_AGGREGATABLE(CDefWbemService)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDefWbemService)
	COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()

public:

    STDMETHOD(OpenNamespace)(
        IN     const BSTR          Namespace,
        IN     long                lFlags,
        IN     IWbemContext      * pCtx,
        IN OUT IWbemServices    ** ppWorkingNamespace,
        IN OUT IWbemCallResult  ** ppResult
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(CancelAsyncCall) (
        IN IWbemObjectSink * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(QueryObjectSink) (
        IN     long               lFlags,
        IN OUT IWbemObjectSink ** pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(GetObject) (
        IN     const BSTR          ObjectPath,
        IN     long                lFlags,
        IN     IWbemContext      * pCtx,
        IN OUT IWbemClassObject ** ppObject,
        IN OUT IWbemCallResult  ** ppCallResult
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(GetObjectAsync) (
        IN const BSTR         ObjectPath,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(PutClass) (
        IN     IWbemClassObject *  pObject,
        IN     long                lFlags,
        IN     IWbemContext     *  pCtx,
        IN OUT IWbemCallResult  ** ppCallResult
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(PutClassAsync) (
        IN IWbemClassObject * pObject,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(DeleteClass) (
        IN     const BSTR         Class,
        IN     long               lFlags,
        IN     IWbemContext     * pCtx,
        IN OUT IWbemCallResult ** ppCallResult
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(DeleteClassAsync)(
        IN const BSTR         Class,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(CreateClassEnum) (
        IN  const BSTR              Superclass,
        IN  long                    lFlags,
        IN  IWbemContext         *  pCtx,
        OUT IEnumWbemClassObject ** ppEnum
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(CreateClassEnumAsync) (
        IN const BSTR         Superclass,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pResponseHandler
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(PutInstance)(
        IN  IWbemClassObject    *  pInst,
        IN  long                   lFlags,
        IN  IWbemContext        *  pCtx,
        OUT IWbemCallResult     ** ppCallResult
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(PutInstanceAsync) (
        IN IWbemClassObject  * pInst,
        IN long                lFlags,
        IN IWbemContext      * pCtx,
        IN IWbemObjectSink   * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(DeleteInstanceAsync) (
        IN const BSTR         ObjectPath,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(DeleteInstance) (
        IN  const BSTR         ObjectPath,
        IN  long               lFlags,
        IN  IWbemContext    *  pCtx,
        OUT IWbemCallResult ** ppCallResult
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(CreateInstanceEnum)(
        IN  const BSTR              Class,
        IN  long                    lFlags,
        IN  IWbemContext         *  pCtx,
        OUT IEnumWbemClassObject ** ppEnum
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(CreateInstanceEnumAsync) (
        IN const BSTR         Class,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(ExecQuery) (
        IN  const BSTR              QueryLanguage,
        IN  const BSTR              Query,
        IN  long                    lFlags,
        IN  IWbemContext         *  pCtx,
        OUT IEnumWbemClassObject ** ppEnum
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(ExecQueryAsync) (
        IN const BSTR       QueryLanguage,
        IN const BSTR       Query,
        IN long             lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(ExecNotificationQuery) (
        IN  const BSTR              QueryLanguage,
        IN  const BSTR              Query,
        IN  long                    lFlags,
        IN  IWbemContext         *  pCtx,
        OUT IEnumWbemClassObject ** ppEnum
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(ExecNotificationQueryAsync) (
        IN const BSTR         QueryLanguage,
        IN const BSTR         Query,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(ExecMethod) ( 
        IN const BSTR, 
        IN const BSTR, 
        IN long, 
        IN IWbemContext*,
        IN IWbemClassObject*, 
        IN IWbemClassObject**, 
        IN IWbemCallResult**
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(ExecMethodAsync) ( 
        IN const BSTR, 
        IN const BSTR, 
        IN long,
        IN IWbemContext*, 
        IN IWbemClassObject*, 
        IN IWbemObjectSink*
        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }


};


/*

Class CNetSecProv
    
    Naming: 

        CNetSecProv stands for Network Security Provider.
    
    Base class: 
        
        (1) CDefWbemService: for threading model and IUnknown, and those functions that we
            are not interested at all. 

        (2) CComCoClass: for class factory support. This is necessary to be
            a provider because we need to be an externally createable class.

        (3) IWbemProviderInit: Allow initialization. Necessary as a provider.

        (4) IWbemServices: indirectly from CDefWbemService.
    
    Purpose of class:

        This is the provider that WMI sees.
    
    Design:

        (1) Implements those functions of IWbemServices that we are interested in,
            plus two static helpers functions for key chain creation. Extremely simple design.
           
    
    Use:

        (1) You will never create an instance directly yourself. It's created by WMI.

        (2) Call the static functions as you need them.
        
    Notes:


*/

class ATL_NO_VTABLE CNetSecProv : 
    public CDefWbemService,
	public CComCoClass<CNetSecProv, &CLSID_NetSecProv>,
	public IWbemProviderInit
{
public:
	CNetSecProv()
	{
	}

	~CNetSecProv()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_NETSECPROV)
DECLARE_NOT_AGGREGATABLE(CNetSecProv)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetSecProv)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
    COM_INTERFACE_ENTRY_CHAIN(CDefWbemService)
END_COM_MAP()


public:

    STDMETHOD(Initialize) (
        IN LPWSTR                  pszUser,
        IN LONG                    lFlags,
        IN LPWSTR                  pszNamespace,
        IN LPWSTR                  pszLocale,
        IN IWbemServices         * pNamespace,
        IN IWbemContext          * pCtx,
        IN IWbemProviderInitSink * pInitSink
        );

    //IWbemServices

    STDMETHOD(GetObjectAsync) (
        IN const BSTR         ObjectPath,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstanceAsync) (
        IN IWbemClassObject * pInst,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(DeleteInstanceAsync) (
        IN const BSTR         ObjectPath,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(CreateInstanceEnumAsync) (
        IN const BSTR         Class,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(ExecQueryAsync) (
        IN const BSTR         QueryLanguage,
        IN const BSTR         Query,
        IN long               lFlags,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(ExecMethodAsync)( 
        IN const BSTR         bstrPath, 
        IN const BSTR         bstrMethod, 
        IN long               Flag,
        IN IWbemContext     * pCtx, 
        IN IWbemClassObject * pObj, 
        IN IWbemObjectSink  * pSink
        );

    static HRESULT GetKeyChainByPath (
        IN  LPCWSTR             pszPath, 
        OUT IIPSecKeyChain **   ppKeyChain
        );

    static HRESULT GetKeyChainFromQuery (
        IN  LPCWSTR             pszQuery, 
        IN  LPCWSTR             pszWhereProperty, 
        OUT IIPSecKeyChain **   ppKeyChain
        );

private:

	CComPtr<IWbemServices> m_srpNamespace;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\netsecprov.cpp ===
//////////////////////////////////////////////////////////////////////
// NetSecProv.cpp : Implementation of CNetSecProv
// Copyright (c)1997-2001 Microsoft Corporation
//
// this is the Network Security WMI provider for IPSec
// Original Create Date: 2/19/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#include "NetSecProv.h"
#include "globals.h"
#include "IPSecBase.h"

#include "TranxMgr.h"
#include "PolicyQM.h"

//
// These are our global variables:
// (1) g_CS. We will generally speaking use one critical section. This is it.
//
// (2) g_varRollbackGuid. This is the rollback guid. If an action is taken and this
//     variable is set to a valid string, then we tied that action to this token.
//     Even though we say it is a guid (string), any string will work for us.
//

//CCriticalSection g_CS;

//CComVariant g_varRollbackGuid;


/*
Routine Description: 

Name:

    UpdateGlobals

Functionality:

    Update the global variables.

Virtual:
    
    No.

Arguments:
    
    pNamespace  - COM interface pointer representing ourselves.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

Return Value:

    None. We don't plan to allow any failure of this function to stop our normal
    execution.

Notes:


void 
UpdateGlobals (
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
{
    //
    // We don't want any exception to cause a critical section leak. But all our function
    // calls are COM interface functions and they should never throw an exception.
    // But is that guaranteed? Chances are it is not. So, we will play safe here and put
    // a try-catch block around it
    //

    g_CS.Enter();

    try 
    {
        g_varRollbackGuid.Clear();
        HRESULT hr = WBEM_NO_ERROR;

        //
        // update the transaction token, which is made available when SCE provider goes
        // into a Configure loop and made unavailable when SCE's configure loop ends.
        // So, we need to ask SCE provider.
        //

        //
        // Try to locate the SCE provider. Need the locator first.
        //

        CComPtr<IWbemLocator> srpLocator;
        hr = ::CoCreateInstance(CLSID_WbemLocator, 
                                0,
                                CLSCTX_INPROC_SERVER,
                                IID_IWbemLocator, 
                                (LPVOID *) &srpLocator
                                );

        if (SUCCEEDED(hr) && srpLocator)
        {
            //
            // Ask the locator to find the SCE provider.
            //

            CComPtr<IWbemServices> srpNamespace;
            CComBSTR bstrSce(L"\\\\.\\root\\Security\\SCE");
            hr = srpLocator->ConnectServer(bstrSce, NULL, NULL, NULL, 0, NULL, NULL, &srpNamespace);

            if (SUCCEEDED(hr) && srpNamespace)
            {
                //
                // SCE provider is found, then ask it for the transaction token object
                //

                CComBSTR bstrQuery(L"select * from Sce_TransactionToken");
                CComPtr<IEnumWbemClassObject> srpEnum;

                hr = srpNamespace->ExecQuery(L"WQL", 
                                             bstrQuery,
                                             WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                             NULL, 
                                             &srpEnum
                                             );
                if (SUCCEEDED(hr))
                {
                    //
                    // if the transaction token object is found, then get the rollback guid of the object
                    //

                    CComPtr<IWbemClassObject> srpObj;
                    ULONG nEnum = 0;
                    hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
                
                    if (srpObj)
                    {
                        srpObj->Get(L"TranxGuid", 0, &g_varRollbackGuid, NULL, NULL);

                        //
                        // if what we got is not what we are prepared to accept, then toss it away
                        //

                        if (g_varRollbackGuid.vt != VT_BSTR)
                        {
                            g_varRollbackGuid.Clear();
                        }
                    }

                    //
                    // Somehow, the following simpler code doesn't work:
                    //
                    // CComBSTR bstrTranxToken(L"Sce_TransactionToken=@");
                    // CComPtr<IWbemClassObject> srpObj;
                    // hr = srpNamespace->GetObject(bstrTranxToken, WBEM_FLAG_RETURN_WBEM_COMPLETE, pCtx, &srpObj, NULL);
                    // if (SUCCEEDED(hr) && srpObj)
                    // {
                    //     srpObj->Get(L"TranxGuid", 0, &g_varRollbackGuid, NULL, NULL);
                    // }
                    //
                }
            }
        }
    }
    catch (...)
    {
        g_CS.Leave();

        //
        // We don't want to eat up any throw here. Such violations of COM programming, or
        // our own bug, should be exposed here to correction. So, re-throw the exception
        //

        throw;
    }

    g_CS.Leave();
}

*/

/////////////////////////////////////////////////////////////////////////////
// CNetSecProv


/*
Routine Description: 

Name:

    CNetSecProv::Initialize

Functionality:

    Called by WMI to let us initialize.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    pszUser         - The name of the user

    lFlags          - Not in use.

    pszNamespace    - Our provider's namespace string.

    pszLocale       - Locale string.

    pNamespace      - COM interface given by WMI that represents our provider.

    pCtx            - COM interface pointer give to us by WMI and needed for various WMI APIs.

    pInitSink       - COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        Various error codes. 

Notes:

    Don't assume that this function will be called only once. I have seen 
    this to be called multiple times by WMI.

*/

STDMETHODIMP 
CNetSecProv::Initialize (
    IN LPWSTR                  pszUser,
    IN LONG                    lFlags,
    IN LPWSTR                  pszNamespace,
    IN LPWSTR                  pszLocale,
    IN IWbemServices         * pNamespace,
    IN IWbemContext          * pCtx,
    IN IWbemProviderInitSink * pInitSink
    )
{
	HRESULT hr = ::CheckImpersonationLevel();
    if (FAILED(hr))
    {
		return hr;
    }

    if (pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    m_srpNamespace = pNamespace;

    //::UpdateGlobals(pNamespace, pCtx);

    //
    //Let CIMOM know you are initialized
    //

    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    return WBEM_NO_ERROR;
}


/*
Routine Description: 

Name:

    CNetSecProv::CreateInstanceEnumAsync

Functionality:

    Given a class name (WMI class name), we will return all its instances to WMI.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    strClass        - The name of the WMI class.

    lFlags          - Not in use.

    pCtx            - COM interface pointer give to us by WMI and needed for various WMI APIs.

    pSink           - COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes. 

Notes:


*/

STDMETHODIMP 
CNetSecProv::CreateInstanceEnumAsync (
    IN const BSTR         bstrClass, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemObjectSink  * pSink
    )
{
    if (pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = CheckImpersonationLevel();
	if(FAILED(hr))
    {
		return hr;
    }

    //
    // we will borrow our query implementation to deal with this class enumeration.
    // So, we will create a query like this: "select * from <bstrClass>"
    //

    CComPtr<IIPSecKeyChain> srpKeyChain;
    CComBSTR bstrQuery(L"SELECT * FROM ");
    bstrQuery += bstrClass;

    //
    // create a key chain that parses information from this class.
    // Again, we don't care about the where clause (actually, there is none)
    // "Name" is just a place holder. It requires a non-NULL value.
    //

    hr = GetKeyChainFromQuery(bstrQuery, L"Name", &srpKeyChain);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Now we know which class we class it will create to respond to the request.
    //

    CComPtr<IIPSecObjectImpl> srpObj;
    hr = CIPSecBase::CreateObject(m_srpNamespace, srpKeyChain, pCtx, &srpObj);
    if (SUCCEEDED(hr))
    {
        hr = srpObj->QueryInstance(bstrQuery, pCtx, pSink);
    }

    pSink->SetStatus(WBEM_STATUS_COMPLETE, hr , NULL, NULL);

    return hr;
}


/*
Routine Description: 

Name:

    CNetSecProv::GetObjectAsync

Functionality:

    Given a path, we will create the wbem object representing it. Since most of our classes
    represent SPD objects, this path must contain the correct information (like the correct
    filter name, etc.) in order for us to create an wbem object to represent it. Bottom line:
    we won't create a wbem object unless we know our SPD has the corresponding object.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    bstrObjectPath  - The path.

    lFlags          - Not in use.

    pCtx            - COM interface pointer give to us by WMI and needed for various WMI APIs.

    pSink           - COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes. 

Notes:


*/

STDMETHODIMP 
CNetSecProv::GetObjectAsync (
    IN const BSTR         bstrObjectPath, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemObjectSink  * pSink
    )
{
    if (pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = CheckImpersonationLevel();
	if(FAILED(hr))
    {
		return hr;
    }

    CComPtr<IIPSecKeyChain> srpKC;
    hr = GetKeyChainByPath(bstrObjectPath, &srpKC);
    if (SUCCEEDED(hr))
    {
        //
        // now create the class and ask it to delete itself
        //

        CComPtr<IIPSecObjectImpl> srpObj;
        hr = CIPSecBase::CreateObject(m_srpNamespace, srpKC, pCtx, &srpObj);
        if (SUCCEEDED(hr))
        {
            hr = srpObj->GetInstance(pCtx, pSink);
        }
    }

    pSink->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    return hr;
}


/*
Routine Description: 

Name:

    CNetSecProv::PutInstanceAsync

Functionality:

    Given the object, we will put the instance in our namespace, which effectively
    translate into the corresponding semantics. For example, for IPSec object,
    this means that we will put the the object into SPD.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    pInst           - The object.

    lFlags          - Not in use.

    pCtx            - COM interface pointer give to us by WMI and needed for various WMI APIs.

    pInParams       - COM interface pointer to the in parameter object.

    pSink           - COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes. 

Notes:


*/

STDMETHODIMP 
CNetSecProv::PutInstanceAsync (
    IN IWbemClassObject * pInst, 
    IN long               lFlags, 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = CheckImpersonationLevel();
	if(FAILED(hr))
    {
		return hr;
    }

    //
    // we need to create our C++ class to represent this wbem object.
    // First, we need the path, which contains key property information.
    //

    CComVariant varObjPath;
    hr = pInst->Get(L"__Relpath", 0, &varObjPath, NULL, NULL);

    if (SUCCEEDED(hr) && varObjPath.vt == VT_BSTR)
    {
        CComPtr<IIPSecKeyChain> srpKC;
        hr = GetKeyChainByPath(varObjPath.bstrVal, &srpKC);

        if (SUCCEEDED(hr))
        {
            //
            // now create the class and ask it to delete itself
            //

            CComPtr<IIPSecObjectImpl> srpObj;
            hr = CIPSecBase::CreateObject(m_srpNamespace, srpKC, pCtx, &srpObj);

            if (SUCCEEDED(hr))
            {
                hr = srpObj->PutInstance(pInst, pCtx, pSink);
            }
        }
    }

    pSink->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    return hr;
}



/*
Routine Description: 

Name:

    CNetSecProv::ExecMethodAsync

Functionality:

    Given the object's path, we will execute the method on the object.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    bstrObjectPath   - The path of the object.

    bstrMethod       - The method name.

    lFlags           - Not in use.

    pCtx             - COM interface pointer give to us by WMI and needed for various WMI APIs.

    pInParams        - COM interface pointer to the in parameter object.

    pSink            - COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes. 

Notes:


*/

STDMETHODIMP 
CNetSecProv::ExecMethodAsync (
    IN const BSTR         bstrObjectPath, 
    IN const BSTR         bstrMethod, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemClassObject * pInParams,
    IN IWbemObjectSink  * pSink
    )
{

    if (pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = CheckImpersonationLevel();
	if(FAILED(hr))
    {
		return hr;
    }

    //
    // we are doing rolling back
    //

    //
    // we only have Nsp_TranxManager and Nsp_QMPolicySettings supporting methods.
    //

    if (_wcsicmp(bstrObjectPath, pszNspTranxManager) == 0)
    {
        //::UpdateGlobals(m_srpNamespace, pCtx);

        hr = CTranxManager::ExecMethod(m_srpNamespace, bstrMethod, pCtx, pInParams, pSink);
    }

    else if (_wcsicmp(bstrObjectPath, pszNspQMPolicy) == 0)
    {
        //::UpdateGlobals(m_srpNamespace, pCtx);

        hr = CQMPolicy::ExecMethod(m_srpNamespace, bstrMethod, pCtx, pInParams, pSink);
    }

    pSink->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    return hr;
}



/*
Routine Description: 

Name:

    CNetSecProv::DeleteInstanceAsync

Functionality:

    Given the object's path, we will delete the the object.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    bstrObjectPath   - The path of the object.

    lFlags           - Not in use.

    pCtx             - The COM interface pointer give to us by WMI and needed for various WMI APIs.

    pSink            - The COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes. 

Notes:


*/

STDMETHODIMP 
CNetSecProv::DeleteInstanceAsync (
    IN const BSTR         bstrObjectPath, 
    IN long               lFlags, 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    HRESULT hr = CheckImpersonationLevel();
	if(FAILED(hr))
    {
		return hr;
    }

    CComPtr<IIPSecKeyChain> srpKC;
    hr = GetKeyChainByPath(bstrObjectPath, &srpKC);

    if (SUCCEEDED(hr))
    {
        //
        // now create the class and ask it to delete the WMI object it represents
        //

        CComPtr<IIPSecObjectImpl> srpObj;
        hr = CIPSecBase::CreateObject(m_srpNamespace, srpKC, pCtx, &srpObj);
        if (SUCCEEDED(hr))
        {
            hr = srpObj->DeleteInstance(pCtx, pSink);
        }
    }

    pSink->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    return hr;
}




/*
Routine Description: 

Name:

    CNetSecProv::ExecQueryAsync

Functionality:

    Given the query, we will return the results to WMI. Each of our C++ classes knows
    how to process a query.

Virtual:
    
    Yes (part of IWbemServices).

Arguments:
    
    bstrQueryLanguage   - The query language. We don't really care about it now.

    bstrQuery           - The query.

    lFlags              - Not in use.

    pCtx                - The COM interface pointer give to us by WMI and needed for various WMI APIs.

    pSink               - The COM interface pointer to notify WMI of any results.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes. 

Notes:
    

*/

STDMETHODIMP 
CNetSecProv::ExecQueryAsync (
    IN const BSTR         bstrQueryLanguage, 
    IN const BSTR         bstrQuery, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemObjectSink  * pSink
    )
{
    if (pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }


	HRESULT hr = CheckImpersonationLevel();
	if(FAILED(hr))
    {
		return hr;
    }

    //
    // For query, we really don't know what to expect inside the where clause.
    // So, we just give "Name" which we really don't care about.
    // Subclasses knows which property it will look for.
    //

    CComPtr<IIPSecKeyChain> srpKeyChain;
    hr = GetKeyChainFromQuery(bstrQuery, L"Name", &srpKeyChain);

    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IIPSecObjectImpl> srpObj;
    hr = CIPSecBase::CreateObject(m_srpNamespace, srpKeyChain, pCtx, &srpObj);

    if (SUCCEEDED(hr))
    {
        hr = srpObj->QueryInstance(bstrQuery, pCtx, pSink);
    }

    pSink->SetStatus(WBEM_STATUS_COMPLETE, hr , NULL, NULL);
    return hr;
}



/*
Routine Description: 

Name:

    CNetSecProv::GetKeyChainByPath

Functionality:

    Given a path, we create a key chain from the path. This key chain
    contains key property information encoded in the path.

Virtual:
    
    No.

Arguments:

    pszPath     - The object's path.

    ppKeyChain  - Out parameter that receives the successfully created the key chain. 

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes. 

Notes:
    

*/

HRESULT 
CNetSecProv::GetKeyChainByPath (
    IN  LPCWSTR         pszPath,
    OUT IIPSecKeyChain ** ppKeyChain
    )
{
    if (ppKeyChain == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppKeyChain = NULL;

    CComPtr<IIPSecPathParser> srpPathParser;
    HRESULT hr = ::CoCreateInstance(CLSID_IPSecPathParser, NULL, CLSCTX_INPROC_SERVER, IID_IIPSecPathParser, (void**)&srpPathParser);

    if (SUCCEEDED(hr))
    {
        hr = srpPathParser->ParsePath(pszPath);
        if (SUCCEEDED(hr))
        {
            hr = srpPathParser->QueryInterface(IID_IIPSecKeyChain, (void**)ppKeyChain);

            //
            // S_FALSE means the object doesn't support the requested interface
            //

            if (S_FALSE == hr)
            {
                //
                // $undone:shawnwu, we need a more specific error
                //

                WBEM_E_FAILED;
            }
        }
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}



/*
Routine Description: 

Name:

    CNetSecProv::GetKeyChainFromQuery

Functionality:

    Given a query, we create a key chain from the query to parse it.
    pszWhereProp is the concerned property of the where clause. Currently,
    our parser only cares about one property. This would be improved.

Virtual:
    
    No.

Arguments:

    pszQuery        - The query.

    pszWhereProp    - The property in the where clause that we care about.

    ppKeyChain      - Out parameter that receives the successfully created the key chain. 

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes. 

Notes:
    

*/

HRESULT 
CNetSecProv::GetKeyChainFromQuery (
    IN LPCWSTR           pszQuery,
    IN LPCWSTR           pszWhereProp, 
    OUT IIPSecKeyChain **  ppKeyChain       // must not be NULL
    )
{
    if (ppKeyChain == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppKeyChain = NULL;

    CComPtr<IIPSecQueryParser> srpQueryParser;

    HRESULT hr = ::CoCreateInstance(CLSID_IPSecQueryParser, NULL, CLSCTX_INPROC_SERVER, IID_IIPSecQueryParser, (void**)&srpQueryParser);
    
    if (SUCCEEDED(hr))
    {
        //
        // this ParseQuery may fail because the where clause property may not be present at all.
        // we will thus ignore this hr
        //

        hr = srpQueryParser->ParseQuery(pszQuery, pszWhereProp);

        if (SUCCEEDED(hr))
        {
            hr = srpQueryParser->QueryInterface(IID_IIPSecKeyChain, (void**)ppKeyChain);

        
            //
            // S_FALSE means the object doesn't support the requested interface
            //

            if (S_FALSE == hr)
            {
                //
                // $undone:shawnwu, we need a more specific error
                //

                WBEM_E_FAILED;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\nsptcp.cpp ===
// NspTCP.cpp: implementation for the WMI class Nsp_TcpSettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "NspTCP.h"



/*
Routine Description: 

Name:

    CNspTCP::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

    Failure:


Notes:
    

*/

STDMETHODIMP 
CNspTCP::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    return WBEM_E_NOT_SUPPORTED;
}



/*
Routine Description: 

Name:

    CNspTCP::DeleteInstance

Functionality:

    Will delete the wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:


Notes:
    

*/

STDMETHODIMP 
CNspTCP::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}



/*
Routine Description: 

Name:

    CNspTCP::PutInstance

Functionality:

    Put a TCP object whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    
    This object is not fully defined at this point. No implementation yet.

*/

STDMETHODIMP 
CNspTCP::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}


/*
Routine Description: 

Name:

    CNspTCP::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    WBEM_E_NOT_SUPPORTED


Notes:
    

*/

STDMETHODIMP 
CNspTCP::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\policy.cpp ===
// Policy.cpp: implementation for the CPolicy base class for main mode
// and quick mode policies
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "NetSecProv.h"
#include "Policy.h"
#include "PolicyMM.h"
#include "PolicyQM.h"

//extern CCriticalSection g_CS;


/*
Routine Description: 

Name:

    CIPSecPolicy::Rollback

Functionality:

    Static function to rollback those policies added by us with the given token.

Virtual:
    
    No.

Arguments:

    pNamespace        - The namespace for ourselves.

    pszRollbackToken  - The token used to record our the action when we add
                        the policies.

    bClearAll         - Flag whether we should clear all policies. If it's true,
                        then we will delete all the policies regardless whether they
                        are added by us or not. This is a dangerous flag.

Return Value:

    Success:

        (1) WBEM_NO_ERROR: rollback objects are found and they are deleted.

        (2) WBEM_S_FALSE: no rollback objects are found.

    Failure:

        Various error codes indicating the cause of the failure.


Notes:

    We will continue the deletion even if some failure happens. That failure will be
    returned, though.

    $undone:shawnwu, should we really support ClearAll?

*/

HRESULT 
CIPSecPolicy::Rollback (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszRollbackToken,
    IN bool               bClearAll
    )
{
    if (pNamespace == NULL || pszRollbackToken == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //if (bClearAll)
    //{
    //    return ClearAllPolicies(pNamespace);
    //}

    CComPtr<IEnumWbemClassObject> srpEnum;

    //
    // this will only enumerate all rollback filter object without testing the 
    // the token guid. This limitation is due to a mysterious error 
    // for any queries containing the where clause. That might be a limitation
    // of non-dynamic classes of WMI
    //

    HRESULT hr = ::GetClassEnum(pNamespace, pszNspRollbackPolicy, &srpEnum);

    //
    // go through all found classes. srpEnum->Next will return WBEM_S_FALSE if instance
    // is not found.
    //

    CComPtr<IWbemClassObject> srpObj;
    ULONG nEnum = 0;
    HRESULT hrError = WBEM_NO_ERROR;

    hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
    bool bHasInst = (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj != NULL);

    while (SUCCEEDED(hr) && hr != WBEM_S_FALSE && srpObj)
    {
        CComVariant varTokenGuid;
        hr = srpObj->Get(g_pszTokenGuid, 0, &varTokenGuid, NULL, NULL);

        //
        // need to compare the token guid ourselves
        //

        if (SUCCEEDED(hr) && 
            varTokenGuid.vt == VT_BSTR && 
            varTokenGuid.bstrVal != NULL &&
            (_wcsicmp(pszRollbackToken, pszRollbackAll) == 0 || _wcsicmp(pszRollbackToken, varTokenGuid.bstrVal) == 0 )
            )
        {
            //
            // get the policy name and find the policy by the name
            //

            CComVariant varPolicyName;
            CComVariant varPolicyType;
            hr = srpObj->Get(g_pszPolicyName,  0, &varPolicyName, NULL, NULL);

            GUID guidFilter = GUID_NULL;

            //
            // different types of policy has different 
            //

            if (SUCCEEDED(hr))
            {
                hr = srpObj->Get(g_pszPolicyType,  0, &varPolicyType, NULL, NULL);

                if (SUCCEEDED(hr) && varPolicyType.vt != VT_I4)
                {
                    hr = WBEM_E_INVALID_OBJECT;
                }
            }

            if (SUCCEEDED(hr) && varPolicyName.vt == VT_BSTR)
            {
                DWORD dwResumeHandle = 0;
                DWORD dwReturned = 0;
                DWORD dwStatus;

                if (varPolicyType.lVal == MainMode_Policy)
                {
                    //
                    // main mode policy
                    //

                    hr = CMMPolicy::DeletePolicy(varPolicyName.bstrVal);
                }
                else if (varPolicyType.lVal == QuickMode_Policy)
                {
                    //
                    // quick mode policy
                    //

                    hr = CQMPolicy::DeletePolicy(varPolicyName.bstrVal);
                }
            }

            if (SUCCEEDED(hr))
            {
                CComVariant varPath;
                if (SUCCEEDED(srpObj->Get(L"__RelPath", 0, &varPath, NULL, NULL)) && varPath.vt == VT_BSTR)
                {
                    hr = pNamespace->DeleteInstance(varPath.bstrVal, 0, NULL, NULL);
                }
            }

            //
            // we are tracking the first error
            //

            if (FAILED(hr) && SUCCEEDED(hrError))
            {
                hrError = hr;
            }
        }
        
        //
        // ready it for re-use
        //

        srpObj.Release();
        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
    }

    if (SUCCEEDED(hr))
    {
        hr = CQMPolicy::DeleteDefaultPolicies();
    }

    if (!bHasInst)
    {
        return WBEM_S_FALSE;
    }
    else
    {
        //
        // any failure code will be returned regardless of the final hr
        //

        if (FAILED(hrError))
        {
            return hrError;
        }
        else
        {
            return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
        }
    }
}


/*
Routine Description: 

Name:

    CIPSecPolicy::ClearAllPolicies

Functionality:

    Static function to delete all policies in SPD. This is a very dangerous action!

Virtual:
    
    No.

Arguments:

    pNamespace  - The namespace for ourselves.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        Various error codes indicating the cause of the failure.


Notes:

    We will continue the deletion even if some failure happens. That failure will be
    returned, though.

    $undone:shawnwu, should we really support this?

*/

HRESULT 
CIPSecPolicy::ClearAllPolicies (
    IN IWbemServices * pNamespace
    )
{
    DWORD dwResumeHandle = 0;
    DWORD dwReturned = 0;
    DWORD dwStatus;

    HRESULT hr = WBEM_NO_ERROR;
    HRESULT hrError = WBEM_NO_ERROR;

    //
    // SPD doesn't have a similar API.
    // We have to do one by one. For that purpose, we need the name.
    //

    //
    // Delete main mode policies.
    //

    PIPSEC_MM_POLICY *ppMMPolicy = NULL;
    dwStatus = ::EnumMMPolicies(NULL, ppMMPolicy, 1, &dwReturned, &dwResumeHandle);
    while (ERROR_SUCCESS == dwStatus && dwReturned > 0)
    {
        hr = CMMPolicy::DeletePolicy((*ppMMPolicy)->pszPolicyName);

        //
        // we will track the first error
        //

        if (FAILED(hr) && SUCCEEDED(hrError))
        {
            hrError = hr;
        }

        FreePolicy(ppMMPolicy, true);
        *ppMMPolicy = NULL;

        dwReturned = 0;
        dwStatus = ::EnumMMPolicies(NULL, ppMMPolicy, 1, &dwReturned, &dwResumeHandle);
    }

    //
    // Delete quick mode policies.
    //

    PIPSEC_QM_POLICY *ppQMPolicy = NULL;

    dwResumeHandle = 0;
    dwReturned = 0;
    dwStatus = ::EnumQMPolicies(NULL, ppQMPolicy, 1, &dwReturned, &dwResumeHandle);
    while (ERROR_SUCCESS == dwStatus && dwReturned > 0)
    {
        hr = CQMPolicy::DeletePolicy((*ppQMPolicy)->pszPolicyName);

        //
        // we will track the first error
        //

        if (FAILED(hr) && SUCCEEDED(hrError))
        {
            hrError = hr;
        }

        FreePolicy(ppQMPolicy, true);
        *ppQMPolicy = NULL;

        dwReturned = 0;
        dwStatus = ::EnumQMPolicies(NULL, ppQMPolicy, 1, &dwReturned, &dwResumeHandle);
    }

    //
    // now, let's clear up all past action information for policies deposited in the
    // WMI depository
    //

    hr = ::DeleteRollbackObjects(pNamespace, pszNspRollbackPolicy);

    if (FAILED(hr) && SUCCEEDED(hrError))
    {
        hrError = hr;
    }

    return SUCCEEDED(hrError) ? WBEM_NO_ERROR : hrError;
}


/*
Routine Description: 

Name:

    CIPSecPolicy::OnAfterAddPolicy

Functionality:

    Post-adding handler to be called after successfully added a policy to SPD.

Virtual:
    
    No.

Arguments:

    pszPolicyName   - The name of the filter.

    eType           - The type of the policy (main mode or quick mode).

Return Value:

    Success:

        (1) WBEM_NO_ERROR: if rollback object is successfully created.

        (2) WBEM_S_FALSE: if there is no rollback guid information.

    Failure:

        (1) various errors indicated by the returned error codes.


Notes:
    
    (1) Currently, we don't require a rollback object to be created for each 
        object added to SPD. Only a host that support rollback will deposit
        rollback guid information and only then can we create a rollback object.

*/

HRESULT 
CIPSecPolicy::OnAfterAddPolicy (
    IN LPCWSTR          pszPolicyName,
    IN EnumPolicyType   eType
    )
{
    //
    // will create an Nsp_RollbackPolicy
    //

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = SpawnRollbackInstance(pszNspRollbackPolicy, &srpObj);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // won't consider a failure if there is no rollback guid, i.e., this action is not
    // part of a transaction block
    //

    if (SUCCEEDED(hr))
    {
        //
        // $undone:shawnwu, this approach to pulling the globals are not good.
        // Instead, we should implement it as an event handler. 
        //

        //::UpdateGlobals(m_srpNamespace, m_srpCtx);
        //if (g_varRollbackGuid.vt != VT_NULL && g_varRollbackGuid.vt != VT_EMPTY)
        //{
        //    hr = srpObj->Put(g_pszTokenGuid, 0, &g_varRollbackGuid, CIM_EMPTY);
        //}
        //else
        //{

        CComVariant varRollbackNull = pszEmptyRollbackToken;
        hr = srpObj->Put(g_pszTokenGuid, 0, &varRollbackNull, CIM_EMPTY);

        //}

        //
        // we can create a rollback object
        //

        if (SUCCEEDED(hr))
        {

            //
            // $undone:shawnwu, Currently, we only support rolling back added objects, not removed objects
            // Also, we don't cache the previous instance data yet.
            //

            VARIANT varAction;

            //
            // This is to record a PutInstance action
            //

            varAction.vt = VT_I4;
            varAction.lVal = Action_Add;

            hr = srpObj->Put(g_pszAction, 0, &varAction, CIM_EMPTY);

            if (SUCCEEDED(hr))
            {
                //
                // need to remember the policy's name
                //

                CComVariant var = pszPolicyName;
                hr = srpObj->Put(g_pszPolicyName, 0, &var, CIM_EMPTY);
                if (SUCCEEDED(hr))
                {
                    var.Clear();
                    var.vt = VT_I4;
                    var.lVal = eType;
                    hr = srpObj->Put(g_pszPolicyType, 0, &var, CIM_EMPTY);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_srpNamespace->PutInstance(srpObj, WBEM_FLAG_CREATE_OR_UPDATE, m_srpCtx, NULL);
        if (SUCCEEDED(hr))
        {
            hr = WBEM_NO_ERROR;
        }
    }
    else if (SUCCEEDED(hr))
    {
        //
        // we don't have rollback guid
        //

        hr = WBEM_S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\nsptcp.h ===
//////////////////////////////////////////////////////////////////////
// TCP.h : Declaration of CNspTCP class which implements our WMI class
// Nsp_TcpSettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"


/*

Class description
    
    Naming: 

        CNspTCP stands for TCP Settings.
    
    Base class: 
        
        CIPSecBase, because it is a class representing a WMI object - its WMI 
        class name is Nsp_TcpSettings
    
    Purpose of class:

        (1) Not known at this point.
    
    Design:

        (1) Not implemented at this time.

    
    Use:

  */


class ATL_NO_VTABLE CNspTCP :
    public CIPSecBase
{
protected:
    CNspTCP(){}
    virtual ~CNspTCP(){}

public:


    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\policy.h ===
//////////////////////////////////////////////////////////////////////
// Policy.h : Declaration of base class for main mode and quick mode
// policies classes
// security WMI provider for SCE
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 4/11/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"

extern CComVariant g_varRollbackGuid;

const DWORD DefaultMMPolicyFlag         = 0;
const DWORD DefaultQMPolicyFlag         = 0;
const DWORD DefaultMMPolicyOfferFlag    = 0;
const DWORD DefaultQMPolicyOfferFlag    = 0;

const DWORD DefaultaultSoftSAExpirationTime = DEFAULT_MM_KEY_EXPIRATION_TIME;

//
// any value is valid. 0 means unlimited
//

const DWORD DefaultQMModeLimit = 32;

//
// either DH_GROUP_1 or DH_GROUP_2 (stronger and more costly)
//

const DWORD DefaultDHGroup = DH_GROUP_1;   

//
//IPSEC_DOI_ESP_3_DES is more cost
//

const DWORD DefaultEncryptAlgoID = IPSEC_DOI_ESP_DES;

const DWORD DefaultHashAlgoID = 0;

//
// either is valid, TRUE more cost
//

const BOOL DefaultPFSRequired = FALSE;

const DWORD DefaultPFSGroup = PFS_GROUP_NONE;
const DWORD DefaultNumAlgos = 1;


//
// If ENCRYPTION, then uAlgoIdentifier is the IPSEC_DOI_ESP_DES or IPSEC_DOI_ESP_3_DES
//      and uSecAlgoIdentifier can't be HMAC_AH_NONE
// else if AUTHENTICATION then uAlgoIdentifier is IPSEC_DOI_AH_MD5 or IPSEC_DOI_AH_SHA1, 
//      and uSecAlgoIdentifier should be HMAC_AH_NONE
// else if COMPRESSION, ??
// else if SA_DELETE, ??
//

const IPSEC_OPERATION DefaultQMAlgoOperation = ENCRYPTION;

const ULONG DefaultAlgoID = IPSEC_DOI_ESP_DES;

const HMAC_AH_ALGO DefaultAlgoSecID = HMAC_AH_MD5;

//
// We have two different types of policies in SPD
//

enum EnumPolicyType
{
    MainMode_Policy = 1,
    QuickMode_Policy = 2,
};


/*

Class description
    
    Naming: 

        CIPSecPolicy stands for IPSec Policy.
    
    Base class: 
        
        CIPSecBase
    
    Purpose of class:

        (1) Being a base for both main mode policy and quick mode policy implementations.
    
    Design:

        (1) Provide property access (both Put and Get) that are common to both main mode
            and quick mode. See GetPolicyFromWbemObj/CreateWbemObjFromPolicy.
           
        (2) Provide rollback support. Both main mode and quick mode have the same logic.

        (3) Provide some allocation/deallocation that can be parameterized using template functions.

    
    Use:

        (1) Class is designed for inheritance use.
        
        (2) Rollback, GetPolicyFromWbemObj, and CreateWbemObjFromPolicy are the ones
            you will use directly, even though all other static ones are also
            available for the other classes, they are not intended for such use.

    Notes:

        (1) It contains several template functions. This reduces the duplicate code.
        

*/

class CIPSecPolicy : 
    public CIPSecBase
{

protected:

    CIPSecPolicy(){}
    virtual ~CIPSecPolicy(){}

public:

    static 
    HRESULT Rollback (
        IN IWbemServices    * pNamespace, 
        IN LPCWSTR            pszRollbackToken, 
        IN bool               bClearAll
        );

    //
    // some template functions
    //

    /*
    Routine Description: 

    Name:

        CIPSecPolicy::GetPolicyFromWbemObj

    Functionality:

        Given a wbem object representing a policy (either main mode or quick mode), this
        function either finds the policy from SPD or creates a new one and fill in the wbem
        object's properties into the policy struct.

    Virtual:
    
        No.

    Arguments:

        pInst       - The wbem object.

        ppPolicy    - Receives the policy. This can be PIPSEC_MM_POLICY or PIPSEC_QM_POLICY.
                      Caller needs to free this by calling FreePolicy;

        pbPreExist  - Whether SPD allocates the buffer (true) or not (false).

    Return Value:

        Success:

            WBEM_NO_ERROR

        Failure:

            (1) WBEM_E_INVALID_PARAMETER if ppPolicy == NULL or pdwResumeHandle == NULL.

            (2) WBEM_E_NOT_FOUND if the policy is not found.

    Notes:
    
        (1) Make sure that you call FreePolicy to free the buffer!


    */

    template <class Policy>
    static 
    HRESULT GetPolicyFromWbemObj     (
        IN  IWbemClassObject  * pInst,
        OUT Policy           ** ppPolicy,
        OUT bool              * pbPreExist
        )
    {
        if (pInst == NULL || ppPolicy == NULL || pbPreExist == NULL)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppPolicy = NULL;
        *pbPreExist = false;

        DWORD dwResumeHandle = 0;

        // this var will be re-used again and again. Each should be Clear'ed before reuse.
        CComVariant var;
        // try to find out if the filter already exists
        HRESULT hr = pInst->Get(g_pszPolicyName, 0, &var, NULL, NULL);

        if (SUCCEEDED(hr) && var.vt == VT_BSTR)
        {   // see if this is a filter we already have
            hr = FindPolicyByName(var.bstrVal, ppPolicy, &dwResumeHandle);

            if (SUCCEEDED(hr))
                *pbPreExist = true;
            else
            {
                // can't find it, fine. I will create a new one
                hr = AllocPolicy(ppPolicy);
                if (SUCCEEDED(hr))
                {
                    (*ppPolicy)->pszPolicyName = NULL;
                    hr = ::CoCreateGuid(&((*ppPolicy)->gPolicyID));
                    if (SUCCEEDED(hr))
                    {
                        // give it the name
                        DWORD dwSize = wcslen(var.bstrVal) + 1;
                        (*ppPolicy)->pszPolicyName = new WCHAR[dwSize];
                        if (NULL == (*ppPolicy)->pszPolicyName)
                            hr = WBEM_E_OUT_OF_MEMORY;
                        else
                        {
                            ::memcpy((*ppPolicy)->pszPolicyName, var.bstrVal, dwSize * sizeof(WCHAR));
                        }
                    }
                }


                // dwFlags and pOffers
                if (SUCCEEDED(hr))
                {
                    var.Clear();
                    // dwFlags. We allow this to be missing
                    if (SUCCEEDED(pInst->Get(g_pszPolicyFlag, 0, &var, NULL, NULL)) && var.vt == VT_I4)
                        (*ppPolicy)->dwFlags = var.lVal;
                    else
                        (*ppPolicy)->dwFlags = 0;

                    hr = pInst->Get(g_pszOfferCount, 0, &var, NULL, NULL);
                    if (SUCCEEDED(hr) && var.vt == VT_I4)
                    {
                        hr = AllocOffer( &((*ppPolicy)->pOffers), var.lVal);
                        if (SUCCEEDED(hr))
                            (*ppPolicy)->dwOfferCount = var.lVal;
                    }
                    else
                        hr = WBEM_E_INVALID_OBJECT;
                }

                // set up the LifeTime
                if (SUCCEEDED(hr))
                {

                    DWORD* pdwTimeKBytes = new DWORD[(*ppPolicy)->dwOfferCount];
                    if (pdwTimeKBytes == NULL)
                        hr = WBEM_E_OUT_OF_MEMORY;
                    else
                    {
                        var.Clear();
                        // we will allow the life-time's expiration time to be missing since we have defaults
                        // if we successfully get the key life exp time, then set them
                        if ( SUCCEEDED(pInst->Get(g_pszKeyLifeTime, 0, &var, NULL, NULL)) && 
                             (var.vt & VT_ARRAY) == VT_ARRAY )
                        {
                                hr = ::GetDWORDSafeArrayElements(&var, (*ppPolicy)->dwOfferCount, pdwTimeKBytes);

                            // if get the exp times
                            if (SUCCEEDED(hr))
                            {
                                for (long l = 0; l < (*ppPolicy)->dwOfferCount; l++)
                                {
                                    (*ppPolicy)->pOffers[l].Lifetime.uKeyExpirationTime = pdwTimeKBytes[l];
                                }
                            }
                        }

                        var.Clear();
                        // set the expiration kbytes, again, we allow the info to be missing since we already has default
                        if ( SUCCEEDED(pInst->Get(g_pszKeyLifeTimeKBytes, 0, &var, NULL, NULL)) && 
                             (var.vt & VT_ARRAY) == VT_ARRAY )
                        {
                                hr = ::GetDWORDSafeArrayElements(&var, (*ppPolicy)->dwOfferCount, pdwTimeKBytes);

                            // if get the exp kbytes
                            if (SUCCEEDED(hr))
                            {
                                for (long l = 0; l < (*ppPolicy)->dwOfferCount; l++)
                                {
                                    (*ppPolicy)->pOffers[l].Lifetime.uKeyExpirationKBytes = pdwTimeKBytes[l];
                                }
                            }
                        }

                        delete [] pdwTimeKBytes;
                    }
                }
            }
        }
        
        if (FAILED(hr))
        {
            FreePolicy(ppPolicy, *pbPreExist);
        }
        return hr;
    };

    template<class Policy>
    HRESULT CreateWbemObjFromPolicy(Policy* pPolicy, IWbemClassObject* pInst)
    {
        if (pInst == NULL || pPolicy == NULL)
            return WBEM_E_INVALID_PARAMETER;

        CComVariant var = pPolicy->pszPolicyName;
        HRESULT hr = pInst->Put(g_pszPolicyName, 0, &var, CIM_EMPTY);

        // put offer count
        if (SUCCEEDED(hr))
        {
            var.Clear();
            var.vt = VT_I4;

            // don't really care much about dwFlags
            var.lVal = pPolicy->dwFlags;
            pInst->Put(g_pszPolicyFlag, 0, &var, CIM_EMPTY);

            var.lVal = pPolicy->dwOfferCount;
            hr = pInst->Put(g_pszOfferCount, 0, &var, CIM_EMPTY);
        }

        // put LifeTime
        if (SUCCEEDED(hr))
        {
            // create the a safearray
            var.vt    = VT_ARRAY | VT_I4;
            SAFEARRAYBOUND rgsabound[1];
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = pPolicy->dwOfferCount;
            var.parray = ::SafeArrayCreate(VT_I4, 1, rgsabound);

            if (var.parray == NULL)
                hr = WBEM_E_OUT_OF_MEMORY;
            else
            {
                long lIndecies[1];

                // deal with uKeyExpirationTime
                for (DWORD dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                {
                    lIndecies[0] = dwIndex;
                    hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].Lifetime.uKeyExpirationTime) );
                }
                if (SUCCEEDED(hr))
                    hr = pInst->Put(g_pszKeyLifeTime, 0, &var, CIM_EMPTY);

                // deal with uKeyExpirationKBytes
                for (DWORD dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                {
                    lIndecies[0] = dwIndex;
                    hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].Lifetime.uKeyExpirationKBytes) );
                }
                if (SUCCEEDED(hr))
                    hr = pInst->Put(g_pszKeyLifeTimeKBytes, 0, &var, CIM_EMPTY);
            }
        }
        return hr;
    }

protected:
    
    template<class Policy>
    static HRESULT AllocPolicy(Policy** ppPolicy)
    {
        if (ppPolicy == NULL)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hr = WBEM_NO_ERROR;
        *ppPolicy = new Policy;
        if (*ppPolicy)
        {
            (*ppPolicy)->pszPolicyName = NULL;
            (*ppPolicy)->dwOfferCount = 0;
            (*ppPolicy)->pOffers = NULL;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
        return hr;
    }
    
    static void GetDefaultOfferLifeTime(PIPSEC_MM_OFFER pOffer, DWORD* pdwDefFlag, ULONG* pulTime, ULONG* pulKBytes)
    {
        *pdwDefFlag = DefaultMMPolicyOfferFlag;
        *pulTime = DEFAULT_MM_KEY_EXPIRATION_TIME;
        *pulKBytes = DEFAULT_QM_KEY_EXPIRATION_KBYTES;
    }

    static void GetDefaultOfferLifeTime(PIPSEC_QM_OFFER pOffer, DWORD* pdwDefFlag, ULONG* pulTime, ULONG* pulKBytes)
    {
        *pdwDefFlag = DefaultQMPolicyOfferFlag;
        *pulTime = DEFAULT_QM_KEY_EXPIRATION_TIME;
        *pulKBytes = DEFAULT_QM_KEY_EXPIRATION_KBYTES;
    }

    template<class Offer>    
    static HRESULT AllocOffer(Offer** ppOffer, long lCount)
    {
        if (ppOffer == NULL)
            return WBEM_E_INVALID_PARAMETER;

        *ppOffer = new Offer[lCount];
        if (*ppOffer != NULL)
        {
            ULONG ulTime, ulKBytes;
            DWORD dwDefFlag;
            GetDefaultOfferLifeTime(*ppOffer, &dwDefFlag, &ulTime, &ulKBytes);

            for (long l = 0; l < lCount; l++)
            {
                (*ppOffer)[l].dwFlags = dwDefFlag;
                (*ppOffer)[l].Lifetime.uKeyExpirationTime = ulTime;
                (*ppOffer)[l].Lifetime.uKeyExpirationKBytes = ulKBytes;
            }
            return WBEM_NO_ERROR;
        }
        else
            return WBEM_E_OUT_OF_MEMORY;
    }

    template<class Policy>
    static void FreePolicy(Policy** ppPolicy, bool bPreExist)
    {
        if (ppPolicy == NULL || *ppPolicy == NULL)
            return;

        if (bPreExist)
            ::SPDApiBufferFree(*ppPolicy);
        else
        {
            delete [] (*ppPolicy)->pszPolicyName;
            delete [] (*ppPolicy)->pOffers;
            delete *ppPolicy;
        }
        *ppPolicy = NULL;
    };

    static HRESULT ClearAllPolicies(IWbemServices* pNamespace);

    HRESULT OnAfterAddPolicy(LPCWSTR pszPolicyName, EnumPolicyType eType);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\policymm.cpp ===
// PolicyMM.cpp: implementation for the WMI class Nsp_MMPolicySettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "PolicyMM.h"
#include "NetSecProv.h"



/*
Routine Description: 

Name:

    CMMPolicy::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

        (1) WBEM_NO_ERROR if instances are returned;

        (2) WBEM_S_NO_MORE_DATA if no instances are returned.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.


Notes:
    

*/

STDMETHODIMP 
CMMPolicy::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    //
    // get the policy name from the query    
    // the given key chain doesn't know anything about where clause property should be policy name
    // so make another one ourselves.
    //

    m_srpKeyChain.Release();

    HRESULT hr = CNetSecProv::GetKeyChainFromQuery(pszQuery, g_pszPolicyName, &m_srpKeyChain);
    if (FAILED(hr))
    {
        return hr;
    }

    CComVariant varPolicyName;

    //
    // GetKeyPropertyValue will return WBEM_S_FALSE in case the requested key property
    // is not found. That is fine because we are querying.
    //
    
    hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPolicyName, &varPolicyName);

    LPCWSTR pszPolicyName = (varPolicyName.vt == VT_BSTR) ? varPolicyName.bstrVal : NULL;

    //
    // let's enumerate all fitting policies
    //

    DWORD dwResumeHandle = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;

    hr = FindPolicyByName(pszPolicyName, &pMMPolicy, &dwResumeHandle);

    while (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromMMPolicy(pMMPolicy, &srpObj);

        //
        // we have successfully created a policy, give it to WMI.
        //

        if (SUCCEEDED(hr))
        {
            pSink->Indicate(1, &srpObj);
        }
        
        ::SPDApiBufferFree(pMMPolicy);

        pMMPolicy = NULL;

        hr = FindPolicyByName(pszPolicyName, &pMMPolicy, &dwResumeHandle);
    }

    //
    // since we are querying, it's ok to return not found
    //

    if (WBEM_E_NOT_FOUND == hr)
    {
        hr = WBEM_S_NO_MORE_DATA;
    }
    else if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CMMPolicy::DeleteInstance

Functionality:

    Will delete the wbem object, which will cause the main mode policy to be deleted.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        WBEM_NO_ERROR;

    Failure:

        (1) WBEM_E_NOT_FOUND. Whether or not this should be considered an error
            depends on context.

        (2) Other errors indicating the cause.
Notes:
    

*/

STDMETHODIMP 
CMMPolicy::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    CComVariant varPolicyName;

    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPolicyName, &varPolicyName);

    if (FAILED(hr))
    {
        return hr;
    }
    else if (varPolicyName.vt != VT_BSTR || varPolicyName.bstrVal == NULL || varPolicyName.bstrVal[0] == L'\0')
    {
        return WBEM_E_NOT_FOUND;
    }

    return DeletePolicy(varPolicyName.bstrVal);
}


/*
Routine Description: 

Name:

    CMMPolicy::PutInstance

Functionality:

    Put a main mode policy into SPD whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CMMPolicy::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pInst == NULL || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    bool bPreExist = false;

    //
    // for those policies that are created by ourselves (bPreExist == true)
    // we have our own way of allocating the buffer, need to free it in our corresponding way
    //

    PIPSEC_MM_POLICY pPolicy = NULL;
    HRESULT hr = GetMMPolicyFromWbemObj(pInst, &pPolicy, &bPreExist);

    //
    // if policy is successfully returned, then use it
    //

    if (SUCCEEDED(hr) && pPolicy)
    {
        hr = AddPolicy(bPreExist, pPolicy);

        //
        // deposit info about this action so that we can rollback
        //

        if (SUCCEEDED(hr))
        {
            hr = OnAfterAddPolicy(pPolicy->pszPolicyName, MainMode_Policy);
        }

        FreePolicy(&pPolicy, bPreExist);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CMMPolicy::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        Success code. Use SUCCEEDED(hr) to test.

    Failure:

        (1) WBEM_E_NOT_FOUND if the auth method can't be found. Depending on
            the context, this may not be an error

        (2) Other various errors indicated by the returned error codes.


Notes:
    

*/

STDMETHODIMP 
CMMPolicy::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    CComVariant varPolicyName;

    //
    // since policy name is a key property, it must have policy name property in the path and thus in the key chain
    //

    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPolicyName, &varPolicyName);
    if (FAILED(hr))
    {
        return hr;
    }
    else if (varPolicyName.vt != VT_BSTR || varPolicyName.bstrVal == NULL || varPolicyName.bstrVal[0] == L'\0')
    {
        return WBEM_E_NOT_FOUND;
    }

    PIPSEC_MM_POLICY pMMPolicy = NULL;
    DWORD dwResumeHandle = 0;

    hr = FindPolicyByName(varPolicyName.bstrVal, &pMMPolicy, &dwResumeHandle);

    if (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromMMPolicy(pMMPolicy, &srpObj);

        if (SUCCEEDED(hr))
        {
            hr = pSink->Indicate(1, &srpObj);
        }

        ::SPDApiBufferFree(pMMPolicy);
    }

    return hr; 
}


/*
Routine Description: 

Name:

    CMMPolicy::CreateWbemObjFromMMPolicy

Functionality:

    Given a SPD's main mode policy, we will create a wbem object representing it.

Virtual:
    
    No.

Arguments:

    pPolicy  - The SPD's main mode policy object.

    ppObj    - Receives the wbem object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CMMPolicy::CreateWbemObjFromMMPolicy (
    IN  PIPSEC_MM_POLICY    pPolicy,
    OUT IWbemClassObject ** ppObj
    )
{
    if (pPolicy == NULL || ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppObj = NULL;

    //
    // create a wbem object of this class that can be used to fill in properties
    //

    HRESULT hr = SpawnObjectInstance(ppObj);

    if (SUCCEEDED(hr))
    {
        //
        // fill in base class members (CIPSecPolicy)
        //

        hr = CreateWbemObjFromPolicy(pPolicy, *ppObj);

        CComVariant var;

        //
        // put MM policy specific members
        //

        //
        // SoftSAExpTime
        //

        if (SUCCEEDED(hr))
        {
            var.Clear();
            var.vt = VT_I4;
            var.lVal = pPolicy->uSoftSAExpirationTime;
            hr = (*ppObj)->Put(g_pszSoftSAExpTime, 0, &var, CIM_EMPTY);
        }

        //
        // now, all those array data
        //

        if (SUCCEEDED(hr))
        {
            var.vt    = VT_ARRAY | VT_I4;
            SAFEARRAYBOUND rgsabound[1];
            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = pPolicy->dwOfferCount;
            var.parray = ::SafeArrayCreate(VT_I4, 1, rgsabound);

            if (var.parray == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                long lIndecies[1];

                //
                //$undone:shawnwu, we need to write some generic routine to do this repeatitive array
                // put (and get). That routine can only be based on memory offset!
                //

                //
                // put dwQuickModeLimit
                //

                for (DWORD dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                {
                    lIndecies[0] = dwIndex;
                    hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].dwQuickModeLimit) );
                }

                if (SUCCEEDED(hr))
                {
                    hr = (*ppObj)->Put(g_pszQMLimit, 0, &var, CIM_EMPTY);
                }

                //
                // put dwDHGroup
                //

                for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                {
                    lIndecies[0] = dwIndex;
                    hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].dwDHGroup) );
                }

                if (SUCCEEDED(hr))
                {
                    hr = (*ppObj)->Put(g_pszDHGroup, 0, &var, CIM_EMPTY);
                }

                //
                // put EncryptionAlgorithm.uAlgoIdentifier
                //

                for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                {
                    lIndecies[0] = dwIndex;
                    hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].EncryptionAlgorithm.uAlgoIdentifier) );
                }

                if (SUCCEEDED(hr))
                {
                    hr = (*ppObj)->Put(g_pszEncryptID, 0, &var, CIM_EMPTY);
                }

                //
                // put HashingAlgorithm.uAlgoIdentifier
                //

                for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                {
                    lIndecies[0] = dwIndex;
                    hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].HashingAlgorithm.uAlgoIdentifier) );
                }

                if (SUCCEEDED(hr))
                {
                    hr = (*ppObj)->Put(g_pszHashID, 0, &var, CIM_EMPTY);
                }
            }
        }
    }

    //
    // we may have created the object, but some mid steps have failed,
    // so let's release the object.
    //

    if (FAILED(hr) && *ppObj != NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;     
}


/*
Routine Description: 

Name:

    CMMPolicy::GetMMPolicyFromWbemObj

Functionality:

    Will try to get the main mode policy if such policy already exists.
    Otherwise, we will create a new one.

Virtual:
    
    No.

Arguments:

    pInst       - The wbem object object.

    ppPolicy    - Receives the quick mode policy.

    pbPreExist  - Receives the information whether this object memory is allocated by SPD or not.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:
    
    if some property is missing from the wbem object, we will supply the default value.

*/

HRESULT 
CMMPolicy::GetMMPolicyFromWbemObj (
    IN  IWbemClassObject * pInst, 
    OUT PIPSEC_MM_POLICY * ppPolicy, 
    OUT bool             * pbPreExist
    )
{
    if (pInst == NULL || ppPolicy == NULL || pbPreExist == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppPolicy = NULL;
    *pbPreExist = false;
    HRESULT hr = GetPolicyFromWbemObj(pInst, ppPolicy, pbPreExist);

    //
    // we don't support modification on existing policies
    //

    if (SUCCEEDED(hr) && *pbPreExist == false)
    {
        CComVariant var;

        //
        // set uSoftSAExpirationTime
        //

        if (SUCCEEDED(pInst->Get(g_pszSoftSAExpTime, 0, &var, NULL, NULL)) && var.vt == VT_I4)
        {
            (*ppPolicy)->uSoftSAExpirationTime = var.lVal;
        }
        else
        {
            (*ppPolicy)->uSoftSAExpirationTime = DefaultaultSoftSAExpirationTime;
        }

        //
        // now, fill in each offer's contents
        //

        //
        // wbem object may not have all the properties, we will use default when a property is missing.
        // as a result, we don't keep the HRESULT and return it the caller
        //

        //
        // for readability
        //

        DWORD dwOfferCount = (*ppPolicy)->dwOfferCount;

        //
        // need to delete the memory
        //

        DWORD* pdwValues = new DWORD[dwOfferCount];
        long l;

        if (pdwValues == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            var.Clear();

            //
            // If the property is missing from wbem object, we will initialize them to default values.
            //

            bool bInitialized = false;

            //
            // set dwQuickModeLimit
            //

            if ( SUCCEEDED(pInst->Get(g_pszQMLimit, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].dwQuickModeLimit = pdwValues[l];
                    }
                }
            }

            if (!bInitialized)
            {
                //
                // set to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].dwQuickModeLimit = DefaultQMModeLimit;
                }
            }

            //
            // ready for next property
            //

            bInitialized = false;
            var.Clear();

            //
            // set dwDHGroup;
            //

            if ( SUCCEEDED(pInst->Get(g_pszDHGroup, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].dwDHGroup = pdwValues[l];
                    }
                }
            }

            if (!bInitialized)
            {
                //
                // set to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].dwDHGroup = DefaultDHGroup;
                }
            }

            //
            // ready for next property
            //

            bInitialized = false;
            var.Clear();

            //
            // IPSEC_MM_ALGO EncryptionAlgorithm;
            //

            //
            // set EncriptionAlogirthm's uAlgoIdentifier
            //

            if ( SUCCEEDED(pInst->Get(g_pszEncryptID, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].EncryptionAlgorithm.uAlgoIdentifier = pdwValues[l];
                    }
                }
            }

            if (!bInitialized)
            {
                //
                // set to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].EncryptionAlgorithm.uAlgoIdentifier = DefaultEncryptAlgoID;
                }
            }

            //
            // ready for next property
            //

            bInitialized = false;
            var.Clear();

            //
            // IPSEC_MM_ALGO HashingAlgorithm;
            //

            //
            // set EncriptionAlogirthm's uAlgoIdentifier
            //

            if ( SUCCEEDED(pInst->Get(g_pszEncryptID, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].HashingAlgorithm.uAlgoIdentifier = pdwValues[l];
                    }
                }
            }

            if (!bInitialized)
            {
                //
                // set to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].HashingAlgorithm.uAlgoIdentifier = DefaultHashAlgoID;
                }
            }           

            //
            // done with the array
            //

            delete [] pdwValues;
        }
    }

    if (FAILED(hr) && *ppPolicy != NULL)
    {
        FreePolicy(ppPolicy, *pbPreExist);
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


/*
Routine Description: 

Name:

    CMMPolicy::AddPolicy

Functionality:

    Add the main quick mode policy to SPD.

Virtual:
    
    No.

Arguments:

    bPreExist - Flag whether the main mode auth method already exists in SPD

    pQMPolicy - The quick mode policy to add.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        WBEM_E_FAILED.

Notes:

*/

HRESULT 
CMMPolicy::AddPolicy (
    IN bool             bPreExist,
    IN PIPSEC_MM_POLICY pMMPolicy
    )
{
    HANDLE hFilter = NULL;
    DWORD dwResult = ERROR_SUCCESS;

    HRESULT hr = WBEM_NO_ERROR;

    if (bPreExist)
    {
        dwResult = ::SetMMPolicy(NULL, pMMPolicy->pszPolicyName, pMMPolicy);
    }
    else
    {
        dwResult = ::AddMMPolicy(NULL, 1, pMMPolicy);
    }

    if (dwResult != ERROR_SUCCESS)
    {
        hr = ::IPSecErrorToWbemError(dwResult);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CMMPolicy::DeletePolicy

Functionality:

    Delete given main mode policy from SPD.

Virtual:
    
    No.

Arguments:

    pszPolicyName - The name of the policy to delete.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        (1) WBEM_E_INVALID_PARAMETER: if pszPolicyName == NULL or *pszPolicyName == L'\0'.

        (2) WBEM_E_VETO_DELETE: if we are not allowed to delete the policy by SPD.

Notes:

*/

HRESULT 
CMMPolicy::DeletePolicy (
    IN LPCWSTR pszPolicyName
    )
{
    if (pszPolicyName == NULL || *pszPolicyName == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    //
    // casting to LPWSTR is due to IPSec API's mistake
    //

    if (ERROR_SUCCESS != ::DeleteMMPolicy(NULL, (LPWSTR)pszPolicyName))
    {
        hr = WBEM_E_VETO_DELETE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\policyqm.cpp ===
// PolicyQM.cpp: implementation for the WMI class Nsp_QMPolicySettings
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "PolicyQM.h"
#include "NetSecProv.h"
#include "TranxMgr.h"

const DWORD DefQMPolicyOfferFlag = 1;

const IID guidDefQMPolicy_Neg_None      = {0xed0d7a90,0x7d11,0x488f,{0x8a,0xd8,0x93,0x86,0xec,0xf6,0x59,0x6f}};
const IID guidDefQMPolicy_Neg_Request   = {0xb01536ca,0x9959,0x49e3,{0xa7,0x1a,0xb5,0x14,0x15,0xf5,0xff,0x63}};
const IID guidDefQMPolicy_Neg_Require   = {0x8853278b,0xc8e9,0x4265,{0xa9,0xfc,0xf2,0x92,0x81,0x2b,0xc6,0x60}};
const IID guidDefQMPolicy_Neg_MAX       = {0xfe048c67,0x1876,0x41c5,{0xae,0xec,0x7f,0x4d,0x62,0xa6,0x33,0xf8}};


/*
Routine Description: 

Name:

    CQMPolicy::QueryInstance

Functionality:

    Given the query, it returns to WMI (using pSink) all the instances that satisfy the query.
    Actually, what we give back to WMI may contain extra instances. WMI will do the final filtering.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    None.

Return Value:

    Success:

        (1) WBEM_NO_ERROR if instances are returned;

        (2) WBEM_S_NO_MORE_DATA if no instances are returned.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.

Notes:
    

*/

STDMETHODIMP 
CQMPolicy::QueryInstance (
    IN LPCWSTR           pszQuery,
    IN IWbemContext	   * pCtx,
    IN IWbemObjectSink * pSink
	)
{
    //
    // get the filter name from the query
    // the key chain doesn't know anything about where clause property (policy name),
    // so let's create a better one.
    //

    m_srpKeyChain.Release();

    HRESULT hr = CNetSecProv::GetKeyChainFromQuery(pszQuery, g_pszPolicyName, &m_srpKeyChain);
    if (FAILED(hr))
    {
        return hr;
    }

    CComVariant varPolicyName;

    //
    // If the key property can't be found, it will return WBEM_S_FALSE,
    // and we are fine with that because a query may not have the key at all.
    //

    hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPolicyName, &varPolicyName);

    LPCWSTR pszPolicyName = (varPolicyName.vt == VT_BSTR) ? varPolicyName.bstrVal : NULL;

    //
    // first, let's enumerate all MM filters
    //

    DWORD dwResumeHandle = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;

    hr = FindPolicyByName(pszPolicyName, &pQMPolicy, &dwResumeHandle);

    while (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromQMPolicy(pQMPolicy, &srpObj);

        //
        // we created our wbem object, now give it to WMI
        //

        if (SUCCEEDED(hr))
        {
            pSink->Indicate(1, &srpObj);
        }
        
        ::SPDApiBufferFree(pQMPolicy);

        pQMPolicy = NULL;

        hr = FindPolicyByName(pszPolicyName, &pQMPolicy, &dwResumeHandle);
    }

    //
    // we are querying, so if not found, it's not an error
    //

    if (WBEM_E_NOT_FOUND == hr)
    {
        hr = WBEM_S_NO_MORE_DATA;
    }

    return hr;
}


/*
Routine Description: 

Name:

    CQMPolicy::DeleteInstance

Functionality:

    Will delete the wbem object, which will cause the quick mode policy to be deleted.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        WBEM_NO_ERROR;

    Failure:

        (1) WBEM_E_NOT_FOUND. Whether or not this should be considered an error
            depends on context.

        (2) Other errors indicating the cause.
Notes:
    

*/

STDMETHODIMP CQMPolicy::DeleteInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    CComVariant varPolicyName;

    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPolicyName, &varPolicyName);
    if (FAILED(hr))
    {
        return hr;
    }
    else if (varPolicyName.vt != VT_BSTR || varPolicyName.bstrVal == NULL || varPolicyName.bstrVal[0] == L'\0')
    {
        return WBEM_E_NOT_FOUND;
    }

    return DeletePolicy(varPolicyName.bstrVal);
}


/*
Routine Description: 

Name:

    CQMPolicy::ExecMethod

Functionality:

    Quick mode policy implements two functions (See mof file) and so we need to implement this virtual function

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pNamespace  - our namespace.

    pszMethod   - The name of the method.

    pCtx        - COM interface pointer by WMI and needed for various WMI APIs

    pInParams   - COM interface pointer to the input parameter object.

    pSink       - COM interface pointer for notifying WMI about results.

Return Value:

    Success:

        Various success codes indicating the result.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.


Notes:
    

*/

HRESULT 
CQMPolicy::ExecMethod (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszMethod,
    IN IWbemContext     * pCtx,
    IN IWbemClassObject * pInParams,
    IN IWbemObjectSink  * pSink
    )
{
    if (pszMethod == NULL || *pszMethod == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    bool bCreateDefPol = (_wcsicmp(pszMethod, pszCreateDefaultPolicy) == 0);
    bool bGetDefPolName= (_wcsicmp(pszMethod, pszGetDefaultPolicyName) == 0);

    HRESULT hr = WBEM_E_NOT_SUPPORTED;

    if (bCreateDefPol || bGetDefPolName)
    {
        CComVariant varEncryption;
        hr = pInParams->Get(g_pszEncryption, 0, &varEncryption, NULL, NULL);

        if (SUCCEEDED(hr) &&  varEncryption.vt == VT_I4     && 
            varEncryption.lVal >= RAS_L2TP_NO_ENCRYPTION    && 
            varEncryption.lVal <= RAS_L2TP_REQUIRE_ENCRYPTION )
        {
            LPCWSTR pszRetNames[2] = {L"ReturnValue", L"Name"};
            VARIANT varValues[2];
            ::VariantInit(&(varValues[0]));
            ::VariantInit(&(varValues[1]));

            //
            // Let's assume it is a CreateDefaultPolicy call. So there is only one value to pass back
            //

            DWORD dwCount = 1;

            if (bCreateDefPol)
            {
                hr = CreateDefaultPolicy((EnumEncryption)varEncryption.lVal);
            }
            else
            {
                varValues[1].vt = VT_BSTR;
                varValues[1].bstrVal = ::SysAllocString(GetDefaultPolicyName((EnumEncryption)varEncryption.lVal));

                //
                // just in case, no memory can be allocated for the bstr, reset the var to empty
                //

                if (varValues[1].bstrVal == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    varValues[1].vt = VT_EMPTY;
                }
                else
                {
                    //
                    // we have two values to pass back: one for the return value and one for the out parameter "Name"
                    //

                    dwCount = 2;
                }
            }

            //
            // pack the values (out parameter and return value) to pass back to WMI.
            // Return value = 1 means success. Regardless of success or failure, we need to do this.
            //

            varValues[0].vt = VT_I4;
            varValues[0].lVal = SUCCEEDED(hr) ? 1 : 0;

            HRESULT hrDoReturn = DoReturn(pNamespace, pszMethod, dwCount, pszRetNames, varValues, pCtx, pSink);

            //
            // now clean up the vars
            //

            ::VariantClear(&(varValues[0]));
            ::VariantClear(&(varValues[1]));

            if (SUCCEEDED(hr) && FAILED(hrDoReturn))
            {
                hr = hrDoReturn;
            }
        }
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    
    return hr;
}


/*
Routine Description: 

Name:

    CQMPolicy::PutInstance

Functionality:

    Put a quick mode policy into SPD whose properties are represented by the
    wbem object.

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pInst       - The wbem object.

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        Various error codes specifying the error.

Notes:
    

*/

STDMETHODIMP 
CQMPolicy::PutInstance (
    IN IWbemClassObject * pInst,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pInst == NULL || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    bool bPreExist = false;

    //
    // for those policies that are created by ourselves (bPreExist == true)
    // we have our own way of allocating the buffer, need to free it in our corresponding way
    //

    PIPSEC_QM_POLICY pPolicy = NULL;
    HRESULT hr = GetQMPolicyFromWbemObj(pInst, &pPolicy, &bPreExist);

    //
    // if policy is successfully returned, then use it
    //

    if (SUCCEEDED(hr) && pPolicy)
    {
        hr = AddPolicy(bPreExist, pPolicy);

        //
        // deposit info about this action so that rollback can be done.
        //

        if (SUCCEEDED(hr))
        {
            hr = OnAfterAddPolicy(pPolicy->pszPolicyName, QuickMode_Policy);
        }

        FreePolicy(&pPolicy, bPreExist);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CQMPolicy::GetInstance

Functionality:

    Create a wbem object by the given key properties (already captured by our key chain object)..

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pCtx        - COM interface pointer given by WMI and needed for various WMI APIs.

    pSink       - COM interface pointer to notify WMI of any created objects.

Return Value:

    Success:

        Success code. Use SUCCEEDED(hr) to test.

    Failure:

        (1) WBEM_E_NOT_FOUND if the auth method can't be found. Depending on
            the context, this may not be an error

        (2) Other various errors indicated by the returned error codes.


Notes:
    

*/

STDMETHODIMP 
CQMPolicy::GetInstance ( 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    CComVariant varPolicyName;

    //
    // since policy name is a key property, it must have policy name property in the path and thus in the key chain
    //

    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(g_pszPolicyName, &varPolicyName);
    if (FAILED(hr))
    {
        return hr;
    }
    else if (varPolicyName.vt != VT_BSTR || varPolicyName.bstrVal == NULL || varPolicyName.bstrVal[0] == L'\0')
    {
        return WBEM_E_NOT_FOUND;
    }

    PIPSEC_QM_POLICY pQMPolicy = NULL;
    DWORD dwResumeHandle = 0;

    hr = FindPolicyByName(varPolicyName.bstrVal, &pQMPolicy, &dwResumeHandle);

    if (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;
        hr = CreateWbemObjFromQMPolicy(pQMPolicy, &srpObj);

        if (SUCCEEDED(hr))
        {
            hr = pSink->Indicate(1, &srpObj);
        }

        ::SPDApiBufferFree(pQMPolicy);
    }

    return hr; 
}


/*
Routine Description: 

Name:

    CQMPolicy::CreateWbemObjFromMMPolicy

Functionality:

    Given a SPD's quick mode policy, we will create a wbem object representing it.

Virtual:
    
    No.

Arguments:

    pPolicy  - The SPD's quick mode policy object.

    ppObj    - Receives the wbem object.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:

*/

HRESULT 
CQMPolicy::CreateWbemObjFromQMPolicy (
    IN  PIPSEC_QM_POLICY     pPolicy,
    OUT IWbemClassObject  ** ppObj
    )
{
    if (pPolicy == NULL || ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppObj = NULL;

    //
    // create a wbem object of this class that can be used to fill in properties
    //

    HRESULT hr = SpawnObjectInstance(ppObj);

    //
    // fill in base class members (CIPSecPolicy)
    //

    if (SUCCEEDED(hr))
    {
        hr = CreateWbemObjFromPolicy(pPolicy, *ppObj);
    }

    if (SUCCEEDED(hr))
    {
        //
        // deal with all those arrays
        //

        CComVariant var;
        var.vt    = VT_ARRAY | VT_I4;
        SAFEARRAYBOUND rgsabound[1];
        rgsabound[0].lLbound = 0;
        rgsabound[0].cElements = pPolicy->dwOfferCount;
        var.parray = ::SafeArrayCreate(VT_I4, 1, rgsabound);

        if (var.parray == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            long lIndecies[1];

            //
            //$undone:shawnwu, we need to write some generic routine to do this repeatitive array
            // put (and get). That routine can only be based on memory offset!
            //

            //
            // put bPFSRequired, array of boolean
            //

            CComVariant varBoolArray;
            varBoolArray.vt = VT_ARRAY | VT_BOOL;
            varBoolArray.parray = ::SafeArrayCreate(VT_BOOL, 1, rgsabound);

            VARIANT varBool;
            varBool.vt = VT_BOOL;

            for (DWORD dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
            {
                lIndecies[0] = dwIndex;
                varBool.boolVal = (pPolicy->pOffers[dwIndex].bPFSRequired) ? VARIANT_TRUE : VARIANT_FALSE;
                hr = ::SafeArrayPutElement(varBoolArray.parray, lIndecies, &(varBool.boolVal));
            }

            if (SUCCEEDED(hr))
            {
                hr = (*ppObj)->Put(g_pszPFSRequired, 0, &varBoolArray, CIM_EMPTY);
            }

            //
            // put dwPFSGroup, array of VT_I4. var has been created with the right count
            // for VT_I4 array
            //

            for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
            {
                lIndecies[0] = dwIndex;
                hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].dwPFSGroup) );
            }

            if (SUCCEEDED(hr))
            {
                hr = (*ppObj)->Put(g_pszPFSGroup, 0, &var, CIM_EMPTY);
            }

            //
            // put dwNumAlgos, array of VT_I4. 
            //

            for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
            {
                lIndecies[0] = dwIndex;
                hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].dwNumAlgos) );
            }

            if (SUCCEEDED(hr))
            {
                hr = (*ppObj)->Put(g_pszNumAlgos, 0, &var, CIM_EMPTY);
            }

            //
            // for each individual Algo, we have to fill up all reserved elements (QM_MAX_ALGOS)
            // even though the actual offer count is less. See PIPSEC_QM_OFFER for details.
            //

            //
            // Now the array size has changed to count the QM_MAX_ALGOS,
            // which is different from what var is created. So, re-create a different array!
            //

            if (SUCCEEDED(hr))
            {
                var.Clear();
                var.vt    = VT_ARRAY | VT_I4;
                rgsabound[0].cElements = pPolicy->dwOfferCount * QM_MAX_ALGOS;

                var.parray = ::SafeArrayCreate(VT_I4, 1, rgsabound);
                if (var.parray == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    DWORD dwSub;

                    //
                    // put Algos[i].Operation. 
                    //

                    for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                    {
                        for (dwSub = 0; SUCCEEDED(hr) && dwSub < QM_MAX_ALGOS; dwSub++)
                        {
                            lIndecies[0] = dwIndex * QM_MAX_ALGOS + dwSub;
                            hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].Algos[dwSub].Operation) );
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = (*ppObj)->Put(g_pszAlgoOp, 0, &var, CIM_EMPTY);
                    }

                    //
                    // put Algos[i].uAlgoIdentifier. 
                    //

                    for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                    {
                        for (dwSub = 0; SUCCEEDED(hr) && dwSub < QM_MAX_ALGOS; dwSub++)
                        {
                            lIndecies[0] = dwIndex * QM_MAX_ALGOS + dwSub;
                            hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].Algos[dwSub].uAlgoIdentifier) );
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = (*ppObj)->Put(g_pszAlgoID, 0, &var, CIM_EMPTY);
                    }

                    //
                    // put Algos[i].uSecAlgoIdentifier. 
                    //

                    for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < pPolicy->dwOfferCount; dwIndex++)
                    {
                        for (dwSub = 0; SUCCEEDED(hr) && dwSub < QM_MAX_ALGOS; dwSub++)
                        {
                            lIndecies[0] = dwIndex * QM_MAX_ALGOS + dwSub;
                            hr = ::SafeArrayPutElement(var.parray, lIndecies, &(pPolicy->pOffers[dwIndex].Algos[dwSub].uSecAlgoIdentifier) );
                        }
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = (*ppObj)->Put(g_pszAlgoSecID, 0, &var, CIM_EMPTY);
                    }

                }
            }
        }
    }


    //
    // we may have created the object, but some mid steps have failed,
    // so let's release the object.
    //

    if (FAILED(hr) && *ppObj != NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;     
}



/*
Routine Description: 

Name:

    CQMPolicy::GetQMPolicyFromWbemObj

Functionality:

    Will try to get the quick mode policy if such policy already exists.
    Otherwise, we will create a new one.

Virtual:
    
    No.

Arguments:

    pInst       - The wbem object object.

    ppPolicy    - Receives the quick mode policy.

    pbPreExist  - Receives the information whether this object memory is allocated by SPD or not.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        (1) various errors indicated by the returned error codes.

Notes:
    
    if some property is missing from the wbem object, we will supply the default value.

*/

HRESULT 
CQMPolicy::GetQMPolicyFromWbemObj (
    IN  IWbemClassObject * pInst, 
    OUT PIPSEC_QM_POLICY * ppPolicy, 
    OUT bool             * pbPreExist
    )
{
    if (pInst == NULL || ppPolicy == NULL || pbPreExist == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppPolicy = NULL;
    *pbPreExist = false;

    //
    // get the policy (if new, then it will fill up the common (MM and QM) properties
    //

    HRESULT hr = GetPolicyFromWbemObj(pInst, ppPolicy, pbPreExist);

    //
    // we don't support modification on existing policies
    //

    if (SUCCEEDED(hr) && *pbPreExist == false)
    {
        CComVariant var;

        //
        // wbem object may not have all the properties, we will use default when a property is not present.
        // as a result, we don't keep the HRESULT and return it the caller
        //

        //
        // for readability
        //

        DWORD dwOfferCount = (*ppPolicy)->dwOfferCount;

        //
        // These four members are for each offer. Our safe array size will be thus of dwOfferCount number of
        // dwFlags; bPFSRequired; dwPFSGroup; dwNumAlgos;
        // But for each offer, its Algos is an array of size QM_MAX_ALGOS (currently defined as 2).
        // See PIPSEC_QM_POLICY for details.
        //

        //
        // dwFlags; We don't have a member for this flag. Hardcode it.
        //

        for (long l = 0; l < dwOfferCount; l++)
        {
            (*ppPolicy)->pOffers[l].dwFlags = DefaultQMPolicyOfferFlag;
        }

        //
        // need to delete the memory
        //

        DWORD* pdwValues = new DWORD[dwOfferCount * QM_MAX_ALGOS];

        if (pdwValues == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            var.Clear();


            //
            // If the property is missing from wbem object, we will initialize them to default values.
            //

            bool bInitialized = false;

            //
            // set bPFSRequired
            //

            if ( SUCCEEDED(pInst->Get(g_pszPFSRequired, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].bPFSRequired = pdwValues[l];
                    }
                }
            }
            
            if (!bInitialized)
            {
                //
                // property is missing, initialize to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].bPFSRequired = DefaultPFSRequired;
                }
            }

            //
            // Reset for next property
            //

            bInitialized = false;

            var.Clear();

            //
            // set bPFSRequired
            //
            
            if ( SUCCEEDED(pInst->Get(g_pszPFSGroup, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].dwPFSGroup = pdwValues[l];
                    }
                }
            }
            
            if (!bInitialized)
            {
                //
                // property is missing, initialize to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].dwPFSGroup = DefaultPFSGroup;
                }
            }

            //
            // Reset for next property
            //

            bInitialized = false;

            var.Clear();

            //
            // set dwNumAlgos
            //

            if ( SUCCEEDED(pInst->Get(g_pszNumAlgos, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        (*ppPolicy)->pOffers[l].dwNumAlgos = pdwValues[l];
                    }
                }
            }
            
            if (!bInitialized)
            {
                //
                // property is missing, initialize to default values
                //

                for (l = 0; l < dwOfferCount; l++)
                {
                    (*ppPolicy)->pOffers[l].dwNumAlgos = DefaultNumAlgos;
                }
            }

            //
            // Reset for next property
            //

            bInitialized = false;

            var.Clear();

            //
            // set individual IPSEC_QM_ALGO. For each offer, there are QM_MAX_ALGOS reserved IPSEC_QM_ALGO's
            // even though there might be less than that number of IPSEC_QM_ALGO's (determined by pOffers[l].dwNumAlgos)
            //

            //
            // lSub is for index of the second dimension.
            //

            long lSub;

            //
            // set Operation
            //

            if ( SUCCEEDED(pInst->Get(g_pszAlgoOp, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount * QM_MAX_ALGOS, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        for (lSub = 0; lSub < (*ppPolicy)->pOffers[l].dwNumAlgos; lSub++)
                        {
                            IPSEC_OPERATION op = (IPSEC_OPERATION)pdwValues[l * QM_MAX_ALGOS + lSub];
                            if (op <= NONE || op > SA_DELETE)
                            {
                                (*ppPolicy)->pOffers[l].Algos[lSub].Operation = DefaultQMAlgoOperation;
                            }
                            else
                            {
                                (*ppPolicy)->pOffers[l].Algos[lSub].Operation = op;
                            }
                        }
                    }
                }
            }

            if (!bInitialized)
            {
                for (l = 0; l < dwOfferCount; l++)
                {
                    for (lSub = 0; lSub < (*ppPolicy)->pOffers[l].dwNumAlgos; lSub++)
                    {
                        (*ppPolicy)->pOffers[l].Algos[lSub].Operation = DefaultQMAlgoOperation;
                    }
                }
            }

            //
            // set uAlgoIdentifier
            //

            bInitialized = false;

            if ( SUCCEEDED(pInst->Get(g_pszAlgoID, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount * QM_MAX_ALGOS, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        for (lSub = 0; lSub < (*ppPolicy)->pOffers[l].dwNumAlgos; lSub++)
                        {
                            (*ppPolicy)->pOffers[l].Algos[lSub].uAlgoIdentifier = pdwValues[l * QM_MAX_ALGOS + lSub];
                        }
                    }
                }
            }

            //
            // in case no values have been set
            //

            if (!bInitialized)
            {
                for (l = 0; l < dwOfferCount; l++)
                {
                    for (lSub = 0; lSub < (*ppPolicy)->pOffers[l].dwNumAlgos; lSub++)
                    {
                        (*ppPolicy)->pOffers[l].Algos[lSub].uAlgoIdentifier = DefaultAlgoID;
                    }
                }
            }

            //
            // set uSecAlgoIdentifier
            //

            bInitialized = false;

            if ( SUCCEEDED(pInst->Get(g_pszAlgoSecID, 0, &var, NULL, NULL)) && (var.vt & VT_ARRAY) == VT_ARRAY )
            {
                if (SUCCEEDED(::GetDWORDSafeArrayElements(&var, dwOfferCount * QM_MAX_ALGOS, pdwValues)))
                {
                    //
                    // we are guaranteed to get values after this point.
                    //

                    bInitialized = true;

                    for (l = 0; l < dwOfferCount; l++)
                    {
                        for (lSub = 0; lSub < (*ppPolicy)->pOffers[l].dwNumAlgos; lSub++)
                        {
                            HMAC_AH_ALGO ag = (HMAC_AH_ALGO)pdwValues[l * QM_MAX_ALGOS + lSub];
                            if (ag <= HMAC_AH_NONE || ag >= HMAC_AH_MAX)
                            {
                                (*ppPolicy)->pOffers[l].Algos[lSub].uSecAlgoIdentifier = DefaultAlgoSecID;
                            }
                            else
                            {
                                (*ppPolicy)->pOffers[l].Algos[lSub].uSecAlgoIdentifier = ag;
                            }
                        }
                    }
                }
            }

            //
            // in case no values have been set
            //

            if (!bInitialized)
            {
                for (l = 0; l < dwOfferCount; l++)
                {
                    for (lSub = 0; lSub < (*ppPolicy)->pOffers[l].dwNumAlgos; lSub++)
                    {
                        (*ppPolicy)->pOffers[l].Algos[lSub].uSecAlgoIdentifier = DefaultAlgoSecID;
                    }
                }
            }

        }

        //
        // free memory
        //

        delete [] pdwValues;
    }

    if (FAILED(hr) && *ppPolicy != NULL)
    {
        FreePolicy(ppPolicy, *pbPreExist);
    }

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


/*
Routine Description: 

Name:

    CQMPolicy::AddPolicy

Functionality:

    Add the given quick mode policy to SPD.

Virtual:
    
    No.

Arguments:

    bPreExist - Flag whether the main mode auth method already exists in SPD

    pQMPolicy - The quick mode policy to add.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        WBEM_E_FAILED.

Notes:

*/

HRESULT 
CQMPolicy::AddPolicy (
    IN bool             bPreExist,
    IN PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwResult = ERROR_SUCCESS;

    HRESULT hr = WBEM_NO_ERROR;

    if (bPreExist)
    {
        dwResult = ::SetQMPolicy(NULL, pQMPolicy->pszPolicyName, pQMPolicy);
    }
    else
    {
        dwResult = ::AddQMPolicy(NULL, 1, pQMPolicy);
    }

    if (dwResult != ERROR_SUCCESS)
    {
        hr = ::IPSecErrorToWbemError(dwResult);
    }

    //
    // $undone:shawnwu, need better error code for failures.
    //

    return hr;
}


/*
Routine Description: 

Name:

    CQMPolicy::DeletePolicy

Functionality:

    Delete given quick mode policy from SPD.

Virtual:
    
    No.

Arguments:

    pszPolicyName - The name of the policy to delete.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        (1) WBEM_E_INVALID_PARAMETER: if pszPolicyName == NULL or *pszPolicyName == L'\0'.

        (2) WBEM_E_VETO_DELETE: if we are not allowed to delete the policy by SPD.

Notes:

*/

HRESULT 
CQMPolicy::DeletePolicy (
    IN LPCWSTR pszPolicyName
    )
{
    if (pszPolicyName == NULL || *pszPolicyName == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    //
    // casting to LPWSTR is due to IPSec API's mistake
    //

    DWORD dwStatus = ::DeleteQMPolicy(NULL, (LPWSTR)pszPolicyName);
    
    if (dwStatus != ERROR_SUCCESS)
    {
        hr = IPSecErrorToWbemError(dwStatus);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CQMPolicy::GetDefaultQMPolicyName

Functionality:

    return to the caller the default quick mode policy name that we will
    create upon request (CreateDefaultQMPolicy).

Virtual:
    
    No.

Arguments:

    eEncryption - The type of encryption the quick mode policy wants.

Return Value:

    Our default policy's name if the encryption is recognized. Otherwise, it returns NULL;

Notes:

*/

LPCWSTR 
CQMPolicy::GetDefaultPolicyName (
    EnumEncryption  eEncryption
    )
{
    switch (eEncryption) 
    {
        case RAS_L2TP_NO_ENCRYPTION:
            return g_pszDefQMPolicyNegNone;
            break;
        case RAS_L2TP_OPTIONAL_ENCRYPTION:
            return g_pszDefQMPolicyNegRequest;
            break;
        case RAS_L2TP_REQUIRE_ENCRYPTION:
            return g_pszDefQMPolicyNegRequire;
            break;
        case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:
            return g_pszDefQMPolicyNegMax;
            break;
        default:
            return NULL;
    }
}




/*
Routine Description: 

Name:

    CQMPolicy::CreateDefaultPolicy

Functionality:

    Will create the default qm policy with the requested encryption.

Virtual:
    
    No.

Arguments:

    eEncryption - The type of encryption the quick mode policy wants.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        (1) WBEM_E_INVALID_PARAMETER: if pszPolicyName == NULL or *pszPolicyName == L'\0'.

        (2) WBEM_E_NOT_SUPPORTED: the requested encryption is not supported

        (3) WBEM_E_OUT_OF_MEMORY.

Notes:

*/

HRESULT 
CQMPolicy::CreateDefaultPolicy (
    EnumEncryption  eEncryption
    )
{

    PIPSEC_QM_POLICY pDefQMPolicy = NULL;
    DWORD dwResumeHandle = 0;
    HRESULT hr = FindPolicyByName(GetDefaultPolicyName(eEncryption), &pDefQMPolicy, &dwResumeHandle);

    if (SUCCEEDED(hr))
    {
        //
        // already there, don't need to create and add
        //

        ::SPDApiBufferFree(pDefQMPolicy);
        return hr;  
    }

    //
    // otherwise, this default policy is not there, then we need to create it and add it to SPD
    //

    IPSEC_QM_OFFER  Offers[20];
    IPSEC_QM_POLICY QMPolicy;

    memset(Offers, 0, sizeof(IPSEC_QM_OFFER)*20);

    DWORD dwOfferCount = 0;
    DWORD dwFlags = 0;

    DWORD dwStatus = ::BuildOffers(
                                   eEncryption,
                                   Offers,
                                   &dwOfferCount,
                                   &dwFlags
                                   );

    if (dwStatus == ERROR_SUCCESS)
    {
        BuildQMPolicy(
                    &QMPolicy,
                    eEncryption,
                    Offers,
                    dwOfferCount,
                    dwFlags
                    );

        return AddPolicy(false, &QMPolicy);
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER;
    }
}



/*
Routine Description: 

Name:

    CQMPolicy::DeleteDefaultPolicies

Functionality:

    Remove from SPD all the default quick mode policies.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:

        various errors translated by IPSecErrorToWbemError

Notes:

*/

HRESULT 
CQMPolicy::DeleteDefaultPolicies()
{
    HRESULT hr = WBEM_NO_ERROR;

    //
    // if the policy is not found, that is certainly ok
    //

    DWORD dwStatus = ::DeleteQMPolicy(NULL, (LPWSTR)g_pszDefQMPolicyNegNone);

    if (ERROR_SUCCESS != dwStatus && ERROR_IPSEC_QM_POLICY_NOT_FOUND != dwStatus)
    {
        hr = IPSecErrorToWbemError(dwStatus);
    }

    dwStatus = ::DeleteQMPolicy(NULL, (LPWSTR)g_pszDefQMPolicyNegRequest);

    if (ERROR_SUCCESS != dwStatus && ERROR_IPSEC_QM_POLICY_NOT_FOUND != dwStatus)
    {
        hr = IPSecErrorToWbemError(dwStatus);
    }

    dwStatus = ::DeleteQMPolicy(NULL, (LPWSTR)g_pszDefQMPolicyNegRequire);

    if (ERROR_SUCCESS != dwStatus && ERROR_IPSEC_QM_POLICY_NOT_FOUND != dwStatus)
    {
        hr = IPSecErrorToWbemError(dwStatus);
    }


    dwStatus = ::DeleteQMPolicy(NULL, (LPWSTR)g_pszDefQMPolicyNegMax);

    if (ERROR_SUCCESS != dwStatus && ERROR_IPSEC_QM_POLICY_NOT_FOUND != dwStatus)
    {
        hr = IPSecErrorToWbemError(dwStatus);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CQMPolicy::DoReturn

Functionality:

    Will create the return result object and pass it back to WMI

Virtual:
    
    No.

Arguments:

    pNamespace  - our namespace.

    pszMethod   - The name of the method.

    dwCount     - The count of values to be passed back

    pszValueNames - The names of the values to be passed back. It is of size (dwCount)

    varValues   - Values to be passed back (in the same order as of pszValueNames).  It is of size (dwCount)

    pCtx        - COM interface pointer by WMI and needed for various WMI APIs

    pReturnObj  - Receives the WBEM object that contains the return result value.

Return Value:

    Success:

        Various success codes indicating the result.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.


Notes:
    
    This is just for testing.

*/


HRESULT 
CQMPolicy::DoReturn (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszMethod,
    IN DWORD              dwCount,
    IN LPCWSTR          * pszValueNames,
    IN VARIANT          * varValues,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink 
    )
{

    CComPtr<IWbemClassObject> srpClass;
    CComBSTR bstrClsName(pszNspQMPolicy);

    HRESULT hr = pNamespace->GetObject(bstrClsName, 0, pCtx, &srpClass, NULL);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // creates an instance of the output argument class.
    //

    CComPtr<IWbemClassObject> srpOutClass;

    hr = srpClass->GetMethod(pszMethod, 0, NULL, &srpOutClass);
    
    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IWbemClassObject> srpOutParam;

    hr = srpOutClass->SpawnInstance(0, &srpOutParam);

    if (SUCCEEDED(hr))
    {
        for (DWORD dwIndex = 0; SUCCEEDED(hr) && (dwIndex < dwCount); dwIndex++)
        {
            CComBSTR bstrRetValName(pszValueNames[dwIndex]);

            //
            // Put the return value as a property
            //

            hr = srpOutParam->Put(bstrRetValName , 0, &(varValues[dwIndex]), 0);
        }
    }

    //
    // Send the output object back to the client by the sink.
    //
    if (SUCCEEDED(hr))
    {
        hr = pSink->Indicate(1, &srpOutParam);
    }

    return hr;
}


//
// The following functions are used to create default QM policies
// We copied it from IPSec's test code located at \nt\net\rras\ras\rasman\rasman
//

#define L2TP_IPSEC_DEFAULT_BYTES     250000

#define L2TP_IPSEC_DEFAULT_TIME      3600

DWORD
BuildOffers(
    EnumEncryption eEncryption,
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers,
    PDWORD pdwFlags
    )
{

    DWORD dwStatus = ERROR_SUCCESS;

    switch (eEncryption) {

        case RAS_L2TP_NO_ENCRYPTION:
            *pdwFlags = 0;
            dwStatus = BuildNoEncryption(
                            pOffers,
                            pdwNumOffers
                            );
            break;


        case RAS_L2TP_OPTIONAL_ENCRYPTION:
            dwStatus = BuildOptEncryption(
                            pOffers,
                            pdwNumOffers
                            );
            break;


        case RAS_L2TP_REQUIRE_ENCRYPTION:
            *pdwFlags = 0;
            dwStatus = BuildRequireEncryption(
                            pOffers,
                            pdwNumOffers
                            );
            break;


        case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:
            *pdwFlags = 0;
            dwStatus = BuildStrongEncryption(
                            pOffers,
                            pdwNumOffers
                            );
            break;
        default:
            dwStatus = ERROR_BAD_ARGUMENTS;

    }

    return(dwStatus);
}


/*++

    Negotiation Policy Name:                L2TP server any encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. ESP 3_DES MD5
    2. ESP 3_DES SHA
    3. AH SHA1 with ESP 3_DES with null HMAC
    4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed
    5. AH SHA1 with ESP 3_DES SHA1, no lifetimes
    6. AH MD5  with ESP 3_DES MD5, no lifetimes

    7. ESP DES MD5
    8. ESP DES SHA1, no lifetimes
    9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed
    10. AH MD5  with ESP DES null HMAC, no lifetimes proposed
    11. AH SHA1 with ESP DES SHA1, no lifetimes
    12. AH MD5  with ESP DES MD5, no lifetimes

--*/
DWORD
BuildOptEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 2. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 5. AH SHA1 with ESP 3_DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 6. AH MD5  with ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 7. ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 8. ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 10. AH MD5  with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 11. AH SHA1 with ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 12. AH MD5  with ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 13. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 14. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 15. AH SHA

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 16. AH MD5

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    *pdwNumOffers = 16;

    return(dwStatus);
}


/*++

    Negotiation Policy Name:                L2TP server strong encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. ESP 3_DES MD5, no lifetimes
    2. ESP 3_DES SHA, no lifetimes
    3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed
    4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed
    5. AH SHA1 with ESP 3_DES SHA1, no lifetimes
    6. AH MD5  with ESP 3_DES MD5, no lifetimes

--*/
DWORD
BuildStrongEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 2. ESP 3_DES SHA, no lifetimes;

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 5. AH SHA1 with ESP 3_DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 6. AH MD5  with ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );

    *pdwNumOffers  = 6;

    return(dwStatus);

}

void
BuildOffer(
    PIPSEC_QM_OFFER pOffer,
    DWORD dwNumAlgos,
    DWORD dwFirstOperation,
    DWORD dwFirstAlgoIdentifier,
    DWORD dwFirstAlgoSecIdentifier,
    DWORD dwSecondOperation,
    DWORD dwSecondAlgoIdentifier,
    DWORD dwSecondAlgoSecIdentifier,
    DWORD dwKeyExpirationBytes,
    DWORD dwKeyExpirationTime
    )
{
    memset(pOffer, 0, sizeof(IPSEC_QM_OFFER));

    pOffer->Lifetime.uKeyExpirationKBytes = dwKeyExpirationBytes;
    pOffer->Lifetime.uKeyExpirationTime = dwKeyExpirationTime;

    pOffer->dwFlags = 0;                      // No flags.
    pOffer->bPFSRequired = FALSE;             // Phase 2 PFS not required.
    pOffer->dwPFSGroup = PFS_GROUP_NONE;

    pOffer->dwNumAlgos = dwNumAlgos;

    if (dwNumAlgos >= 1) {

        pOffer->Algos[0].Operation = (IPSEC_OPERATION)dwFirstOperation;
        pOffer->Algos[0].uAlgoIdentifier = dwFirstAlgoIdentifier;
        pOffer->Algos[0].uAlgoKeyLen = 64;
        pOffer->Algos[0].uAlgoRounds = 8;
        pOffer->Algos[0].uSecAlgoIdentifier = (HMAC_AH_ALGO)dwFirstAlgoSecIdentifier;
        pOffer->Algos[0].MySpi = 0;
        pOffer->Algos[0].PeerSpi = 0;

    }

    if (dwNumAlgos == 2) {

        pOffer->Algos[1].Operation = (IPSEC_OPERATION)dwSecondOperation;
        pOffer->Algos[1].uAlgoIdentifier = dwSecondAlgoIdentifier;
        pOffer->Algos[1].uAlgoKeyLen = 64;
        pOffer->Algos[1].uAlgoRounds = 8;
        pOffer->Algos[1].uSecAlgoIdentifier = (HMAC_AH_ALGO)dwSecondAlgoSecIdentifier;
        pOffer->Algos[1].MySpi = 0;
        pOffer->Algos[1].PeerSpi = 0;

    }
}



/*++

    Negotiation Policy Name:                L2TP server any encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. AH SHA1
    2. AH MD5


--*/
DWORD
BuildNoEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 2. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 3. AH SHA

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    *pdwNumOffers = 4;

    return(dwStatus);
}


/*++

    Negotiation Policy Name:                L2TP server any encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. ESP 3_DES MD5 
    2. ESP 3_DES SHA
    3. AH SHA1 with ESP 3_DES with null HMAC
    4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed
    5. AH SHA1 with ESP 3_DES SHA1, no lifetimes
    6. AH MD5  with ESP 3_DES MD5, no lifetimes

    7. ESP DES MD5
    8. ESP DES SHA1, no lifetimes
    9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed
    10. AH MD5  with ESP DES null HMAC, no lifetimes proposed
    11. AH SHA1 with ESP DES SHA1, no lifetimes
    12. AH MD5  with ESP DES MD5, no lifetimes

--*/
DWORD
BuildRequireEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )

{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 2. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 5. AH SHA1 with ESP 3_DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 6. AH MD5  with ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 7. ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 8. ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 10. AH MD5  with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 11. AH SHA1 with ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 12. AH MD5  with ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    *pdwNumOffers = 12;

    return(dwStatus);
}



VOID
BuildQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    EnumEncryption eEncryption,
    PIPSEC_QM_OFFER pOffers,
    DWORD dwNumOffers,
    DWORD dwFlags
    )
{
    switch (eEncryption) 
    {

    case RAS_L2TP_NO_ENCRYPTION:
        pQMPolicy->pszPolicyName = (LPWSTR)g_pszDefQMPolicyNegNone;
        pQMPolicy->gPolicyID = guidDefQMPolicy_Neg_None;
        break;


    case RAS_L2TP_OPTIONAL_ENCRYPTION:
        pQMPolicy->pszPolicyName = (LPWSTR)g_pszDefQMPolicyNegRequest;
        pQMPolicy->gPolicyID = guidDefQMPolicy_Neg_Request;
        break;


    case RAS_L2TP_REQUIRE_ENCRYPTION:
        pQMPolicy->pszPolicyName = (LPWSTR)g_pszDefQMPolicyNegRequire;
        pQMPolicy->gPolicyID = guidDefQMPolicy_Neg_Require;
        break;


    case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:
        pQMPolicy->pszPolicyName = (LPWSTR)g_pszDefQMPolicyNegMax;
        pQMPolicy->gPolicyID = guidDefQMPolicy_Neg_MAX;
        break;

    }

    pQMPolicy->dwFlags = dwFlags;
    pQMPolicy->pOffers = pOffers;
    pQMPolicy->dwOfferCount = dwNumOffers;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\precomp.h ===
#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include <atlbase.h>

#include "netseccore.h"

#include "wbemcli.h"
#include "wbemprov.h"

#include "wmiutils.h"
#include "winipsec.h"

#include <map>
#include <vector>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\policymm.h ===
//////////////////////////////////////////////////////////////////////
// PolicyMM.h : Declaration of CMMPolicy class which implements
// our WMI class Nsp_MMPolicySettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "Policy.h"



/*

Class description
    
    Naming: 

        CMMPolicy stands for Maink Mode Policy.
    
    Base class: 
        
        CIPSecBase, because it is a class representing a WMI object - its WMI 
        class name is Nsp_MMPolicySettings
    
    Purpose of class:

        (1) Nsp_MMPolicySettings is the WMI class for SPD's IPSEC_MM_POLICY.
    
    Design:

        (1) it implements IIPSecObjectImpl.

    Use:

        (1) You probably will never create an instance and use it directly. Everything
            should normall go through IIPSecObjectImpl for non-static functions.


*/

class ATL_NO_VTABLE CMMPolicy :
    public CIPSecPolicy
{

protected:
    CMMPolicy(){}
    virtual ~CMMPolicy(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    static 
    HRESULT AddPolicy (
        IN bool             bPreExist, 
        IN PIPSEC_MM_POLICY pMMPolicy
        );

    static 
    HRESULT DeletePolicy (
        IN LPCWSTR pszPolicyName
        );

private:

    HRESULT CreateWbemObjFromMMPolicy (
        IN  PIPSEC_MM_POLICY    pPolicy,
        OUT IWbemClassObject ** ppObj
        );

    HRESULT GetMMPolicyFromWbemObj (
        IN  IWbemClassObject * pInst, 
        OUT PIPSEC_MM_POLICY * ppPolicy, 
        OUT bool             * pbPreExist
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\resource.h ===
//{{NO_DEPENDENCIES}}
// resource header file.
// Used by ipsecprov.rc
//
#define IDR_NETSECPROV                  200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\policyqm.h ===
//////////////////////////////////////////////////////////////////////
// PolicyQM.h : Declaration of CQMPolicy class which implements
// our WMI class Nsp_QMPolicySettings
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 3/8/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "Policy.h"

//
// flags for quick mode policy's negotiation
//

enum EnumEncryption
{
    RAS_L2TP_NO_ENCRYPTION,
    RAS_L2TP_OPTIONAL_ENCRYPTION,
    RAS_L2TP_REQUIRE_MAX_ENCRYPTION,
    RAS_L2TP_REQUIRE_ENCRYPTION,
};


/*

Class description
    
    Naming: 

        CQMPolicy stands for Quick Mode Policy.
    
    Base class: 
        
        CIPSecBase, because it is a class representing a WMI object - its WMI 
        class name is Nsp_QMPolicySettings
    
    Purpose of class:

        (1) Nsp_QMPolicySettings is the WMI class for SPD's IPSEC_QM_POLICY.
    
    Design:

        (1) it implements IIPSecObjectImpl.
    
    Use:

        (1) You probably will never create an instance and use it directly. Everything
            should normall go through IIPSecObjectImpl for non-static functions.


*/

class ATL_NO_VTABLE CQMPolicy :
    public CIPSecPolicy
{

protected:
    CQMPolicy(){}
    virtual ~CQMPolicy(){}

public:

    //
    // IIPSecObjectImpl methods:
    //

    STDMETHOD(QueryInstance) (
        IN LPCWSTR           pszQuery,
        IN IWbemContext    * pCtx,
        IN IWbemObjectSink * pSink
        );

    STDMETHOD(DeleteInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(PutInstance) (
        IN IWbemClassObject * pInst,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    STDMETHOD(GetInstance) ( 
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink
        );

    static
    HRESULT AddPolicy (
        IN bool             bPreExist, 
        IN PIPSEC_QM_POLICY pQMPolicy
        );

    static 
    HRESULT DeletePolicy (
        IN LPCWSTR pszPolicyName
        );

    static
    HRESULT ExecMethod (
        IN IWbemServices    * pNamespace,
        IN LPCWSTR            pszMethod, 
        IN IWbemContext     * pCtx, 
        IN IWbemClassObject * pInParams,
        IN IWbemObjectSink  * pSink
        );

    static
    HRESULT DeleteDefaultPolicies();

    
    static
    HRESULT DoReturn (
        IN IWbemServices    * pNamespace,
        IN LPCWSTR            pszMethod,
        IN DWORD              dwCount,
        IN LPCWSTR          * pszValueNames,
        IN VARIANT          * varValues,
        IN IWbemContext     * pCtx,
        IN IWbemObjectSink  * pSink 
        );

private:

    static
    HRESULT CreateDefaultPolicy (
        EnumEncryption  eEncryption
        );


    HRESULT CreateWbemObjFromQMPolicy (
        IN  PIPSEC_QM_POLICY    pPolicy,
        OUT IWbemClassObject ** ppObj
        );

    HRESULT GetQMPolicyFromWbemObj (
        IN  IWbemClassObject * pInst, 
        OUT PIPSEC_QM_POLICY * ppPolicy, 
        OUT bool             * pbPreExist
        );

    static
    LPCWSTR GetDefaultPolicyName (
        EnumEncryption  eEncryption
        );
};

//
// The following functions are used to create default QM policies
//


DWORD
BuildOffers(
    EnumEncryption eEncryption,
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers,
    PDWORD pdwFlags
    );

DWORD
BuildOptEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );

DWORD
BuildRequireEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );

DWORD
BuildNoEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );


DWORD
BuildStrongEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );

void
BuildOffer(
    IPSEC_QM_OFFER * pOffer,
    DWORD dwNumAlgos,
    DWORD dwFirstOperation,
    DWORD dwFirstAlgoIdentifier,
    DWORD dwFirstAlgoSecIdentifier,
    DWORD dwSecondOperation,
    DWORD dwSecondAlgoIdentifier,
    DWORD dwSecondAlgoSecIdentifier,
    DWORD dwKeyExpirationBytes,
    DWORD dwKeyExpirationTime
    );

VOID
BuildQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    EnumEncryption eEncryption,
    PIPSEC_QM_OFFER pOffers,
    DWORD dwNumOffers,
    DWORD dwFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\scriptsupport.cpp ===
// ScriptSupport.cpp: implementation for our scripting support class CScriptSupport
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "ScriptSupport.h"


/*
Routine Description: 

Name:

    CScriptSupport::CScriptSupport

Functionality:

    Constructor

Virtual:
    
    No

Arguments:

    None

Return Value:

    None


Notes:

*/

CScriptSupport::CScriptSupport ()
{
    //
    // this is not part of WMI provider, so, we need to do the security
    //
    HRESULT hr = ::CoInitializeSecurity(
                                        NULL, 
                                        -1, 
                                        NULL, 
                                        NULL,
                                        RPC_C_AUTHN_LEVEL_CONNECT, 
                                        RPC_C_IMP_LEVEL_IDENTIFY, 
                                        NULL, 
                                        EOAC_NONE, 
                                        0
                                        );


}



/*
Routine Description: 

Name:

    CScriptSupport::~CScriptSupport

Functionality:

    Destructor

Virtual:
    
    Yes.

Arguments:

    None

Return Value:

    None


Notes:

*/
CScriptSupport::~CScriptSupport ()
{
}



/*
Routine Description: 

Name:

    CScriptSupport::InterfaceSupportsErrorInfo

Functionality:

    Queries if we support IErrorInfo

Virtual:
    
    Yes (part of ISupportErrorInfo)

Arguments:

    riid - Interface ID (guid).

Return Value:

    S_OK


Notes:
    
    $undone:shawnwu, This is just testing for now. Don't check in the code.

*/
	
STDMETHODIMP 
CScriptSupport::InterfaceSupportsErrorInfo (
    REFIID riid
    )
{
    //return (riid == IID_INetSecProvMgr) ? NOERROR : ResultFromScode(S_FALSE);

    return S_FALSE;
}

/*
Routine Description: 

Name:

    CScriptSupport::get_RandomPortLower

Functionality:

    Get the random port's lower bound.

Virtual:
    
    Yes (part of INetSecProvMgr)

Arguments:

    plLower - Receivs the lower bound of random port range.

Return Value:

    S_OK


Notes:
    
    $undone:shawnwu, This is just testing for now. Don't check in the code.

*/
	
STDMETHODIMP 
CScriptSupport::get_RandomPortLower (
    OUT long * plLower
	)
{
	*plLower = 65000;

    return S_OK;
}


/*
Routine Description: 

Name:

    CScriptSupport::gett_RandomPortUpper

Functionality:

    Get the random port's upper bound.

Virtual:
    
    Yes (part of INetSecProvMgr)

Arguments:

    plUpper - Receivs the upper bound of random port range.

Return Value:

    S_OK


Notes:
    
    $undone:shawnwu, This is just testing for now. Don't check in the code.

*/
	
STDMETHODIMP 
CScriptSupport::get_RandomPortUpper (
    OUT long * plUpper
	)
{
	*plUpper = 65012;

    return S_OK;
}



/*
Routine Description: 

Name:

    CScriptSupport::GetNamespace

Functionality:

    Private helper for finding the provider's service interface given its namespace string.

Virtual:
    
    No.

Arguments:

    bstrNamespace - Namespace string.

    ppNS          - Receives the namespace.

Return Value:

    Success: S_OK.

    Failure: other error codes.


Notes:
    
    $undone:shawnwu, This is just testing for now. Don't check in the code.

*/

HRESULT
CScriptSupport::GetNamespace (
    IN  BSTR             bstrNamespace,
    OUT IWbemServices ** ppNS
    )
{
    if (ppNS == NULL)
    {
        return E_INVALIDARG;
    }

    *ppNS = NULL;

    CComPtr<IWbemLocator> srpLocator;
    HRESULT hr = ::CoCreateInstance(CLSID_WbemLocator, 
                                    0,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator, 
                                    (LPVOID *) &srpLocator
                                    );

    if (SUCCEEDED(hr) && srpLocator)
    {
        //
        // Ask the locator to find the SCE provider.
        //

        CComPtr<IWbemServices> srpNamespace;

        hr = srpLocator->ConnectServer(bstrNamespace, NULL, NULL, NULL, 0, NULL, NULL, &srpNamespace);

        if (SUCCEEDED(hr) && srpNamespace)
        {
            //
            // Set the proxy so that impersonation of the client occurs.
            //

            hr = ::CoSetProxyBlanket(
                                     srpNamespace,
                                     RPC_C_AUTHN_WINNT,
                                     RPC_C_AUTHZ_NONE,
                                     NULL,
                                     RPC_C_AUTHN_LEVEL_CALL,
                                     RPC_C_IMP_LEVEL_IMPERSONATE,
                                     NULL,
                                     EOAC_NONE
                                     );
            if (SUCCEEDED(hr))
            {
                *ppNS = srpNamespace.Detach();
                hr = S_OK;
            }
        }
    }

    return hr;

}


/*
Routine Description: 

Name:

    CScriptSupport::ExecuteQuery

Functionality:

    Execute the given query.

Virtual:
    
    Yes (part of INetSecProvMgr)

Arguments:

    bstrNaemspace   - The provider namespace.

    bstrQuery       - The query to be executed.

    plSucceeded     - Receives the execution result. It is = 1 if succeeded and 0 otherwise.

Return Value:

    S_OK

Notes:
    
    $undone:shawnwu, This is just testing for now. Don't check in the code.

*/
	
STDMETHODIMP 
CScriptSupport::ExecuteQuery (
    IN  BSTR   bstrNamespace, 
    IN  BSTR   bstrQuery,
    IN  BSTR   bstrDelimiter,
    IN  BSTR   bstrPropName,
    OUT BSTR * pbstrResult
    )
{
    *pbstrResult = 0;

    CComPtr<IWbemServices> srpNamespace;
    HRESULT hr = GetNamespace(bstrNamespace, &srpNamespace);

    if (SUCCEEDED(hr))
    {
        CComPtr<IEnumWbemClassObject> srpEnum;

        //
        // querying the objects
        //

        hr = srpNamespace->ExecQuery(L"WQL", 
                                     bstrQuery,
                                     WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                     NULL, 
                                     &srpEnum
                                     );

        if (SUCCEEDED(hr))
        {
            
            //
            // find out how many we have
            //

            ULONG nEnum = 0;

            CComVariant var;

            //
            // push the property values to this vector for later packing
            //

            std::vector<BSTR> vecPropValues;

            //
            // total length of the result string, we need a 0 terminator, that is it is initialized to 1
            //

            long lTotLen = 1;

            //
            // Length of the delimiter
            //

            long lDelLen = wcslen(bstrDelimiter);

            while (SUCCEEDED(hr))
            {
                CComPtr<IWbemClassObject> srpObj;
                hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
                if (SUCCEEDED(hr) && srpObj != NULL)
                {
                    hr = srpObj->Get(bstrPropName, 0, &var, NULL, NULL);
                    if (SUCCEEDED(hr) && var.vt != VT_EMPTY && var.vt != VT_NULL)
                    {
                        CComVariant varResult;
                        if (SUCCEEDED(::VariantChangeType(&varResult, &var, 0, VT_BSTR)))
                        {
                            vecPropValues.push_back(varResult.bstrVal);
                            lTotLen += wcslen(varResult.bstrVal) + lDelLen;
                            varResult.vt = VT_EMPTY;
                        }
                    }
                }
                else
                {
                    break;
                }
            }
            
            *pbstrResult = ::SysAllocStringLen(NULL, lTotLen);

            if (*pbstrResult != NULL)
            {

                //
                // running head of copying
                //

                LPWSTR pDest = *pbstrResult;
                pDest[0] = L'\0';

                for (int i = 0; i < vecPropValues.size(); i++)
                {
                    wcscpy(pDest, vecPropValues[i]);
                    pDest += wcslen(vecPropValues[i]);
                    wcscpy(pDest, bstrDelimiter);
                    pDest += lDelLen;
                }
            }
        }
    }

    return S_OK;
}



/*
Routine Description: 

Name:

    CScriptSupport::GetProperty

Functionality:

    Get the property value of the given object's given property.

Virtual:
    
    Yes (part of INetSecProvMgr)

Arguments:

    bstrNaemspace   - The provider namespace.

    bstrObjectPath  - The path for the object.

    bstrPropName    - The name of the property.

    pvarValue       - Receives the value in string format.

Return Value:

    S_OK

Notes:
    
    $undone:shawnwu, This is just testing for now. Don't check in the code.

*/
	
STDMETHODIMP 
CScriptSupport::GetProperty (
    IN  BSTR      bstrNamespace, 
    IN  BSTR      bstrObjectPath, 
    IN  BSTR      bstrPropName, 
    OUT VARIANT * pvarValue
    )
{
    ::VariantInit(pvarValue);

    CComPtr<IWbemServices> srpNamespace;
    HRESULT hr = GetNamespace(bstrNamespace, &srpNamespace);

    if (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpObj;

        hr = srpNamespace->GetObject(
                                      bstrObjectPath, 
                                      0,
                                      NULL,
                                      &srpObj,
                                      NULL
                                      );
        if (SUCCEEDED(hr))
        {
            hr = srpObj->Get(bstrPropName, 0, pvarValue, NULL, NULL);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\tranxmgr.cpp ===
// TranxMgr.cpp: implementation for the CTranxMgr
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "TranxMgr.h"
#include "FilterMM.h"
#include "FilterTr.h"
#include "FilterTun.h"
#include "PolicyMM.h"
#include "PolicyQM.h"
#include "AuthMM.h"


/*
Routine Description: 

Name:

    CTranxManager::ExecMethod

Functionality:

    This is our C++ class implmeneting Nsp_TranxManager WMI class which
    can execute methods. The class is defined to support "rollback".

Virtual:
    
    Yes (part of IIPSecObjectImpl)

Arguments:

    pNamespace  - our namespace.

    pszMethod   - The name of the method.

    pCtx        - COM interface pointer by WMI and needed for various WMI APIs

    pInParams   - COM interface pointer to the input parameter object.

    pSink       - COM interface pointer for notifying WMI about results.

Return Value:

    Success:

        Various success codes indicating the result.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.


Notes:
    
    Even if errors happen amid the rolling back execution, we will continue. However, we will
    return the first error.

*/

HRESULT 
CTranxManager::ExecMethod (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszMethod,
    IN IWbemContext     * pCtx,
    IN IWbemClassObject * pInParams,
    IN IWbemObjectSink  * pSink
    )
{
    if (pszMethod == NULL || *pszMethod == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    else if (_wcsicmp(pszMethod, g_pszRollback) != 0)   
    {
        //
        // we only support Rollback method
        //

        //
        // $undone:shawnwu, don't check in this code. This is to test
        //


        /*
        if (_wcsicmp(pszMethod, L"ParseXMLFile") == 0)
        {
            if (pInParams == NULL)
            {
                return WBEM_E_INVALID_PARAMETER;
            }

            CComVariant varInput;
            HRESULT hrIgnore = pInParams->Get(L"InputFile", 0, &varInput, NULL, NULL);

            if (SUCCEEDED(hrIgnore) && varInput.vt == VT_BSTR && varInput.bstrVal != NULL)
            {
                CComVariant varOutput;
                hrIgnore = pInParams->Get(L"OutputFile", 0, &varOutput, NULL, NULL);
                
                if (SUCCEEDED(hrIgnore) && varOutput.vt == VT_BSTR && varOutput.bstrVal != NULL)
                {
                    CComVariant varArea;
                    hrIgnore = pInParams->Get(L"Area", 0, &varArea, NULL, NULL);

                    //
                    // allow the section to be empty - meaning all areas.
                    //

                    if (FAILED(hrIgnore) || varArea.vt != VT_BSTR || varArea.bstrVal == NULL)
                    {
                        varArea.Clear();
                        varArea.vt = VT_BSTR;
                        varArea.bstrVal = NULL;
                    }

                    //
                    // get element info we care about
                    //

                    CComVariant varElement;
                    hrIgnore = pInParams->Get(L"Element", 0, &varElement, NULL, NULL);

                    //
                    // allow the element to be empty - meaning every element.
                    //

                    if (FAILED(hrIgnore) || varElement.vt != VT_BSTR || varElement.bstrVal == NULL)
                    {
                        varElement.Clear();
                        varElement.vt = VT_BSTR;
                        varElement.bstrVal = NULL;
                    }

                    CComVariant varSingleArea;
                    hrIgnore = pInParams->Get(L"SingleArea", 0, &varSingleArea, NULL, NULL);

                    bool bSingleArea = false;

                    if (SUCCEEDED(hrIgnore) && varSingleArea.vt == VT_BOOL)
                    {
                        bSingleArea = (varSingleArea.boolVal == VARIANT_TRUE);
                    }

                    return ParseXMLFile(varInput.bstrVal, varOutput.bstrVal, varArea.bstrVal, varElement.bstrVal, bSingleArea);

                }
            }
            return WBEM_E_INVALID_METHOD_PARAMETERS;
        }
        */

        return WBEM_E_NOT_SUPPORTED;
    }
    else if (pInParams == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // we are executing g_pszRollback ("Rollback") method
    //

    //
    // get the in parameters (rollback token and rollback flag)
    //

    CComVariant varToken, varClearAll;

    //
    // if no token, then we will use the GUID_NULL as the token
    //

    HRESULT hr = pInParams->Get(g_pszTokenGuid, 0, &varToken, NULL, NULL);

    //
    // We require the input parameter object to be of good type.
    // We won't tolerate a wrong type of data, either, even though
    // we can live with missing token, though.
    //

    if (FAILED(hr) || SUCCEEDED(hr) && varToken.vt != VT_BSTR)
    {
        return WBEM_E_INVALID_OBJECT;
    }
    else if (SUCCEEDED(hr) && varToken.bstrVal == NULL || *(varToken.bstrVal) == L'\0')
    {
        varToken.Clear();

        varToken = pszRollbackAll;
    }


    //
    // we will allow the flag to be missing. 
    // In that case, it is equivalent to false, meaning not to clear all
    //

    bool bClearAll = false;
    hr = pInParams->Get(g_pszClearAll, 0, &varClearAll, NULL, NULL);
    if (SUCCEEDED(hr) && varClearAll.vt == VT_BOOL)
    {
        bClearAll = (varClearAll.boolVal == VARIANT_TRUE);
    }

    //
    // will return the first error
    //

    HRESULT hrFirstError = WBEM_NO_ERROR;

    //
    // rollback MM filters first
    //

    hr = CIPSecFilter::Rollback(pNamespace, varToken.bstrVal, bClearAll);
    if (FAILED(hr))
    {
        hrFirstError = hr;
    }

    //
    // rollback policies
    //

    hr = CIPSecPolicy::Rollback(pNamespace, varToken.bstrVal, bClearAll);
    if (FAILED(hr) && SUCCEEDED(hrFirstError))
    {
        hrFirstError = hr;
    }

    //
    // rollback main mode authentication
    //

    hr = CAuthMM::Rollback(pNamespace, varToken.bstrVal, bClearAll);

    return FAILED(hrFirstError) ? hrFirstError : hr;
}


/*
Routine Description: 

Name:

    CMMPolicy::ParseXMLFile

Functionality:

    Testing the MSXML parser.

Virtual:
    
    No.

Arguments:

    pszInput    - The input file (XML) name.

    pszOutput   - We will write the parsing result into this output file.

Return Value:

    Success:

        Various success codes indicating the result.

    Failure:

        Various errors may occur. We return various error code to indicate such errors.


Notes:
    
    This is just for testing.



HRESULT 
CTranxManager::ParseXMLFile (
    IN LPCWSTR pszInput, 
    IN LPCWSTR pszOutput,
    IN LPCWSTR pszArea,
    IN LPCWSTR pszElement,
    IN bool    bSingleArea
    )
{
    CComPtr<ISAXXMLReader> srpRdr;

    HRESULT hr = ::CoCreateInstance(
								CLSID_SAXXMLReader, 
								NULL, 
								CLSCTX_ALL, 
								IID_ISAXXMLReader, 
								(void **)&srpRdr);

	if (SUCCEEDED(hr)) 
    {
		CComObject<CXMLContent> * pXMLContent;
        hr = CComObject<CXMLContent>::CreateInstance(&pXMLContent);

        if (SUCCEEDED(hr))
        {
            CComPtr<ISAXContentHandler> srpHandler;
            pXMLContent->AddRef();

            if (S_OK == pXMLContent->QueryInterface(IID_ISAXContentHandler, (void**)&srpHandler))
            {
		        hr = srpRdr->putContentHandler(srpHandler);
            }
            else
            {
                hr = WBEM_E_NOT_SUPPORTED;
            }

            if (SUCCEEDED(hr))
            {
                pXMLContent->SetOutputFile(pszOutput);
                pXMLContent->SetSection(pszArea, pszElement, bSingleArea);
            }

            pXMLContent->Release();

            //
            // CXMLErrorHandler * pEH;
            // hr = srpRdr->putErrorHandler(pDH);
		    // CXMLDTDHandler * pDH;
		    // hr = srpRdr->putDTDHandler(pDH);
            //
		    
		    if (SUCCEEDED(hr))
            {
                hr = srpRdr->parseURL(pszInput);

                //
                // we allow parseURL to fail because we may stop processing
                // in the middle of parsing XML.
                //

                if (FAILED(hr) && pXMLContent->ParseComplete())
                {
                    hr = WBEM_S_FALSE;
                }
            }
        }
	}

    return SUCCEEDED(hr) ? WBEM_NO_ERROR : hr;
}


*/



/*


//----------------------------------------------------------------------------------
// Implementation for CFileStream
//----------------------------------------------------------------------------------

bool 
CFileStream::Open (
    IN LPCWSTR  pszName, 
    IN bool     bRead = true
    )
{
    this->m_bRead = bRead;
    long len;

    if (pszName == NULL)
    {
        m_hFile = GetStdHandle(STD_INPUT_HANDLE);
    }
    else
    { 
        if (bRead)
        {
		    m_hFile = ::CreateFile( 
                                   pszName,
			                       GENERIC_READ,
			                       FILE_SHARE_READ,
			                       NULL,
			                       OPEN_EXISTING,
			                       FILE_ATTRIBUTE_NORMAL,
			                       NULL
                                  );
        }
        else
        {
		    m_hFile = ::CreateFile(
			                       pszName,
			                       GENERIC_WRITE,
			                       FILE_SHARE_READ,
			                       NULL,
			                       CREATE_ALWAYS,
			                       FILE_ATTRIBUTE_NORMAL,
			                       NULL
                                  );
        }
    }
    return (m_hFile == INVALID_HANDLE_VALUE) ? false : true;
}

HRESULT 
CFileStream::Read ( 
    OUT void  * pv,
    IN  ULONG   cb,
    OUT ULONG * pcbRead
    )
{	
    if (!read) 
    {
        return E_FAIL;
    }

    DWORD len = 0;

	BOOL rc = ReadFile(
			           m_hFile,	// handle of file to read 
			           pv,	    // address of buffer that receives data  
			           cb,	    // number of bytes to read 
			           &len,	// address of number of bytes read 
			           NULL 	// address of structure for data 
		              );

    *pcbRead = len;

    if (*pcbRead == 0) 
    {
        return S_FALSE;
    }

	return (rc) ? S_OK : E_FAIL;
}
    
HRESULT 
CFileStream::Write ( 
    IN  const void * pv,
    IN  ULONG        cb,
    OUT ULONG      * pcbWritten
    )
{
    if (read) 
    {
        return E_FAIL;
    }

	BOOL rc = WriteFile(
			            m_hFile,	// handle of file to write 
			            pv,	        // address of buffer that contains data  
			            cb,	        // number of bytes to write 
			            pcbWritten,	// address of number of bytes written 
			            NULL 	    // address of structure for overlapped I/O  
		               );

	return (rc) ? S_OK : E_FAIL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\scriptsupport.h ===
//////////////////////////////////////////////////////////////////////
// ScriptSupport.h : Declaration of scripting support class
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 6/1/2001
// Original Author: shawnwu
// Note: Theoretically, WMI allows us to script its object. That truly
//       works for regular scripts. However, I found that any extension
//       function written in VBScript (JScript) can't use WMI objects.
//       But it can use regular scriptable objects.
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"



/*

Class description
    
    Naming: 

        CScriptSupport stands for Scripting Support.
    
    Base class: 
        
        (1) CComObjectRootEx for threading model and IUnknown.

        (2) CComCoClass for it to be externally creatable.

        (3) ISupportErrorInfo for error info support.

        (4) INetSecProvMgr, which is what this object really do
    
    Purpose of class:

        (1) A scripting support helper object, which is exposed to the outside world
            via our Type library under the class name of NetSecProvMgr.
    
    Design:

        (1) Very simple and typical Dual interface implementation.

    
    Use:

        (1) This class is intended for script to use, really.  So, script
            can create our object by CreateObject("NetSecProv.NetSecProvMgr");

        (2) If you want to use it inside our own code, follow normal CComObject creation
            sequence to create it and then call the functions.

    Notes:

        (1) $undone:shawnwu, This is just testing for now. Don't check in the code.

        

*/

class ATL_NO_VTABLE CScriptSupport :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CScriptSupport, &CLSID_NetSecProvMgr>,
    public ISupportErrorInfo,
    public IDispatchImpl<INetSecProvMgr, &IID_INetSecProvMgr, &LIBID_NetSecProvLib>
{

protected:

    CScriptSupport();


    virtual ~CScriptSupport();

BEGIN_COM_MAP(CScriptSupport)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(INetSecProvMgr)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CScriptSupport )
DECLARE_REGISTRY_RESOURCEID(IDR_NETSECPROV)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:

    //
    // ISupportErrorInfo:
    //

    STDMETHOD(InterfaceSupportsErrorInfo) (
        REFIID riid
        );

    //
    // INetSecProvMgr methods:
    //

    //
    // [id][propget], piLower is [retval][out]
    //

    STDMETHOD(get_RandomPortLower) ( 
        OUT long * piLower
        );

        
    //
    // [id][propget], piUpper is [retval][out]
    //

    STDMETHOD(get_RandomPortUpper) ( 
        OUT long * piUpper
        );

    STDMETHOD(ExecuteQuery) (
        IN  BSTR   bstrNamespace, 
        IN  BSTR   bstrQuery,
        IN  BSTR   bstrDelimiter,
        IN  BSTR   bstrPropName,
        OUT BSTR * pbstrResult
        );

    STDMETHOD(GetProperty) (
        IN  BSTR      bstrNamespace, 
        IN  BSTR      bstrObjectPath, 
        IN  BSTR      bstrPropName, 
        OUT VARIANT * pvarValue
        );

protected:

    HRESULT GetNamespace (
        IN  BSTR             bstrNamespace,
        OUT IWbemServices ** ppNS
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\tranxmgr.h ===
//////////////////////////////////////////////////////////////////////
// TranxMgr.h : Declaration of CTranxManager
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 4/9/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"
#include "IPSecBase.h"


/*

Class description
    
    Naming: 

        CTranxManager stands for Transaction Manager.
    
    Base class: 
        
        None.
    
    Purpose of class:

        (1) To support method execution for the purpose of supporting rollback. Its WMI class
            is called Nsp_TranxManager.

    Design:

        (1) This is one of the classes that differ drastically to the rest of C++ classes
            for the WMI corresponding classes. This class is directly used by our provider class
            CNetSecProv when method is to be executed because all those method execution is
            going to go through this class. Since Nsp_TranxManager doesn't have any other property
            and it is not a dyanmic class, we don't need to do anything other than implementing
            the ExecMethod called from CNetSecProv.

        (2) Because of the nature of the class, we don't even allow you to create an instance.

    Use:

        (1) Just call the static function.


*/

class CTranxManager
{

protected:
    CTranxManager(){};
    ~CTranxManager(){};

public:
    static
    HRESULT ExecMethod (
        IN IWbemServices    * pNamespace,
        IN LPCWSTR            pszMethod, 
        IN IWbemContext     * pCtx, 
        IN IWbemClassObject * pInParams,
        IN IWbemObjectSink  * pSink
        );

private:

    //
    // for testing xml file parsing
    //

//#ifdef _DEBUG

    static
    HRESULT ParseXMLFile (
        IN LPCWSTR pszInput, 
        IN LPCWSTR pszOutput,
        IN LPCWSTR pszArea,
        IN LPCWSTR pszSection,
        IN bool    bSingleSection
        );

//#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\xmlreader.cpp ===
// TranxMgr.cpp: implementation for the CTranxMgr
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "XMLReader.h"


/*
Routine Description: 

Name:

    CXMLContent::CXMLContent

Functionality:

    Trivial.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here.

*/

CXMLContent::CXMLContent ()
    : m_dwTotalElements(0),
      m_hOutFile(NULL),
      m_bFinished(false),
      m_bInSection(false),
      m_bSingleArea(true)
{
}


/*
Routine Description: 

Name:

    CXMLContent::~CXMLContent

Functionality:

    Trivial.

Virtual:
    
    Yes.

Arguments:

    None.

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about releasing them here.

*/

CXMLContent::~CXMLContent()
{
    if (m_hOutFile != NULL)
    {
        ::CloseHandle(m_hOutFile);
    }
}


/*
Routine Description: 

Name:

    CXMLContent::startElement

Functionality:

    Analyze the elements. If the element is what we are interested in,
    then we will cache the information.

Virtual:
    
    Yes.

Arguments:

    pwchNamespaceUri    - The namespace URI.

    cchNamespaceUri     - The length for the namespace URI. 

    pwchLocalName       - The local name string. 

    cchLocalName        - The length of the local name. 

    pwchQName           - The QName (with prefix) or, if QNames are not available, an empty string. 

    cchQName            - The length of the QName. 

    pAttributes         - COM interface to the attribute object.

Return Value:

    Success:

        S_OK;

    Failure:
        
        E_FAIL (this causes the parser not to continue parsing).

Notes:
    
    See MSDN ISAXContentHandler::startElement for detail. We must maintain our handler
    to stay compatible with MSDN's specification.
*/

STDMETHODIMP
CXMLContent::startElement ( 
    IN const wchar_t  * pwchNamespaceUri,
    IN int              cchNamespaceUri,
    IN const wchar_t  * pwchLocalName,
    IN int              cchLocalName,
    IN const wchar_t  * pwchQName,
    IN int              cchQName,
    IN ISAXAttributes * pAttributes
    )
{
    
    //
    // If we have finished then we will stop here.
    //

    if ( m_bFinished ) 
    {
        return E_FAIL;
    }

    ++m_dwTotalElements;

    //
    // if we are not in our section, we will only need to carry out
    // further if this element is a Section element
    //

    if (m_bInSection == false && _wcsicmp(pwchQName, L"Section") == 0)
    {
        LPWSTR pArea = NULL;
        if (GetAttributeValue(pAttributes, L"Area", &pArea))
        {
            m_bInSection = (_wcsicmp(m_bstrSecArea, L"All") == 0 || _wcsicmp(pArea, m_bstrSecArea) == 0);

            //
            // $undone:shawnwu, put some header information, currently, hard coded for SCE's INF file
            //

            if (_wcsicmp(L"Sce_Core", pArea) == 0)
            {
                WriteContent(L"[Unicode]", NULL);
                WriteContent(L"Unicode", L"yes");
                WriteContent(L"[Version]", NULL);
                WriteContent(L"$CHICAGO$", NULL);
                WriteContent(L"Revision", L"1");
                WriteContent(L"\r\n", NULL);
                WriteContent(L"[System Access]", NULL);
            }
            WriteContent(L"\r\n", NULL);
        }

        delete [] pArea;
    }

    //
    // if not in our section, don't bother to continue
    //

    if (m_bInSection == false)
    {
        return S_OK;
    }

    if (m_bInElement == false && _wcsicmp(pwchQName, m_bstrElement) == 0)
    {
        m_bInElement = true;

        //
        // $undone:shawnwu, consider writing some element comments?
        //
    }
    
    if (m_bInElement == false)
    {
        return S_OK;
    }

    int iAttribCount = 0;

    pAttributes->getLength(&iAttribCount);

    LPWSTR pszPropName = NULL;
    LPWSTR pszPropValue = NULL; 

    if (GetAttributeValue(pAttributes, L"Name", &pszPropName))
    {

        //
        // In real time, we will do something with the (name, value) pair
        // since we are just testing here, write it to the file
        //

        if (GetAttributeValue(pAttributes, L"Value", &pszPropValue))
        {
            WriteContent(pszPropName, pszPropValue);
        }

        delete [] pszPropName;
        pszPropName = NULL;

        delete [] pszPropValue;
        pszPropValue = NULL;
    }

    return S_OK;
}
        

/*
Routine Description: 

Name:

    CXMLContent::endElement

Functionality:

    Analyze the elements. We may decide that this is the end of our parsing need
    depending on our settings.

Virtual:
    
    Yes.

Arguments:

    pwchNamespaceUri    - The namespace URI.

    cchNamespaceUri     - The length for the namespace URI. 

    pwchLocalName       - The local name string. 

    cchLocalName        - The length of the local name. 

    pwchQName           - The QName (with prefix) or, if QNames are not available, an empty string. 

    cchQName            - The length of the QName. 

Return Value:

    Success:

        S_OK;

    Failure:
        
        E_FAIL (this causes the parser not to continue parsing).

Notes:
    
    See MSDN ISAXContentHandler::endElement for detail. We must maintain our handler
    to stay compatible with MSDN's specification.
*/
       
STDMETHODIMP
CXMLContent::endElement ( 
    IN const wchar_t  * pwchNamespaceUri,
    IN int              cchNamespaceUri,
    IN const wchar_t  * pwchLocalName,
    IN int              cchLocalName,
    IN const wchar_t  * pwchQName,
    IN int              cchQName
    )
{
    //
    // if we have seen the section ended, we are done.
    //

    if (m_bInSection && _wcsicmp(pwchQName, L"Section") == 0)
    {
        m_bFinished = m_bSingleArea;
        m_bInSection = false;
    }
    
    if (m_bInElement && _wcsicmp(pwchQName, m_bstrElement) == 0)
    {
        m_bInElement = false;
    }

    return S_OK;
}

STDMETHODIMP
CXMLContent::startDocument()
{
    m_bFinished = false;
    m_bInElement = false;
    m_bInSection = false;
    m_dwTotalElements = 0;
    return S_OK;
}

STDMETHODIMP
CXMLContent::endDocument ()
{
    LPCWSTR pszOutFile = m_bstrOutputFile;

    if (pszOutFile && *pszOutFile != L'\0')
    {
        //
        // testing code.
        //

        WCHAR pszValue[100];

        swprintf(pszValue, L"%d", m_dwTotalElements);

        WriteContent(L"\r\nTotal Elements parsed: ", pszValue);
    }

    return S_OK;
}

STDMETHODIMP
CXMLContent::putDocumentLocator ( 
    IN ISAXLocator *pLocator
    )
{
    return S_OK;
}
        

STDMETHODIMP
CXMLContent::startPrefixMapping ( 
    IN const wchar_t  * pwchPrefix,
    IN int              cchPrefix,
    IN const wchar_t  * pwchUri,
    IN int              cchUri
    )
{
    return S_OK;
}
        
STDMETHODIMP
CXMLContent::endPrefixMapping ( 
    IN const wchar_t  * pwchPrefix,
    IN int              cchPrefix
    )
{
    return S_OK;
}

STDMETHODIMP
CXMLContent::characters ( 
    IN const wchar_t  * pwchChars,
    IN int              cchChars
    )
{
    return S_OK;
}
        
STDMETHODIMP
CXMLContent::ignorableWhitespace ( 
    IN const wchar_t * pwchChars,
    IN int              cchChars
    )
{
    return S_OK;
}
        
STDMETHODIMP
CXMLContent::processingInstruction ( 
    IN const wchar_t  * pwchTarget,
    IN int              cchTarget,
    IN const wchar_t  * pwchData,
    IN int              cchData
    )
{
    return S_OK;
}
        
STDMETHODIMP
CXMLContent::skippedEntity ( 
    IN const wchar_t  * pwchName,
    IN int              cchName
    )
{
    return S_OK;
}



/*
Routine Description: 

Name:

    CXMLContent::GetAttributeValue

Functionality:

    Private helper. Given the attribute's name, we will return the attribute's value.

Virtual:
    
    No.

Arguments:

    pAttributes         - COM interface to the attribute object.

    pszTestName         - The name of the attributes we want the value of.

    ppszAttrVal         - Receives the attribute's value if found.

Return Value:

    true if the named attribute is found;

    false otherwise.

Notes:
    Caller is responsible for releasing the memory allocated to the 
    out parameter.

*/

bool
CXMLContent::GetAttributeValue (
    IN  ISAXAttributes * pAttributes,
    IN  LPCWSTR          pszAttrName,
    OUT LPWSTR         * ppszAttrVal
    )
{
    //
    // caller is responsible for passing valid parameters
    //

    *ppszAttrVal = NULL;

    int iAttribCount = 0;

    pAttributes->getLength(&iAttribCount);

    const wchar_t * pszName;
    const wchar_t * pszValue; 

    int iNameLen;
    int iValLen;

    for ( int i = 0; i < iAttribCount; i++ ) 
    {
        HRESULT hr = pAttributes->getLocalName(i, &pszName, &iNameLen);

        if (SUCCEEDED(hr) && wcsncmp(pszAttrName, pszName, iNameLen) == 0)
        {
            hr = pAttributes->getValue(i, &pszValue, &iValLen);
            if (SUCCEEDED(hr))
            {
                *ppszAttrVal = new WCHAR[iValLen + 1];
                if (*ppszAttrVal != NULL)
                {
                    wcscpy(*ppszAttrVal, pszValue);
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
    }

    return false;
}



/*
Routine Description: 

Name:

    CXMLContent::GetAttributeValue

Functionality:

    Private helper. Given the index, we will return the attribute's name and its value.

Virtual:
    
    No.

Arguments:

    pAttributes     - COM interface to the attribute object.

    iIndex          - The index of the attribute we want.

    ppszAttrName    - Receives the name of the attributes we want.

    ppszAttrVal     - Receives the attribute's value if found.

Return Value:

    true if the named attribute is found;

    false otherwise.

Notes:
    
    Caller is responsible for releasing the memory allocated to both 
    out parameters.
*/

bool
CXMLContent::GetAttributeValue (
    IN  ISAXAttributes * pAttributes,
    IN  int              iIndex,
    OUT LPWSTR         * ppszAttrName,
    OUT LPWSTR         * ppszAttrVal
    )
{

    //
    // caller is responsible for passing valid parameters
    //

    *ppszAttrName = NULL;
    *ppszAttrVal = NULL;

    const wchar_t * pszName;
    const wchar_t * pszValue; 

    int iNameLen;
    int iValLen;

    HRESULT hr = pAttributes->getLocalName(iIndex, &pszName, &iNameLen);

    if (SUCCEEDED(hr) && iNameLen > 0)
    {
        hr = pAttributes->getValue(iIndex, &pszValue, &iValLen);
        if (SUCCEEDED(hr) && iValLen > 0)
        {
            *ppszAttrName = new WCHAR[iNameLen + 1];
            *ppszAttrVal = new WCHAR[iValLen + 1];

            if (*ppszAttrName != NULL && *ppszAttrVal != NULL)
            {
                wcsncpy(*ppszAttrName, pszName, iNameLen);
                (*ppszAttrName)[iNameLen] = L'\0';

                wcsncpy(*ppszAttrVal, pszValue, iValLen);
                (*ppszAttrVal)[iValLen] = L'\0';
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    return false;
}



/*
Routine Description: 

Name:

    CXMLContent::WriteContent

Functionality:

    Testing function. This determines which section area this
    reader is interested in and which element of the section
    this reader will process.


Virtual:
    
    No.

Arguments:

    pszSecArea  - The Area attribute of the section the reader will process.

    pszElement  - The name of the element the reader will process.

    bOneAreaOnly- Whether we will only process one area.

Return Value:

    None.

Notes:
    
*/

void 
CXMLContent::SetSection (
    IN LPCWSTR pszSecArea,
    IN LPCWSTR pszElement,
    IN bool    bOneAreaOnly
    )
{
    m_bstrSecArea = pszSecArea;
    m_bstrElement = pszElement;
    m_bSingleArea = bOneAreaOnly;
}


/*
Routine Description: 

Name:

    CXMLContent::WriteContent

Functionality:

    Private helper for testing (for now). 

    Given the name and value pair, we will write <name>=<value> into the output file.

Virtual:
    
    No.

Arguments:

    pszName     - The name of the pair.

    pszValue    - The value of the pair. Can be NULL. In that case, we will only
                  write the pszName as a separate line.

Return Value:

    None.

Notes:
    
*/

void 
CXMLContent::WriteContent (
    IN LPCWSTR  pszName,
    IN LPCWSTR  pszValue
    )
{
    if (m_hOutFile == NULL)
    {
        m_hOutFile = ::CreateFile (m_bstrOutputFile,
                                   GENERIC_WRITE,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL
                                   );
    }

    if (m_hOutFile != NULL)
    {
        DWORD dwBytesWritten = 0;

        ::WriteFile (m_hOutFile, 
                     (LPCVOID) pszName,
                     wcslen(pszName) * sizeof(WCHAR),
                     &dwBytesWritten,
                     NULL
                     );

        if (pszValue != NULL)
        {
            ::WriteFile (m_hOutFile, 
                         (LPCVOID) L"=",
                         sizeof(WCHAR),
                         &dwBytesWritten,
                         NULL
                         );

            ::WriteFile (m_hOutFile, 
                         (LPCVOID) pszValue,
                         wcslen(pszValue) * sizeof(WCHAR),
                         &dwBytesWritten,
                         NULL
                         );
        }

        //
        // a new line
        //

        ::WriteFile (m_hOutFile, 
                     (LPCVOID) L"\r\n",
                     2 * sizeof(WCHAR),
                     &dwBytesWritten,
                     NULL
                     );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\winipsec.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    winipsec.h

Abstract:

    Header file for IPSec WINAPIs.

Author:

    krishnaG    21-September-1999

Environment:

    User Level: Win32

Revision History:

    abhisheV    21-September-1999    Added the structures.

--*/


#ifndef _WINIPSEC_
#define _WINIPSEC_


#ifdef __cplusplus
extern "C" {
#endif


#define     PERSIST_SPD_OBJECT      (ULONG) 0x00000001

#define     IP_ADDRESS_ME           (ULONG) 0x00000000
#define     IP_ADDRESS_MASK_NONE    (ULONG) 0xFFFFFFFF
#define     SUBNET_ADDRESS_ANY      (ULONG) 0x00000000
#define     SUBNET_MASK_ANY         (ULONG) 0x00000000


#define     FILTER_NATURE_PASS_THRU     0x00000001
#define     FILTER_NATURE_BLOCKING      0x00000002
#define     FILTER_DIRECTION_INBOUND    0x00000004
#define     FILTER_DIRECTION_OUTBOUND   0x00000008


#define     ENUM_GENERIC_FILTERS           0x00000001
#define     ENUM_SELECT_SPECIFIC_FILTERS   0x00000002
#define     ENUM_SPECIFIC_FILTERS          0x00000004


//
// Policy flags.
//

#define IPSEC_MM_POLICY_ENABLE_DIAGNOSTICS  0x00000001
#define IPSEC_MM_POLICY_DEFAULT_POLICY      0x00000002
#define IPSEC_MM_POLICY_ON_NO_MATCH         0x00000004
#define IPSEC_MM_POLICY_DISABLE_CRL         0x00000008
#define IPSEC_MM_POLICY_DISABLE_NEGOTIATE   0x00000010


#define IPSEC_QM_POLICY_TRANSPORT_MODE  0x00000000
#define IPSEC_QM_POLICY_TUNNEL_MODE     0x00000001
#define IPSEC_QM_POLICY_DEFAULT_POLICY  0x00000002
#define IPSEC_QM_POLICY_ALLOW_SOFT      0x00000004
#define IPSEC_QM_POLICY_ON_NO_MATCH     0x00000008
#define IPSEC_QM_POLICY_DISABLE_NEGOTIATE 0x00000010


#define IPSEC_MM_AUTH_DEFAULT_AUTH      0x00000001
#define IPSEC_MM_AUTH_ON_NO_MATCH       0x00000002


#define RETURN_DEFAULTS_ON_NO_MATCH     0x00000001


//
// Delete MM SA flags.
//

#define IPSEC_MM_DELETE_ASSOCIATED_QMS  0x00000001


#define IPSEC_SA_TUNNEL         0x00000001
#define IPSEC_SA_REPLAY         0x00000002
#define IPSEC_SA_DELETE         0x00000004
#define IPSEC_SA_MANUAL         0x00000010

#define IPSEC_SA_MULTICAST_MIRROR 0x00000020
#define IPSEC_SA_INBOUND          0x00000040
#define IPSEC_SA_OUTBOUND         0x00000080
#define IPSEC_SA_DISABLE_IDLE_OUT 0x00000100

#define IPSEC_SA_DISABLE_ANTI_REPLAY_CHECK 0x00000200
#define IPSEC_SA_DISABLE_LIFETIME_CHECK    0x00000400






//
// Bounds for number of offers
//
#define IPSEC_MAX_MM_OFFERS	20
#define IPSEC_MAX_QM_OFFERS	50

typedef enum _ADDR_TYPE {
    IP_ADDR_UNIQUE = 1,
    IP_ADDR_SUBNET,
    IP_ADDR_INTERFACE,
} ADDR_TYPE, * PADDR_TYPE;


typedef struct _ADDR {
    ADDR_TYPE AddrType;
    ULONG uIpAddr;
    ULONG uSubNetMask;
    GUID gInterfaceID;
} ADDR, * PADDR;


typedef enum _PROTOCOL_TYPE {
    PROTOCOL_UNIQUE = 1,
} PROTOCOL_TYPE, * PPROTOCOL_TYPE;


typedef struct _PROTOCOL {
    PROTOCOL_TYPE ProtocolType;
    DWORD dwProtocol;
} PROTOCOL, * PPROTOCOL;


typedef enum _PORT_TYPE {
    PORT_UNIQUE = 1,
} PORT_TYPE, * PPORT_TYPE;


typedef struct _PORT {
    PORT_TYPE PortType;
    WORD wPort;
} PORT, * PPORT;


typedef enum _IF_TYPE {
    INTERFACE_TYPE_ALL = 1,
    INTERFACE_TYPE_LAN,
    INTERFACE_TYPE_DIALUP,
    INTERFACE_TYPE_MAX
} IF_TYPE, * PIF_TYPE;


typedef enum _FILTER_FLAG {
    PASS_THRU = 1,
    BLOCKING,
    NEGOTIATE_SECURITY,
    FILTER_FLAG_MAX
} FILTER_FLAG, * PFILTER_FLAG;


typedef struct _TRANSPORT_FILTER {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
} TRANSPORT_FILTER, * PTRANSPORT_FILTER;


//
// Maximum number of transport filters that can be enumerated
// by SPD at a time.
//

#define MAX_TRANSPORTFILTER_ENUM_COUNT 1000


typedef struct _TUNNEL_FILTER {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    ADDR SrcTunnelAddr;
    ADDR DesTunnelAddr;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
} TUNNEL_FILTER, * PTUNNEL_FILTER;


//
// Maximum number of tunnel filters that can be enumerated
// by SPD at a time.
//

#define MAX_TUNNELFILTER_ENUM_COUNT 1000


typedef struct _MM_FILTER {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gMMAuthID;
    GUID gPolicyID;
} MM_FILTER, * PMM_FILTER;


//
// Maximum number of main mode filters that can be enumerated
// by SPD at a time.
//

#define MAX_MMFILTER_ENUM_COUNT 1000


//
//  Common Structures for Main Mode and Quick Mode Policies.
//


//
// IPSEC DOI ESP algorithms supported by SPD.
//

typedef enum _IPSEC_DOI_ESP_ALGO {
    IPSEC_DOI_ESP_NONE = 0,
    IPSEC_DOI_ESP_DES,
    IPSEC_DOI_ESP_3_DES = 3,
    IPSEC_DOI_ESP_MAX
} IPSEC_DOI_ESP_ALGO, * PIPSEC_DOI_ESP_ALGO;


//
// IPSEC DOI AH algorithms supported by SPD.
//

typedef enum _IPSEC_DOI_AH_ALGO {
    IPSEC_DOI_AH_NONE = 0,
    IPSEC_DOI_AH_MD5,
    IPSEC_DOI_AH_SHA1,
    IPSEC_DOI_AH_MAX
} IPSEC_DOI_AH_ALGO, * PIPSEC_DOI_AH_ALGO;


//
// Types of IPSEC Operations supported by SPD.
//

typedef enum _IPSEC_OPERATION {
    NONE = 0,
    AUTHENTICATION,
    ENCRYPTION,
    COMPRESSION,
    SA_DELETE
} IPSEC_OPERATION, * PIPSEC_OPERATION;


//
// HMAC authentication algorithm to use with IPSEC
// Encryption operation.
//

typedef enum _HMAC_AH_ALGO {
    HMAC_AH_NONE = 0,
    HMAC_AH_MD5,
    HMAC_AH_SHA1,
    HMAC_AH_MAX
} HMAC_AH_ALGO, * PHMAC_AH_ALGO;


//
// Key Lifetime structure.
//

typedef struct  _KEY_LIFETIME {
    ULONG uKeyExpirationTime;
    ULONG uKeyExpirationKBytes;
} KEY_LIFETIME, * PKEY_LIFETIME;


//
// Main mode policy structures.
//


//
// Main mode authentication algorithms supported by SPD.
//

typedef enum _MM_AUTH_ENUM {
    IKE_PRESHARED_KEY = 1,
    IKE_DSS_SIGNATURE,
    IKE_RSA_SIGNATURE,
    IKE_RSA_ENCRYPTION,
    IKE_SSPI
} MM_AUTH_ENUM, * PMM_AUTH_ENUM;


//
// Main mode authentication information structure.
//

typedef struct _IPSEC_MM_AUTH_INFO {
    MM_AUTH_ENUM AuthMethod;
    DWORD dwAuthInfoSize;
#ifdef __midl
    [size_is(dwAuthInfoSize)] LPBYTE pAuthInfo;
#else
    LPBYTE pAuthInfo;
#endif
} IPSEC_MM_AUTH_INFO, * PIPSEC_MM_AUTH_INFO;


//
// Main mode authentication methods.
//

typedef struct _MM_AUTH_METHODS {
    GUID gMMAuthID;
    DWORD dwFlags;
    DWORD dwNumAuthInfos;
#ifdef __midl
    [size_is(dwNumAuthInfos)] PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
#else
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
#endif
} MM_AUTH_METHODS, * PMM_AUTH_METHODS;


//
// Maximum number of main mode auth methods that can be enumerated
// by SPD at a time.
//

#define MAX_MMAUTH_ENUM_COUNT 1000


//
// Main mode algorithm structure.
//

typedef struct _IPSEC_MM_ALGO {
    ULONG uAlgoIdentifier;
    ULONG uAlgoKeyLen;
    ULONG uAlgoRounds;
} IPSEC_MM_ALGO, * PIPSEC_MM_ALGO;


//
// Main mode policy offer structure.
//

typedef struct _IPSEC_MM_OFFER {
    KEY_LIFETIME Lifetime;
    DWORD dwFlags;
    DWORD dwQuickModeLimit;
    DWORD dwDHGroup;
    IPSEC_MM_ALGO EncryptionAlgorithm;
    IPSEC_MM_ALGO HashingAlgorithm;
} IPSEC_MM_OFFER, * PIPSEC_MM_OFFER;


//
// Defines for DH groups.
//

#define DH_GROUP_1 0x00000001   // For Diffe Hellman group 1.
#define DH_GROUP_2 0x00000002   // For Diffe Hellman group 2.


//
// Default Main Mode key expiration time.
//

#define DEFAULT_MM_KEY_EXPIRATION_TIME 480*60 // 8 hours expressed in seconds.


//
// Maximum number of main mode policies that can be enumerated
// by SPD at a time.
//

#define MAX_MMPOLICY_ENUM_COUNT 10


//
// Main mode policy structure.
//

typedef struct  _IPSEC_MM_POLICY {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD dwFlags;
    ULONG uSoftSAExpirationTime;
    DWORD dwOfferCount;
#ifdef __midl
    [size_is(dwOfferCount)] PIPSEC_MM_OFFER pOffers;
#else
    PIPSEC_MM_OFFER pOffers;
#endif
} IPSEC_MM_POLICY, * PIPSEC_MM_POLICY;


//
// Quick mode policy structures.
//


typedef DWORD IPSEC_QM_SPI, * PIPSEC_QM_SPI;


//
// Quick mode algorithm structure.
//

typedef struct  _IPSEC_QM_ALGO {
    IPSEC_OPERATION Operation;
    ULONG uAlgoIdentifier;
    HMAC_AH_ALGO uSecAlgoIdentifier;
    ULONG uAlgoKeyLen;
    ULONG uSecAlgoKeyLen;
    ULONG uAlgoRounds;
    IPSEC_QM_SPI MySpi;
    IPSEC_QM_SPI PeerSpi;
} IPSEC_QM_ALGO, * PIPSEC_QM_ALGO;


//
// Maximum number of quick mode algorithms in
// a quick mode policy offer.
//

#define QM_MAX_ALGOS    2


//
// Quick mode policy offer structure.
//

typedef struct _IPSEC_QM_OFFER {
    KEY_LIFETIME Lifetime;
    DWORD dwFlags;
    BOOL bPFSRequired;
    DWORD dwPFSGroup;
    DWORD dwNumAlgos;
    IPSEC_QM_ALGO Algos[QM_MAX_ALGOS];
} IPSEC_QM_OFFER, * PIPSEC_QM_OFFER;


//
// Defines for PFS groups.
//

#define PFS_GROUP_NONE 0x00000000   // If PFS is not required.
#define PFS_GROUP_1    0x00000001   // For Diffe Hellman group 1 PFS.
#define PFS_GROUP_2    0x00000002   // For Diffe Hellman group 2 PFS.
#define PFS_GROUP_MM   0x10000000   // Use group negotiated in MM


//
// Default Quick Mode key expiration time.
//

#define DEFAULT_QM_KEY_EXPIRATION_TIME 60*60 // 1 hour expressed in seconds.


//
// Default Quick Mode key expiration kbytes.
//

#define DEFAULT_QM_KEY_EXPIRATION_KBYTES 100*1000 // 100 MB expressed in KB.


//
// Maximum number of quick mode policies that can be enumerated
// by SPD at a time.
//

#define MAX_QMPOLICY_ENUM_COUNT 10


//
// Quick mode policy structure.
//

typedef struct _IPSEC_QM_POLICY {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD dwFlags;
    DWORD dwOfferCount;
#ifdef __midl
    [size_is(dwOfferCount)] PIPSEC_QM_OFFER pOffers;
#else
    PIPSEC_QM_OFFER pOffers;
#endif
} IPSEC_QM_POLICY, * PIPSEC_QM_POLICY;


//
// IKE structures.
//

typedef struct _IKE_STATISTICS {
    DWORD dwActiveAcquire;
    DWORD dwActiveReceive;
    DWORD dwAcquireFail;
    DWORD dwReceiveFail;
    DWORD dwSendFail;
    DWORD dwAcquireHeapSize;
    DWORD dwReceiveHeapSize;
    DWORD dwNegotiationFailures;
    DWORD dwAuthenticationFailures;
    DWORD dwInvalidCookiesReceived;
    DWORD dwTotalAcquire;
    DWORD dwTotalGetSpi;
    DWORD dwTotalKeyAdd;
    DWORD dwTotalKeyUpdate;
    DWORD dwGetSpiFail;
    DWORD dwKeyAddFail;
    DWORD dwKeyUpdateFail;
    DWORD dwIsadbListSize;
    DWORD dwConnListSize;
    DWORD dwOakleyMainModes;
    DWORD dwOakleyQuickModes;
    DWORD dwSoftAssociations;
    DWORD dwInvalidPacketsReceived;
} IKE_STATISTICS, * PIKE_STATISTICS;


typedef LARGE_INTEGER IKE_COOKIE, * PIKE_COOKIE;


typedef struct _IKE_COOKIE_PAIR {
    IKE_COOKIE Initiator;
    IKE_COOKIE Responder;
} IKE_COOKIE_PAIR, * PIKE_COOKIE_PAIR;


typedef struct _IPSEC_BYTE_BLOB {
    DWORD dwSize;
#ifdef __midl
    [size_is(dwSize)] LPBYTE pBlob;
#else
    LPBYTE pBlob;
#endif
} IPSEC_BYTE_BLOB, * PIPSEC_BYTE_BLOB;


typedef struct _IPSEC_MM_SA {
    GUID gMMPolicyID;
    IPSEC_MM_OFFER SelectedMMOffer;
    MM_AUTH_ENUM MMAuthEnum;
    IKE_COOKIE_PAIR MMSpi;
    ADDR Me;
    IPSEC_BYTE_BLOB MyId;
    IPSEC_BYTE_BLOB MyCertificateChain;
    ADDR Peer;
    IPSEC_BYTE_BLOB PeerId;
    IPSEC_BYTE_BLOB PeerCertificateChain;
    DWORD dwFlags;
} IPSEC_MM_SA, * PIPSEC_MM_SA;


typedef enum _QM_FILTER_TYPE {
      QM_TRANSPORT_FILTER = 1,
      QM_TUNNEL_FILTER
} QM_FILTER_TYPE, * PQM_FILTER_TYPE;


typedef struct _IPSEC_QM_FILTER {
    QM_FILTER_TYPE QMFilterType;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    ADDR MyTunnelEndpt;
    ADDR PeerTunnelEndpt;
    DWORD dwFlags;
} IPSEC_QM_FILTER, * PIPSEC_QM_FILTER;


typedef struct _IPSEC_QM_SA {
    GUID gQMPolicyID;
    IPSEC_QM_OFFER SelectedQMOffer;
    GUID gQMFilterID;
    IPSEC_QM_FILTER IpsecQMFilter;
    IKE_COOKIE_PAIR MMSpi;
} IPSEC_QM_SA, * PIPSEC_QM_SA;


#define MAX_QMSA_ENUM_COUNT 1000


typedef enum _SA_FAIL_MODE {
    MAIN_MODE = 1,
    QUICK_MODE,
} SA_FAIL_MODE, * PSA_FAIL_MODE;


typedef enum _SA_FAIL_POINT {
    FAIL_POINT_ME = 1,
    FAIL_POINT_PEER,
} SA_FAIL_POINT, * PSA_FAIL_POINT;


typedef struct _SA_NEGOTIATION_STATUS_INFO {
    SA_FAIL_MODE FailMode;
    SA_FAIL_POINT FailPoint;
    DWORD dwError;
} SA_NEGOTIATION_STATUS_INFO, * PSA_NEGOTIATION_STATUS_INFO;


//
// IPSec structures.
//

typedef struct _IPSEC_STATISTICS {
    DWORD dwNumActiveAssociations;
    DWORD dwNumOffloadedSAs;
    DWORD dwNumPendingKeyOps;
    DWORD dwNumKeyAdditions;
    DWORD dwNumKeyDeletions;
    DWORD dwNumReKeys;
    DWORD dwNumActiveTunnels;
    DWORD dwNumBadSPIPackets;
    DWORD dwNumPacketsNotDecrypted;
    DWORD dwNumPacketsNotAuthenticated;
    DWORD dwNumPacketsWithReplayDetection;
    ULARGE_INTEGER uConfidentialBytesSent;
    ULARGE_INTEGER uConfidentialBytesReceived;
    ULARGE_INTEGER uAuthenticatedBytesSent;
    ULARGE_INTEGER uAuthenticatedBytesReceived;
    ULARGE_INTEGER uTransportBytesSent;
    ULARGE_INTEGER uTransportBytesReceived;
    ULARGE_INTEGER uBytesSentInTunnels;
    ULARGE_INTEGER uBytesReceivedInTunnels;
    ULARGE_INTEGER uOffloadedBytesSent;
    ULARGE_INTEGER uOffloadedBytesReceived;
} IPSEC_STATISTICS, * PIPSEC_STATISTICS;


typedef struct _IPSEC_INTERFACE_INFO {

    GUID gInterfaceID;
    DWORD dwIndex;
    LPWSTR pszInterfaceName;
    LPWSTR pszDeviceName;
    DWORD dwInterfaceType;
    ULONG uIpAddr;

} IPSEC_INTERFACE_INFO, * PIPSEC_INTERFACE_INFO;

//
// If dwInterfaceType is MIB_IF_TYPE_ETHERNET or MIB_IF_TYPE_FDDI
// or MIB_IF_TYPE_TOKENRING then its a LAN interface.
// If dwInterfaceType is MIB_IF_TYPE_PPP or MIB_IF_TYPE_SLIP
// then its a WAN/DIALUP interface.
//

#define MAX_INTERFACE_ENUM_COUNT 100


typedef struct _Record {
    DWORD SrcIpAddress;
    DWORD DesIpAddress;
}RECORD, *PRECORD;

//
// IPSEC SPD APIs.
//


DWORD
WINAPI
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    );


VOID
WINAPI
SPDApiBufferFree(
    LPVOID pBuffer
    );


DWORD
WINAPI
AddTransportFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phFilter
    );


DWORD
WINAPI
DeleteTransportFilter(
    HANDLE hFilter
    );


DWORD
WINAPI
EnumTransportFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTRANSPORT_FILTER * ppTransportFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetTransportFilter(
    HANDLE hFilter,
    PTRANSPORT_FILTER pTransportFilter
    );


DWORD
WINAPI
GetTransportFilter(
    HANDLE hFilter,
    PTRANSPORT_FILTER * ppTransportFilter
    );


DWORD
WINAPI
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy
    );


DWORD
WINAPI
DeleteQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    );


DWORD
WINAPI
EnumQMPolicies(
    LPWSTR pServerName,
    PIPSEC_QM_POLICY * ppQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy
    );


DWORD
WINAPI
GetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY * ppQMPolicy
    );


DWORD
WINAPI
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy
    );


DWORD
WINAPI
DeleteMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    );


DWORD
WINAPI
EnumMMPolicies(
    LPWSTR pServerName,
    PIPSEC_MM_POLICY * ppMMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy
    );


DWORD
WINAPI
GetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy
    );


DWORD
WINAPI
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    );


DWORD
WINAPI
DeleteMMFilter(
    HANDLE hMMFilter
    );


DWORD
WINAPI
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PMM_FILTER * ppMMFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER pMMFilter
    );


DWORD
WINAPI
GetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER * ppMMFilter
    );


DWORD
WINAPI
MatchMMFilter(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PMM_AUTH_METHODS * ppMatchedMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
MatchTransportFilter(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTxFilter,
    DWORD dwFlags,
    PTRANSPORT_FILTER * ppMatchedTxFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
GetQMPolicyByID(
    LPWSTR pServerName,
    GUID gQMPolicyID,
    PIPSEC_QM_POLICY * ppQMPolicy
    );


DWORD
WINAPI
GetMMPolicyByID(
    LPWSTR pServerName,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy
    );


DWORD
WINAPI
AddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
WINAPI
DeleteMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID
    );


DWORD
WINAPI
EnumMMAuthMethods(
    LPWSTR pServerName,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
WINAPI
GetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS * ppMMAuthMethods
    );


DWORD
IPSecInitiateIKENegotiation(
    LPWSTR pServerName,
    PIPSEC_QM_FILTER pQMFilter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    PHANDLE phNegotiation
    );


DWORD
IPSecQueryIKENegotiationStatus(
    HANDLE hNegotiation,
    PSA_NEGOTIATION_STATUS_INFO pNegotiationStatus
    );


DWORD
IPSecCloseIKENegotiationHandle(
    HANDLE hNegotiation
    );


DWORD
IPSecEnumMMSAs(
    LPWSTR pServerName,
    PIPSEC_MM_SA pMMTemplate,
    PIPSEC_MM_SA * ppMMSAs,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    );


DWORD
IPSecDeleteMMSAs(
    LPWSTR pServerName,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags
    );


DWORD
IPSecDeleteQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags
    );


DWORD
IPSecQueryIKEStatistics(
    LPWSTR pServerName,
    PIKE_STATISTICS pIKEStatistics
    );


DWORD
IPSecRegisterIKENotifyClient(
    LPWSTR pServerName,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    IPSEC_QM_SA QMTemplate,
    PHANDLE phNotifyHandle,
    DWORD dwFlags
    );

DWORD IPSecQueryNotifyData(
    HANDLE hNotifyHandle,
    PDWORD pdwNumEntries,
    PIPSEC_QM_SA *ppQMSAs,
    DWORD dwFlags
    );

DWORD IPSecCloseNotifyHandle(
    HANDLE hNotifyHandle
    );

DWORD
WINAPI
QueryIPSecStatistics(
    LPWSTR pServerName,
    PIPSEC_STATISTICS * ppIpsecStatistics
    );


DWORD
WINAPI
EnumQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pQMSATemplate,
    PIPSEC_QM_SA * ppQMSAs,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    );


DWORD
WINAPI
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phFilter
    );


DWORD
WINAPI
DeleteTunnelFilter(
    HANDLE hFilter
    );


DWORD
WINAPI
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTUNNEL_FILTER * ppTunnelFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetTunnelFilter(
    HANDLE hFilter,
    PTUNNEL_FILTER pTunnelFilter
    );


DWORD
WINAPI
GetTunnelFilter(
    HANDLE hFilter,
    PTUNNEL_FILTER * ppTunnelFilter
    );


DWORD
WINAPI
MatchTunnelFilter(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
OpenMMFilterHandle(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    );

DWORD
WINAPI
CloseMMFilterHandle(
    HANDLE hMMFilter
    );

DWORD
WINAPI
OpenTransportFilterHandle(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phTxFilter
    );

DWORD
WINAPI
CloseTransportFilterHandle(
    HANDLE hTxFilter
    );

DWORD
WINAPI
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phTnFilter
    );

DWORD
WINAPI
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    );


DWORD
WINAPI
EnumIPSecInterfaces(
    LPWSTR pServerName,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    );

DWORD
WINAPI
IPSecAddSAs(
    LPWSTR pServerName,
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE *hLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    DWORD dwFlags
    );


#ifdef __cplusplus
}
#endif


#endif // _WINIPSEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\ipsecprov\xmlreader.h ===
//////////////////////////////////////////////////////////////////////
// XMLReader.h : Declaration of CXMLContent
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original Create Date: 5/25/2001
// Original Author: shawnwu
//////////////////////////////////////////////////////////////////////

#pragma once

#include "globals.h"

/*

Class description
    
    Naming: 

        CXMLContent stands for XML Content handler.
    
    Base class: 
        
        (1) CComObjectRootEx for threading model and IUnknown.

        (2) ISAXContentHandler which implements handler.
    
    Purpose of class:

        (1) To support reading of XML file content handler. This handles events sent
            by MSXML parser.

    Design:

        (1) Just a typical COM object.

    Use:

        (1) Just call the static function.


*/

#include <msxml2.h>


class ATL_NO_VTABLE CXMLContent :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISAXContentHandler  
{
protected:
    CXMLContent();
    virtual ~CXMLContent();

public:

BEGIN_COM_MAP(CXMLContent)
    COM_INTERFACE_ENTRY(ISAXContentHandler)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CXMLContent )
DECLARE_REGISTRY_RESOURCEID(IDR_NETSECPROV)

public:

    //
    // ISAXContentHandler
    //

    STDMETHOD(startElement) ( 
        IN const wchar_t    * pwchNamespaceUri,
        IN int                cchNamespaceUri,
        IN const wchar_t    * pwchLocalName,
        IN int                cchLocalName,
        IN const wchar_t    * pwchQName,
        IN int                cchQName,
        IN ISAXAttributes   * pAttributes
        );
        
    STDMETHOD(endElement) ( 
        IN const wchar_t  * pwchNamespaceUri,
        IN int              cchNamespaceUri,
        IN const wchar_t  * pwchLocalName,
        IN int              cchLocalName,
        IN const wchar_t  * pwchQName,
        IN int              cchQName
        );

    STDMETHOD(startDocument) ();


    STDMETHOD(endDocument) ();

    STDMETHOD(putDocumentLocator) ( 
        IN ISAXLocator *pLocator
        );
        

    STDMETHOD(startPrefixMapping) ( 
        IN const wchar_t  * pwchPrefix,
        IN int              cchPrefix,
        IN const wchar_t  * pwchUri,
        IN int              cchUri
        );
        
    STDMETHOD(endPrefixMapping) ( 
        IN const wchar_t  * pwchPrefix,
        IN int              cchPrefix
        );

    STDMETHOD(characters) ( 
        IN const wchar_t  * pwchChars,
        IN int              cchChars
        );
        
    STDMETHOD(ignorableWhitespace) ( 
        IN const wchar_t * pwchChars,
        IN int              cchChars
        );
        
    STDMETHOD(processingInstruction) ( 
        IN const wchar_t  * pwchTarget,
        IN int              cchTarget,
        IN const wchar_t  * pwchData,
        IN int              cchData
        );
        
    STDMETHOD(skippedEntity) ( 
        IN const wchar_t  * pwchName,
        IN int              cchName
        );

    //
    // other public functions for our handler
    //

    void SetOutputFile (
        IN LPCWSTR pszFileName
        )
    {
        m_bstrOutputFile = pszFileName;
    }

    void SetSection (
        IN LPCWSTR pszSecArea,
        IN LPCWSTR pszElement,
        IN bool    bOneAreaOnly
        );

    bool ParseComplete()const
    {
        return m_bFinished;
    }

private:

    bool GetAttributeValue (
        IN  ISAXAttributes * pAttributes,
        IN  LPCWSTR          pszAttrName,
        OUT LPWSTR         * ppszAttrVal
        );

    bool GetAttributeValue (
        IN  ISAXAttributes * pAttributes,
        IN  int              iIndex,
        OUT LPWSTR         * ppszAttrName,
        OUT LPWSTR         * ppszAttrVal
        );

    void WriteContent (
        IN LPCWSTR  pszName,
        IN LPCWSTR  pszValue
        );

    CComBSTR m_bstrOutputFile;

    CComBSTR m_bstrSecArea;

    CComBSTR m_bstrElement;

    HANDLE  m_hOutFile;

    DWORD   m_dwTotalElements;

    bool    m_bFinished;

    bool    m_bSingleArea;

    bool    m_bInSection;

    bool    m_bInElement;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\common.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    common.h

Abstract:

    This module accumulates common headers for
    SSR Knowledge Base processing.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/

#ifndef _KBCOMMON_H_
#define _KBCOMMON_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <comdef.h>
#include <msxml2.h>
#include <winsvc.h>
#include <atlbase.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( kbproc )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( kbproc ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\custom.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    custom.cpp

Abstract:

    This module implements routines to evaluate
    custom mode values by loading the helper dll.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/

#include "stdafx.h"
#include "kbproc.h"
#include "process.h"

DWORD
process::SsrpEvaluateCustomFunction(
    IN  PWSTR   pszMachineName,
    IN  BSTR    bstrDLLName, 
    IN  BSTR    bstrFunctionName, 
    OUT  BOOL    *pbSelect
    )
/*++

Routine Description:

    Routine called to evaluate custom mode values per role or service

Arguments:

    pszMachineName  -   name of machine to evaluate custom function on
    
    bstrDLLName -   name of DLL to load
    
    bstrFunctionName    -   name of function to evaluate
    
    pbSelect -   to emit the boolean evaluation result
    
Return:

    Win32 error code

++*/

{
    DWORD rc = ERROR_SUCCESS;
    HINSTANCE hDll = NULL;
    typedef DWORD (*PFN_SSR_CUSTOM_FUNCTION)(PWSTR, BOOL *);
    PFN_SSR_CUSTOM_FUNCTION pfnSsrpCustomFunction = NULL;
    PCHAR   pStr = NULL;
    DWORD   dwBytes = 0;
    
    if (pbSelect == NULL ) {
        rc = ERROR_INVALID_PARAMETER;
        goto ExitHandler;
    }
    
    *pbSelect = FALSE;

    hDll = LoadLibrary(bstrDLLName);

    if ( hDll == NULL ) {
        rc = GetLastError();
        goto ExitHandler;
    }

    //
    // convert WCHAR into ASCII
    //

    dwBytes = WideCharToMultiByte(CP_THREAD_ACP,
                                      0,
                                      bstrFunctionName,
                                      wcslen(bstrFunctionName),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL
                                      );

    if (dwBytes <= 0) {
        rc = ERROR_INVALID_PARAMETER;
        goto ExitHandler;
    }

    pStr = (PCHAR)LocalAlloc(LPTR, dwBytes+1);

    if ( pStr == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;
    }

    dwBytes = WideCharToMultiByte(CP_THREAD_ACP,
                                  0,
                                  bstrFunctionName,
                                  wcslen(bstrFunctionName),
                                  pStr,
                                  dwBytes,
                                  NULL,
                                  NULL
                                 );
        
    pfnSsrpCustomFunction = 
        (PFN_SSR_CUSTOM_FUNCTION)GetProcAddress(
            hDll,                                                       
            pStr);
        
    if ( pfnSsrpCustomFunction == NULL ) {

        rc = ERROR_PROC_NOT_FOUND;
        goto ExitHandler;

    }

    rc = (*pfnSsrpCustomFunction )( pszMachineName, pbSelect );

ExitHandler:

    if (hDll) {
        FreeLibrary(hDll);
    }

    if (pStr) {
        LocalFree(pStr);
    }

    if (m_bDbg)
        wprintf(L" Error %i when processing function %s in dll %s \n",rc, bstrFunctionName, bstrDLLName); 

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\kbproc.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    kbproc.cpp

Abstract:

    Implementation of DLL Exports.
    
    Note: Proxy/Stub Information
    To build a separate proxy/stub DLL, 
    run nmake -f kbprocps.mk in the project directory.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

    DLL regserver etc.

Revision History:

    Created - Oct 2001

--*/




#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "kbproc.h"

#include "kbproc_i.c"
#include "process.h"


#include <windows.h>
#include <tchar.h>
#include <comdef.h>
#include <msxml2.h>
#include <winsvc.h>
#include <atlbase.h>
#include <atlcom.h>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_process, process)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_KBPROCLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}

HRESULT 
process::SsrpCprocess(
    BSTR pszKBDir, 
    BSTR pszUIFile, 
    BSTR pszKbMode, 
    BSTR pszLogFile,
    BSTR pszMachineName,
    VARIANT vtFeedback)
/*++

Routine Description:

    Main routine called by COM KB interface

Arguments:

    pszKBDir        -   KBs dir
    
    pszUIFile       -   UI XML file
    
    pszKbMode       -   KB Mode
    
    pszLogFile      -   Log file name
    
    pszMachineName  -   Machine name to query SCM info (optional)
    
Return:

    HRESULT error code
    
--*/
{
        
    HRESULT hr;
    DWORD   rc;

    CComPtr<IXMLDOMDocument> pXMLMergedKBsDoc = NULL;
    CComPtr<IXMLDOMElement>  pXMLMergedKBsDocElemRoot = NULL;

    
    VARIANT_BOOL vtSuccess;
    CComVariant OutFile(pszUIFile);
    CComVariant InFile(pszKBDir);
    CComVariant Type(NODE_ELEMENT);

    m_bDbg = FALSE;

    if (pszMachineName && pszMachineName[0] == L'\0') {
        pszMachineName = NULL;
    }
    
    hr = CoInitialize(NULL); 

    if (FAILED(hr)) {

        return hr;
            
    }
    
    CComPtr <ISsrFeedbackSink> pISink = NULL;

    if (!(vtFeedback.vt == VT_UNKNOWN || 
        vtFeedback.vt == VT_DISPATCH)) {

        hr = E_INVALIDARG;
    }

    if (vtFeedback.punkVal != NULL ) {

        hr = vtFeedback.punkVal->QueryInterface(IID_ISsrFeedbackSink, (void **) &pISink);

        if (FAILED(hr)) {

            return hr;
            
        }
    }
    
    VARIANT var;
    var.vt = VT_UI4;
    var.ulVal = 120;


    if (pISink) {
        pISink->OnNotify(SSR_FB_TOTAL_STEPS, var, L"Starting...");
    }
    
    //
    // instantiate the logging object object to process the KB
    //

    hr = CoCreateInstance(CLSID_SsrLog, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_ISsrLog, 
                          (void**)&m_pSsrLogger);

    if (FAILED(hr) || m_pSsrLogger == NULL ) {

        return hr;

    }
    
    hr = m_pSsrLogger->put_LogFile(pszLogFile);

    if (FAILED(hr)) {

        SsrpLogError(L"Logger failed create log file");
        goto ExitHandler;
    }
    
    var.ulVal = 10;

    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }
    
    //
    // instantiate an empty DOM document object to store the merged KB
    //
    
    hr = CoCreateInstance(CLSID_DOMDocument, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IXMLDOMDocument, 
                          (void**)&pXMLMergedKBsDoc);
    
    if (FAILED(hr) || pXMLMergedKBsDoc == NULL ) {

        SsrpLogError(L"COM failed to create a DOM instance");
        goto ExitHandler;
    }
        
    hr =  pXMLMergedKBsDoc->get_parseError(&m_pXMLError);
    
    if (FAILED(hr) || m_pXMLError == NULL ) {

        SsrpLogError(L"Unable to get the XML parse error interface");
        goto ExitHandler;
    }
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    hr = pXMLMergedKBsDoc->put_validateOnParse(VARIANT_TRUE);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pXMLMergedKBsDoc->put_async(VARIANT_FALSE);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }


    rc = SsrpQueryInstalledServicesInfo(pszMachineName);

    if (rc != ERROR_SUCCESS ) {

        SsrpLogWin32Error(rc);
        goto ExitHandler;
    }
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    //
    // merge Extensions/Custom/Root KBs
    //

    hr = SsrpProcessKBsMerge(pszKBDir, 
                             pszMachineName, 
                             &pXMLMergedKBsDocElemRoot, 
                             &pXMLMergedKBsDoc);

    if (FAILED(hr) || pXMLMergedKBsDocElemRoot == NULL) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }
    
    //
    // delete all comments
    //

    hr = SsrpDeleteComments(pXMLMergedKBsDocElemRoot);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    //
    // create <Preprocessor> section
    //
    
    hr = SsrpCreatePreprocessorSection(pXMLMergedKBsDocElemRoot, pXMLMergedKBsDoc, pszKbMode, pszKBDir);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }
    
    //
    // process every Role
    //

    hr = SsrpProcessRolesOrTasks(pszMachineName,
                                 pXMLMergedKBsDocElemRoot, 
                                 pXMLMergedKBsDoc, 
                                 pszKbMode,
                                 TRUE);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    //
    // process every Task
    //

    hr = SsrpProcessRolesOrTasks(pszMachineName,
                                 pXMLMergedKBsDocElemRoot, 
                                 pXMLMergedKBsDoc, 
                                 pszKbMode,
                                 FALSE);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    //
    // write out all services on system but not in KB in the Unknown role
    //

    hr = SsrpAddUnknownSection(pXMLMergedKBsDocElemRoot, pXMLMergedKBsDoc);
    

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    hr = SsrpAddUnknownServicesInfoToServiceLoc(pXMLMergedKBsDocElemRoot, pXMLMergedKBsDoc);
    
    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    //
    // write out all services on system with startup mode information
    //
    
    hr = SsrpAddServiceStartup(pXMLMergedKBsDocElemRoot, pXMLMergedKBsDoc);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Processing...");
    }

    hr = SsrpAddUnknownServicestoServices(pXMLMergedKBsDocElemRoot, pXMLMergedKBsDoc);
    
    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    
    hr = pXMLMergedKBsDoc->save(OutFile);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
    }

ExitHandler:
    
    if (pISink) {
        pISink->OnNotify(SSR_FB_STEPS_JUST_DONE, var, L"Stopping...");
    }
    
    CoUninitialize(); 

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\process.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    process.cpp

Abstract:

    Implementation of processor interface.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

    Processor interface .

Revision History:

    Created - Oct 2001

--*/


#include "stdafx.h"
#include "kbproc.h"
#include "process.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP process::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_Iprocess,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


STDMETHODIMP process::preprocess(BSTR pszKbFile, 
                                 BSTR pszUIFile, 
                                 BSTR pszKbMode, 
                                 BSTR pszLogFile, 
                                 BSTR pszMachineName,
                                 VARIANT vtFeedback)
{
    HRESULT hr = S_OK;

	if (pszKbFile == NULL ||
		pszUIFile == NULL ||
		pszKbMode == NULL ||
		pszLogFile == NULL)

		return E_INVALIDARG;

    hr = SsrpCprocess(pszKbFile, 
                      pszUIFile, 
                      pszKbMode, 
                      pszLogFile,
                      pszMachineName,
                      vtFeedback
                      );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\process.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    process.h

Abstract:

    Definition of the process class

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/


#if !defined(AFX_PROCESS_H__139D0BA5_19A7_4AA2_AE2C_E18A5FFAAA0F__INCLUDED_)
#define AFX_PROCESS_H__139D0BA5_19A7_4AA2_AE2C_E18A5FFAAA0F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "..\te\obj\i386\ssrte.h"
#include <windows.h>
#include <comdef.h>
#include <atlbase.h>


/////////////////////////////////////////////////////////////////////////////
// process

class process : 
	public IDispatchImpl<Iprocess, &IID_Iprocess, &LIBID_KBPROCLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<process,&CLSID_process>
{
public:
	process() {
        m_bDbg = FALSE;
        m_pSsrLogger = NULL;
        m_pXMLError = NULL;
        m_hScm = NULL;
        m_dwNumServices = 0;
        m_bArrServiceInKB = NULL;
        m_pInstalledServicesInfo = NULL;
    }

    ~process() {
        SsrpCleanup();
    }

BEGIN_COM_MAP(process)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(Iprocess)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(process) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_process)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
                                         
// Iprocess
public:

    //
    // data values used across most processor methods
    //

    BOOL    m_bDbg;
    CComPtr <ISsrLog> m_pSsrLogger;
    CComPtr <IXMLDOMParseError> m_pXMLError;

    SC_HANDLE   m_hScm;
    DWORD       m_dwNumServices;
    DWORD       *m_bArrServiceInKB;
    LPENUM_SERVICE_STATUS_PROCESS   m_pInstalledServicesInfo;

    //
    // processor methods
    //

	STDMETHOD(preprocess)   (BSTR pszKbFile, 
                             BSTR pszUIFile, 
                             BSTR pszKbMode, 
                             BSTR pszLogFile,
                             BSTR pszMachineName,
                             VARIANT vtFeedback);

    HRESULT SsrpCprocess(IN  BSTR pszKbDir, 
                         IN  BSTR pszUIFile, 
                         IN  BSTR pszKbMode, 
                         IN  BSTR pszLogFile, 
                         IN  BSTR pszMachineName,
                         IN  VARIANT    vtFeedback);
    //
    // utility methods
    //

    VOID    SsrpCleanup();

    VOID    SsrpLogParseError(IN  HRESULT hr);

    VOID    SsrpLogWin32Error(IN  DWORD   rc);

    VOID    SsrpLogError(IN  PWSTR   pszError);

    BOOL    SsrpIsServiceInstalled(IN  BSTR   bstrService);

    VOID    SsrpConvertBstrToPwstr(IN OUT  BSTR   bstrString);

    HRESULT SsrpDeleteChildren( IN  CComPtr <IXMLDOMNode> pParent);

    HRESULT SsrpDeleteComments(IN  CComPtr <IXMLDOMElement> pParent);

    DWORD   SsrpQueryInstalledServicesInfo(IN  PWSTR   pszMachineName);

    DWORD   SsrpQueryServiceDescription(IN  PWSTR   pszServiceName,
                                        OUT LPSERVICE_DESCRIPTION *ppServiceDescription);

    PWSTR   SsrpQueryServiceDisplayName(IN  BSTR   bstrService);

    int     SsrpICompareBstrPwstr(IN  BSTR   bstrString, IN  PWSTR  pszString);

    HRESULT SsrpCloneAllChildren(IN  CComPtr <IXMLDOMDocument> pXMLDocSource, 
                                 IN  CComPtr <IXMLDOMDocument> pXMLDocDestination);

    HRESULT SsrpAddWhiteSpace(IN  CComPtr <IXMLDOMDocument> pXMLDoc, 
                              IN  CComPtr <IXMLDOMNode> pXMLParent, 
                              IN  BSTR    bstrWhiteSpace);


    HRESULT SsrpGetRemoteOSVersionInfo(IN  PWSTR   pszMachineName,
                                       OUT OSVERSIONINFOEX *posVersionInfo);
    
    //
    // methods to process roles, tasks and services
    //

    HRESULT SsrpCreatePreprocessorSection(IN  CComPtr<IXMLDOMElement> pXMLDocElemRoot, 
                             IN  CComPtr<IXMLDOMDocument> pXMLDocIn,
                             IN  PWSTR pszKbMode,
                                          IN  PWSTR pszKbFile);

    
    HRESULT SsrpProcessRolesOrTasks(IN  PWSTR   pszMachineName,
                                    IN  CComPtr<IXMLDOMElement> pXMLDocElemRoot,                              
                                    IN  CComPtr<IXMLDOMDocument> pXMLDoc,                              
                                    IN  PWSTR pszKbMode,
                                    IN  BOOL    bRole);


    HRESULT SsrpProcessTasks(IN  CComPtr<IXMLDOMElement> pXMLDocElemRoot,        
                             IN  CComPtr<IXMLDOMDocument> pXMLDoc,    
                             IN  PWSTR   pszKbMode
                             );
    
    HRESULT SsrpProcessService( IN  CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
                                IN  CComPtr <IXMLDOMNode> pXMLServiceNode, 
                                IN  PWSTR   pszMode, 
                                OUT BOOL    *pbRoleIsSatisfiable, 
                                OUT BOOL    *pbSomeRequiredServiceDisabled);
    
    HRESULT SsrpAddExtraServices( IN  CComPtr <IXMLDOMDocument> pXMLDoc, 
                                  IN  CComPtr <IXMLDOMNode> pRolesNode);


    HRESULT SsrpAddOtherRole( IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
                              IN CComPtr <IXMLDOMDocument> pXMLDoc);

    HRESULT SsrpAddUnknownSection( IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
                                   IN CComPtr <IXMLDOMDocument> pXMLDoc);

    HRESULT SsrpAddServiceStartup(IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
                                  IN CComPtr <IXMLDOMDocument> pXMLDoc
                                  );

    HRESULT SsrpAddUnknownServicesInfoToServiceLoc(IN  CComPtr <IXMLDOMElement> pElementRoot,
                                                   IN  CComPtr <IXMLDOMDocument> pXMLDoc
                                                   );


    HRESULT SsrpAddUnknownServicestoServices(IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
                                             IN CComPtr <IXMLDOMDocument> pXMLDoc
                                             );

    //
    // extension KBs merge methods
    //


    HRESULT SsrpProcessKBsMerge(IN  PWSTR   pszKBDir,
                                IN  PWSTR   pszMachineName,
                                OUT IXMLDOMElement **ppElementRoot,
                                OUT IXMLDOMDocument  **ppXMLDoc
                                );

    HRESULT SsrpMergeDOMTrees(OUT  IXMLDOMElement **ppMergedKBElementRoot,
                              OUT  IXMLDOMDocument  **ppMergedKBXMLDoc,
                              IN  WCHAR    *szXMLFileName
                              );

    HRESULT SsrpMergeAccordingToPrecedence(IN PWSTR   pszKBType,
                                           IN PWSTR   pszKBDir,
                                           OUT IXMLDOMElement **ppElementRoot,
                                           OUT IXMLDOMDocument  **ppXMLDoc,
                                           IN  IXMLDOMNode *pKB
                                           );

    HRESULT SsrpAppendOrReplaceMergeableEntities(IN  PWSTR   pszFullyQualifiedEntityName,
                                                 IN  IXMLDOMElement *pMergedKBElementRoot, 
                                                 IN  IXMLDOMDocument *pMergedKBXMLDoc, 
                                                 IN  IXMLDOMDocument *pCurrentKBDoc, 
                                                 IN  IXMLDOMElement *pCurrentKBElemRoot,
                                                 IN  PWSTR   pszKBName
                                                 );

    HRESULT SsrpOverwriteServiceLocalizationFromSystem(IN  IXMLDOMElement *pMergedKBElementRoot, 
                                                       IN  IXMLDOMDocument *pMergedKBXMLDoc
                                                       );


    
    //
    // methods to evaluate role/service conditionals
    //
    
    DWORD   SsrpEvaluateCustomFunction(IN  PWSTR   pszMachineName,
                                       IN  BSTR    bstrDLLName, 
                                       IN  BSTR    bstrFunctionName, 
                                       OUT BOOL    *pbSelect);
    
    
    HRESULT SsrpCheckIfOptionalService(IN  CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
                                       IN  BSTR    bstrServiceName, 
                                       IN  BOOL    *pbOptional);

    DWORD   SsrpQueryServiceStartupType(IN  PWSTR   pszServiceName, 
                                        OUT BYTE   *pbyStartupType);
};

#endif // !defined(AFX_PROCESS_H__139D0BA5_19A7_4AA2_AE2C_E18A5FFAAA0F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\resource.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Used by kbproc.rc

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/


#define IDS_PROJNAME                    100
#define IDS_PROCESS_DESC                101
#define IDR_process                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\merge.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    merge.cpp

Abstract:

    This module implements routines for service
    specific SSR Knowledge Base merging via KBreg.xml.

Author:

    Vishnu Patankar (VishnuP) - Jun 2002

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Jun 2002

--*/

#include "stdafx.h"
#include "kbproc.h"
#include "process.h"
#include <Wbemcli.h>

HRESULT
process::SsrpProcessKBsMerge(
    IN  PWSTR   pszKBDir,
    IN  PWSTR   pszMachineName,
    OUT IXMLDOMElement **ppElementRoot,
    OUT IXMLDOMDocument  **ppXMLDoc
    )
/*++

Routine Description:

    Routine called to merge KBs

Arguments:

    pszKBDir    -   the root directory from which to get the KBs

    pszMachineName  -   name of the machine to preprocess

    ppElementRoot    -   the root element pointer to be filled in
    
    ppXMLDoc -   document pointer to be filled in
    
Return:

    HRESULT error code

++*/
{

    //
    // load the KB registration document
    //

    WCHAR   szKBregs[MAX_PATH + 50];
    WCHAR   szWindir[MAX_PATH + 50];
    WCHAR   szMergedKB[MAX_PATH + 50];
    DWORD   rc = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    CComPtr <IXMLDOMDocument> pXMLKBDoc;
    OSVERSIONINFOEX osVersionInfo;
    CComPtr <IXMLDOMNodeList> pKBList;
    CComPtr <IXMLDOMNode> pKB;
    CComPtr <IXMLDOMElement> pXMLDocElemRoot;
    BOOL    bOsKbMatch = FALSE;


    if ( !GetSystemWindowsDirectory(szWindir, MAX_PATH + 1) ) {
        SsrpLogError(L"Error GetSystemWindowsDirectory() \n");
        SsrpLogWin32Error(GetLastError());
        return E_INVALIDARG;
    }
    
    wcscpy(szMergedKB, szWindir);
    wcscat(szMergedKB, L"\\security\\ssr\\kbs\\MergedRawKB.xml");
    
    CComVariant MergedKB(szMergedKB);

    wcscpy(szKBregs, pszKBDir);
    wcscat(szKBregs, L"KBreg.xml");
    

    CComVariant KBregsFile(szKBregs);
    
    hr = CoCreateInstance(CLSID_DOMDocument, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IXMLDOMDocument, 
                          (void**)&pXMLKBDoc);
    
    if (FAILED(hr) || pXMLKBDoc == NULL ) {

        SsrpLogError(L"COM failed to create a DOM instance");
        goto ExitHandler;
    }

    VARIANT_BOOL vtSuccess;

    hr = pXMLKBDoc->load(KBregsFile, &vtSuccess);

    if (FAILED(hr) || vtSuccess == VARIANT_FALSE ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    //
    // get the root element
    //
    
    hr = pXMLKBDoc->get_documentElement(&pXMLDocElemRoot);

    if (FAILED(hr) || pXMLDocElemRoot == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    if (NULL == pszMachineName) {

        //
        // local machine
        //
        
        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);

        if  (!GetVersionEx((LPOSVERSIONINFOW)&osVersionInfo)){
            SsrpLogError(L"Error GetVersionEx \n");
            SsrpLogWin32Error(GetLastError());
            goto ExitHandler;
        }
    }

    else {

        //
        // remote machine - use WMI
        //

        hr = SsrpGetRemoteOSVersionInfo(pszMachineName, 
                                        &osVersionInfo);

        if (FAILED(hr)) {

            SsrpLogError(L"SsrpGetRemoteOSVersionInfo failed");
            goto ExitHandler;
        }
    
    }

    hr = pXMLDocElemRoot->selectNodes(L"KBs", &pKBList);

    if (FAILED(hr) || pKBList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pKBList->nextNode(&pKB);

    if (FAILED(hr) || pKB == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }


    while (pKB) {
        
        CComBSTR    bstrText;
        CComPtr <IXMLDOMNode> pName;
        CComPtr <IXMLDOMNode> pXDNodeServiceStartup;
        CComPtr <IXMLDOMNamedNodeMap> pXMLAttribNode;
        CComPtr <IXMLDOMNode> pXMLMajorInfo;
        CComPtr <IXMLDOMNode> pXMLMinorInfo;
         
        hr = pKB->get_attributes( &pXMLAttribNode );

        if (FAILED(hr) || pXMLAttribNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pXMLAttribNode->getNamedItem(L"OSVersionMajorInfo", &pXMLMajorInfo );
                  
        if (FAILED(hr) || pXMLMajorInfo == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pXMLAttribNode->getNamedItem(L"OSVersionMinorInfo", &pXMLMinorInfo );

        if (FAILED(hr) || pXMLMinorInfo == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        CComBSTR   bstrValue;
        DWORD   dwMajor;
        DWORD   dwMinor;

        hr = pXMLMajorInfo->get_text(&bstrValue);

        if (FAILED(hr) || !bstrValue ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        dwMajor = _wtoi(bstrValue);
        
        hr = pXMLMinorInfo->get_text(&bstrValue);

        if (FAILED(hr) || !bstrValue ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        dwMinor = _wtoi(bstrValue);


        if (osVersionInfo.dwMajorVersion == dwMajor && 
            osVersionInfo.dwMinorVersion == dwMinor) {


            //
            // got the required KB node
            //

            bOsKbMatch = TRUE;

            break;
        }

        hr = pKBList->nextNode(&pKB);
        
        if (FAILED(hr) || pKB == NULL ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }

    if (bOsKbMatch == FALSE) {
        SsrpLogError(L"Failed to map OSversion to KB information in registration");
        hr = E_INVALIDARG;
        goto ExitHandler;

    }

    //
    // merge according to precedence
    //


    hr = SsrpMergeAccordingToPrecedence(L"Extensions", 
                                        pszKBDir, 
                                        ppElementRoot, 
                                        ppXMLDoc, 
                                        pKB);


    if (FAILED(hr)) {

        SsrpLogError(L"Failed to merge Extension KB");
        goto ExitHandler;
    }
    
    hr = SsrpMergeAccordingToPrecedence(L"Root", 
                                        pszKBDir, 
                                        ppElementRoot, 
                                        ppXMLDoc, 
                                        pKB);

    
    if (FAILED(hr)) {

        SsrpLogError(L"Failed to merge Root KB");
        goto ExitHandler;
    }
    
    hr = SsrpMergeAccordingToPrecedence(L"Custom", 
                                        pszKBDir, 
                                        ppElementRoot, 
                                        ppXMLDoc, 
                                        pKB);
    
    if (FAILED(hr)) {

        SsrpLogError(L"Failed to merge Custom KB");
        goto ExitHandler;
    }

    hr = SsrpOverwriteServiceLocalizationFromSystem(*ppElementRoot, *ppXMLDoc);

    if (FAILED(hr)) {

        SsrpLogError(L"Failed to merge Custom KB");
        goto ExitHandler;
    }

    hr = (*ppXMLDoc)->save(MergedKB);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
    }
    
ExitHandler:

        return hr;

}

HRESULT
process::SsrpGetRemoteOSVersionInfo(
    IN  PWSTR   pszMachineName, 
    OUT OSVERSIONINFOEX *posVersionInfo
    )
/*++

Routine Description:

    Routine called to get version info from remote machine via WMI

Arguments:

    pszMachineName   -   remote machine name
    
    posVersionInfo    -   os version info to fill via WMI queries
    
Return:

    HRESULT error code

++*/
{
    HRESULT             hr = S_OK;
    
    CComPtr <IWbemLocator>  pWbemLocator = NULL;
    CComPtr <IWbemServices> pWbemServices = NULL;
    CComPtr <IWbemClassObject>  pWbemOsObjectInstance = NULL;
    CComPtr <IEnumWbemClassObject>  pWbemEnumObject = NULL;
    CComBSTR    bstrMachineAndNamespace; 
    ULONG  nReturned = 0;
    
    bstrMachineAndNamespace = pszMachineName;
    bstrMachineAndNamespace += L"\\root\\cimv2";

    hr = CoCreateInstance(
                         CLSID_WbemLocator, 
                         0, 
                         CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator, 
                         (LPVOID *) &pWbemLocator
                         );

    if (FAILED(hr) || pWbemLocator == NULL ) {

        SsrpLogError(L"Error getting instance of CLSID_WbemLocator \n");
        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pWbemLocator->ConnectServer(
                                bstrMachineAndNamespace,
                                NULL, 
                                NULL, 
                                NULL, 
                                0L,
                                NULL,
                                NULL,
                                &pWbemServices
                                );

    if (FAILED(hr) || pWbemServices == NULL ) {

        SsrpLogError(L"Error ConnectServer \n");
        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = CoSetProxyBlanket(
                          pWbemServices,
                          RPC_C_AUTHN_WINNT,
                          RPC_C_AUTHZ_NONE,
                          NULL,
                          RPC_C_AUTHN_LEVEL_PKT,
                          RPC_C_IMP_LEVEL_IMPERSONATE,
                          NULL, 
                          EOAC_NONE
                          );

    if (FAILED(hr)) {

        SsrpLogError(L"Error CoSetProxyBlanket \n");
        SsrpLogParseError(hr);
        goto ExitHandler;
    }
        
    hr = pWbemServices->ExecQuery(CComBSTR(L"WQL"),
                                 CComBSTR(L"SELECT * FROM Win32_OperatingSystem"),
                                 WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                 NULL,
                                 &pWbemEnumObject);

    if (FAILED(hr) || pWbemEnumObject == NULL) {

        SsrpLogError(L"Error SELECT * FROM Win32_OperatingSystem\n");
        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pWbemEnumObject->Next(WBEM_INFINITE, 1, &pWbemOsObjectInstance, &nReturned);

    if (FAILED(hr) || pWbemOsObjectInstance == NULL) {

        SsrpLogError(L"Error enumerating\n");
        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    VARIANT vVersion;

    VariantInit(&vVersion); 

    hr = pWbemOsObjectInstance->Get(CComBSTR(L"Version"), 
                            0,
                            &vVersion, 
                            NULL, 
                            NULL);


    if (FAILED(hr)) {

        SsrpLogError(L"Error getting Version property \n");
        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    if (V_VT(&vVersion) == VT_NULL) {

        SsrpLogError(L"Error Version property is null\n");
        goto ExitHandler;

    }

    //
    // extract the version information into DWORDs since
    // the return type of this property is BSTR variant
    // of the form "5.1.2195"
    //

    BSTR  bstrVersion = V_BSTR(&vVersion);
    WCHAR szVersion[5];
    szVersion[0] = L'\0';

    PWSTR pszDot = wcsstr(bstrVersion, L".");

    if (NULL == pszDot) {
        SsrpLogError(L"Version property has no '.' \n");
        hr = E_INVALIDARG;
        goto ExitHandler;

    }

    wcsncpy(szVersion, bstrVersion, 1);

    posVersionInfo->dwMajorVersion = (DWORD)_wtoi(szVersion);

    wcsncpy(szVersion, pszDot+1, 1);

    posVersionInfo->dwMinorVersion = (DWORD)_wtoi(szVersion);

ExitHandler:
    
    if (V_VT(&vVersion) != VT_NULL) {
        VariantClear( &vVersion );
    }

    return hr;
}


HRESULT
process::SsrpMergeAccordingToPrecedence(
    IN  PWSTR   pszKBType,
    IN  PWSTR   pszKBDir,
    OUT IXMLDOMElement **ppElementRoot,
    OUT IXMLDOMDocument  **ppXMLDoc,
    IN  IXMLDOMNode *pKB
    )
/*++

Routine Description:

    Routine called to load and merge XML KBs

Arguments:

    pszKBType   -   type of KB - i.e. Custom/Extension/Root
    
    pszKBDir    -   path to KB directory
    
    ppElementRoot    -   the root element pointer to be filled in
    
    ppXMLDoc -   document pointer to be filled in
    
    pKB -   pointer to KB registration node

Return:

    HRESULT error code

++*/
{

    HRESULT hr = S_OK;
    WCHAR   szKBandName[MAX_PATH];
    CComPtr <IXMLDOMNodeList> pKBList;
    WCHAR   szKBFile[MAX_PATH + 20];
    WCHAR   szWindir[MAX_PATH + 20];

    wcscpy(szKBandName, pszKBType);
    wcscat(szKBandName, L"/Name");

    hr = pKB->selectNodes(szKBandName, &pKBList);

    if (FAILED(hr) || pKBList == NULL ) {

        SsrpLogError(L"No KBs in this category \n");
        hr = S_OK;
        goto ExitHandler;
    }

    hr = pKBList->nextNode(&pKB);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    while (pKB) {

        CComBSTR    bstrValue;

        hr = pKB->get_text(&bstrValue);

        if (FAILED(hr) || !bstrValue ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        SsrpConvertBstrToPwstr(bstrValue);

        wcscpy(szKBFile, pszKBDir); 
        wcscat(szKBFile, bstrValue);
        

        if ( 0xFFFFFFFF == GetFileAttributes(szKBFile) ) {

            SsrpLogError(L"KB File not found");

            hr = E_INVALIDARG;
            goto ExitHandler;
        }

        hr = SsrpMergeDOMTrees(ppElementRoot, ppXMLDoc, szKBFile);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pKBList->nextNode(&pKB);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    
    }


ExitHandler:

        return hr;

}



HRESULT
process::SsrpMergeDOMTrees(
    OUT  IXMLDOMElement **ppMergedKBElementRoot,
    OUT  IXMLDOMDocument  **ppMergedKBXMLDoc,
    IN  WCHAR    *szXMLFileName
    )
/*++

Routine Description:

    Routine called to load and merge XML KBs

Arguments:

    *ppElementRoot  -   pointer to final merged KB root
    
    *ppXMLDoc       -   pointer to final merged KB doc to which merges are made
    
Return:

    HRESULT error code

++*/
{

    CComPtr <IXMLDOMDocument>   pXMLKBDoc;
    CComPtr <IXMLDOMElement>    pXMLKBElemRoot;
    CComVariant KBFile(szXMLFileName);
    CComPtr <IXMLDOMNode> pNewNode;
    
    HRESULT hr = S_OK;
    VARIANT_BOOL vtSuccess = VARIANT_FALSE;

    //
    // instantiate DOM document object to read and store each KB
    //
    
    hr = CoCreateInstance(CLSID_DOMDocument, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IXMLDOMDocument, 
                          (void**)&pXMLKBDoc);
    
    if (FAILED(hr) || pXMLKBDoc == NULL ) {

        SsrpLogError(L"COM failed to create a DOM instance");
        goto ExitHandler;
    }

    hr = pXMLKBDoc->put_preserveWhiteSpace(VARIANT_TRUE);

    if (FAILED(hr)) {
        
        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    //
    // load the KB XML into DOM
    //
        
    hr = pXMLKBDoc->load(KBFile, &vtSuccess);

    if (FAILED(hr) || vtSuccess == VARIANT_FALSE ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
                
    //
    // get the root element
    //
    
    hr = pXMLKBDoc->get_documentElement(&pXMLKBElemRoot);

    if (FAILED(hr) || pXMLKBElemRoot == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    if (*ppMergedKBElementRoot == NULL) {

        //
        // special case: this is the first KB, so simply clone the empty merged KB tree with it
        //

        hr = pXMLKBElemRoot->cloneNode(VARIANT_TRUE, &pNewNode);

        if (FAILED(hr) || pNewNode == NULL ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    
        hr = (*ppMergedKBXMLDoc)->appendChild(pNewNode, NULL);

        if (FAILED(hr) ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        //
        // update the empty values so that next time around, we know that 
        // the merged KB is initialized with the first KB
        //


        hr = (*ppMergedKBXMLDoc)->get_documentElement(ppMergedKBElementRoot);

        if (FAILED(hr) || *ppMergedKBElementRoot == NULL ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        goto ExitHandler;

    }

    //
    // this is not the first KB - perform actual merges in the following way:
    //
    // number of mergeable entities in MergedKB = n
    // number of mergeable entities in CurrentKB = m
    //
    // O(m x n) algorithm for merging:
    // 
    // foreach mergeable entity in CurrentKB
    //  foreach mergeable entity in MergedKB
    //      if no <Name> based collision 
    //          append entity from CurrentKB into MergedKB
    //      else
    //          replace existing entity in MergedKB by entity from CurrentKB
    //

    hr = SsrpAppendOrReplaceMergeableEntities(L"Description/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {


        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = SsrpAppendOrReplaceMergeableEntities(L"SecurityLevels/Level/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        
        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = SsrpAppendOrReplaceMergeableEntities(L"Roles/Role/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = SsrpAppendOrReplaceMergeableEntities(L"Tasks/Task/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        
        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = SsrpAppendOrReplaceMergeableEntities(L"Services/Service/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = SsrpAppendOrReplaceMergeableEntities(L"RoleLocalization/Role/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = SsrpAppendOrReplaceMergeableEntities(L"TaskLocalization/Task/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = SsrpAppendOrReplaceMergeableEntities(L"ServiceLocalization/Service/Name",
                                              *ppMergedKBElementRoot, 
                                              *ppMergedKBXMLDoc, 
                                              pXMLKBDoc, 
                                              pXMLKBElemRoot,
                                              szXMLFileName
                                              );


    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }


ExitHandler:
    

    
    return hr;
}

HRESULT
process::SsrpAppendOrReplaceMergeableEntities(
    IN  PWSTR   pszFullyQualifiedEntityName,
    IN  IXMLDOMElement *pMergedKBElementRoot, 
    IN  IXMLDOMDocument *pMergedKBXMLDoc, 
    IN  IXMLDOMDocument *pCurrentKBDoc, 
    IN  IXMLDOMElement *pCurrentKBElemRoot,
    IN  PWSTR   pszKBName
    )
/*++

Routine Description:

    Routine called to load and merge XML KBs

Arguments:

    pszFullyQualifiedEntityName   -   string containing the entity name representing the entity
                                         
    pMergedKBElementRoot    -   pointer to final merged KB root
         
    pMergedKBXMLDoc     -   pointer to final merged KB doc to which merges are made
         
    pElementRoot  -   root of current KB
    
    pXMLDoc       -   pointer to current KB doc from which merges are made
    
    pszKBName   -   name of the source KB
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr = S_OK;
    CComPtr <IXMLDOMNode> pNameCurrent;
    CComPtr <IXMLDOMNodeList> pNameListCurrent;
    CComPtr <IXMLDOMNamedNodeMap>   pAttribNodeMap;
    CComPtr <IXMLDOMAttribute>   pAttrib;
    CComBSTR    bstrSourceKB(L"SourceKB");
    CComBSTR    bstrSourceKBName(wcsrchr(pszKBName, L'\\')+1);
    
    hr = pCurrentKBElemRoot->selectNodes(pszFullyQualifiedEntityName, &pNameListCurrent);

    if (FAILED(hr) || pNameListCurrent == NULL ) {

        hr = S_OK;
        goto ExitHandler;
    }

    hr = pNameListCurrent->nextNode(&pNameCurrent);

    if (FAILED(hr) || pNameCurrent == NULL) {
#if 0
        //
        // no need to error out if these nodes are not present in the source KB
        //

#endif
        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pNameCurrent) {
        
        CComBSTR    bstrCurrentText;
        CComPtr <IXMLDOMNode> pNameMerged;
        CComPtr <IXMLDOMNodeList> pNameListMerged;
        CComPtr <IXMLDOMNode> pRootOfEntityName;
        LONG   ulLength;
        
        hr = pNameCurrent->get_text(&bstrCurrentText);

        if (FAILED(hr) || !bstrCurrentText ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
                                            
        hr = pMergedKBElementRoot->selectNodes(pszFullyQualifiedEntityName, &pNameListMerged);
        
        if (FAILED(hr) || pNameListMerged == NULL ) {
        
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
            
        hr = pNameListMerged->get_length(&ulLength);
        
        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        if (ulLength == 0) {
            
            PWSTR   pszRootOfFullyQualifiedEntityName;
            WCHAR   szRootOfEntityName[MAX_PATH];

            memset(szRootOfEntityName, L'\0', MAX_PATH * sizeof(WCHAR));

            //
            // no need to error out if these nodes are not present - but append is necessary
            //

            wcscpy(szRootOfEntityName, pszFullyQualifiedEntityName);

            pszRootOfFullyQualifiedEntityName = wcschr(szRootOfEntityName, L'/');

            pszRootOfFullyQualifiedEntityName[0] = L'\0';


            hr = pCurrentKBElemRoot->selectSingleNode(szRootOfEntityName, &pRootOfEntityName);

            if (FAILED(hr) || pRootOfEntityName == NULL) {

                
                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            
            hr = pMergedKBElementRoot->appendChild(pRootOfEntityName,
                                                     NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
            }            
            
            goto ExitHandler;
            
        }

        hr = pNameListMerged->nextNode(&pNameMerged);

        if (FAILED(hr) || pNameMerged == NULL) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        while (pNameMerged) {
        
            CComBSTR    bstrMergedText;
            CComPtr <IXMLDOMNode> pCurrentNameParent;
            CComPtr <IXMLDOMNode> pMergedNameParent;
            CComPtr <IXMLDOMNode> pMergedNameGrandParent;

            hr = pNameMerged->get_text(&bstrMergedText);

            if (FAILED(hr) || !bstrMergedText ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pNameCurrent->get_parentNode(&pCurrentNameParent);

            if (FAILED(hr) || pCurrentNameParent == NULL ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pNameMerged->get_parentNode(&pMergedNameParent);

            if (FAILED(hr) || pMergedNameParent == NULL ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pMergedNameParent->get_parentNode(&pMergedNameGrandParent);

            if (FAILED(hr) || pMergedNameGrandParent == NULL ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pCurrentNameParent->get_attributes(&pAttribNodeMap);

            if (FAILED(hr) || pAttribNodeMap == NULL ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

           hr = pCurrentKBDoc->createAttribute( bstrSourceKB, &pAttrib );

           if (FAILED(hr) || pAttrib == NULL ) {

               SsrpLogParseError(hr);
               goto ExitHandler;
           }

           hr = pAttrib->put_text(bstrSourceKBName);

           if (FAILED(hr)) {

               SsrpLogParseError(hr);
               goto ExitHandler;
           }

           hr = pAttribNodeMap->setNamedItem(pAttrib, NULL);

           if (FAILED(hr)) {

               SsrpLogParseError(hr);
               goto ExitHandler;
           }
            
            if (0 == SsrpICompareBstrPwstr(bstrCurrentText, bstrMergedText)) {

                //
                // collision - need to delete pNameMerged's parent and 
                // replace  pMergedNameParent with  pCurrentNameParent
                //



                hr = pMergedNameGrandParent->replaceChild(pCurrentNameParent,
                                                          pMergedNameParent,
                                                          NULL);


                if (FAILED(hr)) {

                    SsrpLogParseError(hr);
                    goto ExitHandler;
                }

            }        
            
            else {

                //
                // no collision - need to append pNameCurrent's parent to 
                // pNameMerged's grandparent's section
                //

                hr = pMergedNameGrandParent->appendChild(pCurrentNameParent,
                                                         NULL);
            
                if (FAILED(hr)) {

                    SsrpLogParseError(hr);
                    goto ExitHandler;
                }            
            }

            hr = pNameListMerged->nextNode(&pNameMerged);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

        }

        hr = pNameListCurrent->nextNode(&pNameCurrent);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }


    }

ExitHandler:
    
    return hr;

}


HRESULT
process::SsrpOverwriteServiceLocalizationFromSystem(
    IN  IXMLDOMElement *pMergedKBElementRoot, 
    IN  IXMLDOMDocument *pMergedKBXMLDoc
    )
/*++

Routine Description:

    Routine called to overwrite service info in localization section

Arguments:

    pMergedKBElementRoot    -   pointer to root of merged DOM
    
    pMergedKBXMLDoc     -   pointer to merged Document
    
Return:

    HRESULT error code

++*/
{
    CComPtr <IXMLDOMNode> pServiceName;
    CComPtr <IXMLDOMNodeList> pServiceNameList;
    HRESULT hr = S_OK;

    hr = pMergedKBElementRoot->selectNodes(L"ServiceLocalization/Service/Name", &pServiceNameList);

    if (FAILED(hr) || pServiceNameList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pServiceNameList->nextNode(&pServiceName);

    if (FAILED(hr) || pServiceName == NULL) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pServiceName) {
        
        CComBSTR    bstrServiceText;
        PWSTR   pszDescription = NULL;
        PWSTR   pszDisplay = NULL;
        LPSERVICE_DESCRIPTION   pServiceDescription = NULL;


        hr = pServiceName->get_text(&bstrServiceText);

        if (FAILED(hr) || !bstrServiceText) {
        
            SsrpLogError(L"Failed to ");
            goto ExitHandler;
    
        }

        pszDisplay = SsrpQueryServiceDisplayName(bstrServiceText);

        SsrpConvertBstrToPwstr(bstrServiceText);

        if ( SsrpQueryServiceDescription(bstrServiceText, &pServiceDescription) && 
             pServiceDescription != NULL){
            pszDescription = pServiceDescription->lpDescription;
        }

        if ( pszDisplay != NULL && pszDescription != NULL) {

            CComPtr <IXMLDOMNode> pServiceNameParent;
            CComPtr <IXMLDOMNode> pDescription;
            CComPtr <IXMLDOMNode> pDisplayName;

            pServiceName->get_parentNode(&pServiceNameParent);

            if (FAILED(hr) || pServiceNameParent == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pServiceNameParent->selectSingleNode(L"Description", &pDescription);
            
            if (FAILED(hr) || pDescription == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pDescription->put_text(pszDescription);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pServiceNameParent->selectSingleNode(L"DisplayName", &pDisplayName);
            
            if (FAILED(hr) || pDisplayName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pDisplayName->put_text(pszDisplay);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

        }

        if (pServiceDescription) {

            LocalFree(pServiceDescription);
            pServiceDescription = NULL;
        }
        
        hr = pServiceNameList->nextNode(&pServiceName);
        
        if (FAILED(hr)) {
        
            SsrpLogError(L"Failed to ");
            goto ExitHandler;
    
        }

    }

ExitHandler:
    
    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\roletask.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    roletask.cpp

Abstract:

    This module implements routines for role/task
    specific SSR Knowledge Base processing.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/

#include "stdafx.h"
#include "kbproc.h"
#include "process.h"

HRESULT
process::SsrpProcessRolesOrTasks(
    IN  PWSTR   pszMachineName,
    IN  CComPtr<IXMLDOMElement> pXMLDocElemRoot,
    IN  CComPtr<IXMLDOMDocument> pXMLDoc,
    IN  PWSTR   pszKbMode,
    IN  BOOL    bRole
    )
/*++

Routine Description:

    Routine called to process all roles

Arguments:

    pszMachineName      -   name of machine to preprocess
    
    pXMLDocElemRoot     -   root of document
    
    pXMLDoc             -   KB document
    
    pszKbMode           -   mode value
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr = S_OK;
    DWORD rc;

    ULONG   uRoleIndex = 0;  
    ULONG   uServiceIndex = 0;  

    CComPtr<IXMLDOMNodeList> pResultList;
    CComPtr<IXMLDOMNode>  pXMLRoleOrTaskNode;
    CComPtr<IXMLDOMNodeList> pChildList;
    
    CComVariant Type(NODE_ELEMENT);

    
    //
    // get the "Role" or "Task" node
    //

    hr = pXMLDocElemRoot->selectNodes(bRole ? L"Roles/Role" : L"Tasks/Task", &pResultList);

    if (FAILED(hr) || pResultList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pResultList->get_item( uRoleIndex, &pXMLRoleOrTaskNode);
           
    if (FAILED(hr) || pXMLRoleOrTaskNode == NULL ) {
        
        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    //
    // for each Role
    //
    
    while ( pXMLRoleOrTaskNode != NULL) {

        BOOL    bRoleIsSatisfiable = TRUE;
        BOOL    bSomeRequiredServiceDisabled = FALSE;
        
        CComBSTR    bstrRoleName;

        CComPtr<IXMLDOMNode>        pNameNode;
        CComPtr<IXMLDOMNode>        pXMLRoleModeNode;
        CComPtr<IXMLDOMNode>        pXMLRoleSelectedNode;
        CComPtr<IXMLDOMNode>        pXMLValueNode;
        CComPtr<IXMLDOMNode>        pXMLServiceNode;
        CComPtr<IXMLDOMNamedNodeMap>    pXMLAttribNode;

        hr = pXMLRoleOrTaskNode->selectSingleNode(L"Name", &pNameNode );

        if (FAILED(hr) || pNameNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        pNameNode->get_text(&bstrRoleName);

        if (FAILED(hr) || !bstrRoleName){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pXMLRoleOrTaskNode->selectSingleNode( L"Selected", &pXMLRoleSelectedNode );

        if (FAILED(hr) || pXMLRoleSelectedNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pXMLRoleSelectedNode->selectSingleNode(pszKbMode, &pXMLRoleModeNode );

        if (FAILED(hr) || pXMLRoleModeNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        hr = pXMLRoleModeNode->get_attributes( &pXMLAttribNode );

        if (FAILED(hr) || pXMLAttribNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pXMLAttribNode->getNamedItem(L"Value", &pXMLValueNode );

        if (FAILED(hr) || pXMLValueNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        CComBSTR    bstrModeValue;

        hr = pXMLValueNode->get_text(&bstrModeValue);

        if (FAILED(hr) || !bstrModeValue){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = SsrpDeleteChildren(pXMLRoleSelectedNode);

        if (FAILED(hr) ){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        CComPtr <IXMLDOMNodeList> pServiceList;

        hr = pXMLRoleOrTaskNode->selectNodes(L"Services/Service", &pServiceList);

        if (FAILED(hr) || pServiceList == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        uServiceIndex=0;

        hr = pServiceList->get_item( uServiceIndex, &pXMLServiceNode);

        if (FAILED(hr) || pXMLServiceNode == NULL ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        //
        // for each Service
        //
        
        while ( pXMLServiceNode != NULL) {

            hr = SsrpProcessService(pXMLDocElemRoot, 
                                    pXMLServiceNode, 
                                    pszKbMode, 
                                    &bRoleIsSatisfiable, 
                                    &bSomeRequiredServiceDisabled);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            pXMLServiceNode.Release();

            uServiceIndex++;

            hr = pServiceList->get_item( uServiceIndex, &pXMLServiceNode);

            if (FAILED(hr)){

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
        }

        BOOL    bRoleSelect = FALSE;

        if (bRoleIsSatisfiable) {
            
            if (0 == SsrpICompareBstrPwstr(bstrModeValue, L"TRUE")){            
                bRoleSelect = TRUE;           
            }
            else if (0 == SsrpICompareBstrPwstr(bstrModeValue, L"DEFAULT")){
                bRoleSelect = !bSomeRequiredServiceDisabled;
            }
            else if (0 == SsrpICompareBstrPwstr(bstrModeValue, L"CUSTOM")){

                //
                // get the attributes "FunctionName" and "DLLName"
                //

                CComBSTR    bstrFunctionName;
                CComBSTR    bstrDLLName;
                CComPtr <IXMLDOMNode> pXMLFunctionName;
                CComPtr <IXMLDOMNode> pXMLDLLName;

                hr = pXMLAttribNode->getNamedItem(L"FunctionName", &pXMLFunctionName );

                if (FAILED(hr) || pXMLFunctionName == NULL){

                    SsrpLogParseError(hr);
                    goto ExitHandler;
                }

                hr = pXMLFunctionName->get_text(&bstrFunctionName);

                if (FAILED(hr) || !bstrFunctionName){

                    SsrpLogParseError(hr);
                    goto ExitHandler;
                }

                hr = pXMLAttribNode->getNamedItem(L"DLLName", &pXMLDLLName );

                if (FAILED(hr) || pXMLDLLName == NULL){

                    SsrpLogParseError(hr);
                    goto ExitHandler;
                }

                hr = pXMLDLLName->get_text(&bstrDLLName);

                if (FAILED(hr) || !bstrDLLName){

                    SsrpLogParseError(hr);
                    goto ExitHandler;
                }

                rc = SsrpEvaluateCustomFunction(pszMachineName, bstrDLLName, bstrFunctionName, &bRoleSelect);

                if (rc != ERROR_SUCCESS) {

                    WCHAR   szMsg[MAX_PATH];

                    swprintf(szMsg, L"%s not found",  bstrFunctionName);

                    SsrpLogError(szMsg);
                    // SsrpLogWin32Error(rc);
                    // continue on error
                    // goto ExitHandler;
                }
            }

        }

        hr = pXMLRoleSelectedNode->put_text(bRoleSelect ? L"TRUE" : L"FALSE");

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        CComPtr <IXMLDOMNode> pFirstChild;
        CComPtr <IXMLDOMNode> pNextSibling;

        hr = pXMLRoleOrTaskNode->get_firstChild(&pFirstChild);

        if (FAILED(hr) || pFirstChild == NULL) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pFirstChild->get_nextSibling(&pNextSibling);

        if (FAILED(hr) || pNextSibling == NULL) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        CComVariant vtRefChild(pNextSibling);
        CComPtr<IXMLDOMNode>  pXDNodeCreate;

        hr = pXMLDoc->createNode(
                                Type,
                                L"Satisfiable",
                                NULL,
                                &pXDNodeCreate);

        if (FAILED(hr) || pXDNodeCreate == NULL) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        hr = pXDNodeCreate->put_text(bRoleIsSatisfiable ? L"TRUE" : L"FALSE");

        if (m_bDbg) {
            if (bRoleIsSatisfiable)
                wprintf(L"ROLE satisfiable: %s\n", bstrRoleName);
            else
                wprintf(L"ROLE not satisfiable: %s\n", bstrRoleName);
        }

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        hr = pXMLRoleOrTaskNode->insertBefore(pXDNodeCreate,
                                     vtRefChild,
                                     NULL);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        uRoleIndex++;

        pXMLRoleOrTaskNode.Release();

        hr = pResultList->get_item( uRoleIndex, &pXMLRoleOrTaskNode);

        if (FAILED(hr)){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }

    }

ExitHandler:
    
    return hr;
}

#if 0

HRESULT
process::SsrpAddUnknownSection(
    IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
    IN CComPtr <IXMLDOMDocument> pXMLDoc
    )
/*++

Routine Description:

    Routine called to add the "Unknown" section

Arguments:

    pXMLDocElemRoot     -   root of document
    
    pXMLDoc             -   KB document
    
Return:

    HRESULT error code

++*/
{
    HRESULT     hr;

    CComPtr <IXMLDOMNode> pUnknownNode;

    hr = pXMLDocElemRoot->selectSingleNode(L"Roles", &pRolesNode);

    if (FAILED(hr) || pRolesNode == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = SsrpAddExtraServices(pXMLDoc, pRolesNode);
    
    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

ExitHandler:

   return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\kbprocess.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    kbprocess.cpp

Abstract:

    This module implements routines for 
    SSR Knowledge Base processing.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

    Exported as a COM Interface

Revision History:

    Created - Oct 2001

--*/

#include "stdafx.h"
#include "kbproc.h"
#include "process.h"

HRESULT
process::SsrpDeleteChildren(
    IN  CComPtr <IXMLDOMNode> pParent
    )
/*++

Routine Description:

    Routine called to delete children from a parent node

Arguments:

    pParent     -   parent node to delete comments from
    
    pChildList  -   list of children of the parent
    
Return:

    HRESULT error code
    
++*/
{
    HRESULT hr = S_OK;
    CComPtr <IXMLDOMNodeList> pChildList;
    CComPtr <IXMLDOMNode> pXMLChildNode;

    hr = pParent->get_childNodes(&pChildList);

    if (FAILED(hr) || pChildList == NULL){

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pChildList->nextNode(&pXMLChildNode);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pXMLChildNode) {

        CComPtr <IXMLDOMNode> pXMLOldChild;

        hr = pParent->removeChild(pXMLChildNode, &pXMLOldChild);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        pXMLChildNode.Release();

        hr = pChildList->nextNode(&pXMLChildNode);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }

ExitHandler:

    return hr;
}


VOID
process::SsrpLogParseError(
    IN HRESULT hr
    )
/*++

Routine Description:

    Routine called to log detailed parse errors

Arguments:

    hr  -   error code
    
Return:

    HRESULT error code
    
++*/
{
    long    lVoid;
    CComBSTR    bstrReason;
    WCHAR   szMsg[MAX_PATH];

    return;
        
    m_pXMLError->get_errorCode(&lVoid);
    m_pSsrLogger->LogResult(L"SSR", lVoid, SSR_LOG_ERROR_TYPE_COM);

    m_pXMLError->get_line(&lVoid);
    wsprintf(szMsg, L"Parsing failed at line number %i", lVoid );
    m_pSsrLogger->LogString(szMsg);
    
    m_pXMLError->get_linepos(&lVoid);
    wsprintf(szMsg, L"Parsing failed at line position %i", lVoid );
    m_pSsrLogger->LogString(szMsg);
    
    m_pXMLError->get_reason(&bstrReason);
    wsprintf(szMsg, L"Parsing failed because %s", bstrReason );
    m_pSsrLogger->LogString(szMsg);

    return;

}   

VOID
process::SsrpLogError(
    IN  PWSTR   pszError
    )
/*++

Routine Description:

    Routine called to log processing errors

Arguments:

    pszError    -   error string
    
Return:

++*/
{
    m_pSsrLogger->LogString(pszError);;

    return;
}


VOID                    
process::SsrpLogWin32Error(
    IN  DWORD   rc
    )
/*++

Routine Description:

    Routine called to log win32 processing errors

Arguments:

    rc  -   win32 error code
    
Return:

++*/
{
    m_pSsrLogger->LogResult(L"SSR", rc, SSR_LOG_ERROR_TYPE_System);
}

HRESULT
process::SsrpDeleteComments(
    IN  CComPtr <IXMLDOMElement> pParent
    )
/*++

Routine Description:

    Routine called to delete comments from a parent node

Arguments:

    pParent -   parent node
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr = S_OK;
    CComPtr <IXMLDOMNode> pXMLChildNode;
    CComPtr <IXMLDOMNodeList> pChildList;

    hr = pParent->get_childNodes(&pChildList);

    if (FAILED(hr) || pChildList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pChildList->nextNode(&pXMLChildNode);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pXMLChildNode) {

        DOMNodeType nodeType;
        CComPtr <IXMLDOMNode> pXMLOldChild;

        hr = pXMLChildNode->get_nodeType(&nodeType);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        if (nodeType == NODE_COMMENT) {
            
            hr = pParent->removeChild(pXMLChildNode, &pXMLOldChild);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
        }
        
        pXMLChildNode.Release();

        hr = pChildList->nextNode(&pXMLChildNode);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }

ExitHandler:

    return hr;
}


int 
process::SsrpICompareBstrPwstr(
    IN  BSTR   bstrString, 
    IN  PWSTR  pszString
    )
/*++

Routine Description:

    Routine called to do a case insensitive comparison
    between BSTR and PWSTR (blanks are removed too)

Arguments:

    bstrString  -   the BSTR argument
    
    pszString   -   the PWSTR argument
    
Return:

    0 if  bstrString == pszString
    -ve if  bstrString < pszString
    +ve if  bstrString > pszString

++*/
{

    WCHAR   szName[MAX_PATH];
    ULONG   uIndex = 0;
    ULONG   uIndexNew = 0;


    if (bstrString == NULL || pszString == NULL) {
        return 0;
    }

    wsprintf(szName, L"%s", bstrString);

    while (szName[uIndex] == L' ') {
        uIndex ++ ;
    }

    do  {
        szName[uIndexNew] = szName[uIndex];
        uIndex++;
        uIndexNew++;
    }  while (szName[uIndex] != L' ' && szName[uIndex] != L'\0' );

    szName[uIndexNew] = L'\0';

    /*
    while (szName[uIndex+1] != L'\0') {
        szName[uIndex] = szName[uIndex+1];
        uIndex++;
    }
    */

    return (_wcsicmp(szName , pszString));

}


HRESULT
process::SsrpAddWhiteSpace(
    IN  CComPtr <IXMLDOMDocument> pXMLDoc,
    IN  CComPtr <IXMLDOMNode> pXMLParent,
    IN  BSTR    bstrWhiteSpace
    )
/*++

Routine Description:

    Routine called to add whitespace nodes

Arguments:

    pXMLDoc     -   XML document
    
    pXMLParent  -   parent node
    
    bstrWhiteSpace  -   whitespace formatting string
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr;
    CComPtr <IXMLDOMText> pXDNodeEmptyText;

    hr = pXMLDoc->createTextNode(
                            bstrWhiteSpace,
                            &pXDNodeEmptyText);
    
    if (FAILED(hr) || pXDNodeEmptyText == NULL) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLParent->appendChild(pXDNodeEmptyText, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

ExitHandler:

    return hr;

}

VOID
process::SsrpCleanup(
    )
/*++

Routine Description:

    Routine called to cleanup SSR memory

Arguments:

    
Return:

++*/
{
    if (m_hScm){
        CloseServiceHandle(m_hScm);
        m_hScm = NULL;
    }
    
    if (m_pInstalledServicesInfo) {
        LocalFree(m_pInstalledServicesInfo);
        m_pInstalledServicesInfo = NULL;
    }

    if (m_bArrServiceInKB) {
        LocalFree(m_bArrServiceInKB);
        m_bArrServiceInKB = NULL;
    }

    return;
}



HRESULT
process::SsrpCloneAllChildren(
    IN  CComPtr <IXMLDOMDocument> pXMLDocSource,
    IN  CComPtr <IXMLDOMDocument> pXMLDocDestination
    )
/*++

Routine Description:

    Routine called to clone children

Arguments:

    pXMLDocSource   -   source document
    
    pXMLDocDestination  -   destination document
    
Return:

    HRESULT error code
    
++*/
{
    HRESULT hr = S_OK;
    CComPtr <IXMLDOMNode> pXMLChildNode;
    CComPtr <IXMLDOMElement> pXMLDocElemRootSource;
    CComPtr <IXMLDOMElement> pXMLDocElemRootDestination;
    CComPtr <IXMLDOMNodeList> pChildList;


    hr = pXMLDocSource->get_documentElement(&pXMLDocElemRootSource);

    if (FAILED(hr) || pXMLDocElemRootSource == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocDestination->get_documentElement(&pXMLDocElemRootDestination);

    if (FAILED(hr) || pXMLDocElemRootDestination == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocElemRootSource->get_childNodes(&pChildList);

    if (FAILED(hr) || pChildList == NULL){

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pChildList->nextNode(&pXMLChildNode);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pXMLChildNode) {

        CComPtr <IXMLDOMNode> pXMLOutChild;
        CComPtr <IXMLDOMNode> pXMLAppendedChild;
        
        pXMLDocDestination->cloneNode(VARIANT_TRUE, &pXMLOutChild);
        
        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        pXMLDocElemRootDestination->appendChild(pXMLOutChild, &pXMLAppendedChild);
        
        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        pXMLChildNode.Release();
        
        hr = pChildList->nextNode(&pXMLChildNode);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }

ExitHandler:

    return hr;
}


VOID 
process::SsrpConvertBstrToPwstr(
    IN OUT  BSTR   bstrString
    )
/*++

Routine Description:

    Routine called to convert (in place) BSTR to PWSTR (strip blanks)

Arguments:

    bstrString  -   the BSTR argument
    
Return:

++*/
{

    ULONG   uIndex = 0;
    ULONG   uIndexNew = 0;

    if (bstrString == NULL) {
        return;
    }

    while (bstrString[uIndex] == L' ') {
        uIndex ++ ;
    }

    do  {
        bstrString[uIndexNew] = bstrString[uIndex];
        uIndex++;
        uIndexNew++;
    }  while (bstrString[uIndex] != L' ' && bstrString[uIndex] != L'\0' );

    bstrString[uIndexNew] = L'\0';

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\service.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    This module implements routines for service
    specific SSR Knowledge Base processing.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/

#include "stdafx.h"
#include "kbproc.h"
#include "process.h"

HRESULT
process::SsrpProcessService(
    IN  CComPtr <IXMLDOMElement> pXMLDocElemRoot,
    IN  CComPtr <IXMLDOMNode> pXMLServiceNode,
    IN  PWSTR   pszMode,
    OUT BOOL    *pbRoleIsSatisfiable,
    OUT BOOL    *pbSomeRequiredServiceDisabled
    )
/*++

Routine Description:

    Routine called to process each service

Arguments:

    pXMLDocElemRoot     -   root of document
    
    pXMLServiceNode     -   service node
    
    pszMode             -   mode value
    
    pbRoleIsSatisfiable -   boolean to fill regarding role satisfiability
    
    pbSomeRequiredServiceDisabled   -   boolean to fill in if required service is disabled
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr = S_OK;
    CComBSTR bstrName;
    //CComBSTR bstrRequired;
    CComPtr <IXMLDOMNode>   pServiceSelect;
    CComPtr <IXMLDOMNode>   pServiceRequired;
    CComPtr <IXMLDOMNodeList> pSelectChildList;
    CComPtr <IXMLDOMNode> pServiceName;

    DWORD   rc = ERROR_SUCCESS;

    if (pbRoleIsSatisfiable == NULL || pbSomeRequiredServiceDisabled == NULL ) {
        return E_INVALIDARG;
    }

    /*
    hr = pXMLServiceNode->selectSingleNode(L"Required", &pServiceRequired);

    if (FAILED(hr) || pServiceRequired == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    pServiceRequired->get_text(&bstrRequired);

    hr = pXMLServiceNode->selectSingleNode(L"Select", &pServiceSelect);

    if (FAILED(hr) || pServiceSelect == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = SsrpDeleteChildren(pServiceSelect);

    if (FAILED(hr) ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
*/
    hr = pXMLServiceNode->selectSingleNode(L"Name", &pServiceName);

    if (FAILED(hr) || pServiceName == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    pServiceName->get_text(&bstrName);

    BOOL    bIsServiceInstalled = FALSE;

    bIsServiceInstalled = SsrpIsServiceInstalled(bstrName);

    BYTE    byStartupType = SERVICE_DISABLED;
    BOOL    bServiceIsDisabled = FALSE;
    
    rc = SsrpQueryServiceStartupType(bstrName, &byStartupType);

    if (rc == ERROR_SERVICE_DOES_NOT_EXIST) {
        rc = ERROR_SUCCESS;
    }

    if ( rc != ERROR_SUCCESS ) {
        SsrpLogError(L"Startup type for some service was not queried\n");
        goto ExitHandler;
    }
    
    bServiceIsDisabled = (byStartupType == SERVICE_DISABLED ? TRUE: FALSE);

/*
    BOOL    bIsServiceOptional = FALSE;

    hr = SsrpCheckIfOptionalService(
                                  pXMLDocElemRoot,
                                  bstrName,
                                  &bIsServiceOptional
                                  );

    if (FAILED(hr) ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
*/
    
    *pbRoleIsSatisfiable  = *pbRoleIsSatisfiable && bIsServiceInstalled;

    *pbSomeRequiredServiceDisabled = *pbSomeRequiredServiceDisabled ||  bServiceIsDisabled;
    
/*    
    if (0 == SsrpICompareBstrPwstr(bstrRequired, L"TRUE")) {

        hr = pServiceSelect->put_text(L"TRUE");

        if (FAILED(hr) ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        *pbRoleIsSatisfiable  = *pbRoleIsSatisfiable && bIsServiceInstalled;

        *pbSomeRequiredServiceDisabled = *pbSomeRequiredServiceDisabled ||  bServiceIsDisabled;

    }

    else {

        //
        // service is not required
        //

        BOOL    bServiceSelect = FALSE;
        CComPtr <IXMLDOMNamedNodeMap> pXMLAttribNode;
        CComPtr <IXMLDOMNode> pXMLValueNode;
        CComPtr <IXMLDOMNode> pXMLServiceModeNode;

        hr = pServiceSelect->selectSingleNode(pszMode, &pXMLServiceModeNode );

        if (FAILED(hr) || pXMLServiceModeNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        hr = pXMLServiceModeNode->get_attributes( &pXMLAttribNode );

        if (FAILED(hr) || pXMLAttribNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pXMLAttribNode->getNamedItem(L"Value", &pXMLValueNode );

        if (FAILED(hr) || pXMLValueNode == NULL){
            
            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        CComBSTR   bstrValue;

        hr = pXMLValueNode->get_text(&bstrValue);

        if (FAILED(hr) || !bstrValue ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        if (0 == SsrpICompareBstrPwstr(bstrValue, L"TRUE")) {
            bServiceSelect = TRUE;
        }
        else if (0 == SsrpICompareBstrPwstr(bstrValue, L"FALSE")) {
            bServiceSelect = TRUE;
        }
        else if (0 == SsrpICompareBstrPwstr(bstrValue, L"DEFAULT")) {

            if (bIsServiceOptional && bIsServiceInstalled && !bServiceIsDisabled ) {
                bServiceSelect = TRUE;
            }
        }
        else if (0 == SsrpICompareBstrPwstr(bstrValue, L"CUSTOM")) {

            //
            // get the attributes "FunctionName" and "DLLName"
            //

            CComPtr <IXMLDOMNode> pXMLFunctionName;
            CComBSTR    bstrFunctionName;

            hr = pXMLAttribNode->getNamedItem(L"FunctionName", &pXMLFunctionName );

            if (FAILED(hr) || pXMLFunctionName == NULL){

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXMLFunctionName->get_text(&bstrFunctionName);

            if (FAILED(hr) || !bstrFunctionName){

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            CComPtr <IXMLDOMNode> pXMLDLLName;
            CComBSTR    bstrDLLName;

            hr = pXMLAttribNode->getNamedItem(L"DLLName", &pXMLDLLName );

            if (FAILED(hr) || pXMLDLLName == NULL){

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXMLDLLName->get_text(&bstrDLLName);

            if (FAILED(hr) || !bstrDLLName ){

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            rc = SsrpEvaluateCustomFunction(bstrDLLName, bstrFunctionName, &bServiceSelect);

            if (rc != ERROR_SUCCESS) {
                SsrpLogWin32Error(rc);
                goto ExitHandler;
            }

        }

        hr = SsrpDeleteChildren(pServiceSelect);

        if (FAILED(hr) ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

//        hr = pServiceSelect->put_text(bServiceSelect ? L"TRUE" : L"FALSE");

        if (FAILED(hr) ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

    }
*/
ExitHandler:

    return rc;
}


DWORD
process::SsrpQueryInstalledServicesInfo(
    IN  PWSTR   pszMachineName
    )
/*++

Routine Description:

    Routine called to initialize service information

Arguments:

    pszMachineName  -   name of machine to lookup SCM information
    
Return:

    HRESULT error code

++*/
{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   cbInfo   = 0;
    DWORD   dwErr    = ERROR_SUCCESS;
    DWORD   dwResume = 0;

    //
    // Connect to the service controller.
    //
    
    m_hScm = OpenSCManager(
                pszMachineName,
                NULL,
                GENERIC_READ);
    
    if (m_hScm == NULL) {

        rc = GetLastError();
        goto ExitHandler;
    }


    if ((!EnumServicesStatusEx(
                              m_hScm,
                              SC_ENUM_PROCESS_INFO,
                              SERVICE_WIN32,
                              SERVICE_STATE_ALL,
                              NULL,
                              0,
                              &cbInfo,
                              &m_dwNumServices,
                              &dwResume,
                              NULL)) && ERROR_MORE_DATA == GetLastError()) {

        m_pInstalledServicesInfo = (LPENUM_SERVICE_STATUS_PROCESS)LocalAlloc(LMEM_ZEROINIT, cbInfo);

        if (m_pInstalledServicesInfo == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto ExitHandler;
        }

    }

    else {
        
        rc = GetLastError();
        goto ExitHandler;
    }

    if (!EnumServicesStatusEx(
                             m_hScm,
                             SC_ENUM_PROCESS_INFO,
                             SERVICE_WIN32,
                             SERVICE_STATE_ALL,
                             (LPBYTE)m_pInstalledServicesInfo,
                             cbInfo,
                             &cbInfo,
                             &m_dwNumServices,
                             &dwResume,
                             NULL)) {

        rc = GetLastError();

        goto ExitHandler;
    }

    m_bArrServiceInKB = (DWORD *) LocalAlloc(LMEM_ZEROINIT, m_dwNumServices * sizeof(DWORD)); 

    if (m_bArrServiceInKB == NULL){
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;
    }

    memset(m_bArrServiceInKB, 0, m_dwNumServices * sizeof(DWORD));

ExitHandler:
    
    return rc;
}

HRESULT
process::SsrpCheckIfOptionalService(
    IN  CComPtr <IXMLDOMElement> pXMLDocElemRoot,
    IN  BSTR    bstrServiceName,
    IN  BOOL    *pbOptional
    )
/*++

Routine Description:

    Routine called to check if service is optional

Arguments:

    pXMLDocElemRoot -   root of document
    
    bstrServiceName -   name of service
    
    pbOptional  -   boolean to fill if optional or not
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr;
    CComPtr <IXMLDOMNode> pService;
    CComPtr <IXMLDOMNode> pOptional;
    CComPtr <IXMLDOMNodeList> pServiceList;

    if (pbOptional == NULL) {
        E_INVALIDARG;
    }

    *pbOptional = FALSE;

    hr = pXMLDocElemRoot->selectNodes(L"Services/Service", &pServiceList);

    if (FAILED(hr) || pServiceList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pServiceList->nextNode(&pService);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pService) {
        
        CComBSTR    bstrText;
        CComPtr <IXMLDOMNode> pName;

        hr = pService->selectSingleNode(L"Name", &pName);

        if (FAILED(hr) || pName == NULL ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pName->get_text(&bstrText);
        
        if (FAILED(hr) || !bstrText ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        if (0 == SsrpICompareBstrPwstr(bstrServiceName, bstrText)) {

            hr = pService->selectSingleNode(L"Optional", &pOptional);

            if (FAILED(hr) || pOptional == NULL ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            CComBSTR    bstrOptional;

            hr = pOptional->get_text(&bstrOptional);

            if (FAILED(hr) || !bstrOptional ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            if (0 == SsrpICompareBstrPwstr(bstrOptional, L"TRUE"))
                *pbOptional = TRUE;
            else 
                *pbOptional = FALSE;

            return hr;

        }

        pService.Release();
        
        hr = pServiceList->nextNode(&pService);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }
    
ExitHandler:    
    
    return hr;
    
}


DWORD
process::SsrpQueryServiceStartupType(
    IN  PWSTR   pszServiceName,
    OUT BYTE   *pbyStartupType
    )
/*++

Routine Description:

    Routine called to check service startup type

Arguments:

    pszServiceName  -   name of service
    
    pbyStartupType    -   startup type
    
Return:

    Win32 error code

++*/
{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwBytesNeeded = 0;
    SC_HANDLE   hService = NULL;
    LPQUERY_SERVICE_CONFIG pServiceConfig=NULL;

    if (pbyStartupType == NULL || pszServiceName == NULL)
        return ERROR_INVALID_PARAMETER;

    *pbyStartupType = SERVICE_DISABLED;

    SsrpConvertBstrToPwstr(pszServiceName);

    hService = OpenService(
                    m_hScm,
                    pszServiceName,
                    SERVICE_QUERY_CONFIG |
                    READ_CONTROL
                   );

    if ( hService == NULL ) {
        rc = GetLastError();
        goto ExitHandler;
    }

    if ( !QueryServiceConfig(
                hService,
                NULL,
                0,
                &dwBytesNeeded
                )) {

        if (ERROR_INSUFFICIENT_BUFFER != (rc = GetLastError()))
            goto ExitHandler;
    }
            
    rc = ERROR_SUCCESS;

    pServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_ZEROINIT, dwBytesNeeded);
            
    if ( pServiceConfig == NULL ) {

        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;

    }
           
    if ( !QueryServiceConfig(
        hService,
        pServiceConfig,
        dwBytesNeeded,
        &dwBytesNeeded) )
        {
        rc = GetLastError();
        goto ExitHandler;
    }

    *pbyStartupType = (BYTE)(pServiceConfig->dwStartType) ;

ExitHandler:

    if (pServiceConfig) {
        LocalFree(pServiceConfig);
    }
        
    if (hService) {
        CloseServiceHandle(hService);
    }
        
    return rc;
}


HRESULT
process::SsrpAddUnknownSection(
    IN  CComPtr <IXMLDOMElement> pElementRoot,
    IN  CComPtr <IXMLDOMDocument> pXMLDoc
    )
/*++

Routine Description:

    Routine called to add extra services

Arguments:

    pElementRoot    -   the root element pointer
    
    pXMLDoc -   document pointer
    
Return:

    HRESULT error code

++*/
{
    CComPtr <IXMLDOMNode> pNewChild;
    CComPtr <IXMLDOMNode> pXDNodeUnknownNode;
    CComPtr <IXMLDOMNode> pXDNodeServices;
    CComPtr <IXMLDOMNode> pXDNodeName;
    CComPtr <IXMLDOMNode> pXDNodeSatisfiable;
    CComPtr <IXMLDOMNode> pXDNodeSelected;
    CComPtr <IXMLDOMNode> pXDNodeRole;
    CComPtr <IXMLDOMNodeList> pRolesList;
    CComPtr <IXMLDOMNode> pRole;
    BOOL    bOtherRolePresent = FALSE;
    LPSERVICE_DESCRIPTION   pServiceDescription = NULL;
    CComPtr <IXMLDOMNode> pServicesNode;

    CComVariant Type(NODE_ELEMENT);
    CComVariant vtRefChild;

    HRESULT hr;
    DWORD   rc = ERROR_SUCCESS;


    hr = pXMLDoc->createNode(
                            Type,
                            L"Unknown",
                            NULL,
                            &pXDNodeUnknownNode);

    if (FAILED(hr) || pXDNodeUnknownNode == NULL) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = SsrpAddWhiteSpace(
        pXMLDoc,
        pXDNodeUnknownNode,
        L"\n\t\t\t"
        );

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pXMLDoc->createNode(
                            Type,
                            L"Services",
                            NULL,
                            &pXDNodeServices);

    if (FAILED(hr) || pXDNodeServices == NULL) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXDNodeUnknownNode->appendChild(pXDNodeServices, NULL);

    if (FAILED(hr) ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = SsrpAddWhiteSpace(
        pXMLDoc,
        pXDNodeUnknownNode,
        L"\n\t\t\t\t\t"
        );
        
    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    for (DWORD ServiceIndex=0; 
         ServiceIndex < m_dwNumServices; 
         ServiceIndex++ ) {

        
        if (m_bArrServiceInKB[ServiceIndex] == 0){ 

            CComPtr <IXMLDOMNode> pXDNodeService;
            CComPtr <IXMLDOMNode> pXDNodeServiceName;
            CComPtr <IXMLDOMNode> pXDNodeServiceDescription;
            CComPtr <IXMLDOMNode> pXDNodeServiceDisplayName;
            CComPtr <IXMLDOMNode> pXDNodeServiceMaximum;
            CComPtr <IXMLDOMNode> pXDNodeServiceTypical;


            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeServices,
                L"\n\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Service",
                                    NULL,
                                    &pXDNodeService);

            if (FAILED(hr) || pXDNodeService == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            

            hr = pXDNodeServices->appendChild(pXDNodeService, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Name",
                                    NULL,
                                    &pXDNodeServiceName);

            if (FAILED(hr) || pXDNodeServiceName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeServiceName->put_text(m_pInstalledServicesInfo[ServiceIndex].lpServiceName);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceName, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
/*            hr = pXMLDoc->createNode(
                                    Type,
                                    L"DisplayName",
                                    NULL,
                                    &pXDNodeServiceDisplayName);

            if (FAILED(hr) || pXDNodeServiceDisplayName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeServiceDisplayName->put_text(m_pInstalledServicesInfo[ServiceIndex].lpDisplayName);
                                                     
            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceDisplayName, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Description",
                                    NULL,
                                    &pXDNodeServiceDescription);

            if (FAILED(hr) || pXDNodeServiceDescription == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            rc = SsrpQueryServiceDescription(m_pInstalledServicesInfo[ServiceIndex].lpServiceName,
                                             &pServiceDescription);

            if (rc != ERROR_SUCCESS ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
                        
            hr = pXDNodeServiceDescription->put_text(
                (pServiceDescription == NULL) ? L"" : pServiceDescription->lpDescription);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            if (pServiceDescription) {
                LocalFree(pServiceDescription);
                pServiceDescription = NULL;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceDescription, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeServiceDescription,
                L"\n\t\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }            
*/
        }
        
    }


    hr = pElementRoot->selectSingleNode(L"Services", &pServicesNode);

    if (FAILED(hr) || pServicesNode == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    vtRefChild = pServicesNode;

    hr = pElementRoot->insertBefore(pXDNodeUnknownNode,
                                 vtRefChild,
                                 NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

ExitHandler:

    return hr;

}


HRESULT
process::SsrpAddUnknownServicesInfoToServiceLoc(
    IN  CComPtr <IXMLDOMElement> pElementRoot,
    IN  CComPtr <IXMLDOMDocument> pXMLDoc
    )
/*++

Routine Description:

    Routine called to add unknown service display and description to 
    <Service Localization>

Arguments:

    pElementRoot    -   the root element pointer
    
    pXMLDoc -   document pointer
    
Return:

    HRESULT error code

++*/
{
    CComPtr <IXMLDOMNode> pNewChild;
    CComPtr <IXMLDOMNode> pXDNodeUnknownNode;
    CComPtr <IXMLDOMNode> pXDNodeServices;
    CComPtr <IXMLDOMNode> pXDNodeName;
    CComPtr <IXMLDOMNode> pXDNodeSatisfiable;
    CComPtr <IXMLDOMNode> pXDNodeSelected;
    CComPtr <IXMLDOMNode> pXDNodeRole;
    CComPtr <IXMLDOMNodeList> pRolesList;
    CComPtr <IXMLDOMNode> pRole;
    BOOL    bOtherRolePresent = FALSE;
    LPSERVICE_DESCRIPTION   pServiceDescription = NULL;
    CComPtr <IXMLDOMNode> pServicesNode;

    CComPtr <IXMLDOMNode> pServiceLoc;
        
    CComVariant Type(NODE_ELEMENT);
    CComVariant vtRefChild;

    HRESULT hr;
    DWORD   rc = ERROR_SUCCESS;


    //
    // get the "ServiceLocalization" section node
    //

    hr = pElementRoot->selectSingleNode(L"ServiceLocalization", &pServiceLoc);

    if (FAILED(hr) || pServiceLoc == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    for (DWORD ServiceIndex=0; 
         ServiceIndex < m_dwNumServices; 
         ServiceIndex++ ) {

        if (m_bArrServiceInKB[ServiceIndex] == 0){ 

            CComPtr <IXMLDOMNode> pXDNodeService;
            CComPtr <IXMLDOMNode> pXDNodeServiceName;
            CComPtr <IXMLDOMNode> pXDNodeServiceDescription;
            CComPtr <IXMLDOMNode> pXDNodeServiceDisplayName;
            CComPtr <IXMLDOMNode> pXDNodeServiceMaximum;
            CComPtr <IXMLDOMNode> pXDNodeServiceTypical;

            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Service",
                                    NULL,
                                    &pXDNodeService);

            if (FAILED(hr) || pXDNodeService == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pServiceLoc->appendChild(pXDNodeService, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Name",
                                    NULL,
                                    &pXDNodeServiceName);

            if (FAILED(hr) || pXDNodeServiceName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeServiceName->put_text(m_pInstalledServicesInfo[ServiceIndex].lpServiceName);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceName, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"DisplayName",
                                    NULL,
                                    &pXDNodeServiceDisplayName);

            if (FAILED(hr) || pXDNodeServiceDisplayName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeServiceDisplayName->put_text(m_pInstalledServicesInfo[ServiceIndex].lpDisplayName);
                                                     
            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceDisplayName, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Description",
                                    NULL,
                                    &pXDNodeServiceDescription);

            if (FAILED(hr) || pXDNodeServiceDescription == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            rc = SsrpQueryServiceDescription(m_pInstalledServicesInfo[ServiceIndex].lpServiceName,
                                             &pServiceDescription);

            if (rc != ERROR_SUCCESS ) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
                        
            hr = pXDNodeServiceDescription->put_text(
                (pServiceDescription == NULL) ? L"" : pServiceDescription->lpDescription);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            if (pServiceDescription) {
                LocalFree(pServiceDescription);
                pServiceDescription = NULL;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceDescription, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeServiceDescription,
                L"\n\t\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }            

        }
        
    }



ExitHandler:

    return hr;

}

BOOL
process::SsrpIsServiceInstalled(
    IN  BSTR   bstrService
    )
/*++

Routine Description:

    Routine called to check if service is installed

Arguments:

    bstrService -  service name
    
Return:

    TRUE if installed, FALSE otherwise

++*/
{
    if (bstrService) {
        
        for (DWORD ServiceIndex=0; ServiceIndex < m_dwNumServices; ServiceIndex++ ) {
            if (m_pInstalledServicesInfo[ServiceIndex].lpServiceName && 
                0 == SsrpICompareBstrPwstr(bstrService, m_pInstalledServicesInfo[ServiceIndex].lpServiceName)) {
                
                if (m_bDbg) 
                    wprintf(L"SERVICE is installed: %s\n", bstrService);
                m_bArrServiceInKB[ServiceIndex] = 1;
                return TRUE;
            }
        }
    }
    return FALSE;
}




HRESULT
process::SsrpAddServiceStartup(
    IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
    IN CComPtr <IXMLDOMDocument> pXMLDoc
    )
/*++

Routine Description:

    Routine called to add service startup mode

Arguments:

    pXMLDoc -   document pointer
    
    pXMLDoc  -   pointer to document
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr;
    CComPtr <IXMLDOMNode> pService;
    CComPtr <IXMLDOMNode> pOptional;
    CComPtr <IXMLDOMNodeList> pServiceList;
    CComVariant Type(NODE_ELEMENT);
    WCHAR   szStartup[15];

    hr = pXMLDocElemRoot->selectNodes(L"Services/Service", &pServiceList);

    if (FAILED(hr) || pServiceList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pServiceList->nextNode(&pService);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    while (pService) {
        
        CComBSTR    bstrText;
        CComPtr <IXMLDOMNode> pName;
        CComPtr <IXMLDOMNode> pXDNodeServiceStartup;
        CComPtr <IXMLDOMNode> pXDNodeServiceInstalled;

        hr = pService->selectSingleNode(L"Name", &pName);

        if (FAILED(hr) || pName == NULL ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
        
        hr = pName->get_text(&bstrText);
        
        if (FAILED(hr) || !bstrText ) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        BYTE    byStartupType = FALSE;
        BOOL    bIsServiceInstalled = FALSE;
        DWORD   rc = ERROR_SUCCESS;

        bIsServiceInstalled = SsrpIsServiceInstalled(bstrText);
        
        if (bIsServiceInstalled) {

            rc = SsrpQueryServiceStartupType(bstrText, &byStartupType);
            
            if ( rc != ERROR_SUCCESS) {

                //wprintf(L"\nName is %s error %d", bstrText, rc);
                goto ExitHandler;
            }
            
            if (byStartupType == SERVICE_DISABLED) {
                wcscpy(szStartup, L"Disabled");
            }
            else if (byStartupType == SERVICE_AUTO_START) {
                wcscpy(szStartup, L"Automatic");
            }
            else if (byStartupType == SERVICE_DEMAND_START) {
                wcscpy(szStartup, L"Manual");
            }
            else if (byStartupType == SERVICE_DEMAND_START) {
                wcscpy(szStartup, L"");
            }

            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Current_startup",
                                    NULL,
                                    &pXDNodeServiceStartup);

            if (FAILED(hr) || pXDNodeServiceStartup == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeServiceStartup->put_text(szStartup);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pService->appendChild(pXDNodeServiceStartup, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
        }


        hr = pXMLDoc->createNode(
                                Type,
                                L"Installed",
                                NULL,
                                &pXDNodeServiceInstalled);


        if (FAILED(hr) || pXDNodeServiceInstalled == NULL) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        hr = pXDNodeServiceInstalled->put_text((bIsServiceInstalled ? L"TRUE" : L"FALSE"));


        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        hr = pService->appendChild(pXDNodeServiceInstalled, NULL);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }

        pService.Release();
        
        hr = pServiceList->nextNode(&pService);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }
    
ExitHandler:    
    
    return hr;
    
}


HRESULT
process::SsrpAddUnknownServicestoServices(
    IN CComPtr <IXMLDOMElement> pXMLDocElemRoot, 
    IN CComPtr <IXMLDOMDocument> pXMLDoc
    )
/*++

Routine Description:

    Routine called to add unknown services to <Services> in the following way
    
            <Service>
                  <Name> Browser </Name>
                  <Optional> TRUE </Optional>  [This would always be set to TRUE]
                  <Startup_Default> Manual </Startup_Default> [This would be set to whatever the current startup mode is]
                  <Current_startup xmlns="">Manual</Current_startup>
                <Installed xmlns="">TRUE</Installed> [THIS would always be set to TRUE]
            </Service>
    
    

Arguments:

    pXMLDoc -   document pointer
    
    pXMLDoc  -   pointer to document
    
Return:

    HRESULT error code

++*/
{
    HRESULT hr;
    CComPtr <IXMLDOMNode> pServices;
    CComPtr <IXMLDOMNode> pOptional;
    CComPtr <IXMLDOMNodeList> pServiceList;
    CComVariant Type(NODE_ELEMENT);
    WCHAR   szStartup[15];

    hr = pXMLDocElemRoot->selectSingleNode(L"Services", &pServices);

    if (FAILED(hr) || pServices == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    for (DWORD ServiceIndex=0; 
         ServiceIndex < m_dwNumServices; 
         ServiceIndex++ ) {

        if (m_bArrServiceInKB[ServiceIndex] == 0){ 

            CComPtr <IXMLDOMNode> pXDNodeService;
            CComPtr <IXMLDOMNode> pXDNodeServiceName;
            CComPtr <IXMLDOMNode> pXDNodeServiceDescription;
            CComPtr <IXMLDOMNode> pXDNodeServiceDisplayName;
            CComPtr <IXMLDOMNode> pXDNodeServiceMaximum;
            CComPtr <IXMLDOMNode> pXDNodeServiceTypical;
            CComPtr <IXMLDOMNode> pXDNodeInstalled;
            CComPtr <IXMLDOMNode> pXDNodeCurrentStartup;



            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pServices,
                L"\n\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Service",
                                    NULL,
                                    &pXDNodeService);

            if (FAILED(hr) || pXDNodeService == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            

            hr = pServices->appendChild(pXDNodeService, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Name",
                                    NULL,
                                    &pXDNodeServiceName);

            if (FAILED(hr) || pXDNodeServiceName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeServiceName->put_text(m_pInstalledServicesInfo[ServiceIndex].lpServiceName);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceName, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Optional",
                                    NULL,
                                    &pXDNodeServiceDisplayName);

            if (FAILED(hr) || pXDNodeServiceDisplayName == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeServiceDisplayName->put_text(L"TRUE");
                                                     
            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeServiceDisplayName, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Startup_Default",
                                    NULL,
                                    &pXDNodeServiceDescription);

            if (FAILED(hr) || pXDNodeServiceDescription == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Current_Startup",
                                    NULL,
                                    &pXDNodeCurrentStartup);

            if (FAILED(hr) || pXDNodeCurrentStartup == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            BYTE    byStartupType = SERVICE_DISABLED;
            DWORD   rc = ERROR_SUCCESS;

            rc = SsrpQueryServiceStartupType(m_pInstalledServicesInfo[ServiceIndex].lpServiceName, &byStartupType);

            if ( rc != ERROR_SUCCESS) {

                //wprintf(L"\nName is %s error %d", m_pInstalledServicesInfo[ServiceIndex].lpServiceName, rc);
                goto ExitHandler;
            }
            
            if (byStartupType == SERVICE_DISABLED) {
                wcscpy(szStartup, L"Disabled");
            }
            else if (byStartupType == SERVICE_AUTO_START) {
                wcscpy(szStartup, L"Automatic");
            }
            else if (byStartupType == SERVICE_DEMAND_START) {
                wcscpy(szStartup, L"Manual");
            }
            else if (byStartupType == SERVICE_DEMAND_START) {
                wcscpy(szStartup, L"");
            }
                        
            hr = pXDNodeServiceDescription->put_text(szStartup);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeCurrentStartup->put_text(szStartup);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeService->appendChild(pXDNodeServiceDescription, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

            hr = pXDNodeService->appendChild(pXDNodeCurrentStartup, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXMLDoc->createNode(
                                    Type,
                                    L"Installed",
                                    NULL,
                                    &pXDNodeInstalled);

            if (FAILED(hr) || pXDNodeInstalled == NULL) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeInstalled->put_text(L"TRUE");
                                                     
            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = pXDNodeService->appendChild(pXDNodeInstalled, NULL);

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }
            
            hr = SsrpAddWhiteSpace(
                pXMLDoc,
                pXDNodeService,
                L"\n\t\t\t\t\t\t"
                );

            if (FAILED(hr)) {

                SsrpLogParseError(hr);
                goto ExitHandler;
            }

        }

    }

ExitHandler:    
    
    return hr;
    

}

DWORD
process::SsrpQueryServiceDescription(
    IN  PWSTR   pszServiceName,
    OUT LPSERVICE_DESCRIPTION *ppServiceDescription
    )
/*++

Routine Description:

    Routine called to get service description

Arguments:

    pszServiceName  -   name of service
    
    ppServiceDescription    -  description structure (to be freed outside)
    
Return:

    Win32 error code

++*/
{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwBytesNeeded = 0;
    SC_HANDLE   hService = NULL;
    LPSERVICE_DESCRIPTION pServiceDescription = NULL;

    if (ppServiceDescription == NULL || pszServiceName == NULL)
        return ERROR_INVALID_PARAMETER;

    *ppServiceDescription = NULL;

    SsrpConvertBstrToPwstr(pszServiceName);

    hService = OpenService(
                    m_hScm,
                    pszServiceName,
                    SERVICE_QUERY_CONFIG |
                    READ_CONTROL
                   );

    if ( hService == NULL ) {
        rc = GetLastError();
        goto ExitHandler;
    }

    if ( !QueryServiceConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                NULL,
                0,
                &dwBytesNeeded
                )) {

        if (ERROR_INSUFFICIENT_BUFFER != (rc = GetLastError()))
            goto ExitHandler;
    }
            
    rc = ERROR_SUCCESS;

    pServiceDescription = (LPSERVICE_DESCRIPTION)LocalAlloc(LMEM_ZEROINIT, dwBytesNeeded);
            
    if ( pServiceDescription == NULL ) {

        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;

    }
           
    if ( !QueryServiceConfig2(
                hService,
                SERVICE_CONFIG_DESCRIPTION,
                (LPBYTE)pServiceDescription,
                dwBytesNeeded,
                &dwBytesNeeded
                )) {

        LocalFree(pServiceDescription);
        pServiceDescription = NULL;
        
        rc = GetLastError();
        goto ExitHandler;
    }
        
    *ppServiceDescription = pServiceDescription;

ExitHandler:
        
    if (hService) {
        CloseServiceHandle(hService);
    }

    return rc;
}

        
PWSTR
process::SsrpQueryServiceDisplayName(
    IN  BSTR   bstrService
    )
/*++

Routine Description:

    Routine called to get service display name

Arguments:

    pszServiceName  -   name of service
    
Return:

    pointer to display name string

++*/
{

    for (DWORD ServiceIndex=0; ServiceIndex < m_dwNumServices; ServiceIndex++ ) {
        if (m_pInstalledServicesInfo[ServiceIndex].lpServiceName && 
            0 == SsrpICompareBstrPwstr(bstrService, m_pInstalledServicesInfo[ServiceIndex].lpServiceName)) {
            return m_pInstalledServicesInfo[ServiceIndex].lpDisplayName;
        }
    }
    
    return NULL;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\sections.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    sections.cpp

Abstract:

    This module implements routines for section
    specific SSR Knowledge Base processing.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/

#include "stdafx.h"
#include "kbproc.h"
#include "process.h"

HRESULT 
process::SsrpCreatePreprocessorSection(
    IN  CComPtr<IXMLDOMElement> pXMLDocElemRoot, 
    IN  CComPtr<IXMLDOMDocument> pXMLDocIn,
    IN  PWSTR pszKbMode,
    IN  PWSTR pszKBDir)
/*++

Routine Description:

    Routine called to process all roles

Arguments:

    pXMLDocElemRoot     -   root of document
    
    pXMLDoc             -   KB document
    
    pszKbMode           -   mode value
    
    pszKBDir           -   KB directory name

Return:

    HRESULT error code

++*/
{
    HRESULT hr = S_OK;
    DWORD rc;

    BSTR    bstrLevelName;
    CComVariant Type(NODE_ELEMENT);
    CComVariant vtRefChild;
    
    CComPtr<IXMLDOMNodeList> pResultList;
    CComPtr<IXMLDOMNode> pSecurityLevels;
    CComPtr<IXMLDOMNode> pPreprocessorNode;
    CComPtr<IXMLDOMNode> pManufacturerNode;
    CComPtr<IXMLDOMNode> pVersionNode;
    CComPtr<IXMLDOMNode> pInputsNode;
    CComPtr<IXMLDOMNode> pKBNode;
    CComPtr<IXMLDOMNode> pLevelNode;
    CComPtr<IXMLDOMNode> pPolicyNode;
        
    CComPtr<IXMLDOMNode>  pXDNodeCreate;
    CComPtr<IXMLDOMNode>  pXMLNameNode;
    
    //
    // get all the Level names since we need to validate the passed in level name
    //

    hr = pXMLDocElemRoot->selectNodes(L"SecurityLevels/Level/Name", &pResultList);

    if (FAILED(hr) || pResultList == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pResultList->nextNode(&pXMLNameNode);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    BOOL bModeIsValid = FALSE;
    
    while (pXMLNameNode && bModeIsValid == FALSE) {

        pXMLNameNode->get_text(&bstrLevelName);

        if ( 0 == SsrpICompareBstrPwstr(bstrLevelName, pszKbMode )) {

            bModeIsValid = TRUE;
            
        }

        pXMLNameNode.Release();

        hr = pResultList->nextNode(&pXMLNameNode);

        if (FAILED(hr)) {

            SsrpLogParseError(hr);
            goto ExitHandler;
        }
    }

    if (bModeIsValid == FALSE) {

        SsrpLogError(L"The mode value is incorrect\n");

        hr = E_INVALIDARG;
        goto ExitHandler;

    }       
    
    hr = pXMLDocIn->createNode(
                            Type,
                            L"Preprocessor",
                            NULL,
                            &pPreprocessorNode);

    if (FAILED(hr) || pPreprocessorNode == NULL) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocIn->createNode(
                            Type,
                            L"Manufacturer",
                            NULL,
                            &pManufacturerNode);

    hr = pManufacturerNode->put_text(L"Microsoft");

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pPreprocessorNode->appendChild(pManufacturerNode, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocIn->createNode(
                            Type,
                            L"Version",
                            NULL,
                            &pVersionNode);

    hr = pVersionNode->put_text(L"1.0");

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pPreprocessorNode->appendChild(pVersionNode, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocIn->createNode(
                            Type,
                            L"Inputs",
                            NULL,
                            &pInputsNode);
    
    hr = pXMLDocIn->createNode(
                            Type,
                            L"KnowledgeBase",
                            NULL,
                            &pKBNode);

    hr = pKBNode->put_text(pszKBDir);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pInputsNode->appendChild(pKBNode, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }


    hr = pXMLDocIn->createNode(
                            Type,
                            L"SecurityLevel",
                            NULL,
                            &pLevelNode);

    hr = pKBNode->put_text(pszKbMode);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pInputsNode->appendChild(pLevelNode, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocIn->createNode(
                            Type,
                            L"Policy",
                            NULL,
                            &pPolicyNode);

    hr = pKBNode->put_text(L"");

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }
    
    hr = pInputsNode->appendChild(pPolicyNode, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pPreprocessorNode->appendChild(pInputsNode, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocElemRoot->selectSingleNode(L"SecurityLevels", &pSecurityLevels);

    if (FAILED(hr) || pSecurityLevels == NULL ) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    vtRefChild = pSecurityLevels;

    hr = pXMLDocElemRoot->insertBefore(pPreprocessorNode,
                                 vtRefChild,
                                 NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

    hr = pXMLDocElemRoot->removeChild(pSecurityLevels, NULL);

    if (FAILED(hr)) {

        SsrpLogParseError(hr);
        goto ExitHandler;
    }

ExitHandler:
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\stdafx.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    stdafx.cpp

Abstract:

    source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

Revision History:

    Created - Oct 2001

--*/


#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\stdafx.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

    Exported as a COM Interface

Revision History:

    Created - Oct 2001

--*/

#if !defined(AFX_STDAFX_H__9188383B_1754_4EF5_98CC_255E72747641__INCLUDED_)
#define AFX_STDAFX_H__9188383B_1754_4EF5_98CC_255E72747641__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9188383B_1754_4EF5_98CC_255E72747641__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\kbproc\test\test.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <comdef.h>
#include <msxml2.h>
#include <winsvc.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include "..\obj\i386\kbproc.h"
#include "..\obj\i386\kbproc_i.c"
#include "..\process.h"


int __cdecl wmain(int argc, wchar_t *argv[])
{
    HRESULT hr;
    DWORD   rc;
    WCHAR   szKB[MAX_PATH+30];
    WCHAR   szMain[MAX_PATH+30];

    if ( !GetSystemWindowsDirectory(szKB, MAX_PATH + 1) ) {
        wprintf(L"Error GetSystemWindowsDirectory() %d \n", GetLastError());
        return 0;
    }

    wcscat(szKB, L"\\security\\ssr\\kbs\\DotNetKB.xml");

    if ( !GetSystemWindowsDirectory(szMain, MAX_PATH + 1) ) {
        wprintf(L"Error GetSystemWindowsDirectory() %d \n", GetLastError());
        return 0;
    }
    
    wcscat(szMain, L"\\security\\ssr\\kbs\\Main.xml");

    hr = CoInitialize(NULL); 

    if (FAILED(hr)) {

        wprintf(L"\nCOM failed to initialize\n");
        
        return 0;
    }

    Iprocess    *pPreProc;

    //
    // instantiate the DOM document object to process the KB
    //

    hr = CoCreateInstance(CLSID_process, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_Iprocess, 
                          (void**)&pPreProc);

    VARIANT vtFeedback;

    VariantInit(&vtFeedback);

    vtFeedback.vt = VT_NULL;
    vtFeedback.punkVal = NULL;


    if (FAILED(hr) || pPreProc == NULL ) {

        wprintf(L"\nCOM failed to create a PreProc instance\n");
        
        goto ExitHandler;
    }

    hr = pPreProc->preprocess(szKB, szMain, L"Typical", L"ssr.log", NULL, vtFeedback);

    hr = pPreProc->Release();

    if (FAILED(hr) ) {

        wprintf(L"\nUnable to get the PreProc interface\n");
        goto ExitHandler;
    }
    

ExitHandler:
    
    CoUninitialize(); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\svcapis\svcapisrc.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    svcdllrc.h

Abstract:

    This module defines resource IDs for strings

Author:

    Vishnu Patankar (VishnuP)

Revision History:

--*/
#ifndef __scedllrc__
#define __scedllrc__

#define SVCAPIS_GENERIC_ERROR   100

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\svcapis\svcapis.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    svcapis.cpp

Abstract:

    This module implements routines to assist 
    CUSTOM Mode Value SSR Knowledge Base processing.

Author:

    Vishnu Patankar (VishnuP) - Oct 2001

Environment:

    User mode only.

Exported Functions:

    svcapis.def

Revision History:

    Created - Oct 2001

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <comdef.h>
#include <msxml2.h>
#include <winsvc.h>
#include <ntlsa.h>
#include <Lmshare.h>
#include <Lmapibuf.h>
#include <lmerr.h>
#include <winsta.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include <iptypes.h>
#include <wbemcli.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>

#include <regapi.h>
#include <initguid.h>
#include <ole2.h>
#include <mstask.h>
#include <msterr.h>
#include <wchar.h>
#include <dsrole.h>

typedef DWORD (WINAPI *PFGETDOMAININFO)(LPCWSTR, DSROLE_PRIMARY_DOMAIN_INFO_LEVEL, PBYTE *);
typedef VOID (WINAPI *PFDSFREE)( PVOID );
typedef BOOLEAN (WINAPI *PFREMOTEASSISTANCEENABLED)(VOID);


DWORD
SvcapispQueryServiceStartupType(
    IN  PWSTR   pszMachineName,
    IN  PWSTR   pszServiceName,
    OUT BYTE   *pbyStartupType
    );

HRESULT
SvcapispGetRemoteOSVersionInfo(
    IN  PWSTR   pszMachineName, 
    OUT OSVERSIONINFOEX *posVersionInfo
    );


BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN ULONG ulReason,
    IN LPVOID Reserved 
    )
/*++

Routine Description:

    Typical DllMain functionality

Arguments:

    DllHandle
    
    ulReason
    
    Reserved

Return:

    TRUE if successfully initialized, FALSE otherwise
    
--*/
{

    switch(ulReason) {

    case DLL_PROCESS_ATTACH:

        //
        // Fall through to process first thread
        //

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;
}

STDAPI DllRegisterServer(
    void
    )
/*++

Routine Description:

    Registers dll

Arguments:

Return:

    S_OK if successful
    
--*/
{

    return S_OK;
}

STDAPI 
DllUnregisterServer(
    void
    )
/*++

Routine Description:

    Unregisters dll

Arguments:

Return:

    S_OK if successful
    
--*/

{
    return S_OK;
}

DWORD
SvcapispQueryServiceStartupType(
    IN  PWSTR   pszMachineName,
    IN  PWSTR   pszServiceName,
    OUT BYTE   *pbyStartupType
    )
/*++

Routine Description:

    Routine called to check service startup type

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pszServiceName  -   name of service
    
    pbyStartupType    -   startup type
    
Return:

    Win32 error code

++*/
{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwBytesNeeded = 0;
    SC_HANDLE   hService = NULL;
    LPQUERY_SERVICE_CONFIG pServiceConfig=NULL;
    SC_HANDLE   hScm = NULL;

    if (pbyStartupType == NULL || pszServiceName == NULL){
        return ERROR_INVALID_PARAMETER;
    }

    *pbyStartupType = SERVICE_DISABLED;

    hScm = OpenSCManager(
                        pszMachineName,
                        NULL,
                        GENERIC_READ);
    
    if (hScm == NULL) {

        rc = GetLastError();
        goto ExitHandler;
    }
    
    hService = OpenService(
                          hScm,
                          pszServiceName,
                          SERVICE_QUERY_CONFIG |
                          READ_CONTROL
                          );

    if ( hService == NULL ) {
        rc = GetLastError();
        goto ExitHandler;
    }

    if ( !QueryServiceConfig(
                            hService,
                            NULL,
                            0,
                            &dwBytesNeeded
                            )) {

        if (ERROR_INSUFFICIENT_BUFFER != (rc = GetLastError())){
            goto ExitHandler;
        }
    }
            
    rc = ERROR_SUCCESS;

    pServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_ZEROINIT, dwBytesNeeded);
            
    if ( pServiceConfig == NULL ) {

        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;

    }
           
    if ( !QueryServiceConfig(
                            hService,
                            pServiceConfig,
                            dwBytesNeeded,
                            &dwBytesNeeded) )
        {
        rc = GetLastError();
        goto ExitHandler;
    }

    *pbyStartupType = (BYTE)(pServiceConfig->dwStartType) ;

ExitHandler:

    if (pServiceConfig) {
        LocalFree(pServiceConfig);
    }
        
    if (hService) {
        CloseServiceHandle(hService);
    }
        
    if (hScm) {
        CloseServiceHandle(hScm);
    }
    
    return rc;
}

DWORD 
SvcapisIsDomainMember(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsDomainMember
    )
/*++

Routine Description:

    Detects if machine is joined to a domain

Arguments:

    pszMachineName  -   name of machine to evaluate function on

    pbIsDomainMember    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    NTSTATUS                    NtStatus;
    PPOLICY_DNS_DOMAIN_INFO     pDnsDomainInfo=NULL;
    LSA_HANDLE                  LsaHandle=NULL;
    LSA_OBJECT_ATTRIBUTES       attributes;
    SECURITY_QUALITY_OF_SERVICE service;
    UNICODE_STRING  uMachineName;

    if (pbIsDomainMember == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsDomainMember = FALSE;

    //
    // Open the LSA policy first
    //

    memset( &attributes, 0, sizeof(attributes) );
    attributes.Length = sizeof(attributes);
    attributes.SecurityQualityOfService = &service;
    service.Length = sizeof(service);
    service.ImpersonationLevel= SecurityImpersonation;
    service.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    service.EffectiveOnly = TRUE;

    RtlInitUnicodeString(&uMachineName, pszMachineName);

    NtStatus = LsaOpenPolicy(
                            pszMachineName ? &uMachineName: NULL,
                            &attributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                            );

    if ( !NT_SUCCESS( NtStatus) ) {
        goto ExitHandler;
    }
        
    //
    // query primary domain DNS information
    //
        
    NtStatus = LsaQueryInformationPolicy(
                                        LsaHandle,                        
                                        PolicyDnsDomainInformation,
                                        (PVOID *)&pDnsDomainInfo
                                        );
        
    if ( !NT_SUCCESS( NtStatus) || pDnsDomainInfo == NULL) {
        goto ExitHandler;
    }

    if (pDnsDomainInfo->Sid){
        *pbIsDomainMember = TRUE;
    }

ExitHandler:
    
    if (pDnsDomainInfo){
        LsaFreeMemory(pDnsDomainInfo);
    }

    if (LsaHandle){
        LsaClose( LsaHandle );
    }

    return(RtlNtStatusToDosError(NtStatus));
}


DWORD 
SvcapisDoPrintSharesExist(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbPrintSharesExist
    )
/*++

Routine Description:

    Detects if print shares exist on machine

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbPrintSharesExist    -   pointer to boolean to fill

Return:

    Win32/NetApi error code
    
--*/

{
	NET_API_STATUS NetStatus;
	DWORD ParmError = 0;
	DWORD Status = ERROR_SUCCESS;
	LPBYTE Buffer = NULL;
	DWORD EntriesRead = 0;
	DWORD TotalEntries = 0;
    LPSHARE_INFO_1  pShareInfo = NULL;

    if (pbPrintSharesExist == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbPrintSharesExist = FALSE;
	
    NetStatus =  NetShareEnum(
                             pszMachineName,     
                             1,           
                             &Buffer,        
                             MAX_PREFERRED_LENGTH,      
                             &EntriesRead,   
                             &TotalEntries,  
                             NULL 
                             );

	if (NetStatus != NERR_Success || 
        EntriesRead == 0 ||
        Buffer == NULL)
	{
		goto ExitHandler;
	}

    pShareInfo = (LPSHARE_INFO_1)Buffer;

    for (ULONG  uIndex=0; uIndex < EntriesRead; uIndex++) {
        if (pShareInfo[uIndex].shi1_type == STYPE_PRINTQ){
            *pbPrintSharesExist = TRUE;
            break;
        }
    }

ExitHandler:

	if (Buffer) {
        NetApiBufferFree(Buffer);
    }

	return NetStatus;
}


DWORD 
SvcapisIsRemoteAssistanceEnabled(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsRemoteAssistanceEnabled
    )
/*++

Routine Description:

    Detects if remote assistance is enabled on machine

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsRemoteAssistanceEnabled    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;
    OSVERSIONINFOEX osVersionInfo;

    if (pbIsRemoteAssistanceEnabled == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
        
    if (!GetVersionEx((LPOSVERSIONINFOW)&osVersionInfo)) {
            
        rc = GetLastError();
        return E_INVALIDARG;
    }

    if (osVersionInfo.dwMajorVersion == 5 && 
        osVersionInfo.dwMajorVersion < 1) {

        //
        // remote assistance available on > w2k
        //

        return S_OK;

    }


    
    HRESULT             hr = S_OK;
    
    CComPtr <IWbemLocator>  pWbemLocator = NULL;
    CComPtr <IWbemServices> pWbemServices = NULL;
    CComPtr <IWbemClassObject>  pWbemTsObjectInstance = NULL;
    CComPtr <IEnumWbemClassObject>  pWbemEnumObject = NULL;
    CComBSTR    bstrMachineAndNamespace; 
    ULONG  nReturned = 0;
    
    bstrMachineAndNamespace = pszMachineName;
    bstrMachineAndNamespace += L"\\root\\cimv2";

    hr = CoCreateInstance(
                         CLSID_WbemLocator, 
                         0, 
                         CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator, 
                         (LPVOID *) &pWbemLocator
                         );

    if (FAILED(hr) || pWbemLocator == NULL ) {

        goto ExitHandler;
    }

    hr = pWbemLocator->ConnectServer(
                                bstrMachineAndNamespace,
                                NULL, 
                                NULL, 
                                NULL, 
                                0L,
                                NULL,
                                NULL,
                                &pWbemServices
                                );

    if (FAILED(hr) || pWbemServices == NULL ) {

        goto ExitHandler;
    }

    hr = CoSetProxyBlanket(
                          pWbemServices,
                          RPC_C_AUTHN_WINNT,
                          RPC_C_AUTHZ_NONE,
                          NULL,
                          RPC_C_AUTHN_LEVEL_PKT,
                          RPC_C_IMP_LEVEL_IMPERSONATE,
                          NULL, 
                          EOAC_NONE
                          );

    if (FAILED(hr)) {

        goto ExitHandler;
    }
        
    hr = pWbemServices->ExecQuery(CComBSTR(L"WQL"),
                                 CComBSTR(L"SELECT * FROM Win32_TerminalServiceSetting"),
                                 WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                 NULL,
                                 &pWbemEnumObject);

    if (FAILED(hr) || pWbemEnumObject == NULL) {

        goto ExitHandler;
    }

    hr = pWbemEnumObject->Next(WBEM_INFINITE, 1, &pWbemTsObjectInstance, &nReturned);

    if (FAILED(hr) || pWbemTsObjectInstance == NULL) {

        goto ExitHandler;
    }

    VARIANT vHelp;

    VariantInit(&vHelp); 

    hr = pWbemTsObjectInstance->Get(CComBSTR(L"Help"), 
                            0,
                            &vHelp, 
                            NULL, 
                            NULL);


    if (FAILED(hr)) {

        goto ExitHandler;
    }

    if (V_VT(&vHelp) == VT_NULL) {

        goto ExitHandler;

    }

    ULONG  uHelp = V_INT(&vHelp);

    if (uHelp) {

        *pbIsRemoteAssistanceEnabled = TRUE;

    }


ExitHandler:
    
    if (V_VT(&vHelp) != VT_NULL) {
        VariantClear( &vHelp );
    }

    return hr;

}


DWORD 
SvcapisIsWINSClient(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsWINSClient
    )
/*++

Routine Description:

    Detects if machine is a WINS client

Arguments:

    pszMachineName  -   name of machine to evaluate function on (this API is not remotable)
    
    pbIsWINSClient    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    ULONG   ulSize = 0;
    DWORD   rc = ERROR_SUCCESS;
    PIP_ADAPTER_INFO    pAdapterInfo = NULL;

    if (pbIsWINSClient == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pszMachineName != NULL) {
        return ERROR_CALL_NOT_IMPLEMENTED;
    }
    
    *pbIsWINSClient = FALSE;

    rc = GetAdaptersInfo(
                        NULL,
                        &ulSize);
		
    if (rc != ERROR_BUFFER_OVERFLOW && 
        rc != ERROR_INSUFFICIENT_BUFFER ){
        goto ExitHandler;
    }

    pAdapterInfo = (PIP_ADAPTER_INFO) LocalAlloc(LMEM_ZEROINIT, ulSize);

    if (pAdapterInfo == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;
    }

    rc = GetAdaptersInfo(
                        pAdapterInfo,
                        &ulSize);
		
    if (rc != ERROR_SUCCESS){
        goto ExitHandler;
    }

    for(PIP_ADAPTER_INFO pCurrAdapterInfo=pAdapterInfo; 
        pCurrAdapterInfo!=NULL; 
        pCurrAdapterInfo=pCurrAdapterInfo->Next){
        
        if (pCurrAdapterInfo->PrimaryWinsServer.IpAddress.String != NULL ||
            pCurrAdapterInfo->SecondaryWinsServer.IpAddress.String != NULL ){
            
            *pbIsWINSClient = TRUE;
            break;
        }
    }

ExitHandler:

    if (pAdapterInfo) {
        LocalFree(pAdapterInfo);
    }
    
    return rc;
}



DWORD 
SvcapisAreTasksScheduled(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbAreTasksScheduled
    )
/*++

Routine Description:

    Detects if at least one task is scheduled

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbAreTasksScheduled    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    HRESULT hr = S_OK;
    CComPtr <ITaskScheduler> pITS = NULL;
    CComPtr <IEnumWorkItems> pIEnum = NULL;
    
    if (pbAreTasksScheduled == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
  
    *pbAreTasksScheduled = FALSE;
  
    hr = CoInitialize(NULL);

    if (FAILED(hr)){
        return hr;
    }

    hr = CoCreateInstance(CLSID_CTaskScheduler,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITaskScheduler,
                          (void **) &pITS);
  
    if (FAILED(hr) || pITS == NULL ){
        goto ExitHandler;
    }

    if (pszMachineName != NULL) {

        hr = pITS->SetTargetComputer((LPCTSTR)pszMachineName);

        if (SCHED_E_SERVICE_NOT_INSTALLED == hr) {
            hr = S_OK;
            goto ExitHandler;
        }

        if (FAILED(hr)) {
          goto ExitHandler;
        }
    }
    
    hr = pITS->Enum(&pIEnum);
    
    if (FAILED(hr) || pIEnum == NULL){
      goto ExitHandler;
    }
    
    LPWSTR *lpwszNames = NULL;
    DWORD dwFetchedTasks = 0;
  
    hr = pIEnum->Next(1,
                    &lpwszNames,
                    &dwFetchedTasks);
  
    if (S_FALSE == hr){
        hr = ERROR_SUCCESS;
    }

    if (FAILED(hr)){
      goto ExitHandler;
    }
  
    if (dwFetchedTasks > 0 ){
      *pbAreTasksScheduled = TRUE;
    }

ExitHandler:
      
    if (lpwszNames){
        CoTaskMemFree(lpwszNames);
    }

    CoUninitialize();
          
    return hr;
}


DWORD 
SvcapisUPSAttached(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsUPSAttached
    )
/*++

Routine Description:

    Detects if UPS hardware is(was) attached

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsUPSAttached    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;
    HKEY    hKeyHklm = HKEY_LOCAL_MACHINE;
    HKEY    hKey = NULL;
    DWORD   RegType;
    DWORD   cbData;
    DWORD   dwOptions = 0;

    if (pbIsUPSAttached == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsUPSAttached = FALSE;

    if (pszMachineName) {
        
        rc = RegConnectRegistry(
                               pszMachineName,
                               HKEY_LOCAL_MACHINE,
                               &hKeyHklm
                               );
    }

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }
    
    rc = RegOpenKeyEx(hKeyHklm,
                      L"SYSTEM\\CurrentControlSet\\Services\\UPS",
                      0,
                      KEY_READ | KEY_QUERY_VALUE,
                      &hKey
                     );

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }

    cbData = sizeof(DWORD);
        
    rc = RegQueryValueEx (
                         hKey,                
                         L"Options",                
                         NULL,                
                         &RegType,                
                         (LPBYTE)&dwOptions,                
                         &cbData                
                         );

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }

    if (dwOptions & 0x1) {
        *pbIsUPSAttached = TRUE;
    }

ExitHandler:

    if (hKeyHklm != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyHklm);
    }
    
    if (hKey) {
        RegCloseKey(hKey);
    }

    if (rc == ERROR_FILE_NOT_FOUND ||
        rc == ERROR_PATH_NOT_FOUND) {
        rc = ERROR_SUCCESS;
    }

    return rc;
}


DWORD 
SvcapisAutoUpdateEnabled(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbAutoUpdateIsEnabled
    )
/*++

Routine Description:

    Detects if Auto Update is enabled

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbAutoUpdateIsEnabled    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;
    HKEY    hKeyHklm = HKEY_LOCAL_MACHINE;
    HKEY    hKey = NULL;
    DWORD   RegType;
    DWORD   cbData;
    DWORD   dwOptions = 0;

    if (pbAutoUpdateIsEnabled == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbAutoUpdateIsEnabled = FALSE;

    if (pszMachineName) {
        
        rc = RegConnectRegistry(
                               pszMachineName,
                               HKEY_LOCAL_MACHINE,
                               &hKeyHklm
                               );
    }

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }
    
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update",
                      0,
                      KEY_READ | KEY_QUERY_VALUE,
                      &hKey
                     );

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }

    cbData = sizeof(DWORD);
        
    rc = RegQueryValueEx (
                         hKey,                
                         L"AUOptions",                
                         NULL,                
                         &RegType,                
                         (LPBYTE)&dwOptions,                
                         &cbData                
                         );

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }

    if (!(dwOptions & 1)) {
        *pbAutoUpdateIsEnabled = TRUE;
    }

ExitHandler:

    if (hKeyHklm != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyHklm);
    }
    
    if (hKey) {
        RegCloseKey(hKey);
    }

    if (rc == ERROR_FILE_NOT_FOUND ||
        rc == ERROR_PATH_NOT_FOUND) {
        rc = ERROR_SUCCESS;
    }

    return rc;
}

DWORD 
ServicesFoundThatAreNotinKB(
    OUT BOOL    *pbIsServiceSatisfiable
    )
/*++

Routine Description:

    Detects if service is enabled on machine

Arguments:

    pbIsServiceSatisfiable    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    if (pbIsServiceSatisfiable == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsServiceSatisfiable = TRUE;

    return ERROR_SUCCESS;
}

DWORD 
SvcapisIsPerfCollectionScheduled(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsPerfCollectionScheduled
    )
/*++

Routine Description:

    Detects if perf data is being collected on the machine

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsPerfCollectionScheduled    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    BYTE    byStartupType;
    DWORD   rc;

    if (pbIsPerfCollectionScheduled == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsPerfCollectionScheduled = FALSE;
    
    rc = SvcapispQueryServiceStartupType(pszMachineName,
                                        L"SysmonLog",
                                        &byStartupType
                                        );

    if (rc != ERROR_SUCCESS) {
        goto ExitHandler;
    }
    
    *pbIsPerfCollectionScheduled = (byStartupType == SERVICE_AUTO_START ? TRUE : FALSE);

ExitHandler:

    return rc;
}


DWORD
SvcapisIsSBS(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsSmallBusinessServer
    )
/*++

Routine Description:

    Routine called to check if SBS is installed

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsSmallBusinessServer - booolean to fill
    
Return:

    Win32 error code

++*/
{
    if (pbIsSmallBusinessServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsSmallBusinessServer = FALSE;

    DWORD   rc = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    OSVERSIONINFOEX osVersionInfo;

    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);

    if (NULL == pszMachineName) {

        if (!GetVersionEx((LPOSVERSIONINFOW)&osVersionInfo)) {
            rc = GetLastError();
            goto ExitHandler;
        }
    }

    else {
        
        hr = SvcapispGetRemoteOSVersionInfo(
            pszMachineName, 
            &osVersionInfo);

        if (FAILED(hr)) {
            rc = ERROR_PRODUCT_VERSION;
            goto ExitHandler;
        }

    }
    
    if (osVersionInfo.dwMajorVersion == VER_SUITE_SMALLBUSINESS ||
        osVersionInfo.dwMajorVersion == VER_SUITE_SMALLBUSINESS_RESTRICTED) {

        *pbIsSmallBusinessServer = TRUE;
    
    }

ExitHandler:

    return rc;

}

DWORD 
SvcapisIsDC(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsDC
    )
/*++

Routine Description:

    Detects if machine is a DC

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsDC    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;

    if (pbIsDC == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsDC = FALSE;

    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole=NULL;

    HINSTANCE hDsRoleDll = LoadLibrary(TEXT("netapi32.dll"));

    if ( hDsRoleDll == NULL) {

        rc = ERROR_MOD_NOT_FOUND;
        goto ExitHandler;

    }

    PVOID pfDsRole;

    pfDsRole = (PVOID)GetProcAddress(
                                    hDsRoleDll,
                                    "DsRoleGetPrimaryDomainInformation");

    if ( pfDsRole == NULL ){
        rc = ERROR_PROC_NOT_FOUND;
        goto ExitHandler;
    }

    rc = (*((PFGETDOMAININFO)pfDsRole))(
                                       pszMachineName,                                               
                                       DsRolePrimaryDomainInfoBasic,                                               
                                       (PBYTE *)&pDsRole                                               
                                       );

    if (rc != ERROR_SUCCESS || NULL == pDsRole) {

        goto ExitHandler;

    }

    if ( pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
         pDsRole->MachineRole == DsRole_RoleBackupDomainController ) {
        *pbIsDC = TRUE;

    }

    pfDsRole = (PVOID)GetProcAddress(
                                    hDsRoleDll,
                                    "DsRoleFreeMemory");

    if ( pfDsRole ) {
        (*((PFDSFREE)pfDsRole))( pDsRole );
    }


ExitHandler:

    if (hDsRoleDll) {
           FreeLibrary(hDsRoleDll);
    }
    
    return(rc);
}

DWORD 
SvcapisIsAppModeTS(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsAppModeTS
    )
/*++

Routine Description:

    Detects if TS is in app mode

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsAppModeTS    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;
    HKEY    hKeyHklm = HKEY_LOCAL_MACHINE;
    HKEY    hKey = NULL;
    DWORD   RegType;
    DWORD   cbData;
    DWORD   dwOptions = 0;
    OSVERSIONINFOEX osVersionInfo;
    HRESULT hr = S_OK;

    if (pbIsAppModeTS == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsAppModeTS = FALSE;

    //
    // SSR paradigm for preprocessing remoteability
    //
    // if local, try the traditional approach
    // if remote, dig-into the registry etc. (maybe less reliable)
    //

    if (pszMachineName == NULL) {

        //
        // local
        //

        if (!GetVersionEx((LPOSVERSIONINFOW)&osVersionInfo)) {
            rc = GetLastError();
            goto ExitHandler;
        }

    } else {

        //
        // remote
        //

        hr = SvcapispGetRemoteOSVersionInfo(
                                           pszMachineName, 
                                           &osVersionInfo);

        if (FAILED(hr)) {
            rc = ERROR_PRODUCT_VERSION;
            goto ExitHandler;
        }

    }

    if (osVersionInfo.wSuiteMask & VER_SUITE_TERMINAL &&
        osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS) {

        *pbIsAppModeTS = TRUE;
    }


/*
        rc = RegConnectRegistry(
                               pszMachineName,
                               HKEY_LOCAL_MACHINE,
                               &hKeyHklm
                               );

        if (rc != ERROR_SUCCESS) {
            goto ExitHandler;
        }

        rc = RegOpenKeyEx(hKeyHklm,
                          L"System\\CurrentControlSet\\Control\\Terminal Server",
                          0,
                          KEY_READ | KEY_QUERY_VALUE,
                          &hKey
                         );

        if (rc != ERROR_SUCCESS) {
            goto ExitHandler;
        }

        cbData = sizeof(DWORD);

        rc = RegQueryValueEx (
                             hKey,                
                             L"TSAppCompat",                
                             NULL,                
                             &RegType,                
                             (LPBYTE)&dwOptions,                
                             &cbData                
                             );

        if (rc != ERROR_SUCCESS) {
            goto ExitHandler;
        }

        if (dwOptions & 0x1) {
            *pbIsAppModeTS = TRUE;
        }
    }
*/    

ExitHandler:

    if (hKeyHklm != HKEY_LOCAL_MACHINE) {
        RegCloseKey(hKeyHklm);
    }
    
    if (hKey) {
        RegCloseKey(hKey);
    }

    if (rc == ERROR_FILE_NOT_FOUND ||
        rc == ERROR_PATH_NOT_FOUND) {
        rc = ERROR_SUCCESS;
    }

    return rc;
}

DWORD 
SvcapisDFSSharesExist(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbDFSSharesExist
    )
/*++

Routine Description:

    Detects if DFS shares exist on machine

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbDFSSharesExist    -   pointer to boolean to fill

Return:

    Win32/NetApi error code
    
--*/

{
    NET_API_STATUS NetStatus;
    DWORD ParmError = 0;
    DWORD Status = ERROR_SUCCESS;
    LPBYTE Buffer = NULL;
    DWORD EntriesRead = 0;
    DWORD TotalEntries = 0;
    LPSHARE_INFO_1  pShareInfo = NULL;

    if (pbDFSSharesExist == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbDFSSharesExist = FALSE;

    NetStatus =  NetShareEnum(
                             pszMachineName,     
                             1,           
                             &Buffer,        
                             MAX_PREFERRED_LENGTH,      
                             &EntriesRead,   
                             &TotalEntries,  
                             NULL 
                             );

    if (NetStatus != NERR_Success || 
        EntriesRead == 0 ||
        Buffer == NULL) {
        goto ExitHandler;
    }

    pShareInfo = (LPSHARE_INFO_1)Buffer;

    PSHARE_INFO_1005 pBufShareInfo = NULL;
    DWORD   shi1005_flags;

    for (ULONG  uIndex=0; uIndex < EntriesRead; uIndex++) {
        if (pShareInfo[uIndex].shi1_type == STYPE_DISKTREE) {

            NetStatus = NetShareGetInfo(
                                       pszMachineName,  
                                       pShareInfo[uIndex].shi1_netname,     
                                       1005,        
                                       (LPBYTE *) &pBufShareInfo
                                       );

            if (NetStatus != NERR_Success ||
                pBufShareInfo == NULL) {
                goto ExitHandler;
            }

            shi1005_flags = pBufShareInfo->shi1005_flags;

            NetApiBufferFree(pBufShareInfo);
            pBufShareInfo = NULL;

            if (SHI1005_FLAGS_DFS & shi1005_flags) {

                *pbDFSSharesExist = TRUE;
                break;

            }
        }
    }

    ExitHandler:

    if (Buffer) {
        NetApiBufferFree(Buffer);
    }

    return NetStatus;
}


DWORD 
SvcapisIsUsingDHCP(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsUsingDHCP
    )
/*++

Routine Description:

    Detects if any adapter on this machine is using DHCP
    in its TCP/IP stack

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsUsingDHCP    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwOutBufLen = 0;
    PIP_ADAPTER_ADDRESSES   pAdapterAddresses = NULL;
    
    if (pbIsUsingDHCP == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsUsingDHCP = FALSE;

    rc = GetAdaptersAddresses(
                             AF_UNSPEC,
                             0,
                             NULL,
                             NULL,
                             &dwOutBufLen
                             );

    if (ERROR_SUCCESS == rc ||
        (ERROR_SUCCESS != rc && ERROR_BUFFER_OVERFLOW != rc)) {
        goto ExitHandler;
    }

    pAdapterAddresses = (PIP_ADAPTER_ADDRESSES) LocalAlloc(LMEM_ZEROINIT, dwOutBufLen);
        
    if ( NULL == pAdapterAddresses) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitHandler;
    }

    rc = GetAdaptersAddresses(
                             AF_UNSPEC,
                             0,
                             NULL,
                             pAdapterAddresses,
                             &dwOutBufLen
                             );
    
    if (ERROR_SUCCESS != rc) {
        goto ExitHandler;
    }

    for (PIP_ADAPTER_ADDRESSES pCurrentAddress = pAdapterAddresses;
         pCurrentAddress != NULL;
         pCurrentAddress = pCurrentAddress->Next) {
        
        if (pCurrentAddress->Flags & IP_ADAPTER_DHCP_ENABLED) {

            *pbIsUsingDHCP = TRUE;
            goto ExitHandler;
        }
    }

ExitHandler:

    if (pAdapterAddresses) {
        LocalFree(pAdapterAddresses);
    }
    
    return(rc);
}


DWORD 
SvcapisIsUsingDDNS(
    IN  PWSTR   pszMachineName,
    OUT BOOL    *pbIsUsingDDNS
    )
/*++

Routine Description:

    Detects if any adapter on this machine is using DDNS (DNS is always enabled)
    in its TCP/IP stack

Arguments:

    pszMachineName  -   name of machine to evaluate function on
    
    pbIsUsingDHCP    -   pointer to boolean to fill

Return:

    Win32 error code
    
--*/

{
    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwOutBufLen = 0;
    
    PIP_ADAPTER_ADDRESSES   pAdapterAddresses;

    if (pbIsUsingDDNS == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pbIsUsingDDNS = FALSE;

    rc = GetAdaptersAddresses(
                             AF_UNSPEC,
                             0,
                             NULL,
                             NULL,
                             &dwOutBufLen
                             );

    if (ERROR_SUCCESS == rc ||
        (ERROR_SUCCESS != rc && ERROR_BUFFER_OVERFLOW != rc)) {
        goto ExitHandler;
    }

    pAdapterAddresses = (PIP_ADAPTER_ADDRESSES) LocalAlloc(LMEM_ZEROINIT, dwOutBufLen);
        
    if ( NULL == pAdapterAddresses) {
        goto ExitHandler;
    }

    rc = GetAdaptersAddresses(
                             AF_UNSPEC,
                             0,
                             NULL,
                             pAdapterAddresses,
                             &dwOutBufLen
                             );
    
    if (ERROR_SUCCESS != rc) {
        goto ExitHandler;
    }

    for (PIP_ADAPTER_ADDRESSES pCurrentAddress = pAdapterAddresses;
         pCurrentAddress != NULL;
         pCurrentAddress = pCurrentAddress->Next) {
        
        if (pCurrentAddress->Flags & IP_ADAPTER_DDNS_ENABLED) {

            *pbIsUsingDDNS = TRUE;
            goto ExitHandler;
        }
    }

ExitHandler:

    if (pAdapterAddresses) {
        LocalFree(pAdapterAddresses);
    }
    
    return(rc);
}


HRESULT
SvcapispGetRemoteOSVersionInfo(
    IN  PWSTR   pszMachineName, 
    OUT OSVERSIONINFOEX *posVersionInfo
    )
/*++

Routine Description:

    Routine called to get version info from remote machine via WMI

Arguments:

    pszMachineName   -   remote machine name
    
    posVersionInfo    -   os version info to fill via WMI queries
    
Return:

    HRESULT error code

++*/
{
    HRESULT             hr = S_OK;
    
    CComPtr <IWbemLocator>  pWbemLocator = NULL;
    CComPtr <IWbemServices> pWbemServices = NULL;
    CComPtr <IWbemClassObject>  pWbemOsObjectInstance = NULL;
    CComPtr <IEnumWbemClassObject>  pWbemEnumObject = NULL;
    CComBSTR    bstrMachineAndNamespace; 
    ULONG  nReturned = 0;
    
    bstrMachineAndNamespace = pszMachineName;
    bstrMachineAndNamespace += L"\\root\\cimv2";

    hr = CoCreateInstance(
                         CLSID_WbemLocator, 
                         0, 
                         CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator, 
                         (LPVOID *) &pWbemLocator
                         );

    if (FAILED(hr) || pWbemLocator == NULL ) {

        goto ExitHandler;
    }

    hr = pWbemLocator->ConnectServer(
                                bstrMachineAndNamespace,
                                NULL, 
                                NULL, 
                                NULL, 
                                0L,
                                NULL,
                                NULL,
                                &pWbemServices
                                );

    if (FAILED(hr) || pWbemServices == NULL ) {

        goto ExitHandler;
    }

    hr = CoSetProxyBlanket(
                          pWbemServices,
                          RPC_C_AUTHN_WINNT,
                          RPC_C_AUTHZ_NONE,
                          NULL,
                          RPC_C_AUTHN_LEVEL_PKT,
                          RPC_C_IMP_LEVEL_IMPERSONATE,
                          NULL, 
                          EOAC_NONE
                          );

    if (FAILED(hr)) {

        goto ExitHandler;
    }
        
    hr = pWbemServices->ExecQuery(CComBSTR(L"WQL"),
                                 CComBSTR(L"SELECT * FROM Win32_OperatingSystem"),
                                 WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                 NULL,
                                 &pWbemEnumObject);

    if (FAILED(hr) || pWbemEnumObject == NULL) {

        goto ExitHandler;
    }

    hr = pWbemEnumObject->Next(WBEM_INFINITE, 1, &pWbemOsObjectInstance, &nReturned);

    if (FAILED(hr) || pWbemOsObjectInstance == NULL) {

        goto ExitHandler;
    }

    VARIANT vVersion;

    VariantInit(&vVersion); 

    hr = pWbemOsObjectInstance->Get(CComBSTR(L"Version"), 
                            0,
                            &vVersion, 
                            NULL, 
                            NULL);


    if (FAILED(hr)) {

        goto ExitHandler;
    }

    if (V_VT(&vVersion) == VT_NULL) {

        goto ExitHandler;

    }

    //
    // extract the version information into DWORDs since
    // the return type of this property is BSTR variant
    // of the form "5.1.2195"
    //

    BSTR  bstrVersion = V_BSTR(&vVersion);
    WCHAR szVersion[5];
    szVersion[0] = L'\0';

    PWSTR pszDot = wcsstr(bstrVersion, L".");

    if (NULL == pszDot) {
        hr = E_INVALIDARG;
        goto ExitHandler;

    }

    wcsncpy(szVersion, bstrVersion, 1);

    posVersionInfo->dwMajorVersion = (DWORD)_wtoi(szVersion);

    wcsncpy(szVersion, pszDot+1, 1);

    posVersionInfo->dwMinorVersion = (DWORD)_wtoi(szVersion);

ExitHandler:
    
    if (V_VT(&vVersion) != VT_NULL) {
        VariantClear( &vVersion );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\actiondata.cpp ===
// ActionData.cpp : Implementation of CSsrActionData

#include "stdafx.h"
#include "SSRTE.h"
#include "ActionData.h"

#include "SSRMembership.h"
#include "MemberAccess.h"

#include "global.h"
#include "util.h"

//---------------------------------------------------------------------
// CSsrActionData implementation
//---------------------------------------------------------------------

/*
Routine Description: 

Name:

    CSsrActionData::CSsrActionData

Functionality:
    
    constructor

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrActionData::CSsrActionData()
    : m_pSsrMembership(NULL)
{
}




/*
Routine Description: 

Name:

    CSsrActionData::~CSsrActionData

Functionality:
    
    destructor

Virtual:
    
    yes.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrActionData::~CSsrActionData()
{
    Reset();
}



/*
Routine Description: 

Name:

    CSsrActionData::GetProperty

Functionality:
    
    Get the named property

Virtual:
    
    yes.
    
Arguments:

    bstrPropName    - The name of the property.

    pvarProperty    - The output parameter that receives the new property value 

Return Value:

    S_OK if it succeeded. Otherwise, it returns various error codes.

Notes:

*/

STDMETHODIMP
CSsrActionData::GetProperty (
    IN BSTR       bstrPropName,
    OUT VARIANT * pvarProperty //[out, retval] 
    )
{
    if (pvarProperty == NULL)
    {
        return E_INVALIDARG;
    }

    ::VariantInit(pvarProperty);

    if (bstrPropName == NULL || *bstrPropName == L'\0')
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // See if the runtime property bag contains that property
    //

    MapNameValue::iterator it = m_mapRuntimeAD.find(bstrPropName);
    MapNameValue::iterator itEnd = m_mapRuntimeAD.end();

    if (it != itEnd)
    {
        VARIANT * pValOld = (*it).second;
        hr = ::VariantCopy(pvarProperty, pValOld);
    }
    else
    {
        hr = W_SSR_PROPERTY_NOT_FOUND;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrActionData::SetProperty

Functionality:
    
    Set the named property

Virtual:
    
    yes.
    
Arguments:

    bstrPropName    - The name of the property.

    varProperty     - The property's value. 

Return Value:

    S_OK if it succeeded. Otherwise, it returns various error codes.

Notes:
    varProperty may be an array

*/

STDMETHODIMP
CSsrActionData::SetProperty (
    IN BSTR     bstrPropName,
 	IN VARIANT  varProperty
    )
{
    //
    // Properties that are dynamically set always goes to the runtime map
    // which will be used to search for the named property when requested.
    // This implementation fulfills our design that runtime property overwrite
    // static registered properties (which are from the CMemberAD object)
    //

    HRESULT hr = S_OK;

    //
    // first, let's see if this property has already been set
    //

    MapNameValue::iterator it = m_mapRuntimeAD.find(bstrPropName);
    MapNameValue::iterator itEnd = m_mapRuntimeAD.end();

    if (it != itEnd)
    {
        VARIANT * pValOld = (*it).second;
        ::VariantClear(pValOld);
        hr = ::VariantCopy(pValOld, &varProperty);
    }
    else
    {
        //
        // the name property is not present. Then add a new pair
        //

        BSTR bstrName = ::SysAllocString(bstrPropName);
        VARIANT * pNewVal = new VARIANT;

        if (bstrName != NULL && pNewVal != NULL)
        {
            //
            // The map will take care of the heap memory
            //

            ::VariantInit(pNewVal);
            hr = ::VariantCopy(pNewVal, &varProperty);
            if (SUCCEEDED(hr))
            {
                m_mapRuntimeAD.insert(MapNameValue::value_type(bstrName, pNewVal));
            }
        }
        else
        {
            if (bstrName != NULL)
            {
                ::SysFreeString(bstrName);
            }

            if (pNewVal != NULL)
            {
                delete pNewVal;
            }

            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrActionData::Reset

Functionality:
    
    Cleanup the whole property bag

Virtual:
    
    yes.
    
Arguments:

    none.

Return Value:

    S_OK.

Notes:
    

*/

STDMETHODIMP
CSsrActionData::Reset ()
{
    //
    // both items of the map (first and second) are heap allocated
    // memories, so we need to release them
    //

    MapNameValue::iterator it = m_mapRuntimeAD.begin();
    MapNameValue::iterator itEnd = m_mapRuntimeAD.end();

    while (it != itEnd)
    {
        BSTR bstrName = (*it).first;
        VARIANT * pvarVal = (*it).second;

        ::SysFreeString(bstrName);

        ::VariantClear(pvarVal);
        delete pvarVal;
        ++it;
    }

    m_mapRuntimeAD.clear();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "SSRTE_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\actiondata.h ===
// ActionData.h : Declaration of the CSsrActionData

#pragma once

#include "resource.h"

#include "global.h"


#include "SSRLog.h"

using namespace std;


class CSsrMembership;

class CSafeArray;

class CMemberAD;


/////////////////////////////////////////////////////////////////////////////
// CSSRTEngine

class ATL_NO_VTABLE CSsrActionData : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISsrActionData, &IID_ISsrActionData, &LIBID_SSRLib>
{
protected:
	CSsrActionData();
    virtual ~CSsrActionData();

    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrActionData (const CSsrActionData& );
    void operator = (const CSsrActionData& );

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSsrActionData)
	COM_INTERFACE_ENTRY(ISsrActionData)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISsrActionData
public:

    STDMETHOD(GetProperty) (
                IN BSTR       bstrPropName,
                OUT VARIANT * pvarPropties //[out, retval] 
                );

    STDMETHOD(SetProperty) (
                IN BSTR     bstrPropName,
 				IN VARIANT  varProperties
                );

    STDMETHOD(Reset) ();

    //HRESULT AttachMemberActionData (
    //            IN BSTR bstrMemberName, 
    //            IN BSTR bstrActionVerb,
    //            IN LONG lActionType
    //            );

    //HRESULT DetachMemberActionData (
    //            IN BSTR bstrMemberName
    //            );

    //
    // This is not a ref-counted pointer.
    // The existence of the SSR Engine should guarantee
    // the availability of the membership object
    //

    void SetMembership (
                IN CSsrMembership * pSsrMembership
                )
    {
        m_pSsrMembership = pSsrMembership;
    }

private:

    CSsrMembership * m_pSsrMembership;

    MapNameValue m_mapRuntimeAD;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__BDA6DB25_8547_47FC_94FC_8A63ED473048__INCLUDED_)
#define AFX_DLLDATAX_H__BDA6DB25_8547_47FC_94FC_8A63ED473048__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__BDA6DB25_8547_47FC_94FC_8A63ED473048__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( SSRTE )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( SSRTE ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\global.cpp ===
//
// global.cpp
//

#include "StdAfx.h"
#include <sddl.h>
#include "global.h"
#include "util.h"
#include "SSRLog.h"


CFBLogMgr g_fblog;

WCHAR g_wszSsrRoot[MAX_PATH + 1];
DWORD g_dwSsrRootLen = 0;

LPCWSTR g_pwszSSRRootToExpand = L"%windir%\\Security\\SSR";

//
// this is our ACL list
//

//LPCWSTR g_pwszSsrDCOMSecDescripACL = L"D:(A;;GA;;;SY)(A;;GA;;;BA)";

LPCWSTR g_pwszAppID = L"SOFTWARE\\Classes\\APPID\\{3f2db10f-6368-4702-a4b1-e5149d931370}";
LPCWSTR g_pwszAccessPermission = L"AccessPermission";
LPCWSTR g_pwszLaunchPermission = L"LaunchPermission";

//
// registry's SSR root
//

LPCWSTR g_pwszSSRRegRoot = L"Software\\Microsoft\\Security\\SSR";

LPCWSTR g_pwszSSR = L"SSR";
LPCWSTR g_pwszLogs = L"Logs";

//
// The following are reserved action verbs
//

CComBSTR g_bstrConfigure(L"Configure");
CComBSTR g_bstrRollback(L"Rollback");
CComBSTR g_bstrReport(L"Report");

//
// the following are reserved file-usage values
//

CComBSTR g_bstrLaunch(L"Launch");
CComBSTR g_bstrResult(L"Result");

//
// the following is the reserved action data's names
//

LPCWSTR g_pwszCurrSecurityPolicy  = L"CurrSecurityPolicy";
LPCWSTR g_pwszTransformFiles      = L"TransformFiles";
LPCWSTR g_pwszScriptFiles         = L"ScriptFiles";


//
// the following are element tag names
//

CComBSTR g_bstrSsrMemberInfo(L"SsrMemberInfo");
CComBSTR g_bstrDescription(L"Description");
CComBSTR g_bstrSupportedAction(L"SupportedAction");
CComBSTR g_bstrProcedures(L"Procedures");
CComBSTR g_bstrDefaultProc(L"DefaultProc");
CComBSTR g_bstrCustomProc(L"CustomProc");
CComBSTR g_bstrTransformInfo(L"TransformInfo");
CComBSTR g_bstrScriptInfo(L"ScriptInfo");

//
// the following are attribute names
//

CComBSTR g_bstrAttrUniqueName(L"UniqueName");
CComBSTR g_bstrAttrMajorVersion(L"MajorVersion");
CComBSTR g_bstrAttrMinorVersion(L"MinorVersion");
CComBSTR g_bstrAttrProgID(L"ProgID");
CComBSTR g_bstrAttrActionName(L"ActionName");
CComBSTR g_bstrAttrActionType(L"ActionType");
CComBSTR g_bstrAttrTemplateFile(L"TemplateFile");
CComBSTR g_bstrAttrResultFile(L"ResultFile");
CComBSTR g_bstrAttrScriptFile(L"ScriptFile");
CComBSTR g_bstrAttrIsStatic(L"IsStatic");
CComBSTR g_bstrAttrIsExecutable(L"IsExecutable");


//
// these are the known action types
// 

LPCWSTR g_pwszApply = L"Prepare";
LPCWSTR g_pwszPrepare = L"Prepare";

CComBSTR g_bstrReportFilesDir;
CComBSTR g_bstrConfigureFilesDir;
CComBSTR g_bstrRollbackFilesDir;
CComBSTR g_bstrTransformFilesDir;
CComBSTR g_bstrMemberFilesDir;

CComBSTR g_bstrTrue(L"True");
CComBSTR g_bstrFalse(L"False");

//
// A guid can be represented in string form such as 
// {aabbccdd-1234-4321-abcd-1234567890ab}.
// The length of such string format guid returned from StringFromGUID2 etc.
// is 38
//

const long g_lGuidStringLen = 38;

//
// global helper function implementations
//



const BSTR 
SsrPGetActionVerbString (
    IN SsrActionVerb action
    )
/*++
Routine Description: 

Functionality:
    
    This will translate an SsrActionVerb value into
    the corresponding BSTR

Virtual:
    
    N/A.
    
Arguments:

    action  - The SsrActionVerb value

Return Value:

    Success: const BSTR of that verb's string;

    Failure: NULL.

Notes:

    Callers must not release in any form of the returned
    BSTR. It is a const BSTR, and you must honor that.
--*/
{
    switch (action)
    {
    case ActionConfigure:
        return g_bstrConfigure;
    case ActionRollback:
        return g_bstrRollback;
    case ActionReport:
        return g_bstrReport;
    }
    
    return NULL;
}

SsrActionVerb
SsrPGetActionVerbFromString (
    IN LPCWSTR pwszVerb
    )
/*++
Routine Description: 

Functionality:
    
    This will translate an string action verb value into
    the corresponding SsrActionVerb value. 

Virtual:
    
    N/A.
    
Arguments:

    pwszVerb  - The action verb string

Return Value:

    Success: the appropriate SsrActionVerb value if the verb is recognized

    Failure: ActionInvalid.

Notes:


--*/
{
    SsrActionVerb ActVerb = ActionInvalid;

    if (pwszVerb != NULL)
    {
        if (_wcsicmp(pwszVerb, g_bstrConfigure) == 0)
        {
            ActVerb = ActionConfigure;
        }
        else if (_wcsicmp(pwszVerb, g_bstrRollback) == 0)
        {
            ActVerb = ActionRollback;
        }
        else if (_wcsicmp(pwszVerb, g_bstrReport) == 0)
        {
            ActVerb = ActionReport;
        }
    }

    return ActVerb;
}


HRESULT 
SsrPDeleteEntireDirectory (
    IN LPCWSTR pwszDirPath
    )
/*++
Routine Description:

Functionality:
    
    This will do a recursive delete of all files and subdirectories of the given
    directory. RemoveDirectory API only deletes empty directories.


Virtual:
    
    N/A.
    
Arguments:

    pwszDirPath  - The path of the directory

Return Value:

    Success: S_OK;

    Failure: various error codes.

Notes:


--*/
{
    HRESULT hr = S_OK;

    WIN32_FIND_DATA FindFileData;

    //
    // prepare the find file filter
    //

    DWORD dwDirLen = wcslen(pwszDirPath);

    if (dwDirLen > MAX_PATH)
    {
        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }

    CComBSTR bstrPath(pwszDirPath);
    bstrPath += CComBSTR(L"\\*");

    if (bstrPath.m_str == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HANDLE hFind = ::FindFirstFile(bstrPath, &FindFileData);

    //
    // IF we have find something, then we have to do a recursive delete,
    // Copy the given directory path to our local memory so that we can 
    // create a full path for the found file/directory
    //

    if (hFind != INVALID_HANDLE_VALUE)
    {
        WCHAR wszFullName[MAX_PATH + 2];
        wszFullName[MAX_PATH + 1] = L'\0';

        ::memcpy(wszFullName, pwszDirPath, sizeof(WCHAR) * (dwDirLen + 1));

        DWORD dwFileNameLength;

        while (hFind != INVALID_HANDLE_VALUE)
        {
            //
            // don't do anything to the parent directories
            //

            bool bDots = wcscmp(FindFileData.cFileName, L".") == 0 ||
                         wcscmp(FindFileData.cFileName, L"..") == 0;

            if (!bDots)
            {
                //
                // create the full name of the file/directory
                //

                dwFileNameLength = wcslen(FindFileData.cFileName);

                if (dwDirLen + 1 + dwFileNameLength > MAX_PATH)
                {
                    //
                    // we don't want names longer than MAX_PATH
                    //

                    hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                    break;
                }

                //
                // pwszFullName + dwDirLen is where the directory path ends
                //

                _snwprintf(wszFullName + dwDirLen,
                           1 + dwFileNameLength + 1,    // backslah plus 0 term.
                           L"\\%s", 
                           FindFileData.cFileName
                           );

                if (FindFileData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
                {
                    //
                    // a directory. recursively delete the entire directory
                    //
        
                    hr = ::SsrPDeleteEntireDirectory(wszFullName);
                }
                else
                {
                    //
                    // a file
                    //

                    if (!::DeleteFile(wszFullName))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        break;
                    }
                }
            }
    
            if (!::FindNextFile(hFind, &FindFileData))
            {
                break;
            }
        }
    
        ::FindClose(hFind);
    }

    if (SUCCEEDED(hr) && !::RemoveDirectory(pwszDirPath))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}




HRESULT
SsrPCreateSubDirectories (
    IN OUT LPWSTR  pwszPath,
    IN     LPCWSTR pwszSubRoot
    )
/*++
Routine Description: 

Functionality:
    
    This will create all subdirectory leading to the path.
    The assumption is that the path contains a subdirectory
    identified by pwszSubRoot, the creation will start from
    there.


Virtual:
    
    N/A.
    
Arguments:

    pwszPath    - The path of the directory

    pwszSubRoot - The subdirectory where the creation sequence
                  will start.

Return Value:

    Success: S_OK;

    Failure: various error codes.

Notes:

    We actually don't change pwszPath. But we will temporarily
    modify the buffer during our operation, but upon returning,
    the buffer is fully restored to the original value.

--*/
{
    if (pwszPath == NULL || *pwszPath == L'\0')
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    LPCWSTR pwszCurrReadHead = pwszPath;

    if (pwszSubRoot != NULL && *pwszSubRoot != L'\0')
    {
        pwszCurrReadHead = ::wcsstr(pwszPath, pwszSubRoot);

        //
        // if you specify a subroot, then it must exists in the path
        //

        if (pwszCurrReadHead == NULL)
        {
            return E_INVALIDARG;
        }
    }

    LPWSTR pwszNextReadHead = ::wcsstr(pwszCurrReadHead, L"\\");

    //
    // will try to create all subdirectories under SSR
    //

    while (true)
    {
        //
        // Temporarily zero terminate it so that we can try 
        // to create the directory
        //

        if (pwszNextReadHead != NULL)
        {
            *pwszNextReadHead = L'\0';
        }
        
        if (!::CreateDirectory(pwszPath, NULL))
        {
            DWORD dwError = GetLastError();

            if (dwError == ERROR_ALREADY_EXISTS)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwError);

                //
                // log the directory that failed to create
                //

                g_fblog.LogFeedback(SSR_FB_ERROR_GENERIC | FBLog_Log,
                                    hr,
                                    pwszPath,
                                    IDS_FAIL_CREATE_DIRECTORY
                                    );
                break;
            }
        }

        //
        // if we don't have any more backslash, then it's over
        //

        if (pwszNextReadHead == NULL)
        {
            break;
        }

        //
        // Restore the backslash
        //

        *pwszNextReadHead = L'\\';
        pwszNextReadHead = ::wcsstr(pwszNextReadHead + 1, L"\\");
    }

    return hr;
}




HRESULT
SsrPLoadDOM (
    BSTR               bstrFile,   // [in],
    LONG               lFlag,      // [in],
    IXMLDOMDocument2 * pDOM        // [in]
    )
/*++
Routine Description: 

Functionality:
    
    Do the XML DOM loading

Virtual:
    
    n/a.
    
Arguments:

    bstrFile- the XML/XSL file path

    uFlag   - The flag that determines the transformation characteristics. 
              The one we use is SSR_LOADDOM_VALIDATE_ON_PARSE.

    pDOM    - The IXMLDOMDocument2 object interface.

Return Value:

    Success: 
    
        various success codes returned from DOM or ourselves. 
        Use SUCCEEDED(hr) to test.

    Failure: 

        various error codes returned from DOM or ourselves. 
        Use FAILED(hr) to test.

Notes:

--*/
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    if ( NULL == pDOM) {
        return E_INVALIDARG;
    }

    //
    // set the validateOnParse property
    //

    if (lFlag & SSR_LOADDOM_VALIDATE_ON_PARSE)
    {
        hr = pDOM->put_validateOnParse(VARIANT_TRUE);
    }
    else
    {
        hr = pDOM->put_validateOnParse(VARIANT_FALSE);
    }

    if (FAILED(hr))
    {
        g_fblog.LogFeedback(SSR_FB_ERROR_LOAD_MEMBER | FBLog_Log,
                            hr,
                            L"put_validateOnParse", 
                            IDS_DOM_PROPERTY_PUT_FAILED
                            );
    }

    CComVariant varInput(bstrFile);

    //
    // we should try to see what happens if we set it to VARIANT_TRUE
    //

    VARIANT_BOOL fSuccess;
    hr = pDOM->load(varInput, &fSuccess);

    if (fSuccess == VARIANT_FALSE)
    {
        //
        // somehow it fails, we want to figure out what is going on, 
        // potential parsing errors
        //

        CComPtr<IXMLDOMParseError> srpParseError;

        //
        // in case of any failure, we will use the bstrReason
        // to log and feedback.
        //

        CComBSTR bstrReason;

        long ulLine = 0, ulColumn = 0, ulCode = 0;

        //
        // if any of the following fails, there is nothing we can do
        // other than logging the error.
        //

        hr = pDOM->get_parseError(&srpParseError);
        if (FAILED(hr))
        {
            bstrReason = L"SsrPLoadDOM failed on pDOM->get_parseError.";
        }
        else
        {
            hr = srpParseError->get_reason(&bstrReason);
            if (FAILED(hr))
            {
                bstrReason = L"SsrPLoadDOM failed on srpParseError->get_reason.";
            }
            else
            {
                hr = srpParseError->get_errorCode(&ulCode);
                if (FAILED(hr))
                {
                    bstrReason = L"SsrPLoadDOM failed on srpParseError->get_errorCode.";
                }

                hr = srpParseError->get_line(&ulLine);

                if (FAILED(hr))
                {
                    bstrReason = L"SsrPLoadDOM failed on srpParseError->get_line.";
                }
            }
        }

        const ULONG uHexMaxLen = 8;
        const ULONG uDecMaxLen = 16;

        LPWSTR pwszError = NULL;

        //
        // we can't continue creating more specific error info
        // if we fail to get the reason - which may include out-of-memory
        // system errors. We don't bother to modify our error to 
        // out-of-memory because we are guessing in that case and also
        // others will catch that error fairly quickly.
        //

        if (SUCCEEDED(hr) && bstrReason != NULL && ulLine != 0)
        {
            //
            // It's a parsing error
            //

            srpParseError->get_linepos(&ulColumn);

            CComBSTR bstrFmt;
            if (SUCCEEDED(bstrFmt.LoadString(IDS_XML_PARSING_ERROR)))
            {
                ULONG uTotLen = bstrFmt.Length() + 
                                uHexMaxLen + 
                                uDecMaxLen + 
                                ::wcslen(bstrReason) + 
                                ::wcslen(bstrFile) + 
                                uDecMaxLen + 1;

                pwszError = new WCHAR[uTotLen];

                if (pwszError == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _snwprintf( pwszError,
                                uTotLen,
                                bstrFmt, 
                                ulCode, 
                                ulLine, 
                                bstrReason, 
                                bstrFile, 
                                ulColumn
                                );
                }
            }
        }
        else
        {
            if ((HRESULT) ulCode == INET_E_OBJECT_NOT_FOUND)
            {
                g_fblog.LogString(IDS_OBJECT_NOT_FOUND, bstrFile);
            }
        }

        //
        // loading DOM failure is critical, do both logging and feedback
        //

        g_fblog.LogFeedback(SSR_FB_ERROR_MEMBER_XML | FBLog_Log,
                            bstrFile,
                            ((pwszError != NULL) ? pwszError : bstrReason),
                            IDS_DOM_LOAD_FAILED
                            );

        delete [] pwszError;

        //
        // I have seen the HRESULT code being a success code while
        // it can't transform fSuccess == VARIANT_FALSE
        //

        if (SUCCEEDED(hr))
        {
            hr = E_SSR_INVALID_XML_FILE;
        }
    }

    return hr;
}


HRESULT
SsrPGetBSTRAttrValue (
    IN IXMLDOMNamedNodeMap * pNodeMap,
    IN  BSTR                 bstrName,
    OUT BSTR               * pbstrValue
    )
/*++
Routine Description: 

Functionality:
    
    A helper function to get string attribute values

Virtual:
    
    N/A.
    
Arguments:

    pNodeMap - The map of attributes

    bstrName - The name of the attribute

    pbstrValue  - Receives the string value.

Return Value:

    S_OK if succeeded.

    Various error codes. Watch out for E_SSR_MISSING_STRING_ATTRIBUTE
    because if it is an optional attribute, then we should allow
    this failure.

Notes:

--*/
{
    if (pNodeMap == NULL || pbstrValue == NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrValue = NULL;

    CComPtr<IXMLDOMNode> srpAttr;
    CComVariant varValue;

    HRESULT hr = pNodeMap->getNamedItem(bstrName, &srpAttr);
    if (SUCCEEDED(hr) && srpAttr != NULL)
    {
        hr = srpAttr->get_nodeValue(&varValue);
    }
    
    if (SUCCEEDED(hr) && varValue.vt == VT_BSTR)
    {
        *pbstrValue = varValue.bstrVal;

        //
        // detach the bstr value so that we can reuse the variant
        //

        varValue.vt = VT_EMPTY;
        varValue.bstrVal = NULL;
    }
    else if (varValue.vt != VT_BSTR)
    {
        hr = E_SSR_MISSING_STRING_ATTRIBUTE;
    }

    return hr;
}


HRESULT 
SsrPCreateUniqueTempDirectory (
    OUT LPWSTR pwszTempDirPath,
    IN  DWORD  dwBufLen
    )
/*++
Routine Description: 

Functionality:
    
    Will create a unique (guid) temporary directory under ssr root

Virtual:
    
    No.
    
Arguments:

    pwszTempDirPath - The path of the temporary directory

    dwBufLen        - The buffer length in WCHAR counts

Return Value:

    succeess: S_OK
    failure: various error codes

Notes:

--*/
{
    //
    // we need the ssr root, the backslash and the guid (36 wchars) and 0 terminator
    //

    if (dwBufLen < g_dwSsrRootLen + 1 + g_lGuidStringLen + 1)
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    WCHAR wszGuid[g_lGuidStringLen + 1];
    GUID guid;
    memset(&guid, 0, sizeof(GUID));
    memset(wszGuid, 0, sizeof(WCHAR) * (g_lGuidStringLen + 1) );

    HRESULT hr = ::CoCreateGuid(&guid);
    if (S_OK == hr)
    {
        ::StringFromGUID2(guid, wszGuid, g_lGuidStringLen + 1);

        memcpy(pwszTempDirPath, g_wszSsrRoot, g_dwSsrRootLen * sizeof(WCHAR));
        pwszTempDirPath[g_dwSsrRootLen] = L'\\';

        //
        // skip the starting '{', and do not copy '}' either.
        //

        memcpy(pwszTempDirPath + g_dwSsrRootLen + 1,
               wszGuid + 1,
               (g_lGuidStringLen - 2) * sizeof(WCHAR)
               );

        //
        // NULL terminate it
        //

        pwszTempDirPath[g_dwSsrRootLen + g_lGuidStringLen - 1] = L'\0';

        if (!CreateDirectory(pwszTempDirPath, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}





HRESULT 
SsrPMoveFiles (
    IN LPCWSTR pwszSrcDirRoot,
    IN LPCWSTR pwszDesDirRoot,
    IN LPCWSTR pwszRelPath
    )
/*++
Routine Description: 

Functionality:
    
    Will move a file given by the relative path of the src directory
    to the destination directory of the same relative path

Virtual:
    
    No.
    
Arguments:

    pwszSrcDirRoot  - The src directory root path. Combined with the
                      pwszRelPath, it becomes the full path of the src file

    pwszDesDirRoot  - The dest directory root path. Combined with the pwszRelPath,
                      it becomes the full path of the destination file.

    pwszRelPath     - the file path relative to the src directory root.

Return Value:

    Success: S_OK.

    Failure: various error codes.

Notes:

    If the destination directory doesn't exist, then we will create it
--*/

{
    HRESULT hr = S_OK;

    //
    // first, we must the source and destination files paths
    //

    DWORD dwSrcRootLen = wcslen(pwszSrcDirRoot);
    DWORD dwDesRootLen = wcslen(pwszDesDirRoot);

    DWORD dwRelPathLen = wcslen(pwszRelPath);

    LPWSTR pwszSrcPath = new WCHAR[dwSrcRootLen + 1 + dwRelPathLen + 1];
    LPWSTR pwszDesPath = new WCHAR[dwDesRootLen + 1 + dwRelPathLen + 1];

    if (pwszSrcPath != NULL && pwszDesPath != NULL)
    {
        ::memcpy(pwszSrcPath, pwszSrcDirRoot, sizeof(WCHAR) * dwSrcRootLen);
        pwszSrcPath[dwSrcRootLen] = L'\\';

        //
        // copy one WCHAR more then length so that the 0 terminator is set
        //

        ::memcpy(pwszSrcPath + dwSrcRootLen + 1, 
                 pwszRelPath, sizeof(WCHAR) * (dwRelPathLen + 1));


        ::memcpy(pwszDesPath, pwszDesDirRoot, sizeof(WCHAR) * dwDesRootLen);

        pwszDesPath[dwDesRootLen] = L'\\';
        ::memcpy(pwszDesPath + dwDesRootLen + 1, 
                 pwszRelPath, sizeof(WCHAR) * (dwRelPathLen + 1));

        if (!::MoveFile(pwszSrcPath, pwszDesPath))
        {
            DWORD dwError = GetLastError();

            if (ERROR_FILE_NOT_FOUND != dwError)
            {
                hr = HRESULT_FROM_WIN32(dwError);
            }

            //
            // log the file name that fails to move
            //

            g_fblog.LogFeedback(SSR_FB_ERROR_GENERIC | FBLog_Log, 
                                dwError,
                                pwszSrcPath,
                                IDS_FAIL_MOVE_FILE
                                );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    delete [] pwszSrcPath;
    delete [] pwszDesPath;

    return hr;
}





bool SsrPPressOn (
    IN SsrActionVerb lActionVerb,
    IN LONG          lActionType,
    IN HRESULT       hr
    )
/*++
Routine Description: 

Functionality:
    
    Determines if we should continue based on the error

Virtual:
    
    No.
    
Arguments:

    lActionVerb  - The action

    lActionType  - The type of the action

    hr           - The HRESULT to test

Return Value:

    true or false

Notes:

    This function is just a placeholder for the need of the test. The implementation
    is far from complete.
--*/
{
    UNREFERENCED_PARAMETER(lActionVerb);
    UNREFERENCED_PARAMETER(lActionType);

    if (hr == E_OUTOFMEMORY ||
        hr == E_SSR_MEMBER_XSD_INVALID)
    {
        return false;
    }

    return true;
}





const BSTR
SsrPGetDirectory (
    IN SsrActionVerb lActionVerb,
    IN BOOL          bScriptFile
    )
/*++
Routine Description: 

Functionality:
    
    SSR controls the physical location for its members to place their files.
    This function returns to the caller the physical directory path for a given
    member. Since SSR is an action oriented architecture, such locations are also
    relative to action. If bstrActionVerb is a non-empty string, then the function
    retrieves the loction for that action. Otherwise, the function retrieves the 
    location for the member's root (actions are sub-directories of this root)


Virtual:
    
    No.
    
Arguments:

    lActionVerb     - The action verb in long format

    bScriptFile     - Whether or not it is asking for a script file. If false,
                      it is asking for transformation file

Return Value:

    the file path if we recognize the call.

Notes:

    !!!Warning!!!

    Caller should never release the BSTR
--*/
{
    if (!bScriptFile)
    {
        //
        // asking for transformation files. All of them goes to 
        // the TransformFiles directory
        //

        return g_bstrTransformFilesDir;
    }

    if (lActionVerb == ActionConfigure)
    {
        return g_bstrConfigureFilesDir;
    }
    else if (lActionVerb == ActionRollback)
    {
        return g_bstrRollbackFilesDir;
    }
    else if (lActionVerb == ActionReport)
    {
        return g_bstrReportFilesDir;
    }
    else
    {
        return NULL;
    }

}


HRESULT
SsrPDoDCOMSettings (
    bool bReg
    )
/*++
Routine Description: 

Functionality:
    
    This function will set the security related registry settings for our
    SSR engine com objects


Virtual:
    
    No.
    
Arguments:

    bReg     - whether this is to register or to un-register

Return Value:

    S_OK if succeeded.
    Otherwise, various error codes

Notes:

--*/
{
    HRESULT hr = S_OK;

    PSECURITY_DESCRIPTOR pSD = NULL;

    BOOL bDaclPresent = FALSE, bDaclDefault = FALSE;

    ULONG ulSDSize = 0;

    return 0;
/*
    if (bReg)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
                        g_pwszSsrDCOMSecDescripACL,
                        SDDL_REVISION_1,
                        &pSD,
                        &ulSDSize
                        ) )
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        //
        // unregister, easy, just delete the AppID key
        //

        LONG lStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,
                                    g_pwszAppID);

        if ( lStatus != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        //
        // now let's set the ACLs on these keys
        //

        HKEY hKey = NULL;

        BYTE * lpData = (BYTE*)pSD;
        DWORD dwDataSize = ulSDSize;

        if (FAILED(hr))
        {
            return hr;
        }

        LONG lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    g_pwszAppID,
                                    0,
                                    KEY_WRITE,
                                    &hKey );

        if ( lStatus != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            //
            // set the access
            //

            lStatus = RegSetValueEx(
                                    hKey,
                                    g_pwszAccessPermission,
                                    0,
                                    REG_BINARY,
                                    lpData,
                                    dwDataSize
                                    );

            if ( lStatus == NO_ERROR )
            {
                //
                // set the launch permission
                //

                lStatus = RegSetValueEx(
                                        hKey,
                                        g_pwszLaunchPermission,
                                        0,
                                        REG_BINARY,
                                        lpData,
                                        dwDataSize
                                        );
            }

            if ( lStatus != NO_ERROR )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            RegCloseKey(hKey);
        }
    }

    if (pSD != NULL)
    {
        LocalFree(pSD);
    }

    return hr;
*/}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\global.h ===
//
// global.h
//

#pragma once

#include "stdafx.h"

#include "SSRTE.h"
#include "ssrmsg.h"

#include <map>
#include <vector>

#include "msxml2.h"


class CFBLogMgr;

extern CFBLogMgr g_fblog;

using namespace std;

const ULONG g_ulSsrEngineMajorVersion = 1;
const ULONG g_ulSsrEngineMinorVersion = 0;

const LONG g_lActionVerbConfigure = 1;
const LONG g_lActionVerbRollback = 2;
const LONG g_lActionVerbReport = 3;

const DWORD g_dwHexDwordLen = 11;

const DWORD g_dwResNothing = 0;

extern  WCHAR g_wszSsrRoot[];
extern  DWORD g_dwSsrRootLen;


extern LPCWSTR g_pwszSSRRegRoot;
extern LPCWSTR g_pwszSSRMembersReg;

extern LPCWSTR g_pwszSSRRootToExpand;
extern LPCWSTR g_pwszSSR;
extern LPCWSTR g_pwszLogs;

//
// The following are reserved action verbs
//

extern CComBSTR g_bstrConfigure;
extern CComBSTR g_bstrRollback;
extern CComBSTR g_bstrReport;

//
// the following are reserved file-usage values
//

extern CComBSTR g_bstrLaunch;
extern CComBSTR g_bstrResult;

//
// the following is the reserved action data's names
//

extern LPCWSTR g_pwszCurrSecurityPolicy;
extern LPCWSTR g_pwszTransformFiles;
extern LPCWSTR g_pwszScriptFiles;



//
// the following are element tag names
//

extern CComBSTR g_bstrSsrMemberInfo;
extern CComBSTR g_bstrDescription;
extern CComBSTR g_bstrSupportedAction;
extern CComBSTR g_bstrProcedures;
extern CComBSTR g_bstrDefaultProc;
extern CComBSTR g_bstrCustomProc;
extern CComBSTR g_bstrTransformInfo;
extern CComBSTR g_bstrScriptInfo;

//
// the following are attribute names
//

extern CComBSTR g_bstrAttrUniqueName;
extern CComBSTR g_bstrAttrMajorVersion;
extern CComBSTR g_bstrAttrMinorVersion;
extern CComBSTR g_bstrAttrProgID;
extern CComBSTR g_bstrAttrActionName;
extern CComBSTR g_bstrAttrActionType;
extern CComBSTR g_bstrAttrTemplateFile;
extern CComBSTR g_bstrAttrResultFile;
extern CComBSTR g_bstrAttrScriptFile;
extern CComBSTR g_bstrAttrIsStatic;
extern CComBSTR g_bstrAttrIsExecutable;


extern CComBSTR g_bstrReportFilesDir;
extern CComBSTR g_bstrConfigureFilesDir;
extern CComBSTR g_bstrRollbackFilesDir;
extern CComBSTR g_bstrTransformFilesDir;
extern CComBSTR g_bstrMemberFilesDir;

extern CComBSTR g_bstrTrue;
extern CComBSTR g_bstrFalse;

//
// these are the known action types
// 

extern LPCWSTR g_pwszApply;
extern LPCWSTR g_pwszPrepare;

typedef LONG SsrActionVerb;

const SsrActionVerb ActionInvalid   = 0;
const SsrActionVerb ActionConfigure = 1;
const SsrActionVerb ActionRollback  = 2;
const SsrActionVerb ActionReport    = 3;

const BSTR SsrPGetActionVerbString (
                IN SsrActionVerb action
                );

SsrActionVerb SsrPGetActionVerbFromString (
                IN LPCWSTR pwszVerb
                );


class CMemberAD;

class CActionType
{
public:
    CActionType (
        IN SsrActionVerb lAction,
        IN LONG          lActionType
        ) : m_lAction(lAction), m_lType(lActionType)
    {
    }

    CActionType (
        const CActionType & at
        )
        : m_lAction(at.m_lAction), m_lType(at.m_lType)
    {
    }

    ~CActionType(){}

    SsrActionVerb GetAction()const
    {
        return m_lAction;
    }

    LONG GetActionType()const
    {
        return m_lType;
    }

protected:

    //
    // we don't want anyone (include self) to be able to do an assignment.
    //

    void operator = (const CActionType& );

    SsrActionVerb m_lAction;
    LONG m_lType;

};

//
// some global helper functions
//

//template< class T>

template< class T>
class strLessThan
{
    public:
    bool operator()( const T& X, const T& Y ) const
    {
        return ( _wcsicmp( X, Y ) < 0 );
    }

};

//template<> class strLessThan<BSTR>{};


//template< class T>

template< class T>
class ActionTypeLessThan
{
    public:
    bool operator()( const T& X, const T& Y ) const
    {
        if (X.GetAction() < Y.GetAction())
        {
            return true;
        }
        else if (X.GetAction() == Y.GetAction())
        {
            return X.GetActionType() < Y.GetActionType();
        }
        
        return false;
    }

};

//template<> class ActionTypeLessThan< CActionType >{};


typedef map<BSTR, VARIANT*, strLessThan<BSTR> > MapNameValue;

//typedef MapNameValue::iterator NameValueIterator;

typedef map< const CActionType, CMemberAD*, ActionTypeLessThan< CActionType > > MapMemberAD;

//typedef MapMemberAD::iterator MemberADIterator;

class CSsrMemberAccess;


typedef map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> > MapMemberAccess;

//typedef MapMemberAccess::iterator MemberAccessIterator;


HRESULT 
SsrPDeleteEntireDirectory (
    IN LPCWSTR pwszDirPath
    );

HRESULT
SsrPCreateSubDirectories (
    IN OUT LPWSTR  pwszPath,
    IN      LPCWSTR pwszSubRoot
    );

HRESULT SsrPLoadDOM (
    IN BSTR               bstrFile,   // [in],
    IN LONG               lFlag,      // [in],
    IN IXMLDOMDocument2 * pDOM        // [in]
    );

HRESULT SsrPGetBSTRAttrValue (
    IN IXMLDOMNamedNodeMap * pNodeMap,
    IN  BSTR                 bstrName,
    OUT BSTR               * pbstrValue
    );

HRESULT SsrPCreateUniqueTempDirectory (
        OUT LPWSTR pwszTempDirPath,
        IN  DWORD  dwBufLen
        );

//
// move files from one location to another
//

HRESULT SsrPMoveFiles (
    IN LPCWSTR pwszSrcDirRoot,
    IN LPCWSTR pwszDesDirRoot,
    IN LPCWSTR pwszRelPath
    );

bool SsrPPressOn (
    IN SsrActionVerb lActionVerb,
    IN LONG          lActionType,
    IN HRESULT hr
    );

const BSTR
SsrPGetDirectory (
    IN SsrActionVerb lActionVerb,
    IN BOOL          bScriptFile
    );

HRESULT
SsrPDoDCOMSettings (
    bool bReg
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\sceagent.h ===
// SCEAgent.h : Declaration of the CSCEAgent

#ifndef __SCEAGENT_H_
#define __SCEAGENT_H_

#include "resource.h"       // main symbols
typedef struct _SERVICE_NODE_ {
    PWSTR   Name;
    DWORD   dwStartupType;
    DWORD   dwGeneralUse;
    _SERVICE_NODE_  *Next;
} SERVICE_NODE, *PSERVICE_NODE;

/////////////////////////////////////////////////////////////////////////////
// CSCEAgent
class ATL_NO_VTABLE CSCEAgent : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSCEAgent, &CLSID_SCEAgent>,
	public IDispatchImpl<ISCEAgent, &IID_ISCEAgent, &LIBID_SSRLib>
{
protected:
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSCEAgent (const CSCEAgent& );
    void operator = (const CSCEAgent& );

public:
	CSCEAgent()
	{
        m_headServiceList = NULL;
	}

    virtual ~CSCEAgent()
    {
        Cleanup();
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCEAgent)
	COM_INTERFACE_ENTRY(ISCEAgent)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISCEAgent
public:
    STDMETHOD(CreateRollbackTemplate) (
        IN BSTR bstrTemplatePath,
        IN BSTR bstrRollbackPath,
        IN BSTR bstrLogFilePath
        );

    STDMETHOD(Configure) (
        IN BSTR  bstrTemplate,
        IN LONG  lAreaMask,
        IN BSTR  bstrLogFile
        );

	STDMETHOD(UpdateServiceList) (
        IN BSTR bstrServiceName,
        IN BSTR bstrStartupType
        );

    STDMETHOD(CreateServicesCfgRbkTemplates) (
        IN BSTR bstrTemplatePath,
        IN BSTR bstrRollbackPath,
        IN BSTR bstrLogFilePath
        );
    
private:
    void Cleanup();

    PSERVICE_NODE m_headServiceList;

};

HRESULT
SceStatusToHRESULT (
    DWORD SceStatus
    );


#endif //__SCEAGENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrcore.cpp ===
// SsrCore.cpp : Implementation of CSsrCore

#include "stdafx.h"
#include "SSRTE.h"
#include "ActionData.h"
#include "SSRTEngine.h"
#include "SsrCore.h"

#include "SSRLog.h"

#include "global.h"
#include "util.h"


//-------------------------------------------------------------------------------
// ISsrCore implementation
//-------------------------------------------------------------------------------



/*
Routine Description: 

Name:

    CSsrCore::CSsrCore

Functionality:
    
    constructor

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrCore::CSsrCore() : m_pEngine(NULL)
{
    if (SUCCEEDED(CComObject<CSsrEngine>::CreateInstance(&m_pEngine)))
    {
        m_pEngine->AddRef();
    }
}



/*
Routine Description: 

Name:

    CSsrCore::~CSsrCore

Functionality:
    
    destructor

Virtual:
    
    yes.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrCore::~CSsrCore()
{
    if (m_pEngine != NULL)
    {
        m_pEngine->Release();
    }
}



/*
Routine Description: 

Name:

    CSsrCore::get_ActionData

Functionality:
    
    It returns the engine's action data object (the property bag) which
    holds all runtime and static data needed to carry out the action.

Virtual:
    
    Yes.
    
Arguments:

    pVal - out parameter receives the ISsrActionData object of the engine.

Return Value:

    Success: 
    
        S_OK

    Failure: 

        various error codes.

Notes:
    
*/

STDMETHODIMP
CSsrCore::get_ActionData (
    OUT VARIANT * pVal  // [out, retval] 
    )
{
    HRESULT hr = E_NOTIMPL;
    if (pVal == NULL)
    {
        hr = E_INVALIDARG;
    }

    ::VariantInit(pVal);

    if (m_pEngine != NULL)
    {
        pVal->vt = VT_DISPATCH;
        hr = m_pEngine->GetActionData((ISsrActionData **)&(pVal->pdispVal));
        if (hr != S_OK)
        {
            pVal->vt = VT_EMPTY;
        }
    }
    else
    {
        hr = E_SSR_ENGINE_NOT_AVAILABLE;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrCore::get_Engine

Functionality:
    
    It returns the engine itself.

Virtual:
    
    Yes.
    
Arguments:

    pVal - out parameter receives the ISsrEngine object.

Return Value:

    Success: 
    
        S_OK

    Failure: 

        various error codes.

Notes:
    
*/

STDMETHODIMP
CSsrCore::get_Engine (
    OUT VARIANT * pVal  // [out, retval] 
    )
{
    HRESULT hr = S_OK;
    if (pVal == NULL)
    {
        hr = E_INVALIDARG;
    }

    ::VariantInit(pVal);

    if (m_pEngine != NULL)
    {
        pVal->vt = VT_DISPATCH;
        hr = m_pEngine->QueryInterface(IID_ISsrEngine, (LPVOID*)&(pVal->pdispVal));
        if (hr != S_OK)
        {
            pVal->vt = VT_EMPTY;
            hr = E_SSR_ENGINE_NOT_SUPPORT_INTERFACE;
        }
    }
    else
    {
        hr = E_SSR_ENGINE_NOT_AVAILABLE;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrCore::get_SsrLog

Functionality:
    
    It returns the engine's logging object.

Virtual:

    Yes.

Arguments:

    pVal - out parameter receives the ISsrPreProcessor object.

Return Value:

    Success: 

        S_OK

    Failure: 

        various error codes.

Notes:

*/

STDMETHODIMP
CSsrCore::get_SsrLog (
    OUT VARIANT * pVal  // [out, retval] 
    )
{
    return g_fblog.GetLogObject(pVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\sceagent.cpp ===
// SCEAgent.cpp : Implementation of CSCEAgent
#include "stdafx.h"
#include "SSRTE.h"
#include "SCEAgent.h"
#include "ntsecapi.h"
#include "secedit.h"

/////////////////////////////////////////////////////////////////////////////
// CSCEAgent

static LPCWSTR g_pwszTempDBName = L"5ac90887-f869-4cb6-ae96-892e939a90ad.sdb";


void CSCEAgent::Cleanup()

/*++

Routine Description: 

Name:

    CSCEAgent::Cleanup

Functionality:
    
    Private helper to reduce duplicate code.
    Cleanup any resources that we might hold on.

Virtual:
    
    None.
    
Arguments:

    None

Return Value:

    None.

Notes:

--*/

{
    if (m_headServiceList != NULL)
    {
        PSERVICE_NODE tempNode = m_headServiceList;
        PSERVICE_NODE tempNodeNext = NULL;

        do 
        {
            tempNodeNext = tempNode->Next;

            if (tempNode->Name)
            {
                LocalFree(tempNode->Name);
            }

            LocalFree(tempNode);
            tempNode = tempNodeNext;

        } while ( tempNode != NULL );

        m_headServiceList = NULL;
    }
}

STDMETHODIMP 
CSCEAgent::Configure (
    IN BSTR          bstrTemplate, 
    IN LONG          lAreaMask, 
    IN BSTR OPTIONAL bstrLogFile
    )

/*++

Routine Description: 

Name:

    CSCEAgent::Configure

Functionality:
    
    this is to expose the SCE's configure capability to scripting

Virtual:
    
    Yes.
    
Arguments:

    bstrTemplate    - The template path the configure is based on.

    lAreaMask       - The areas this configure will be run.

    bstrLogFile     - The log file path

Return Value:

    None.

Notes:

    1.  We should really be passing in AREA_ALL for the area mask parameter
        But that requires the caller to use a DWORD flag 65535 in script,
        which is odd. So, we opt to ignore the mask at this point. Meaning
        we will always use AREA_ALL.

--*/

{

    if (bstrTemplate == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // process options
    //

    DWORD dwOption = SCE_OVERWRITE_DB;

    if (bstrLogFile == NULL || *bstrLogFile == L'\0')
    {
        dwOption |= SCE_DISABLE_LOG;
    }
    else
    {
        dwOption |= SCE_VERBOSE_LOG;
    }

    //
    // According to Vishnu, SCE will configure an INF file.
    //

    CComBSTR bstrTempDBFile(bstrTemplate);

    bstrTempDBFile += g_pwszTempDBName;

    if (bstrTempDBFile.m_str != NULL)
    {
	    SCESTATUS rc = ::SceConfigureSystem(
                            NULL,
                            bstrTemplate,
                            bstrTempDBFile,
                            bstrLogFile,
                            dwOption,
                            lAreaMask,
                            NULL,
                            NULL,
                            NULL
                            );

        ::DeleteFile(bstrTempDBFile);

        //
        // we can opt to not to delete the database, but leaving it there will 
        // create confusions
        //

	    return SceStatusToHRESULT(rc);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


STDMETHODIMP 
CSCEAgent::CreateRollbackTemplate (
    IN BSTR bstrTemplatePath,
    IN BSTR bstrRollbackPath,
    IN BSTR bstrLogFilePath
    )

/*++

Routine Description: 

Name:

    CSCEAgent::CreateRollbackTemplate

Functionality:
    
    this is to expose the SCE's rollback tempalte creation capability to scripting

Virtual:
    
    Yes.
    
Arguments:

    bstrTemplatePath    - The template path this rollback will be based on.

    bstrRollbackPath    - The rollback template that will be created

    bstrLogFilePath     - The logfile path

Return Value:

    None.

Notes:

    1. I believe this log file path can be optional. Need to check with JinHuang

--*/

{
	if (bstrTemplatePath == NULL || 
        bstrRollbackPath == NULL)
    {
        return E_INVALIDARG;
    }

    DWORD dwWarning = 0;
    SCESTATUS rc = ::SceGenerateRollback(
                                        NULL,
                                        bstrTemplatePath,
                                        bstrRollbackPath,
                                        bstrLogFilePath,
                                        SCE_VERBOSE_LOG,
                                        AREA_ALL,
                                        &dwWarning
                                        );

    //
    // $undone:shawnwu, how should I use the dwWarning?
    //

    return SceStatusToHRESULT(rc);

}

//
// UpdateServiceList is authored by VishnuP. Please send comments or
// questions to him.
//
 
STDMETHODIMP 
CSCEAgent::UpdateServiceList (
    IN BSTR bstrServiceName,
    IN BSTR bstrStartupType
    )
{
	if (bstrServiceName == NULL || bstrStartupType == NULL )
    {
        return E_INVALIDARG;
    }

    DWORD   dwStartupType;

    if (0 == _wcsicmp(bstrStartupType, L"automatic")) {
        dwStartupType = 2;
    } else if (0 == _wcsicmp(bstrStartupType, L"manual")) {
        dwStartupType = 3;
    } else if (0 == _wcsicmp(bstrStartupType, L"disabled")) {
        dwStartupType = 4;
    } else {
        return E_INVALIDARG;
    }

    PSERVICE_NODE   NewNode = NULL;

    NewNode = (PSERVICE_NODE)LocalAlloc(LMEM_ZEROINIT, 
                                        sizeof(SERVICE_NODE)
                                        );
    if (NewNode == NULL) {
        return E_OUTOFMEMORY;
    }
    
    int iSvcNameLen = wcslen(bstrServiceName) + 1;
    NewNode->Name = (PWSTR)LocalAlloc(
                                      LMEM_ZEROINIT, 
                                      iSvcNameLen * sizeof(WCHAR)
                                      );
    if (NewNode->Name == NULL) {
        LocalFree(NewNode);
        return E_OUTOFMEMORY;
    }

    wcsncpy(NewNode->Name, bstrServiceName, iSvcNameLen);

    NewNode->dwStartupType = dwStartupType;
    NewNode->Next = m_headServiceList;
    m_headServiceList = NewNode;

    return S_OK;

}




//
// CreateServicesCfgRbkTemplates is authored by VishnuP. Please send comments or
// questions to him.
//

STDMETHODIMP 
CSCEAgent::CreateServicesCfgRbkTemplates (
    IN BSTR bstrTemplatePath,
    IN BSTR bstrRollbackPath,
    IN BSTR bstrLogFilePath
    )
{
    UNREFERENCED_PARAMETER(bstrLogFilePath);

	if (bstrTemplatePath == NULL || bstrRollbackPath == NULL)
    {
        return E_INVALIDARG;
    }


    DWORD       dwNumServices = 0;
    SC_HANDLE   hScm = NULL;
    DWORD rc = ERROR_SUCCESS;
    LPENUM_SERVICE_STATUS_PROCESS   pInfo = NULL;
    DWORD *aSCMListStartupTypes = NULL;
    DWORD *aSCMListStartupTypesCfg = NULL;
    SCESVC_CONFIGURATION_INFO ServiceInfo;
    ServiceInfo.Count = dwNumServices;
    ServiceInfo.Lines = NULL;

    //
    // Connect to the service controller.
    //
    
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
    
    if (hScm == NULL) {

        rc = GetLastError();
        goto CleanUp;
    }

    DWORD                           cbInfo   = 0;

    DWORD                           dwResume = 0;

    if ((!EnumServicesStatusEx(
                              hScm,
                              SC_ENUM_PROCESS_INFO,
                              SERVICE_WIN32,
                              SERVICE_STATE_ALL,
                              NULL,
                              0,
                              &cbInfo,
                              &dwNumServices,
                              &dwResume,
                              NULL)) && ERROR_MORE_DATA == GetLastError()) {

        pInfo = (LPENUM_SERVICE_STATUS_PROCESS)LocalAlloc(LMEM_ZEROINIT, cbInfo);

        if (pInfo == NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanUp;
        }

    }

    else {
        rc = GetLastError();
        goto CleanUp;
    }


    if (!EnumServicesStatusEx(
                             hScm,
                             SC_ENUM_PROCESS_INFO,
                             SERVICE_WIN32,
                             SERVICE_STATE_ALL,
                             (LPBYTE)pInfo,
                             cbInfo,
                             &cbInfo,
                             &dwNumServices,
                             &dwResume,
                             NULL)) {

        rc = GetLastError();

        goto CleanUp;
    }

    //
    // get the startup type for each service
    //

    aSCMListStartupTypes = (DWORD *) LocalAlloc (
                                                LMEM_ZEROINIT, 
                                                sizeof(DWORD) * dwNumServices
                                                );
    if (aSCMListStartupTypes == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    aSCMListStartupTypesCfg = (DWORD *) LocalAlloc (
                                                    LMEM_ZEROINIT, 
                                                    sizeof(DWORD) * dwNumServices
                                                    );
    if (aSCMListStartupTypes == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    for (DWORD ServiceIndex=0; ServiceIndex < dwNumServices; ServiceIndex++ ) {

        SC_HANDLE   hService = NULL;
        DWORD BytesNeeded = 0;
        LPQUERY_SERVICE_CONFIG pConfig = NULL;
        hService = OpenService(
                             hScm,
                             pInfo[ServiceIndex].lpServiceName,
                             SERVICE_QUERY_CONFIG);
        if (hService == NULL) {
            rc = GetLastError();
            goto CleanUp;
        }

        if ( !QueryServiceConfig(
                    hService,
                    NULL,
                    0,
                    &BytesNeeded
                    ) && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            rc = GetLastError();
            if (hService) {
                CloseServiceHandle(hService);
                hService = NULL;
            }
            goto CleanUp;
        }

        pConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_ZEROINIT, BytesNeeded);
                
        if ( pConfig == NULL ) {

            rc = ERROR_NOT_ENOUGH_MEMORY;
            if (hService) {
                CloseServiceHandle(hService);
                hService = NULL;
            }
            goto CleanUp;
        }
                    
        //                    
        // the real query of config                    
        //
                    
        if ( !QueryServiceConfig(
                                hService,
                                pConfig,
                                BytesNeeded,
                                &BytesNeeded
                                ) ) {
                        rc = GetLastError();
                        
                        if (hService) {
                            CloseServiceHandle(hService);
                            hService = NULL;
                        }

                        if (pConfig) {
                            LocalFree(pConfig);
                            pConfig = NULL;
                        }
                        goto CleanUp;
        }

        aSCMListStartupTypes[ServiceIndex] = (BYTE)(pConfig->dwStartType);

        if (hService) {
            CloseServiceHandle(hService);
            hService = NULL;
        }

        if (pConfig) {
            LocalFree(pConfig);
            pConfig = NULL;
        }
        
    }

    //
    // configure all startup types for manual and automatic and the rest as disabled
    //

    //
    // first generate the rollback (basically a system snapshot - could be optimized)
    //

    //
    // Prepare SCE structure for generating a configuration template
    //

    WCHAR ppSceTemplateTypeFormat[10][10] = {
        L"2,\"\"",
        L"3,\"\"",
        L"4,\"\""
    };
    

    DWORD dwAllocSize = sizeof(SCESVC_CONFIGURATION_LINE) * dwNumServices;
    ServiceInfo.Lines = (PSCESVC_CONFIGURATION_LINE) LocalAlloc(
                                                                LMEM_ZEROINIT, 
                                                                dwAllocSize
                                                                );
    if (ServiceInfo.Lines == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    for (DWORD ServiceIndex=0; ServiceIndex < dwNumServices; ServiceIndex++ ) {
        ServiceInfo.Lines[ServiceIndex].Key = pInfo[ServiceIndex].lpServiceName;
        ServiceInfo.Lines[ServiceIndex].Value = ppSceTemplateTypeFormat[aSCMListStartupTypes[ServiceIndex] - 2];
        ServiceInfo.Lines[ServiceIndex].ValueLen = sizeof(ppSceTemplateTypeFormat[aSCMListStartupTypes[ServiceIndex] - 2]);
    }

    rc = ::SceSvcSetInformationTemplate(
                                       bstrRollbackPath,
                                       szServiceGeneral,
                                       TRUE,
                                       &ServiceInfo
                                       );
    
    
    BOOL bFoundService;

    for (DWORD ServiceIndex=0; ServiceIndex < dwNumServices; ServiceIndex++ ) {
        bFoundService = FALSE;
        for (PSERVICE_NODE tempNode = m_headServiceList;  tempNode != NULL; tempNode = tempNode->Next ) {
            if (_wcsicmp (tempNode->Name, pInfo[ServiceIndex].lpServiceName) == 0) {
                aSCMListStartupTypesCfg[ServiceIndex] = tempNode->dwStartupType;
                bFoundService = TRUE;
            }
        }
        if (bFoundService == FALSE) {
            //
            // stop services that are not found
            //
            aSCMListStartupTypesCfg[ServiceIndex] = 4;
        }
    }


    for (DWORD ServiceIndex=0; ServiceIndex < dwNumServices; ServiceIndex++ ) {
        ServiceInfo.Lines[ServiceIndex].Value = ppSceTemplateTypeFormat[aSCMListStartupTypesCfg[ServiceIndex] - 2];
        ServiceInfo.Lines[ServiceIndex].ValueLen = sizeof(ppSceTemplateTypeFormat[aSCMListStartupTypesCfg[ServiceIndex] - 2]);
    }

    rc = ::SceSvcSetInformationTemplate(
                                       bstrTemplatePath,
                                       szServiceGeneral,
                                       TRUE,
                                       &ServiceInfo
                                       );


CleanUp:
    
    if (hScm)
        CloseServiceHandle(hScm);

    if (pInfo)
        LocalFree(pInfo);

    if (aSCMListStartupTypes)
        LocalFree (aSCMListStartupTypes);
    
    if (aSCMListStartupTypesCfg)
        LocalFree (aSCMListStartupTypesCfg);
    
    if (ServiceInfo.Lines)
        LocalFree(ServiceInfo.Lines);

    //
    // after we create the templates, we will clean them up
    //

    Cleanup();

    return rc;

}







HRESULT
SceStatusToHRESULT (
    IN SCESTATUS SceStatus
    )

/*++

Routine Description: 

Name:

    SceStatusToHRESULT

Functionality:
    
    converts SCESTATUS error code to dos error defined in winerror.h

Virtual:
    
    N/A.
    
Arguments:

    none.

Return Value:

    HRESULT.

Notes:

--*/

{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return HRESULT_FROM_WIN32(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_NO_MAPPING:
        return HRESULT_FROM_WIN32(ERROR_NONE_MAPPED);

    case SCESTATUS_TRUST_FAIL:
        return HRESULT_FROM_WIN32(ERROR_TRUSTED_DOMAIN_FAILURE);

    case SCESTATUS_INVALID_DATA:
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return HRESULT_FROM_WIN32(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING);
    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);

    case SCESTATUS_MOD_NOT_FOUND:
        return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);

    case SCESTATUS_EXCEPTION_IN_SERVER:
        return HRESULT_FROM_WIN32(ERROR_EXCEPTION_IN_SERVICE);

    default:
        return HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\memberaccess.h ===
// MemberAccess.h : Declaration of the CSsrMemberAccess

#pragma once

#include "resource.h"       // main symbols

#include "global.h"

using namespace std;

class CSsrFilePair
{
public:

    CSsrFilePair(BSTR bstrFirst, BSTR bstrSecond, bool bIsStatic = false, bool bIsExecutable = true)
        : m_bstrFirst(bstrFirst), 
          m_bstrSecond(bstrSecond),
          m_bIsStatic(bIsStatic),
          m_bIsExecutable(bIsExecutable)
    {}

    BSTR GetFirst()const
    {
        return m_bstrFirst;
    }

    BSTR GetSecond()const
    {
        return m_bstrSecond;
    }

    bool IsExecutable()const
    {
        return m_bIsExecutable;
    }

    bool IsStatic()const
    {
        return m_bIsStatic;
    }

protected:
    
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrFilePair (const CSsrFilePair& );
    void operator = (const CSsrFilePair& );

private:
    CComBSTR m_bstrFirst;
    CComBSTR m_bstrSecond;
    bool m_bIsExecutable;
    bool m_bIsStatic;
};

class CSsrProcedure
{
protected:

    //
    // we don't allow direct construction. The only way to do it is
    // via LoadProcedure.
    //

    CSsrProcedure();

public:
    ~CSsrProcedure();

    static HRESULT StaticLoadProcedure (
        IN  IXMLDOMNode    * pNode,
        IN  bool             bDefProc,
        IN  LPCWSTR          pwszProgID,
        OUT CSsrProcedure ** ppNewProc
        );

    bool IsDefaultProcedure()const
    {
        return m_bIsDefault;
    }

    ULONG GetFilePairCount()const
    {
        return m_vecFilePairs.size();
    }

    CSsrFilePair * GetFilePair(
        IN ULONG lIndex
        )const
    {
        if (lIndex < m_vecFilePairs.size())
        {
            return m_vecFilePairs[lIndex];
        }
        else
        {
            return NULL;
        }
    }

    //
    // Warning: don't ever release this returned BSTR!
    //

    BSTR GetProgID() const
    {
        return m_bstrProgID;
    }

protected:
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrProcedure (const CSsrProcedure& );
    void operator = (const CSsrProcedure& );

private:

    bool m_bIsDefault;
    CComBSTR m_bstrProgID;

    vector<CSsrFilePair*> m_vecFilePairs;
};



//---------------------------------------------------------------------------
// CMemberAD encapsulate member specific action data. Each CSsrMemberAccess
// has an array of this class that keeps track of information for each action
//---------------------------------------------------------------------------


class CMemberAD
{
protected:

    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    void operator = (const CMemberAD& );
    CMemberAD (const CMemberAD& );

    //
    // Outsiders must load call LoadAD to create an instance
    // of this class.
    //

    CMemberAD (
        IN SsrActionVerb lActionVerb,
        IN LONG          lActionType
        );


public:

    ~CMemberAD();

    static HRESULT LoadAD (
        IN  LPCWSTR       pwszMemberName,
        IN  IXMLDOMNode * pActionNode,
        IN  LPCWSTR       pwszProgID,
        OUT CMemberAD  ** ppMAD
        );
    
    const BSTR GetActionName()const
    {
        return SsrPGetActionVerbString(m_AT.GetAction());
    }

    LONG GetType()const
    {
        return m_AT.GetActionType();
    }

    const CActionType * GetActionType()const
    {
        return &m_AT;
    }

    int GetProcedureCount()const
    {
        return m_vecProcedures.size();
    }

    const CSsrProcedure * GetProcedure (ULONG lIndex)
    {
        if (lIndex < m_vecProcedures.size())
        {
            return m_vecProcedures[lIndex];
        }
        else
        {
            return NULL;
        }
    }

private:

    HRESULT LoadProcedure (
        IN LPCWSTR       pwszMemberName,
        IN IXMLDOMNode * pNode,
        IN LPCWSTR       pwszProgID
        );

    CActionType m_AT;
    
    vector<CSsrProcedure*> m_vecProcedures;
};


/////////////////////////////////////////////////////////////////////////////
// CSsrMemberAccess

class ATL_NO_VTABLE CSsrMemberAccess : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISsrMemberAccess, &IID_ISsrMemberAccess, &LIBID_SSRLib>
{
protected:
    CSsrMemberAccess()
        : m_ulMajorVersion(0), m_ulMinorVersion(0)
    {
    }

    virtual ~CSsrMemberAccess()
    {
        Cleanup();
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)
DECLARE_NOT_AGGREGATABLE(CSsrMemberAccess)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSsrMemberAccess)
	COM_INTERFACE_ENTRY(ISsrMemberAccess)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISsrMemberAccess
public:

    STDMETHOD(GetSupportedActions) (
	            IN  BOOL      bDefault,
                OUT VARIANT * pvarArrayActionNames  //[out, retval] 
                );

    STDMETHOD(get_Name) (
                OUT BSTR * pbstrName    // [out, retval] 
                );

    STDMETHOD(get_SsrMember) (
                OUT VARIANT * pvarSsrMember //[out, retval] 
                );

    HRESULT Load (
                IN LPCWSTR                   wszMemberFilePath
                );

    CMemberAD * GetActionDataObject (
                IN SsrActionVerb lActionVerb,
                IN LONG          lActionType
                );

    HRESULT MoveOutputFiles (
                IN SsrActionVerb lActionVerb,
                IN LPCWSTR       pwszDirPathSrc,
                IN LPCWSTR       pwszDirPathDest,
                IN bool          bIsDelete,
                IN bool          bLog
                );

    DWORD GetActionCost (
                IN SsrActionVerb lActionVerb,
                IN LONG          lActionType
                )const;


    //
    // ******************** Warning ********************
    // Caller be awared! This is an internal helper for efficient retrieval
    // of name. Caller must not release the returned BSTR in any form.
    // ******************** Warning ********************
    //

    const BSTR GetName()const
    {
        return m_bstrName;
    }

    const BSTR GetProgID()const
    {
        return m_bstrProgID;
    }

private:

    void Cleanup();

    CComBSTR m_bstrName;

    CComBSTR m_bstrProgID;

    MapMemberAD m_mapMemAD;

    ULONG m_ulMajorVersion;
    ULONG m_ulMinorVersion;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SSRTE.rc
//
#define IDS_PROJNAME                    100
#define IDR_SSRTENGINE                  101
#define IDS_TRANSFORM_SUCCEEDED         101
#define IDS_TRANSFORM_FAILED            102
#define IDS_FILEWRITE_FAILED            103
#define IDR_FEEDBACK                    104
#define IDS_FILEREAD_FAILED             104
#define IDS_FILECREATE_FAILED           105
#define IDS_FILECREATE_SUCCEEDED        106
#define IDS_DOM_PROPERTY_PUT_FAILED     107
#define IDS_DOM_LOAD_FAILED             108
#define IDS_NOT_SUPPORTED_SCRIPT_FILE_TYPE  109
#define IDS_EXIT_CODE                   110
#define IDS_ERROR_CREATE_PROCESS        111
#define IDS_EXECUTE_SCRIPT              112
#define IDS_RUNSCRIPTS                  113
#define IDS_LOAD_MEM_ACTION_DATA        114
#define IDS_DO_ACTION_VERB              115
#define IDS_NO_CUSTOM_MEMBER_OBJ        116
#define IDS_MISSING_CUSTOM_MEMBER       117
#define IDS_NO_SCRIPT_FILES             118
#define IDS_TRANSFORM                   119
#define IDS_LAUNCH_SCRIPTS              120
#define IDS_DO_CUSTOM                   121
#define IDS_NO_ACTION                   122
#define IDS_CANNOT_ACCESS_FILE          123
#define IDS_FAIL_MOVE_FILE              124
#define IDS_FAIL_CREATE_DIRECTORY       125
#define IDS_LOAD_SECPOLICY              126
#define IDS_REG_TYPE_NOT_SUPPORTED      127
#define IDS_TOTAL_STEPS                 128
#define IDS_START_CLEANUP_CONFIGURE_OUTPUTS 129
#define IDS_END_CLEANUP_CONFIGURE_OUTPUTS   130
#define IDS_START_BACKUP_ROLLBACK_OUTPUTS   131
#define IDS_END_BACKUP_ROLLBACK_OUTPUTS     132
#define IDS_NO_SCRIPTS_TO_RUN               133
#define IDS_RUNNING_SCRIPTS                 134
#define IDS_INVALID_PARAMETER               135
#define IDS_CREATE_IXSLPROC_FAILED          136
#define IDS_XSL_TRANSFORM_FAILED            137
#define IDS_SSR_START_ACTION_TRANSFORM      138
#define IDS_SSR_START_ACTION_APPLY          139
#define IDS_START_CUSTOM                    140
#define IDS_START_XSL_TRANSFORM             141
#define IDS_START_SCRIPTS                   142
#define IDS_END_CUSTOM                      143
#define IDS_END_XSL_TRANSFORM               144
#define IDS_END_SCRIPTS                     145
#define IDS_SSR_END_ACTION_TRANSFORM        146
#define IDS_SSR_END_ACTION_APPLY            147
#define IDS_MISSING_SECPOLICY               148
#define IDS_SECPOLICY_INVALID_TYPE          149
#define IDS_FAIL_CREATE_XSLT                150
#define IDS_XML_PARSING_ERROR               151
#define IDS_OBJECT_NOT_FOUND                152
#define IDS_MISSING_MEMBER                  153
#define IDS_MEMBER_NOT_SUPPORT_ACTION       154
#define IDS_MISSING_PROGID                  155
#define IDS_XML_LOADING_MEMBER              156
#define IDS_XML_LOADING_PROCEDURE           157


      
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           128
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\memberaccess.cpp ===
// MemberAccess.cpp : Implementation of CSsrMemberAccess

#include "stdafx.h"
#include "SSRTE.h"
#include "SSRLog.h"


#include "MemberAccess.h"

#include "global.h"
#include "util.h"


static bool SsrPIsValidActionType ( DWORD dwType )
{
    return ( (dwType & SSR_ACTION_PREPARE)  ||
             (dwType & SSR_ACTION_APPLY)
           );
}



//
// returning bool instead of bool is on purpose!
//

static bool SsrPIsDefaultAction ( DWORD dwType )
{
    return ( (dwType & SSR_ACTION_PREPARE)  ||
             (dwType & SSR_ACTION_APPLY)
           );
}


static bool SsrPIsSupportedRegValueType (DWORD dwType)
{
    return (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_DWORD);
}

//---------------------------------------------------------------------
// CSsrMemberAccess implementation
//---------------------------------------------------------------------



/*
Routine Description: 

Name:

    CSsrMemberAccess::Cleanup

Functionality:
    
    Cleanup the resource held by the object

Virtual:
    
    No.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

void CSsrMemberAccess::Cleanup()
{

    MapMemberAD::iterator it = m_mapMemAD.begin();
    MapMemberAD::iterator itEnd = m_mapMemAD.end();

    while(it != itEnd)
    {
        CMemberAD * pVal = (*it).second;
        delete pVal;

        it++;
    }

    m_mapMemAD.clear();
    m_bstrName.Empty();
    m_bstrProgID.Empty();
}


/*
Routine Description: 

Name:

    CSsrMemberAccess::GetSupportedActions

Functionality:
    
    Get the names of the actions supported by this member

Virtual:
    
    yes.
    
Arguments:

    bDefault        - If true, then this function queries the default actions
    
    pvarActionNames - The out parameter that receives the names of the actions of
                      the given type supported by this member

Return Value:

    Success: S_OK if there are actions of the type and the names are returned
             S_FALSE if there is no such actions supported by the member.

    Failure: various error codes.

Notes:
    

*/

STDMETHODIMP
CSsrMemberAccess::GetSupportedActions (
	IN  BOOL      bDefault,
    OUT VARIANT * pvarActionNames  //[out, retval] 
    )
{
    if (pvarActionNames == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // now, create the array of action names
    //

    ::VariantInit(pvarActionNames);

    //
    // let's see how many actions of this type exists
    //

    MapMemberAD::iterator it = m_mapMemAD.begin();
    MapMemberAD::iterator itEnd = m_mapMemAD.end();

    int iCount = 0;

    //
    // we need to find out how many actions are of the given type
    //

    while(it != itEnd)
    {
        CMemberAD * pAD = (*it).second;
        _ASSERT(pAD != NULL);

        //
        // Be aware! Don't simply use bDefault == ::SsrPIsDefaultAction to test
        // because bDefault will be -1 when it comes from scripts!
        //

        if (bDefault && ::SsrPIsDefaultAction(pAD->GetType()) ||
            !bDefault && !::SsrPIsDefaultAction(pAD->GetType()))
        {
            ++iCount;
        }
        ++it;
    }

    if (iCount == 0)
    {
        return S_FALSE;
    }

    //
    // given the count we just get, now we know how big a safearray
    // we need to create.
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iCount;

    SAFEARRAY * psa = ::SafeArrayCreate(VT_VARIANT , 1, rgsabound);

    HRESULT hr = S_OK;

    if (psa == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //
        // we only add one name at a time
        //

        long indecies[1] = {0};

        it = m_mapMemAD.begin();

        while(it != itEnd)
        {
            CMemberAD * pAD = (*it).second;
            _ASSERT(pAD != NULL);

            //
            // count only those actions that match the requested action type
            //

            if (bDefault && ::SsrPIsDefaultAction(pAD->GetType()) ||
                !bDefault && !::SsrPIsDefaultAction(pAD->GetType()))
            {
                VARIANT v;
                v.vt = VT_BSTR;
                v.bstrVal = ::SysAllocString(pAD->GetActionName());

                if (v.bstrVal != NULL)
                {
                    hr = ::SafeArrayPutElement(psa, indecies, &v);
                    ::VariantClear(&v);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr))
                {
                    break;
                }

                indecies[0]++;
            }

            ++it;
        }

        //
        // only return the safearray if everything goes well
        //

        if (SUCCEEDED(hr))
        {
            pvarActionNames->vt = VT_ARRAY | VT_VARIANT;
            pvarActionNames->parray = psa;
        }
        else
        {
            ::SafeArrayDestroy(psa);
        }

    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrMemberAccess::get_Name

Functionality:
    
    Get the names of the member.

Virtual:
    
    yes.
    
Arguments:

    pbstrName   - the BSTR which is the action of the member.

Return Value:

    Success: S_OK as long as pbstrName is not NULL (which is invalid)

    Failure: various error codes.

Notes:
    

*/

STDMETHODIMP
CSsrMemberAccess::get_Name (
    OUT BSTR * pbstrName    // [out, retval] 
    )
{
    if (pbstrName == NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrName = ::SysAllocString(m_bstrName);

    return (NULL == *pbstrName) ? E_OUTOFMEMORY : S_OK;
}



/*
Routine Description: 

Name:

    CSsrMemberAccess::get_SsrMember

Functionality:
    
    Return the SsrMember property - the custom ISsrMember object implemented by 
    the member who desires to implement some custom behavior for certain actions.


Virtual:
    
    yes.
    
Arguments:

    pvarSsrMember   - Out parameter receiving the custom ISsrMember object 
                      implemented by the member who desires to implement some
                      custom behavior for certain actions.

Return Value:

    Success: S_OK if this member does have a custom implementation
             of ISsrMember. 

             S_FALSE if this member doesn't have a custom 
             implementation of ISsrMember.

    Failure: various error codes

Notes:
    

*/

STDMETHODIMP
CSsrMemberAccess::get_SsrMember (
    OUT VARIANT * pvarSsrMember //[out, retval] 
    )
{
    if (pvarSsrMember == NULL)
    {
        return E_INVALIDARG;
    }

    ::VariantInit(pvarSsrMember);

    HRESULT hr = S_FALSE;

    if (m_bstrProgID != NULL)
    {
        //
        // now create the COM object
        //

        GUID clsID;

        hr = ::CLSIDFromProgID(m_bstrProgID, &clsID);

        if (S_OK == hr)
        {
            ISsrMember * pISsrMember = NULL;
            hr = ::CoCreateInstance(clsID, 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER, 
                                    IID_ISsrMember, 
                                    (LPVOID*)&pISsrMember
                                    );

            if (S_OK == hr)
            {
                pvarSsrMember->vt = VT_DISPATCH;
                pvarSsrMember->pdispVal = pISsrMember;
            }
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CSsrMemberAccess::Load

Functionality:
    
    Will create this object based on the information available
    from the registry key.

Virtual:
    
    no.
    
Arguments:

    wszMemberFilePath   - The path for the member registration XML file.

Return Value:

    Success: S_OK if there are concrete member information being 
             loaded (has action data). 
             
             S_FALSE if there is really nothing this member has registered.
             Such a member should be discarded because it doesn't contain
             anything that SSR can use.

    Failure: various error codes.

Notes:
    

*/

HRESULT
CSsrMemberAccess::Load (
    IN LPCWSTR  wszMemberFilePath
    )
{
    if (wszMemberFilePath == NULL || *wszMemberFilePath == L'\0')
    {
        return E_INVALIDARG;
    }

    //
    // just in case, this object is called to Load twice, clean up everything first
    //

    Cleanup();

    //
    // load the DOM
    //

    CComPtr<IXMLDOMDocument2> srpXmlDom;

    HRESULT hr = ::CoCreateInstance(CLSID_DOMDocument40, 
                            NULL, 
                            CLSCTX_SERVER, 
                            IID_IXMLDOMDocument2, 
                            (LPVOID*)(&srpXmlDom) 
                            );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = SsrPLoadDOM(CComBSTR(wszMemberFilePath), SSR_LOADDOM_VALIDATE_ON_PARSE, srpXmlDom);

    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IXMLDOMElement>  srpXMLDocRoot;
    hr = srpXmlDom->get_documentElement(&srpXMLDocRoot);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the UniqueName attribute
    //

    CComPtr<IXMLDOMNamedNodeMap> srpAttr;

    if (SUCCEEDED(hr))
    {
        CComVariant varAttr;
        hr = srpXMLDocRoot->getAttribute(g_bstrAttrUniqueName, &varAttr);

        if (FAILED(hr) || varAttr.vt != VT_BSTR)
        {
            //
            // we must have the unique name. This fails, we log and quit
            //

            return hr;
        }
        else
        {
            m_bstrName = varAttr.bstrVal;
            varAttr.vt = VT_EMPTY;
        }

        //
        // first, let's see if there is a ProgID value. We will ignore
        // any failure of reading the ProgID since it may not be there at all.
        //

        if (SUCCEEDED(srpXMLDocRoot->getAttribute(g_bstrAttrProgID, &varAttr)) && 
            varAttr.vt == VT_BSTR)
        {
            m_bstrProgID = varAttr.bstrVal;
            varAttr.vt = VT_EMPTY;
        }

        varAttr.Clear();

        //
        // Let's grab the major and minor versions. Currently, we don't have any
        // implementation to enforce them other than that the major version must
        // the same as our dll's. Otherwise we quit
        //

        if (SUCCEEDED(srpXMLDocRoot->getAttribute(g_bstrAttrMajorVersion, &varAttr)))
        {
            CComVariant varMajor;

            if (SUCCEEDED(VariantChangeType(&varMajor, &varAttr, VARIANT_NOVALUEPROP, VT_UI4)))
            {
                m_ulMajorVersion = varMajor.ulVal;
            }
        }

        if (m_ulMajorVersion != g_ulSsrEngineMajorVersion)
        {
            return E_SSR_MAJOR_VERSION_MISMATCH;
        }

        varAttr.Clear();

        if (SUCCEEDED(srpXMLDocRoot->getAttribute(g_bstrAttrMinorVersion, &varAttr)))
        {
            CComVariant varMinor;
            if (SUCCEEDED(VariantChangeType(&varMinor, &varAttr, VARIANT_NOVALUEPROP, VT_UI4)))
            {
                m_ulMinorVersion = varMinor.ulVal;
            }
        }
    }

    //
    // now, let's load each action
    //

    CComPtr<IXMLDOMNode> srpActionNode;
    hr = srpXMLDocRoot->get_firstChild(&srpActionNode);

    bool bLoaded = false;

    while (SUCCEEDED(hr) && srpActionNode != NULL)
    {
        CComBSTR bstrName;
        srpActionNode->get_nodeName(&bstrName);

        if (_wcsicmp(bstrName, g_bstrSupportedAction) == 0)
        {
            //
            // we only care about SupportedAction elements
            //

            CMemberAD * pMAD = NULL;

            hr = CMemberAD::LoadAD(m_bstrName, srpActionNode, m_bstrProgID, &pMAD);

            if (SUCCEEDED(hr))
            {
                //
                // we might load some empty procedure
                //

                if (pMAD != NULL)
                {
                    const CActionType * pAT = pMAD->GetActionType();

                    m_mapMemAD.insert(MapMemberAD::value_type(*pAT, pMAD));

                    bLoaded = true;
                }
            }
            else
            {
                g_fblog.LogFeedback(SSR_FB_ERROR_LOAD_MEMBER | FBLog_Log, 
                                    hr,
                                    wszMemberFilePath,
                                    IDS_XML_LOADING_MEMBER
                                    );
                break;
            }
        }


        CComPtr<IXMLDOMNode> srpNext;
        hr = srpActionNode->get_nextSibling(&srpNext);
        srpActionNode.Release();
        srpActionNode = srpNext;
    }

    if (FAILED(hr))
    {
        g_fblog.LogError(hr, L"CSsrMemberAccess::Load", wszMemberFilePath);
    }
    else if (bLoaded)
    {
        hr = S_OK;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrMemberAccess::GetActionDataObject

Functionality:
    
    Will find and return (if found) the CMemberAD that of the given name.
    This is a helper function


Virtual:
    
    no.
    
Arguments:

    lActionVerb  - The action verb in long format.

    lActionType  - The action type

Return Value:

    If found, then the CMemberAD object pointer is return. It will return NULl
    if the given action is not registered or this operation can't be completed.

Notes:
    

*/

CMemberAD* 
CSsrMemberAccess::GetActionDataObject (
    IN SsrActionVerb lActionVerb,
    IN LONG          lActionType
    )
{
    CActionType at(lActionVerb, lActionType);

    MapMemberAD::iterator it = m_mapMemAD.find(at);
    MapMemberAD::iterator itEnd = m_mapMemAD.end();

    if (it != itEnd)
    {
        CMemberAD * pAD = (*it).second;
        return pAD;
    }

    return NULL;
}





/*
Routine Description: 

Name:

    CSsrMemberAccess::MoveOutputFiles

Functionality:
    
    Will move/delete all those output files.


Virtual:
    
    no.
    
Arguments:

    bstrActionVerb  - the action verb

    pwszDirPathSrc  - The directory path from which the files will be moved.

    pwszDirPathSrc  - The directory path to which the files will be moved. This will
                      be ignored if the action is a delete

    bDelete         - Flag as whether the action is a move or delete.

    bLog            - To prevent extraneous logging during restoring (backed up
                      files), if this is not true, then no logging will occur


Return Value:

    Success: S_OK

    Failure: various error codes

Notes:
    

*/

HRESULT 
CSsrMemberAccess::MoveOutputFiles (
    IN SsrActionVerb lActionVerb,
    IN LPCWSTR       pwszDirPathSrc,
    IN LPCWSTR       pwszDirPathDest,
    IN bool          bDelete,
    IN bool          bLog
    )
{
    if (bLog)
    {
        CComBSTR bstrMsg(L"...");
        bstrMsg += m_bstrName;

        if (bstrMsg.m_str != NULL)
        {
            g_fblog.LogString(bstrMsg);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    if (lActionVerb     == ActionInvalid    || 
        pwszDirPathSrc  == NULL             || 
        pwszDirPathDest == NULL && !bDelete )
    {
        return E_INVALIDARG;
    }

    //
    // output files are the transformation results. So, we need
    // the transformation result action data, which has the (xsl, output)
    // file pairs
    //

    //
    // find the action data for the given action
    //

    CActionType at(lActionVerb, SSR_ACTION_PREPARE);

    MapMemberAD::iterator it = m_mapMemAD.find(at);

    HRESULT hr = S_OK;

    //
    // since we will continue the cleanup in case of errors
    // we will return the last error
    //

    HRESULT hrLastError = S_OK;

    if (it != m_mapMemAD.end())
    {
        CMemberAD * pAD = (*it).second;

        _ASSERT(pAD != NULL);

        int iProcCount = pAD->GetProcedureCount();

        //
        // Each member (CMemberAD) may have multiple procedures for this action
        //

        for (int iProcIndex = 0; iProcIndex < iProcCount; iProcIndex++)
        {
            const CSsrProcedure * pProc = pAD->GetProcedure(iProcIndex);
            _ASSERT(pProc != NULL);

            int iFilePairsCount = pProc->GetFilePairCount();

            CSsrFilePair * pFilePair;

            //
            // each procedure may contain multiple file pairs
            //

            for (int iFPIndex = 0; iFPIndex < iFilePairsCount; iFPIndex++)
            {
                pFilePair = pProc->GetFilePair(iFPIndex);

                _ASSERT(pFilePair != NULL);

                //
                // if no second file (which is the result file) or the
                // second file is a static file, then don't bother to move them
                //

                if ( pFilePair->GetSecond() == NULL || pFilePair->IsStatic() )
                {
                    continue;
                }

                //
                // move/delete this file
                //

                CComBSTR bstrSrcFullPath(pwszDirPathSrc);
                bstrSrcFullPath += L"\\";
                bstrSrcFullPath += pFilePair->GetSecond();
                if (bstrSrcFullPath.m_str == NULL)
                {
                    return E_OUTOFMEMORY;
                }

                if (bDelete)
                {
                    ::DeleteFile(bstrSrcFullPath);
                }
                else
                {
                    CComBSTR bstrDestFullPath(pwszDirPathDest);
                    bstrDestFullPath += L"\\";
                    bstrDestFullPath += pFilePair->GetSecond();

                    if (bstrDestFullPath.m_str == NULL)
                    {
                        return E_OUTOFMEMORY;
                    }

                    ::MoveFile(bstrSrcFullPath, bstrDestFullPath);
                }

                DWORD dwErrorCode = GetLastError();

                if (dwErrorCode != ERROR_SUCCESS && 
                    dwErrorCode != ERROR_FILE_NOT_FOUND)
                {
                    hr = HRESULT_FROM_WIN32(dwErrorCode);

                    //
                    // we will continue to delete the others. But log it
                    //

                    if (bLog)
                    {
                        hrLastError = hr;
                        g_fblog.LogFeedback(SSR_FB_ERROR_FILE_DEL | FBLog_Log, 
                                            hrLastError,
                                            bstrSrcFullPath,
                                            g_dwResNothing
                                            );

                    }
                }
            }
        }
    }

    return hrLastError;
}

DWORD 
CSsrMemberAccess::GetActionCost (
    IN SsrActionVerb lActionVerb,
    IN LONG          lActionType
    )const
{
    CActionType at(lActionVerb, lActionType);

    MapMemberAD::iterator it = m_mapMemAD.find(at);

    DWORD dwSteps = 0;

    if (it != m_mapMemAD.end())
    {
        CMemberAD * pAD = (*it).second;
        _ASSERT(pAD != NULL);

        for (int i = 0; i < pAD->GetProcedureCount(); i++)
        {
            const CSsrProcedure * pProc = pAD->GetProcedure(i);

            if (pProc->IsDefaultProcedure())
            {
                //
                // each file pair will count as two steps
                //

                dwSteps += 2 * pProc->GetFilePairCount();
            }
            else
            {
                //
                // we have to consult with the custom member
                //

                CComPtr<ISsrMember> srpCusMember;

                GUID clsID;

                HRESULT hr = ::CLSIDFromProgID(pProc->GetProgID(), &clsID);

                if (S_OK == hr)
                {
                    hr = ::CoCreateInstance(clsID, 
                                            NULL, 
                                            CLSCTX_INPROC_SERVER, 
                                            IID_ISsrMember, 
                                            (LPVOID*)&srpCusMember
                                            );
                }

                if (SUCCEEDED(hr))
                {
                    LONG lCost = 0;
                    hr = srpCusMember->get_ActionCost(SsrPGetActionVerbString(lActionVerb),
                                                      lActionType,
                                                      SSR_ACTION_COST_STEPS,
                                                      &lCost
                                                      );

                    if (SUCCEEDED(hr))
                    {
                        dwSteps += lCost;
                    }
                }

            }
        }
    }

    return dwSteps;
}


/*
Routine Description: 

Name:

    CMemberAD::CMemberAD

Functionality:
    
    Constructor.


Virtual:
    
    no.
    
Arguments:

    lActionVerb - The verb of the action.

    lActionType - The type of the action

Return Value:

    None

Notes:

*/

CMemberAD::CMemberAD (
    IN SsrActionVerb lActionVerb,
    IN LONG          lActionType
    ) : m_AT(lActionVerb, lActionType)
{
}




/*
Routine Description: 

Name:

    CMemberAD::~CMemberAD

Functionality:
    
    destructor. This will clean up our map which contains BSTRs and VARIANTs,
    both of which are heap objects.


Virtual:
    
    no.
    
Arguments:

    None.

Return Value:

    None

Notes:

*/

CMemberAD::~CMemberAD()
{
    for (ULONG i = 0; i < m_vecProcedures.size(); i++)
    {
        delete m_vecProcedures[i];
    }

    m_vecProcedures.clear();
}





/*
Routine Description: 

Name:

    CMemberAD::LoadAD

Functionality:
    
    Will create an a action data object pertaining to a 
    particular member and an action name.


Virtual:
    
    no.
    
Arguments:

    pActionNode     - The SsrAction node

    ppMAD           - The out parameter that receives the 
                      heap object created by this function

Return Value:

    Success: S_OK if there are concrete action data loaded 
             and in that case the out paramter ppMAD will
             point to the heap object. Otherwise, *ppMAD == NULL;

    Failure: various error codes.

Notes:
    
    2. Caller is responsible for releaseing the CMemberAD 
       object passed back by the function.

*/

HRESULT
CMemberAD::LoadAD (
    IN  LPCWSTR       pwszMemberName,
    IN  IXMLDOMNode * pActionNode,
    IN  LPCWSTR       pwszProgID,
    OUT CMemberAD  ** ppMAD
    )
{
    if (ppMAD == NULL)
    {
        return E_INVALIDARG;
    }

    *ppMAD = NULL;

    if (pActionNode == NULL)
    {
        return E_INVALIDARG;
    }

    CComPtr<IXMLDOMNamedNodeMap> srpAttr;

    HRESULT hr = pActionNode->get_attributes(&srpAttr);

    //
    // we must have attributes
    //

    if (FAILED(hr))
    {
        return hr;
    }

    CComBSTR bstrActionName, bstrActionType;
    LONG lActionType;

    //
    // ActionName and ActionType are mandatory attributes
    //

    hr = SsrPGetBSTRAttrValue(srpAttr, g_bstrAttrActionName, &bstrActionName);
    if (FAILED(hr))
    {
        return hr;
    }

    SsrActionVerb lActionVerb = SsrPGetActionVerbFromString(bstrActionName);
    if (lActionVerb == ActionInvalid)
    {
        return E_SSR_INVALID_ACTION_VERB;
    }

    hr = SsrPGetBSTRAttrValue(srpAttr, g_bstrAttrActionType, &bstrActionType);

    if (FAILED(hr))
    {
        return hr;
    }

    if (_wcsicmp(bstrActionType, g_pwszPrepare) == 0)
    {
        lActionType = SSR_ACTION_PREPARE;
    }
    else
    {
        _ASSERT(_wcsicmp(bstrActionType, g_pwszApply) == 0);
        lActionType = SSR_ACTION_APPLY;
    }

    *ppMAD = new CMemberAD(lActionVerb, lActionType);

    if (*ppMAD == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // now, we need to load the each individual procedure
    //

    bool bLoaded = false;

    if (SUCCEEDED(hr))
    {
        CComPtr<IXMLDOMNode> srpProcedure;
        hr = pActionNode->get_firstChild(&srpProcedure);

        while (SUCCEEDED(hr) && srpProcedure != NULL)
        {
            CComBSTR bstrName;
            srpProcedure->get_nodeName(&bstrName);

            bool bDefProc = _wcsicmp(bstrName, g_bstrDefaultProc) == 0;
            bool bCusProc = _wcsicmp(bstrName, g_bstrCustomProc) == 0;

            //
            // we only care about DefaultProc and CustomProc elements
            //
            if ( bDefProc || bCusProc )
            {

                CSsrProcedure * pNewProc = NULL;
                if (SUCCEEDED(hr))
                {
                    hr = CSsrProcedure::StaticLoadProcedure(srpProcedure, bDefProc, pwszProgID, &pNewProc);
                }
        
                if (SUCCEEDED(hr))
                {
                    //
                    // give it to our vector
                    //

                    (*ppMAD)->m_vecProcedures.push_back(pNewProc);
                    bLoaded = true;
                }
                else
                {
                    //
                    // will quit loading
                    //

                    g_fblog.LogFeedback(SSR_FB_ERROR_LOAD_MEMBER | FBLog_Log, 
                                        hr,
                                        pwszMemberName,
                                        IDS_XML_LOADING_PROCEDURE
                                        );
                    break;
                }
            }

            CComPtr<IXMLDOMNode> srpNext;
            hr = srpProcedure->get_nextSibling(&srpNext);
            srpProcedure.Release();
            srpProcedure = srpNext;
        }
    }

    //
    // either failed or loaded nothing
    //

    if (FAILED(hr) || !bLoaded)
    {
        delete *ppMAD;
        *ppMAD = NULL;
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}



CSsrProcedure::CSsrProcedure()
: m_bIsDefault(true)
{
}

CSsrProcedure::~CSsrProcedure()
{
    for (ULONG i = 0; i < m_vecFilePairs.size(); i++)
    {
        delete m_vecFilePairs[i];
    }

    m_vecFilePairs.clear();
}

HRESULT
CSsrProcedure::StaticLoadProcedure (
    IN  IXMLDOMNode    * pNode,
    IN  bool             bDefProc,
    IN  LPCWSTR          pwszProgID,
    OUT CSsrProcedure ** ppNewProc
    )
{
    if (ppNewProc == NULL)
    {
        return E_INVALIDARG;
    }

    *ppNewProc = NULL;

    if (pNode == NULL)
    {
        return E_INVALIDARG;
    }

    *ppNewProc = new CSsrProcedure;

    if (*ppNewProc == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // let's determine if this procedure is a default proc or custom proc.
    // That is determined by the tag name.
    //

    CComPtr<IXMLDOMNamedNodeMap> srpAttr;
    CComBSTR bstrTagName;

    HRESULT hr = S_OK;

    if (!bDefProc)
    {
        //
        // we are loding custom proc
        //

        (*ppNewProc)->m_bIsDefault = false;

        //
        // in this case, you should have no more than the ProgID that we care
        //

        hr = pNode->get_attributes(&srpAttr);
        _ASSERT(srpAttr);

        CComBSTR bstrProgID;

        if (SUCCEEDED(hr))
        {
            //
            // will try to get the ProgID attribute, may fail and we
            // don't care if it does
            //

            SsrPGetBSTRAttrValue(srpAttr, g_bstrAttrProgID, &bstrProgID);
        }

        if (bstrProgID != NULL)
        {
            (*ppNewProc)->m_bstrProgID = bstrProgID;
        }
        else
        {
            (*ppNewProc)->m_bstrProgID = pwszProgID;
        }
    }
    else
    {
        //
        // for default procedures, we should have a list of TransformFiles or ScriptFiles
        // elements. But we will create for both type of elements a CSsrFilePair object
        // and put it in the m_vecFilePairs vector
        //

        //
        // for that purpose, we need to traverse through the in sequential order
        // the TransformFiles and ScriptFiles elements
        //

        CComPtr<IXMLDOMNode> srpFilePairNode;
        CComPtr<IXMLDOMNode> srpNext;
        hr = pNode->get_firstChild(&srpFilePairNode);

        while (SUCCEEDED(hr) && srpFilePairNode != NULL)
        {
            //
            // Get the tag name. Empty the smart pointer so that we can re-use it
            //
    
            CComPtr<IXMLDOMNamedNodeMap> srpFilePairAttr;

            bstrTagName.Empty();

            hr = srpFilePairNode->get_nodeName(&bstrTagName);
            _ASSERT(SUCCEEDED(hr));

            if (FAILED(hr))
            {
                break;
            }

            hr = srpFilePairNode->get_attributes(&srpFilePairAttr);
            _ASSERT(srpAttr);

            //
            // we will ignore all other elements because we only know
            // two possible types of elements: TransformInfo and ScriptInfo
            //

            if (_wcsicmp(bstrTagName, g_bstrTransformInfo) == 0)
            {
                //
                // if it is a TransformFiles element, then, we really have a pair
                // (xsl, script)
                //

                //
                // we have potentially both TemplateFile and ResultFile attributes
                //

                CComBSTR bstrXsl, bstrResult;
                hr = SsrPGetBSTRAttrValue(srpFilePairAttr, g_bstrAttrTemplateFile, &bstrXsl);
                _ASSERT(SUCCEEDED(hr));

                //
                // may not have this one
                //

                SsrPGetBSTRAttrValue(srpFilePairAttr, g_bstrAttrResultFile, &bstrResult);

                if (SUCCEEDED(hr))
                {
                    //
                    // any result file is used as a result file (funny?), which means that the 
                    // file is created during the process of transformation
                    //

                    CSsrFilePair * pNewFilePair = new CSsrFilePair(bstrXsl, bstrResult);
                    if (pNewFilePair != NULL)
                    {
                        (*ppNewProc)->m_vecFilePairs.push_back(pNewFilePair);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

            }
            else if (_wcsicmp(bstrTagName, g_bstrScriptInfo) == 0)
            {

                //
                // we will only have ScriptFile and usage attributes
                //

                CComBSTR bstrAttr;
                CComBSTR bstrScript;
                hr = SsrPGetBSTRAttrValue(srpFilePairAttr, g_bstrAttrScriptFile, &bstrScript);
                _ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr))
                {

                    //
                    // may not have this one, but in that case, it is defaulted
                    // to "Launch". Since an executable file will be launched,
                    // it's safer to assume that it is not an executable file.
                    // Likewise, since non-static file will be removed during
                    // preparation, we'd better assume that it is a static.
                    //

                    bool bIsExecutable = false;
                    bool bIsStatic = true;

                    //
                    // Get the IsExecutable attribute
                    //

                    bstrAttr.Empty();
                    if ( SUCCEEDED(SsrPGetBSTRAttrValue(srpFilePairAttr, 
                                                        g_bstrAttrIsExecutable, 
                                                        &bstrAttr)) &&
                         bstrAttr != NULL )
                    {
                        //
                        // err on the side of false is safer
                        //

                        if (_wcsicmp(bstrAttr, g_bstrTrue) != 0)
                        {
                            bIsExecutable = false;
                        }
                        else
                        {
                           bIsExecutable = true;
                        }
                    }

                    //
                    // Get the IsStatic attribute.
                    //

                    bstrAttr.Empty();
                    if ( SUCCEEDED(SsrPGetBSTRAttrValue(srpFilePairAttr, 
                                                        g_bstrAttrIsStatic, 
                                                        &bstrAttr)) &&
                         bstrAttr != NULL )
                    {
                        if (_wcsicmp(bstrAttr, g_bstrFalse) == 0)
                        {
                            bIsStatic = false;
                        }
                    }

                    //
                    // the script may be a result of a preparation, or a script file
                    // to launch during the action
                    //

                    CSsrFilePair * pNewFilePair = new CSsrFilePair(NULL, bstrScript, bIsStatic, bIsExecutable);
                    if (pNewFilePair != NULL)
                    {
                        (*ppNewProc)->m_vecFilePairs.push_back(pNewFilePair);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

            }

            if (FAILED(hr))
            {
                break;
            }

            //
            // if it is a ScriptFiles element, then, it only has the script file
            //

            hr = srpFilePairNode->get_nextSibling(&srpNext);
            srpFilePairNode = srpNext;
            srpNext.Release();
        }
    }

    if (FAILED(hr) && *ppNewProc != NULL)
    {
        delete *ppNewProc;
        *ppNewProc = NULL;
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrcore.h ===
// SsrCore.h : Declaration of the CSsrCore

#pragma once

#include "resource.h"

#include <vector>

using namespace std;

class CSsrMembership;

class CSsrActionData;

class CSsrEngine;

class CSafeArray;



/////////////////////////////////////////////////////////////////////////////
// CSSRTEngine
class ATL_NO_VTABLE CSsrCore : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSsrCore, &CLSID_SsrCore>,
	public IDispatchImpl<ISsrCore, &IID_ISsrCore, &LIBID_SSRLib>
{
protected:
    CSsrCore();

    virtual ~CSsrCore();

    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrCore (const CSsrCore& );
    void operator = (const CSsrCore& );

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSsrCore)
	COM_INTERFACE_ENTRY(ISsrCore)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISsrCore
public:
	STDMETHOD(get_ActionData)(
        OUT VARIANT * pVal  // [out, retval] 
        );

	STDMETHOD(get_Engine)(
        OUT VARIANT * pVal  // [out, retval] 
        );


	STDMETHOD(get_SsrLog)(
        OUT VARIANT * pVal  // [out, retval] 
        );

private:

    CComObject<CSsrEngine> * m_pEngine;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrte.cpp ===
// SSRTE.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for SSRTE.idl by adding the following 
//      files to the Outputs.
//          SSRTE_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f SSRTEps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include "SSRTE.h"
#include "dlldatax.h"

#include "SSRTE_i.c"

#include "SSRMemberShip.h"
#include "SsrCore.h"
#include "SSRLog.h"
#include "SCEAgent.h"

#include "global.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SsrCore, CSsrCore)
//OBJECT_ENTRY(CLSID_SsrMembership, CSsrMembership)
OBJECT_ENTRY(CLSID_SsrLog, CSsrLog)
OBJECT_ENTRY(CLSID_SCEAgent, CSCEAgent)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SSRLib);
        DisableThreadLibraryCalls(hInstance);
        
        //
        // if we haven't initialize ourselves before
        //

        if (g_dwSsrRootLen == 0)
        {
            g_wszSsrRoot[0] = L'\0';

            //
            // ExpandEnvironmentStrings returns the total length of 
            // expanded buffer, including 0 terminator.
            //
    
            g_dwSsrRootLen =::ExpandEnvironmentStrings (
                                                        g_pwszSSRRootToExpand,
                                                        g_wszSsrRoot,
                                                        MAX_PATH + 1
                                                        );

            if (g_dwSsrRootLen == 0)
            {
                //
                // we have a failure.
                //
                
                return FALSE;
            }

            //
            // ExpandEnvironmentStrings includes the 0 terminator in its return value
            //

            g_dwSsrRootLen -= 1;

            //
            // create the various directory paths needed throughout out code
            //

            WCHAR wcPath[MAX_PATH + 2];
            wcPath[MAX_PATH + 1] = L'\0';

            //
            // report file directory
            //

            _snwprintf(wcPath, 
                       MAX_PATH + 1,
                       L"%s\\%s", 
                       g_wszSsrRoot,  
                       L"ReportFiles"
                       );

            if (wcslen(wcPath) > MAX_PATH)
            {
                //
                // we path too long, we won't be able to function properly. quit.
                //
                
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }

            g_bstrReportFilesDir = wcPath;

            //
            // configure file directory
            //

            _snwprintf(wcPath, 
                       MAX_PATH + 1,
                       L"%s\\%s", 
                       g_wszSsrRoot,  
                       L"ConfigureFiles"
                       );

            if (wcslen(wcPath) > MAX_PATH)
            {
                //
                // we path too long, we won't be able to function properly. quit.
                //
                
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }

            g_bstrConfigureFilesDir = wcPath;

            //
            // rollback file directory
            //

            _snwprintf(wcPath, 
                       MAX_PATH + 1,
                       L"%s\\%s", 
                       g_wszSsrRoot,  
                       L"RollbackFiles"
                       );

            if (wcslen(wcPath) > MAX_PATH)
            {
                //
                // we path too long, we won't be able to function properly. quit.
                //
                
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }

            g_bstrRollbackFilesDir = wcPath;

            //
            // Transform file directory
            //

            _snwprintf(wcPath, 
                       MAX_PATH + 1,
                       L"%s\\%s", 
                       g_wszSsrRoot,  
                       L"TransformFiles"
                       );

            if (wcslen(wcPath) > MAX_PATH)
            {
                //
                // we path too long, we won't be able to function properly. quit.
                //
                
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }

            g_bstrTransformFilesDir = wcPath;

            //
            // Member file directory
            //

            _snwprintf(wcPath, 
                       MAX_PATH + 1,
                       L"%s\\%s", 
                       g_wszSsrRoot,  
                       L"Members"
                       );

            if (wcslen(wcPath) > MAX_PATH)
            {
                //
                // we path too long, we won't be able to function properly. quit.
                //
                
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }

            g_bstrMemberFilesDir = wcPath;

        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib

    HRESULT hr = _Module.RegisterServer(TRUE);

    if (SUCCEEDED(hr))
    {
        hr = SsrPDoDCOMSettings(true);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    HRESULT hr = _Module.UnregisterServer(TRUE);

    if (SUCCEEDED(hr))
    {
        hr = SsrPDoDCOMSettings(false);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrmembership.cpp ===
// SSRMemberShip.cpp : Implementation of CSsrMembership

#include "stdafx.h"
#include "global.h"

#include "SSRTE.h"
#include "SSRMemberShip.h"

#include "SSRLog.h"

#include "MemberAccess.h"


/////////////////////////////////////////////////////////////////////////////
// CSsrMembership




/*
Routine Description: 

Name:

    CSsrMembership::CSsrMembership

Functionality:
    
    constructor. This constructor also builds the member list.

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrMembership::CSsrMembership()
{

}
        


/*
Routine Description: 

Name:

    CSsrMembership::~CSsrMembership

Functionality:
    
    destructor

Virtual:
    
    yes.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrMembership::~CSsrMembership()
{
    map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> >::iterator it = m_ssrMemberAccessMap.begin();
    map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> >::iterator itEnd = m_ssrMemberAccessMap.end();

    while(it != itEnd)
    {
        CSsrMemberAccess * pMA = (*it).second;
        pMA->Release();
        it++;
    }

    m_ssrMemberAccessMap.clear();
}


HRESULT
CSsrMembership::LoadAllMember ()
/*++
Routine Description: 

Name:

    CSsrMembership::LoadAllMember

Functionality:
    
    Will try to load all information about all the members that 
    are registered with SSR.

Virtual:
    
    no.
    
Arguments:

    None.

Return Value:

    Success: various success code.

    Failure: various error codes. However, we may tolerate that and only
    load those that we can load successfully. So, don't blindly quit.

Notes:
    

--*/
{
    //
    // We should never load more than once.
    //

    if (m_ssrMemberAccessMap.size() > 0)
    {
        return S_OK;    // we let you call it if you have already call it before
    }

    //
    // Let's enumerate through the Members directory's .xml files. They will
    // all be considered as member registration files.
    //

    WCHAR wcsXmlFiles[MAX_PATH + 2];
    _snwprintf(wcsXmlFiles, MAX_PATH + 1, L"%s\\Members\\*.xml", g_wszSsrRoot);

    wcsXmlFiles[MAX_PATH + 1] = L'\0';

    long lDirLen = wcslen(wcsXmlFiles);
    
    if (lDirLen > MAX_PATH)
    {
        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }
    
    lDirLen -= 5;

    WIN32_FIND_DATA wfd;
    DWORD dwErr;
    HRESULT hr;


    HANDLE hFindFiles = FindFirstFile(
                                      wcsXmlFiles,    // file name
                                      &wfd            // information buffer
                                      );

    if (INVALID_HANDLE_VALUE == hFindFiles)
    {
        hr = S_FALSE;
        g_fblog.LogError(hr,
                         L"There is no member to load", 
                         wcsXmlFiles
                         );
        
        return hr;
    }

    HRESULT hrFirstError = S_OK;
    long lFileNameLength;

    while (INVALID_HANDLE_VALUE != hFindFiles)
    {
        //
        // make sure that we won't load anything other then a perfect .xml extension
        // file. I found that this Find will return such files: adc.xml-xxx
        //

        lFileNameLength = wcslen(wfd.cFileName);

        if (_wcsicmp(wfd.cFileName + lFileNameLength - 4, L".xml") == 0)
        {
            //
            // Get the file name and then load that member
            //

            wcsncpy(wcsXmlFiles + lDirLen, wfd.cFileName, lFileNameLength + 1);

            hr = LoadMember(wcsXmlFiles);

            if (FAILED(hr))
            {
                g_fblog.LogError(hr,
                                 L"CSsrMembership loading member failed", 
                                 wcsXmlFiles
                                 );
                if (SUCCEEDED(hr))
                {
                    hrFirstError = hr;
                }
            }
        }

        if (!FindNextFile (hFindFiles, &wfd))
        {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_FILES != dwErr)
            {
                //
                // log it
                //

                g_fblog.LogError(HRESULT_FROM_WIN32(dwErr),
                                 L"CSsrMembership", 
                                 L"FindNextFile"
                                 );
            }
            break;
        }
    }

    FindClose(hFindFiles);

    return hrFirstError;
}


/*
Routine Description: 

Name:

    CSsrMembership::LoadMember

Functionality:
    
    By given a valid member name, this function will load all the 
    detailed information from the registry.

Virtual:
    
    no.
    
Arguments:


    wszMemberFilePath   - The XML registration file path for a particular member.

Return Value:

    Success: S_OK.

    Failure: various error codes

Notes:
    

*/

HRESULT
CSsrMembership::LoadMember (
    IN LPCWSTR  wszMemberFilePath
    )
{
    HRESULT hr = S_OK;
    CComObject<CSsrMemberAccess> * pMA = NULL;
    
    hr = CComObject<CSsrMemberAccess>::CreateInstance(&pMA);
    if (SUCCEEDED(hr))
    {
        //
        // holding on to the object. When the member access
        // map cleans up, remember to let go the objects
        //

        pMA->AddRef();

        hr = pMA->Load(wszMemberFilePath);

        if (S_OK == hr)
        {
            //
            // Everything is fine and we loaded the member.
            // Add it to our map. The map owns the object from this point on.
            //

            m_ssrMemberAccessMap.insert(
                        map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> >::value_type(pMA->GetName(), 
                        pMA)
                        );
        }
        else
        {
            //
            // let go the object
            //

            pMA->Release();

            g_fblog.LogError(hr, wszMemberFilePath,  NULL);
        }
    }
    else
    {
        g_fblog.LogError(hr, wszMemberFilePath,  NULL);
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrMembership::GetAllMembers

Functionality:
    
    Retrieve all members currently registered on the system.

Virtual:
    
    yes.
    
Arguments:

    pvarArrayMembers    - Receives names of the members

Return Value:

    ?.

Notes:
   
*/

STDMETHODIMP CSsrMembership::GetAllMembers (
    OUT VARIANT * pvarArrayMembers // [out, retval] 
    )
{
    if (pvarArrayMembers == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // have a clean output parameter, no matter what
    //

    ::VariantInit(pvarArrayMembers);

    //
    // prepare the safearray
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = m_ssrMemberAccessMap.size();

    SAFEARRAY * psa = ::SafeArrayCreate(VT_VARIANT , 1, rgsabound);

    HRESULT hr = S_OK;

    if (psa == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> >::iterator it = m_ssrMemberAccessMap.begin();
        map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> >::iterator itEnd = m_ssrMemberAccessMap.end();

        //
        // we only add one name at a time
        //

        long indecies[1] = {0};

        while(it != itEnd)
        {
            CSsrMemberAccess * pMA = (*it).second;

            VARIANT varName;
            varName.vt = VT_BSTR;

            //
            // don't clean up varName! CSsrMemberAccess::GetName returns
            // a const BSTR which simplies points to the cached variable!
            //

            varName.bstrVal = pMA->GetName();
            
            hr = ::SafeArrayPutElement(psa, indecies, &varName);

            if (FAILED(hr))
            {
                break;
            }

            indecies[0]++;

            ++it;
        }

        if (SUCCEEDED(hr))
        {
            pvarArrayMembers->vt = VT_ARRAY | VT_VARIANT;
            pvarArrayMembers->parray = psa;
        }
        else
        {
            ::SafeArrayDestroy(psa);
        }

    }

    return hr;

}



/*
Routine Description: 

Name:

    CSsrMembership::GetMember

Functionality:
    
    Retrieve one member of the given name.

Virtual:
    
    yes.
    
Arguments:

    pvarMember  - Receives ISsrMemberAccess object of the named member.

Return Value:

    Success: S_OK;

    Failure: various error codes.

Notes:
    

*/

STDMETHODIMP CSsrMembership::GetMember (
	IN  BSTR      bstrMemberName,
    OUT VARIANT * pvarMember      //[out, retval] 
    )
{
    if (bstrMemberName == NULL || *bstrMemberName == L'\0' || pvarMember == NULL)
    {
        return E_INVALIDARG;
    }

    ::VariantInit(pvarMember);

    CSsrMemberAccess * pMA = GetMemberByName(bstrMemberName);
    HRESULT hr = S_OK;

    if (pMA != NULL)
    {
        pvarMember->vt = VT_DISPATCH;
        hr = pMA->QueryInterface(IID_ISsrMemberAccess, 
                                 (LPVOID*)&(pvarMember->pdispVal) );
        if (hr != S_OK)
        {
            pvarMember->vt = VT_EMPTY;
            hr = E_SSR_MEMBER_NOT_FOUND;
        }
    }
    else
    {
        hr = E_SSR_MEMBER_NOT_FOUND;
    }

    return hr;
}




/*
Routine Description: 

Name:

    CSsrMembership::GetMemberByName

Functionality:
    
    Will find the CSsrMemberAccess object based the name.

Virtual:
    
    No.
    
Arguments:

    bstrMemberName  - The member's name

Return Value:

    None NULL if the object is found. Otherwise, it returns NULL.

Notes:
    
    Since this is a helper function, we don't call AddRef to the returned object!

*/

CSsrMemberAccess* 
CSsrMembership::GetMemberByName (
    IN BSTR bstrMemberName
    )
{
    map<const BSTR, CSsrMemberAccess*, strLessThan<BSTR> >::iterator it = m_ssrMemberAccessMap.find(bstrMemberName);

    if (it != m_ssrMemberAccessMap.end())
    {
        CSsrMemberAccess * pMA = (*it).second;
        return pMA;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrtengine.h ===
// SSRTEngine.h : Declaration of the CSSRTEngine

#pragma once

#include "resource.h"       // main symbols

#include "global.h"

#include "SSRLog.h"


using namespace std;

class CSsrFilePair;

class CMemberAD;

class CSsrMembership;

class CSafeArray;

interface ISsrActionData;
class CSsrActionData;


/////////////////////////////////////////////////////////////////////////////
// CSSRTEngine
class ATL_NO_VTABLE CSsrEngine : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISsrEngine, &IID_ISsrEngine, &LIBID_SSRLib>
{
protected:
    CSsrEngine();
    virtual ~CSsrEngine();
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrEngine (const CSsrEngine& );
    void operator = (const CSsrEngine& );

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSsrEngine)
	COM_INTERFACE_ENTRY(ISsrEngine)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISsrEngine
public:

    STDMETHOD(DoActionVerb) (
        IN BSTR     bstrActionVerb,
        IN LONG     lActionType,
        IN VARIANT  varFeedbackSink,
        IN LONG     lFlag
        );

    HRESULT GetActionData (
        OUT ISsrActionData ** ppAD
        );

private:

    //
    // Do a transformation for the given action.
    //

    HRESULT DoTransforms (
        IN SsrActionVerb  lActionVerb,
        IN CSsrFilePair * pfp,
        IN OUT IXMLDOMDocument2 ** ppXmlDom,
        IN LONG           lFlag
        );

    //
    // Will invoke those custom implementation for the given action.
    //

    HRESULT DoCustom (
        IN SsrActionVerb lActionVerb,
        IN LONG          lActionType,
        IN const BSTR    bstrProgID,
        IN VARIANT       varFeedbackSink,
        IN LONG          lFlag
        );

    //
    // Do memberwise transform 
    //

    HRESULT DoMemberTransform (
        IN CSsrFilePair     * pfp,
        IN LPCWSTR            pwszXslFilesDir,
        IN LPCWSTR            pwszResultFilesDir,
        IN IXMLDOMDocument2 * pXmlDOM,
        IN IXSLTemplate     * pXslTemplate,
        IN LONG               lFlag
        );

    //
    // Given the XSL file, we will do a transformation
    // using the input data DOM object.
    //

    HRESULT Transform (
        IN BSTR              bstrXslPath,
        IN BSTR              bstrResultPath,
        IN IXMLDOMDocument2 * pXmlDOM,
        IN IXSLTemplate    * pXslTemplate,
        IN LONG              lFlag
        );

    //
    // This is the work horse for our transformation
    //

    HRESULT PrivateTransform (
        IN  BSTR                bstrXsl,
        IN  IXMLDOMDocument2 *  pxmlDom,
        IN  IXSLTemplate    *   pxslTemplate,
        IN  LONG                lFlag,
        OUT BSTR *              pbstrResult
        );

    //
    // Given the scripts (pvarSAScripts) in the given
    // directory, we will launch them sequentially.
    //

    HRESULT RunScript (
        IN BSTR bstrDirPath,
        IN BSTR bstrScriptFile
        );

    //
    // see if the given file is a script file. We won't blindly
    // launch scripts to those files that we don't recognize
    //

    bool IsScriptFile (
        IN LPCWSTR pwszFileName
        )const;

    //
    // Will check to see if this xml policy
    // contains only sections we recognize.
    //

    HRESULT VerifyDOM(
        IN  IXMLDOMDocument2 * pXmlPolicy,
        OUT BSTR            * pbstrUnknownMember,
        OUT BSTR            * pbstrExtraInfo
        );

    HRESULT CleanupOutputFiles(
        IN CSafeArray    * psaMemberNames,
        IN SsrActionVerb   lAction,
        IN bool            bLog
        );

    //
    // will backup/restore the rollback files by moving them
    // from one place to another.
    //

    HRESULT MoveRollbackFiles(
        IN CSafeArray * psaMemberNames,
        IN LPCWSTR      pwszSrcDirPath,
        IN LPCWSTR      pwszDestDirPath,
        IN bool         bLog
        );

    CComObject<CSsrActionData> * m_pActionData;
    CComObject<CSsrMembership> * m_pMembership;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrtengine.cpp ===
// SSRTEngine.cpp : Implementation of SSR Engine

#include "stdafx.h"
#include "SSRTE.h"
#include "SSRTEngine.h"
#include "SSRMembership.h"
#include "MemberAccess.h"
#include "SSRLog.h"
#include "ActionData.h"

#include "global.h"

#include "util.h"


/////////////////////////////////////////////////////////////////////////////
// CSsrEngine


/*
Routine Description: 

Name:

    CSsrEngine::CSsrEngine

Functionality:
    
    constructor

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/


CSsrEngine::CSsrEngine()
    : m_pActionData(NULL), 
      m_pMembership(NULL)
{
    HRESULT hr = CComObject<CSsrMembership>::CreateInstance(&m_pMembership);

    if (FAILED(hr))
    {
        throw hr;
    }

    hr = CComObject<CSsrActionData>::CreateInstance(&m_pActionData);

    if (FAILED(hr))
    {
        throw hr;
    }

    //
    // hold on to these objects
    //

    m_pMembership->AddRef();
    m_pActionData->AddRef();

    m_pActionData->SetMembership(m_pMembership);
}



/*
Routine Description: 

Name:

    CSsrEngine::~CSsrEngine

Functionality:
    
    destructor

Virtual:
    
    yes.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/


CSsrEngine::~CSsrEngine()
{
    m_pActionData->Release(); 
    m_pMembership->Release();
}



/*
Routine Description: 

Name:

    CSsrEngine::GetActionData

Functionality:
    
    Retrieve the action data interface

Virtual:
    
    Yes.
    
Arguments:

    ppAD    - The out parameter that receives the ISsrActionData interface from 
              the m_pActionData object

Return Value:

    Success: 
    
        S_OK.

    Failure: 

        various error codes.

Notes:
    

*/

HRESULT
CSsrEngine::GetActionData (
    OUT ISsrActionData ** ppAD
    )
{
    HRESULT hr = E_SSR_ACTION_DATA_NOT_AVAILABLE;

    if (ppAD == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (m_pActionData != NULL)
    {
        *ppAD = NULL;
        hr = m_pActionData->QueryInterface(IID_ISsrActionData, (LPVOID*)ppAD);
        if (S_OK != hr)
        {
            hr = E_SSR_ACTION_DATA_NOT_AVAILABLE;
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrEngine::DoActionVerb

Functionality:
    
    The engine will perform the action.

Virtual:
    
    Yes.
    
Arguments:

    bstrActionVerb  - "configure" or "rollback".

    lActionType     - The action's type.

    varFeedbackSink - The COM interface ISsrFeedbackSink given by the caller.
                      We will use this interface to call back when we want
                      to give feedback information to the caller.

    lFlag           - Reserved for future use. 

Return Value:

    Success: 
    
        S_OK.

    Failure: 

        various error codes.

Notes:
    

*/

STDMETHODIMP
CSsrEngine::DoActionVerb (
    IN BSTR     bstrActionVerb,
    IN LONG     lActionType,
    IN VARIANT  varFeedbackSink,
    IN LONG     lFlag
    )
{
    if (bstrActionVerb == NULL)
    {
        g_fblog.LogString(IDS_INVALID_PARAMETER, L"bstrActionVerb");
        return E_INVALIDARG;
    }

    SsrActionVerb lActionVerb = SsrPGetActionVerbFromString(bstrActionVerb);

    if (lActionVerb == ActionInvalid)
    {
        g_fblog.LogString(IDS_INVALID_PARAMETER, bstrActionVerb);
        return E_SSR_INVALID_ACTION_VERB;
    }

    //
    // we will only accept SSR_ACTION_APPLY or SSR_ACTION_PREPARE
    //

    if ( (lActionType != SSR_ACTION_PREPARE) &&
         (lActionType != SSR_ACTION_APPLY) )
    {
        g_fblog.LogString(IDS_INVALID_PARAMETER, L"lActionType");
        return E_SSR_INVALID_ACTION_TYPE;
    }

    HRESULT hr;

    VARIANT  varFeedbackSinkNull;

    varFeedbackSinkNull.vt = VT_NULL;
    
    if ( lActionVerb == ActionConfigure && lActionType == SSR_ACTION_APPLY) {
        hr = DoActionVerb (
                       g_bstrRollback,
                       SSR_ACTION_PREPARE,
                       varFeedbackSinkNull,
                       lFlag);

        if (FAILED(hr))
        {
            g_fblog.LogError(hr, L"CSsrEngine", L"Rollback failed");
            return hr;
        }

    }

    //
    // need to loop through all members
    //

    hr = m_pMembership->LoadAllMember();

    if (hr == E_SSR_MEMBER_XSD_INVALID)
    {
        //
        // logging has been done by LoadAllMembers
        //

        return hr;
    }

    CComVariant var;
    hr = m_pMembership->GetAllMembers(&var);

    if (FAILED(hr))
    {
        g_fblog.LogError(hr, L"CSsrEngine", L"m_pMembership->GetAllMembers");
        return hr;
    }

    //
    // now we have members to work on, so get the feedback sink ready and
    // kick out the actions!
    //

    if (varFeedbackSink.vt == VT_UNKNOWN || varFeedbackSink.vt == VT_DISPATCH)
    {
        hr = g_fblog.SetFeedbackSink(varFeedbackSink);
        if (FAILED(hr))
        {
            g_fblog.LogError(hr, L"CSsrEngine", L"g_fblog.SetFeedbackSink");
            return hr;
        }
    }
    else if (varFeedbackSink.vt != VT_NULL && varFeedbackSink.vt != VT_EMPTY)
    {
        //
        // if the feedback has something other than NULL or empty, but
        // it is not an IUnknown or IDispatch, then, we log the error,
        // but we will continue
        //

        g_fblog.LogString(IDS_INVALID_PARAMETER, L"varFeedbackSink");
    }

    CSafeArray sa(&var);

    //
    // We have to discover information about total number of items to be processed.
    // Currently, this mimics the actual action, which is a little bit costly. We
    // should consider some lookup mechanism without going so much to the members.
    //

    //vector<ULONG> vecTransformIndexes;
    //vector<ULONG> vecScriptIndexes;
    //vector<ULONG> vecCustomIndexes;

    //
    // The following actions will be counted:
    // (1) Loading security policy XML files
    // (2) Transform using one xsl file and the creation of the output 
    //     file count as one.
    // (3) executing a script
    // (4) any custom actions
    //
    
    DWORD dwTotalSteps = 0;

	CSsrMemberAccess * pMA;
    CComVariant varMemberName;

    //
    // ask each member to give us the cost for the action
    //

    for (ULONG i = 0; i < sa.GetSize(); i++)
    {
        pMA = NULL;
        varMemberName.Clear();

        //
        // see if this member supports the desired action. If it does
        // then get the cost.
        //

        if (SUCCEEDED(sa.GetElement(i, VT_BSTR, &varMemberName)))
        {
            pMA = m_pMembership->GetMemberByName(varMemberName.bstrVal);

            if (pMA != NULL)
            {
                dwTotalSteps += pMA->GetActionCost(lActionVerb, lActionType);
            }
        }
    }

    //
    // if we need to do transformation, then let us cleanup the old ones.
    // We won't bother to restore them if somehow we fail to do the transformation
    // unless we are doing rollback transformation. 
    // We must not continue if this fails.
    //

    WCHAR wszTempDir[MAX_PATH + 2];
    wszTempDir[MAX_PATH + 1] = L'\0';

    if ( (lActionType == SSR_ACTION_PREPARE ) )
    {
        if ( lActionVerb == ActionRollback )
        {
            //
            // if we need to do "rollback" transformation, then we need to
            // backup our previous rollback output files
            //

            //
            // first, we need a temporary directory
            //

            hr = SsrPCreateUniqueTempDirectory(wszTempDir, MAX_PATH + 1);

            if (SUCCEEDED(hr))
            {
                hr = MoveRollbackFiles(&sa, 
                                       SsrPGetDirectory(lActionVerb, TRUE), 
                                       wszTempDir, 
                                       true         // we want logging
                                       );
            }
        }
        else
        {
            //
            // otherwise, we will just delete them and never bother
            // to restore them if anything fails
            //

            hr = CleanupOutputFiles(&sa,
                                    lActionVerb, 
                                    true    // we want logging
                                    );

        }

        if (FAILED(hr))
        {
            g_fblog.LogError(hr, L"CSsrEngine", L"Cleanup previous result files failed.");
            return hr;
        }
    }

    //
    // Feedback the total steps info
    //

    g_fblog.SetTotalSteps(dwTotalSteps);

    //
    // now let's carry out the action. First, feedback/log the action started
    // information.
    //

    g_fblog.LogFeedback(SSR_FB_START, 
                        (DWORD)S_OK,
                        NULL,
                        g_dwResNothing
                        );

    //
    // we may decide to presson in case of errors, but we should always
    // return the error we found
    //

    HRESULT hrFirstError = S_OK;

    CComPtr<IXMLDOMDocument2> srpDomSecurityPolicy;

    //
    // ask each member to give us the action data so that we can
    // carry out the action.
    //

    for (i = 0; i < sa.GetSize(); i++)
    {
        pMA = NULL;
        varMemberName.Clear();

        //
        // see if this member supports the desired action. If it does
        // then get the cost.
        //

        if (SUCCEEDED(sa.GetElement(i, VT_BSTR, &varMemberName)))
        {
            pMA = m_pMembership->GetMemberByName(varMemberName.bstrVal);

            if (pMA == NULL)
            {
                //
                // $undone:shawnwu, should we press on? This shouldn't happen.
                //

                _ASSERT(FALSE);
                g_fblog.LogString(IDS_MISSING_MEMBER, varMemberName.bstrVal);
                continue;

            }

            CMemberAD* pmemberAD = pMA->GetActionDataObject(lActionVerb,
                                                            lActionType
                                                            );

            if (pmemberAD == NULL)
            {
                //
                // $undone:shawnwu, should we press on? This shouldn't happen.
                //

                _ASSERT(FALSE);
                g_fblog.LogString(IDS_MEMBER_NOT_SUPPORT_ACTION, varMemberName.bstrVal);
                continue;

            }

            int iCount = pmemberAD->GetProcedureCount();

            //
            // mark the entry point for carrying out the action
            //

            g_fblog.LogFeedback(SSR_FB_START_MEMBER_ACTION,
                                varMemberName.bstrVal, 
                                bstrActionVerb, 
                                g_dwResNothing
                                );

            for (int iProc = 0; iProc < iCount; iProc++)
            {
                const CSsrProcedure * pSsrProc = pmemberAD->GetProcedure(iProc);

                if (pSsrProc->IsDefaultProcedure())
                {
                    int iFilePairCount = pSsrProc->GetFilePairCount();
                    
                    for (int iPair = 0; iPair < iFilePairCount; iPair++)
                    {
                        //
                        // get the file pair information so that we can
                        // determine which action to carry out
                        //

                        CSsrFilePair * pfp = pSsrProc->GetFilePair(iPair);
                        if (pfp->GetFirst() != NULL)
                        {
                            //
                            // if the first file is there, then, we will do
                            // a transformation.
                            //

                            hr = DoTransforms(lActionVerb, 
                                              pfp,
                                              &srpDomSecurityPolicy,
                                              lFlag
                                              );
                        }
                        else if (pfp->GetSecond()  != NULL &&
                                 pfp->IsExecutable() )
                        {
                            hr = RunScript(SsrPGetDirectory(lActionVerb, TRUE),
                                           pfp->GetSecond()
                                           );

                        }

                        if (hrFirstError == S_OK && FAILED(hr))
                        {
                            hrFirstError = hr;
                        }

                        g_fblog.Steps(2);

                        if (!SsrPPressOn(lActionVerb, lActionType, hr))
                        {
                            break;
                        }
                    }
                }
                else
                {
                    if (pSsrProc->GetProgID() == NULL && 
                        pMA->GetProgID() == NULL)
                    {
                        //
                        // we can't do anything because the progID is missing
                        //

                        g_fblog.LogString(IDS_MISSING_PROGID, varMemberName.bstrVal);
                    }
                    else
                    {
                        hr = DoCustom(lActionVerb, 
                                      lActionType, 
                                      (pSsrProc->GetProgID() != NULL) ? pSsrProc->GetProgID() : pMA->GetProgID(), 
                                      varFeedbackSink, 
                                      lFlag
                                      );

                        //
                        // Feedback steps are counted by the custom member itself
                        // via the feedback sink we give.
                        //

                    }

                    if (hrFirstError == S_OK && FAILED(hr))
                    {
                        hrFirstError = hr;
                    }

                    if (!SsrPPressOn(lActionVerb, lActionType, hr))
                    {
                        break;
                    }
                }

                
                if (hrFirstError == S_OK && FAILED(hr))
                {
                    hrFirstError = hr;
                }

                if (!SsrPPressOn(lActionVerb, lActionType, hr))
                {
                    break;
                }
            }

            g_fblog.LogFeedback(SSR_FB_END_MEMBER_ACTION, 
                                varMemberName.bstrVal, 
                                bstrActionVerb, 
                                g_dwResNothing
                                );
        }
    }

    if (SUCCEEDED(hrFirstError) && 
        (lActionType == SSR_ACTION_PREPARE) && 
        (lActionVerb == ActionRollback) )
    {
        //
        // transform succeeded, then we need to get rid of the files
        // backed up for rollback.
        //

        ::SsrPDeleteEntireDirectory(wszTempDir);
    }
    else if ( (lActionType == SSR_ACTION_PREPARE) && (lActionVerb == ActionRollback))
    {
        //
        // transform failed, we need to restore the backup files
        // for the rollback. First, we must remove all output files
        //

        HRESULT hrRestore = CleanupOutputFiles(&sa,
                                                lActionVerb, 
                                                false    // we don't want logging
                                                );

        //
        // we will purposely leave the rollback files backed up
        // in previous steps in case we failed to restore all of them
        // so that we can at least log it and let the user do
        // the restoration
        //

        if (SUCCEEDED(hrRestore))
        {
            hrRestore = MoveRollbackFiles(&sa, 
                                          wszTempDir, 
                                          g_wszSsrRoot,
                                          false         // no logging
                                          );
            if (SUCCEEDED(hrRestore))
            {
                ::SsrPDeleteEntireDirectory(wszTempDir);
            }
            else
            {
                g_fblog.LogError(hr,
                                 L"CSsrEngine", 
                                 L"Restore old rollback files failed. These files are located at the directory whose name is the following guid:"
                                 );

                g_fblog.LogString(wszTempDir);
            }
        }
    }

    //
    // now action has complete! Give the HRESULT as feedback.
    // Also, we always give back S_OK as the return result if 
    // everything goes on fine.
    //

    if (SUCCEEDED(hrFirstError))
    {
        hrFirstError = S_OK;
    }

    g_fblog.LogFeedback(SSR_FB_END | FBLog_Log,
                        hr,
                        NULL,
                        g_dwResNothing
                        );

    g_fblog.TerminateFeedback();

    return hrFirstError;
}



/*
Routine Description: 

Name:

    CSsrEngine::DoCustom

Functionality:
    
    We will delegate to the objects of custom implementation for this action.

Virtual:
    
    no.
    
Arguments:

    lActionVerb     - action verb
      
    bstrProgID      - The member's ProgID

    varFeedbackSink - the sink interface if any.

    lFlag           - reserved for future use.

Return Value:

    Success: 
    
        various success codes returned from DOM or ourselves. 
        Use SUCCEEDED(hr) to test.

    Failure: 

        various error codes returned from DOM or ourselves. 
        Use FAILED(hr) to test.

Notes:
    

*/

HRESULT
CSsrEngine::DoCustom (
    IN SsrActionVerb lActionVerb,
    IN LONG          lActionType,
    IN const BSTR    bstrProgID,
    IN VARIANT       varFeedbackSink,
    IN LONG          lFlag
    )
{
    g_fblog.LogString(IDS_START_CUSTOM, NULL);

    GUID clsID;

	CComPtr<ISsrMember> srpMember;
    CComVariant varAD;

    HRESULT hr = ::CLSIDFromProgID(bstrProgID, &clsID);

    if (S_OK == hr)
    {
        hr = ::CoCreateInstance(clsID, 
                                NULL, 
                                CLSCTX_INPROC_SERVER, 
                                IID_ISsrMember, 
                                (LPVOID*)&srpMember
                                );

    }

    if (SUCCEEDED(hr))
    {
        varAD.vt = VT_UNKNOWN;
        varAD.punkVal = NULL;

        //
        // this m_pActionData must have ISsrActionData unless exception
        //

        hr = m_pActionData->QueryInterface(IID_ISsrActionData, 
                                          (LPVOID*)&(varAD.punkVal)
                                          );

        if (FAILED(hr))
        {
            g_fblog.LogError(hr, 
                             bstrProgID, 
                             L"m_pActionData->QueryInterface failed"
                             );
        }
    }
    else
    {
        g_fblog.LogString(IDS_MISSING_CUSTOM_MEMBER, bstrProgID);
    }


    //
    // if we can't provide an log object, then the custom 
    // object should create one by itself
    //

    if (SUCCEEDED(hr))
    {
        CComVariant varLog;
        g_fblog.GetLogObject(&varLog);

        //
        // custom object must let us pass in action context
        //

        hr = srpMember->SetActionContext(varAD, varLog, varFeedbackSink);
        if (FAILED(hr))
        {
            g_fblog.LogError(hr, 
                             bstrProgID, 
                             L"SetActionContext failed."
                             );
        }
    }


    //
    // logging and feedback will be done by the custom objects
    //

    if (SUCCEEDED(hr))
    {
        hr = srpMember->DoActionVerb(SsrPGetActionVerbString(lActionVerb), lActionType, lFlag);
        if (FAILED(hr))
        {
            g_fblog.LogError(hr, 
                             L"DoActionVerb", 
                             SsrPGetActionVerbString(lActionVerb)
                             );
        }
    }

    g_fblog.LogString(IDS_END_CUSTOM, NULL);

    return hr;
}





/*
Routine Description: 

Name:

    CSsrEngine::DoTransforms

Functionality:
    
    We perform our well defined XSLT transformation action.

Virtual:
    
    no.
    
Arguments:

    lActionVerb     - action verb
      
    pfp             - CSsrFilePair object that contains the xsl and output file
                      name information. Output file information may be empty,
                      in which case in means that the the transformation does
                      require to create an output file.

    ppXmlDom        - The security policy DOM object. If this is a NULL object,
                      then this function will create and load it for later use.

    lFlag           - The flag that determines the transformation characteristics. 
                      The one we heavily used is SSR_LOADDOM_VALIDATE_ON_PARSE.
                      This can be bitwise OR'ed. If this is set to 0, then we
                      use the registered flags for each individual member. 
                      In other words, this flag overwrites the registered flag
                      if it is not 0.

Return Value:

    Success: 
    
        various success codes returned from DOM or ourselves. 
        Use SUCCEEDED(hr) to test.

    Failure: 

        various error codes returned from DOM or ourselves. 
        Use FAILED(hr) to test.

Notes:
    

*/

HRESULT
CSsrEngine::DoTransforms (
    IN SsrActionVerb  lActionVerb,
    IN CSsrFilePair * pfp,
    IN OUT IXMLDOMDocument2 ** ppXmlDom,
    IN LONG           lFlag
    )
{
    g_fblog.LogString(IDS_START_XSL_TRANSFORM, NULL);

	//
    // We will prepare an XML dom object if it doesn't pass in one.
    //

    HRESULT hr = S_OK;

    if (*ppXmlDom == NULL)
    {
        //
        // First of all, we need the SecurityPolicy.xml file
        //

        CComVariant varXmlPolicy;
        hr = m_pActionData->GetProperty(CComBSTR(g_pwszCurrSecurityPolicy), 
                                                &varXmlPolicy
                                                );

        //
        // Loading the security policy XML file is considered SSR Engine actions
        //

	    if (S_OK != hr)
        {
            g_fblog.LogFeedback(SSR_FB_ERROR_CRITICAL | FBLog_Log, 
                                (LPCWSTR)NULL,
                                NULL,
                                IDS_MISSING_SECPOLICY
                                );
            return hr;
        }
        else if (varXmlPolicy.vt != VT_BSTR)
        {
            g_fblog.LogFeedback(SSR_FB_ERROR_CRITICAL | FBLog_Log, 
                                (LPCWSTR)NULL, 
                                g_pwszCurrSecurityPolicy,
                                IDS_SECPOLICY_INVALID_TYPE
                                );
            return hr;
        }

        CComBSTR bstrSecPolicy(varXmlPolicy.bstrVal);
//        bstrSecPolicy += L"\\Policies\\";
//        bstrSecPolicy = varXmlPolicy.bstrVal;

        if (bstrSecPolicy.m_str == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = ::CoCreateInstance(CLSID_DOMDocument40, 
                                NULL, 
                                CLSCTX_SERVER, 
                                IID_IXMLDOMDocument2, 
                                (LPVOID*)(ppXmlDom) 
                                );

        if (SUCCEEDED(hr))
        {
            hr = SsrPLoadDOM(bstrSecPolicy, lFlag, (*ppXmlDom));
            if (SUCCEEDED(hr))
            {
                //
                // we loaded the security policy xml file
                //

                g_fblog.LogFeedback(FBLog_Log, 
                                    hr,
                                    bstrSecPolicy,
                                    IDS_LOAD_SECPOLICY
                                    );
            }
            else
            {
                g_fblog.LogFeedback(SSR_FB_ERROR_CRITICAL | FBLog_Log,
                                    hr,
                                    bstrSecPolicy, 
                                    IDS_LOAD_SECPOLICY
                                    );
                return hr;
            }
        }
        else
        {
            g_fblog.LogError(
                            hr,
                            L"Can't create CLSID_DOMDocument40 object", 
                            NULL
                            );
            return hr;
        }
    }

    //
    // let's check if all section of the security policy xml file
    // contains any section that we have no member that understands
    //

    CComBSTR bstrUnknownMember, bstrExtraInfo;

    HRESULT hrCheck;

    hrCheck = VerifyDOM((*ppXmlDom), &bstrUnknownMember, &bstrExtraInfo);

    if (bstrUnknownMember.Length() > 0)
    {
        g_fblog.LogFeedback(SSR_FB_ERROR_UNKNOWN_MEMBER | FBLog_Log,
                            bstrUnknownMember, 
                            bstrExtraInfo,
                            g_dwResNothing
                            );
    }

    //
    // let's create the XSL template object
    //

    CComPtr<IXSLTemplate> srpIXSLTemplate;
    hr = ::CoCreateInstance(CLSID_XSLTemplate, 
                            NULL, 
                            CLSCTX_SERVER, 
                            IID_IXSLTemplate, 
                            (LPVOID*)(&srpIXSLTemplate)
                            );

    if (FAILED(hr))
    {
        g_fblog.LogFeedback(SSR_FB_ERROR_CRITICAL | FBLog_Log,
                            hr,
                            NULL, 
                            IDS_FAIL_CREATE_XSLT
                            );
        return hr;
    }

    //
    // now ready to do member wise transform
    //

    BSTR bstrXslDir = SsrPGetDirectory(lActionVerb, FALSE);
    BSTR bstrResultDir = SsrPGetDirectory(lActionVerb, TRUE);
    hr = DoMemberTransform(
                            pfp,
                            bstrXslDir,    
                            bstrResultDir,
                            (*ppXmlDom),
                            srpIXSLTemplate,
                            lFlag
                            );

    if (FAILED(hr))
    {
        g_fblog.LogError(hr, 
                         L"DoTransforms", 
                         pfp->GetFirst()
                         );
    }

    g_fblog.LogString(IDS_END_XSL_TRANSFORM, NULL);

    return hr;
}



/*
Routine Description: 

Name:

    CSsrEngine::DoMemberTransform

Functionality:
    
    We will do the private transform and then create the output file.

Virtual:
    
    no.
    
Arguments:

    pfp             - CSsrFilePair object that contains names of 
                      both xsl and output files. If the latter is empty,
                      it means it doesn't need to create an output file.

    pwszXslFilesDir - the XSL file directory

    pwszResultFilesDir  - the output file directory

    pXmlDOM         - The XML DOM object interface

    pXslTemplate    - The XSL template object interface

    lFlag           - The flag that determines the transformation characteristics. 
                      The one we heavily used is SSR_LOADDOM_VALIDATE_ON_PARSE.

Return Value:

    Success: 
    
        various success codes returned from DOM or ourselves. 
        Use SUCCEEDED(hr) to test.

    Failure: 

        various error codes returned from DOM or ourselves. 
        Use FAILED(hr) to test.

Notes:
    

*/

HRESULT 
CSsrEngine::DoMemberTransform (
    IN CSsrFilePair     * pfp,
    IN LPCWSTR            pwszXslFilesDir,
    IN LPCWSTR            pwszResultFilesDir,
    IN IXMLDOMDocument2 * pXmlDOM,
    IN IXSLTemplate     * pXslTemplate,
    IN LONG               lFlag
    )
{
    HRESULT hr = S_OK;
    CComBSTR bstrXslFilePath(pwszXslFilesDir);
    bstrXslFilePath += L"\\";
    bstrXslFilePath += pfp->GetFirst();

    CComBSTR bstrResultFilePath;

    if (pfp->GetSecond() != NULL)
    {
        bstrResultFilePath = pwszResultFilesDir;
        bstrResultFilePath += L"\\";
        bstrResultFilePath += pfp->GetSecond();
    }

    hr = Transform (bstrXslFilePath,
                    bstrResultFilePath,
                    pXmlDOM, 
                    pXslTemplate,
                    lFlag
                    );

    DWORD dwID = SUCCEEDED(hr) ? IDS_TRANSFORM_SUCCEEDED : IDS_TRANSFORM_FAILED;

    g_fblog.LogFeedback(SSR_FB_TRANSFORM_RESULT | FBLog_Log,
                        hr,
                        pfp->GetFirst(),
                        dwID
                        );

    return hr;
}


/*
Routine Description: 

Name:

    CSsrEngine::Transform

Functionality:
    
    We will do the private transform and then create the output file.

Virtual:
    
    no.
    
Arguments:

    bstrXslPath     - The xsl file path.

    bstrResultPath  - the output file path

    pXmlDOM         - The XML DOM object interface

    pXslTemplate    - The XSL template object interface

    lFlag           - The flag that determines the transformation characteristics. 
                      The one we heavily used is SSR_LOADDOM_VALIDATE_ON_PARSE.

Return Value:

    Success: 
    
        various success codes returned from DOM or ourselves. 
        Use SUCCEEDED(hr) to test.

    Failure: 

        various error codes returned from DOM or ourselves. 
        Use FAILED(hr) to test.

Notes:
    

*/

HRESULT 
CSsrEngine::Transform (
    IN BSTR               bstrXslPath,
    IN BSTR               bstrResultPath,
    IN IXMLDOMDocument2 * pXmlDOM,
    IN IXSLTemplate     * pXslTemplate,
    IN LONG               lFlag
    )
{
    CComBSTR bstrResult;

    HRESULT hr = S_OK;
    
    if (bstrResultPath != NULL)
    {
        //
        // we need to create a result file
        // using our transformation result.
        //

        hr = PrivateTransform (
                            bstrXslPath, 
                            pXmlDOM, 
                            pXslTemplate, 
                            lFlag, 
                            &bstrResult
                            );
    }
    else
    {
        hr = PrivateTransform (
                            bstrXslPath, 
                            pXmlDOM, 
                            pXslTemplate, 
                            lFlag, 
                            NULL
                            );
    }

    //
    // we allow transform to have no text results. Or there is no
    // output file given. In either case, the effect is simply to call
    // the transformation, which may still do meaningful things.
    //

    if (SUCCEEDED(hr)            && 
        bstrResult.m_str != NULL && 
        bstrResultPath   != NULL && 
        *bstrResultPath  != L'\0' )
    {
        //
        // if there is an output file that needs to be created.
        //

        HANDLE hFile = ::CreateFile(bstrResultPath, 
                                    GENERIC_WRITE, 
                                    0, 
                                    NULL, 
                                    CREATE_ALWAYS, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL
                                    );
    
        if (hFile != INVALID_HANDLE_VALUE)
        {
            //
            // write the results into the file
            //

            long lLen = wcslen(bstrResult);
            DWORD dwWritten = 0;

            BOOL bStatus = ::WriteFile(hFile, 
                                       bstrResult.m_str, 
                                       lLen * sizeof(WCHAR), 
                                       &dwWritten,
                                       NULL
                                       );
            ::CloseHandle(hFile);
            if (!bStatus)
            {
                g_fblog.LogFeedback(SSR_FB_ERROR_FILE_WRITE | FBLog_Log,
                                    GetLastError(),
                                    bstrResultPath,
                                    IDS_FILEWRITE_FAILED
                                    );

                hr = E_FAIL;
            }
        }
        else
        {
            g_fblog.LogFeedback(SSR_FB_ERROR_FILE_CREATE | FBLog_Log,
                                GetLastError(),
                                bstrResultPath,
                                IDS_FILECREATE_FAILED
                                );
            hr = E_FAIL;
        }
    }

	return hr;
}




/*
Routine Description: 

Name:

    CSsrEngine::PrivateTransform

Functionality:
    
    Do the real XSLT transformation

Virtual:
    
    no.
    
Arguments:

    bstrXsl     - the XSL file path

    pxmlDom     - The XML DOM object interface

    pxslTemplate- The XSL template object interface

    uFlag       - The flag that determines the transformation 
                  characteristics. The one we heavily used is
                  SSR_LOADDOM_VALIDATE_ON_PARSE.

    pbstrResult - The result string.

Return Value:

    Success: 
    
        various success codes returned from DOM or ourselves. 
        Use SUCCEEDED(hr) to test.

    Failure: 

        various error codes returned from DOM or ourselves. 
        Use FAILED(hr) to test.

Notes:
    

*/

HRESULT 
CSsrEngine::PrivateTransform (
    IN  BSTR                bstrXsl,
    IN  IXMLDOMDocument2 *  pxmlDom,
    IN  IXSLTemplate     *  pxslTemplate,
    IN  LONG                lFlag,
    OUT BSTR *              pbstrResult OPTIONAL
    )
{
    if (bstrXsl      == NULL  || 
        *bstrXsl     == L'\0' || 
        pxmlDom      == NULL  || 
        pxslTemplate == NULL)
    {
        return E_INVALIDARG;
    }

    CComPtr<IXMLDOMDocument2> srpXsl;

    HRESULT hr = ::CoCreateInstance(CLSID_FreeThreadedDOMDocument, 
                                    NULL, 
                                    CLSCTX_SERVER, IID_IXMLDOMDocument2, 
                                    (LPVOID*)(&srpXsl)
                                    );

    if (SUCCEEDED(hr))
    {
        hr = SsrPLoadDOM(bstrXsl, lFlag, srpXsl);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    short sResult = FALSE;

    CComPtr<IXSLProcessor> srpIXSLProcessor;
    
    if (pbstrResult != NULL)
    {
        *pbstrResult = NULL;
    }

    hr = pxslTemplate->putref_stylesheet(srpXsl);
    if (FAILED(hr))
    {
        g_fblog.LogString(IDS_XSL_TRANSFORM_FAILED, L"putref_stylesheet");
    }

    if (SUCCEEDED(hr))
    {
        hr = pxslTemplate->createProcessor(&srpIXSLProcessor);
        if (FAILED(hr))
        {
            g_fblog.LogString(IDS_CREATE_IXSLPROC_FAILED, NULL);
        }
    }

    if (SUCCEEDED(hr))
    {
        CComVariant varIDoc2(pxmlDom);
        hr = srpIXSLProcessor->put_input(varIDoc2);

        if (SUCCEEDED(hr))
        {
            hr = srpIXSLProcessor->transform(&sResult);
            if (SUCCEEDED(hr) && (sResult == VARIANT_TRUE))
            {
                //
                // if we want results back
                //

                if (pbstrResult != NULL)
                {
                    VARIANT varValue;
                    ::VariantInit(&varValue);
                    hr = srpIXSLProcessor->get_output(&varValue);

                    //
                    // if the output is successffuly retrieved, 
                    // then it is owned by the out parameter
                    //

                    if (SUCCEEDED(hr) && varValue.vt == VT_BSTR)
                    {
                        *pbstrResult = varValue.bstrVal;

                        //
                        // the bstr value is owned by the output parameter now
                        //

                        varValue.vt = VT_EMPTY;
                        varValue.bstrVal = NULL;
                    }
                    else
                    {
                        ::VariantClear(&varValue);
                    }
                }
            }
            else
            {
                g_fblog.LogString(IDS_XSL_TRANSFORM_FAILED, 
                                  L"IXSLProcessor->transform"
                                  );
            }
        }
        else
        {
            g_fblog.LogString(IDS_XSL_TRANSFORM_FAILED, 
                              L"IXSLProcessor->put_input"
                              );
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrEngine::RunScript

Functionality:
    
    We will launch all given scripts

Virtual:
    
    No.
    
Arguments:

    bstrDirPath     - The path of the directory where the scripts resides

    bstrScriptFile  - The script file's name

Return Value:

    Success: 
    
        S_OK of some scripts are run.
        S_FALSE if no scripts can be found to run.

    Failure: 

        various error codes.

Notes:
    
    1. We should try to hide the cmd window.

*/

HRESULT 
CSsrEngine::RunScript (
    IN BSTR bstrDirPath,
    IN BSTR bstrScriptFile
    ) 
{

    if (bstrDirPath == NULL || bstrScriptFile == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // create the script file's full path
    //

    int iLen = wcslen(bstrDirPath) + 1 + wcslen(bstrScriptFile) + 1;
    LPWSTR pwszFilePath = new WCHAR[iLen];

    if (pwszFilePath == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // don't return blindly w/o freeing the pwszFilePath from this point on
    //

    HRESULT hr = S_OK;

    _snwprintf(pwszFilePath, iLen, L"%s\\%s", bstrDirPath, bstrScriptFile);

    WIN32_FILE_ATTRIBUTE_DATA wfad;

    if ( !GetFileAttributesEx(pwszFilePath, GetFileExInfoStandard, &wfad) )
    {
        g_fblog.LogFeedback(SSR_FB_ERROR_FILE_MISS | FBLog_Log, 
                            hr,
                            pwszFilePath,
                            IDS_CANNOT_ACCESS_FILE
                            );

        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (SUCCEEDED(hr) && !IsScriptFile(pwszFilePath))
    {
        g_fblog.LogString(IDS_NOT_SUPPORTED_SCRIPT_FILE_TYPE,
                          pwszFilePath
                          );

        hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        //
        // now kick out the script
        //

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        ZeroMemory( &si, sizeof(si) );
        si.cb = sizeof(si);
        ZeroMemory( &pi, sizeof(pi) );

        WCHAR wszExitCode[g_dwHexDwordLen];

        g_fblog.LogString(IDS_RUNNING_SCRIPTS, pwszFilePath);

        CComBSTR bstrCmdLine(L"CScript.exe //B ");
        bstrCmdLine += pwszFilePath;

        if (bstrCmdLine.m_str == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // this will launch the script w/o a window
            //

            BOOL bRun = ::CreateProcess(
                                        NULL,
                                        bstrCmdLine,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        CREATE_NO_WINDOW,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi
                                        );

            if (!bRun)
            {
                g_fblog.LogFeedback(SSR_FB_ERROR_CRITICAL | FBLog_Log,
                                    GetLastError(),
                                    bstrCmdLine,
                                    IDS_ERROR_CREATE_PROCESS
                                    );

                //
                // $undone:shawnwu, should we quit?
                //
            }
            else
            {
                //
                // we don't proceed until the script ends
                // and then we log the exit code
                //

                ::WaitForSingleObject( pi.hProcess, INFINITE );

                DWORD dwExitCode;
                bRun = ::GetExitCodeProcess(pi.hProcess, &dwExitCode);
        
                _snwprintf(wszExitCode, g_dwHexDwordLen, L"0x%X", dwExitCode);

                g_fblog.LogFeedback(SSR_FB_EXIT_CODE | FBLog_Log,
                                    (LPCWSTR)NULL,
                                    wszExitCode,
                                    IDS_EXIT_CODE
                                    );
            }

        }
    }

    delete [] pwszFilePath;

    return hr;
}



/*
Routine Description: 

Name:

    CSsrEngine::IsScriptFile

Functionality:
    
    test if a file is a script file

Virtual:
    
    No.
    
Arguments:

    pwszFileName    - The path of the file

Return Value:

    true if and only if it is one of the script file types (.vbs, .js, .wsf)

Notes:

*/

bool 
CSsrEngine::IsScriptFile (
    IN LPCWSTR pwszFileName
    )const
{
    //
    // check if the the file is indeed a script
    //

    if (pwszFileName == NULL)
    {
        return false;
    }

    LPCWSTR pwszExt = pwszFileName + wcslen(pwszFileName) - 1;

    while (pwszExt != pwszFileName)
    {
        if (*pwszExt == L'.')
        {
            break;
        }
        else
        {
            pwszExt--;
        }
    }

    return (_wcsicmp(L".js", pwszExt)  == 0 || 
            _wcsicmp(L".vbs", pwszExt) == 0 || 
            _wcsicmp(L".wsf", pwszExt) == 0 );

}



/*
Routine Description: 

Name:

    CSsrEngine::VerifyDOM

Functionality:
    
    Will check if the every section of the security policy has a member
    to process it.

Virtual:
    
    No.
    
Arguments:

    pXmlPolicy          - The XML policy DOM.

    pbstrUnknownMember  - receives the unknown member's name if found.

    pbstrExtraInfo      - receives extra info, such as whether the missing
                          member is from local system or from the security policy

Return Value:

    Success:   S_OK

    Failure:   various error codes

Notes:

    $undone:shawnwu
    Harmless to call, but no actio is taken at this time. Waiting for 
    finalization of security policy schema.
*/

HRESULT 
CSsrEngine::VerifyDOM (
    IN IXMLDOMDocument2 * pXmlPolicy,
    OUT BSTR            * pbstrUnknownMember,
    OUT BSTR            * pbstrExtraInfo
    )
{
    HRESULT hr = S_OK;

    if (pbstrUnknownMember == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pbstrUnknownMember = NULL;
    }

    if (pbstrExtraInfo == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pbstrExtraInfo = NULL;
    }

    if (pXmlPolicy == NULL)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrEngine::CleanupOutputFiles

Functionality:
    
    Will clean up all those transformation output files for the given
    action.

Virtual:
    
    No.
    
Arguments:

    psaMemberNames  - The names of the members

    lAction         - The action verb.

    bLog            - If false, there will be no logging. This prevents 
                       extra logging during restoration of failed rollback
                       transformation.

Return Value:

    Success:   S_OK

    Failure:   various error codes

Notes:

    We must not blindly delete all the files in the output directory
    because some of them may be installed by a member. Only those transformation
    files we are told to generate will be cleanup.

*/

HRESULT 
CSsrEngine::CleanupOutputFiles (
    IN CSafeArray    * psaMemberNames,
    IN SsrActionVerb   lAction,
    IN bool            bLog
    )
{
    HRESULT hr = S_OK;
    HRESULT hrLastError = S_OK;

    //
    // log the action
    //

    if (bLog)
    {
        g_fblog.LogString(IDS_START_CLEANUP_CONFIGURE_OUTPUTS, NULL);
    }

    //
    // we will try to finish the work even if errors occur. However
    // we will return such error.
    //

    for (ULONG i = 0; i < psaMemberNames->GetSize(); i++)
    {
        CComVariant varName;

        //
        // Get the indexed element as a bstr = the name of the member
        //

        hr = psaMemberNames->GetElement(i, VT_BSTR, &varName);

        if (SUCCEEDED(hr))
        {
            CSsrMemberAccess * pMA = m_pMembership->GetMemberByName(
                                                        varName.bstrVal);

            if (pMA != NULL)
            {
                //
                // want output file directory (true inside SsrPGetDirectory)
                //

                hr = pMA->MoveOutputFiles(lAction, 
                                          SsrPGetDirectory(lAction, TRUE),
                                          NULL,
                                          true,
                                          bLog
                                          );

                if (FAILED(hr))
                {
                    hrLastError = hr;
                }
            }
        }
    }

    if (bLog)
    {
        g_fblog.LogString(IDS_END_CLEANUP_CONFIGURE_OUTPUTS, NULL);
    }

    return hrLastError;
}



/*
Routine Description: 

Name:

    CSsrEngine::MoveRollbackFiles

Functionality:
    
    Will move the rollback files (only those transformation output files
    for rollback) in the source directory root to the destination
    directory root.

Virtual:
    
    No.
    
Arguments:

    psaMemberNames  - The names of the all members

    pwszSrcDirPath  - The path of the source directory from which the files 
                      will to be moved.

    pwszDestDirRoot - The path of the destination directory to which the files 
                      will be moved .

Return Value:

    Success:   S_OK

    Failure:   various error codes

Notes:

*/

HRESULT 
CSsrEngine::MoveRollbackFiles (
    IN CSafeArray * psaMemberNames,
    IN LPCWSTR      pwszSrcDirPath,
    IN LPCWSTR      pwszDestDirPath,
    IN bool         bLog
    )
{
    HRESULT hr = S_OK;
    HRESULT hrLastError = S_OK;

    //
    // it's the output files of rollback transformation that 
    // need to be moved.
    //

    if (bLog)
    {
        g_fblog.LogString(IDS_START_BACKUP_ROLLBACK_OUTPUTS, NULL);
    }

    //
    // for each member, we need to move the rollback files
    //

    for (ULONG i = 0; i < psaMemberNames->GetSize(); i++)
    {
        CComVariant varName;

        //
        // this is the i-th member's name
        //

        hr = psaMemberNames->GetElement(i, VT_BSTR, &varName);

        if (SUCCEEDED(hr))
        {
            //
            // get this member's information access class
            //

            CSsrMemberAccess * pMA = m_pMembership->GetMemberByName(varName.bstrVal);

            _ASSERT(pMA != NULL);

            hr = pMA->MoveOutputFiles(ActionRollback,
                                      pwszSrcDirPath,
                                      pwszDestDirPath,
                                      false,    // don't delete
                                      bLog
                                      );
        }
    }

    if (bLog)
    {
        g_fblog.LogString(IDS_END_BACKUP_ROLLBACK_OUTPUTS, NULL);
    }

    return hrLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrmembership.h ===
// SSRMembership.h : Declaration of the CSSRMembership

#pragma once

#include "resource.h"       // main symbols

#include <map>

#include "global.h"

using namespace std;

class CSsrMemberAccess;


/////////////////////////////////////////////////////////////////////////////
// CSsrMembership

class ATL_NO_VTABLE CSsrMembership : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISsrMembership, &IID_ISsrMembership, &LIBID_SSRLib>
{
protected:
    CSsrMembership();

    virtual ~CSsrMembership();
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrMembership (const CSsrMembership& );
    void operator = (const CSsrMembership& );

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)
DECLARE_NOT_AGGREGATABLE(CSsrMembership)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSsrMembership)
	COM_INTERFACE_ENTRY(ISsrMembership)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISsrMembership
public:


    STDMETHOD(GetAllMembers) (
                OUT VARIANT * pvarArrayMembers // [out, retval] 
                );

    STDMETHOD(GetMember) (
			    IN BSTR bstrMemberName,
                OUT VARIANT * pvarMember //[out, retval] 
                );

    STDMETHOD(GetDirectoryLocation) (
                IN  BSTR   bstrActionVerb,
                IN  BOOL   bIsScriptFile,
                OUT BSTR * pbstrLocPath
                )
    {
        SsrActionVerb lAction = SsrPGetActionVerbFromString(bstrActionVerb);
        if (lAction == ActionInvalid)
        {
            return E_INVALIDARG;
        }

        BSTR bstrDir = SsrPGetDirectory(lAction, bIsScriptFile);
        *pbstrLocPath = SysAllocString(bstrDir);

        HRESULT hr = S_OK;

        if (bstrDir == NULL)
        {
            hr = E_INVALIDARG;
        }
        else if (*pbstrLocPath == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        return hr;
    }

    CSsrMemberAccess * GetMemberByName (
                IN BSTR bstrMemberName
                );

    HRESULT
    LoadAllMember ();

private:

    HRESULT
    LoadMember (
        IN LPCWSTR  wszMemberFilePath
        );

    MapMemberAccess m_ssrMemberAccessMap;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrlog.cpp ===
// SSRLog.cpp : Implementation of CSSRLog


#include "stdafx.h"

#include "SSRTE.h"
#include "SSRLog.h"

#include <Userenv.h>
#include "global.h"
#include "SSRMembership.h"

extern CComModule _Module;

/////////////////////////////////////////////////////////////////////////////
// CSsrLog


static LPCWSTR s_pszDefLogFileName = L"Log.txt";

static LPCWSTR s_pwszSource              = L"Source=";
static LPCWSTR s_pwszDetail              = L"Detail=";
static LPCWSTR s_pwszErrorCode           = L"ErrorCode=";
static LPCWSTR s_pwszErrorTextNotFound   = L"Error text can't be found";
static LPCWSTR s_pwszNotSpecified        = L"Not specified";
static LPCWSTR s_pwszSep                 = L"    ";
static LPCWSTR s_pwszCRLF                = L"\r\n";

static const DWORD s_dwSourceLen = wcslen(s_pwszSource);
static const DWORD s_dwSepLen    = wcslen(s_pwszSep);
static const DWORD s_dwErrorLen  = wcslen(s_pwszErrorCode);
static const DWORD s_dwDetailLen = wcslen(s_pwszDetail);
static const DWORD s_dwCRLFLen   = wcslen(s_pwszCRLF);


/*
Routine Description: 

Name:

    CSsrLog::CSsrLog

Functionality:
    
    constructor

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrLog::CSsrLog()
    : m_bstrLogFile(s_pszDefLogFileName)
{
}




/*
Routine Description: 

Name:

    CSsrLog::~CSsrLog

Functionality:
    
    destructor

Virtual:
    
    yes.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSsrLog::~CSsrLog()
{
}


/*
Routine Description: 

Name:

    CSsrLog::LogResult

Functionality:
    
    Log error code information. This function will do a message format function
    and then log both the error code and the formatted msg.

Virtual:
    
    yes.
    
Arguments:

    bstrSrc     - source of error. This is just indicative of the information source.

    dwErrorCode - The error code itself.

    dwCodeType  - The type of error code. We use WMI extensively, 
                  its error code lookup is slightly different from others.
                 

Return Value:

    ?.

Notes:
    
    The error code may not be an error. It can be a success code.

*/

STDMETHODIMP 
CSsrLog::LogResult (
    BSTR bstrSrc, 
    LONG lErrorCode, 
    LONG lCodeType
    )
{
    HRESULT hr = S_OK;

    if (m_bstrLogFilePath.Length() == 0)
    {
        hr = CreateLogFilePath();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // default to not able to find the error text
    //

    LPCWSTR pwszLog = s_pwszErrorTextNotFound;

    //
    // will hold the hex decimal of the error code in case the 
    // error code can't be translated into a string
    //

    CComBSTR bstrErrorText;

    hr = GetErrorText(lErrorCode, lCodeType, &bstrErrorText);

    if (SUCCEEDED(hr))
    {
        //
        // if we can get error test, then this is the log we want
        //

        pwszLog = bstrErrorText;
    }

    //
    // now write to the file
    //

    LPCWSTR pwszSrcString = s_pwszNotSpecified;

    if (bstrSrc != NULL && *bstrSrc != L'\0')
    {
        pwszSrcString = bstrSrc;
    }

    //
    // one error log is like this: Source=XXXX*****ErrorCode=XXXX*****Detail=XXXX
    // where XXXX represent any text and the ***** represents the separater.
    //

    int iLen = s_dwSourceLen + 
               wcslen(pwszSrcString) + 
               s_dwSepLen + 
               s_dwErrorLen + 
               10 +                         // hex decimal has 10 chars for DWORD
               s_dwSepLen +
               s_dwDetailLen + 
               wcslen(pwszLog);

    LPWSTR pwszLogString = new WCHAR[iLen + 1];

    //
    // format the log string and do the logging
    //

    if (pwszLogString != NULL)
    {
        _snwprintf(pwszLogString,
                   iLen + 1,
                   L"%s%s%s%s0x%X%s%s%s",
                   s_pwszSource, 
                   pwszSrcString, 
                   s_pwszSep, 
                   s_pwszErrorCode, 
                   lErrorCode, 
                   s_pwszSep,
                   s_pwszDetail, 
                   pwszLog
                   );

        hr = PrivateLogString(pwszLogString);

        delete [] pwszLogString;
        pwszLogString = NULL;
    }

    
	return hr;
}




/*
Routine Description: 

Name:

    CSsrLog::GetErrorText

Functionality:
    
    Lookup the error text using the error code

Virtual:
    
    no.
    
Arguments:

    lErrorCode      - The error code itself.

    lCodeType       - The type of error code. We use WMI extensively, 
                      its error code lookup is slightly different from others.

    pbstrErrorText  - The error text corresponding to this error code
                 

Return Value:

    ?.

Notes:
    
    The error code may not be an error. It can be a success code.

*/

HRESULT 
CSsrLog::GetErrorText (
    IN  LONG   lErrorCode, 
    IN  LONG   lCodeType,
    OUT BSTR * pbstrErrorText
    )
{
    if (pbstrErrorText == NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrErrorText = NULL;

    LPVOID pMsgBuf = NULL;

    HRESULT hr = S_OK;

    if (lCodeType == SSR_LOG_ERROR_TYPE_Wbem)
    {
        hr = GetWbemErrorText(lErrorCode, pbstrErrorText);
    }
    else
    {
        DWORD flag = FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                     FORMAT_MESSAGE_FROM_SYSTEM     |
                     FORMAT_MESSAGE_IGNORE_INSERTS;

        DWORD dwRet = ::FormatMessage( 
                                    flag,
                                    NULL,
                                    lErrorCode,
                                    0, // Default language
                                    (LPWSTR) &pMsgBuf,
                                    0,
                                    NULL 
                                    );

        //
        // trying our own errors if this failes to give us anything
        //

        if (dwRet == 0)
        {
            flag = FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                   FORMAT_MESSAGE_FROM_HMODULE    |
                   FORMAT_MESSAGE_IGNORE_INSERTS;

            dwRet = ::FormatMessage( 
                                    flag,
                                    _Module.m_hInst,
                                    lErrorCode,
                                    0, // Default language
                                    (LPWSTR) &pMsgBuf,
                                    0,
                                    NULL 
                                    );

        }

        if (dwRet != 0)
        {
            *pbstrErrorText = ::SysAllocString((LPCWSTR)pMsgBuf);
            if (*pbstrErrorText == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (pMsgBuf != NULL)
    {
        ::LocalFree( pMsgBuf );
    }

    if (FAILED(hr) && E_OUTOFMEMORY != hr)
    {
        if (*pbstrErrorText != NULL)
        {
            ::SysFreeString(*pbstrErrorText);
            *pbstrErrorText = NULL;
        }

        //
        // fall back to just give the error code
        //

        WCHAR wszErrorCode[g_dwHexDwordLen];
        _snwprintf(wszErrorCode, g_dwHexDwordLen, L"0x%X", lErrorCode);

        *pbstrErrorText = ::SysAllocString(wszErrorCode);

        hr = (*pbstrErrorText != NULL) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}




/*
Routine Description: 

Name:

    CSsrLog::PrivateLogString

Functionality:
    
    Just log the string to the log file. We don't attempt to do any formatting.

Virtual:
    
    no.
    
Arguments:

    pwszLogRecord   - The string to be logged into the log file

Return Value:

    Success: S_OK.

    Failure: various error codes.

Notes:

*/

HRESULT 
CSsrLog::PrivateLogString (
    IN LPCWSTR pwszLogRecord
    )
{
    HRESULT hr = S_OK;

    if (m_bstrLogFilePath.Length() == 0)
    {
        hr = CreateLogFilePath();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // $consider:shawnwu,
    // Right now, we write to the log file each time the function is called.
    // That might cause the problem too much file access and becomes a performance
    // issue. We might want to consider optimizing this.
    //

    DWORD dwWait = ::WaitForSingleObject(g_fblog.m_hLogMutex, INFINITE);

    //
    // $undone:shawnwu, some error happened, should we continue to log?
    //

    if (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_ABANDONED)
    {
        return E_SSR_LOG_FILE_MUTEX_WAIT;
    }

    HANDLE hFile = ::CreateFile(m_bstrLogFilePath,
                               GENERIC_WRITE,
                               0,       // not shared
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );

    if (hFile != INVALID_HANDLE_VALUE)
    {
        //
        // append the text to the end of the file
        //

        ::SetFilePointer (hFile, 0, NULL, FILE_END);

        DWORD dwBytesWritten = 0;

        if ( 0 == ::WriteFile (hFile, 
                               (LPCVOID)pwszLogRecord, 
                               wcslen(pwszLogRecord) * sizeof(WCHAR), 
                               &dwBytesWritten, 
                               NULL) ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        //
        // put a line break
        //

        if ( 0 == ::WriteFile (hFile, 
                               (LPCVOID)s_pwszCRLF, 
                               s_dwCRLFLen * sizeof(WCHAR), 
                               &dwBytesWritten, 
                               NULL) ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        ::CloseHandle(hFile);

    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    ::ReleaseMutex(g_fblog.m_hLogMutex);

	return hr;
}



/*
Routine Description: 

Name:

    CSsrLog::get_LogFilePath

Functionality:
    
    Will return the full path of the log file this object uses

Virtual:
    
    yes.
    
Arguments:

    pbstrLogFilePath    - receives the current log file's full path.

Return Value:

    Success: S_OK;

    Failure: E_OUTOFMEMORY

Notes:

*/

STDMETHODIMP
CSsrLog::get_LogFilePath (
    OUT BSTR * pbstrLogFilePath /*[out, retval]*/ 
    )
{
    HRESULT hr = S_OK;

    if (pbstrLogFilePath == NULL)
    {
        return E_INVALIDARG;
    }

    if (m_bstrLogFilePath.Length() == 0)
    {
        hr = CreateLogFilePath();
    }
    
    if (SUCCEEDED(hr))
    {
        *pbstrLogFilePath = ::SysAllocString(m_bstrLogFilePath);
    }
    
    return (*pbstrLogFilePath != NULL) ? S_OK : E_OUTOFMEMORY;
}



/*
Routine Description: 

Name:

    CSsrLog::put_LogFile

Functionality:
    
    Will set the log file.

Virtual:
    
    yes.
    
Arguments:

    bstrLogFile - the file name (plus extension) the caller wants this
                  object to use.

Return Value:

    ?.

Notes:
    The bstrLogFile must be just a file name without any directory path
*/

STDMETHODIMP
CSsrLog::put_LogFile (
    IN BSTR bstrLogFile
    )
{
    HRESULT hr = S_OK;

    //
    // you can't give me a invalid log file name
    // It also must just be an name
    //

    if (bstrLogFile == NULL     || 
        *bstrLogFile == L'\0'   || 
        ::wcsstr(bstrLogFile, L"\\") != NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_bstrLogFile = bstrLogFile;
        hr = CreateLogFilePath();
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSsrLog::CreateLogFilePath

Functionality:
    
    Create the log file's path.

Virtual:
    
    no.
    
Arguments:

    None

Return Value:

    Success: S_OK;

    Failure: E_OUTOFMEMORY

Notes:
    The bstrLogFile must be just a file name without any directory path
*/

HRESULT
CSsrLog::CreateLogFilePath ( )
{
    if (wcslen(g_wszSsrRoot) + 1 + wcslen(g_pwszLogs) + 1 + wcslen(m_bstrLogFile) > MAX_PATH)
    {
        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }

    WCHAR wcLogFilePath[MAX_PATH + 1];

    _snwprintf(wcLogFilePath, 
               MAX_PATH + 1,
               L"%s%c%s%c%s", 
               g_wszSsrRoot, 
               L'\\',
               g_pwszLogs,
               L'\\',
               m_bstrLogFile
               );

    m_bstrLogFilePath.Empty();  // so that in case of out-of-memory, it will be NULL

    m_bstrLogFilePath = wcLogFilePath;

    return m_bstrLogFilePath != NULL ? S_OK : E_OUTOFMEMORY;
}



/*
Routine Description: 

Name:

    CSsrLog::GetWbemErrorText

Functionality:
    
    Private helper to lookup WMI error text based on the error code

Virtual:
    
    yes.
    
Arguments:

    hrCode          - HRESULT code.

    pbstrErrText    - The out paramter that receives the text of the error code

Return Value:

    Success:
        S_OK if everything is OK.
        S_FALSE if we can't locate the error text. in that case, we fall back
                to give text, which is just the text representation of the 
                error code

    Failure:
        various error codes.

Notes:
    
    The error code may not be an error. It can be a success code.

*/

HRESULT 
CSsrLog::GetWbemErrorText (
    HRESULT    hrCode,
    BSTR    *  pbstrErrText
    )
{
    if (pbstrErrText == NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrErrText = NULL;
    
    HRESULT hr = S_OK;

    if (m_srpStatusCodeText == NULL)
    {
        hr = ::CoCreateInstance(CLSID_WbemStatusCodeText, 
                                0, 
                                CLSCTX_INPROC_SERVER, 
                                IID_IWbemStatusCodeText, 
                                (LPVOID*)&m_srpStatusCodeText
                                );
    }

    if (m_srpStatusCodeText)
    {
        //
        // IWbemStatusCodeText is to translate the HRESULT to text
        //

        hr = m_srpStatusCodeText->GetErrorCodeText(hrCode, 0, 0, pbstrErrText);
    }
    
    if (FAILED(hr) || *pbstrErrText == NULL)
    {
        //
        // we fall back to just formatting the error code. 
        // Hex of DWORD has 10 WCHARs
        //

        WCHAR wszCode[g_dwHexDwordLen];
        _snwprintf(wszCode, g_dwHexDwordLen, L"0x%X", hrCode);

        *pbstrErrText = ::SysAllocString(wszCode);

        if (*pbstrErrText != NULL)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}



//--------------------------------------------------------------
// implementation of CFBLogMgr



/*
Routine Description: 

Name:

    CFBLogMgr::CFBLogMgr

Functionality:
    
    constructor

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CFBLogMgr::CFBLogMgr()
    : m_hLogMutex(NULL),
      m_dwRemainSteps(0),
      m_bVerbose(false)
{
    HRESULT hr = CComObject<CSsrLog>::CreateInstance(&m_pLog);

    if (SUCCEEDED(hr))
    {
        m_pLog->AddRef();
        m_hLogMutex = ::CreateMutex(NULL, FALSE, L"ISsrLogMutex");
    }
    
    //
    // see if we are logging verbose or not
    //

    HKEY hRootKey = NULL;

    LONG lStatus = ::RegOpenKeyEx(
                          HKEY_LOCAL_MACHINE,
                          g_pwszSSRRegRoot,
                          0,
                          KEY_READ,
                          &hRootKey
                          );

    if (ERROR_SUCCESS == lStatus)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwVerbose = 0;
        DWORD dwType;

        lStatus = ::RegQueryValueEx(hRootKey,
                                    L"LogVerbose",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwVerbose,
                                    &dwSize
                                    );

        if (ERROR_SUCCESS == lStatus)
        {
            m_bVerbose = (dwVerbose == 0) ? false : true;
        }

        ::RegCloseKey(hRootKey);
    }
}




/*
Routine Description: 

Name:

    CFBLogMgr::~CFBLogMgr

Functionality:
    
    destructor

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CFBLogMgr::~CFBLogMgr()
{
    if (m_pLog)
    {
        m_pLog->Release();
        if (m_hLogMutex)
        {
            ::CloseHandle(m_hLogMutex);
        }
    }
}



/*
Routine Description: 

Name:

    CFBLogMgr::SetFeedbackSink

Functionality:
    
    Caches the feedback sink interface. This allows us to send
    feedback. If the in parameter is not a valid interface, then
    we won't send feedback.

Virtual:
    
    no.
    
Arguments:

    varFeedbackSink - The variant that holds an ISsrFeedbackSink COM
                      interface pointer.

Return Value:

    Success: S_OK

    Failure: E_INVALIDARG;

Notes:
    

*/

HRESULT
CFBLogMgr::SetFeedbackSink (
    IN VARIANT varFeedbackSink
    )
{
    DWORD dwWait = ::WaitForSingleObject(m_hLogMutex, INFINITE);

    if (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_ABANDONED)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    m_srpFeedback.Release();

    HRESULT hr = S_FALSE;

    if (varFeedbackSink.vt == VT_UNKNOWN)
    {
        hr = varFeedbackSink.punkVal->QueryInterface(IID_ISsrFeedbackSink, 
                                                     (LPVOID*)&m_srpFeedback);
    }
    else if (varFeedbackSink.vt == VT_DISPATCH)
    {
        hr = varFeedbackSink.pdispVal->QueryInterface(IID_ISsrFeedbackSink, 
                                                      (LPVOID*)&m_srpFeedback);
    }
    
    if (hr == S_FALSE)
    {
        hr = E_INVALIDARG;
    }

    ::ReleaseMutex(m_hLogMutex);
    
    return hr;
}




/*
Routine Description: 

Name:

    CFBLogMgr::LogFeedback

Functionality:
    
    Will log/feedback ULONG informaiton for SSR Engine's custom behavior. 

Virtual:
    
    no.
    
Arguments:

    lSsrFbLogMsg - This parameter contains two parts: everything under SSR_FB_ALL_MASK
                   is the ssr feedback message. Other bits are for logging perposes.

    dwErrorCode  - The error code.

    ulDetail     - The detail of the information in integer format.

    uCauseResID  - The cause's resource ID. This helps us to localize. If this
                   value is 0, then it means no valid resource ID.

Return Value:

    none.

Notes:

*/

void
CFBLogMgr::LogFeedback (
    IN LONG      lSsrFbLogMsg,
    IN DWORD     dwErrorCode,
    IN LPCWSTR   pwszObjDetail,
    IN ULONG     uCauseResID
    )
{
    
    bool bNeedFB  = NeedFeedback(lSsrFbLogMsg);
    bool bNeedLog = NeedLog(lSsrFbLogMsg);

    if (!bNeedFB && !bNeedLog)
    {
        return;
    }

    HRESULT hr = S_OK; 
    LONG lSsrFbMsg = lSsrFbLogMsg & SSR_FB_ALL_MASK;

    //
    // hex for DWORD is 10 wchar long
    //

    LPWSTR pwszCode = new WCHAR[s_dwErrorLen + g_dwHexDwordLen];

    if (pwszCode != NULL)
    {
        CComBSTR bstrLogStr;
        hr = GetLogString(uCauseResID, dwErrorCode, pwszObjDetail, lSsrFbLogMsg, &bstrLogStr);
    
        if (SUCCEEDED(hr) && bNeedFB)
        {
            //
            // need to feedback
            //

            VARIANT var;
            var.vt = VT_UI4;
            var.ulVal = dwErrorCode;
        
            m_srpFeedback->OnNotify(lSsrFbMsg, var, bstrLogStr);
        }

        if (SUCCEEDED(hr) && bNeedLog)
        {
            //
            // need to log
            //

            m_pLog->LogString(bstrLogStr);
        }

        delete [] pwszCode;
    }
}



/*
Routine Description: 

Name:

    CFBLogMgr::LogFeedback

Functionality:
    
    Will log/feedback string informaiton for SSR Engine's custom behavior. 

Virtual:
    
    no.
    
Arguments:

    lSsrFbLogMsg    - This parameter contains two parts: everything under SSR_FB_ALL_MASK
                      is the ssr feedback message. Other bits are for logging perposes.

    pwszError       - The error test.

    pwszObjDetail   - Some extra informaiton about the target "object"

    uCauseResID     - The cause's resource ID. This helps us to localize. If this
                      value is 0, then it means no valid resource ID.

Return Value:

    none.

Notes:
    

*/

void
CFBLogMgr::LogFeedback (
    IN LONG      lSsrFbLogMsg,
    IN LPCWSTR   pwszError,
    IN LPCWSTR   pwszObjDetail,
    IN ULONG     uCauseResID
    )
{
    //
    // See if we need to send feedback notification or logging
    //


    bool bNeedFB  = NeedFeedback(lSsrFbLogMsg);
    bool bNeedLog = NeedLog(lSsrFbLogMsg);

    LONG lSsrFbMsg = lSsrFbLogMsg & SSR_FB_ALL_MASK;

    if (!bNeedFB && !bNeedLog)
    {
        return;
    }

    HRESULT hr = S_OK;

    CComBSTR bstrLogStr;
    hr = GetLogString(uCauseResID, pwszError, pwszObjDetail, lSsrFbLogMsg, &bstrLogStr);


    if (SUCCEEDED(hr) && bNeedFB)
    {
        //
        // need to feedback
        //

        CComVariant var(pwszError);
        
        m_srpFeedback->OnNotify(lSsrFbMsg, var, bstrLogStr);

    }

    if (SUCCEEDED(hr) && bNeedLog)
    {
        //
        // need to log
        //

        m_pLog->LogString(bstrLogStr);
    }
}





/*
Routine Description: 

Name:

    CFBLogMgr::LogError

Functionality:
    
    Will log the error. 

Virtual:
    
    no.
    
Arguments:

    dwErrorCode     - The error code

    pwszMember      - The member's name. Can be NULL.

    pwszExtraInfo   - Extra inforamtion. Can be NULL.

Return Value:

    none.

Notes:
    

*/

void
CFBLogMgr::LogError (
    IN DWORD   dwErrorCode,
    IN LPCWSTR pwszMember,
    IN LPCWSTR pwszExtraInfo
    )
{
    if (m_pLog != NULL)
    {
        CComBSTR bstrErrorText;
        HRESULT hr = m_pLog->GetErrorText(dwErrorCode, 
                                          SSR_LOG_ERROR_TYPE_COM, 
                                          &bstrErrorText
                                          );
        if (SUCCEEDED(hr))
        {
            //
            // if we have a member, then put a separator and then
            // append the member's name
            //

            if (pwszMember != NULL && *pwszMember != L'\0')
            {
                bstrErrorText += s_pwszSep;
                bstrErrorText += pwszMember;
            }

            //
            // if we have extra info, then put a separator and then
            // append the extra info
            //

            if (pwszExtraInfo != NULL && *pwszExtraInfo != L'\0')
            {
                bstrErrorText += s_pwszSep;
                bstrErrorText += pwszExtraInfo;
            }

            m_pLog->PrivateLogString(bstrErrorText);
        }
    }
}





/*
Routine Description: 

Name:

    CFBLogMgr::LogString

Functionality:
    
    Will log the error. 

Virtual:
    
    no.
    
Arguments:

    dwResID     - The resource ID

    pwszDetail  - if not NULL, we will insert this string into
                  the string from the resource.

Return Value:

    none.

Notes:
    
    Caller must guarantee that the resource string contains
    formatting info if pwszDetail is not NULL.

*/

void
CFBLogMgr::LogString (
    IN DWORD   dwResID,
    IN LPCWSTR pwszDetail
    )
{
    if (m_pLog != NULL)
    {
        CComBSTR strText;

        //
        // load the string
        //

        if (strText.LoadString(dwResID))
        {
            LPWSTR pwszLogText = NULL;
            bool bReleaseLogText = false;

            //
            // need to reformat the text if pwszDetail is not NULL
            //

            if (pwszDetail != NULL)
            {
                DWORD dwDetailLen = (pwszDetail == NULL) ? 0 : wcslen(pwszDetail);
                dwDetailLen += strText.Length() + 1;

                pwszLogText = new WCHAR[dwDetailLen];

                if (pwszLogText != NULL)
                {
                    _snwprintf(pwszLogText, dwDetailLen, strText, pwszDetail);
                    bReleaseLogText = true;
                }
            }
            else
            {
                pwszLogText = strText.m_str;
            }

            if (pwszLogText != NULL)
            {
                m_pLog->PrivateLogString(pwszLogText);
            }

            if (bReleaseLogText)
            {
                delete [] pwszLogText;
            }
        }
    }
}

/*
Routine Description: 

Name:

    CFBLogMgr::GetLogObject

Functionality:
    
    Return the ISsrLog Object wrapped up by this class in VARIANT.

Virtual:
    
    no.
    
Arguments:

    pvarVal    - Receives the ISsrLog object

Return Value:

    none.

Notes:
    

*/

HRESULT CFBLogMgr::GetLogObject (
    OUT VARIANT * pvarVal
    )
{
    HRESULT hr = S_FALSE;
    ::VariantInit(pvarVal);
    if (m_pLog)
    {
        CComPtr<ISsrLog> srpObj;
        hr = m_pLog->QueryInterface(IID_ISsrLog, (LPVOID*)&srpObj);
        if (S_OK == hr)
        {
            pvarVal->vt = VT_DISPATCH;
            pvarVal->pdispVal = srpObj.Detach();
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CFBLogMgr::GetLogString

Functionality:
    
    Return the ISsrLog Object wrapped up by this class in VARIANT.

Virtual:
    
    no.
    
Arguments:

    uCauseResID     - The resource ID for the cause this log/feedback information

    pwszText        - Whatever text the caller want to pass.

    pwszObjDetail   - The target object or info detail

    lSsrMsg         - The msg will eventually affect how detail our logging information
                      will be. Currently, it is not used.

    pbstrLogStr     - Receives the formatted single piece of text.

Return Value:

    Success: S_OK.

    Failure: various error codes

Notes:
   
    
*/

HRESULT 
CFBLogMgr::GetLogString (
    IN  ULONG       uCauseResID,
    IN  LPCWSTR     pwszText,
    IN  LPCWSTR     pwszObjDetail,
    IN  LONG        lSsrMsg, 
    OUT BSTR      * pbstrLogStr
    )const
{
    UNREFERENCED_PARAMETER(lSsrMsg);

    if (pbstrLogStr == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // if verbose logging, then we will prefix the log text with
    // the heading.
    //

    *pbstrLogStr = NULL;
    CComBSTR bstrLogText = (m_bVerbose) ? m_bstrVerboseHeading : L"";

    if (bstrLogText.m_str == NULL)
    {
        return E_OUTOFMEMORY;
    }


    if (uCauseResID != g_dwResNothing)
    {
        CComBSTR bstrRes;
        if (bstrRes.LoadString(uCauseResID))
        {
            bstrRes += s_pwszSep;
            bstrLogText += bstrRes;
        }
    }

    if (pwszText != NULL)
    {
        bstrLogText += s_pwszSep;
        bstrLogText += pwszText;
    }

    if (pwszObjDetail != NULL)
    {
        bstrLogText += s_pwszSep;
        bstrLogText += pwszObjDetail;
    }
    *pbstrLogStr = bstrLogText.Detach();

    return (*pbstrLogStr == NULL) ? E_OUTOFMEMORY : S_OK;
}




/*
Routine Description: 

Name:

    CFBLogMgr::GetLogString

Functionality:
    
    Return the ISsrLog Object wrapped up by this class in VARIANT.

Virtual:
    
    no.
    
Arguments:

    uCauseResID     - The resource ID for the cause this log/feedback information

    lSsrFbMsg       - The feedback msg will eventually be used to determine how
                      detail (verbose) the information will be logged. Currently,
                      it is not used.

    pbstrDescription- Receives the description text.

Return Value:

    Success: S_OK.

    Failure: various error codes

Notes:
    
*/

HRESULT 
CFBLogMgr::GetLogString (
    IN  ULONG       uCauseResID,
    IN  DWORD       dwErrorCode,
    IN  LPCWSTR     pwszObjDetail,
    IN  LONG        lSsrFbMsg, 
    OUT BSTR      * pbstrLogStr
    )const
{
    UNREFERENCED_PARAMETER( lSsrFbMsg );

    if (pbstrLogStr == NULL)
    {
        return E_INVALIDARG;
    }
    *pbstrLogStr = NULL;

    CComBSTR bstrLogText = (m_bVerbose) ? m_bstrVerboseHeading : L"";
    if (bstrLogText.m_str == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (uCauseResID != 0)
    {
        CComBSTR bstrRes;
        if (bstrRes.LoadString(uCauseResID))
        {
            bstrRes += s_pwszSep;
            bstrLogText += bstrRes;
        }
    }

    HRESULT hr = S_OK;
    
    //
    // get the detail based on the error code
    //

    if (m_pLog != NULL)
    {
        CComBSTR bstrDetail;
        hr = m_pLog->GetErrorText(dwErrorCode, 
                                 SSR_LOG_ERROR_TYPE_COM, 
                                 &bstrDetail
                                 );

        if (SUCCEEDED(hr))
        {
            bstrLogText += bstrDetail;

            if (pwszObjDetail != NULL)
            {
                bstrLogText += s_pwszSep;
                bstrLogText += pwszObjDetail;
            }
        }
    }

    *pbstrLogStr = bstrLogText.Detach();

    return (*pbstrLogStr == NULL) ? E_OUTOFMEMORY : hr;
}




/*
Routine Description: 

Name:

    CFBLogMgr::SetTotalSteps

Functionality:
    
    Inform the sink (if any) that the entire action will take these many
    steps to complte. Later on, we will use Steps function to inform the sink
    that that many steps have just been completed. This forms the notication
    for progress feedback

Virtual:
    
    no.
    
Arguments:

    dwTotal - The total number of steps for the entire process to complete

Return Value:

    none.

Notes:
    
*/

void 
CFBLogMgr::SetTotalSteps (
    IN DWORD dwTotal
    )
{
    DWORD dwWait = ::WaitForSingleObject(m_hLogMutex, INFINITE);

    if (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_ABANDONED)
    {
        return;
    }

    m_dwRemainSteps = dwTotal;

    if (m_srpFeedback != NULL)
    {
        VARIANT var;
        var.vt = VT_UI4;
        var.ulVal = dwTotal;

        static CComBSTR bstrTotalSteps;
        
        if (bstrTotalSteps.m_str == NULL)
        {
            bstrTotalSteps.LoadString(IDS_TOTAL_STEPS);
        }

        if (bstrTotalSteps.m_str != NULL)
        {
            m_srpFeedback->OnNotify(SSR_FB_TOTAL_STEPS, var, bstrTotalSteps);
        }
    }

    ::ReleaseMutex(m_hLogMutex);
}



/*
Routine Description: 

Name:

    CFBLogMgr::Steps

Functionality:
    
    Inform the sink (if any) that these many steps have just been completed. 
    This count is not the total number of steps that have been completed to
    this point. It is the steps since last notification that have been done.

Virtual:
    
    no.
    
Arguments:

    dwSteps - The completed steps done since last notification

Return Value:

    none.

Notes:
    
*/

void 
CFBLogMgr::Steps (
    IN DWORD dwSteps
    )
{
    DWORD dwWait = ::WaitForSingleObject(m_hLogMutex, INFINITE);

    if (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_ABANDONED)
    {
        return;
    }

    //
    // we will never progress more than the remaining steps
    //

    DWORD dwStepsToNotify = dwSteps;
    if (m_dwRemainSteps < dwSteps)
    {
        dwStepsToNotify = m_dwRemainSteps;
    }
    
    m_dwRemainSteps -= dwStepsToNotify;

    if (m_srpFeedback != NULL)
    {
        VARIANT var;
        var.vt = VT_UI4;
        var.ulVal = dwStepsToNotify;

        CComBSTR bstrNoDetail;

        m_srpFeedback->OnNotify(SSR_FB_STEPS_JUST_DONE, var, bstrNoDetail);
    }

    ::ReleaseMutex(m_hLogMutex);
}




/*
Routine Description: 

Name:

    CFBLogMgr::TerminateFeedback

Functionality:
    
    We will let go the feedback sink object once our action is
    completed. This is also a place to progress any remaining steps.

Virtual:
    
    no.
    
Arguments:

    None.

Return Value:

    none.

Notes:
    
    Many errors will cause a function to prematurely
    return and cause the total steps not going down to zero,
    this is a good place to do the final steps count balance.
    
*/

void 
CFBLogMgr::TerminateFeedback()
{
    DWORD dwWait = ::WaitForSingleObject(m_hLogMutex, INFINITE);

    if (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_ABANDONED)
    {
        return;
    }

    Steps(m_dwRemainSteps);
    m_srpFeedback.Release();

    ::ReleaseMutex(m_hLogMutex);
}


/*
Routine Description: 

Name:

    CFBLogMgr::SetMemberAction

Functionality:
    
    This function sets the member and action information
    that can be used for verbose logging. We will as a result
    create a log heading which will be added to the log when
    LogFeedback functions are called.

Virtual:
    
    no.
    
Arguments:

    pwszMember - The member's name

    pwszAction - the action

Return Value:

    none.

Notes:
    
*/

void 
CFBLogMgr::SetMemberAction (
    IN LPCWSTR pwszMember,
    IN LPCWSTR pwszAction
    )
{
    //
    // wait for the mutex.
    //

    DWORD dwWait = ::WaitForSingleObject(m_hLogMutex, INFINITE);

    if (dwWait != WAIT_OBJECT_0 && dwWait != WAIT_ABANDONED)
    {
        return;
    }

    m_bstrVerboseHeading.Empty();

    //
    // for better formatting, we will reserve 20 characters for
    // the name of member and action. For that need, we will prepare
    // an array containing only space characters.
    //

    const DWORD PART_LENGTH = 20;

    WCHAR wszHeading[ 2 * PART_LENGTH + 1];
    ::memset(wszHeading, 1, 2 * PART_LENGTH * sizeof(WCHAR));
    wszHeading[2 * PART_LENGTH] = L'\0';

    _wcsset(wszHeading, L' ');
    
    //
    // if the given member and action's total length is more
    // than our pre-determined buffer, then we are going to 
    // let the heading grow
    //

    DWORD dwMemLen = wcslen(pwszMember);
    DWORD dwActLen = wcslen(pwszAction);

    if (dwMemLen + dwActLen > 2 * PART_LENGTH)
    {
        //
        // just let the heading grow to whatever length it needs
        //

        m_bstrVerboseHeading = pwszMember;
        m_bstrVerboseHeading += s_pwszSep;
        m_bstrVerboseHeading += pwszAction;
        m_bstrVerboseHeading += s_pwszSep;
    }
    else
    {
        //
        // copy the member
        //

        LPWSTR pwszHead = wszHeading;

        for (ULONG i = 0; i < dwMemLen; i++)
        {
            *pwszHead = pwszMember[i];
            pwszHead++;
        }

        if (i < PART_LENGTH)
        {
            pwszHead = wszHeading + PART_LENGTH;
        }

        //
        // copy the action
        //

        for (i = 0; i < dwActLen; i++)
        {
            *pwszHead = pwszAction[i];
            pwszHead++;
        }

        m_bstrVerboseHeading.m_str = ::SysAllocString(wszHeading);
    }

    ::ReleaseMutex(m_hLogMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\ssrlog.h ===
// SSRLog.h : Declaration of the CSSRLog

#pragma once

#include "resource.h"       // main symbols
#include "SSRTE.h"
#include "wbemcli.h"


/////////////////////////////////////////////////////////////////////////////
// CSSRLog


class ATL_NO_VTABLE CSsrLog : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSsrLog, &CLSID_SsrLog>,
	public IDispatchImpl<ISsrLog, &IID_ISsrLog, &LIBID_SSRLib>
{
protected:
    CSsrLog();
    virtual ~CSsrLog();
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSsrLog (const CSsrLog& );
    void operator = (const CSsrLog& );

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SSRTENGINE)
DECLARE_NOT_AGGREGATABLE(CSsrLog)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSsrLog)
	COM_INTERFACE_ENTRY(ISsrLog)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISsrLog
public:

	STDMETHOD(LogString) (
        IN BSTR bstrLogRecord
        )
    {
        return PrivateLogString(bstrLogRecord);
    }

	STDMETHOD(LogResult) (
        IN BSTR bstrSrc, 
        IN LONG lErrorCode, 
        IN LONG lErrorCodeType
        );

    STDMETHOD(get_LogFilePath) (
        OUT BSTR * pbstrLogFilePath
        );

	STDMETHOD(put_LogFile) (
        IN BSTR bstrLogFile
        );

    HRESULT PrivateLogString (
        IN LPCWSTR pwszLogRecord
        );

    HRESULT 
    GetErrorText (
        IN  LONG   lErrorCode, 
        IN  LONG   lCodeType,
        OUT BSTR * pbstrErrorText
        );

private:

    HRESULT CreateLogFilePath ();

    HRESULT 
    GetWbemErrorText (
        HRESULT    hrCode,
        BSTR    * pbstrErrText
        );

    CComPtr<IWbemStatusCodeText> m_srpStatusCodeText;
    
    CComBSTR m_bstrLogFilePath;
    CComBSTR m_bstrLogFile;
};


const LONG FBLog_Log       = 0x01000000;

//
// these are for logging only, not for feedback. Please see SSR_FB_ALL_MASK
//

const LONG FBLog_Stack         = 0x10000000;   // for call stack only
const LONG FBLog_Verbose       = 0x20000000;   // intended for verbose logging only
const LONG FBLog_VerboseMask   = 0xF0000000;



//
// helper class to do feedback and logging. We will only have one object
// instance of this class.
//


class CFBLogMgr
{
protected:
    
    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CFBLogMgr (const CFBLogMgr& );
    void operator = (const CFBLogMgr& );

public:
    CFBLogMgr();
    ~CFBLogMgr();

    HRESULT SetFeedbackSink (
            IN VARIANT varSink
            );

    //
    // We will release the feedback object once the action
    // is completed instead of holding on to the object for
    // future use.
    //

    void TerminateFeedback();

    //
    // This will cause the logging header to be modified
    //

    void SetMemberAction (
            IN LPCWSTR pwszMember,
            IN LPCWSTR pwszAction
            );

    //
    // This will do both logging and feedback.
    //

    void LogFeedback (
            IN LONG      lSsrFbLogMsg,
            IN DWORD     dwErrorCode,
            IN LPCWSTR   pwszObjDetail,
            IN ULONG     uCauseResID
            );

    //
    // This will do both logging and feedback.
    //

    void LogFeedback (
            IN LONG      lSsrFbLogMsg,
            IN LPCWSTR   pwszError,
            IN LPCWSTR   pwszObjDetail,
            IN ULONG     uCauseResID
            );

    //
    // This only does logging, no feedback. The error code will
    // be used to lookup the error text (assuming this is not WBEM error)
    //

    void LogError (
            IN DWORD   dwErrorCode,
            IN LPCWSTR pwszMember,
            IN LPCWSTR pwszExtraInfo
            );

    //
    // will return the ISsrLog object this helper class uses
    //

    HRESULT GetLogObject (
            OUT VARIANT * pvarVal
            );

    //
    // will just log the text to the log file
    //

    void LogString (
            IN LPCWSTR pwszText
            )
    {
        if (m_pLog != NULL)
        {
            m_pLog->PrivateLogString(pwszText);
        }
    }

    //
    // will just log the text (using resource id) with pwszDetail
    // inserted into the text (if not NULL)
    //

    void LogString (
            IN DWORD   dwResID,
            IN LPCWSTR pwszDetail
            );

    //
    // entire process will take these many steps
    //

    void SetTotalSteps (
        IN DWORD dwTotal
        );

    //
    // progress has moved forward these many steps
    //

    void Steps (
        IN DWORD dwSteps
        );

    //
    // Since this is an internal class, we don't intend to create multiple
    // instance of this class. This mutex is thus a single instance
    //

    HANDLE m_hLogMutex;

private:

    bool NeedLog (
            IN LONG lFbMsg
            )const
    {
        return ( m_pLog != NULL && 
                 ( (lFbMsg & FBLog_Log) || 
                   ( (lFbMsg & FBLog_VerboseMask) && m_bVerbose) 
                 )
               );
    }

    bool NeedFeedback (
            IN LONG  lFbMsg
            )const
    {
        return ( (lFbMsg & SSR_FB_ALL_MASK)  && (m_srpFeedback != NULL) );
    }

    HRESULT GetLogString (
            IN  ULONG       uCauseResID,
            IN  LPCWSTR     pwszText,
            IN  LPCWSTR     pwszObjDetail,
            IN  LONG        lSsrFbMsg, 
            OUT BSTR      * pbstrLogStr
            )const;


    HRESULT 
    GetLogString (
            IN  ULONG       uCauseResID,
            IN  DWORD       dwErrorCode,
            IN  LPCWSTR     pwszObjDetail,
            IN  LONG        lSsrFbMsg, 
            OUT BSTR      * pbstrLogStr
            )const;

    CComObject<CSsrLog> * m_pLog;
    CComPtr<ISsrFeedbackSink> m_srpFeedback;

    DWORD m_dwRemainSteps;

    bool m_bVerbose;

    CComBSTR m_bstrVerboseHeading;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__02A1E618_85DA_4977_8F12_DDC93E114783__INCLUDED_)
#define AFX_STDAFX_H__02A1E618_85DA_4977_8F12_DDC93E114783__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#define UNICODE

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__02A1E618_85DA_4977_8F12_DDC93E114783__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\util.h ===
//
// util.h, some common utility classes
//

#include "SSRTE.h"

#pragma once

class CSafeArray
{

public:

    CSafeArray( IN VARIANT * pVal);

    ULONG GetSize()
    {
        return m_ulSize;
    }

    HRESULT GetElement (
                IN REFIID       guid, 
                IN  ULONG       ulIndex,
                OUT IUnknown ** ppUnk
                );


    HRESULT GetElement (
                IN  ULONG     ulIndex,
                IN  VARTYPE   vt,
                OUT VARIANT * pulVal
                );


    HRESULT GetElement (
                IN  ULONG     ulIndex,
                OUT VARIANT * pulVal
                );

    //
    // we don't want anyone (include self) to be able to do an assignment
    // or invoking copy constructor.
    //

    CSafeArray (const CSafeArray& );
    void operator = (const CSafeArray& );

private:
    
    SAFEARRAY * m_pSA;

    VARIANT * m_pVal;

    ULONG m_ulSize;

    bool m_bValidArray;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ssr\te\util.cpp ===
//
// util.cpp, implementation for various utility classes
//

#include "global.h"
#include "util.h"

extern LPCWSTR g_pwszSsrRootPath;
extern const DWORD g_dwSsrRootPathLen;


/*
Routine Description: 

Name:

    CSafeArray::CSafeArray

Functionality:
    
    Constructor. Will prepare our private data for a safearray variant.
    In case the in parameter is not a safearray, then we will behave as
    it is a one element array.

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    none.

Notes:
    

*/

CSafeArray::CSafeArray (
    IN VARIANT * pVal
    ) : m_pSA(NULL), 
        m_pVal(NULL), 
        m_ulSize(0),
        m_bValidArray(true)
{
    if (pVal->vt & VT_ARRAY)
    {
        m_pSA = pVal->parray;

        if ( pVal->vt & VT_BYREF )
        {
            m_pSA = *(pVal->pparray);
        }

        LONG lb = 0;
        LONG ub = 0;
        ::SafeArrayGetLBound(m_pSA, 1, &lb);
        ::SafeArrayGetUBound(m_pSA, 1, &ub);

        m_ulSize = ub - lb + 1;

        //
        // we won't support it as an array, instead, we treat it as
        // a normal VARIANT
        //

        if (m_pSA->cDims > 2)
        {
            m_ulSize = 1;
            m_pVal = pVal;
            m_bValidArray = false;
            m_pSA = NULL;
        }
    }
    else
    {
        m_ulSize = 1;
        m_pVal = pVal;
        m_bValidArray = false;
    }
}





/*
Routine Description: 

Name:

    CSafeArray::GetElement

Functionality:
    
    Get the ulIndex-th element as the given (guid) interface object.

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    Success:
        
        S_OK
    
    Failure:
    
        various error codes.

Notes:
    

*/

HRESULT 
CSafeArray::GetElement (
    IN  REFIID      guid, 
    IN  ULONG       ulIndex, 
    OUT IUnknown ** ppUnk
    )
{
    //
    // The following default return value is not really good for invalid
    // array var given to this object.
    //


    if (ppUnk == NULL || ulIndex >= m_ulSize)
    {
        return E_INVALIDARG;
    }
    else if (!m_bValidArray)
    {
        //
        // if the given variant is not an array, then
        // we will use the value to handle the request
        //

        if (ulIndex == 0 && m_pVal != NULL)
        {
            if (m_pVal->vt == VT_UNKNOWN)
            {
                return m_pVal->punkVal->QueryInterface(guid, (LPVOID*)ppUnk);
            }
            else if (m_pVal->vt == VT_DISPATCH)
            {
                return m_pVal->pdispVal->QueryInterface(guid, (LPVOID*)ppUnk);
            }
            else
            {
                return E_SSR_VARIANT_NOT_CONTAIN_OBJECT;
            }
        }
        else if (ulIndex >= 1)
        {
            return E_SSR_ARRAY_INDEX_OUT_OF_RANGE;
        }
        else
        {
            return E_SSR_NO_VALID_ELEMENT;
        }
    }

    HRESULT hr = E_INVALIDARG;
    *ppUnk = NULL;

    VARIANT v;
    ::VariantInit(&v);

    long index[1] = {ulIndex};

    hr = ::SafeArrayGetElement(m_pSA, index, &v);

    if (SUCCEEDED(hr) && v.vt == VT_UNKNOWN)
    {
        hr = v.punkVal->QueryInterface(guid, (LPVOID*)ppUnk);
        if (S_OK != hr)
        {
            hr = E_NOINTERFACE;
        }
    }
    else if (SUCCEEDED(hr) && v.vt == VT_DISPATCH)
    {
        hr = v.pdispVal->QueryInterface(guid, (LPVOID*)ppUnk);
        if (S_OK != hr)
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    ::VariantClear(&v);

    return hr;
}




/*
Routine Description: 

Name:

    CSafeArray::GetElement

Functionality:
    
    Get the ulIndex-th element as the given type (non-interface).

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    Success:
        
        S_OK
    
    Failure:
    
        various error codes.

Notes:
    

*/

HRESULT 
CSafeArray::GetElement (
    IN  ULONG     ulIndex,
    IN  VARTYPE   vt,
    OUT VARIANT * pVal
    )
{
    HRESULT hr = GetElement(ulIndex, pVal);

    //
    // if the types do not match, then we need to coerce it
    //

    if (SUCCEEDED(hr) && pVal->vt != vt)
    {
        VARIANT v;
        hr = ::VariantCopy(&v, pVal);

        ::VariantClear(pVal);

        if (SUCCEEDED(hr))
        {
            hr = ::VariantChangeType(pVal, &v, VARIANT_NOVALUEPROP, vt);
        }

        ::VariantClear(&v);
    }

    return hr;
}




/*
Routine Description: 

Name:

    CSafeArray::GetElement

Functionality:
    
    Get the ulIndex-th element as a variant.

Virtual:
    
    no.
    
Arguments:

    none.

Return Value:

    Success:
        
        S_OK
    
    Failure:
    
        various error codes.

Notes:
    

*/

HRESULT 
CSafeArray::GetElement (
    IN  ULONG   ulIndex,
    OUT VARIANT * pVal
    )
{
    if (pVal == NULL || ulIndex >= m_ulSize)
    {
        return E_INVALIDARG;
    }

    ::VariantInit(pVal);

    if (!m_bValidArray)
    {
        if (ulIndex == 0 && m_pVal != NULL)
        {
            return ::VariantCopy(pVal, m_pVal);
        }
        else if (ulIndex >= 1)
        {
            return E_SSR_ARRAY_INDEX_OUT_OF_RANGE;
        }
        else
        {
            return E_SSR_NO_VALID_ELEMENT;
        }

    }

    HRESULT hr = E_INVALIDARG;

    LONG index[2] = {ulIndex, 0};

    if (m_pSA->cDims > 1)
    {
        //
        // we must be dealing with 2-dimensional arrays because we don't
        // support more than that
        //

        LONG ilb = m_pSA->rgsabound[1].lLbound;
        LONG iSize = m_pSA->rgsabound[1].cElements;

        VARIANT * pvarValues = new VARIANT[iSize];

        if (pvarValues != NULL)
        {
            //
            // null all the contents
            //

            ::memset(pvarValues, 0, sizeof(VARIANT) * iSize);

            for (LONG i = ilb; i < ilb + iSize; i++)
            {
                //
                // Gett every element in the second dimension, so the index[1]
                //

                index[1] = i;
                hr = ::SafeArrayGetElement(m_pSA, index, &(pvarValues[i - ilb]));
                if (FAILED(hr))
                {
                    break;
                }
            }

            if (SUCCEEDED(hr))
            {
                SAFEARRAYBOUND rgsabound[1];
                rgsabound[0].lLbound = 0;
                rgsabound[0].cElements = iSize;

                SAFEARRAY * psa = ::SafeArrayCreate(VT_VARIANT , 1, rgsabound);
                if (psa == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    //
                    // put every element in the second dimension into the new safearray
                    // BTW, this is a single dimension new safearray, so the index[0]
                    //

                    for (i = 0; i < iSize; i++)
                    {        
                        index[0] = i;
                        hr = ::SafeArrayPutElement(psa, index, &(pvarValues[i]));

                        if (FAILED(hr))
                        {
                            break;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        pVal->vt = VT_ARRAY | VT_VARIANT;
                        pVal->parray = psa;
                    }
                    else
                    {
                        ::SafeArrayDestroy(psa);
                    }
                }
            }

            //
            // now clean it up
            //

            for (i = 0; i < iSize; i++)
            {
                ::VariantClear(&(pvarValues[i]));
            }

            delete [] pvarValues;
        }
    }
    else
    {
        hr = ::SafeArrayGetElement(m_pSA, index, pVal);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\autologon.c ===
/*++

   Copyright (c) 2000  Microsoft Corporation

   Module Name:

       autologon.c

   Abstract:

		This is a command-line utility munges that settings related to the 
        Windows NT/2000 Autologon functionality

		if PRIVATE_VERSION is defined, password info will be displayed on the output
		For general distribution, this should not be defined

   Author:
        Jason Garms (jasong)             12 October 2000

   History:
        Cristian Ilac (crisilac)         11 November 2001   Made spec changes
        Jason Garms (jasong)             12 October 2000    Created
--*/

#include "common.h"
#include <wincred.h>

//+----------------------------------------------------------------------------
//
// Prototypes
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Command functions
//
//+----------------------------------------------------------------------------
typedef DWORD (*CommandFn)();

DWORD
DumpCmd();

DWORD
MigratePassword();

DWORD
Delete();

DWORD
EnableAutoLogon();

#ifdef PRIVATE_VERSION
DWORD
DumpAutoLogonInfo();
#endif

//+----------------------------------------------------------------------------
//
// Data/Options set functions
//
//+----------------------------------------------------------------------------
DWORD
SetCommand(
    UINT uCommand);

DWORD
SetQuietMode(
    WCHAR* pszData);

DWORD
SetUserName(
    WCHAR* pszData);

DWORD
SetCount(
    WCHAR* pszData);

#ifdef PRIVATE_VERSION
DWORD
SetMachineName(
    WCHAR* pszData);

#endif

//+----------------------------------------------------------------------------
//
// Other functions
//
//+----------------------------------------------------------------------------
DWORD
CheckWinVersion();

DWORD
GetPassword();

//+----------------------------------------------------------------------------
//
// Global command table
//
//+----------------------------------------------------------------------------
#define COMMAND_HELP            0
#define COMMAND_MIGRATE         1
#define COMMAND_LSA_DELETE      2
#define COMMAND_LSA_ENABLE      3

#ifdef PRIVATE_VERSION
#define COMMAND_DUMP            4
#define COMMAND_NOT_SET         5
#else
#define COMMAND_NOT_SET         4
#endif

#define COMMAND_SIZE            COMMAND_NOT_SET

CommandFn   g_Commands[COMMAND_SIZE] = {
    DumpCmd,
    MigratePassword,
    Delete,
    EnableAutoLogon,
#ifdef PRIVATE_VERSION
    DumpAutoLogonInfo
#endif
    };

//+----------------------------------------------------------------------------//
//
// Global data
//
//+----------------------------------------------------------------------------
WCHAR  g_UserName[MAX_STRING] = {0};

WCHAR  g_DomainName[MAX_STRING] = {0};

WCHAR  g_Password[MAX_STRING] = {0};

DWORD  g_AutoLogonCount = 0;

WCHAR  g_TempString[MAX_STRING] = {0};
WCHAR  g_ErrorString[MAX_STRING] = {0};
WCHAR  g_FailureLocation[MAX_STRING] = {0};

BOOL   g_QuietMode = FALSE;
BOOL   g_FullHelp = FALSE;

BOOL   g_SetDefaultPIN = FALSE;

UINT   g_uCommand = COMMAND_NOT_SET;

#ifdef PRIVATE_VERSION
BOOL   g_RemoteOperation = FALSE;
WCHAR  g_RemoteComputerName[MAX_STRING] = {0};
#endif

// various strings
WCHAR  g_PasswordSecretName[]   = L"DefaultPassword";
WCHAR  g_PinSecretName[]        = L"DefaultPIN";
WCHAR  g_AutoAdminLogonName[]   = L"AutoAdminLogon";
WCHAR  g_DefaultUserName[]      = L"DefaultUserName";
WCHAR  g_DefaultDomainName[]    = L"DefaultDomainName";
WCHAR  g_AutoLogonCountName[]   = L"AutoLogonCount";

//+----------------------------------------------------------------------------
//
// Functions
//
//+----------------------------------------------------------------------------


int 
__cdecl 
wmain(
    int argc,
    WCHAR *argv[]
)
{
    UINT uCommandPosition = 0;

    DWORD dwRetCode = ERROR_SUCCESS;

    //
    // loop through all command line arguments and check for known ones
    //  - if one argument is identified continue the loop
    //  - if unknown arguments are passed break the loop and fail
    //
    while( ++uCommandPosition < (UINT)argc )
    {
        if( !_wcsicmp(argv[uCommandPosition], L"/?") )
        {
            g_FullHelp = TRUE;
            dwRetCode = SetCommand(COMMAND_HELP);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsicmp(argv[uCommandPosition], L"/Q") ||
            !_wcsicmp(argv[uCommandPosition], L"/Quiet")
            )
        {
            dwRetCode = SetQuietMode(argv[uCommandPosition]);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsicmp(argv[uCommandPosition], L"/M") ||
            !_wcsicmp(argv[uCommandPosition], L"/Migrate") )
        {
            dwRetCode = SetCommand(COMMAND_MIGRATE);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsicmp(argv[uCommandPosition], L"/D") ||
            !_wcsicmp(argv[uCommandPosition], L"/Delete") )
        {
            dwRetCode = SetCommand(COMMAND_LSA_DELETE);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsicmp(argv[uCommandPosition], L"/S") ||
            !_wcsicmp(argv[uCommandPosition], L"/Set") )
        {
            dwRetCode = SetCommand(COMMAND_LSA_ENABLE);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsnicmp(argv[uCommandPosition], L"/U:", wcslen(L"/U:")) ||
            !_wcsicmp(argv[uCommandPosition], L"/U") ||
            !_wcsnicmp(argv[uCommandPosition], L"/UserName:", wcslen(L"/UserName:")) ||
            !_wcsicmp(argv[uCommandPosition], L"/Username") )
        {
            dwRetCode = SetUserName(argv[uCommandPosition]);
            if( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                //
                // it may be because there was a column followed by spaces
                // Try to recover
                //
                if( uCommandPosition + 1 < (UINT)argc )
                {
                    //
                    // only if not another parameter
                    //
                    if( argv[uCommandPosition + 1][0] != '/' )
                    {
                        dwRetCode = SetUserName(argv[++uCommandPosition]);
                    }
                    else
                    {
                        DisplayMessage(L"Command line: Missing Username.\n");
                    }
                }
            }

            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsnicmp(argv[uCommandPosition], L"/C:", wcslen(L"/C:")) ||
            !_wcsicmp(argv[uCommandPosition], L"/C") ||
            !_wcsnicmp(argv[uCommandPosition], L"/Count:", wcslen(L"/Count:")) ||
            !_wcsicmp(argv[uCommandPosition], L"/Count") )
        {
            dwRetCode = SetCount(argv[uCommandPosition]);
            if( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                //
                // it may be because there was no column or a column
                // followed by spaces. Try to recover by moving on.
                //
                if( uCommandPosition + 1 < (UINT)argc )
                {
                    //
                    // only if not another parameter
                    //
                    if( argv[uCommandPosition + 1][0] != '/' )
                    {
                        dwRetCode = SetCount(argv[++uCommandPosition]);
                    }
                    else
                    {
                        DisplayMessage(L"Command line: Missing count.\n");
                    }
                }
            }
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsicmp(argv[uCommandPosition], L"/P") ||
            !_wcsicmp(argv[uCommandPosition], L"/Pin") )
        {
            g_SetDefaultPIN = TRUE;
            dwRetCode = SetCommand(COMMAND_LSA_ENABLE);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

#ifdef PRIVATE_VERSION
        if( !_wcsnicmp(argv[uCommandPosition], L"/T:", wcslen(L"/T:")) ||
            !_wcsicmp(argv[uCommandPosition], L"/T") ||
            !_wcsnicmp(argv[uCommandPosition], L"/Target:", wcslen(L"/Target:")) ||
            !_wcsicmp(argv[uCommandPosition], L"/Target") )
        {
            dwRetCode = SetMachineName(argv[uCommandPosition]);
            if( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                //
                // it may be because there was no column or a column
                // followed by spaces. Try to recover by moving on.
                //
                if( uCommandPosition + 1 < (UINT)argc )
                {
                    //
                    // only if not another parameter
                    //
                    if( argv[uCommandPosition + 1][0] != '/' )
                    {
                        dwRetCode = SetMachineName(argv[++uCommandPosition]);
                    }
                    else
                    {
                        DisplayMessage(L"Command line: Missing machine name.\n");
                    }
                }
            }
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }

        if( !_wcsicmp(argv[uCommandPosition], L"/L") ||
            !_wcsicmp(argv[uCommandPosition], L"/List") )
        {
            dwRetCode = SetCommand(COMMAND_DUMP);
            if( ERROR_SUCCESS == dwRetCode )
            {
                continue;
            }
            else
            {
                break;
            }
        }
#endif
        //
        // unknown argument, set the help as command and break
        // we have to use this parameter as the command might
        // have already been set
        //
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Invalid command: %s\n",
                   argv[uCommandPosition]);
        DisplayMessage(g_TempString);

        SetCommand(COMMAND_NOT_SET);
        break;
    }

	//
	// Display usage if no command switch is present
	//
	if( ERROR_SUCCESS != dwRetCode )
    {
        DumpCmd();
    }
    else
    {
        if( COMMAND_NOT_SET == g_uCommand ) {
            SetCommand(COMMAND_HELP);
	    }

        dwRetCode = g_Commands[g_uCommand]();

        //
        // bad arguments passed to the command, display help
        //
        if( ERROR_BAD_ARGUMENTS == dwRetCode )
        {
            DumpCmd();
        }
    }
    
    return dwRetCode;
}


//+----------------------------------------------------------------------------
//
// MigratePassword
//
//  - reads the registry password, deletes it and sets the LSA secret
//  - works only on certain win versions
//  - if no password present fails
//  - if any ops fail does not roll back
//      - if pwd read fails - nothing happens
//      - if LSA secret set fails - pretty much nothing happens as well.
//      - if RegDelete fails - there is no need to delete the LSA secret...
//
//+----------------------------------------------------------------------------
DWORD
MigratePassword() 
{
    WCHAR Password[MAX_STRING];
    DWORD dwRetCode = ERROR_SUCCESS;
    BOOL fMigratedPIN = FALSE;

    if( ERROR_SUCCESS != CheckWinVersion() ) {
        dwRetCode = ERROR_OLD_WIN_VERSION;
        goto cleanup;
    }

    //
    // get the DefaultPIN registry key from the local
    // or remote system and store it in a local string
    // As this is not something we document we do not display any errors
    // We also do not display any success messages. The only case where 
    // we have to display smth PIN related is when we can migrate the PIN
    // but there is no password. We can't fail and we have to display something.
    //
    dwRetCode = GetRegValueSZ(g_PinSecretName, Password, MAX_STRING - 1);
    if( ERROR_SUCCESS != dwRetCode )
    {
        //
        // we won't migrate the PIN and silently move on
        // this is something we do not document for the tool
        //
#ifdef PRIVATE_VERSION
        if( ERROR_FILE_NOT_FOUND != dwRetCode )
        {
            DisplayMessage(L"Migrate: DefaultPIN key cannot be read.\n");
        }
#endif
        dwRetCode = ERROR_SUCCESS;
        goto MigratePassword;
    }

    //
    // Set the DefaultPassword LSASecret to the value we retrieved
    // from the registry
    //
    dwRetCode = SetSecret(Password, FALSE, g_PinSecretName);
    if( ERROR_SUCCESS != dwRetCode )
    {
#ifdef PRIVATE_VERSION
        _snwprintf(g_TempString, MAX_STRING - 1,
               L"Migrate: Could not set DefaultPIN LSASecret: %s\n",
               GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
#endif
        dwRetCode = ERROR_SUCCESS;
        goto MigratePassword;
    }

    // Delete the DefaultPassword registry key
    dwRetCode = ClearRegValue(g_PinSecretName);
    if( ERROR_SUCCESS != dwRetCode )
    {
        //
        // delete the secret if could not remove the password.
        //
        (void)SetSecret(NULL, TRUE, g_PinSecretName);

#ifdef PRIVATE_VERSION
        _snwprintf(g_TempString, MAX_STRING - 1,
               L"Migrate: Could not delete DefaultPIN key: %s\n",
               GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
#endif

        dwRetCode = ERROR_SUCCESS;
        goto MigratePassword;
    }

#ifdef PRIVATE_VERSION
    DisplayMessage(L"Pin migrated from Registry to LSASecret\n");
#endif
    fMigratedPIN = TRUE;

MigratePassword:
    
    // Get the DefaultPassword registry key from the local
    // or remote system and store it in a local string
    dwRetCode = GetRegValueSZ(g_PasswordSecretName, Password, MAX_STRING - 1);
    if( ERROR_FILE_NOT_FOUND == dwRetCode )
    {
        if( fMigratedPIN )
        {
            DisplayMessage(L"Migrate: Migrated PIN, DefaultPassword does not exist.\n");
            dwRetCode = ERROR_SUCCESS;
        }
        else
        {
            DisplayMessage(L"Migrate failed: DefaultPassword does not exist.\n");
        }
        goto cleanup;
    }

    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
               L"Migrate failed: Could not read DefaultPassword: %s\n",
               GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    //
    // Set the DefaultPassword LSASecret to the value we retrieved
    // from the registry
    //
    dwRetCode = SetSecret(Password, FALSE, g_PasswordSecretName);
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
               L"Migrate failed: Could not set DefaultPassword LSASecret: %s\n",
               GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    // Delete the DefaultPassword registry key
    dwRetCode = ClearRegValue(g_PasswordSecretName);
    if( ERROR_SUCCESS != dwRetCode )
    {
        //
        // delete the secret if could not remove the password.
        //
        (void)SetSecret(NULL, TRUE, g_PasswordSecretName);

        _snwprintf(g_TempString, MAX_STRING - 1,
               L"Migrate Failed: Could not delete DefaultPassword key: %s\n",
               GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    DisplayMessage(L"Password migrated from Registry to LSASecret\n");

cleanup:
    // zero out the password so it's not left in memory
    SecureZeroMemory(Password, MAX_STRING * sizeof(WCHAR));
    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// Delete
//
//  - Deletes the secret and the autoadmin logon value
//  - Silently ignores the file not found cases
//
//+----------------------------------------------------------------------------
DWORD
Delete()
{
    DWORD dwRetCode = ERROR_SUCCESS;

    //
    // make sure we're running against a correct version of NT
    //
    if (CheckWinVersion() != ERROR_SUCCESS) {
        dwRetCode = ERROR_OLD_WIN_VERSION;
        goto cleanup;
    }

    dwRetCode = ClearRegValue(g_PasswordSecretName);

    if( (ERROR_SUCCESS != dwRetCode) && 
        (ERROR_FILE_NOT_FOUND != dwRetCode) )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Delete: Registry default password delete failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    dwRetCode = SetSecret(NULL, TRUE, g_PasswordSecretName);
    if( (ERROR_SUCCESS != dwRetCode)  && 
        (ERROR_FILE_NOT_FOUND != dwRetCode) )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Delete: LSA Secret delete failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    dwRetCode = ClearRegValue(g_PinSecretName);
    if( (ERROR_SUCCESS != dwRetCode) && 
        (ERROR_FILE_NOT_FOUND != dwRetCode) )
    {
#ifdef PRIVATE_VERSION
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Delete: Registry default pin delete failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
#endif
    }

    dwRetCode = SetSecret(NULL, TRUE, g_PinSecretName);
    if( (ERROR_SUCCESS != dwRetCode)  && 
        (ERROR_FILE_NOT_FOUND != dwRetCode) )
    {
#ifdef PRIVATE_VERSION
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Delete: LSA Secret(PIN) delete failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
#endif
    }

    //
    // disable the autologon - if it fails don't recover - the autologon
    // will pretty much fail anyway
    //
    dwRetCode = SetRegValueSZ(g_AutoAdminLogonName, L"0");
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Delete: AutoAdminLogon reg value reset failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    dwRetCode = ClearRegValue(g_AutoLogonCountName);
    if( (ERROR_SUCCESS != dwRetCode)  && 
        (ERROR_FILE_NOT_FOUND != dwRetCode) )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"AutoLogonCount    : Set Failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    dwRetCode = ERROR_SUCCESS;
    DisplayMessage(L"AutoAdminLogon disabled.\n");

cleanup:
    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// EnableAutoLogon
//
//  - gets the username/pwd
//  - sets the username/domain
//  - sets the autlogon count if specified and != 0
//  - sets the LSA secret
//  - sets the autoadminlogon
//  - if autoadminlogon fails then tries to delete the LSA secret
//
//+----------------------------------------------------------------------------
DWORD
EnableAutoLogon()
{
    DWORD dwRetCode = ERROR_SUCCESS;
    WCHAR* pBackSlash = NULL;
    WCHAR* pAtSign = NULL;

    //
    // make sure we're running against a correct version of NT
    //
    if (CheckWinVersion() != ERROR_SUCCESS) {
        dwRetCode = ERROR_OLD_WIN_VERSION;
        goto cleanup;
    }

    //
    // fill in the user name: try both NameUserPrincipal and NameSamCompatible
    //
    if( !*g_UserName )
    {
        ULONG uSize = MAX_STRING - 1;
        if( !GetUserNameEx(NameUserPrincipal,
                           g_UserName,
                           &uSize) )
        {
            uSize = MAX_STRING - 1;
            if( !GetUserNameEx(NameSamCompatible,
                               g_UserName,
                               &uSize) )
            {
                dwRetCode = GetLastError();
                _snwprintf(g_TempString, MAX_STRING - 1,
                           L"Set: Could not get the logged on user name: %s\n",
                           GetErrorString(dwRetCode));
                DisplayMessage(g_TempString);
                goto cleanup;
            }
        }
    }

    //
    // Make sure we have correct information passed in
    //
    if( !g_SetDefaultPIN && !*g_UserName )
    {
        DisplayMessage(L"Set: Failed: Username does not exist.\n");
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    //
    // this call uses CredMan on XP
    //
    dwRetCode = GetPassword();
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Set: Failed to get the password: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    if( !g_SetDefaultPIN )
    {
        //
        // if a domain specified in the form of domain\username extract it
        // Proper formats are
        // Case 1: /username:JohnDoe
        // Case 2: /username: JohnDoe@domain.microsoft.com
        // Case 3: /username:Domain\JohnDoe
        //

        //
        // is '\' present?
        //
        pBackSlash = wcschr(g_UserName, '\\');
        if( NULL != pBackSlash )
        {
            //
            // Case 3, copy into both user and domain buffer
            // Domain is first as we don't want to overwrite the buffer
            // Yes, wcsncpy works from beggining to the end ;-)
            //
            wcsncpy(g_DomainName, g_UserName,
                    __min(MAX_STRING - 1, (pBackSlash - g_UserName)) );
            g_DomainName[MAX_STRING - 1] = 0;

            wcsncpy(g_UserName, pBackSlash + 1, MAX_STRING - 1);
            g_UserName[MAX_STRING - 1] = 0;
        }
        else
        {
            //
            // if we have @ in the user name delete the domain
            //
            pAtSign = wcschr(g_UserName, '@');
            g_DomainName[0] = 0;
        }
    }

    //
    // Deletes the reg password value
    //
    if( g_SetDefaultPIN )
    {
        dwRetCode = ClearRegValue(g_PinSecretName);
    }
    else
    {
        dwRetCode = ClearRegValue(g_PasswordSecretName);
    }

    if( (ERROR_SUCCESS != dwRetCode) &&
        (ERROR_FILE_NOT_FOUND != dwRetCode) )
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"RegPassword   : Reset Failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    if( !g_SetDefaultPIN )
    {
        //
        // sets the username
        //
        dwRetCode = SetRegValueSZ(g_DefaultUserName, g_UserName);
        if( ERROR_SUCCESS != dwRetCode )
        {
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"UserName   : Set Failed: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
        }

        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"UserName          : %s\n",
                   g_UserName);
        DisplayMessage(g_TempString);
    }

    if( !g_SetDefaultPIN )
    {
        //
        // sets the domain, if any or pAtSign is not NULL
        //
        if( *g_DomainName || pAtSign )
        {
            SetRegValueSZ(g_DefaultDomainName, g_DomainName);
            if( ERROR_SUCCESS != dwRetCode )
            {
                _snwprintf(g_TempString, MAX_STRING - 1,
                           L"DomainName : Set Failed: %s\n",
                           GetErrorString(dwRetCode));
                DisplayMessage(g_TempString);
                goto cleanup;
            }
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DomainName        : %s\n",
                       g_DomainName);
            DisplayMessage(g_TempString);
        }
    }

    //
    // set the AutoLogonCount if not 0
    //
    if( g_AutoLogonCount )
    {
        dwRetCode = SetRegValueDWORD(g_AutoLogonCountName, g_AutoLogonCount);

        if( ERROR_SUCCESS != dwRetCode )
        {
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoLogonCount    : Set Failed: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
        }
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"AutoLogonCount    : %#x\n",
                   g_AutoLogonCount);
        DisplayMessage(g_TempString);
    }
    else
    {
        dwRetCode = ClearRegValue(g_AutoLogonCountName);

        if( (ERROR_SUCCESS != dwRetCode) && 
            (ERROR_FILE_NOT_FOUND != dwRetCode) )
        {
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoLogonCount    : Clear Failed: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
        }
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"AutoLogonCount    : (Disabled)\n");
        DisplayMessage(g_TempString);
    }

    //
    // set the password
    //
    if( g_SetDefaultPIN )
    {
        dwRetCode = SetSecret(g_Password, FALSE, g_PinSecretName);
    }
    else
    {
        dwRetCode = SetSecret(g_Password, FALSE, g_PasswordSecretName);
    }

    if( ERROR_SUCCESS != dwRetCode)
    {
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"LSASecret         : Set Failed: %s\n",
                   GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

#ifdef PRIVATE_VERSION
    _snwprintf(g_TempString, MAX_STRING - 1,
               L"LSASecret         : %s\n",
               g_Password);
#else
    _snwprintf(g_TempString, MAX_STRING - 1,
               L"LSASecret         : (set)\n");
#endif
    DisplayMessage(g_TempString);

    if( !g_SetDefaultPIN )
    {
        //
        // set the AutoAdminLogon regvalue to 1
        //
        dwRetCode = SetRegValueSZ(g_AutoAdminLogonName, L"1");
        if( ERROR_SUCCESS != dwRetCode )
        {
            //
            // (try to) clear the secret if this fails
            //
            (void)SetSecret(NULL, TRUE, g_PasswordSecretName);

            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoAdminLogon: Set Failed: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
        }

        DisplayMessage(L"AutoAdminLogon    : 1\n");
    }

cleanup:
    SecureZeroMemory(g_Password, MAX_STRING * sizeof(WCHAR));
    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// DumpCmd
//
//  - Help
//
//+----------------------------------------------------------------------------
DWORD
DumpCmd()
{
    if (g_QuietMode)
    {
        return ERROR_SUCCESS;
    }

    wprintf(L"\nAUTOLOGON v1.00 : (c) 2001, Microsoft Corporation\n\n");
    wprintf(L"DESCRIPTION:\n");
    wprintf(L"   Used to configure encrypted autologon functionality\n\n");
    wprintf(L"USAGE:\n");
    wprintf(L"   AUTOLOGON [/?] [/Quiet] [/Migrate] [/Delete] [/Set]\n");
    wprintf(L"             [/Username:username] [/Count:count]\n");
    wprintf(L"    Options:\n");
    wprintf(L"      /?         Display complete help documentation\n");
    wprintf(L"      /Quiet     Enable quiet mode, which supresses all output\n");
    wprintf(L"      /Migrate   Migrate cleartext password from registry to LSASecret\n");
    wprintf(L"      /Delete    Deletes the default password and disable AutoAdminLogon \n");
    wprintf(L"      /Set       Set the DefaultPassword LSASecret and enable AutoAdminLogon\n");
    wprintf(L"      /Username  The username to set in Default UserName.\n");
    wprintf(L"      /Count     Set the logoncount\n");
#ifdef PRIVATE_VERSION
    wprintf(L"      /Pin       Set the DefaultPin LSASecret\n");
    wprintf(L"      /List      List autologon settings\n");
    wprintf(L"      /Target    The remote computer name\n");
#endif

    if( g_FullHelp )
    {
        wprintf(L"\nNOTES:\n");
        wprintf(L"    1.The /Migrate /Delete /Set commands are exclusive.\n");
        wprintf(L"      You will always be prompted for a password.\n");
        wprintf(L"      If a username is not specified the currently logged on user is assumed.\n");
        wprintf(L"      If no count is specified a count of 0 is implicitely assumed.\n\n");
        wprintf(L"    2.You need to be running as a member of the local administrators group for\n");
        wprintf(L"      this utility to work properly.\n\n");
        wprintf(L"    3.When setting a password that has special characters in it, such as \"|>&\n");
        wprintf(L"      make sure that you escape these characters. Also, passwords with spaces \n");
        wprintf(L"      should be enclosed in double quotes.\n\n");
        wprintf(L"    4.Setting the logoncount to 0 means an autologon will be performed until\n");
        wprintf(L"      the secret is deleted.\n\n");
    }
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// DumpAutoLogonInfo
//
//  - Dumps relevant data
//
//+----------------------------------------------------------------------------
#ifdef PRIVATE_VERSION
DWORD
DumpAutoLogonInfo()
{
    WCHAR wcsTempString[MAX_STRING];
    DWORD dwRetCode = ERROR_SUCCESS;

    //
    // make sure we're running against a correct version of NT
    //
    if (CheckWinVersion() != ERROR_SUCCESS) {
        dwRetCode = ERROR_OLD_WIN_VERSION;
        goto cleanup;
    }

    //
    // Get the username
    //
    dwRetCode = GetRegValueSZ(g_DefaultUserName, wcsTempString, MAX_STRING - 1);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultUserName  : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultUserName  : %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultUserName  : Failed to query regkey: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the DefaultDomainName
    //
    dwRetCode = GetRegValueSZ(g_DefaultDomainName, wcsTempString, MAX_STRING - 1);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultDomainName: (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultDomainName: %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultDomainName: Failed to query regkey: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the DefaultPassword
    //
    dwRetCode = GetRegValueSZ(g_PasswordSecretName,
                              wcsTempString, MAX_STRING - 1);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultPassword  : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultPassword  : %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultPassword  : Failed to query regkey: %s\n",
                       GetErrorString(dwRetCode));
            goto cleanup;
    }

    //
    // Get the DefaultPin - display it only if there
    //
    dwRetCode = GetRegValueSZ(g_PinSecretName,
                              wcsTempString, MAX_STRING - 1);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"DefaultPIN       : %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and continue
        default:
            break;
    }

    //
    // Get the AutoAdminLogonCount
    //
    dwRetCode = GetRegValueDWORD(g_AutoLogonCountName, &g_AutoLogonCount);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoLogonCount   : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoLogonCount   : %#x\n",
                       g_AutoLogonCount);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoLogonCount   : Failed to query regkey: %s\n",
                       GetErrorString(dwRetCode));
            goto cleanup;
    }

    //
    // Get the LSASecret DefaultPassword
    //
    dwRetCode = GetSecret(wcsTempString, MAX_STRING - 1, g_PasswordSecretName);
    switch (dwRetCode) {
        // catch this case and continue
        case STATUS_OBJECT_NAME_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret        : (secret does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // catch this case and continue
        case ERROR_ACCESS_DENIED:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret        : (access denied)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret        : %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret        : Failed to query LSASecret: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the LSASecret DefaultPin
    //
    dwRetCode = GetSecret(wcsTempString, MAX_STRING - 1, g_PinSecretName);
    switch (dwRetCode) {
        // catch this case and continue
        case STATUS_OBJECT_NAME_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret(PIN)   : (secret does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // catch this case and continue
        case ERROR_ACCESS_DENIED:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret(PIN)   : (access denied)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret(PIN)   : %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"LSASecret(PIN)   : Failed to query LSASecret: %s\n",
                       GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the AutoAdminLogon
    //
    dwRetCode = GetRegValueSZ(g_AutoAdminLogonName, wcsTempString, MAX_STRING - 1);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoAdminLogon   : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoAdminLogon   : %s\n",
                       wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end
        default:
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"AutoAdminLogon   : Failed to query regkey: %s\n",
                       GetErrorString(dwRetCode));
            goto cleanup;
    }

cleanup:
    SecureZeroMemory(g_TempString, MAX_STRING * sizeof(WCHAR));
    SecureZeroMemory(wcsTempString, MAX_STRING * sizeof(WCHAR));
    return dwRetCode;

}
#endif


//+----------------------------------------------------------------------------
//
// SetCommand
//
//  - Sets the command
//  - if there are two successive calls to this it will fail - as in two
//    commands passed in the command line 
//  - a call greater with  than COMMAND line resets the command to COMMAND_HELP
//
//+----------------------------------------------------------------------------
DWORD
SetCommand(UINT uCommand)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    if( COMMAND_NOT_SET == uCommand )
    {
        g_uCommand = COMMAND_NOT_SET;
        goto cleanup;
    }

    //
    // if already set, fail
    //
    if( COMMAND_NOT_SET != g_uCommand ) 
    {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    if( g_uCommand > COMMAND_SIZE )
    {
        //
        // assert?
        //
        g_uCommand = COMMAND_HELP;
    }
    else
    {
        g_uCommand = uCommand;
    }

cleanup:
    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// SetQuietMode
//
//+----------------------------------------------------------------------------
DWORD
SetQuietMode(WCHAR* pszData)
{
    UNREFERENCED_PARAMETER(pszData);

    g_QuietMode = TRUE;
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// SetUserName
//
//  - Sets the username
//  - Proper formats are combinations of
//      /username:"user name"
//      /username username
//      /username: " user name"
//
//  - returns ERROR_FILE_NOT_FOUND when the arg is missing so the caller can
//    move on to the next parameter
//+----------------------------------------------------------------------------
DWORD
SetUserName(WCHAR* pszData)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    WCHAR* pCh = NULL;

    //
    // is ":" present?
    //
    pCh = wcschr(pszData, ':');
    if( NULL == pCh )
    {
        pCh = pszData;
    }
    else
    {
        pCh++;
    }

    //
    // scan past any leading spaces - we KNOW this is NULL terminated
    //
    while( iswspace(*pCh) )
    {
        pCh++;
    }

    //
    // column followed by spaces only
    //
    if( !*pCh )
    {
        dwRetCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // if we're still at the leading '/' then it means we have the
    // /U username case
    //
    if( '/' == *pCh )
    {
        dwRetCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }


    wcsncpy(g_UserName, pCh, MAX_STRING - 1);
    g_UserName[MAX_STRING - 1] = 0;

cleanup:
    return dwRetCode;
}

#ifdef PRIVATE_VERSION
//+----------------------------------------------------------------------------
//
// SetMachineName
//
//+----------------------------------------------------------------------------
DWORD
SetMachineName(WCHAR* pszData)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    WCHAR* pCh = NULL;

    //
    // is ":" present?
    //
    pCh = wcschr(pszData, ':');
    if( NULL == pCh )
    {
        pCh = pszData;
    }
    else
    {
        pCh++;
    }

    //
    // scan past any leading spaces - we KNOW this is NULL terminated
    //
    while( iswspace(*pCh) )
    {
        pCh++;
    }

    //
    // column followed by spaces only
    //
    if( !*pCh )
    {
        dwRetCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // if we're still at the leading '/' then it means we have the
    // /U username case
    //
    if( '/' == *pCh )
    {
        dwRetCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;
    }


    g_RemoteOperation = TRUE;
    wcsncpy(g_RemoteComputerName, pCh, MAX_STRING - 1);
    g_RemoteComputerName[MAX_STRING - 1] = 0;

cleanup:
    return dwRetCode;
}
#endif

//+----------------------------------------------------------------------------
//
// SetCount
//
//  - Sets the count
//  - Proper formats are combinations of
//      /Count:300
//      /Count 300
//      /Count: 300
//
//  - returns ERROR_FILE_NOT_FOUND when the arg is missing so the caller can
//    move on to the next parameter
//+----------------------------------------------------------------------------
DWORD
SetCount(WCHAR* pszData)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    WCHAR* pEndString = NULL;
    UINT Count = 0;

    //
    // is ":" present?
    //
    WCHAR* pCh = wcschr(pszData, ':');
    if( NULL == pCh )
    {
        pCh = pszData;
    }
    else
    {
        pCh++;
    }

    //
    // scan past any leading spaces - we KNOW this is NULL terminated
    //
    while ( iswspace(*pCh) )
    {
        pCh++;
    }

    //
    // column followed by spaces only
    //
    if( !*pCh )
    {
        dwRetCode = ERROR_FILE_NOT_FOUND;
        goto cleanup;

    }

    Count = wcstoul(pCh, &pEndString, 0);
    if( *pEndString )
    {
        if( pEndString != pCh )
        {
            //
            // If the input is incorrect
            //
            dwRetCode = ERROR_BAD_ARGUMENTS;
            DisplayMessage(L"Count: Failed: Not a number.\n");
        }
        else
        {
            //
            // this means we run into a "/C 100" case and we have to move
            // to the next argument
            //
            dwRetCode = ERROR_FILE_NOT_FOUND;
        }
        goto cleanup;
    }

    //
    // Ignore if 0
    //
    if( Count )
    {
        g_AutoLogonCount = (DWORD)Count;
    }

cleanup:
    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// CredMan call data
//
// We have to dinamically load the dll and call into it as it is not present
// Win2k, NT4
//
//+----------------------------------------------------------------------------

//
// CredMan function
//
typedef DWORD (*PCredUIFunction) (
  PCTSTR pszTargetName,
  PCtxtHandle Reserved,
  DWORD dwAuthError,
  PCTSTR pszUserName,
  ULONG ulUserNameMaxChars,
  PCTSTR pszPassword,
  ULONG ulPasswordMaxChars,
  PBOOL pfSave,
  DWORD dwFlags
);

//+----------------------------------------------------------------------------
//
// GetPassword
//
//  - tries to load credui dll and if not there
//    falls back on regular console functions
//
//+----------------------------------------------------------------------------
DWORD GetPassword()
{
    DWORD dwRetCode = ERROR_INVALID_FUNCTION;
    BOOL  fSave = FALSE;
    PCredUIFunction pCredUICmdLinePromptForCredentials = NULL;
    HMODULE hModule = NULL;

    do
    {
        //
        // Try see if CredMan is present
        //
        hModule = LoadLibrary(L"credui.dll");

        if( NULL == hModule )
        {
            break;
        }

        //
        // get function pointer
        //
        pCredUICmdLinePromptForCredentials =
                (PCredUIFunction)GetProcAddress(
                                    hModule,
                                    "CredUICmdLinePromptForCredentialsW");

        if( NULL == pCredUICmdLinePromptForCredentials )
        {
            break;
        }

        //
        // CREDUI_FLAGS_DO_NOT_PERSIST - autologon pwd should not be persisted
        // CREDUI_FLAGS_VALIDATE_USERNAME - just a precaution
        // CREDUI_FLAGS_EXCLUDE_CERTIFICATES - we don't want this for autologon
        // CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS - prevents 'connect to'
        //      string to be displayed and since target is AutoAdminLogon
        //      it boils down to a nice prompt. Note that this flag will skip
        //      the user name, but we assume the username is already filled in
        //
        dwRetCode = pCredUICmdLinePromptForCredentials(
                                L"AutoAdminLogon",  // PCTSTR pszTargetName
                                NULL,               // PCtxtHandle Reserved
                                NO_ERROR,           // DWORD dwAuthError
                                g_UserName,         // PCTSTR pszUserName
                                MAX_STRING - 1,     // ULONG ulUserNameMaxChars
                                g_Password,         // PCTSTR pszPassword
                                MAX_STRING - 1,     // ULONG ulPasswordMaxChars
                                &fSave,             // PBOOL pfSave,
                                                    // DWORD dwFlags
                                CREDUI_FLAGS_DO_NOT_PERSIST |
                                CREDUI_FLAGS_VALIDATE_USERNAME |
                                CREDUI_FLAGS_EXCLUDE_CERTIFICATES |
                                CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS
                                );

    } while( FALSE );

    //
    // if CredMan is not present then just try the console input;
    // pass similar strings (though non localized)
    //
    if( ERROR_INVALID_FUNCTION == dwRetCode )
    {
        //
        // if user has not been specified
        //
        if( !*g_UserName )
        {
            dwRetCode = GetConsoleStr(g_UserName, MAX_STRING - 1,
                                      FALSE,
                                      L"Enter the user name for AutoAdminLogon: ",
                                      NULL);
            if( ERROR_SUCCESS != dwRetCode )
            {
                goto cleanup;
            }
        }

        dwRetCode = GetConsoleStr(g_Password, MAX_STRING - 1,
                                  TRUE,
                                  L"Enter the password for AutoAdminLogon: ", 
                                  NULL);
        if( ERROR_SUCCESS != dwRetCode )
        {
            goto cleanup;
        }
    }
    goto cleanup;

cleanup:
    if( hModule )
    {
        FreeLibrary(hModule);
    }
    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// CheckWinVersion
//  - currently any OS post NT4/SP7 supports this.
//  - the remote case (which we do not support yet) assumes remote NT4
//    as being pre-SP7...
//
//+----------------------------------------------------------------------------
DWORD
CheckWinVersion()
{
    DWORD dwMachineVerNumber = 0;
    DWORD dwRetCode = ERROR_SUCCESS;
    OSVERSIONINFOEX versionInfoEx;
    NET_API_STATUS status;

    // Make sure it's a Win2k box
#ifdef PRIVATE_VERSION
    if (g_RemoteOperation) {
        status = GetMajorNTVersion(&dwMachineVerNumber,
                                   g_RemoteComputerName);
    }
    else
#endif
    {
        status = GetMajorNTVersion(&dwMachineVerNumber,
                                   NULL);
    }

    switch (dwMachineVerNumber) {
    case 3:
            dwRetCode = ERROR_OLD_WIN_VERSION;
            _snwprintf(g_TempString, MAX_STRING - 1,
                       L"Error: Running NT3.x\n");
            DisplayMessage(g_TempString);
            break;
    case 4:
        //
        // Verify SP7 - only locally for now
        //
#ifdef PRIVATE_VERSION
        if( !g_RemoteOperation )
#endif
        {
            //
            // GetVersionInfoEx call for getting the SP information
            //
            SecureZeroMemory(&versionInfoEx, sizeof(OSVERSIONINFOEX));
            versionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

            if( !GetVersionEx((LPOSVERSIONINFO)(&versionInfoEx)) )
            {
                dwRetCode = GetLastError();
                _snwprintf(g_TempString, MAX_STRING - 1,
                           L"Error: Running NT4, can't query SP version: %s\n",
                           GetErrorString(dwRetCode));
                DisplayMessage(g_TempString);
            }

            if( versionInfoEx.wServicePackMajor < 7 )
            {
                dwRetCode = ERROR_OLD_WIN_VERSION;
                _snwprintf(g_TempString, MAX_STRING - 1,
                           L"Error: Running NT4 pre SP7\n");
                DisplayMessage(g_TempString);
                break;
            }
        }

        break;
    case 5:
        break;
    default:
        _snwprintf(g_TempString, MAX_STRING - 1,
                   L"Error: Unknown target machine version (%#x).\n",
                   status);
        DisplayMessage(g_TempString);
        dwRetCode = ERROR_OLD_WIN_VERSION;
        break;
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\common.c ===
#include <common.h>

//
// from autlogon.c
//
extern BOOL g_QuietMode;
extern WCHAR g_TempString[];
extern WCHAR g_ErrorString[];
extern WCHAR g_FailureLocation[];

#ifdef PRIVATE_VERSION
extern BOOL g_RemoteOperation;
extern WCHAR g_RemoteComputerName[];
#endif

//+----------------------------------------------------------------------------
//
// Wow64 stuff
//
//+----------------------------------------------------------------------------
#ifdef _X86_
typedef BOOL (*PFNISWOW64PROCESS)(HANDLE, PBOOL);
#endif
//+----------------------------------------------------------------------------
//
// DisplayMessage
//
//+----------------------------------------------------------------------------
VOID
DisplayMessage(
    WCHAR *MessageText)
{
    if (!g_QuietMode)
    {
        wprintf(L"%s", MessageText);
    }
}

//+----------------------------------------------------------------------------
//
// GetErrorString
//
//+----------------------------------------------------------------------------
WCHAR*
GetErrorString(
    DWORD dwErrorCode)
{
    LPVOID lpMsgBuf=NULL; 
    SecureZeroMemory(g_ErrorString, MAX_STRING * sizeof(WCHAR));

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL);

    // Free the bufferoa
    if (lpMsgBuf != NULL)
    {
        wcsncpy(g_ErrorString, lpMsgBuf, MAX_STRING - 1);
        LocalFree(lpMsgBuf);
    }
    return g_ErrorString;
}



DWORD
GetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *RegValue,
    size_t RegValueLength)
{
    DWORD    dwRetCode = ERROR_SUCCESS;
    HKEY     hKey=NULL;
    DWORD    dwMaxValueData = (MAX_STRING * sizeof(WCHAR));        // Longest Value data
    HANDLE   hHeap=NULL;
    BYTE     *bData=NULL;
    DWORD    cbData;
    DWORD    dwType;

    // get a handle to the local or remote computer
    // (as specified by our global flag)
    dwRetCode = GetRegistryHandle(&hKey, KEY_READ);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    // create a heap
    hHeap = HeapCreate(0, 0, 0);
    if( NULL == hHeap )
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: HeapCreate: %s\n",
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    // allocate some space on the heap for our regvalue we'll read in
    bData = (BYTE*)HeapAlloc(hHeap, 0, dwMaxValueData);
    if (bData == NULL)
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: HeapAlloc: %s\n",
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    cbData = dwMaxValueData;

    // read the regkey using the handle we open above
    dwRetCode = RegQueryValueEx(
            hKey,
            ValueName,
            NULL,        
            &dwType,    
            bData,
            &cbData);
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: RegQueryValueEx: %s",
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    // if it's not a type reg_sz, then something's wrong, so
    // report the error, which will cause us to stop.
    if( dwType != REG_SZ )
    {
        dwRetCode = ERROR_BADKEY;
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: RegQueryValueEx: %s: %s\n",
                   ValueName,
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    //
    // copy the (0 terminated) buffer to the registry value
    // If empty, just 0 the buffer for the caller
    //
    if( cbData )
    {
        if( cbData / sizeof(WCHAR) > RegValueLength )
        {
            *RegValue = 0;
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(RegValue, (WCHAR *)bData);
        }
    }
    else
    {
        *RegValue = 0;
    }

cleanup:
    if( NULL != bData )
    {
        SecureZeroMemory(bData, sizeof(bData));
        if( NULL != hHeap )
        {
            HeapFree(hHeap, 0, bData);
            HeapDestroy(hHeap);
        }
    }

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    return dwRetCode;
}


DWORD
GetRegValueDWORD(
    WCHAR* ValueName,
    DWORD*  RegValue)
{
    DWORD    dwRetCode = ERROR_SUCCESS;
    HKEY     hKey=NULL;
    DWORD    dwMaxValueData = (MAX_STRING * sizeof(WCHAR));        // Longest Value data
    HANDLE   hHeap=NULL;
    BYTE     *bData=NULL;
    DWORD    cbData;
    DWORD    dwType;

    // get a handle to the local or remote computer
    // (as specified by our global flag)
    dwRetCode = GetRegistryHandle(&hKey, KEY_READ);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    // create a heap
    hHeap = HeapCreate(0, 0, 0);
    if( NULL == hHeap )
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: HeapCreate: %s\n",
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    // allocate some space on the heap for our regvalue we'll read in
    bData = (BYTE*)HeapAlloc(hHeap, 0, dwMaxValueData);
    if (bData == NULL)
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: HeapAlloc: %s\n",
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    cbData = dwMaxValueData;

    // read the regkey using the handle we open above
    dwRetCode = RegQueryValueEx(
            hKey,
            ValueName,
            NULL,        
            &dwType,    
            bData,
            &cbData);
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: RegQueryValueEx: %s",
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    // if it's not a type reg_sz, then something's wrong, so
    // report the error, which will cause us to stop.
    if( dwType != REG_DWORD )
    {
        dwRetCode = ERROR_BADKEY;
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetRegValueSZ: RegQueryValueEx: %s: %s\n",
                   ValueName,
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

    //
    // copy the buffer to the registry value
    // If empty, just 0 the buffer for the caller
    //
    *RegValue = *(DWORD*)bData;

cleanup:
    if( NULL != bData )
    {
        SecureZeroMemory(bData, sizeof(bData));
        if( NULL != hHeap )
        {
            HeapFree(hHeap, 0, bData);
            HeapDestroy(hHeap);
        }
    }

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    return dwRetCode;
}

DWORD
ClearRegValue(
    WCHAR* ValueName)
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    HKEY    hKey=NULL;

    dwRetCode = GetRegistryHandle(&hKey, KEY_WRITE);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    dwRetCode = RegDeleteValue(hKey, ValueName);
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"ClearRegPassword: RegDeleteValue: %s: %s\n",
                   ValueName,
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

cleanup:
    if( NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return dwRetCode;
}


DWORD
SetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *ValueData)
{
    DWORD  dwRetCode = ERROR_SUCCESS;
    HKEY   hKey=NULL;

    dwRetCode = GetRegistryHandle(&hKey, KEY_WRITE);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    dwRetCode = RegSetValueEx(
                     hKey,
                     ValueName,
                     0,
                     REG_SZ,
                     (LPSTR) ValueData,
                     wcslen(ValueData)*sizeof(WCHAR));
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"SetRegValueSZ: RegSetValueEx: %s: %s\n",
                   ValueName,
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

cleanup:
    if( NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return dwRetCode;
}

DWORD
SetRegValueDWORD(
    WCHAR *ValueName,
    DWORD ValueData)
{
    DWORD  dwRetCode = ERROR_SUCCESS;
    HKEY   hKey=NULL;

    dwRetCode = GetRegistryHandle(&hKey, KEY_WRITE);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    dwRetCode = RegSetValueEx(
                     hKey,
                     ValueName,
                     0,
                     REG_DWORD,
                     (const BYTE*) (&ValueData),
                     sizeof(DWORD));
    if( ERROR_SUCCESS != dwRetCode )
    {
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"SetRegValueSZ: RegSetValueEx: %s: %s\n",
                   ValueName,
                   GetErrorString(dwRetCode));
        goto cleanup;
    }

cleanup:
    if( NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return dwRetCode;
}


DWORD 
GetRegistryHandle(
    HKEY   *phKey,
    REGSAM samDesired)
{
#ifdef PRIVATE_VERSION
    HKEY   RemoteRegistryHandle = NULL;
#endif
    DWORD  dwRetCode = ERROR_SUCCESS;

#ifdef _X86_
    //
    // if we run this tool on a 64bit system, we may need to write to
    // the 64bit hive
    //
    static PFNISWOW64PROCESS pfnIsWow64Process = NULL;
    static BOOL fIsWow64Process = FALSE;
    if( pfnIsWow64Process == NULL )
    {
        HINSTANCE hInstDLL = LoadLibrary(L"kernel32.dll");
        if( hInstDLL )
        {
            pfnIsWow64Process = 
                (PFNISWOW64PROCESS)GetProcAddress(hInstDLL, "IsWow64Process");
            if( pfnIsWow64Process )
            {
                pfnIsWow64Process(GetCurrentProcess(),
                                  &fIsWow64Process);
            }
            // else we assume we run on a downlevel platform
            FreeLibrary(hInstDLL);
        }
    }
    if( fIsWow64Process )
    {
        samDesired |= KEY_WOW64_64KEY;
    }

#endif

    //
    // If not PRIVATE mode, ignore the access requested passed in and
    // request all access, even though we don't need it. This will force the
    // caller to need to be admin to use this tool. We don't want someone using
    // this tool to view the autologon passwords of all machines across the domain
    // as a normal domain user...
    //
#ifndef PRIVATE_VERSION
    samDesired = KEY_ALL_ACCESS;
#endif

#ifdef PRIVATE_VERSION
    //
    // If we're connecting against a remote computer
    //
    if( g_RemoteOperation )
    {
        // open a handle to the remote registry
        dwRetCode = RegConnectRegistry(g_RemoteComputerName,
                        HKEY_LOCAL_MACHINE,
                        &RemoteRegistryHandle);

        if( ERROR_SUCCESS != dwRetCode )
        {
            _snwprintf(g_FailureLocation, MAX_STRING - 1,
                       L"GetRegistryHandle: RegConnectRegistry: %s: %s\n",
                       g_RemoteComputerName,
                       GetErrorString(dwRetCode));
            goto cleanup;
        }

        // open the WINLOGON key on the remote machine
        dwRetCode = RegOpenKeyEx(RemoteRegistryHandle,    
                        WINLOGON_REGKEY,
                        0,
                        samDesired,
                        phKey);
        if( ERROR_SUCCESS != dwRetCode )
        {
            _snwprintf(g_FailureLocation, MAX_STRING - 1,
                       L"GetRegistryHandle: RegOpenKeyEx: %s: %s\n",
                       g_RemoteComputerName,
                       GetErrorString(dwRetCode));
            goto cleanup;
        }
    }
    else
#endif
    {
        // open the WINLOGON key on the local machine
        dwRetCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,    
                        WINLOGON_REGKEY,
                        0,
                        samDesired,
                        phKey);
        if( ERROR_SUCCESS != dwRetCode )
        {
            _snwprintf(g_FailureLocation, MAX_STRING - 1,
                       L"GetRegistryHandle: RegOpenKeyEx: %s\n",
                       GetErrorString(dwRetCode));
            goto cleanup;
        }
    }

cleanup:
#ifdef PRIVATE_VERSION
    if( NULL != RemoteRegistryHandle )
    {
        RegCloseKey(RemoteRegistryHandle);
    }
#endif
    return dwRetCode;
}

//+---------------------------------------------------------------------------------------------------------
//
// LSASecret munging routines
//
//+---------------------------------------------------------------------------------------------------------

DWORD
GetPolicyHandle(LSA_HANDLE *LsaPolicyHandle)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS ntsResult;
#ifdef PRIVATE_VERSION
    LSA_UNICODE_STRING TargetMachine;
    USHORT TargetMachineLength;
#endif
    DWORD dwRetCode = ERROR_SUCCESS;

    // Object attributes are reserved, so initialize to zeroes.
    SecureZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

#ifdef PRIVATE_VERSION
    if( g_RemoteOperation )
    {
        //Initialize an LSA_UNICODE_STRING 
        TargetMachineLength = (USHORT)wcslen(g_RemoteComputerName);
        TargetMachine.Buffer = g_RemoteComputerName;
        TargetMachine.Length = TargetMachineLength * sizeof(WCHAR);
        TargetMachine.MaximumLength = (TargetMachineLength+1) * sizeof(WCHAR);

        // Get a handle to the Policy object.
        ntsResult = LsaOpenPolicy(
            &TargetMachine,    //local machine
            &ObjectAttributes, 
            POLICY_CREATE_SECRET | POLICY_GET_PRIVATE_INFORMATION,
            LsaPolicyHandle);

    }
    else
#endif
    {
        // Get a handle to the Policy object.
        ntsResult = LsaOpenPolicy(
            NULL,    //local machine
            &ObjectAttributes, 
            POLICY_CREATE_SECRET | POLICY_GET_PRIVATE_INFORMATION,
            LsaPolicyHandle);
    }

    if( STATUS_SUCCESS != ntsResult )
    {
        // An error occurred. Display it as a win32 error code.
        dwRetCode = LsaNtStatusToWinError(ntsResult);
        _snwprintf(g_FailureLocation, MAX_STRING - 1,
                   L"GetPolicyHandle: LsaOpenPolicy: %s\n",
                   GetErrorString(dwRetCode));
        goto cleanup;
    } 

cleanup:
    return dwRetCode;

}

DWORD
SetSecret(
    WCHAR *Secret,
    BOOL bClearSecret,
    WCHAR* SecretName)
{
    DWORD        dwRetCode = ERROR_SUCCESS;
    NTSTATUS     ntsResult;
    USHORT       SecretNameLength, SecretDataLength;
    LSA_HANDLE   LsaPolicyHandle=NULL;
    LSA_UNICODE_STRING lusSecretName, lusSecretData;

    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(SecretName);
    lusSecretName.Buffer = SecretName;
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength = (SecretNameLength+1) * sizeof(WCHAR);

    dwRetCode = GetPolicyHandle(&LsaPolicyHandle);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    // if bClearSecret is set, then delete the secret
    // otherwise set the secret to Secret
    if( bClearSecret )
    {
        ntsResult = LsaStorePrivateData(
            LsaPolicyHandle,
            &lusSecretName,
            NULL);
        if( STATUS_SUCCESS != ntsResult ) {
            dwRetCode = LsaNtStatusToWinError(ntsResult);
            _snwprintf(g_FailureLocation, MAX_STRING - 1,
                       L"SetSecret: LsaStorePrivateData: %s\n",
                       GetErrorString(dwRetCode));
            goto cleanup;
        }

    }
    else
    {
        //Initialize the Secret LSA_UNICODE_STRING 
        SecretDataLength = (USHORT)wcslen(Secret);
        lusSecretData.Buffer = Secret;
        lusSecretData.Length = SecretDataLength * sizeof(WCHAR);
        lusSecretData.MaximumLength = (SecretDataLength+1) * sizeof(WCHAR);

        ntsResult = LsaStorePrivateData(
            LsaPolicyHandle,
            &lusSecretName,
            &lusSecretData);
        if( STATUS_SUCCESS != ntsResult ) {
            dwRetCode = LsaNtStatusToWinError(ntsResult);
            goto cleanup;
        }
    }

cleanup:
    if( NULL != LsaPolicyHandle )
    {
        LsaClose(LsaPolicyHandle);
    }
    return dwRetCode;
}


DWORD 
GetSecret(
    WCHAR* Secret,
    size_t SecretLength,
    WCHAR* SecretName)
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    NTSTATUS    ntsResult;
    USHORT      SecretNameLength;
    LSA_HANDLE  LsaPolicyHandle=NULL;
    LSA_UNICODE_STRING lusSecretName;
    LSA_UNICODE_STRING *PrivateData=NULL;

    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(SecretName);
    lusSecretName.Buffer = SecretName;
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength= (SecretNameLength+1) * sizeof(WCHAR);

    dwRetCode = GetPolicyHandle(&LsaPolicyHandle);
    if( ERROR_SUCCESS != dwRetCode )
    {
        goto cleanup;
    }

    ntsResult = LsaRetrievePrivateData(
        LsaPolicyHandle,
        &lusSecretName,
        &PrivateData);

    if( STATUS_SUCCESS != ntsResult )
    {
        if( STATUS_OBJECT_NAME_NOT_FOUND == ntsResult)
        {
            dwRetCode = ntsResult;
            goto cleanup;
        }
        else
        {
            dwRetCode = LsaNtStatusToWinError(ntsResult);
            _snwprintf(g_FailureLocation, MAX_STRING - 1,
                       L"GetSecret: LsaRetrievePrivateData: %s \n",
                       GetErrorString(dwRetCode));
            goto cleanup;
        }
    }

    // copy the (not 0 terminated) buffer data to Secret
    if( (PrivateData->Length)/sizeof(WCHAR) < SecretLength )
    {
        wcsncpy(Secret, PrivateData->Buffer, (PrivateData->Length)/sizeof(WCHAR));
        Secret[(PrivateData->Length)/sizeof(WCHAR)] = 0;
    }
    else
    {
        Secret[0] = 0;
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
    }
    
cleanup:
    if( NULL != PrivateData )
    {
        SecureZeroMemory(PrivateData->Buffer, PrivateData->Length);
        LsaFreeMemory(PrivateData);
    }
    if( NULL != LsaPolicyHandle )
    {
        LsaClose(LsaPolicyHandle);
    }
    return dwRetCode;
}


//+----------------------------------------------------------------------------
//
// Other helpers
//
//+----------------------------------------------------------------------------
NET_API_STATUS 
GetMajorNTVersion(
    DWORD* Version,
    WCHAR* Server)
{
    SERVER_INFO_101* pInf;
    NET_API_STATUS status;

    status = NetServerGetInfo(Server, 101, (BYTE**)&pInf);
    if(!status)
    {
        if(pInf->sv101_platform_id == PLATFORM_ID_NT)
        {
            *Version = pInf->sv101_version_major;
        }
        else
        {
            *Version = 0;
        }
        NetApiBufferFree(pInf);
    }
    else
    {
        *Version = 0;
    }
        
    return status;
}


//+----------------------------------------------------------------------------
//
// GetConsoleStr - reads a console string and other stuff...
//
// "borrowed" from ds\netapi\netcmd\common\mutil.c
//
//+----------------------------------------------------------------------------
#define CR              0xD
#define LF              0xA
#define BACKSPACE       0x8

DWORD
GetConsoleStr(
    WCHAR*  buf,
    DWORD   buflen,
    BOOL    hide,
    WCHAR*  message,
    PDWORD  len
    )
{
    WCHAR	ch;
    WCHAR	*bufPtr = buf;
    DWORD	c;
    BOOL    err;
    DWORD   mode;
    DWORD   cchBuffer;

    DWORD   dwRetCode = ERROR_SUCCESS;
    DWORD   dwLen = 0;
    BOOL    hidden = FALSE;

    if( hide )
    {
        //
        // Init mode in case GetConsoleMode() fails
        //
        mode = ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT |
                   ENABLE_MOUSE_INPUT;

        if( !GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode) )
        {
            dwRetCode = GetLastError();
            goto cleanup;
        }

        if( !SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
		                    (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode) )
        {
            dwRetCode = GetLastError();
            goto cleanup;
        }

        hidden = TRUE;
    }

    //
    // prints the message
    //
    if( message )
    {
        if( !WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                          message, wcslen(message),
                          &cchBuffer, NULL) )
        {
            dwRetCode = GetLastError();
            goto cleanup;
        }
    }

    while (TRUE)
    {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);

	    if (!err || c != 1)
        {
    	    ch = 0xffff;
        }

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
        {
            if( (ch == CR) && !hide)
            {
                //
                // LF comes when echo enabled. Ignore it
                //
                ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
            }
            break;
        }

        if (ch == BACKSPACE)    /* back up one or two */
        {
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != buf)
            {
                bufPtr--;
                dwLen--;
            }
        }
        else
        {
            *bufPtr = ch;

            if (dwLen < buflen) 
                bufPtr++ ;                   /* don't overflow buf */
            dwLen++;                         /* always increment len */
        }
    }

    if( hidden )
    {
        SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    }

    //
    // NULL terminate
    //
    *bufPtr = 0;
    if( hide )
    {
        //
        // fake the echo for CR/LF
        //
        putchar(L'\n');
    }

    if( dwLen > buflen )
    {
        dwRetCode = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    //
    // set the optional out parameter
    //
    if( len )
    {
        *len = dwLen;
    }

cleanup:
    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\common.h ===
#ifndef UNICODE
    #define    UNICODE
    #define    _UNICODE
#endif

//+---------------------------------------------------------------------------------------------------------
//
// Includes
//
//+---------------------------------------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<windows.h>
#define SECURITY_WIN32
#include<security.h>
#include<ntsecapi.h>
#include<Winnetwk.h>
#include<lmserver.h>
#include<lmcons.h>
#include<lm.h>

//+---------------------------------------------------------------------------------------------------------
//
// Definitions
//
//+---------------------------------------------------------------------------------------------------------

// local definitions
#define MAX_STRING          255
#define MAX_NUM_STRING      15
#define WINLOGON_REGKEY     L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"


//+---------------------------------------------------------------------------------------------------------
//
// Prototypes
//
//+---------------------------------------------------------------------------------------------------------

// from common.c

VOID
DisplayMessage(
    WCHAR *MessageText);

WCHAR*
GetErrorString(
    DWORD dwErrorCode);

DWORD
GetRegValueSZ(
    WCHAR *RegValue,
    WCHAR *ValueName,
    size_t RegValueLength);

DWORD
GetRegValueDWORD(
    WCHAR *ValueName,
    DWORD *RegValue);

DWORD
ClearRegValue(
    WCHAR* ValueName);

DWORD
SetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *ValueData);

DWORD
SetRegValueDWORD(
    WCHAR *ValueName,
    DWORD dwValue);

DWORD 
GetRegistryHandle(
    HKEY   *hKey,
    REGSAM samDesired);

DWORD
GetPolicyHandle(
    LSA_HANDLE *LsaPolicyHandle);

DWORD
SetSecret(
    WCHAR *Secret,
    BOOL bClearSecret,
    WCHAR* SecretName);

DWORD
GetSecret(
    WCHAR *Secret,
    size_t SecretLength,
    WCHAR* SecretName);

NET_API_STATUS
GetMajorNTVersion(
    DWORD* Version,
    WCHAR* Server);

DWORD GetUserNameAndPassword();

DWORD
GetConsoleStr(
    WCHAR*  buf,
    DWORD   buflen,
    BOOL    hide,
    WCHAR*  message,
    PDWORD  len
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\oldsrc\common\common.c ===
#include <common.h>

extern BOOL g_QuietMode;
extern WCHAR g_TempString[];
extern WCHAR g_ErrorString[];
extern WCHAR g_FailureLocation[];

extern BOOL g_RemoteOperation;
extern WCHAR g_RemoteComputerName[];
extern BOOL g_CheckNT4Also;



VOID
DisplayMessage(
    WCHAR *MessageText)
{
    if (!g_QuietMode) {
        wprintf(L"%s", MessageText);
    }
}

WCHAR*
GetErrorString(
    DWORD dwErrorCode)
{
    LPVOID lpMsgBuf=NULL; 
    ZeroMemory(g_ErrorString, MAX_STRING * sizeof(WCHAR));

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL);

    // Free the bufferoa
    if (lpMsgBuf != NULL) {
        wcscpy(g_ErrorString, lpMsgBuf);
        LocalFree(lpMsgBuf);
    }
    return g_ErrorString;
}



//+---------------------------------------------------------------------------------------------------------
//
// Registry munging routines
//
//+---------------------------------------------------------------------------------------------------------

DWORD
GetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *RegValue)
{
    DWORD    dwRetCode = ERROR_SUCCESS;
    HKEY     hKey=NULL;
    DWORD    dwMaxValueData = (MAX_STRING * sizeof(WCHAR));        // Longest Value data
    HANDLE   hHeap=NULL;
    BYTE     *bData=NULL;
    DWORD    cbData;
    DWORD    dwType;

//    ZeroMemory(RegValue, MAX_STRING * sizeof(WCHAR));

    // get a handle to the local or remote computer
    // (as specified by our global flag)
    dwRetCode = GetRegistryHandle(&hKey, KEY_READ);
    if (dwRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    // create a heap
    hHeap = HeapCreate(0, 0, 0);
    if (hHeap == NULL) {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        wsprintf(g_FailureLocation, L"GetRegValueSZ: HeapCreate: %s\n", GetErrorString(dwRetCode));
        goto cleanup;
    }

    // allocate some space on the heap for our regvalue we'll read in
    bData = (BYTE*)HeapAlloc(hHeap, 0, dwMaxValueData);
    if (bData == NULL) {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        wsprintf(g_FailureLocation, L"GetRegValueSZ: HeapAlloc: %s\n", GetErrorString(dwRetCode));
        goto cleanup;
    }

    cbData = dwMaxValueData;

    // read the regkey using the handle we open above
    dwRetCode = RegQueryValueEx(
            hKey,
            ValueName,
            NULL,        
            &dwType,    
            bData,
            &cbData);
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_FailureLocation, L"GetRegValueSZ: RegQueryValueEx: %s", GetErrorString(dwRetCode));
        goto cleanup;
    }

    // if it's not a type reg_sz, then something's wrong, so
    // report the error, which will cause us to stop.
    if (dwType != REG_SZ) {
        dwRetCode = ERROR_BADKEY;
        wsprintf(g_FailureLocation, L"GetRegValueSZ: RegQueryValueEx: %s: %s\n", ValueName, GetErrorString(dwRetCode));
        goto cleanup;
    }

    // copy the buffer to the registry value
    wcsncpy(RegValue, (WCHAR *)bData, cbData * sizeof(WCHAR));

cleanup:
    if (bData != NULL) {
        ZeroMemory(bData, sizeof(bData));
        if (hHeap != NULL) {
            HeapFree(hHeap, 0, bData);
            HeapDestroy(hHeap);
        }
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return dwRetCode;
}


DWORD
ClearRegPassword()
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    HKEY    hKey=NULL;

    dwRetCode = GetRegistryHandle(&hKey, KEY_WRITE);
    if (dwRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    dwRetCode = RegDeleteValue(hKey, L"DefaultPassword");
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_FailureLocation, L"ClearRegPassword: RegDeleteValue: %s\n", GetErrorString(dwRetCode));
//        DisplayMessage(g_TempString);
        goto cleanup;
    }

cleanup:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    return dwRetCode;
}


DWORD
SetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *ValueData)
{
    DWORD  dwRetCode = ERROR_SUCCESS;
    HKEY   hKey=NULL;

    dwRetCode = GetRegistryHandle(&hKey, KEY_WRITE);
    if (dwRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    dwRetCode = RegSetValueEx(
                     hKey,
                     ValueName,
                     0,
                     REG_SZ,
                     (LPSTR) ValueData,
                     wcslen(ValueData)*sizeof(WCHAR));
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_FailureLocation, L"SetRegValueSZ: RegSetValueEx: %s: %s\n", ValueName, GetErrorString(dwRetCode));
        goto cleanup;
    }

cleanup:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    return dwRetCode;
}


DWORD 
GetRegistryHandle(
    HKEY   *phKey,
    REGSAM samDesired)
{
    HKEY   RemoteRegistryHandle=NULL;
    DWORD  dwRetCode = ERROR_SUCCESS;

    //
    // If not PRIVATE mode, ignore the access requested passed in and
    // request all access, even though we don't need it. This will force the
    // caller to need to be admin to use this tool. We don't want someone using
    // this tool to view the autologon passwords of all machines across the domain
    // as a normal domain user...
    //
#ifndef PRIVATE_VERSION
    samDesired = KEY_ALL_ACCESS;
#endif
    //
    // If we're connecting against a remote computer
    //
    if (g_RemoteOperation) {
        // open a handle to the remote registry
        dwRetCode = RegConnectRegistry(
                g_RemoteComputerName,
                HKEY_LOCAL_MACHINE,
                &RemoteRegistryHandle);

        if (dwRetCode != ERROR_SUCCESS) {
            wsprintf(g_FailureLocation, L"GetRegistryHandle: RegConnectRegistry: %s: %s\n", g_RemoteComputerName, GetErrorString(dwRetCode));
            goto cleanup;
        }

        // open the WINLOGON key on the remote machine
        dwRetCode = RegOpenKeyEx(
                RemoteRegistryHandle,    
                WINLOGON_REGKEY,
                0,
                samDesired,
                phKey);
        if (dwRetCode != ERROR_SUCCESS) {
            wsprintf(g_FailureLocation, L"GetRegistryHandle: RegOpenKeyEx: %s: %s\n", g_RemoteComputerName, GetErrorString(dwRetCode));
            goto cleanup;
        }
    } else {
        // open the WINLOGON key on the local machine
        dwRetCode = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,    
                WINLOGON_REGKEY,
                0,
                samDesired,
                phKey);
        if (dwRetCode != ERROR_SUCCESS) {
            wsprintf(g_FailureLocation, L"GetRegistryHandle: RegOpenKeyEx: %s\n", GetErrorString(dwRetCode));
            goto cleanup;
        }
    }

cleanup:
    if (RemoteRegistryHandle != NULL) {
        RegCloseKey(RemoteRegistryHandle);
    }
    return dwRetCode;
}

//+---------------------------------------------------------------------------------------------------------
//
// LSASecret munging routines
//
//+---------------------------------------------------------------------------------------------------------

DWORD
GetPolicyHandle(LSA_HANDLE *LsaPolicyHandle)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS ntsResult;
    LSA_UNICODE_STRING TargetMachine;
    USHORT TargetMachineLength;
    DWORD dwRetCode = ERROR_SUCCESS;

    // Object attributes are reserved, so initialize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (g_RemoteOperation) {
        //Initialize an LSA_UNICODE_STRING 
        TargetMachineLength = (USHORT)wcslen(g_RemoteComputerName);
        TargetMachine.Buffer = g_RemoteComputerName;
        TargetMachine.Length = TargetMachineLength * sizeof(WCHAR);
        TargetMachine.MaximumLength = (TargetMachineLength+1) * sizeof(WCHAR);

        // Get a handle to the Policy object.
        ntsResult = LsaOpenPolicy(
            &TargetMachine,    //local machine
            &ObjectAttributes, 
            POLICY_CREATE_SECRET | POLICY_GET_PRIVATE_INFORMATION,
            LsaPolicyHandle);

    } else {
        // Get a handle to the Policy object.
        ntsResult = LsaOpenPolicy(
            NULL,    //local machine
            &ObjectAttributes, 
            POLICY_CREATE_SECRET | POLICY_GET_PRIVATE_INFORMATION,
            LsaPolicyHandle);
    }

    if (ntsResult != STATUS_SUCCESS)
    {
        // An error occurred. Display it as a win32 error code.
        dwRetCode = LsaNtStatusToWinError(ntsResult);
        wsprintf(g_FailureLocation, L"GetPolicyHandle: LsaOpenPolicy: %s\n", GetErrorString(dwRetCode));
        goto cleanup;
    } 

cleanup:
    return dwRetCode;

}

DWORD
SetSecret(
    WCHAR *Password,
    BOOL bClearSecret)
{
    DWORD        dwRetCode = ERROR_SUCCESS;
    NTSTATUS     ntsResult;
    USHORT       SecretNameLength, SecretDataLength;
    LSA_HANDLE   LsaPolicyHandle=NULL;
    LSA_UNICODE_STRING lusSecretName, lusSecretData;

    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(L"DefaultPassword");
    lusSecretName.Buffer = L"DefaultPassword";
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength = (SecretNameLength+1) * sizeof(WCHAR);

    dwRetCode = GetPolicyHandle(&LsaPolicyHandle);
    if (dwRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    // if bClearSecret is set, then delete the secret
    // otherwise set the secret to Password
    if (bClearSecret) {
        ntsResult = LsaStorePrivateData(
            LsaPolicyHandle,
            &lusSecretName,
            NULL);
        if (ntsResult != STATUS_SUCCESS) {
            dwRetCode = LsaNtStatusToWinError(ntsResult);
            wsprintf(g_FailureLocation, L"SetSecret: LsaStorePrivateData: %s\n", GetErrorString(dwRetCode));
            goto cleanup;
        }

    } else {
        //Initialize the Password LSA_UNICODE_STRING 
        SecretDataLength = (USHORT)wcslen(Password);
        lusSecretData.Buffer = Password;
        lusSecretData.Length = SecretDataLength * sizeof(WCHAR);
        lusSecretData.MaximumLength = (SecretDataLength+1) * sizeof(WCHAR);

        ntsResult = LsaStorePrivateData(
            LsaPolicyHandle,
            &lusSecretName,
            &lusSecretData);
        if (ntsResult != STATUS_SUCCESS) {
            dwRetCode = LsaNtStatusToWinError(ntsResult);
            wsprintf(g_FailureLocation, L"SetSecret: LsaStorePrivateData: %s\n", GetErrorString(dwRetCode));
            goto cleanup;
        }
    }

cleanup:
    if (LsaPolicyHandle != NULL) {
        LsaClose(LsaPolicyHandle);
    }
    return dwRetCode;
}


DWORD 
GetSecret(
    WCHAR *Password)
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    NTSTATUS    ntsResult;
    USHORT      SecretNameLength;
    LSA_HANDLE  LsaPolicyHandle=NULL;
    LSA_UNICODE_STRING lusSecretName;
    LSA_UNICODE_STRING *PrivateData=NULL;

    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(L"DefaultPassword");
    lusSecretName.Buffer = L"DefaultPassword";
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength= (SecretNameLength+1) * sizeof(WCHAR);

    dwRetCode = GetPolicyHandle(&LsaPolicyHandle);
    if (dwRetCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    ntsResult = LsaRetrievePrivateData(
        LsaPolicyHandle,
        &lusSecretName,
        &PrivateData);

    if (ntsResult != STATUS_SUCCESS) {
        if (ntsResult == STATUS_OBJECT_NAME_NOT_FOUND) {
            return ntsResult;
        } else {
            dwRetCode = LsaNtStatusToWinError(ntsResult);
            wsprintf(g_FailureLocation, L"GetSecret: LsaRetrievePrivateData: %s \n", GetErrorString(dwRetCode));
            goto cleanup;
        }
    }

    // copy the buffer data to Password
    wcsncpy(Password, PrivateData->Buffer, (PrivateData->Length)/sizeof(WCHAR));
    
cleanup:
    if (PrivateData != NULL) {
        ZeroMemory(PrivateData->Buffer, PrivateData->Length);
        LsaFreeMemory(PrivateData);
    }
    if (LsaPolicyHandle != NULL) {
        LsaClose(LsaPolicyHandle);
    }
    return dwRetCode;
}



DWORD 
GetMajorNTVersion(
    WCHAR *Server)
{
    SERVER_INFO_101* pInf;
    DWORD ver = 0;

    if(!NetServerGetInfo(Server, 101, (BYTE**)&pInf))
    {
        if(pInf->sv101_platform_id == PLATFORM_ID_NT) {
            ver = pInf->sv101_version_major;
        } else {
            ver = 0;
        }
        NetApiBufferFree(pInf);
    } else {
        ver = 0;
    }
        
    return ver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\oldsrc\common\common.h ===
#ifndef UNICODE
    #define    UNICODE
    #define    _UNICODE
#endif

//+---------------------------------------------------------------------------------------------------------
//
// Includes
//
//+---------------------------------------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
#include<windows.h>
#include<winuser.h>
#include<ntsecapi.h>
#include<Winnetwk.h>
#include<lmserver.h>
#include<lmcons.h>
#include<lm.h>

//+---------------------------------------------------------------------------------------------------------
//
// Definitions
//
//+---------------------------------------------------------------------------------------------------------

// from NTSTATUS.H
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

// local definitions
#define MAX_STRING          255
#define WINLOGON_REGKEY     L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"


//+---------------------------------------------------------------------------------------------------------
//
// Prototypes
//
//+---------------------------------------------------------------------------------------------------------

// from shared.c

VOID
DisplayMessage(
    WCHAR *MessageText);

WCHAR*
GetErrorString(
    DWORD dwErrorCode);

DWORD
GetRegValueSZ(
    WCHAR *RegValue,
    WCHAR *ValueName);

DWORD
ClearRegPassword();

DWORD
SetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *ValueData);

DWORD 
GetRegistryHandle(
    HKEY   *hKey,
    REGSAM samDesired);

DWORD
GetPolicyHandle(
    LSA_HANDLE *LsaPolicyHandle);

DWORD
SetSecret(
    WCHAR *Password,
    BOOL bClearSecret);

DWORD
GetSecret(
    WCHAR *Password);

DWORD 
GetMajorNTVersion(
    WCHAR *Server);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\oldsrc\forcemigrate\forcemigrate.c ===
/*++

   Copyright (c) 2000  Microsoft Corporation

   Module Name:

       forcemigrate.c

   Abstract:

	forcemigrate.c

   Author:
        Jason Garms (jasong)             27 October 2000


--*/

#include <shared.h>



//+---------------------------------------------------------------------------------------------------------
//
// Prototypes
//
//+---------------------------------------------------------------------------------------------------------

DWORD
MigratePassword();

DWORD
ListAll();

VOID
DumpCmd();


//+---------------------------------------------------------------------------------------------------------
//
// Globals
//
//+---------------------------------------------------------------------------------------------------------
BOOL   g_QuietMode = FALSE;
WCHAR  g_TempString[MAX_STRING] = {0};
WCHAR  g_ErrorString[MAX_STRING] = {0};
WCHAR  g_FailureLocation[MAX_STRING] = {0};

BOOL   g_RemoteOperation = FALSE;
WCHAR  g_RemoteComputerName[MAX_STRING] = {0};
DWORD  g_RunningUsersCreds = 0;
DWORD  g_CheckNT4Also = 0;

//+---------------------------------------------------------------------------------------------------------
//
// Functions
//
//+---------------------------------------------------------------------------------------------------------


int 
__cdecl 
wmain(
    int argc,
    WCHAR *argv[]
)
{
    DWORD dwCommandPosition=1;
    DWORD dwRetCode=ERROR_SUCCESS;

    // parse the command line params and act on them
    // if there's fewer than 2 params, it's not a valid call
    if (argc < 2) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }
        
    // check to see quietmode is enabled and set global flag
    // and increment commandposition pointer, but only if there
    // are more arguments to our right, otherwise, it's invalid
    // usage
    if (!wcscmp(argv[dwCommandPosition], L"-q")) {
        g_QuietMode = 1;
        dwCommandPosition++;
    }


    if ((DWORD)argc <= (dwCommandPosition)) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    // check to see if we should try the running user's credentials as well 
    if (!wcscmp(argv[dwCommandPosition], L"-r")) {
        g_RunningUsersCreds = 1;
        dwCommandPosition++;
    }

    if ((DWORD)argc <= (dwCommandPosition)) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }
    
    // check to see if we should run against NT4 as well
    if (!wcscmp(argv[dwCommandPosition], L"-nt4")) {
        g_CheckNT4Also = 1;
        dwCommandPosition++;
    }

    if ((DWORD)argc <= (dwCommandPosition)) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }
    
    // check to see if a UNC machine name is passed in for
    // remote operation and set the approprite globals
    // if there is a UNC path here, then increment commandposition
    // pointer, but only if there's more arguments to our right,
    // otherwise it's invalid usage.
    if ((*(argv[dwCommandPosition]) != '\\')) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    // make sure there's actually some chars to the right of the \\s
    if (wcslen(argv[dwCommandPosition])<=2) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    // make sure the machine name fits in our buffer
    if (wcslen(argv[dwCommandPosition]) >= MAX_STRING) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    g_RemoteOperation = TRUE;
    wcsncpy(g_RemoteComputerName, 
        argv[dwCommandPosition], 
        wcslen(argv[dwCommandPosition]));

    dwRetCode = MigratePassword();

cleanup:
    if (dwRetCode == ERROR_BAD_ARGUMENTS) {
        DumpCmd();
    }
    return dwRetCode;
}


DWORD
MigratePassword() 
{
    WCHAR UserName[MAX_STRING];
    WCHAR DomainName[MAX_STRING];
    WCHAR Password[MAX_STRING];
    WCHAR ConCat[MAX_STRING];
    DWORD dwRetCode = ERROR_SUCCESS;
    NETRESOURCE NetResource = {0};
    DWORD dwMachineVerNumber = 0;

    // Connect to the remote machine to obtain the username, domain, and password

    // Make sure it's a Win2k box
    dwMachineVerNumber = GetMajorNTVersion(g_RemoteComputerName);
    switch (dwMachineVerNumber) {
    case 3:
    case 4:
        if ((dwMachineVerNumber == 4) && (g_CheckNT4Also)) {
            break;
        } else {
            wprintf(L"%s: Error, target is running NT4 and -nt4 option not selected\n", g_RemoteComputerName);
            dwRetCode = ERROR_OLD_WIN_VERSION;
            goto cleanup;
        }
    case 5:
        break;
    default:
        wprintf(L"%s: Error target's machine version is invalid\n", g_RemoteComputerName);
        dwRetCode = ERROR_OLD_WIN_VERSION;
        goto cleanup;
    }
    
    wsprintf(g_TempString, L"%s: Beginning Migration: System is running NT%d\n", g_RemoteComputerName, dwMachineVerNumber);
    wsprintf(g_TempString, L"%s: DefaultPassword  : (reg does not exist)\n", g_RemoteComputerName);

    //
    // Get the DefaultPassword
    //
    dwRetCode = GetRegValueSZ(L"DefaultPassword", Password);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"%s: DefaultPassword  : (reg does not exist)\n", g_RemoteComputerName);
            DisplayMessage(g_TempString);
            goto cleanup;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            if (!wcscmp(Password, L"")) {
                dwRetCode = ERROR_FILE_NOT_FOUND;
                wsprintf(g_TempString, L"%s: DefaultPassword  : (exists, but is empty)\n", g_RemoteComputerName);
                DisplayMessage(g_TempString);
                break;
            }
            wsprintf(g_TempString, L"%s: DefaultPassword  : %s\n", g_RemoteComputerName, Password);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"DefaultPassword  : Failed to query regkey: %s\n", GetErrorString(dwRetCode));
                wprintf(L"Flag 3\n", dwRetCode);
            goto cleanup;
    }

    //
    // Get the username
    //
    dwRetCode = GetRegValueSZ(L"DefaultUserName", UserName);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"%s: DefaultUserName  : (does not exist)\n", g_RemoteComputerName);
            DisplayMessage(g_TempString);
            goto cleanup;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            wsprintf(g_TempString, L"%s: DefaultUserName  : %s\n", g_RemoteComputerName, UserName);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"%s: DefaultUserName  : Failed to query regkey: %s\n", g_RemoteComputerName, GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the DefaultDomainName
    //
    dwRetCode = GetRegValueSZ(L"DefaultDomainName", DomainName);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"%s: DefaultDomainName: (does not exist)\n", g_RemoteComputerName);
            DisplayMessage(g_TempString);
            goto cleanup;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            wsprintf(g_TempString, L"%s: DefaultDomainName: %s\n", g_RemoteComputerName, DomainName);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"%s: DefaultDomainName: Failed to query regkey: %s\n", g_RemoteComputerName, GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    if ((wcslen(DomainName) + wcslen(UserName)) >= MAX_STRING) {
        dwRetCode = ERROR_BUFFER_OVERFLOW;
        goto cleanup;
    }

    wcscpy(ConCat, DomainName);
    wcscat(ConCat, L"\\");
    wcscat(ConCat, UserName);

    NetResource.lpRemoteName = g_RemoteComputerName;

    dwRetCode = WNetAddConnection2(
          &NetResource,   // connection details
          Password,         // password
          ConCat,           // user name
          0);               // connection options

    if (dwRetCode != ERROR_SUCCESS) {
        if (!g_RunningUsersCreds) {
            wprintf(L"%s: Could not logon as %s using password %s\n", g_RemoteComputerName, ConCat, Password);
            goto cleanup;
        } else {
            wprintf(L"Trying with your own credentials\n");
            dwRetCode = WNetAddConnection2(
                  &NetResource,     // connection details
                  NULL,             // password
                  NULL,             // user name
                  0);               // connection options
            if (dwRetCode != ERROR_SUCCESS) {
                wprintf(L"%s: Could not logon you or as %s using password %s\n", g_RemoteComputerName, ConCat, Password);
                goto cleanup;
            }
        }
    }

    // Set the DefaultPassword LSAsecret to the value we retrieved from the registry
    dwRetCode = SetSecret(Password, 0);
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_TempString, L"%s: Migrate Failed: Could not set DefaultPassword LSASecret: %s\n", g_RemoteComputerName, GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        wsprintf(g_TempString, L"%s:                 This is probably because the user is not the admin of the local machine\n", g_RemoteComputerName);
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    // Delete the DefaultPassword registry key
    dwRetCode = ClearRegPassword();
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_TempString, L"%s: Migrate Failed: Could not delete DefaultPassword RegKey: %s\n", g_RemoteComputerName, GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    wsprintf(g_TempString, L"%s: Password migrated from Registry to LSASecret\n", g_RemoteComputerName);
    DisplayMessage(g_TempString);

cleanup:
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_TempString, L"%s: Migrate Failed  ---------\n", g_RemoteComputerName);
        DisplayMessage(g_TempString);
    } else {
        wsprintf(g_TempString, L"%s: Migrate Success !!!!!!!!!\n", g_RemoteComputerName);
        DisplayMessage(g_TempString);
    }
    return dwRetCode;
}



VOID
DumpCmd()
{
        wprintf(L"FORCEMIGRATE v0.1: Copyright 2000, Microsoft Corporation\n\n");
        wprintf(L"DESCRIPTION:\n");
        wprintf(L"   Force migrates DefaultPassword cleartext to LSASecret\n");
        wprintf(L"USAGE:\n");
        wprintf(L"   FORCEMIGRATE [-q] [-r] [-nt4] \\\\machine\n");
        wprintf(L"      -q         Enable quiet mode, which supresses all output\n");
        wprintf(L"      -r         Try with current user's creds as well as DefaultPassword\n");
        wprintf(L"      -nt4       Run against NT4 boxes as well\n");
        wprintf(L"      \\machine  If specified, the UNC name of the machine to configure\n");
} // DumpCmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\oldsrc\autologon\autologon.c ===
/*++

   Copyright (c) 2000  Microsoft Corporation

   Module Name:

       autologon.c

   Abstract:

		This is a command-line utility munges that settings related to the 
        Windows NT/2000 Autologon functionality

		if PRIVATE_VERSION is defined, password info will be displayed on the output
		For general distribution, this should not be defined

   Author:
        Jason Garms (jasong)             12 October 2000


--*/

#include "..\common\common.h"

//+---------------------------------------------------------------------------------------------------------
//
// Prototypes
//
//+---------------------------------------------------------------------------------------------------------

DWORD
MigratePassword();

DWORD
ListAll();

DWORD
CheckWinVersion();

VOID
DumpCmd();

VOID
DisplayHelp();


//+---------------------------------------------------------------------------------------------------------//
// Globals
//
//+---------------------------------------------------------------------------------------------------------
BOOL   g_QuietMode = FALSE;
WCHAR  g_TempString[MAX_STRING] = {0};
WCHAR  g_ErrorString[MAX_STRING] = {0};
WCHAR  g_FailureLocation[MAX_STRING] = {0};

BOOL   g_RemoteOperation = FALSE;
WCHAR  g_RemoteComputerName[MAX_STRING] = {0};
BOOL   g_CheckNT4Also = 0;


//+---------------------------------------------------------------------------------------------------------
//
// Functions
//
//+---------------------------------------------------------------------------------------------------------


int 
__cdecl 
wmain(
    int argc,
    WCHAR *argv[]
)
{
    DWORD dwCommandPosition=1;
    DWORD dwRetCode=ERROR_SUCCESS;
    WCHAR myChar[20];

	//
	// Display usage if there's no options on the cmd line
	//
	if ( argc < 2 ) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
	}
	

	//
	// Populate the argument string
	//
    wcscpy(myChar, argv[1]);


	//
	// Display online help
	//
    if (!wcscmp(argv[dwCommandPosition], L"/?")) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    // check to see quietmode is enabled and set global flag
    // and increment commandposition pointer, but only if there
    // are more arguments to our right, otherwise, it's invalid
    // usage
    if (!wcscmp(_wcslwr(argv[dwCommandPosition]), L"/q")) {
        g_QuietMode = 1;
        dwCommandPosition++;
    }

    if ((DWORD)argc <= (dwCommandPosition)) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    if (!wcscmp(_wcslwr(argv[dwCommandPosition]), L"/nt4")) {
        g_CheckNT4Also = 1;
        dwCommandPosition++;
    }

    if ((DWORD)argc <= (dwCommandPosition)) {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }

    // check to see if a UNC machine name is passed in for
    // remote operation and set the approprite globals
    // if there is a UNC path here, then increment commandposition
    // pointer, but only if there's more arguments to our right,
    // otherwise it's invalid usage.
    if( (*(argv[dwCommandPosition]) == '\\')) {
        if (*(argv[dwCommandPosition]+1) != '\\') {
            dwRetCode = ERROR_BAD_ARGUMENTS;
            goto cleanup;
        }
        // make sure there's more commands to our right
        if ((DWORD)argc <= dwCommandPosition+1) {
            dwRetCode = ERROR_BAD_ARGUMENTS;
            goto cleanup;
        }
        // make sure there's actually some chars to the right of the \\s
        if (wcslen(argv[dwCommandPosition])<=2) {
            dwRetCode = ERROR_BAD_ARGUMENTS;
            goto cleanup;
        }
        // make sure the machine name fits in our buffer
        if (wcslen(argv[dwCommandPosition]) >= MAX_STRING) {
            dwRetCode = ERROR_BAD_ARGUMENTS;
            goto cleanup;
        }
        g_RemoteOperation = TRUE;
        wcsncpy(g_RemoteComputerName, 
            argv[dwCommandPosition], 
            wcslen(argv[dwCommandPosition]));
        dwCommandPosition++;
    }

    // now, what's left on the arg line must be our command action
    // parse and execute the appropriate action, and if we don't have
    // a match, then it's improper usage, so display usage info
    if (*(argv[dwCommandPosition]) != '/') {
        dwRetCode = ERROR_BAD_ARGUMENTS;
        goto cleanup;
    }
    switch( *(_wcslwr(argv[dwCommandPosition]+1))) {
        //
        // delete password
        //
        case 'x':
            _wcslwr(argv[dwCommandPosition]+2);
            if ((*(argv[dwCommandPosition]+2) != 'r') 
                && (*(argv[dwCommandPosition]+2) != 's')) {
                dwRetCode = ERROR_BAD_ARGUMENTS;
                goto cleanup;
            }
            if (*(argv[dwCommandPosition]+2) == 'r') {
                dwRetCode = ClearRegPassword();
                if (dwRetCode == ERROR_FILE_NOT_FOUND) {

                    DisplayMessage(L"DefaultPassword: Delete Failed: RegKey does not exist.\n");
                    goto cleanup;
                }
                if (dwRetCode != ERROR_SUCCESS) {
                    wsprintf(g_TempString, L"DefaultPassword: Delete Failed: %s\n", GetErrorString(dwRetCode));
                    DisplayMessage(g_TempString);
                    goto cleanup;
                }
                DisplayMessage(L"DefaultPassword deleted\n");
            }
            if (*(argv[dwCommandPosition]+2) == 's') {
                dwRetCode = SetSecret(L"", 1);
                if (dwRetCode == ERROR_FILE_NOT_FOUND) {
                    DisplayMessage(L"LSASecret: Delete Failed: LSASecret does not exist.\n");
                    goto cleanup;
                }
                if (dwRetCode != ERROR_SUCCESS) {
                    wsprintf(g_TempString, L"LSASecret: Delete Failed: %s\n", GetErrorString(dwRetCode));
                    DisplayMessage(g_TempString);
                    goto cleanup;
                }
                DisplayMessage(L"LSASecret deleted\n");
            }
            break;

        //
        // migrate password
        //
        case 'm':    
            MigratePassword();
            break;

        //
        // list autologon info
        //
        case 'l':
            ListAll();
            break;

        //
        // set autologon info
        //
        case 's':
            //
            // make sure we're running against a correct version of NT first
            //
            if (CheckWinVersion() != ERROR_SUCCESS) {
                dwRetCode = ERROR_OLD_WIN_VERSION;
                goto cleanup;
            }

            //
            // with the -s option, there must be a password, or
            // a password, username and domainname. so if there aren't
            // exactly 3 or 4 arguments, then it's invalid usage
            //
            if (((DWORD)argc != 2+dwCommandPosition) && 
                ((DWORD)argc != 3+dwCommandPosition))
            {
                dwRetCode = ERROR_BAD_ARGUMENTS;
                goto cleanup;
            }

            //
            // if there's 4 args, then the Domain\UserName, so set these
            //
            if ((DWORD)argc == 3+dwCommandPosition) {
                WCHAR DomainName[MAX_STRING] = {0};
                WCHAR *ptrUserName = NULL;
                DWORD i;

                //
                // make sure the input value is smaller than our buffers
                //
                if (wcslen(argv[dwCommandPosition+2]) >= MAX_STRING) {
                    dwRetCode = ERROR_BAD_ARGUMENTS;
                    goto cleanup;
                }

                //
                // copy the arguement to DomainName
                //
                wcsncpy(DomainName, argv[dwCommandPosition+2], MAX_STRING);

                //
                // Replace the first \ character with a NULL to terminate, then
                // assign user pointer to second half of string
                // if there is no \ character, then it's not a valid name, terminate
                //
                for (i=1; (i < wcslen(DomainName)); i++) {
                    if (*(DomainName+i) == L'\\') {
                        *(DomainName+i) = L'\0';
                        ptrUserName = DomainName+i+1;
                        continue;
                    }
                }

                //
                // If the username pointer is still NULL, then we didn't hit a \
                // in the input string, so it's not valid. Terminate with usage error
                //
                if ((ptrUserName == NULL) || (*ptrUserName == L'\0')) {
                    wsprintf(g_TempString, L"Invalid UserName and DomainName\n");
                    DisplayMessage(g_TempString);
                    dwRetCode = ERROR_BAD_USERNAME;
                    goto cleanup;
                }

                dwRetCode = SetRegValueSZ(L"DefaultUserName", ptrUserName);
                if (dwRetCode != ERROR_SUCCESS) {
                    wsprintf(g_TempString, L"DefaultUserName   : Set Failed: %s\n", GetErrorString(dwRetCode));
                    DisplayMessage(g_TempString);
                    goto cleanup;
                }
                wsprintf(g_TempString, L"DefaultUserName   : %s\n", ptrUserName);
                DisplayMessage(g_TempString);

                SetRegValueSZ(L"DefaultDomainName", DomainName);
                if (dwRetCode != ERROR_SUCCESS) {
                    wsprintf(g_TempString, L"DefaultDomainName : Set Failed: %s\n", GetErrorString(dwRetCode));
                    DisplayMessage(g_TempString);
                    goto cleanup;
                }
                wsprintf(g_TempString, L"DefaultDomainName : %s\n", DomainName);
                DisplayMessage(g_TempString);
            }

            //
            // set the password
            //
            dwRetCode = SetSecret(argv[dwCommandPosition+1], FALSE);
            if (dwRetCode != ERROR_SUCCESS) {
                wsprintf(g_TempString, L"LSASecret         : Set Failed: %s\n", GetErrorString(dwRetCode));
                DisplayMessage(g_TempString);
                goto cleanup;
            }

#ifdef PRIVATE_VERSION
            wsprintf(g_TempString, L"LSASecret         : %s\n", argv[dwCommandPosition+1]);
#else
            wsprintf(g_TempString, L"LSASecret         : (set)\n");
#endif
            DisplayMessage(g_TempString);

            //
            // set the AutoAdminLogon regvalue to 1
            //
            dwRetCode = SetRegValueSZ(L"AutoAdminLogon", L"1");
            if (dwRetCode != ERROR_SUCCESS) {
                wsprintf(g_TempString, L"AutoAdminLogon    : Set Failed: %s\n", GetErrorString(dwRetCode));
                DisplayMessage(g_TempString);
                goto cleanup;
            }

            DisplayMessage(L"AutoAdminLogon    : 1\n");


            break;

        //
        // not a valid command, display usage
        //
        default:
            dwRetCode = ERROR_BAD_ARGUMENTS;
            goto cleanup;
    }

cleanup:
    if (dwRetCode == ERROR_BAD_ARGUMENTS) {
        DumpCmd();
    }
    return dwRetCode;
}


DWORD
MigratePassword() 
{
    WCHAR Password[MAX_STRING];
    DWORD dwRetCode = ERROR_SUCCESS;

    if (CheckWinVersion() != ERROR_SUCCESS) {
        dwRetCode = ERROR_OLD_WIN_VERSION;
        goto cleanup;
    }

    // Get the DefaultPassword registry key from the local
    // or remote system and store it in a local string
    dwRetCode = GetRegValueSZ(L"DefaultPassword", Password);
    if (dwRetCode == ERROR_FILE_NOT_FOUND) {
        DisplayMessage(L"Migrate failed: DefaultPassword regkey does not exist.\n");
        goto cleanup;
    }
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_TempString, L"Migrate Failed: Could not read DefaultPassword RegKey: %s\n", GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    // Set the DefaultPassword LSAsecret to the value we retrieved from the registry
    dwRetCode = SetSecret(Password, 0);
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_TempString, L"Migrate Failed: Could not set DefaultPassword LSASecret: %s\n", GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    // zero out the password so it's not left in memory
    ZeroMemory(Password, MAX_STRING * sizeof(WCHAR));

    // Delete the DefaultPassword registry key
    dwRetCode = ClearRegPassword();
    if (dwRetCode != ERROR_SUCCESS) {
        wsprintf(g_TempString, L"Migrate Failed: Could not delete DefaultPassword RegKey: %s\n", GetErrorString(dwRetCode));
        DisplayMessage(g_TempString);
        goto cleanup;
    }

    DisplayMessage(L"Password migrated from Registry to LSASecret\n");

cleanup:
    return dwRetCode;
}


DWORD
ListAll()
{
    WCHAR wcsTempString[MAX_STRING];
    DWORD dwRetCode = ERROR_SUCCESS;

    //
    // Get the username
    //
    dwRetCode = GetRegValueSZ(L"DefaultUserName", wcsTempString);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"DefaultUserName  : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            wsprintf(g_TempString, L"DefaultUserName  : %s\n", wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"DefaultUserName  : Failed to query regkey: %s\n", GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the DefaultDomainName
    //
    dwRetCode = GetRegValueSZ(L"DefaultDomainName", wcsTempString);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"DefaultDomainName: (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            wsprintf(g_TempString, L"DefaultDomainName: %s\n", wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"DefaultDomainName: Failed to query regkey: %s\n", GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

    //
    // Get the DefaultPassword
    //
    dwRetCode = GetRegValueSZ(L"DefaultPassword", wcsTempString);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"DefaultPassword  : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            wsprintf(g_TempString, L"DefaultPassword  : %s\n", wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"DefaultPassword  : Failed to query regkey: %s\n", GetErrorString(dwRetCode));
            goto cleanup;
    }

    //
    // Get the AutoAdminLogon
    //
    dwRetCode = GetRegValueSZ(L"AutoAdminLogon", wcsTempString);
    switch (dwRetCode) {
        // catch this case and continue
        case ERROR_FILE_NOT_FOUND:
            wsprintf(g_TempString, L"AutoAdminLogon   : (regvalue does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
            wsprintf(g_TempString, L"AutoAdminLogon   : %s\n", wcsTempString);
            wsprintf(g_TempString, L"AutoAdminLogon   : %s\n", wcsTempString);
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"AutoAdminLogon   : Failed to query regkey: %s\n", GetErrorString(dwRetCode));
            goto cleanup;
    }

    //
    // Get the LSASecret DefaultPassword
    //
    dwRetCode = GetSecret(wcsTempString);
    switch (dwRetCode) {
        // catch this case and continue
        case STATUS_OBJECT_NAME_NOT_FOUND:
            wsprintf(g_TempString, L"LSASecret        : (secret does not exist)\n");
            DisplayMessage(g_TempString);
            break;

        // catch this case and continue
        case ERROR_ACCESS_DENIED:
            wsprintf(g_TempString, L"LSASecret        : (access denied)\n");
            DisplayMessage(g_TempString);
            break;

        // On success, print the regkey and continue to next item
        case ERROR_SUCCESS:
#ifdef PRIVATE_VERSION
            wsprintf(g_TempString, L"LSASecret        : %s\n", wcsTempString);
#else
            wsprintf(g_TempString, L"LSASecret        : (set)\n");
#endif
            DisplayMessage(g_TempString);
            break;

        // catch all the generic errors and end program
        default:
            wsprintf(g_TempString, L"LSASecret        : Failed to query LSASecret: %s\n", GetErrorString(dwRetCode));
            DisplayMessage(g_TempString);
            goto cleanup;
    }

cleanup:
    ZeroMemory(g_TempString, MAX_STRING * sizeof(WCHAR));
    ZeroMemory(wcsTempString, MAX_STRING * sizeof(WCHAR));
    return dwRetCode;

}


DWORD
CheckWinVersion()
{
    DWORD dwMachineVerNumber = 0;
    DWORD dwRetCode = ERROR_SUCCESS;

    // Make sure it's a Win2k box
    if (g_RemoteOperation) {
        dwMachineVerNumber = GetMajorNTVersion(g_RemoteComputerName);
    } else {
        dwMachineVerNumber = GetMajorNTVersion(NULL);
    }

    switch (dwMachineVerNumber) {
    case 3:
            wprintf(L"Error, target is running NT3.x\n");
            dwRetCode = ERROR_OLD_WIN_VERSION;
            break;
    case 4:
        if ((dwMachineVerNumber == 4) && (g_CheckNT4Also)) {
            break;
        } else {
            wprintf(L"Error, target is running NT4 and /nt4 option not selected\n");
            dwRetCode = ERROR_OLD_WIN_VERSION;
            break;
        }
    case 5:
        break;
    default:
        wprintf(L"Error target's machine version is invalid\n");
        dwRetCode = ERROR_OLD_WIN_VERSION;
        break;
    }

    return dwRetCode;
}


VOID
DumpCmd()
{
        wprintf(L"AUTOLOGON v0.91 (01/22/01): (c) 2001, Microsoft Corporation (jasong@microsoft.com)\n\n");
        wprintf(L"DESCRIPTION:\n");
        wprintf(L"   Used to configure encrypted autologon functionality in Windows 2000\n");
        wprintf(L"USAGE:\n");
        wprintf(L"   AUTOLOGON [/?] [/q] [/nt4] [\\\\machine] </command> [password] [domain\\username]\n");
        wprintf(L"    Options:\n");
        wprintf(L"      /?         Display complete help documentation\n");
        wprintf(L"      /q         Enable quiet mode, which supresses all output\n");
        wprintf(L"      /nt4       Permit set and migrate options against NT4 boxes\n");
        wprintf(L"      \\\\machine  If specified, the UNC name of the machine to configure\n");
        wprintf(L"    Commands:\n");
        wprintf(L"      /m         Migrate cleartext password from DefaultPassword to LSASecret\n");
        wprintf(L"      /xs        Delete the DefaultPassword LSASecret\n");
        wprintf(L"      /xr        Delete the DefaultPassword RegKey\n");
        wprintf(L"      /l         Dump autologon settings\n");
        wprintf(L"      /s         Set the DefaultPassword LSASecret and enbable AutoAdminLogon\n");
        wprintf(L"      password   The password of the user account specified in DefaultUserName\n");
        wprintf(L"      domain     The domain name to set in DefaultDomainName\n");
        wprintf(L"      username   The username to set in Default UserName\n");
// add the following to the usage notes
/*
        wprintf(L"Notes:\n");
        wprintf(L"    1.You need to be running as a member of the local adminsitrators group for\n");
        wprintf(L"      this utility to work properly.\n");
        wprintf(L"    2.When setting a password that has special characters in it, such as \"|>&\n");
        wprintf(L"      make sure that you escape these characters. Also, passwords with spaces \n");
        wprintf(L"      should be enclosed in double quotes.\n");
*/
} // DumpCmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\cacls2\common\caclscom.c ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    calcscom.c

Abstract:

    Support routines for dacls/sacls exes

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <caclscom.h>
#include <dsysdbg.h>
#include <aclapi.h>
#include <stdio.h>
#include <wcstr.h>

#include <seopaque.h>
#include <sertlp.h>


DWORD
ConvertCmdlineRights(
    IN  PSTR                pszCmdline,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    OUT DWORD              *pConvertedRights
    )
/*++

Routine Description:

    Parses the given command line string that corresponds to a given rights
    list.  The individual righs entry are looked up in the rights table and
    added to the list of converted rights

Arguments:

    pszCmdline - The list of string rights to convert

    pRightsTable - The mapping from the string rights to the new win32 rights.
        It is expected that the rights table string tags will all be in upper
        case upon function entry.

    cRights - The number of items in the rights table

    pConvertedRights - Where the converted access mask is returned

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_INVALID_PARAMETER -- An unexpected string right was encountered


--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    PSTR    pszCurrent = pszCmdline;
    INT     i;
#if DBG
    INT     j;
#endif

    *pConvertedRights = 0;

    //
    // Allow empty lists
    //
    if (pszCurrent == NULL) {

        return(ERROR_SUCCESS);

    }

    //
    // Assert that the table is upper case as expected
    //
#if DBG
    for (i = 0; i < cRights; i++) {

        for (j = 0; j < 2; j++) {

            if(toupper(pRightsTable[i].szRightsTag[j]) != pRightsTable[i].szRightsTag[j]) {

                dwErr = ERROR_INVALID_PARAMETER;
                break;

            }
        }
    }
#endif


    while (dwErr == ERROR_SUCCESS && *pszCurrent != '\0') {

        dwErr = ERROR_INVALID_PARAMETER;

        for (i = 0; i < cRights; i++ ) {

            if (pRightsTable[i].szRightsTag[0] ==
                                                toupper(*pszCurrent) &&
                pRightsTable[i].szRightsTag[1] ==
                                                toupper(*(pszCurrent + 1))) {

                dwErr = ERROR_SUCCESS;
                *pConvertedRights |= pRightsTable[i].Right;
                break;

            }
        }

        pszCurrent++;

        if (*pszCurrent != '\0') {

            pszCurrent++;
        }
    }

    return(dwErr);
}




DWORD
ParseCmdline (
    IN  PSTR               *ppszArgs,
    IN  INT                 cArgs,
    IN  INT                 cSkip,
    IN  PCACLS_CMDLINE      pCmdValues,
    IN  INT                 cCmdValues
    )
/*++

Routine Description:

    Parses the command line against the given cmd values.

Arguments:

    ppszArgs - The argument list

    cArgs - Count of arguments in the list

    cSkip - Number of initial arguments to skip

    pCmdValues - Command values list to process the command line against

    cCmdValues - Number of command values in the list

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_INVALID_PARAMETER -- An unexpected command line value was found


--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    INT     i,j;

    i = cSkip;

    while (i < cArgs && dwErr == ERROR_SUCCESS) {

        if( *ppszArgs[i] == '/' || *ppszArgs[i] == '-') {

            for (j = 0; j < cCmdValues; j++) {

                if (_stricmp(ppszArgs[i] + 1, pCmdValues[j].pszSwitch) == 0) {

                    if (pCmdValues[j].iIndex != -1) {

                        dwErr = ERROR_INVALID_PARAMETER;

                    } else {

                        pCmdValues[j].iIndex = i;

                        //
                        // See if we need to skip some number of values
                        //

                        if (pCmdValues[j].fFindNextSwitch == TRUE ) {

                            pCmdValues[j].cValues = 0;

                            while (i + 1 < cArgs) {

                                if (*ppszArgs[i + 1] != '/' &&
                                    *ppszArgs[i + 1] != '-') {

                                    pCmdValues[j].cValues++;
                                    i++;
                                } else {

                                    break;
                                }
                            }
                        }
                    }


                    break;
                }
            }

            if (j == cCmdValues) {

                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } else {

            dwErr = ERROR_INVALID_PARAMETER;
        }

        i++;
    }

    return(dwErr);
}




DWORD
ProcessOperation (
    IN  PSTR               *ppszCmdline,
    IN  PCACLS_CMDLINE      pCmdInfo,
    IN  ACCESS_MODE         AccessMode,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    IN  DWORD               fInherit,
    IN  PACL                pOldAcl      OPTIONAL,
    OUT PACL               *ppNewAcl
    )
/*++

Routine Description:

    Performs an "operation", such as Grant, Revoke, Deny.  It parses the given command values
    into User/Permission pairs, and then creates a new security descriptor.  The returned
    security descriptor needs to be freed via LocalFree.

Arguments:

    ppszCmdline - The command line argument list

    pCmdInfo - Information about where this operation lives in the comand line

    AccessMode - Type of operation (Grant/Revoke/Deny) to do

    pRightsTable - The mapping from the string rights to the new win32 rights.
        It is expected that the rights table string tags will all be in upper
        case upon function entry.

    cRights - The number of items in the rights table

    fInherit - Inheritance flags to apply

    pOldAcl - Optional.  If present, this is the ACL off of the object in the edit case.

    ppNewAcl - Where the new ACL is returned.


Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_INVALID_PARAMETER -- The switch was specified, but no user/perms pairs were found
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed.

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    PEXPLICIT_ACCESS_A  pNewAccess = NULL;
    PSTR    pszRights;
    INT     i;
    DWORD   dwRights;

    //
    // Make sure we have valid parameters
    //
    if (pCmdInfo->iIndex != -1 && pCmdInfo->cValues == 0) {

        return(ERROR_INVALID_PARAMETER);
    }

    pNewAccess = (PEXPLICIT_ACCESS_A)LocalAlloc(LMEM_FIXED,
                                                sizeof(EXPLICIT_ACCESS_A) * pCmdInfo->cValues);
    if (pNewAccess == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Otherwise, start parsing and converting...
    //
    for (i = 0; i < (INT)pCmdInfo->cValues && dwErr == ERROR_SUCCESS; i++) {

        pszRights = strchr(ppszCmdline[pCmdInfo->iIndex + i + 1], ':');

        if (pszRights == NULL && AccessMode != REVOKE_ACCESS) {

            dwErr = ERROR_INVALID_PARAMETER;

        } else {

            if (pszRights != NULL) {

                *pszRights = '\0';
                pszRights++;

            }

            dwErr = ConvertCmdlineRights(pszRights,
                                         pRightsTable,
                                         cRights,
                                         &dwRights);

            if (dwErr == ERROR_SUCCESS) {

                BuildExplicitAccessWithNameA(&pNewAccess[i],
                                             ppszCmdline[pCmdInfo->iIndex + i + 1],
                                             dwRights,
                                             AccessMode,
                                             fInherit);
            }

        }
    }

    //
    // If all of that worked, we'll apply it to the new security descriptor
    //
    if (dwErr == ERROR_SUCCESS) {

        dwErr = SetEntriesInAclA(pCmdInfo->cValues,
                                 pNewAccess,
                                 pOldAcl,
                                 ppNewAcl);
    }


    LocalFree(pNewAccess);
    return(dwErr);
}




DWORD
SetAndPropagateFileRights (
    IN  PSTR                    pszFilePath,
    IN  PACL                    pAcl,
    IN  SECURITY_INFORMATION    SeInfo,
    IN  BOOL                    fPropagate,
    IN  BOOL                    fContinueOnDenied,
    IN  BOOL                    fBreadthFirst,
    IN  DWORD                   fInherit
    )
/*++

Routine Description:

    This function will set [and propagate] the given acl to the specified path and optionally all
    of its children.  In the event of an access denied error, this function may or may not
    terminate, depending on the state of the fContinueOnDenied flag. This function does a depth
    first search with a write on return.  This function is recursive.

Arguments:

    pszFilePath - The file path to set the ACL on

    pAcl - The acl to set

    SeInfo - Whether the DACL or SACL is being set

    fPropagate - Determines whether the function should propagate or not

    fContinueOnDenied - Determines the behavior when an access denied is encountered.

    fBreadthFirst - If TRUE, do a breadth first propagation.  Otherwise, do a depth first

    fInherit - Optional inheritance flags to apply

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed.

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;

    PSTR                pszFullPath = NULL;
    PSTR                pszSearchPath = NULL;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    DWORD               cPathLen = 0;
    WIN32_FIND_DATAA    FindData;
    BOOL                fRestoreWhack = FALSE;
    PACE_HEADER         pAce;
    DWORD               iAce;


    if ( fInherit != 0 ) {

        pAce = (PACE_HEADER)FirstAce(pAcl);

        for ( iAce = 0;
              iAce < pAcl->AceCount && dwErr == ERROR_SUCCESS;
              iAce++, pAce = (PACE_HEADER)NextAce(pAce) ) {

              pAce->AceFlags |= (UCHAR)fInherit;
        }
    }

    //
    // If we're doing a breadth first propagation, set the security first
    //
    if ( fBreadthFirst == TRUE ) {

        dwErr = SetNamedSecurityInfoA(pszFilePath, SE_FILE_OBJECT, SeInfo, NULL, NULL,
                                      SeInfo == DACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL,
                                      SeInfo == SACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL);
    }

    if (fPropagate == TRUE) {

        cPathLen = strlen(pszFilePath);

        pszSearchPath = (PSTR)LocalAlloc(LMEM_FIXED, cPathLen + 1 + 4);

        if (pszSearchPath == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            if (pszFilePath[cPathLen - 1] == '\\') {

                pszFilePath[cPathLen - 1] = '\0';
                cPathLen--;
                fRestoreWhack = TRUE;
            }

            sprintf(pszSearchPath, "%s\\%s", pszFilePath, "*.*");

            hFind = FindFirstFileA(pszSearchPath,
                                   &FindData);
            if (hFind == INVALID_HANDLE_VALUE) {

                dwErr = GetLastError();

            }
        }


        //
        // Start processing all the files
        //
        while (dwErr == ERROR_SUCCESS) {

            //
            // Ignore the . and ..
            //
            if (strcmp(FindData.cFileName, ".") != 0 &&
                strcmp(FindData.cFileName, "..") != 0) {

                //
                // Now, build the full path...
                //
                pszFullPath = (PSTR)LocalAlloc(LMEM_FIXED,
                                               cPathLen + 1 + strlen(FindData.cFileName) + 1);
                if (pszFullPath == NULL) {

                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                } else  {

                    sprintf(pszFullPath, "%s\\%s", pszFilePath, FindData.cFileName);

                    //
                    // Call ourselves
                    //
                    dwErr = SetAndPropagateFileRights(pszFullPath, pAcl, SeInfo,
                                                      fPropagate, fContinueOnDenied, fBreadthFirst,
                                                      fInherit);

                    if (dwErr == ERROR_ACCESS_DENIED && fContinueOnDenied == TRUE) {

                        dwErr = ERROR_SUCCESS;
                    }

                }
            }


            if (dwErr == ERROR_SUCCESS && FindNextFile(hFind, &FindData) == FALSE) {

                dwErr = GetLastError();
            }
        }

        if(dwErr == ERROR_NO_MORE_FILES)
        {
            dwErr = ERROR_SUCCESS;
        }
    }

    //
    // Cover the case where it is a file
    //
    if (dwErr == ERROR_DIRECTORY) {

        dwErr = ERROR_SUCCESS;
    }


    //
    // Now, do the set
    //
    if (dwErr == ERROR_SUCCESS && fBreadthFirst == FALSE) {

        dwErr = SetNamedSecurityInfoA(pszFilePath, SE_FILE_OBJECT, SeInfo, NULL, NULL,
                                      SeInfo == DACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL,
                                      SeInfo == SACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL);

    }

    if (fRestoreWhack == TRUE) {

        pszFilePath[cPathLen - 1] = '\\';
        pszFilePath[cPathLen] = '\0';

    }

    //
    // If necessary, restore the inheritance flags
    //
    if ( fInherit != 0 ) {

        pAce = (PACE_HEADER)FirstAce(pAcl);

        for ( iAce = 0;
              iAce < pAcl->AceCount && dwErr == ERROR_SUCCESS;
              iAce++, pAce = (PACE_HEADER)NextAce(pAce) ) {

              pAce->AceFlags &= (UCHAR)~fInherit;
        }
    }


    return(dwErr);
}




DWORD
DisplayAcl (
    IN  PSTR                pszPath,
    IN  PACL                pAcl,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights
    )
/*++

Routine Description:

    This function will display the given acl to the screen

Arguments:

    pszPath - The file path to be displayed

    pAcl - The Acl to display

    pRightsTable - List of available rights

    cRights - Number of rights in the list

Return Value:

    ERROR_SUCCESS   --  Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    ACL_SIZE_INFORMATION        AclSize;
    ACL_REVISION_INFORMATION    AclRev;
    PKNOWN_ACE                  pAce;
    PSID                        pSid;
    DWORD                       iIndex;
    PSTR                        pszName;
    INT                         i,cPathLen, iSkip, j;
    PSTR                        pszAceTypes[] = {"ACCESS_ALLOWED_ACE_TYPE",
                                                 "ACCESS_DENIED_ACE_TYPE",
                                                 "SYSTEM_AUDIT_ACE_TYPE",
                                                 "SYSTEM_ALARM_ACE_TYPE",
                                                 "ACCESS_ALLOWED_COMPOUND_ACE_TYPE",
                                                 "ACCESS_ALLOWED_OBJECT_ACE_TYPE",
                                                 "ACCESS_DENIED_OBJECT_ACE_TYPE",
                                                 "SYSTEM_AUDIT_OBJECT_ACE_TYPE",
                                                 "SYSTEM_ALARM_OBJECT_ACE_TYPE"};
    PSTR                        pszInherit[] = {"OBJECT_INHERIT_ACE",
                                                "CONTAINER_INHERIT_ACE",
                                                "NO_PROPAGATE_INHERIT_ACE",
                                                "INHERIT_ONLY_ACE",
                                                "INHERITED_ACE"};

    fprintf(stdout, "%s: ", pszPath);
    cPathLen = strlen(pszPath) + 2;

    if (pAcl == NULL) {

        fprintf(stdout, "NULL acl\n");

    } else {

        if (GetAclInformation(pAcl, &AclRev, sizeof(ACL_REVISION_INFORMATION),
                              AclRevisionInformation) == FALSE) {

            return(GetLastError());
        }

        if(GetAclInformation(pAcl, &AclSize, sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE) {

            return(GetLastError());
        }

        fprintf(stdout, "AclRevision: %lu\n", AclRev.AclRevision);

        fprintf(stdout, "%*sAceCount: %lu\n", cPathLen, " ", AclSize.AceCount);
        fprintf(stdout, "%*sInUse: %lu\n", cPathLen, " ", AclSize.AclBytesInUse);
        fprintf(stdout, "%*sFree: %lu\n", cPathLen, " ", AclSize.AclBytesFree);
        fprintf(stdout, "%*sFlags: %lu\n", cPathLen, " ", pAcl->Sbz1);


        //
        // Now, dump all of the aces
        //
        pAce = FirstAce(pAcl);
        for(iIndex = 0; iIndex < pAcl->AceCount; iIndex++) {

            cPathLen = strlen(pszPath) + 2;

            fprintf(stdout, "  %*sAce [%3lu]: ", cPathLen, " ", iIndex);

            cPathLen += 13;

            fprintf(stdout, "Type:  %s\n", pAce->Header.AceType > ACCESS_MAX_MS_ACE_TYPE ?
                                                        "UNKNOWN ACE TYPE" :
                                                        pszAceTypes[pAce->Header.AceType]);
            fprintf(stdout, "%*sFlags: ", cPathLen, " ");
            if ( pAce->Header.AceFlags == 0 ) {

                fprintf(stdout, "0\n");

            } else {

                if (( pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) != 0 ) {

                    fprintf( stdout,"SUCCESSFUL_ACCESS_ACE_FLAG  " );
                }

                if (( pAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) != 0 ) {

                    if (( pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) != 0 ) {

                        fprintf( stdout, "| " );

                    }

                    fprintf( stdout,"FAILED_ACCESS_ACE_FLAG" );
                }

                iSkip = 0;

                if ( ( pAce->Header.AceFlags &
                                    (FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG)) != 0 &&
                     ( pAce->Header.AceFlags & VALID_INHERIT_FLAGS) != 0 ) {

                    iSkip = cPathLen + 7;
                }

                //
                // Now, the inheritance flags
                //
                for (j = 0; j < sizeof(pszInherit) / sizeof(PSTR) ; j++) {

                    if ((pAce->Header.AceFlags & (1 << j)) != 0 ) {

                        if (iSkip != 0) {

                            fprintf(stdout, "   |  \n");
                            fprintf(stdout, "%*s", iSkip, " ");
                        }

                        fprintf(stdout, "%s", pszInherit[j]);

                        if (iSkip == 0) {

                            iSkip = cPathLen + 7;

                        }

                    }
                }

                fprintf( stdout,"\n" );
            }

            fprintf(stdout, "%*sSize:  0x%lx\n", cPathLen, " ", pAce->Header.AceSize);

            fprintf(stdout, "%*sMask:  ", cPathLen, " ");

            if (pAce->Mask == 0) {
                fprintf(stdout, "%*sNo access\n", cPathLen, " ");
            } else {

                iSkip = 0;
                for (i = 1 ;i < cRights ;i++ ) {

                    if ((pAce->Mask & pRightsTable[i].Right) != 0) {

                        if (iSkip != 0) {

                            fprintf(stdout, "%*s", iSkip, " ");

                        } else {

                            iSkip = cPathLen + 7;
                        }

                        fprintf(stdout, "%s\n", pRightsTable[i].pszDisplayTag);
                    }
                }

            }

            //
            // Lookup the account name and return it...
            //
            //
            // If it's an object ace, dump the guids
            //
            dwErr = TranslateAccountName((PSID)&(pAce->SidStart), &pszName);
            if (dwErr == ERROR_SUCCESS) {

                fprintf(stdout, "%*sUser:  %s\n", cPathLen, " ", pszName);
                LocalFree(pszName);
            }

            fprintf( stdout, "\n" );

            pAce = NextAce(pAce);

        }
    }

    return(dwErr);
}




DWORD
TranslateAccountName (
    IN  PSID    pSid,
    OUT PSTR   *ppszName
    )
/*++

Routine Description:

    This function will "translate" a sid into a name by doing a LookupAccountSid on the sid

Arguments:

    pSid - The sid to convert to a name

    ppszName - Where the name is returned.  Must be freed via a call to LocalFree.

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    SID_NAME_USE    esidtype;
    LPSTR           pszDomain = NULL;
    LPSTR           pszName = NULL;
    ULONG           cName = 0;
    ULONG           cDomain = 0;


    if (LookupAccountSidA(NULL, pSid, NULL, &cName, NULL,  &cDomain, &esidtype) == FALSE) {

        dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            dwErr = ERROR_SUCCESS;

            //
            // Allocate for the name and the domain
            //
            pszName = (PSTR)LocalAlloc(LMEM_FIXED, cName);
            if (pszName != NULL) {

                pszDomain = (PSTR)LocalAlloc(LMEM_FIXED, cDomain);

                if (pszDomain == NULL) {

                    LocalFree(pszName);
                    pszName = NULL;
                }
            }


            if (pszName == NULL) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (dwErr == ERROR_SUCCESS) {

                if(LookupAccountSidA(NULL, pSid, pszName, &cName, pszDomain, &cDomain,
                                     &esidtype) == FALSE) {

                    dwErr = GetLastError();
                    LocalFree(pszName);
                    LocalFree(pszDomain);
                }
            }

        } else if (dwErr == ERROR_NONE_MAPPED) {

            UCHAR           String[256];
            UNICODE_STRING  SidStr;
            NTSTATUS        Status;

            dwErr = ERROR_SUCCESS;
            pszName = NULL;

            //
            // Ok, return the sid as a name
            //
            SidStr.Buffer = (PWSTR)String;
            SidStr.Length = SidStr.MaximumLength = 256;

            Status = RtlConvertSidToUnicodeString(&SidStr, pSid, FALSE);

            if (NT_SUCCESS(Status)) {

                pszName = (PSTR)LocalAlloc(LMEM_FIXED,
                                          wcstombs(NULL, SidStr.Buffer,
                                                   wcslen(SidStr.Buffer) + 1) + 1);
                if (pszName == NULL) {

                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    wcstombs(pszName, SidStr.Buffer, wcslen(SidStr.Buffer) + 1);
                }

            } else {

                dwErr = RtlNtStatusToDosError(Status);
            }

        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        ULONG   cLen;

        if(pszDomain != NULL && *pszDomain != '\0')
        {
            cLen = strlen(pszDomain) + 1;
            cLen += strlen(pszName) + 1;

            *ppszName = (PSTR)LocalAlloc(LMEM_FIXED, cLen);

            if (*ppszName == NULL) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                sprintf(*ppszName, "%s\\%s", pszDomain, pszName);
            }

        } else {

            *ppszName = pszName;
            pszName = NULL;
        }
    }


    LocalFree(pszDomain);
    LocalFree(pszName);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\autologon\oldsrc\forcemigrate\shared.h ===
#ifndef UNICODE
    #define    UNICODE
    #define    _UNICODE
#endif

//+---------------------------------------------------------------------------------------------------------
//
// Includes
//
//+---------------------------------------------------------------------------------------------------------
#include<stdio.h>
#include<stdlib.h>
#include<windows.h>
#include<winuser.h>
#include<ntsecapi.h>
#include<Winnetwk.h>
#include<lmserver.h>
#include<lmcons.h>
#include<lm.h>

//+---------------------------------------------------------------------------------------------------------
//
// Definitions
//
//+---------------------------------------------------------------------------------------------------------

// from NTSTATUS.H
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

// local definitions
#define MAX_STRING          255
#define WINLOGON_REGKEY     L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"

//
// define whether we want the public version, or the private version.
// in the public version:
//   - we don't display the LSASecret when we retrieve it on a -l call
//   - we make the remote registry calls requesting FULL CONTROL so that
//     you will need to be an admin on the target machine to run this.
//
#define PRIVATE_VERSION


//+---------------------------------------------------------------------------------------------------------
//
// Prototypes
//
//+---------------------------------------------------------------------------------------------------------

// from shared.c

VOID
DisplayMessage(
    WCHAR *MessageText);

WCHAR*
GetErrorString(
    DWORD dwErrorCode);

DWORD
GetRegValueSZ(
    WCHAR *RegValue,
    WCHAR *ValueName);

DWORD
ClearRegPassword();

DWORD
SetRegValueSZ(
    WCHAR *ValueName,
    WCHAR *ValueData);

DWORD 
GetRegistryHandle(
    HKEY   *hKey,
    REGSAM samDesired);

DWORD
GetPolicyHandle(
    LSA_HANDLE *LsaPolicyHandle);

DWORD
SetSecret(
    WCHAR *Password,
    BOOL bClearSecret);

DWORD
GetSecret(
    WCHAR *Password);

DWORD 
GetMajorNTVersion(
    WCHAR *Server);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\cacls2\sacls\sacls.c ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    sacls.c

Abstract:

    Extended version of cacls.exe

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <seopaque.h>
#include <windows.h>
#include <caclscom.h>
#include <dsysdbg.h>
#include <stdio.h>
#include <aclapi.h>

#define CMD_PRESENT(index, list)    ((list)[index].iIndex != -1)

#define NO_INHERIT_ONLY

//
// Enumeration of command tags
//
typedef enum _CMD_TAGS {
    CmdTree = 0,
    CmdEdit,
    CmdContinue,
    CmdSuccess,
    CmdRevoke,
    CmdFail,
    CmdICont,
    CmdIObj,
#ifndef NO_INHERIT_ONLY
    CmdIOnly,
#endif
    CmdIProp
} CMD_TAGS, *PCMD_TAGS;

VOID
Usage (
    IN  PCACLS_STR_RIGHTS   pStrRights,
    IN  INT                 cStrRights,
    IN  PCACLS_CMDLINE      pCmdVals
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    INT i;

    printf("Displays or modifies audit control lists (ACLs) of files.  You need \"Manage "
           "auditing and security log\" privilege to run this utility.\n\n" );

    printf("SACLS filename [/T] [/E] [/C] [/G user:perm] [/R user [...]]\n");
    printf("               [/P user:perm [...]] [/D user [...]]\n");
    printf("   filename      Displays ACLs.\n");
    printf("   /%s            Changes ACLs of specified files in\n", pCmdVals[CmdTree].pszSwitch);
    printf("                 the current directory and all subdirectories.\n");
    printf("   /%s            Edit ACL instead of replacing it.\n", pCmdVals[CmdEdit].pszSwitch);
    printf("   /%s            Continue on access denied errors.\n",
           pCmdVals[CmdContinue].pszSwitch);
    printf("   /%s user:perms Add specified user successful access auditing\n",
          pCmdVals[CmdSuccess].pszSwitch);
    printf("   /%s user       Revoke specified user's auditing rights (only valid with /E).\n",
           pCmdVals[CmdRevoke].pszSwitch);
    printf("   /%s user:perms Add specified user failed access auditing.\n",
           pCmdVals[CmdFail].pszSwitch);
    printf("   /%s            Mark the ace as CONTAINER_INHERIT (directory inherit)\n",
           pCmdVals[CmdICont].pszSwitch);
    printf("   /%s            Mark the ace as OBJECT_INHERIT\n", pCmdVals[CmdIObj].pszSwitch);
#ifndef NO_INHERIT_ONLY
    printf("   /%s            Mark the ace as INHERIT_ONLY\n", pCmdVals[CmdIOnly].pszSwitch);
#endif
    printf("   /%s            Mark the ace as INHERIT_NO_PROPAGATE\n",
          pCmdVals[CmdIProp].pszSwitch);
    printf("The list of supported perms for Success and Failure auditing are:\n");

    for (i = 0; i < cStrRights; i++) {

        printf("              %c%c  %s\n",
               pStrRights[i].szRightsTag[0],
               pStrRights[i].szRightsTag[1],
               pStrRights[i].pszDisplayTag);
    }


    printf("\nMultiple perms can be specified per user\n");

    printf("Wildcards can be used to specify more that one file in a command.\n");
    printf("You can specify more than one user in a command.\n\n");

    printf("Example: SACLS c:\\temp /S user1:GRGW user2:SDRC /F user3:GF\n");
}



DWORD
MergeAcls (
    IN  PACL    pOldAcl,
    IN  PACL    pNewAcl
    )
/*++

Routine Description:

    Merges the old acl into the new one, by combining any identical aces.  It is assumed that
    the destintation acl is of sufficient size.  No allocations will be done, but an error will
    be returned if it isn't

Arguments:

    pOldAcl - The acl to be merged

    pNewAcl - The acl to be merged into

Return Value:

    ERROR_SUCCESS -- Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    PACE_HEADER pNewAce, pOldAce;
    DWORD   iNewAce, iOldAce;
    BOOL    fFound;

    //
    // If the new acl is empty, simply copy the new one over
    //
    if (pNewAcl->AceCount == 0 ) {

        memcpy((PVOID)((PBYTE)pNewAcl + sizeof(ACL)), (PBYTE)pOldAcl + sizeof(ACL),
                                                pOldAcl->AclSize - sizeof(ACL));
        pNewAcl->AceCount = pOldAcl->AceCount;
        return(ERROR_SUCCESS);

    }

    pOldAce = (PACE_HEADER)FirstAce(pOldAcl);

    for ( iOldAce = 0;
          iOldAce < pOldAcl->AceCount && dwErr == ERROR_SUCCESS;
          iOldAce++, pOldAce = (PACE_HEADER)NextAce(pOldAce) ) {

        fFound = FALSE;

        //
        // We'll walk each of the existing acls, and try and compress the new
        // acls out of existance
        //
        pNewAce = (PACE_HEADER)FirstAce(pNewAcl);
        for ( iNewAce = 0;
              iNewAce < pOldAcl->AceCount && dwErr == ERROR_SUCCESS;
              iNewAce++, pNewAce = (PACE_HEADER)NextAce(pNewAce) ) {

            if ( EqualSid ( (PSID)(&((PSYSTEM_AUDIT_ACE)pNewAce)->SidStart),
                            (PSID)(&((PSYSTEM_AUDIT_ACE)pOldAce)->SidStart) ) &&
                 pNewAce->AceType == pOldAce->AceType &&
                 (pNewAce->AceFlags & VALID_INHERIT_FLAGS) == 0 &&
                 (pOldAce->AceFlags & VALID_INHERIT_FLAGS) == 0 &&
                 ((PSYSTEM_AUDIT_ACE)pNewAce)->Mask == ((PSYSTEM_AUDIT_ACE)pOldAce)->Mask) {

                ((PSYSTEM_AUDIT_ACE)pNewAce)->Mask |=
                                         ((PSYSTEM_AUDIT_ACE)pOldAce)->Mask;
                pNewAce->AceFlags |= pOldAce->AceFlags;
                fFound = TRUE;

                break;

            }
        }

        if ( fFound != TRUE ) {

            //
            // We'll have to add it
            //
            if ( !AddAuditAccessAce (
                        pNewAcl,
                        ACL_REVISION2,
                        ((PSYSTEM_AUDIT_ACE)pOldAce)->Mask,
                        (PSID)(&((PSYSTEM_AUDIT_ACE)pOldAce)->SidStart),
                        (pOldAce->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG),
                        (pOldAce->AceFlags & FAILED_ACCESS_ACE_FLAG) ) ) {

                dwErr = GetLastError();
                break;
            }
        }

    }


    return(dwErr);
}



INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    DWORD   dwErr = 0;
    CACLS_STR_RIGHTS   pStrRights[] = {
         "GR", GENERIC_READ, "Read",
         "GC", GENERIC_WRITE, "Change (write)",
         "GF", GENERIC_ALL, "Full rights",
         "SD", DELETE, "Delete",
         "RC", READ_CONTROL, "Read Control",
         "WP", WRITE_DAC, "Write DAC",
         "WO", WRITE_OWNER, "Write Owner",
         "RD", FILE_READ_DATA, "Read Data (on file) / List Directory (on Dir)",
         "WD", FILE_WRITE_DATA, "Write Data (on file) / Add File (on Dir)",
         "AD", FILE_APPEND_DATA, "Append Data (on file) / Add SubDir (on Dir)",
         "FE", FILE_EXECUTE, "Execute (on file) / Traverse (on Dir)",
         "DC", FILE_DELETE_CHILD, "Delete Child (on Dir only)",
         "RA", FILE_READ_ATTRIBUTES, "Read Attributes",
         "WA", FILE_WRITE_ATTRIBUTES, "Write Attributes",
         "RE", FILE_READ_EA, "Read Extended Attributes",
         "WE", FILE_WRITE_EA, "Write Extended Attributes"
        };
    INT cStrRights = sizeof(pStrRights) / sizeof(CACLS_STR_RIGHTS);
    CACLS_CMDLINE   pCmdVals[] = {
        "T", -1, FALSE, 0,              // CmdTree
        "E", -1, FALSE, 0,              // CmdEdit
        "C", -1, FALSE, 0,              // CmdContinue
        "S", -1, TRUE,  0,              // CmdSuccess
        "R", -1, TRUE,  0,              // CmdRevoke
        "F", -1, TRUE,  0,              // CmdFail
        "D", -1, FALSE, 0,              // CmdICont
        "O", -1, FALSE, 0,              // CmdIObj
#ifndef NO_INHERIT_ONLY
        "I", -1, FALSE, 0,              // CmdIOnly
#endif
        "N", -1, FALSE, 0,              // CmdIProp
        };
    INT cCmdVals = sizeof(pCmdVals) / sizeof(CACLS_CMDLINE);
    INT i;
    PSECURITY_DESCRIPTOR    pInitialSD = NULL, pFinalSD;
    PACL                    pOldAcl = NULL, pSuccessAcl = NULL, pFailAcl = NULL;
    DWORD                   fInherit = 0;
    HANDLE                  hProcessToken;


    if (argc < 2) {

        Usage( pStrRights, cStrRights, pCmdVals );
        return(1);

    } else if (argc == 2 && (strcmp(argv[1], "-?") == 0 || strcmp(argv[1], "/?") == 0)) {

        Usage( pStrRights, cStrRights, pCmdVals );
        return(0);

    }


    //
    // Parse the command line
    //
    dwErr = ParseCmdline(argv, argc, 2, pCmdVals, cCmdVals);

    if (dwErr != ERROR_SUCCESS) {

        Usage( pStrRights, cStrRights, pCmdVals );
        return(1);

    }

    //
    // Set our inheritance flags
    //
    if (CMD_PRESENT(CmdICont, pCmdVals)) {

        fInherit |= CONTAINER_INHERIT_ACE;
    }

    if (CMD_PRESENT(CmdIObj, pCmdVals)) {

        fInherit |= OBJECT_INHERIT_ACE;
    }

#ifndef NO_INHERIT_ONLY
    if (CMD_PRESENT(CmdIOnly, pCmdVals)) {

        fInherit |= INHERIT_ONLY_ACE;
    }
#endif

    if (CMD_PRESENT(CmdIProp, pCmdVals)) {

        fInherit |= NO_PROPAGATE_INHERIT_ACE;
    }


    //
    // Enable the read sacl privs
    //
    if ( OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &hProcessToken ) == FALSE) {

        dwErr = GetLastError();

    } else {

        TOKEN_PRIVILEGES EnableSeSecurity;
        TOKEN_PRIVILEGES Previous;
        DWORD PreviousSize;

        EnableSeSecurity.PrivilegeCount = 1;
        EnableSeSecurity.Privileges[0].Luid.LowPart = SE_SECURITY_PRIVILEGE;
        EnableSeSecurity.Privileges[0].Luid.HighPart = 0;
        EnableSeSecurity.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        PreviousSize = sizeof(Previous);

        if (AdjustTokenPrivileges( hProcessToken, FALSE, &EnableSeSecurity,
                                   sizeof(EnableSeSecurity), &Previous,
                                   &PreviousSize ) == FALSE) {

            dwErr = GetLastError();
        }
    }



    //
    // Ok, see if we need to read the existing security
    //
    if ( dwErr == ERROR_SUCCESS && (CMD_PRESENT(CmdEdit, pCmdVals) || argc == 2 )) {

        dwErr = GetNamedSecurityInfoA( argv[1], SE_FILE_OBJECT, SACL_SECURITY_INFORMATION,
                                       NULL, NULL, NULL, &pOldAcl, &pInitialSD );
        if ( dwErr != ERROR_SUCCESS ) {

            fprintf(stderr, "Failed to read the security off of %s: %lu\n", argv[1], dwErr);
        }

    }

    //
    // Either display the existing access or do the sets as requested
    //
    if (dwErr == ERROR_SUCCESS && argc == 2) {

        dwErr = DisplayAcl ( argv[1], pOldAcl, pStrRights, cStrRights );

    } else {

        //
        // Ok, first we do the revokes
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdRevoke, pCmdVals)) {

            PACL    pNewAcl;

            //
            // Make sure we've read it first...
            //
            if (CMD_PRESENT(CmdEdit, pCmdVals)) {

                dwErr = ProcessOperation( argv, &pCmdVals[CmdRevoke], REVOKE_ACCESS, pStrRights,
                                          cStrRights, fInherit, pOldAcl, &pNewAcl );

                if (dwErr == ERROR_SUCCESS) {

                    LocalFree(pOldAcl);
                    pOldAcl = pNewAcl;
                }

            } else {

                dwErr = ERROR_INVALID_PARAMETER;
            }

        }

        //
        // Then the audit failures
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdFail, pCmdVals)) {

            dwErr = ProcessOperation(argv, &pCmdVals[CmdFail], SET_AUDIT_FAILURE, pStrRights,
                                     cStrRights, 0, NULL, &pFailAcl);
        }

        //
        // Finally, the audit success
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdSuccess, pCmdVals)) {

            dwErr = ProcessOperation(argv, &pCmdVals[CmdSuccess], SET_AUDIT_SUCCESS, pStrRights,
                                     cStrRights, 0, NULL, &pSuccessAcl);

        }



        //
        // Finally, do the set
        //
        if (dwErr == ERROR_SUCCESS) {

            PACL    pNewAcl;
            USHORT  usSize = 0;

            //
            // In order to do this, we'll have to combine any of the up to 3 acls we created
            // above.  The order will be:
            //      FAILURE
            //      SUCCESS
            //      OLD SACL
            //
            if ( pOldAcl != NULL ) {

                usSize += pOldAcl->AclSize;
            }

            if ( pFailAcl != NULL ) {

                usSize += pFailAcl->AclSize;
            }

            if ( pSuccessAcl != NULL ) {

                usSize += pSuccessAcl->AclSize;
            }

            ASSERT(usSize != 0);

            pNewAcl = (PACL)LocalAlloc(LMEM_FIXED, sizeof(ACL) + usSize);

            if ( pNewAcl == NULL ) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                pNewAcl->AclRevision = ACL_REVISION2;
                pNewAcl->Sbz1 = 0;
                pNewAcl->AclSize = usSize + sizeof(ACL);
                pNewAcl->AceCount = 0;
                pNewAcl->Sbz2 = 0;

                if( pFailAcl != NULL ) {

                    dwErr = MergeAcls( pFailAcl, pNewAcl );

                }

                if( pSuccessAcl != NULL ) {

                    dwErr = MergeAcls( pSuccessAcl, pNewAcl );

                }


                if( pOldAcl != NULL ) {

                    dwErr = MergeAcls( pOldAcl, pNewAcl );
                }

            }

            if (dwErr == ERROR_SUCCESS ) {

                dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, SACL_SECURITY_INFORMATION,
                                                  CMD_PRESENT(CmdTree, pCmdVals),
                                                  CMD_PRESENT(CmdContinue, pCmdVals), TRUE,
                                                  fInherit);

                LocalFree(pNewAcl);
            }
        }

        if (dwErr == ERROR_INVALID_PARAMETER) {

            Usage( pStrRights, cStrRights, pCmdVals );
        }

        LocalFree(pInitialSD);
    }

    LocalFree(pOldAcl);
    LocalFree(pFailAcl);
    LocalFree(pSuccessAcl);

    if(dwErr == ERROR_SUCCESS) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error %lu\n", dwErr);

    }

    return(dwErr == 0 ? 0 : 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\cacls2\common\caclscom.h ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    calcscom.h

Abstract:

    Support routines for dacls/sacls exes

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#ifndef __CACLSCOM_H__
#define __CACLSCON_H__

#include <accctrl.h>

typedef struct _CACLS_STR_RIGHTS_
{
    CHAR    szRightsTag[2];
    DWORD   Right;
    PSTR    pszDisplayTag;

} CACLS_STR_RIGHTS, *PCACLS_STR_RIGHTS;


typedef struct _CACLS_CMDLINE
{
    PSTR    pszSwitch;
    INT     iIndex;
    BOOL    fFindNextSwitch;
    DWORD   cValues;
} CACLS_CMDLINE, *PCACLS_CMDLINE;

//
// Function prototypes
//
DWORD
ConvertCmdlineRights (
    IN  PSTR                pszCmdline,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    OUT DWORD              *pConvertedRights
    );

DWORD
ParseCmdline (
    IN  PSTR               *ppszArgs,
    IN  INT                 cArgs,
    IN  INT                 cSkip,
    IN  PCACLS_CMDLINE      pCmdValues,
    IN  INT                 cCmdValues
    );

DWORD
ProcessOperation (
    IN  PSTR               *ppszCmdline,
    IN  PCACLS_CMDLINE      pCmdInfo,
    IN  ACCESS_MODE         AccessMode,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    IN  DWORD               fInherit,
    IN  PACL                pOldAcl      OPTIONAL,
    OUT PACL               *ppNewAcl
    );

DWORD
SetAndPropagateFileRights (
    IN  PSTR                    pszFilePath,
    IN  PACL                    pAcl,
    IN  SECURITY_INFORMATION    SeInfo,
    IN  BOOL                    fPropagate,
    IN  BOOL                    fContinueOnDenied,
    IN  BOOL                    fBreadthFirst,
    IN  DWORD                   fInherit
    );

DWORD
DisplayAcl (
    IN  PSTR                pszPath,
    IN  PACL                pAcl,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights
    );

DWORD
TranslateAccountName (
    IN  PSID    pSid,
    OUT PSTR   *ppszName
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\cacls2\dacls\dacls.c ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dacls.c

Abstract:

    Extended version of cacls.exe

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <windows.h>
#include <caclscom.h>
#include <dsysdbg.h>
#include <stdio.h>
#include <aclapi.h>

#define CMD_PRESENT(index, list)    ((list)[index].iIndex != -1)

#define NO_INHERIT_ONLY

//
// Enumeration of command tags
//
typedef enum _CMD_TAGS {
    CmdTree = 0,
    CmdEdit,
    CmdContinue,
    CmdGrant,
    CmdRevoke,
    CmdReplace,
    CmdDeny,
    CmdICont,
    CmdIObj,
#ifndef NO_INHERIT_ONLY
    CmdIOnly,
#endif
    CmdIProp
} CMD_TAGS, *PCMD_TAGS;


VOID
Usage (
    IN  PCACLS_STR_RIGHTS   pStrRights,
    IN  INT                 cStrRights,
    IN  PCACLS_CMDLINE      pCmdVals
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    INT i;

    printf("Displays or modifies access control lists (ACLs) of files\n\n");
    printf("DACLS filename [/T] [/E] [/C] [/G user:perm] [/R user [...]]\n");
    printf("               [/P user:perm [...]] [/D user [...]]\n");
    printf("   filename      Displays ACLs.\n");
    printf("   /%s            Changes ACLs of specified files in\n", pCmdVals[CmdTree].pszSwitch);
    printf("                 the current directory and all subdirectories.\n");
    printf("   /%s            Edit ACL instead of replacing it.\n", pCmdVals[CmdEdit].pszSwitch);
    printf("   /%s            Continue on access denied errors.\n", pCmdVals[CmdContinue].pszSwitch);
    printf("   /%s user:perms Grant specified user access rights .\n", pCmdVals[CmdGrant].pszSwitch);
    printf("   /%s user       Revoke specified user's access rights (only valid with /E).\n", pCmdVals[CmdRevoke].pszSwitch);
    printf("   /%s user:perms Replace specified user's access rights.\n", pCmdVals[CmdReplace].pszSwitch);
    printf("   /%s user:perms Deny specified user access.\n", pCmdVals[CmdDeny].pszSwitch);
    printf("   /%s            Mark the ace as CONTAINER_INHERIT (folder or directory inherit)\n", pCmdVals[CmdICont].pszSwitch);
    printf("   /%s            Mark the ace as OBJECT_INHERIT\n", pCmdVals[CmdIObj].pszSwitch);
#ifndef NO_INHERIT_ONLY
    printf("   /%s            Mark the ace as INHERIT_ONLY\n", pCmdVals[CmdIOnly].pszSwitch);
#endif
    printf("   /%s            Mark the ace as INHERIT_NO_PROPAGATE\n", pCmdVals[CmdIProp].pszSwitch);
    printf("The list of supported perms for the Grant and Replace operations are:\n");

    for (i = 0; i < cStrRights; i++) {

        printf("              %c%c  %s\n",
               pStrRights[i].szRightsTag[0],
               pStrRights[i].szRightsTag[1],
               pStrRights[i].pszDisplayTag);
    }


    printf("\nMultiple perms can be specified per user\n");

    printf("Wildcards can be used to specify more that one file in a command.\n");
    printf("You can specify more than one user in a command.\n\n");

    printf("Example: DACLS c:\\temp /G user1:GRGW user2:SDRC\n");
}


INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    DWORD   dwErr = 0;
    CACLS_STR_RIGHTS   pStrRights[] = {
         "NA", 0, "No Access",
         "GR", GENERIC_READ, "Read",
         "GC", GENERIC_WRITE, "Change (write)",
         "GF", GENERIC_ALL, "Full control",
         "SD", DELETE, "Delete",
         "RC", READ_CONTROL, "Read Control",
         "WP", WRITE_DAC, "Write DAC",
         "WO", WRITE_OWNER, "Write Owner",
         "RD", FILE_READ_DATA, "Read Data (on file) / List Directory (on Dir)",
         "WD", FILE_WRITE_DATA, "Write Data (on file) / Add File (on Dir)",
         "AD", FILE_APPEND_DATA, "Append Data (on file) / Add SubDir (on Dir)",
         "FE", FILE_EXECUTE, "Execute (on file) / Traverse (on Dir)",
         "DC", FILE_DELETE_CHILD, "Delete Child (on Dir only)",
         "RA", FILE_READ_ATTRIBUTES, "Read Attributes",
         "WA", FILE_WRITE_ATTRIBUTES, "Write Attributes",
         "RE", FILE_READ_EA, "Read Extended Attributes",
         "WE", FILE_WRITE_EA, "Write Extended Attributes"
        };
    INT cStrRights = sizeof(pStrRights) / sizeof(CACLS_STR_RIGHTS);
    CACLS_CMDLINE   pCmdVals[] = {
        "T", -1, FALSE, 0,      // CmdTree
        "E", -1, FALSE, 0,      // CmdEdit
        "C", -1, FALSE, 0,      // CmdContinue
        "G", -1, TRUE,  0,      // CmdGrant
        "R", -1, TRUE,  0,      // CmdRevoke
        "P", -1, TRUE,  0,      // CmdReplace
        "D", -1, TRUE,  0,      // CmdDeny
        "F", -1, FALSE, 0,      // CmdICont
        "O", -1, FALSE, 0,      // CmdIObj
#ifndef NO_INHERIT_ONLY
        "I", -1, FALSE, 0,     // CmdIOnly
#endif
        "N", -1, FALSE, 0,      // CmdIProp
        };
    INT cCmdVals = sizeof(pCmdVals) / sizeof(CACLS_CMDLINE);
    INT i;
    PSECURITY_DESCRIPTOR    pInitialSD = NULL, pFinalSD;
    PACL                    pOldAcl = NULL, pNewAcl = NULL;
    DWORD                   fInherit = 0;
    BOOL                    fFreeAcl = FALSE;


    if (argc < 2) {

        Usage(pStrRights, cStrRights, pCmdVals);
        return(1);

    } else if (argc == 2 && (strcmp(argv[1], "-?") == 0 || strcmp(argv[1], "/?") == 0)) {

        Usage(pStrRights, cStrRights, pCmdVals);
        return(0);

    }


    //
    // Parse the command line
    //
    dwErr = ParseCmdline(argv, argc, 2, pCmdVals, cCmdVals);

    if (dwErr != ERROR_SUCCESS) {

        Usage(pStrRights, cStrRights, pCmdVals);
        return(1);

    }

    //
    // Set our inheritance flags
    //
    if (CMD_PRESENT(CmdICont, pCmdVals)) {

        fInherit |= CONTAINER_INHERIT_ACE;
    }

    if (CMD_PRESENT(CmdIObj, pCmdVals)) {

        fInherit |= OBJECT_INHERIT_ACE;
    }

#ifndef NO_INHERIT_ONLY
    if (CMD_PRESENT(CmdIOnly, pCmdVals)) {

        fInherit |= INHERIT_ONLY_ACE;
    }
#endif

    if (CMD_PRESENT(CmdIProp, pCmdVals)) {

        fInherit |= NO_PROPAGATE_INHERIT_ACE;
    }



    //
    // Ok, see if we need to read the existing security
    //
    if (CMD_PRESENT(CmdEdit, pCmdVals) || argc == 2) {

        dwErr = GetNamedSecurityInfoA(argv[1], SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
                                      NULL, NULL, &pOldAcl, NULL, &pInitialSD);
        if (dwErr != ERROR_SUCCESS) {

            fprintf(stderr, "Failed to read the security off of %s: %lu\n", argv[1], dwErr);
        }

    }

    //
    // Either display the existing access or do the sets as requested
    //
    if (dwErr == ERROR_SUCCESS && argc == 2) {

        dwErr = DisplayAcl ( argv[1], pOldAcl, pStrRights, cStrRights );

    } else {

        //
        // Ok, first we do the revokes
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdRevoke, pCmdVals)) {

            //
            // Make sure we've read it first...
            //
            if (CMD_PRESENT(CmdEdit, pCmdVals)) {

                dwErr = ProcessOperation( argv, &pCmdVals[CmdRevoke], REVOKE_ACCESS, pStrRights,
                                          cStrRights, fInherit, pOldAcl, &pNewAcl );

                if (dwErr == ERROR_SUCCESS) {

                    pOldAcl = pNewAcl;
                }

            } else {

                dwErr = ERROR_INVALID_PARAMETER;
            }

        }

        //
        // Then the grants
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdGrant, pCmdVals)) {

            //
            // First, see if we need to free the old acl on completion
            //
            if (pOldAcl == pNewAcl) {

                fFreeAcl = TRUE;
            }


            dwErr = ProcessOperation(argv, &pCmdVals[CmdGrant], GRANT_ACCESS, pStrRights,
                                     cStrRights, 0, pOldAcl, &pNewAcl);

            if (dwErr == ERROR_SUCCESS) {

                if (fFreeAcl == TRUE) {

                    LocalFree(pOldAcl);
                }

                pOldAcl = pNewAcl;

                //
                // Now set it and optionally propagate it
                //
                dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, DACL_SECURITY_INFORMATION,
                                                  CMD_PRESENT(CmdTree, pCmdVals),
                                                  CMD_PRESENT(CmdContinue, pCmdVals), TRUE,
                                                  fInherit);
            }
        }

        //
        // Finally, the denieds
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdDeny, pCmdVals)) {

            //
            // First, see if we need to free the old acl on completion
            //
            if (pOldAcl == pNewAcl) {

                fFreeAcl = TRUE;
            }


            dwErr = ProcessOperation(argv, &pCmdVals[CmdDeny], DENY_ACCESS, pStrRights,
                                     cStrRights, 0, pOldAcl, &pNewAcl);

            if (dwErr == ERROR_SUCCESS) {

                if (fFreeAcl == TRUE) {

                    LocalFree(pOldAcl);
                }

                pOldAcl = pNewAcl;

                //
                // Now set it and optionally propagate it
                //
                dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, DACL_SECURITY_INFORMATION,
                                                  CMD_PRESENT(CmdTree, pCmdVals),
                                                  CMD_PRESENT(CmdContinue, pCmdVals), FALSE,
                                                  fInherit);
            }
        }



        //
        // Finally, do the set if it hasn't already been done
        //
        if (dwErr == ERROR_SUCCESS  && !CMD_PRESENT(CmdGrant, pCmdVals) &&
                                                                !CMD_PRESENT(CmdDeny, pCmdVals)) {

            dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, DACL_SECURITY_INFORMATION,
                                              CMD_PRESENT(CmdTree, pCmdVals),
                                              CMD_PRESENT(CmdContinue, pCmdVals), FALSE,
                                              fInherit);
        }

        if (dwErr == ERROR_INVALID_PARAMETER) {

            Usage(pStrRights, cStrRights, pCmdVals);
        }

        LocalFree(pInitialSD);
    }

    LocalFree(pOldAcl);

    if(dwErr == ERROR_SUCCESS) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error %lu\n", dwErr);

    }

    return(dwErr == 0 ? 0 : 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\delegate\delegate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    delegate.c

Abstract:

    This Module implements the delegation tool, which allows for the management
    of access to DS objects

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:

--*/

#include <delegate.h>



__cdecl main(
    IN  INT     argc,
    IN  CHAR   *argv[]
    )
/*++

Routine Description:

    The MAIN for this executable


Arguments:

    argc - The count of arguments
    argv - The list of arguments

Return Value:

    0 - Success
    1 - Failure

--*/
{

    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR               pwszObjPath = NULL;
    ULONG               fAccessFlags = 0;
    PWSTR               rgwszObjIds[UNKNOWN_ID];
    PACTRL_ACCESSW      rgpDefObjAccess[MAX_DEF_ACCESS_ID + 1];
    PACTRL_ACCESSW      pCurrentAccess = NULL;
    PACTRL_ACCESSW      pAccess = NULL;
    DWORD               i;
    DWORD               cUsed;

    memset(rgwszObjIds, 0, sizeof(rgwszObjIds));
    memset(rgpDefObjAccess, 0, sizeof(rgpDefObjAccess));

    //
    // Temporary inclusion, until the new ADVAPI32.DLL is built
    //
    AccProvInit(dwErr);
    if(dwErr != ERROR_SUCCESS)
    {
        fprintf(stderr,
                "Failed to initialize the security apis: %lu\n",
                dwErr);
    }


    //
    // Ok, parse the command line
    //
    if(argc < 2)
    {
        Usage();
        exit(1);
    }

    //
    // See if we need help
    //
    if(strlen(argv[1]) == 2 && IS_ARG_SWITCH(argv[1]) && argv[1][1] == '?')
    {
        Usage();
        exit(1);
    }

    //
    // Ok, convert our OU parameter into a WIDE string, so we can do what we
    // have to
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW(argv[1], &pwszObjPath);
    }

    //
    // Ok, first, we initialize our ID list from the DS schema
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = InitializeIdAndAccessLists(pwszObjPath,
                                           rgwszObjIds,
                                           rgpDefObjAccess);
    }

    //
    // Make sure we're actually dealing with an OU
    //
    if(dwErr == ERROR_SUCCESS)
    {
        BOOL    fIsOU = FALSE;

        dwErr = IsPathOU(pwszObjPath,
                         &fIsOU);
        if(dwErr == ERROR_SUCCESS)
        {
            if(fIsOU == FALSE)
            {
                fprintf(stderr,
                        "%ws is not an Organizational Unit\n",
                        pwszObjPath);
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            fprintf(stderr,
                    "Failed to determine the status of %ws\n",
                    pwszObjPath);
        }
    }
    else
    {

        fprintf(stderr,"Initialization failed\n");
    }

    //
    // First pass through the command line.  We'll read off our flags.  We
    // need this to determine whether to do the initial read or not
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, go through and look for all of our flags
        //
        for(i = 2; i < (DWORD)argc; i++)
        {
            if(IS_ARG_SWITCH(argv[i]))
            {
                if(_stricmp(argv[i] + 1, "T") == 0 ||
                                        _stricmp(argv[i] + 1, "reseT") == 0)
                {
                    fAccessFlags |= D_REPLACE;
                }
                else if(_stricmp(argv[i] + 1, "I") == 0 ||
                                        _stricmp(argv[i] + 1, "Inherit") == 0)
                {
                    fAccessFlags |= D_INHERIT;
                }
                else if(_stricmp(argv[i] + 1, "P") == 0 ||
                                      _stricmp(argv[i] + 1, "Protected") == 0)
                {
                    fAccessFlags |= D_PROTECT;
                }
            }
        }
    }


    //
    // See if we need to read the current access, which is if we are simply
    // displaying the current security, or editing the existing security
    //
    if(dwErr == ERROR_SUCCESS && (argc == 2 ||
                                            (fAccessFlags & D_REPLACE) == 0))
    {
        //
        // GetNamedSecurityInfoEx is a NT 5 API
        //
        dwErr = GetNamedSecurityInfoEx(pwszObjPath,
                                       SE_DS_OBJECT_ALL,
                                       DACL_SECURITY_INFORMATION,
                                       L"Windows NT Access Provider",
                                       NULL,
                                       &pCurrentAccess,
                                       NULL,
                                       NULL,
                                       NULL);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See if we were supposed to display it
            //
            if(argc == 2)
            {
                DumpAccess(pwszObjPath,
                           pCurrentAccess,
                           rgwszObjIds);
            }
        }
        else
        {
            fprintf(stderr,
                    "Failed to read the current security from %ws\n",
                    pwszObjPath);
        }
    }

    //
    // Ok, now process the command line again, and do the necessary operations
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, go through and look for all of our flags
        //
        i = 2;

        while(dwErr == ERROR_SUCCESS && i < (DWORD)argc)
        {
            if(IS_ARG_SWITCH(argv[i]))
            {
                if(_stricmp(argv[i] + 1, "T") == 0 ||
                                        _stricmp(argv[i] + 1, "reseT") == 0)
                {
                    //
                    // already processed above
                    //
                }
                else if(_stricmp(argv[i] + 1, "I") == 0 ||
                                        _stricmp(argv[i] + 1, "Inherit") == 0)
                {
                    //
                    // already processed above
                    //
                }
                else if(_stricmp(argv[i] + 1, "P") == 0 ||
                                      _stricmp(argv[i] + 1, "Protected") == 0)
                {
                    //
                    // already processed above
                    //
                }
                else if(_stricmp(argv[i] + 1, "R") == 0 ||
                                      _stricmp(argv[i] + 1, "Revoke") == 0)
                {
                    dwErr = ProcessCmdlineUsers(pCurrentAccess,
                                                argv,
                                                argc,
                                                i,
                                                REVOKE,
                                                fAccessFlags,
                                                rgwszObjIds,
                                                rgpDefObjAccess,
                                                &cUsed,
                                                &pAccess);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        LocalFree(pCurrentAccess);
                        pCurrentAccess = pAccess;

                        i += cUsed;
                    }
                }
                else if(_stricmp(argv[i] + 1, "G") == 0 ||
                                      _stricmp(argv[i] + 1, "Grant") == 0)
                {
                    dwErr = ProcessCmdlineUsers(pCurrentAccess,
                                                argv,
                                                argc,
                                                i,
                                                GRANT,
                                                fAccessFlags,
                                                rgwszObjIds,
                                                rgpDefObjAccess,
                                                &cUsed,
                                                &pAccess);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        LocalFree(pCurrentAccess);
                        pCurrentAccess = pAccess;

                        i += cUsed;
                    }
                }
                else if(_stricmp(argv[i] + 1, "D") == 0 ||
                                      _stricmp(argv[i] + 1, "Deny") == 0)
                {
                    dwErr = ProcessCmdlineUsers(pCurrentAccess,
                                                argv,
                                                argc,
                                                i,
                                                DENY,
                                                fAccessFlags,
                                                rgwszObjIds,
                                                rgpDefObjAccess,
                                                &cUsed,
                                                &pAccess);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        LocalFree(pCurrentAccess);
                        pCurrentAccess = pAccess;

                        i += cUsed;
                    }
                }
                else
                {
                    //
                    // Some unknown command line parameter
                    //
                    fprintf(stderr,
                            "Unrecognized command line parameter: %s\n",
                            argv[i]);
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }

            i++;
        }
    }

    //
    // Finally, set the access as requested
    //
    if(dwErr == ERROR_SUCCESS && pAccess != NULL)
    {
        //
        // SetNamedSecurityInfoEx is a NT 5 API
        //
        dwErr = SetNamedSecurityInfoEx(pwszObjPath,
                                       SE_DS_OBJECT_ALL,
                                       DACL_SECURITY_INFORMATION,
                                       L"Windows NT Access Provider",
                                       pCurrentAccess,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Delegate failed to write the new access to %ws\n",
                    pwszObjPath);
        }
    }

    //
    // Last little informative message...
    //
    if(dwErr == ERROR_PATH_NOT_FOUND)
    {
        fprintf(stderr,
                "DELEGATE did not recognize %ws as a DS path\n",
                pwszObjPath);
    }

    //
    // Free all our allocated memory
    //
    FreeIdAndAccessList(rgwszObjIds,
                        rgpDefObjAccess);
    LocalFree(pwszObjPath);
    LocalFree(pCurrentAccess);

    if(dwErr == ERROR_SUCCESS)
    {
        fprintf(stdout,
                "The command completed successfully.\n");
    }

    return(dwErr == ERROR_SUCCESS ? 0 : 1);
}



VOID
DumpAccess (
    IN  PWSTR           pwszObject,
    IN  PACTRL_ACCESSW  pAccess,
    IN  PWSTR          *ppwszIDs
)
/*++

Routine Description:

    This routine will display the given actrl_access list to stdout


Arguments:

    pwszObject - The path to the object being displayed
    pAccess - The access list to display
    ppwszIDs - The list of property/control ids read from the schema.  Used
               to assign a name to the property list.


Return Value:

    VOID

--*/
{
    ULONG           iProp, iEnt, i;
    ULONG           Inherit;
    ACCESS_RIGHTS   Access;
    PWSTR           pwszTag = NULL;
    PWSTR           pwszPropertyTag = L"Object or Property:";
    PWSTR rgwszInheritTags[] = {L"None",
                                L"Object",
                                L"Container",
                                L"Inherit, no propagate",
                                L"Inherit only",
                                L"Inherited"};

    PWSTR rgwszAccessTags[] = {L"None",
                               L"Delete",
                               L"Read Security Information",
                               L"Change Security Information",
                               L"Change owner",
                               L"Synchronize",
                               L"Open Object",
                               L"Create Child",
                               L"Delete Child",
                               L"List contents",
                               L"Write Self",
                               L"Read Property",
                               L"Write Property"};

    ACCESS_RIGHTS   rgAccess[] = {0,
                                  ACTRL_DELETE,
                                  ACTRL_READ_CONTROL,
                                  ACTRL_CHANGE_ACCESS,
                                  ACTRL_CHANGE_OWNER,
                                  ACTRL_SYNCHRONIZE,
                                  ACTRL_DS_OPEN,
                                  ACTRL_DS_CREATE_CHILD,
                                  ACTRL_DS_DELETE_CHILD,
                                  ACTRL_DS_LIST,
                                  ACTRL_DS_SELF,
                                  ACTRL_DS_READ_PROP,
                                  ACTRL_DS_WRITE_PROP};

    PWSTR           rgwszPropTags[] = {L"User object",
                                       L"Group object",
                                       L"Printer object",
                                       L"Volume object",
                                       L"Organizational Unit object",
                                       L"Change group membership property",
                                       L"Change password property",
                                       L"Account control property",
                                       L"Local Group object"};

    //
    // These [currently string versions of valid] IDs are currently planned to
    // be publicly defined for the product.  They are included below only due
    // to the fact that is no current public definition (as it is not
    // necessary for anyone else to need them), and the delegate tool needs
    // to be able to display a friendly name for it.  DO NOT RELY ON THE
    // FOLLOWING DEFINITIONS REMAINING CONSTANT.
    //
    PWSTR           rgwszDSControlIds[] = {
                                    L"ab721a50-1e2f-11d0-9819-00aa0040529b",
                                    L"ab721a51-1e2f-11d0-9819-00aa0040529b"};

    PWSTR           rgwszDSControlTrags[] = {
                                    L"List Domain Accounts",
                                    L"Lookup Domains"
                                    };



    //
    // Don't dump something that doesn't exist...
    //
    if(pAccess == NULL)
    {
        return;
    }

    fprintf(stdout, "Displaying access list for object %ws\n", pwszObject);
    fprintf(stdout, "\tNumber of property lists: %lu\n", pAccess->cEntries);
    for(iProp = 0; iProp < pAccess->cEntries; iProp++)
    {
        if(pAccess->pPropertyAccessList[iProp].lpProperty != NULL)
        {
            pwszTag = NULL;
            //
            // Find it in our list, so we can display the right value
            //
            for(i = 0; i < UNKNOWN_ID; i++)
            {
                if(_wcsicmp(pAccess->pPropertyAccessList[iProp].lpProperty,
                            ppwszIDs[i]) == 0)
                {
                    pwszTag = rgwszPropTags[i];
                    break;
                }
            }

            //
            // Look up the list of DS control rights
            //
            for(i = 0;
                i < sizeof(rgwszDSControlIds) / sizeof(PWSTR) &&
                                                              pwszTag == NULL;
                i++)
            {
                if(_wcsicmp(pAccess->pPropertyAccessList[iProp].lpProperty,
                            rgwszDSControlIds[i]) == 0)
                {
                    pwszTag = rgwszDSControlTrags[i];
                    pwszPropertyTag = L"DS Control right id:";
                    break;
                }
            }

            if(pwszTag == NULL)
            {
                fprintf(stdout,
                        "\t\tUnrecognized property whose id is %ws\n",
                        pAccess->pPropertyAccessList[iProp].lpProperty);
            }
            else
            {
                fprintf(stdout, "\t\t%ws %ws\n", pwszPropertyTag, pwszTag);
            }
        }
        else
        {
            fprintf(stdout, "\t\tObject: %ws\n", pwszObject);
        }

        //
        // Is it protected?
        //
        if(pAccess->pPropertyAccessList[iProp].fListFlags != 0)
        {
            if((pAccess->pPropertyAccessList[iProp].fListFlags &
                                                 ACTRL_ACCESS_PROTECTED) != 0)
            {
                fprintf(stdout,"\t\tAccess list is protected\n");
            }
        }

        if(pAccess->pPropertyAccessList[iProp].pAccessEntryList == NULL)
        {
            fprintf(stdout,"\t\tpAccessEntryList: NULL\n");
        }
        else
        {
            PACTRL_ACCESS_ENTRYW pAE= pAccess->pPropertyAccessList[iProp].
                                            pAccessEntryList->pAccessList;
            fprintf(stdout,
                    "\t\t\t%lu Access Entries for this object or property\n",
                   pAccess->pPropertyAccessList[iProp].pAccessEntryList->
                                                                cEntries);

            for(iEnt = 0;
                iEnt < pAccess->pPropertyAccessList[iProp].
                                               pAccessEntryList->cEntries;
                iEnt++)
            {
                //
                // Type of entry
                //
                if(pAE[iEnt].fAccessFlags == ACTRL_ACCESS_ALLOWED)
                {
                    fprintf(stdout,
                            "\t\t\t[%lu] Access Allowed entry\n",
                            iEnt);
                }
                else if(pAE[iEnt].fAccessFlags == ACTRL_ACCESS_DENIED)
                {
                    fprintf(stdout,
                            "\t\t\t[%lu] Access Denied entry\n",
                            iEnt);
                }
                else
                {
                    fprintf(stdout,"\t\t\t[%lu]", iEnt);
                    if((pAE[iEnt].fAccessFlags & ACTRL_AUDIT_SUCCESS) != 0)
                    {
                        fprintf(stdout,"Success Audit");
                    }
                    if((pAE[iEnt].fAccessFlags & ACTRL_AUDIT_FAILURE) != 0)
                    {
                        if((pAE[iEnt].fAccessFlags & ACTRL_AUDIT_SUCCESS) != 0)
                        {
                            fprintf(stdout," | ");
                        }
                        fprintf(stdout,"Failure Audit");
                    }
                    fprintf(stdout," entry\n");
                }

                //
                //  User name
                //
                fprintf(stdout,"\t\t\t\tUser: %ws\n",
                       pAE[iEnt].Trustee.ptstrName);

                //
                // Access rights
                //
                fprintf(stdout,"\t\t\t\tAccess:  ");
                Access = pAE[iEnt].Access;
                if(Access == 0)
                {
                    fprintf(stdout,"%ws\n", rgwszAccessTags[0]);
                }
                else
                {
                    for(i = 1;
                        i < sizeof(rgwszAccessTags) / sizeof(PWSTR);
                        i++)
                    {
                        if((Access & rgAccess[i]) != 0)
                        {
                            fprintf(stdout,"%ws", rgwszAccessTags[i]);
                            Access &= ~(rgAccess[i]);

                            if(Access != 0)
                            {
                                fprintf(stdout,
                                        "  |\n\t\t\t\t         ");
                            }
                        }
                    }

                    if(Access != 0)
                    {
                        fprintf(stdout,
                                "Unrecognized rights: 0x%lx\n",
                                Access);
                    }

                    fprintf(stdout,"\n");
                }

                //
                // Inheritance
                //
                fprintf(stdout,"\t\t\t\tInheritance:  ");
                Inherit = pAE[iEnt].Inheritance;
                if(Inherit == 0)
                {
                    fprintf(stdout,"%ws\n", rgwszInheritTags[0]);
                }
                else
                {
                    for(i = 0;
                        i < sizeof(rgwszInheritTags) / sizeof(PWSTR);
                        i++)
                    {
                        if((Inherit & 1 << i) != 0)
                        {
                            fprintf(stdout,"%ws", rgwszInheritTags[i + 1]);
                            Inherit &= ~(1 << i);

                            if(Inherit == 0)
                            {
                                fprintf(stdout,"\n");
                            }
                            else
                            {
                                fprintf(stdout,
                                        "  |\n\t\t\t\t              ");
                            }
                        }
                    }
                }

                if(pAE[iEnt].lpInheritProperty != NULL)
                {
                    pwszTag = NULL;
                    //
                    // Find it in our list, so we can display the right value
                    //
                    for(i = 0; i < UNKNOWN_ID; i++)
                    {
                        if(_wcsicmp(pAE[iEnt].lpInheritProperty,
                                    ppwszIDs[i]) == 0)
                        {
                            pwszTag = rgwszPropTags[i];
                            break;
                        }
                    }

                    if(pwszTag == NULL)
                    {
                        fprintf(stdout,
                                "\t\t\t\tUnrecognized inherit to object "
                                "whose id is %ws\n",
                                pAE[iEnt].lpInheritProperty);
                    }
                    else
                    {
                        fprintf(stdout,
                                "\t\t\t\tObject to inherit to: %ws\n",
                                pwszTag);
                    }

                }
            }
        }

        printf("\n");
    }
}




VOID
Usage (
    )
/*++

Routine Description:

    This routine will display the expected command line usage

Arguments:

    None

Return Value:

    VOID

--*/
{

fprintf(stdout,
        "Delegates administrative privileges on a directory OU\n");
fprintf(stdout, "\n");
fprintf(stdout,
        "DELEGATE <ou> [/T] [/I] [/P] [/G user:perm] [/D user:perm [...]] "
        "[/R user [...]]\n");
fprintf(stdout, "\n");
fprintf(stdout,"  <ou>\tOU to modify or display the rights for\n");
fprintf(stdout,"  /T\tReplace the access instead of editing it.\n");
fprintf(stdout,"  /I\tInherit to all subcontainers in the directory.\n");
fprintf(stdout,"  /P\tMark the object as protected following the operation\n");
fprintf(stdout,"  /G  user:perm\tGrant specified user admin access rights.\n");
fprintf(stdout,"  /D  user:perm\tDeny specified user admin access rights.\n");
fprintf(stdout,"  \tPerm can be:\n");
fprintf(stdout,"  \t\tAbility to create/manage objects in this container\n");
fprintf(stdout,"  \t\t\t%2s  Create/Manage All object types\n",D_ALL);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Users\n", D_USER);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Groups\n", D_GROUP);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Printers\n", D_PRINT);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Volumes\n", D_VOL);
fprintf(stdout,"  \t\t\t%2s  Create/Manage OUs\n", D_OU);
fprintf(stdout,"  \t\tAbility to modify specific user or group "
        "properties\n");
fprintf(stdout,"  \t\t\t%2s  Change Group membership for "
        "all groups\n", D_MEMBERS);
fprintf(stdout,"  \t\t\t%2s  Set User Passwords\n", D_PASSWD);
fprintf(stdout,"  \t\t\t%2s  Enable/Disable user accounts\n", D_ENABLE);
fprintf(stdout, "\n");
fprintf(stdout,"  /R user  Revoke\tSpecified user's access rights (only valid "
        "without /E).\n");
fprintf(stdout, "\n");
fprintf(stdout,"You can specify more than one user in a command and "
               "more than one perm per user, seperated by a , (comma).\n");

}




DWORD
ConvertStringAToStringW (
    IN  PSTR            pszString,
    OUT PWSTR          *ppwszString
)
/*++

Routine Description:

    This routine will convert an ASCII string to a UNICODE string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pszString - The string to convert
    ppwszString - Where the converted string is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pszString == NULL)
    {
        *ppwszString = NULL;
    }
    else
    {
        ULONG cLen = strlen(pszString);
        *ppwszString = (PWSTR)LocalAlloc(LMEM_FIXED,sizeof(WCHAR) *
                                  (mbstowcs(NULL, pszString, cLen + 1) + 1));
        if(*ppwszString  != NULL)
        {
             mbstowcs(*ppwszString,
                      pszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




DWORD
ConvertStringWToStringA (
    IN  PWSTR           pwszString,
    OUT PSTR           *ppszString
)
/*++

Routine Description:

    This routine will convert a UNICODE string to an ANSI string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pwszString - The string to convert
    ppszString - Where the converted string is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pwszString == NULL)
    {
        *ppszString = NULL;
    }
    else
    {
        ULONG cLen = wcslen(pwszString);
        *ppszString = (PSTR)LocalAlloc(LMEM_FIXED,sizeof(CHAR) *
                                  (wcstombs(NULL, pwszString, cLen + 1) + 1));
        if(*ppszString  != NULL)
        {
             wcstombs(*ppszString,
                      pwszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




DWORD
InitializeIdAndAccessLists (
    IN  PWSTR           pwszOU,
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList
    )
/*++

Routine Description:

    This routine will read the list of object ids from the schema for the
    object types as indicated by DELEGATE_OBJ_ID enumeration.

    The returned access list needs to be processed by FreeIdList.

Arguments:

    pwszOU - Information on the domain for which to query the schema
    ppwszObjIdList - The list of object ids to initialize.  The list must
                     already exist and must of the proper size



Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed
    ERROR_INVALID_PARAMETER - The OU given was not correct

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   i;
    PSTR    pszSchemaPath = NULL;
    PLDAP   pLDAP;

    //
    // Build a list of attributes to read
    //
    PSTR    pszAttribs[] = {"User",                 // USER_ID
                            "Group",                // GROUP_ID
                            "Print-Queue",          // PRINT_ID
                            "Volume",               // VOLUME_ID
                            "Organizational-Unit",  // OU_ID
                            "Member",               // MEMBER_ID
                            "User-Password",        // PASSWD_ID
                            "User-Account-Control", // ACCTCTRL_ID
                            "LocalGroup"            // LOCALGRP_ID
                            };

    //
    // Get the path to the schema
    //
    dwErr = LDAPReadSchemaPath(pwszOU,
                               &pszSchemaPath,
                               &pLDAP);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, now, we need to query the schema for the information
        //
        for(i = 0; i < UNKNOWN_ID && dwErr == ERROR_SUCCESS; i++)
        {
            //
            // Get the info from the schema
            //
            dwErr = LDAPReadSecAndObjIdAsString(pLDAP,
                                                pszSchemaPath,
                                                pszAttribs[i],
                                                &(ppwszObjIdList[i]),
                                                i > MAX_DEF_ACCESS_ID ?
                                                    NULL    :
                                                    &(ppDefObjAccessList[i]));
        }


        LocalFree(pszSchemaPath);
        LDAPUnbind(pLDAP);
    }

    return(dwErr);
}



VOID
FreeIdAndAccessList (
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList

    )
/*++

Routine Description:

    This routine will process the list of Ids and determine if any of them
    have been converted to strings.  If so, it deallocates the memory

Arguments:

    pObjIdList - The list of object ids to free


Return Value:

    VOID

--*/
{
    DWORD   i;

    for(i = 0; i < UNKNOWN_ID; i++)
    {
        RpcStringFree(&(ppwszObjIdList[i]));

        if(i <= MAX_DEF_ACCESS_ID)
        {
            LocalFree(ppDefObjAccessList[i]);
        }
    }
}



DWORD
ProcessCmdlineUsers (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  CHAR               *argv[],
    IN  INT                 argc,
    IN  DWORD               iStart,
    IN  DELEGATE_OP         Op,
    IN  ULONG               fFlags,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    OUT PULONG              pcUsed,
    OUT PACTRL_ACCESSW     *ppNewAccess
    )
/*++

Routine Description:

    This routine will process the command line for any users to have
    access added/denied.  If any entries are found, the access list will be
    appropriately updated.

    The returned access list must be freed via a call to LocalFree


Arguments:

    pAccessList - The current access list
    argv - List of command line arguments
    argc - count of command line arguments
    iStart - Where in the command line does the current argument start
    Op   - Type of operation (grant, revoke, etc) to perform
    fInherit - Whether to do inheritance or not
    fProtected - Whether to mark the entries as protected
    ppwszIDs - List of supported IDs
    pcUsed - Number of items command line items used
    ppNewAccess - Where the new access list is returned.  Only valid if
                  returned count of revoked items is non-0


Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    DWORD                   i;
    PACTRL_ACCESSW          pListToFree = NULL;

    *pcUsed = 0;
    iStart++;

    //
    // Process all the entries until we find the next seperator or the end of
    // the list
    //
    while(iStart + *pcUsed < (DWORD)argc &&
          !IS_ARG_SWITCH(argv[iStart + *pcUsed]) &&
          dwErr == ERROR_SUCCESS)
    {
        PWSTR       pwszUser = NULL;
        PSTR        pszAccess;
        PSTR        pszAccessStart;

        //
        // Get the user name and the list of arguments, if it exists
        //
        dwErr = GetUserInfoFromCmdlineString(argv[iStart + *pcUsed],
                                             &pwszUser,
                                             &pszAccessStart);
        if(dwErr == ERROR_SUCCESS)
        {
            pszAccess = pszAccessStart;
            //
            // Should we have arguments?  All except for the revoke case, we
            // should
            //
            if(pszAccess == NULL && Op != REVOKE)
            {
                fprintf(stderr,
                        "Missing permissions for %ws\n",
                        pwszUser);
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }


        //
        // Ok, now we'll have to process the list, and actually build the
        // access entries
        //
        if(dwErr == ERROR_SUCCESS)
        {
            DWORD   iIndex = 0;

            //
            // Reset our list of entries...
            //
            pszAccess = pszAccessStart;
            while(dwErr == ERROR_SUCCESS)
            {
                PSTR    pszNext = NULL;

                if(pszAccess != NULL)
                {
                    pszNext = strchr(pszAccess, ',');

                    if(pszNext != NULL)
                    {
                        *pszNext = '\0';
                    }
                }

                dwErr = AddAccessEntry(pAccessList,
                                       pszAccess,
                                       pwszUser,
                                       Op,
                                       ppwszIDs,
                                       ppDefObjAccessList,
                                       fFlags,
                                       ppNewAccess);
                //
                // Restore our string
                //
                if(pszNext != NULL)
                {
                    *pszNext = ',';
                    pszNext++;
                }

                pszAccess = pszNext;

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // We don't want to free the original list, since that
                    // is what we were given to start with...
                    //
                    LocalFree(pListToFree);
                    pAccessList = *ppNewAccess;
                    pListToFree = pAccessList;
                }
                else
                {
                    if(dwErr == ERROR_NONE_MAPPED)
                    {
                        fprintf(stderr,"Unknown user %ws specified\n",
                                pwszUser);
                    }
                }

                if(Op == REVOKE || pszAccess == NULL)
                {
                    break;
                }
            }
        }

        (*pcUsed)++;
    }

    if(*pcUsed == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        fprintf(stderr,"No user information was supplied!\n");
    }

    return(dwErr);
}




DWORD
GetUserInfoFromCmdlineString (
    IN  PSTR            pszUserInfo,
    OUT PWSTR          *ppwszUser,
    OUT PSTR           *ppszAccessStart
)
/*++

Routine Description:

    This routine will process the command line for any user to convert the
    user name to a wide string, and optionally get the access, if it exists

    The returned user must be freed via a call to LocalFree


Arguments:

    pszUserInfo - The user info to convert.  In the form of username or
                  username:access
    ppwszUser - Where to return the user name
    pAccess - Where the access is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, find the seperator, if it exists
    //
    PSTR pszSep = strchr(pszUserInfo, ':');
    if(pszSep != NULL)
    {
        *pszSep = '\0';
    }

    //
    // Convert our user name
    //
    dwErr = ConvertStringAToStringW(pszUserInfo,
                                    ppwszUser);

    if(pszSep != NULL)
    {
        *pszSep = ':';
        pszSep++;
    }

    *ppszAccessStart = pszSep;

    return(dwErr);
}



DWORD
AddAccessEntry (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  PSTR                pszAccess,
    IN  PWSTR               pwszTrustee,
    IN  DELEGATE_OP         Op,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    IN  ULONG               fFlags,
    OUT PACTRL_ACCESSW     *ppNewAccess
)
/*++

Routine Description:

    This routine will add a new access entry to the list based upon the access
    action string and the operation.  The pointer to the index variable will
    indicate where in the list it goes, and will be updated to point to the
    next entry on return.


Arguments:

    pAccessList - The current access list.  Can be NULL.
    pszAccess - User access string to add
    pwszTrustee - The user for which an entry is being created
    Op   - Type of operation (grant, revoke, etc) to perform
    ppwszIDs - List of object IDs from the DS Schema
    fFlags - Whether to do inheritance, protection, etc
    ppNewAccess - Where the new access list is returned.


Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    DWORD           i,j,k,iIndex = 0;
    PWSTR           pwszProperty = NULL;
    ULONG           cEntries = 0;
    BOOL            fInherit;
    ACCESS_MODE     Access[] = {REVOKE_ACCESS,
                                GRANT_ACCESS,
                                GRANT_ACCESS};
    ULONG           Flags[] = {0,
                               ACTRL_ACCESS_ALLOWED,
                               ACTRL_ACCESS_DENIED};
    //
    // The most we add is 3 entries at a time...  (2 per items, 1 inheritable)
    //
    ACTRL_ACCESS_ENTRYW AccList[3];
    memset(&AccList, 0, sizeof(AccList));

    fInherit =  (BOOL)(fFlags & D_INHERIT);
    if(Op == REVOKE)
    {
        BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                             pwszTrustee);
    }
    else
    {
        //
        // GroupMembership
        //
        if(_stricmp(pszAccess, D_MEMBERS) == 0)
        {
            //
            // This gets 1 access entry: WriteProp
            //
            AccList[cEntries].lpInheritProperty = ppwszIDs[GROUP_ID];
            AccList[cEntries].Inheritance = INHERIT_ONLY | fInherit ?
                                      SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                      0;
            BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                 pwszTrustee);

            AccList[cEntries].fAccessFlags = Flags[Op];
            AccList[cEntries].Access = ACTRL_DS_WRITE_PROP;
            pwszProperty = ppwszIDs[MEMBER_ID];
            iIndex = MEMBER_ID;
            fprintf(stderr,
                    "Sorry... delegation for changing Group membership is "
                    "not supported in this alpha release\n");
            dwErr = ERROR_INVALID_PARAMETER;

        }
        //
        // SetPassword
        //
        else if(_stricmp(pszAccess, D_PASSWD) == 0)
        {
            //
            // This gets 1 access entry: WriteProp
            //
            AccList[cEntries].lpInheritProperty = ppwszIDs[USER_ID];
            AccList[cEntries].Inheritance = INHERIT_ONLY | fInherit ?
                                      SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                      0;
            BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                 pwszTrustee);

            AccList[cEntries].fAccessFlags = Flags[Op];
            AccList[cEntries].Access = ACTRL_DS_WRITE_PROP;
            pwszProperty = ppwszIDs[PASSWD_ID];
            iIndex = PASSWD_ID;
            fprintf(stderr,
                    "Sorry... delegation for Set Password is "
                    "not supported in this alpha release\n");
            dwErr = ERROR_INVALID_PARAMETER;
        }
        //
        // Enable/Disable accounts
        //
        else if(_stricmp(pszAccess, D_ENABLE) == 0)
        {
            //
            // This gets 1 access entry: WriteProp
            //
            AccList[cEntries].lpInheritProperty = ppwszIDs[USER_ID];
            AccList[cEntries].Inheritance = INHERIT_ONLY | fInherit ?
                                      SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                      0;
            BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                 pwszTrustee);

            AccList[cEntries].fAccessFlags = Flags[Op];
            AccList[cEntries].Access = ACTRL_DS_WRITE_PROP;
            pwszProperty = ppwszIDs[ACCTCTRL_ID];
            iIndex = ACCTCTRL_ID;
            fprintf(stderr,
                    "Sorry... delegation for Enabling and Disabling accounts "
                    " is not supported in this alpha release\n");
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // Some object type...
            //
            if(_stricmp(pszAccess, D_ALL) == 0)         // All
            {
                pwszProperty = NULL;
            }
            else if(_stricmp(pszAccess, D_USER) == 0)   // User
            {
                pwszProperty = ppwszIDs[USER_ID];
                iIndex = USER_ID;
                fprintf(stderr,
                        "Sorry... delegation for user objects is "
                        "not supported in this alpha release\n");
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else if(_stricmp(pszAccess, D_GROUP) == 0)  // Group
            {
                pwszProperty = ppwszIDs[USER_ID];
                iIndex = GROUP_ID;
                fprintf(stderr,
                        "Sorry... delegation for group objects is "
                        "not supported in this alpha release\n");
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else if(_stricmp(pszAccess, D_PRINT) == 0)  // Printers
            {
                pwszProperty = ppwszIDs[PRINT_ID];
                iIndex = PRINT_ID;
            }
            else if(_stricmp(pszAccess, D_VOL) == 0)    // Volumes
            {
                pwszProperty = ppwszIDs[VOLUME_ID];
                iIndex = VOLUME_ID;
            }
            else if(_stricmp(pszAccess, D_OU) == 0)     // OUs
            {
                pwszProperty = ppwszIDs[OU_ID];
                iIndex = OU_ID;
            }
            else
            {
                dwErr = ERROR_INVALID_PARAMETER;
                fprintf(stderr,
                        "Unexpected delegation permission %s given for "
                        "user %ws\n",
                        pszAccess,
                        pwszTrustee);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Add the create/delete for the user
                //
                BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                     pwszTrustee);

                AccList[cEntries].fAccessFlags = Flags[Op];
                AccList[cEntries].Access = ACTRL_DS_CREATE_CHILD  |
                                                ACTRL_DS_DELETE_CHILD;
                AccList[cEntries].Inheritance = fInherit ?
                                        SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                        0;
                //
                // If we are inheriting, make sure we inherit only to the
                // proper property
                //
                if(fInherit == TRUE)
                {
                    AccList[cEntries].lpInheritProperty = pwszProperty;
                }

                //
                // Then the inherit on the child object
                //
                cEntries++;
                AccList[cEntries].Inheritance = INHERIT_ONLY |
                                            (fInherit ?
                                          SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                          0);
                BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                     pwszTrustee);

                AccList[cEntries].fAccessFlags = Flags[Op];
                AccList[cEntries].Access = ACTRL_DS_WRITE_PROP  |
                                           ACTRL_DS_READ_PROP   |
                                           ACTRL_DS_LIST        |
                                           ACTRL_DS_SELF;

                AccList[cEntries].lpInheritProperty = pwszProperty;
            }

        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // SetEntriesInAccessList is a NT5 API
        //
        dwErr = SetEntriesInAccessList(cEntries + 1,
                                       AccList,
                                       Access[Op],
                                       pwszProperty,
                                       pAccessList,
                                       ppNewAccess);
        //
        // Mark it as protected if we were so asked
        //
        if(dwErr == ERROR_SUCCESS && (fFlags & D_PROTECT) != 0)
        {
            (*ppNewAccess)->pPropertyAccessList[0].fListFlags =
                                                      ACTRL_ACCESS_PROTECTED;
        }
    }

    //
    // Finally, if this was the first entry we were asked to add for this
    // property, we'll have to go get the default security information
    // from the schema, so we can figure out what inherited entries should
    // be on the object, and apply them as object inherit entries for the
    // property
    //
    if(dwErr == ERROR_SUCCESS && iIndex <= MAX_DEF_ACCESS_ID && Op != REVOKE)
    {
        PACTRL_ACCESS   pOldAccess = pAccessList;

        //
        // First, find the property in our list of access entries we
        // created above
        //
        for(i = 0; i <= (*ppNewAccess)->cEntries; i++)
        {
            //
            // We'll do this based on property...  In this case, the only
            // entries we'll be adding will have a property, so we don't have
            // to protect against that...
            //
            if(pwszProperty != NULL &&
               (*ppNewAccess)->pPropertyAccessList[i].lpProperty != NULL &&
               _wcsicmp((*ppNewAccess)->pPropertyAccessList[i].lpProperty,
                        pwszProperty) == 0)
            {
                //
                // If it has more entries that we added, we won't have to
                // worry about it, since the information will already
                // have been added.  Note that in this case, we don't have
                // to worry about pAccessEntryList being null, since we know
                // we have added some valid entries.
                //
                if((*ppNewAccess)->pPropertyAccessList[i].
                                                pAccessEntryList->cEntries ==
                    cEntries + 1)
                {
                    PACTRL_ACCESS   pAddAccess = ppDefObjAccessList[iIndex];
                    pAccessList = *ppNewAccess;

                    //
                    // Ok, we'll have to add them...
                    //
                    for(j = 0;
                        j < (DWORD)(pAddAccess->cEntries) &&
                                                        dwErr == ERROR_SUCCESS;
                        j++)
                    {
                        PACTRL_PROPERTY_ENTRY pPPE =
                                        &(pAddAccess->pPropertyAccessList[j]);
                        dwErr = SetEntriesInAccessList(
                                         pPPE->pAccessEntryList->cEntries,
                                         pPPE->pAccessEntryList->pAccessList,
                                         GRANT_ACCESS,
                                         pPPE->lpProperty,
                                         pAccessList,
                                         ppNewAccess);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            pAccessList = *ppNewAccess;
                        }
                    }
                }

                //
                // We don't want to run through the loop anymore
                //
                break;
            }
        }
    }

    return(dwErr);
}




DWORD
IsPathOU (
    IN  PWSTR               pwszOU,
    OUT PBOOL               pfIsOU
)
/*++

Routine Description:

    This routine will determine whether the given path is an OU or not.


Arguments:

    pwszOU - The path into the DS to check on
    ppwszIDs - List of string representations of known IDs
    pfIsOU - Where the results of the test are returned


Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    PSTR                pszOU = NULL;
    HANDLE              hDS = NULL;
    PDS_NAME_RESULTA    pNameRes;


    dwErr = ConvertStringWToStringA(pwszOU,
                                    &pszOU);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsBindA(NULL,
                        NULL,
                        &hDS);
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsCrackNamesA(hDS,
                              DS_NAME_NO_FLAGS,
                              DS_UNKNOWN_NAME,
                              DS_FQDN_1779_NAME,
                              1,
                              &pszOU,
                              &pNameRes);

        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                PSTR    pszName = NULL;
                PLDAP   pLDAP;

                //
                // Now, we'll bind to the object, and then do the read
                //
                dwErr = LDAPBind(pNameRes->rItems[0].pDomain,
                                 &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
                    PSTR   *ppszValues;
                    DWORD   cValues;
                    dwErr = LDAPReadAttribute(pszOU,
                                              "objectclass",
                                              pLDAP,
                                              &cValues,
                                              &ppszValues);
                    LDAPUnbind(pLDAP);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        ULONG i;
                        *pfIsOU = FALSE;
                        for(i = 0; i <cValues; i++)
                        {
                            if(_stricmp(ppszValues[i],
                                        "organizationalUnit") == 0)
                            {
                                *pfIsOU = TRUE;
                                break;
                            }
                        }

                        LDAPFreeValues(ppszValues);
                    }
                }
            }

            DsFreeNameResultA(pNameRes);
        }

    }

    if (NULL != pszOU)
    {
        LocalFree(pszOU);
    }
    if (NULL != hDS)
    {
        DsUnBindA(hDS);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\delegate\delegate.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    delegate.h

Abstract:

    The main header file for the delegate tool

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:

--*/

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>
#include <aclapi.h>
#include <aclapip.h>
#include <winldap.h>
#include <ntdsapi.h>


//
// C-Runtime Header
//
#include <stdio.h>
#include <stdlib.h>


//
// Macro to help determine if a given argument is a swith or not
//
#define IS_ARG_SWITCH(arg)      (arg[0] == '/' || arg[0] == '-')

//
// Type of operation to perform
//
typedef enum _DELEGATE_OP
{
    REVOKE = 0,
    GRANT,
    DENY
} DELEGATE_OP;

//
// Type of object ID we're dealing with
//
typedef enum _DELEGATE_OBJ_ID
{
    USER_ID = 0,
    GROUP_ID,
    PRINT_ID,
    VOLUME_ID,
    OU_ID,
    MEMBER_ID,
    PASSWD_ID,
    ACCTCTRL_ID,
    LOCALGRP_ID,
    UNKNOWN_ID  // This ALWAYS has to be the last item in the enumeration
} DELEGATE_OBJ_ID, *PDELEGATE_OBJ_ID;
#define MAX_DEF_ACCESS_ID   OU_ID       // Last item we need to get the
                                        // default access for


//
// List of permissions to be granted/denied
//
#define D_ALL       "All"
#define D_USER      "User"
#define D_GROUP     "Group"
#define D_PRINT     "Print"
#define D_VOL       "Volume"
#define D_OU        "OU"
#define D_MEMBERS   "Members"
#define D_PASSWD    "Password"
#define D_ENABLE    "EnableAccount"


//
// Options flags
//
#define D_REPLACE   0x00000001L
#define D_INHERIT   0x00000002L
#define D_PROTECT   0x00000004L


//
// Function prototypes (delegate.c)
//
VOID
DumpAccess (
    IN  PWSTR           pwszObject,
    IN  PACTRL_ACCESSW  pAccess,
    IN  PWSTR          *ppwszIDs
    );

VOID
Usage (
    );

DWORD
ConvertStringAToStringW (
    IN  PSTR            pszString,
    OUT PWSTR          *ppwszString
    );

DWORD
ConvertStringWToStringA (
    IN  PWSTR           pwszString,
    OUT PSTR           *ppszString
    );


DWORD
InitializeIdAndAccessLists (
    IN  PWSTR           pwszOU,
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList
    );

VOID
FreeIdAndAccessList  (
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList
    );

DWORD
ProcessCmdlineUsers (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  CHAR               *argv[],
    IN  INT                 argc,
    IN  DWORD               iStart,
    IN  DELEGATE_OP         Op,
    IN  ULONG               fFlags,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    OUT PDWORD              pcUsed,
    OUT PACTRL_ACCESSW     *ppNewAccess
    );

DWORD
GetUserInfoFromCmdlineString (
    IN  PSTR            pszUserInfo,
    OUT PWSTR          *ppwszUser,
    OUT PSTR           *ppszAccessStart
    );

DWORD
AddAccessEntry (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  PSTR                pszAccess,
    IN  PWSTR               pwszTrustee,
    IN  DELEGATE_OP         Op,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    IN  ULONG               fFlags,
    OUT PACTRL_ACCESSW     *ppNewAccess
    );

DWORD
IsPathOU (
    IN  PWSTR               pwszOU,
    OUT PBOOL               pfIsOU
    );



//
// Function prototypes (ldap.c)
//
DWORD
LDAPReadAttribute (
    IN  PSTR        pszOU,
    IN  PSTR        pszAttribute,
    IN  PLDAP       pLDAP,
    OUT PDWORD      pcValues,
    OUT PSTR      **pppszValues
    );

VOID
LDAPFreeValues (
    IN  PSTR       *ppszValues
    );

DWORD
LDAPReadSchemaPath (
    IN  PWSTR       pwszOU,
    OUT PSTR       *ppszSchemaPath,
    OUT PLDAP      *ppLDAP
    );

DWORD
LDAPReadSecAndObjIdAsString (
    IN  PLDAP           pLDAP,
    IN  PSTR            pszSchemaPath,
    IN  PSTR            pszObject,
    OUT PWSTR          *ppwszObjIdAsString,
    OUT PACTRL_ACCESS  *ppAccess
    );

DWORD
LDAPBind (
    IN  PSTR    pszObject,
    OUT PLDAP  *ppLDAP
    );

VOID
LDAPUnbind (
    IN  PLDAP   pLDAP
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\delegate\ldap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ldap.c

Abstract:

    This Module implements the utility LDAP functions to read information
    from the DS schema

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:

--*/

#define LDAP_UNICODE 0

#include <delegate.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>



DWORD
LDAPBind (
    IN  PSTR    pszObject,
    OUT PLDAP  *ppLDAP
    )
/*++

Routine Description:

    This routine will bind to the appropriate server for the path

Arguments:

    pszObject - Object server to bind to
    ppLDAP - Where the ldap binding is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    PDOMAIN_CONTROLLER_INFOA pDCI;

    //
    // First, get the address of our server.  Note that we are binding to
    // a machine in a local domain.  Normally, a valid DNS domain name
    // would be passed in.
    //
    dwErr = DsGetDcNameA(NULL,
                         NULL,
                         NULL,
                         NULL,
                         DS_IP_REQUIRED,
                         &pDCI);


    if(dwErr == ERROR_SUCCESS)
    {
        PSTR    pszDomain = pDCI[0].DomainControllerAddress;
        if(*pszDomain == '\\')
        {
            pszDomain += 2;
        }
        *ppLDAP = ldap_open(pszDomain,
                            LDAP_PORT);

        if(*ppLDAP == NULL)
        {
            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            //
            // Do a bind...
            //
            dwErr = ldap_bind(*ppLDAP,
                              NULL,
                              NULL,
                              LDAP_AUTH_SSPI);
        }

        NetApiBufferFree(pDCI);
    }



    return(dwErr);
}




VOID
LDAPUnbind (
    IN  PLDAP   pLDAP
    )
/*++

Routine Description:

    This routine will unbind a previously bound connection

Arguments:

    pLDAP - LDAP connection to unbind


Return Value:

    void

--*/
{
    if(pLDAP != NULL)
    {
        ldap_unbind(pLDAP);
    }
}




DWORD
LDAPReadAttribute (
    IN  PSTR        pszBase,
    IN  PSTR        pszAttribute,
    IN  PLDAP       pLDAP,
    OUT PDWORD      pcValues,
    OUT PSTR      **pppszValues
    )
/*++

Routine Description:

    This routine will read the specified attribute from the base path

Arguments:

    pszBase - Base object path to read from
    pszAttribute - Attribute to read
    pcValues - Where the count of read items is returned
    pppszValues - Where the list of items is returned
    ppLDAP - LDAP connection handle to use/initialize

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed
    ERROR_INVALID_PARAMETER - The LDAP connection that was given is not
                              correct

Notes:

    The returned values list should be freed via a call to LDAPFreeValues

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PLDAPMessage    pMessage = NULL;
    PSTR            rgAttribs[2];

    rgAttribs[0] = NULL;

    //
    // Ensure that our LDAP connection is valid
    //
    if(pLDAP == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // Then, do the search...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgAttribs[0] = pszAttribute;
        rgAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              pszBase,
                              LDAP_SCOPE_BASE,
                              "(objectClass=*)",
                              rgAttribs,
                              0,
                              &pMessage);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        LDAPMessage *pEntry = NULL;
        pEntry = ldap_first_entry(pLDAP,
                                  pMessage);

        if(pEntry == NULL)
        {
            dwErr = pLDAP->ld_errno;
        }
        else
        {
            //
            // Now, we'll have to get the values
            //
            *pppszValues = ldap_get_values(pLDAP,
                                           pEntry,
                                           rgAttribs[0]);
            if(*pppszValues == NULL)
            {
                dwErr = pLDAP->ld_errno;
            }
            else
            {
                *pcValues = ldap_count_values(*pppszValues);
            }
        }

        ldap_msgfree(pMessage);
    }

    return(dwErr);
}




VOID
LDAPFreeValues (
    IN  PSTR       *ppszValues
    )
/*++

Routine Description:

    Frees the results of an LDAPReadAttribute call

Arguments:

    ppwszValues - List to be freed

Return Value:

    Void

--*/
{
    ldap_value_free(ppszValues);
}




DWORD
LDAPReadSchemaPath (
    IN  PWSTR       pwszOU,
    OUT PSTR       *ppszSchemaPath,
    OUT PLDAP      *ppLDAP
    )
/*++

Routine Description:

    Reads the path to the schema from the DS

Arguments:

    pwszOU - OU path for which the schema path needs to be obtained
    ppszSchemaPath - Where the schema path is returned
    ppLDAP - LDAP connection to be returned following the successful
             completion of this routine

Return Value:

    ERROR_SUCCESS - Success
    ERROR_INVALID_PARAMETER - The OU given was not correct
    ERROR_PATH_NOT_FOUND - The path to the schema could not be found
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

Notes:

    The returned schema path should be free via a call to LocalFree.
    The LDAP connection should be freed via a call to LDAPUnbind

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    PSTR               *ppszValues = NULL;
    ULONG               cValues;
    PSTR                pszOU = NULL;
    HANDLE              hDS = NULL;
    PDS_NAME_RESULTW    pNameRes = NULL;

    *ppLDAP = NULL;

    //
    // Get our OU name into a form we can recognize
    //
    dwErr = DsBindW(NULL,
                    NULL,
                    &hDS);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsCrackNamesW(hDS,
                              DS_NAME_NO_FLAGS,
                              DS_UNKNOWN_NAME,
                              DS_FQDN_1779_NAME,
                              1,
                              &pwszOU,
                              &pNameRes);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
        {

            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            PSTR    pszDomain = NULL;

            dwErr = ConvertStringWToStringA(pNameRes->rItems[0].pDomain,
                                            &pszDomain);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Now, we'll bind to the object, and then do the read
                //
                dwErr = LDAPBind(pszDomain,
                                 ppLDAP);
                LocalFree(pszDomain);
            }
        }
    }

    if(hDS != NULL)
    {
        DsUnBindW(&hDS);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringWToStringA(pNameRes->rItems[0].pName,
                                        &pszOU);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = LDAPReadAttribute(pszOU,
                                      "subschemaSubentry",
                                      *ppLDAP,
                                      &cValues,
                                      &ppszValues);
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        PSTR    pszSchemaPath = NULL;
        PWSTR   pwszSchemaPath = NULL;

        pszSchemaPath = strstr(ppszValues[0],
                               "CN=Schema");
        if(pszSchemaPath == NULL)
        {
            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            //
            // Now that we have the proper schema path, we'll return it
            //
            *ppszSchemaPath = (PSTR)LocalAlloc(LMEM_FIXED,
                                               strlen(pszSchemaPath) + 1);
            if(*ppszSchemaPath == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                strcpy(*ppszSchemaPath,
                       pszSchemaPath);
            }

        }

        //
        // Don't need the LDAP returned schema path anymore...
        //
        LDAPFreeValues(ppszValues);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        LDAPUnbind(*ppLDAP);
        *ppLDAP = NULL;
    }


    DsFreeNameResultW(pNameRes);

    return(dwErr);
}




DWORD
LDAPReadSecAndObjIdAsString (
    IN  PLDAP           pLDAP,
    IN  PSTR            pszSchemaPath,
    IN  PSTR            pszObject,
    OUT PWSTR          *ppwszObjIdAsString,
    OUT PACTRL_ACCESS  *ppAccess
    )
/*++

Routine Description:

    Reads the schemaID off of the specified object type and converts it
    to a string

Arguments:

    pLDAP - LDAP connection to use for attribute read
    pszSchemaPath - Path to the schema for this object
    pszObject - LDAP name of the object for which to get the GUID
    ppwszObjIdAsString - Where the string representation of the GUID
                         is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

Notes:

    The returned string should be freed via a call to RpcFreeString (or as
    part of the whole list, by FreeIdList)

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, build the new schema path...
    //
    PSTR    pszBase = NULL;
    PSTR   *ppszValues = NULL;
    ULONG   cValues;
    DWORD   i,j;

    pszBase = (PSTR)LocalAlloc(LMEM_FIXED,
                               3                        +   // strlen("CN=")
                               strlen(pszObject)        +
                               1                        +   // strlen(",")
                               strlen(pszSchemaPath)    +
                               1);
    if(pszBase == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        sprintf(pszBase,
                "CN=%s,%s",
                pszObject,
                pszSchemaPath);


        //
        // We may not always want the object name
        //
        if(ppwszObjIdAsString != NULL)
        {
            dwErr = LDAPReadAttribute(pszBase,
                                      "SchemaIdGUID",
                                      pLDAP,
                                      &cValues,
                                      &ppszValues);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // The object we get back is actually a GUID
                //
                GUID   *pGuid = (GUID *)ppszValues[0];

                dwErr = UuidToStringW((GUID *)ppszValues[0],
                                      ppwszObjIdAsString);


                LDAPFreeValues(ppszValues);
            }
        }

        //
        // Then, if that worked, and we need to, we'll read the default
        // security
        //
        if(dwErr == ERROR_SUCCESS && ppAccess != NULL)
        {
            dwErr = LDAPReadAttribute(pszBase,
                                      "defaultSecurityDescriptor",
                                      pLDAP,
                                      &cValues,
                                      &ppszValues);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Get it as a security descriptor
                //
                PSECURITY_DESCRIPTOR pSD =
                                        (PSECURITY_DESCRIPTOR)ppszValues[0];
                //
                // This is an NT5 security API
                //
                dwErr = ConvertSecurityDescriptorToAccessNamedW
                                (NULL,               // There is no object
                                 SE_DS_OBJECT,
                                 pSD,
                                 ppAccess,
                                 NULL,
                                 NULL,
                                 NULL);
                LDAPFreeValues(ppszValues);
            }
            else
            {
                //
                // If the attribute wasn't found, try looking up the chain
                //
                if(dwErr == LDAP_NO_SUCH_ATTRIBUTE)
                {
                    dwErr = LDAPReadAttribute(pszBase,
                                              "subClassOf",
                                              pLDAP,
                                              &cValues,
                                              &ppszValues);
                    //
                    // Ok, if that worked, we'll call ourselves.  Note that
                    // we don't care about the object name
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = LDAPReadSecAndObjIdAsString(pLDAP,
                                                            ppszValues[0],
                                                            pszSchemaPath,
                                                            NULL,
                                                            ppAccess);
                        LDAPFreeValues(ppszValues);
                    }
                }
            }

            //
            // If it worked in that we read the access, we'll go through
            // and create all these as inherit entries
            //
            if(dwErr == ERROR_SUCCESS)
            {
                for(i = 0; i < (DWORD)((*ppAccess)->cEntries); i++)
                {
                    for(j = 0;
                        j < (DWORD)((*ppAccess)->pPropertyAccessList[i].
                                                  pAccessEntryList->cEntries);
                        j++)
                    {
                        (*ppAccess)->pPropertyAccessList[i].
                                pAccessEntryList->pAccessList[j].
                                      lpInheritProperty = *ppwszObjIdAsString;
                        (*ppAccess)->pPropertyAccessList[i].
                              pAccessEntryList->pAccessList[j].Inheritance |=
                                           SUB_CONTAINERS_AND_OBJECTS_INHERIT;
                    }
                }
            }

            //
            // If it failed, don't forget to deallocate our memory
            //
            if(dwErr != ERROR_SUCCESS && ppwszObjIdAsString != NULL)
            {
                RpcStringFree(ppwszObjIdAsString);
            }
        }

        //
        // Free our memory
        //
        LocalFree(pszBase);
    }
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\dsace.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"


//This constructor is used to initialize from an Ace
CAce::CAce( )
            :m_AceFlags( 0 ), 
            m_AceType( ALLOW ),
            m_ObjectTypeType( DSACLS_SELF), 
            m_Flags( 0 ),
            m_Mask( 0 ), 
            m_pSid( NULL ),
            m_szObjectType( NULL ), 
            m_szTrusteeName( NULL ),
            m_szInheritedObjectType( NULL ),
            m_bErased( FALSE ),
            m_GuidObjectType( GUID_NULL ),
            m_GuidInheritedObjectType( GUID_NULL )
{}

CAce::~CAce()
{
   if( m_pSid )
      LocalFree( m_pSid );
   if( m_szTrusteeName )
      LocalFree( m_szTrusteeName );
   if( m_szInheritedObjectType )
      LocalFree( m_szInheritedObjectType );
   if( m_szObjectType )
      LocalFree( m_szObjectType );
}


DWORD CAce::Initialize( PACE_HEADER pAceHeader, UINT nAllowDeny, UINT nAudit )
{
   DWORD dwErr = ERROR_SUCCESS;
   ASSERT( pAceHeader != NULL );

   m_nAllowDeny = nAllowDeny;
   m_nAudit = nAudit;
   
   m_AceFlags = pAceHeader->AceFlags;   
   m_Mask = ((PKNOWN_ACE)pAceHeader)->Mask;
   MapGeneric(&m_Mask);
   
   // Is this an object ACE?
   if (IsObjectAceType(pAceHeader))
   {
      GUID *pGuid;

      // Copy the object type guid if present
      pGuid = RtlObjectAceObjectType(pAceHeader);
      if (pGuid)
      {  
         m_Flags |= ACE_OBJECT_TYPE_PRESENT;
         m_GuidObjectType = *pGuid;
      }

      // Copy the inherit type guid if present
      pGuid = RtlObjectAceInheritedObjectType(pAceHeader);
      if (pGuid)
      {
         m_Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
         m_GuidInheritedObjectType = *pGuid;
      }
   }

   // Copy the SID
   PSID psidT = GetAceSid(pAceHeader);
   DWORD nSidLength = GetLengthSid(psidT);

   m_pSid = (PSID)LocalAlloc(LPTR, nSidLength);
   if (m_pSid)
      CopyMemory(m_pSid, psidT, nSidLength);
   else
      return ERROR_NOT_ENOUGH_MEMORY;

   //Get the Trustee Name from the SID
   dwErr = GetAccountNameFromSid( g_szServerName, m_pSid, &m_szTrusteeName );
   if( dwErr != ERROR_SUCCESS )
      return dwErr;
   m_AceType = GetAceType( pAceHeader );

   if( m_AceType == ALLOW )
      m_AccessMode = GRANT_ACCESS;
   else
      m_AccessMode = DENY_ACCESS;
   

   //Get LDAP display name of ObjectType
   if( FlagOn( m_Flags, ACE_OBJECT_TYPE_PRESENT) )
   {  
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( &m_GuidObjectType );
      //Found in Cache, copy the name
      if( pItemCache )
      {
         if( ( dwErr = CopyUnicodeString( &m_szObjectType, pItemCache->pszName ) ) != ERROR_SUCCESS )
            return dwErr;
         m_ObjectTypeType = pItemCache->ObjectTypeType;
      }
      //Add to cache, Guid will be resolved when cache is build
      else
         g_Cache->AddItem( &m_GuidObjectType );
   }

   //Get the LDAP display name for the InheriteObjectType
   if( FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) )
   {
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( &m_GuidInheritedObjectType );
      if( pItemCache )
      {
         if( ( dwErr = CopyUnicodeString( &m_szInheritedObjectType, pItemCache->pszName ) ) != ERROR_SUCCESS )
            return ERROR_SUCCESS;
      }
      else
         g_Cache->AddItem( &m_GuidInheritedObjectType );
   }

   return ERROR_SUCCESS;
}
                  
DWORD CAce::Initialize( LPWSTR pszTrustee,
                        LPWSTR pszObjectId,
                        LPWSTR pszInheritId,
                        ACCESS_MODE AccessMode,
                        ACCESS_MASK Access,
                        BYTE Inheritance 
                        )
{
   DWORD dwErr = ERROR_SUCCESS; 
   m_AceFlags = Inheritance;
   m_Mask = Access;
   MapGeneric(&m_Mask);
   m_AccessMode = AccessMode;
   // Is this an object ACE?
   if ( pszObjectId || pszInheritId )
   {
      if ( pszObjectId )
      {  
         m_Flags |= ACE_OBJECT_TYPE_PRESENT;
         dwErr = CopyUnicodeString( &m_szObjectType,pszObjectId );
         if( dwErr != ERROR_SUCCESS )
            return dwErr;
      }

      // Copy the inherit type guid if present
      if ( pszInheritId )
      {
         m_Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
         dwErr = CopyUnicodeString( &m_szInheritedObjectType ,pszInheritId);
         if( dwErr != ERROR_SUCCESS )
            return dwErr;
      }
   }   
      
   if( ( dwErr = CopyUnicodeString( &m_szTrusteeName, pszTrustee ) ) != ERROR_SUCCESS )
      return dwErr;
   if( ( dwErr = GetSidFromAccountName( g_szServerName,
                                        &m_pSid, 
                                        m_szTrusteeName ) ) != ERROR_SUCCESS )
   {
      DisplayMessageEx( 0, MSG_DSACLS_NO_MATCHING_SID, m_szTrusteeName );
      return dwErr;
   }
   //AceType
   if( m_AccessMode == GRANT_ACCESS )
      m_AceType = ALLOW;
   else if ( m_AccessMode == DENY_ACCESS )
      m_AceType = DENY;
   //else Doesn't Matter


   //Get LDAP display name of ObjectType
   if( FlagOn( m_Flags, ACE_OBJECT_TYPE_PRESENT) )
   {  
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( m_szObjectType );
      if( pItemCache )
      {
         m_GuidObjectType = pItemCache->Guid;
      }
      else
         g_Cache->AddItem( m_szObjectType );
   }

   //Get the LDAP display name for the InheriteObjectType
   if( FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) )
   {
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( m_szInheritedObjectType );
      if( pItemCache )
      {
         m_GuidInheritedObjectType = pItemCache->Guid;
      }
      else
         g_Cache->AddItem( m_szInheritedObjectType );

   }
   return ERROR_SUCCESS;
}


GUID* CAce::GetGuidObjectType()
{ 
   if( !IsEqualGUID( m_GuidObjectType, GUID_NULL ) )
      return &m_GuidObjectType; 
   return NULL;
}

GUID* CAce::GetGuidInheritType() 
{
   if( !IsEqualGUID( m_GuidInheritedObjectType, GUID_NULL ) )
      return &m_GuidInheritedObjectType; 
   return NULL;
}

VOID CAce::Display( UINT nMaxTrusteeLength )
{
WCHAR szLoadBuffer[1024];
WCHAR szDisplayBuffer[1024];
HMODULE hInstance = GetModuleHandle(NULL);
DWORD err=0;
UINT nAccessDisplayLen = 0;
UINT uID = 0;
UINT nLen = 0;

   switch ( m_AceType )
   {
      case ALLOW:
         uID = MSG_DSACLS_ALLOW;
         break;
      case DENY:
         uID = MSG_DSACLS_DENY;
         break;
      case AUDIT_SUCCESS:
         uID = MSG_DSACLS_AUDIT_SUCCESS;
         break;
      case AUDIT_FAILURE:
         uID = MSG_DSACLS_AUDIT_FAILURE;
         break;
      case AUDIT_ALL:
         uID = MSG_DSACLS_AUDIT_ALL;
         break;

   }
   nLen = LoadStringW( hInstance, uID, szLoadBuffer, 1023 );
   
   if( m_AceType == ALLOW || m_AceType == DENY )
      nLen = m_nAllowDeny - nLen;
   else
      nLen = m_nAudit - nLen;
    
   wcscpy(szDisplayBuffer,szLoadBuffer );

   StringWithNSpace(1 + nLen ,szLoadBuffer );

   wcscat( szDisplayBuffer, szLoadBuffer );
   wcscat( szDisplayBuffer, m_szTrusteeName );

   nLen = wcslen( m_szTrusteeName );
   StringWithNSpace(2 + ( nMaxTrusteeLength - nLen ), szLoadBuffer );
   wcscat( szDisplayBuffer, szLoadBuffer );
   if( m_ObjectTypeType == DSACLS_EXTENDED_RIGHTS )
   {
      wcscat( szDisplayBuffer, GetObjectType() );
   }
   else
   {
      nAccessDisplayLen = wcslen( szDisplayBuffer );

      ConvertAccessMaskToGenericString( m_Mask, szLoadBuffer, 1023 );

      if( m_ObjectTypeType == DSACLS_CHILD_OBJECTS || 
          m_ObjectTypeType == DSACLS_PROPERTY  ||
          m_ObjectTypeType == DSACLS_VALIDATED_RIGHTS )
      {
         LPWSTR szTemp = NULL;
         if( ERROR_SUCCESS == ( err = LoadMessage( MSG_DSACLS_ACCESS_FOR, &szTemp, szLoadBuffer, GetObjectType() ) ) )
         {
            wcscat( szDisplayBuffer, szTemp );
            LocalFree(szTemp);
         }

      }
      else  
         wcscat( szDisplayBuffer, szLoadBuffer );
   }

   if( IsInheritedFromParent() )
   {
      StringWithNSpace(3, szLoadBuffer );
      wcscat( szDisplayBuffer, szLoadBuffer );
      LoadString( hInstance, MSG_DSACLS_INHERITED_FROM_PARENT, szLoadBuffer, 1023 );
      wcscat( szDisplayBuffer, szLoadBuffer );
   }
   
   DisplayStringWithNewLine(0, szDisplayBuffer );

   if( m_ObjectTypeType != DSACLS_EXTENDED_RIGHTS && 
       ( GENERIC_ALL_MAPPING != ( m_Mask & GENERIC_ALL_MAPPING ) ) )
      DisplayAccessRights( nAccessDisplayLen, m_Mask );
}


CAcl::~CAcl()
{
   CAce *pAce= NULL;
   for( list<CAce*>::iterator i = listAces.begin(); i != listAces.end(); ++i )
   {
      pAce = (*i);
      pAce->~CAce();
      //delete (*i);
   }
}

DWORD CAcl::Initialize( BOOL bProtected, PACL pAcl, UINT nAllowDeny, UINT nAudit )
{
   DWORD dwErr = ERROR_SUCCESS;

   bAclProtected = bProtected;

   if( pAcl == NULL )
      return ERROR_SUCCESS;
   UINT nMaxTrusteeLength = 0;
   PACE_HEADER pAceHeader = (PACE_HEADER) FirstAce(pAcl);
   for ( int j = 0; j < pAcl->AceCount; j++, pAceHeader = (PACE_HEADER) NextAce(pAceHeader))
   {
      CAce * pAce = new CAce();
      if( !pAce )
         return ERROR_NOT_ENOUGH_MEMORY;
      dwErr = pAce->Initialize( pAceHeader, nAllowDeny, nAudit );
      if( dwErr != ERROR_SUCCESS )
      {
         delete pAce;
         return dwErr;
       }
      if( nMaxTrusteeLength < pAce->GetTrusteeLength() )
         nMaxTrusteeLength = pAce->GetTrusteeLength();

      listAces.push_back( pAce );

      if( pAce->IsEffective() )
         listEffective.push_back( pAce );

      if( pAce->IsInheritedToAll() )
         listInheritedAll.push_back( pAce );

      if( pAce->IsInheritedToSpecific() )
         listInheritedSpecific.push_back( pAce );

   }

   m_nMaxTrusteeLength = nMaxTrusteeLength;
   return ERROR_SUCCESS;
}


VOID CAcl::AddAce( CAce *pAce )
{
   listAces.push_back(pAce);
}

VOID CAcl::MergeAcl( CAcl * pAcl )
{
   for( list<CAce*>::iterator i = pAcl->listAces.begin(); i != pAcl->listAces.end(); ++i )
   {
      if( (*i)->GetAccessMode() == REVOKE_ACCESS )
      {
         //Remove all Aces from this->listAces which have same sid
         for( list<CAce*>::iterator j = listAces.begin(); j != listAces.end(); ++j )
         {
            if( EqualSid( (*i)->GetSID(), (*j)->GetSID() ) )
               (*j)->SetErased(TRUE);
         }        
      }
      else
      {  
         AddAce( (*i) );
      }     
   }
   //After Merging pAcl should be empty()
   for( i = pAcl->listAces.begin(); i != pAcl->listAces.end(); ++i )
   {
      if( (*i)->GetAccessMode() == REVOKE_ACCESS )
      {
         delete (*i);
      }
   }
   while( !pAcl->listAces.empty() )
   {
      pAcl->listAces.pop_back();
   }
}

DWORD CAcl::BuildAcl( PACL *ppAcl )
{
   ULONG cAceCount = 0;
   PEXPLICIT_ACCESS pListOfExplicitEntries = NULL;
   DWORD dwErr = ERROR_SUCCESS;
   for( list<CAce*>::iterator j = listAces.begin(); j != listAces.end(); ++j )
   {
     if( !(*j)->IsErased() )
         ++cAceCount;
   }
   pListOfExplicitEntries = (PEXPLICIT_ACCESS)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                               cAceCount * sizeof( EXPLICIT_ACCESS ) );
   if ( pListOfExplicitEntries == NULL ) 
   {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        return dwErr;
   }   
   
   cAceCount = 0;
   for(  j = listAces.begin(); j != listAces.end(); ++j )
   {
     if( !(*j)->IsErased() )
     {
         dwErr = BuildExplicitAccess( (*j)->GetSID(),
                                      (*j)->GetGuidObjectType(),
                                      (*j)->GetGuidInheritType(),
                                      (*j)->GetAccessMode(),
                                      (*j)->GetAccessMask(),
                                      (*j)->GetAceFlags(),
                                      &pListOfExplicitEntries[cAceCount] );
         if( dwErr != ERROR_SUCCESS )
            break;

         ++cAceCount;
      }
   }
   
   if( dwErr == ERROR_SUCCESS )
   {
      dwErr = SetEntriesInAcl( cAceCount, 
                               pListOfExplicitEntries,
                               NULL,
                               ppAcl );
   }
    //
    // Free the memory from the access entry list
    //
   for ( int i = 0; i < cAceCount; i++ ) 
   {
      if( pListOfExplicitEntries[i].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID )
      {
         POBJECTS_AND_SID pOAS = (POBJECTS_AND_SID)pListOfExplicitEntries[i].Trustee.ptstrName;
         if( pOAS  && pOAS->pSid )
            LocalFree( pOAS->pSid );
         if( pOAS )
            LocalFree( pOAS );
      }
      else
         LocalFree( pListOfExplicitEntries[i].Trustee.ptstrName );
   }
   LocalFree( pListOfExplicitEntries );

   return dwErr;
}

VOID CAcl::GetInfoFromCache()
{

LPWSTR pszTemp = NULL;
GUID * pGuid = NULL;
PDSACL_CACHE_ITEM pItem = NULL;
DWORD dwErr = ERROR_SUCCESS;
WCHAR szGuid[39];

   for ( list<CAce*>::iterator i = listAces.begin(); i != listAces.end(); i++ )
   {
      if( (*i)->IsObjectTypePresent() )
      {
         if( (*i)->GetGuidObjectType() == NULL )
         {
               pItem = g_Cache->LookUp( (*i)->GetObjectType() );
               if( pItem )
               {
                  (*i)->SetGuidObjectType( &pItem->Guid );
                  (*i)->SetObjectTypeType( pItem->ObjectTypeType );
               }
            //else is fatal error since we cannot get guid this is taken care in verify
            
         }
         else if( (*i)->GetObjectType() == NULL )
         {

               pItem = g_Cache->LookUp( (*i)->GetGuidObjectType() );
               if( pItem )
               {
                  (*i)->SetObjectType( pItem->pszName );
                  (*i)->SetObjectTypeType( pItem->ObjectTypeType );
               }
               else
               {    
                  FormatStringGUID( szGuid, 38, (*i)->GetGuidObjectType() );
                  (*i)->SetObjectType( szGuid );
                  (*i)->SetObjectTypeType( DSACLS_UNDEFINED );
               }
         }
      }
      if( (*i)->IsInheritedTypePresent() )
      {
         if( (*i)->GetGuidInheritType() == NULL )
         {               
               pItem = g_Cache->LookUp( (*i)->GetInheritedObjectType() );
               if( pItem )
               {
                  (*i)->SetGuidInheritType( &pItem->Guid );
               }
            //else is fatal error since we cannot get guid this is taken care in verify
         }
         else if( (*i)->GetInheritedObjectType() == NULL )
         {
               pItem = g_Cache->LookUp( (*i)->GetGuidInheritType() );
               if( pItem )
               {
                  (*i)->SetInheritedObjectType( pItem->pszName );
               }
               else
               {    
                  FormatStringGUID( szGuid, 38, (*i)->GetGuidInheritType() );
                  (*i)->SetInheritedObjectType( szGuid );
               }
            
         }
      }
      
   }
}

BOOL CAcl::VerifyAllNames()
{
   for ( list<CAce*>::iterator i = listAces.begin(); i != listAces.end(); i++ )
   {
      if( (*i)->IsObjectTypePresent() )
      {
         if( (*i)->GetGuidObjectType() == NULL )
         {
            DisplayMessageEx(0, MSG_DSACLS_NO_MATCHING_GUID, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_PROPERTY &&
              (((*i)->GetAccessMask() & (~(ACTRL_DS_WRITE_PROP|ACTRL_DS_READ_PROP))) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_PROPERTY_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_EXTENDED_RIGHTS &&
              (((*i)->GetAccessMask() & (~ACTRL_DS_CONTROL_ACCESS)) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_EXTENDED_RIGHTS_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_VALIDATED_RIGHTS &&
              (((*i)->GetAccessMask() & (~ACTRL_DS_SELF)) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_VALIDATED_RIGHTS_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_CHILD_OBJECTS &&
              (((*i)->GetAccessMask() & (~(ACTRL_DS_CREATE_CHILD|ACTRL_DS_DELETE_CHILD))) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_CHILD_OBJECT_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
      }
      if( (*i)->IsInheritedTypePresent() )
      {
         if( (*i)->GetGuidInheritType() == NULL )
         {
            DisplayMessageEx(0, MSG_DSACLS_NO_MATCHING_GUID, (*i)->GetInheritedObjectType() );
            return FALSE;
         }

         if( (*i)->GetAceFlags() != (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE) )
         {
            DisplayMessageEx(0, MSG_DSACLS_INCORRECT_INHERIT, (*i)->GetInheritedObjectType() );
            return FALSE;
         }
      }
   }
   return TRUE;
}  

void CAcl::Display()
{
   if( bAclProtected )
      DisplayMessageEx( 0, MSG_DSACLS_PROTECTED );
   if( listAces.empty() )
   {
      DisplayMessageEx( 0, MSG_DSACLS_NO_ACES );
   }
   //Display Effective permissons on this object
   if ( !listEffective.empty() )
   {
      DisplayMessageEx( 0, MSG_DSACLS_EFFECTIVE );
      for ( list<CAce*>::iterator i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( !(*i)->IsObjectTypePresent() )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for (  i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_CHILD_OBJECTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_PROPERTY )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_VALIDATED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_EXTENDED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      DisplayNewLine();
   }
   if( !listInheritedAll.empty() || !listInheritedSpecific.empty() )
      DisplayMessageEx( 0, MSG_DSACLS_INHERITED );

   //Display permissons inherited by all subobjects
   if( !listInheritedAll.empty() )
   {
      DisplayMessageEx( 0, MSG_DSACLS_INHERITED_ALL );
      for ( list<CAce*>::iterator i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( !(*i)->IsObjectTypePresent() )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_CHILD_OBJECTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for (  i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_PROPERTY )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for (  i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_VALIDATED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }

      for ( i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_EXTENDED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      DisplayNewLine();

   }
   
   LPWSTR pszInherit = NULL;
   //Display permissons inherited to Inherited Object Class
   if( !listInheritedSpecific.empty() )
   {
      listInheritedSpecific.sort(CACE_SORT());
      for ( list<CAce*>::iterator i = listInheritedSpecific.begin(); i != listInheritedSpecific.end(); i++ )
      {
         if( !pszInherit )
         {
            pszInherit = (*i)->GetInheritedObjectType();
            DisplayMessageEx( 0, MSG_DSACLS_INHERITED_SPECIFIC, pszInherit );
         }
         else if( wcscmp( pszInherit,(*i)->GetInheritedObjectType() )  )
         {
               pszInherit = (*i)->GetInheritedObjectType();
               DisplayMessageEx( 0, MSG_DSACLS_INHERITED_SPECIFIC, pszInherit );
         }  
         (*i)->Display( m_nMaxTrusteeLength );
     }
   }
}





DWORD CCache::AddItem( GUID *pGuid,
                       DSACLS_SEARCH_IN s )
{
   ASSERT( pGuid );
   PDSACL_CACHE_ITEM pItem = NULL;

   pItem = (PDSACL_CACHE_ITEM)LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
   if( pItem == NULL )
      return ERROR_NOT_ENOUGH_MEMORY;

   pItem->Guid = *pGuid;
   pItem->pszName = NULL;
   pItem->bResolved = FALSE;
   pItem->resolve = RESOLVE_GUID;
   pItem->searchIn = s;
   m_listItem.push_back( pItem );

   return ERROR_SUCCESS;
}

DWORD CCache::AddItem( LPWSTR pName,
                       DSACLS_SEARCH_IN s  )
{
   ASSERT( pName );
   PDSACL_CACHE_ITEM pItem = NULL;
   DWORD dwErr = ERROR_SUCCESS;

   pItem = (PDSACL_CACHE_ITEM)LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
   if( pItem == NULL )
      return ERROR_NOT_ENOUGH_MEMORY;

   dwErr = CopyUnicodeString(&pItem->pszName, pName );
   if( dwErr != ERROR_SUCCESS )
   {
      LocalFree( pItem );
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   
   pItem->bResolved = FALSE;
   pItem->resolve = RESOLVE_NAME;
   pItem->searchIn = s;

   m_listItem.push_back( pItem );

   return ERROR_SUCCESS;
}

DWORD CCache::BuildCache()
{
   SearchConfiguration();
   SearchSchema();
   
   PDSACL_CACHE_ITEM pItem = NULL;
   //Empty m_listItem
   while( !m_listItem.empty() )
   {
      pItem = m_listItem.back();
      m_listItem.pop_back();
      if( pItem->pszName)
         LocalFree( pItem->pszName );
      LocalFree( pItem );
   }

   return ERROR_SUCCESS;
}
   
   
DWORD CCache::SearchConfiguration()
{
   ULONG nTotalFilterSize = 1024;
   ULONG nCurrentFilterSize = 0;
   LPWSTR lpszFilter = NULL;
   LPWSTR lpszFilterTemp = NULL;   
   WCHAR szTempBuffer[1024];
   WCHAR szTempString[1024];
   DWORD dwErr = 0;
   HRESULT hr = S_OK;
   IDirectorySearch * IDs = NULL;
   ADS_SEARCH_HANDLE hSearchHandle=NULL;  
   LPWSTR lpszConfigGuidFilter = L"(rightsGuid=%s)";
   LPWSTR lpszConfigNameFilter = L"(displayName=%s)";    
   LPWSTR pszAttr[] = { L"rightsGuid",L"displayName", L"validAccesses" };
   ADS_SEARCH_COLUMN col,col1,col2;
   ULONG uLen = 0;
   list<PDSACL_CACHE_ITEM>::iterator i;
   PDSACL_CACHE_ITEM pCacheItem = NULL;
   if( m_listItem.empty() )
      return ERROR_SUCCESS;
   

   lpszFilter = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize*sizeof(WCHAR) );
   if( lpszFilter == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   
   wcscpy(lpszFilter, L"(|" );
   nCurrentFilterSize = 4; //One for closing (

   for (  i = m_listItem.begin(); i != m_listItem.end(); i++ )
   {
      if( (*i)->resolve == RESOLVE_GUID && 
          ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == CONFIGURATION ) ) )
      {
         FormatStringGUID( szTempString, ARRAYSIZE(szTempString), &(*i)->Guid );
         hr = StringCchPrintf(szTempBuffer,ARRAYSIZE(szTempBuffer),lpszConfigGuidFilter,szTempString);
         if(FAILED(hr))
         {
             dwErr = HRESULT_CODE(hr);
             goto FAILURE_RETURN;
         }
         
         nCurrentFilterSize += wcslen(szTempBuffer);
      }
      else if( (*i)->resolve == RESOLVE_NAME && 
             ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == SCHEMA ) ) )
      {
            hr = StringCchPrintf(szTempBuffer,ARRAYSIZE(szTempBuffer),lpszConfigNameFilter,(*i)->pszName);
            if(FAILED(hr))
            {
                dwErr = HRESULT_CODE(hr);
                goto FAILURE_RETURN;
            }
            nCurrentFilterSize += wcslen(szTempBuffer);
      }

      if( nCurrentFilterSize > nTotalFilterSize )
      {
         nTotalFilterSize = nTotalFilterSize * 2;
         lpszFilterTemp = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize * sizeof( WCHAR ) );
         if( lpszFilterTemp == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         wcscpy( lpszFilterTemp, lpszFilter );
         LocalFree(lpszFilter);
         lpszFilter = lpszFilterTemp;
         lpszFilterTemp = NULL;
      }
      hr = StringCchCat(lpszFilter,nTotalFilterSize,szTempBuffer);      
      if(FAILED(hr))
      {
          dwErr = HRESULT_CODE(hr);
          goto FAILURE_RETURN;
      }
   }
   hr = StringCchCat(lpszFilter,nTotalFilterSize,L")");
   if(FAILED(hr))
   {
       dwErr = HRESULT_CODE(hr);
       goto FAILURE_RETURN;
   }
   
   //We have Filter Now

   //Search in Configuration Contianer
   hr = ::ADsOpenObject( g_szConfigurationNamingContext,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectorySearch,
                         (void **)&IDs );

   if( hr != S_OK )
   {
      dwErr = HRESULT_CODE( hr );
      goto FAILURE_RETURN;
   }

   hr = IDs->ExecuteSearch(lpszFilter,
                           pszAttr,
                           3,
                           &hSearchHandle );

   if( hr != S_OK )
   {  
      dwErr = HRESULT_CODE( hr );
      goto FAILURE_RETURN;
   }


   hr = IDs->GetFirstRow(hSearchHandle);
   if( hr == S_OK )
   {  
      while( hr != S_ADS_NOMORE_ROWS )
      {
         pCacheItem = (PDSACL_CACHE_ITEM) LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
         if( pCacheItem == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         
         //Get Guid
         hr = IDs->GetColumn( hSearchHandle, pszAttr[0], &col );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }

         GuidFromString( &pCacheItem->Guid, col.pADsValues->CaseIgnoreString);
         IDs->FreeColumn( &col );
         
         //Get Display Name                     
         hr = IDs->GetColumn( hSearchHandle, pszAttr[1], &col1 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         uLen = wcslen( (LPWSTR) col1.pADsValues->CaseIgnoreString );
         pCacheItem->pszName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( uLen + 1 ) * sizeof( WCHAR) );
         if( pCacheItem->pszName == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         wcscpy( pCacheItem->pszName, col1.pADsValues->CaseIgnoreString );
         IDs->FreeColumn( &col1 );

         //Get validAccesses
         hr = IDs->GetColumn( hSearchHandle, pszAttr[2], &col2 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         pCacheItem->ObjectTypeType = GetObjectTypeType( col2.pADsValues->Integer );
         IDs->FreeColumn( &col2 );
         //Add item to cache
         m_listCache.push_back( pCacheItem );
         pCacheItem = NULL;
         hr = IDs->GetNextRow(hSearchHandle);
      }

   }
   if( hr == S_ADS_NOMORE_ROWS )
      dwErr = ERROR_SUCCESS;
   


   
FAILURE_RETURN:
   if( lpszFilter )
      LocalFree( lpszFilter );

  
   if( IDs )
   {
      if( hSearchHandle )
         IDs->CloseSearchHandle( hSearchHandle );
      IDs->Release();
   }
   if( pCacheItem )
      LocalFree( pCacheItem );

   return dwErr;
}   
 
DWORD CCache::SearchSchema()
{
   ULONG nTotalFilterSize = 1024;
   ULONG nCurrentFilterSize = 0;
   LPWSTR lpszFilter = NULL;
   LPWSTR lpszFilterTemp = NULL;
   WCHAR szTempBuffer[1024];
   WCHAR szTempString[1024];
   LPWSTR pszDestData = NULL;
   DWORD dwErr = 0;
   HRESULT hr = S_OK;
   IDirectorySearch * IDs = NULL;
   ADS_SEARCH_HANDLE hSearchHandle=NULL;  
   LPWSTR lpszSchemaGuidFilter = L"(schemaIdGuid=%s)";
   LPWSTR lpszSchemaNameFilter = L"(LDAPdisplayName=%s)";    
   LPWSTR pszAttr[] = {L"schemaIdGuid",L"LDAPdisplayName", L"objectClass"};
   ADS_SEARCH_COLUMN col,col1,col2;
   ULONG uLen = 0;
   list<PDSACL_CACHE_ITEM>::iterator i;
   PDSACL_CACHE_ITEM pCacheItem = NULL;
   if( m_listItem.empty() )
      return ERROR_SUCCESS;
    

   lpszFilter = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize*sizeof(WCHAR) );
   if( lpszFilter == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   
   wcscpy(lpszFilter, L"(|" );
   nCurrentFilterSize = 4; //One for closing (

   for (  i = m_listItem.begin(); i != m_listItem.end(); i++ )
   {
      if( (*i)->resolve == RESOLVE_GUID && 
          ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == SCHEMA ) ) )
      {
         ADsEncodeBinaryData( (PBYTE)&((*i)->Guid),
                              sizeof(GUID),
                              &pszDestData  );
         hr = StringCchPrintf(szTempBuffer,ARRAYSIZE(szTempBuffer),lpszSchemaGuidFilter,pszDestData);
         LocalFree( pszDestData );
         pszDestData = NULL;

         if(FAILED(hr))
         {
             dwErr = HRESULT_CODE(hr);
             goto FAILURE_RETURN;
         }
         nCurrentFilterSize += wcslen(szTempBuffer);
      }
      else if( (*i)->resolve == RESOLVE_NAME && 
             ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == SCHEMA ) ) )
      {
            hr = StringCchPrintf(szTempBuffer,ARRAYSIZE(szTempBuffer),lpszSchemaNameFilter,(*i)->pszName );
            if(FAILED(hr))
            {
                dwErr = HRESULT_CODE(hr);
                goto FAILURE_RETURN;
            }

            nCurrentFilterSize += wcslen(szTempBuffer);
      }
      if( nCurrentFilterSize > nTotalFilterSize )
      {
         nTotalFilterSize = nTotalFilterSize * 2;
         lpszFilterTemp = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize * sizeof( WCHAR ) );
         if( lpszFilterTemp == NULL )
         {
               dwErr = ERROR_NOT_ENOUGH_MEMORY;
               goto FAILURE_RETURN;
         }
         wcscpy( lpszFilterTemp, lpszFilter );
         LocalFree( lpszFilter );
         lpszFilter = lpszFilterTemp;
         lpszFilterTemp = NULL;
      }
      hr = StringCchCat(lpszFilter,nTotalFilterSize,szTempBuffer);
      if(FAILED(hr))
      {
          dwErr = HRESULT_CODE(hr);
          goto FAILURE_RETURN;
      }
   }
   hr = StringCchCat(lpszFilter,nTotalFilterSize,L")");
   if(FAILED(hr))
   {
       dwErr = HRESULT_CODE(hr);
       goto FAILURE_RETURN;      
   }
   
   //We have Filter Now

   //Search in Configuration Contianer
   hr = ::ADsOpenObject( g_szSchemaNamingContext,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectorySearch,
                         (void **)&IDs );

   if( hr != S_OK )
   {
      dwErr = HRESULT_CODE( hr );
      goto FAILURE_RETURN;
   }

   hr = IDs->ExecuteSearch(lpszFilter,
                           pszAttr,
                           3,
                           &hSearchHandle );

   if( hr != S_OK )
   {  
      dwErr = HRESULT_CODE( hr );
      goto FAILURE_RETURN;
   }


   hr = IDs->GetFirstRow(hSearchHandle);
   if( hr == S_OK )
   {  
      while( hr != S_ADS_NOMORE_ROWS )
      {
         pCacheItem = (PDSACL_CACHE_ITEM) LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
         if( pCacheItem == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         
         //Get Guid
         hr = IDs->GetColumn( hSearchHandle, pszAttr[0], &col );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }

         if(sizeof(GUID) != col.pADsValues->OctetString.dwLength)
         {
             dwErr = ERROR_INVALID_PARAMETER;
             goto FAILURE_RETURN;
         }

         memcpy( &pCacheItem->Guid, 
                  col.pADsValues->OctetString.lpValue,
                  col.pADsValues->OctetString.dwLength);
         IDs->FreeColumn( &col );
         
         //Get Display Name                     
         hr = IDs->GetColumn( hSearchHandle, pszAttr[1], &col1 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         uLen = wcslen( (LPWSTR) col1.pADsValues->CaseIgnoreString );
         pCacheItem->pszName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( uLen + 1 ) * sizeof( WCHAR) );
         if( pCacheItem->pszName == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         wcscpy( pCacheItem->pszName, col1.pADsValues->CaseIgnoreString );
         IDs->FreeColumn( &col1 );

         //Get Object Class
         hr = IDs->GetColumn( hSearchHandle, pszAttr[2], &col2 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         pCacheItem->ObjectTypeType = GetObjectTypeType( col2.pADsValues[1].CaseIgnoreString );
         IDs->FreeColumn( &col2 );
         //Add item to cache
         m_listCache.push_back( pCacheItem );
         pCacheItem = NULL;
         hr = IDs->GetNextRow(hSearchHandle);
      }

   }
   if( hr == S_ADS_NOMORE_ROWS )
      dwErr = ERROR_SUCCESS;
   


   
FAILURE_RETURN:
   if( lpszFilter )
      LocalFree( lpszFilter );
   if( IDs )
   {
      if( hSearchHandle )
         IDs->CloseSearchHandle( hSearchHandle );
      IDs->Release();
   }
   if( pCacheItem )
      LocalFree( pCacheItem );

   return dwErr;
}   
 
PDSACL_CACHE_ITEM CCache::LookUp( LPWSTR pszName )
{
   if( m_listCache.empty() )
      return NULL;

   for( list<PDSACL_CACHE_ITEM>::iterator i = m_listCache.begin(); i != m_listCache.end(); ++i )
   {
      if( wcscmp( (*i)->pszName, pszName ) == 0 )
         return (*i);
   }

   return NULL;
}



PDSACL_CACHE_ITEM CCache::LookUp( GUID *pGuid )
{
  if( m_listCache.empty() )
      return NULL;

   for( list<PDSACL_CACHE_ITEM>::iterator i = m_listCache.begin(); i != m_listCache.end(); ++i )
   {
      if( IsEqualGUID( (*i)->Guid, *pGuid ) )
         return (*i);
   }
   return NULL;
}

CCache::~CCache()
{
   for( list<PDSACL_CACHE_ITEM>::iterator i = m_listCache.begin(); i != m_listCache.end(); ++i )
   {
      if( (*i)->pszName )
         LocalFree( (*i)->pszName );
      LocalFree(*i);
   }

   for( i = m_listItem.begin(); i != m_listItem.end(); ++i )
   {
      if( (*i)->pszName )
         LocalFree( (*i)->pszName );
      LocalFree(*i);
   }
}



//Some Utility Functions
DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( INT validAccesses )
{
   if( FLAG_ON( validAccesses , ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP ) )
      return DSACLS_PROPERTY;
   if( FLAG_ON( validAccesses , ACTRL_DS_CONTROL_ACCESS ) )
      return DSACLS_EXTENDED_RIGHTS;
   if( FLAG_ON( validAccesses , ACTRL_DS_SELF ) )
      return DSACLS_VALIDATED_RIGHTS;
   
   return DSACLS_UNDEFINED;
}

DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( LPWSTR szObjectCategory )
{
   if( wcscmp( szObjectCategory, L"attributeSchema" ) == 0 )
      return DSACLS_PROPERTY;
   if( wcscmp( szObjectCategory, L"classSchema" ) == 0 )
      return DSACLS_CHILD_OBJECTS;
   return DSACLS_UNDEFINED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\dsace.h ===
#ifndef _DSACLS_DSACE_H
#define _DSACLS_DSACE_H

#include <iostream>
#include <algorithm>
#include <functional>
#include <list>
using namespace std;

typedef enum _DSACLS_OBJECT_TYPE_TYPE
{
    DSACLS_SELF = 0,     
    DSACLS_CHILD_OBJECTS,
    DSACLS_PROPERTY,
    DSACLS_EXTENDED_RIGHTS,
    DSACLS_VALIDATED_RIGHTS,
    DSACLS_UNDEFINED
        
} DSACLS_OBJECT_TYPE_TYPE;

class CAce
{

typedef enum _DSACLS_ACE_TYPE
{
   ALLOW = 0,
   DENY,
   AUDIT_SUCCESS,
   AUDIT_FAILURE,
   AUDIT_ALL
}DSACLS_ACE_TYPE;


private:
   //Members Present in Ace
   BYTE              m_AceFlags;
   ACCESS_MASK       m_Mask;
   GUID              m_GuidObjectType;
   GUID              m_GuidInheritedObjectType;
   PSID              m_pSid;

   //Data given by users to build an Ace
   ACCESS_MODE       m_AccessMode;
   LPWSTR            m_szTrusteeName;
   LPWSTR            m_szObjectType;               //LDAP display name of CHILD_OBJECT, 
   LPWSTR            m_szInheritedObjectType;

   //Misc Info
   ULONG             m_Flags;                      // ACE_OBJECT_TYPE_PRESENT, etc.   
   DSACLS_OBJECT_TYPE_TYPE m_ObjectTypeType;   
   DSACLS_ACE_TYPE   m_AceType;
   BOOL              m_bErased;                    //This flag is used to mark the ace as deleted.
   //These two are used for format of display
   UINT m_nAllowDeny;              
   UINT m_nAudit;

protected:
   //Is ACE Allow or DENY
   DSACLS_ACE_TYPE  GetAceType( PACE_HEADER pAceHeader )
   {
      if( pAceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE )
      {
         if( pAceHeader->AceFlags &  SUCCESSFUL_ACCESS_ACE_FLAG 
             && pAceHeader->AceFlags & FAILED_ACCESS_ACE_FLAG ) 
            return AUDIT_ALL;
         else if( pAceHeader->AceFlags &  SUCCESSFUL_ACCESS_ACE_FLAG )
            return AUDIT_SUCCESS;
         else if( pAceHeader->AceFlags & FAILED_ACCESS_ACE_FLAG ) 
            return AUDIT_FAILURE;
         else
            ASSERT(FALSE);
      }
      if( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ||
          pAceHeader->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE )
          return ALLOW;
      else 
         return DENY;
   }
public:
   BYTE GetAceFlags(){ return m_AceFlags; }
   ACCESS_MASK GetAccessMask(){ return m_Mask; }
   GUID* GetGuidObjectType();
   VOID SetGuidObjectType( GUID * guid ){ m_GuidObjectType = *guid; }
   GUID* GetGuidInheritType();
   VOID SetGuidInheritType( GUID *guid ){ m_GuidInheritedObjectType = *guid; }
	PSID GetSID(){ return m_pSid; }

   ACCESS_MODE  GetAccessMode() { return m_AccessMode; }
   LPWSTR GetObjectType(){ return m_szObjectType; };
   VOID SetObjectType( LPWSTR pszName ) { CopyUnicodeString( &m_szObjectType, pszName ); }
   LPWSTR GetInheritedObjectType(){ return m_szInheritedObjectType; }
   VOID SetInheritedObjectType( LPWSTR pszName ) { CopyUnicodeString( &m_szInheritedObjectType, pszName ); }

   BOOL IsObjectTypePresent(){ return m_Flags & ACE_OBJECT_TYPE_PRESENT; }
   BOOL IsInheritedTypePresent(){ return m_Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT; }
   VOID SetObjectTypeType( DSACLS_OBJECT_TYPE_TYPE ot ){ m_ObjectTypeType = ot; }
   DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType() { return m_ObjectTypeType; }

	UINT GetTrusteeLength()
   {
    if( m_szTrusteeName )
      return wcslen( m_szTrusteeName ); 
    else
      return 0;
   }

   
   VOID SetErased( BOOL bErase ){ m_bErased = bErase; }
   BOOL IsErased( ){ return m_bErased; }
   //Is ACE Effective on the object
   BOOL CAce::IsEffective(){ return !FlagOn( m_AceFlags, INHERIT_ONLY_ACE ); }
   //Is ACE Inherited to all child Objects
   BOOL CAce::IsInheritedToAll()
   {
      return ( FlagOn( m_AceFlags, CONTAINER_INHERIT_ACE ) && 
               !FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) );
   }
   //Is Ace Inherited to Specific child object
   BOOL CAce::IsInheritedToSpecific()
   {
      return ( FlagOn( m_AceFlags, INHERIT_ONLY_ACE ) && 
               FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) );
   }
   //Is Ace inherited from parent
   BOOL CAce::IsInheritedFromParent(){ return FlagOn( m_AceFlags, INHERITED_ACE );}

   VOID Display( UINT nMaxTrusteeLength );

   //Constructor
   CAce();
   ~CAce();
   DWORD Initialize( PACE_HEADER ace,
                     UINT nAllowDeny,
                     UINT nAudit 
                     );   
   DWORD Initialize( LPWSTR pszTrustee,
                     LPWSTR pszObjectId,
                     LPWSTR pszInheritId,
                     ACCESS_MODE AccessMode,
                     ACCESS_MASK Access,
                     BYTE Inheritance
                   );

};

class CACE_SORT:public greater<CAce*>
{
   bool operator()( CAce * a, CAce * b )
   {
      if( wcscmp( a->GetInheritedObjectType(),
                     b->GetInheritedObjectType() ) > 0 )
                     return true;
      else
         return false;
                     
   }
};

class CAcl
{
public:
   VOID AddAce( CAce * pAce );
   VOID MergeAcl( CAcl * pAcl );
   DWORD BuildAcl( PACL * pAcl );

	VOID Display();
   DWORD Initialize( BOOL bProtected, PACL pAcl, UINT nAllowDeny, UINT nAudit); 
   BOOL VerifyAllNames();
   VOID GetInfoFromCache();
   
   UINT m_nMaxTrusteeLength;     //This length is maintained for formating the display
   ~CAcl();
private:
   list<CAce*> listAces;               //List represnting an ACL

   //These three used only for display purposes
   list<CAce *> listEffective;         //List of Aces Effective directly on the object;
   list<CAce *> listInheritedAll;      //List of Aces Inherited to all sub objects;
   list<CAce *> listInheritedSpecific; //List of Aces Inherited to <Inherited Object Class>

   BOOL bAclProtected;                 //Is Acl protected
};


/*
CCache mainitains a cache of GUIDs And Display Name
*/
typedef enum _DSACLS_SERACH_IN
{
    BOTH = 0,
    SCHEMA,
    CONFIGURATION
} DSACLS_SEARCH_IN;

typedef enum _DSACLS_RESOLVE
{
   RESOLVE_NAME = 0,
   RESOLVE_GUID
}DSACLS_RESOLVE;

typedef struct _DSACL_CACHE_ITEM
{
   GUID Guid;
   LPWSTR pszName;
   DSACLS_OBJECT_TYPE_TYPE ObjectTypeType;
   DSACLS_SEARCH_IN searchIn;
   DSACLS_RESOLVE resolve;
   BOOL bResolved;
}DSACL_CACHE_ITEM, * PDSACL_CACHE_ITEM;

class CCache
{
public:
   DWORD AddItem( IN GUID *pGuid,
                  IN DSACLS_SEARCH_IN s = BOTH );

   DWORD AddItem( IN LPWSTR pszName,
                  IN DSACLS_SEARCH_IN s = BOTH );
   
   DWORD BuildCache();

   PDSACL_CACHE_ITEM LookUp( LPWSTR pszName );
   PDSACL_CACHE_ITEM LookUp( GUID* pGuid );
   ~CCache();


private:
   list<PDSACL_CACHE_ITEM> m_listItem;
   list<PDSACL_CACHE_ITEM> m_listCache;
   
   //Methods
   DWORD SearchSchema();
   DWORD SearchConfiguration();
};

DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( INT validAccesses );
DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( LPWSTR szObjectCategory );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\stdafx.h ===
/*
This is predefined header file.

*/

#ifndef _STDAFX_H
#define _STDAFX_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <lm.h>
#include <lmapibuf.h>
#include <objbase.h>
#include <ntdsapi.h>
#include "rpc.h"
#include "rpcndr.h"
#include <windows.h>
#include "ole2.h"
#include <activeds.h>
#include "dsgetdc.h"
#include "sddl.h"
#include "seopaque.h"
#include "adshlp.h"
#include <aclapi.h>
//#include <permit.h>
#include <activeds.h>
#include <ntlsa.h>
#include <winldap.h>
#include <sddlp.h>
//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\dsacls.cpp ===
/*++

Copyright (c) 1996 - 1998  Microsoft Corporation

Module Name:

    dsacls.c

Abstract:

    This Module implements the delegation tool, which allows for the management
    of access to DS objects

Author:

    Mac McLain  (MacM)    10-15-96

Environment:

    User Mode

Revision History:

   Hitesh Raigandhi  (hiteshr  6-29-98)
   1: Changed the code to Old NTMART API's 
   2: Redesigned the structure
   

--*/
#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"
#include <winnlsp.h>


#define DSACL_DBG   1


//
// Local helper macros
//
#define FLAG_ON(flag,bits)        ((flag) & (bits))
#define IS_CMD_FLAG( string )    (*(string) == L'-' || *(string) == L'/' )


DSACLS_ARG  DsAclsArgs[] = {
   { MSG_TAG_CI,     NULL, 0, 0, MSG_TAG_CI,       0, FALSE, DSACLS_EXTRA_INFO_REQUIRED },
   { MSG_TAG_CN,     NULL, 0, 0, MSG_TAG_CN,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CP,     NULL, 0, 0, MSG_TAG_CP,       0, FALSE, DSACLS_EXTRA_INFO_REQUIRED },
   { MSG_TAG_CG,     NULL, 0, 0, MSG_TAG_CG,       0, TRUE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CD,     NULL, 0, 0, MSG_TAG_CD,       0, TRUE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CR,     NULL, 0, 0, MSG_TAG_CR,       0, TRUE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CS,     NULL, 0, 0, MSG_TAG_CS,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CT,     NULL, 0, 0, MSG_TAG_CT,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CA,     NULL, 0, 0, MSG_TAG_CA,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_GETSDDL,NULL, 0, 0, MSG_TAG_GETSDDL,  0, FALSE, DSACLS_EXTRA_INFO_OPTIONAL },
   { MSG_TAG_SETSDDL,NULL, 0, 0, MSG_TAG_SETSDDL,  0, FALSE, DSACLS_EXTRA_INFO_REQUIRED }
};

    
DSACLS_INHERIT DsAclsInherit[] = {
   { MSG_TAG_IS, NULL, 0, TRUE, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE},
   { MSG_TAG_IT, NULL, 0, TRUE, CONTAINER_INHERIT_ACE },
   { MSG_TAG_IP, NULL, 0, TRUE, INHERIT_NO_PROPAGATE },
   { MSG_TAG_ID, NULL, 0, FALSE, INHERITED_ACCESS_ENTRY }
};

DSACLS_RIGHTS DsAclsRights[] = {
   { MSG_TAG_GR, NULL,MSG_TAG_GR_EX,NULL, 0, GENERIC_READ },
   { MSG_TAG_GE, NULL,MSG_TAG_GE_EX,NULL, 0, GENERIC_EXECUTE },
   { MSG_TAG_GW, NULL,MSG_TAG_GW_EX,NULL, 0, GENERIC_WRITE },
   { MSG_TAG_GA, NULL,MSG_TAG_GA_EX,NULL, 0, GENERIC_ALL },
   { MSG_TAG_SD, NULL,MSG_TAG_SD_EX,NULL, 0, DELETE },
   { MSG_TAG_RC, NULL,MSG_TAG_RC_EX,NULL, 0, READ_CONTROL },
   { MSG_TAG_WD, NULL,MSG_TAG_WD_EX,NULL, 0, WRITE_DAC },
   { MSG_TAG_WO, NULL,MSG_TAG_WO_EX,NULL, 0, WRITE_OWNER },
   { MSG_TAG_CC, NULL,MSG_TAG_CC_EX,NULL, 0, ACTRL_DS_CREATE_CHILD },
   { MSG_TAG_DC, NULL,MSG_TAG_DC_EX,NULL, 0, ACTRL_DS_DELETE_CHILD },
   { MSG_TAG_LC, NULL,MSG_TAG_LC_EX,NULL, 0, ACTRL_DS_LIST },
   { MSG_TAG_WS, NULL,MSG_TAG_WS_EX,NULL, 0, ACTRL_DS_SELF },
   { MSG_TAG_WP, NULL,MSG_TAG_WP_EX,NULL, 0, ACTRL_DS_WRITE_PROP },
   { MSG_TAG_RP, NULL,MSG_TAG_RP_EX,NULL, 0, ACTRL_DS_READ_PROP },
   { MSG_TAG_DT, NULL,MSG_TAG_DT_EX,NULL, 0, ACTRL_DS_DELETE_TREE },
   { MSG_TAG_LO, NULL,MSG_TAG_LO_EX,NULL, 0, ACTRL_DS_LIST_OBJECT },
   { MSG_TAG_AC, NULL,MSG_TAG_AC_EX,NULL, 0, ACTRL_DS_CONTROL_ACCESS } //This is only for input
};

DSACLS_PROTECT DsAclsProtect[] = {
   { MSG_TAG_PY, NULL, 0, PROTECTED_DACL_SECURITY_INFORMATION },
   { MSG_TAG_PN, NULL, 0, UNPROTECTED_DACL_SECURITY_INFORMATION }
};




/*
Displays The security Descriptor
*/
DWORD 
DumpAccess (
    IN PSECURITY_DESCRIPTOR pSD,
    IN BOOL bDisplayAuditAndOwner
    )
{

   DWORD dwErr = ERROR_SUCCESS;
	SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
	DWORD dwRevision;
	PSID psidOwner = NULL;
	PSID psidGroup = NULL;
	PACL pDacl = NULL;
	PACL pSacl = NULL;
	BOOL bDefaulted;
	BOOL bPresent;
   LPWSTR pOwnerName = NULL;
   LPWSTR pGroupName = NULL;
   CAcl * pCSacl = NULL;
   CAcl * pCDacl = NULL;
   UINT nLen1 = 0;
   UINT nLen2 = 0;
   UINT nAllowDeny = 0;
   UINT nAudit = 0;
   WCHAR szLoadBuffer[1024];

	if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
	if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
   }
	if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
	if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
	if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
   
   //Find out the Max len out of ( ALLOW, DENY ) and ( FAILURE, SUCCESS, BOTH)
   nLen1 = LoadStringW( g_hInstance, MSG_DSACLS_ALLOW, szLoadBuffer, 1023 );
   nLen2 = LoadStringW( g_hInstance, MSG_DSACLS_DENY,  szLoadBuffer, 1023 );
   nAllowDeny = ( nLen1 > nLen2 ) ? nLen1 : nLen2;
   nLen1 = LoadStringW( g_hInstance, MSG_DSACLS_AUDIT_SUCCESS, szLoadBuffer, 1023 );
   nLen2 = LoadStringW( g_hInstance, MSG_DSACLS_AUDIT_FAILURE,  szLoadBuffer, 1023 );
   nAudit = ( nLen1 > nLen2 ) ? nLen1 : nLen2;
   nLen1 = LoadStringW( g_hInstance, MSG_DSACLS_AUDIT_ALL, szLoadBuffer, 1023 );
   nAudit = ( nLen1 > nAudit ) ? nLen1 : nAudit;
   

   if( bDisplayAuditAndOwner )
   {
      pCSacl = new CAcl();
      CHECK_NULL( pCSacl, CLEAN_RETURN );
      dwErr = pCSacl->Initialize(wSDControl & SE_SACL_PROTECTED, 
                                 pSacl, 
                                 nAllowDeny, 
                                 nAudit );      
      if( dwErr != ERROR_SUCCESS )
         return dwErr;
   }
   pCDacl = new CAcl();
   CHECK_NULL( pCDacl,CLEAN_RETURN );
   dwErr = pCDacl->Initialize(wSDControl & SE_DACL_PROTECTED, 
                              pDacl, 
                              nAllowDeny, 
                              nAudit);

   if( dwErr != ERROR_SUCCESS )
      return dwErr;

   if( ( dwErr = g_Cache->BuildCache() ) != ERROR_SUCCESS )
      return dwErr;			

   pCDacl->GetInfoFromCache();
   if( bDisplayAuditAndOwner )
   {
      if( ( dwErr = GetAccountNameFromSid( g_szServerName, psidOwner, &pOwnerName ) ) != ERROR_SUCCESS )
         goto CLEAN_RETURN;
      DisplayMessageEx( 0, MSG_DSACLS_OWNER, pOwnerName );
      if( ( dwErr = GetAccountNameFromSid( g_szServerName, psidGroup, &pGroupName ) ) != ERROR_SUCCESS )
         goto CLEAN_RETURN;
      DisplayMessageEx( 0, MSG_DSACLS_GROUP, pGroupName );
      DisplayNewLine();
      DisplayMessageEx( 0, MSG_DSACLS_AUDIT );
      pCSacl->Display();
      DisplayNewLine();
   }

   
   DisplayMessageEx( 0, MSG_DSACLS_ACCESS );
   pCDacl->Display();

CLEAN_RETURN:
   if( pOwnerName )
      LocalFree( pOwnerName );
   if( pGroupName )
      LocalFree( pGroupName );
   if( pCSacl )
      delete pCSacl;
   if( pCDacl )
      delete pCDacl;
   return dwErr;
}



/*
This Function process the command line argument for /D /R /G
options and add the corresponding aces to pAcl.
*/
DWORD
ProcessCmdlineUsers ( IN WCHAR *argv[],
                      IN PDSACLS_ARG  AclsArg,
                      IN DSACLS_OP Op,
                      IN ULONG Inheritance,
                      IN ULONG RightsListCount,
                      IN PDSACLS_RIGHTS RightsList,
                      OUT CAcl *pAcl )
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG i, j;
    ULONG AccIndex, Access;
    PEXPLICIT_ACCESS pListOfExplicitEntries = NULL;
    PWSTR pObjectId = NULL;
    PWSTR pTrustee = NULL;
    PWSTR pInheritId = NULL;
    ACCESS_MODE AccessMode;
    CAce * pAce = NULL;
    switch ( Op ) {
    case REVOKE:
        AccessMode = REVOKE_ACCESS;
        break;

    case GRANT:
        AccessMode = GRANT_ACCESS;
        break;

    case DENY:
        AccessMode = DENY_ACCESS;
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    if ( dwErr != ERROR_SUCCESS ) 
      goto FAILURE_RETURN;
        
   for ( i = 0; i < AclsArg->SkipCount && dwErr == ERROR_SUCCESS; i++ ) 
   {
      dwErr = ParseUserAndPermissons( argv[AclsArg->StartIndex + 1 + i],
                                         Op,
                                         RightsListCount,
                                         RightsList,
                                         &pTrustee,
                                         &Access,
                                         &pObjectId,
                                         &pInheritId );
      if( dwErr != ERROR_SUCCESS )
         goto FAILURE_RETURN;
   
      pAce = new CAce();
      CHECK_NULL( pAce , FAILURE_RETURN);
      dwErr= pAce->Initialize( pTrustee,
                               pObjectId,
                               pInheritId,
                               AccessMode,
                               Access,
                               Inheritance );

      if( dwErr != ERROR_SUCCESS )
         return dwErr;

      pAcl->AddAce( pAce );
     
      if( pObjectId )
      {
         LocalFree( pObjectId );
         pObjectId = NULL;
      }

      if( pInheritId )
      {
         LocalFree( pInheritId );
         pInheritId = NULL;
      }
      if( pTrustee )
      {
         LocalFree( pTrustee );
         pTrustee = NULL;
      }
   }
    

FAILURE_RETURN:
   if( pObjectId )
   {
      LocalFree( pObjectId );
      pObjectId = NULL;
   }

   if( pInheritId )
   {
      LocalFree( pInheritId );
      pInheritId = NULL;
   }
   if( pTrustee )
   {
      LocalFree( pTrustee );
      pTrustee = NULL;
   }
   
   return( dwErr );
}

//These five are global variables used by the dsacls
LPWSTR g_szSchemaNamingContext;
LPWSTR g_szConfigurationNamingContext;
HMODULE g_hInstance;
LPWSTR g_szServerName;
CCache *g_Cache;

__cdecl
main (
    IN  INT     argc,
    IN  CHAR   *argv[]
)
{   
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG Length, Options = 0;
    PWSTR pszObjectPath = NULL;
    PWSTR pszLDAPObjectPath = NULL;
    PSTR SddlString = NULL,  TempString;
    LPWSTR FileName = NULL;
    CHAR ReadString[ 512 ];
    BOOLEAN Mapped;
    LPWSTR  CurrentInherit = NULL;
    LPWSTR CurrentProtect = NULL;
    ULONG Inheritance = 0;
    SECURITY_INFORMATION Protection = 0;
    ULONG SddlStringLength = 0;
    WCHAR ** wargv = NULL;
    ULONG i = 0;
    ULONG j = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;
    SECURITY_INFORMATION SecurityInformation = DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR pTempSD = NULL;
    PACL pNewDacl = NULL;
    CAcl * pCAclOld = NULL;
    CAcl *pCAclNew = NULL;
    BOOL bErrorShown = FALSE;

    SetThreadUILanguage(0);


   //Initialize Com Library 
   HRESULT  hr = CoInitialize(NULL);
   CHECK_HR(hr, CLEAN_RETURN);
   //Get Instance Handle
   g_hInstance = GetModuleHandle(NULL);
   //Create global instance of Cache
   g_Cache = new CCache();
   CHECK_NULL(g_Cache,CLEAN_RETURN);
    
   setlocale( LC_CTYPE, "" );
   
   //Initialize Global Arrays   
   if( ( dwErr = InitializeGlobalArrays() ) != ERROR_SUCCESS )
      goto CLEAN_RETURN;


   if ( argc == 1 ) 
   {
      DisplayMessage( 0, MSG_DSACLS_USAGE );
      goto CLEAN_RETURN;
   }

   //Convert argv to Unicode
   wargv = (LPWSTR*)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, argc * sizeof(LPWSTR) );
   CHECK_NULL(wargv, CLEAN_RETURN );

   if( ( dwErr = ConvertArgvToUnicode( wargv, argv, argc ) ) != ERROR_SUCCESS )
      goto CLEAN_RETURN;

    //First Argument is Object Path or /?
   if( IS_CMD_FLAG( wargv[ 1 ] ) )
   {
      if ( _wcsicmp( wargv[ 1 ] + 1, L"?" ) != 0 ) 
            DisplayMessageEx( 0, MSG_DSACLS_PARAM_UNEXPECTED, wargv[1] );
            
      DisplayMessage(0,MSG_DSACLS_USAGE);
      goto CLEAN_RETURN;
   }

   Length = wcslen( wargv[1] );
   pszObjectPath = (LPWSTR)LocalAlloc( LMEM_FIXED, 
                                       ( Length + 1 ) * sizeof( WCHAR ) );
   if ( !pszObjectPath )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto CLEAN_RETURN;
   } else 
   {
      wcscpy( pszObjectPath,
              wargv[ 1 ] );
   }            
   //Get the name of server
   dwErr = GetServerName( pszObjectPath, &g_szServerName );
   if( dwErr != ERROR_SUCCESS )
      goto CLEAN_RETURN;

   if( ( dwErr = BuildLdapPath( &pszLDAPObjectPath,
                                g_szServerName,
                                pszObjectPath ) ) != ERROR_SUCCESS )
      goto CLEAN_RETURN;
   //Get Schema and Configuration naming context
   dwErr = GetGlobalNamingContexts(  g_szServerName,
                                     &g_szSchemaNamingContext,
                                     &g_szConfigurationNamingContext );
   
   if( dwErr != ERROR_SUCCESS )
      goto CLEAN_RETURN;

    
   //
   // Parse the command line
   //
   i = 2;
   while ( i < ( ULONG )argc && dwErr == ERROR_SUCCESS )
   {
      if ( IS_CMD_FLAG( wargv[ i ] ) )
      {     
         if ( !_wcsicmp( wargv[ i ] + 1, L"?" ) ) {
            DisplayMessage( 0, MSG_DSACLS_USAGE );
            goto CLEAN_RETURN;
         } 

         Mapped = FALSE;
         for (  j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
         {
            if ( !wcsncmp( wargv[ i ] + 1, DsAclsArgs[ j ].String,DsAclsArgs[ j ].Length ) )
            {
               if( DsAclsArgs[ j ].ExtraInfo )
               {
                  if( ( DsAclsArgs[ j ].ExtraInfo == DSACLS_EXTRA_INFO_REQUIRED &&
                        wargv[ i ][ DsAclsArgs[ j ].Length + 1 ] == ':' &&
                        wargv[ i ][ DsAclsArgs[ j ].Length + 2 ] != '\0' ) ||
                        (DsAclsArgs[ j ].ExtraInfo == DSACLS_EXTRA_INFO_OPTIONAL &&
                        ( ( wargv[ i ][ DsAclsArgs[ j ].Length + 1 ] == ':' &&
                        wargv[ i ][ DsAclsArgs[ j ].Length + 2 ] != '\0' ) ||
                        wargv[ i ][ DsAclsArgs[ j ].Length + 1 ] == '\0' ) ) )
                  {
                     Mapped = TRUE;
                  }

               } else 
               {
                  Mapped = TRUE;
               }
               break;
            }
         }//For 


         if ( Mapped ) 
         {
            DsAclsArgs[ j ].StartIndex = i;
            Options |= DsAclsArgs[ j ].Flag;
            if ( DsAclsArgs[ j ].SkipNonFlag )
            {
               while ( i + 1 < ( ULONG )argc && !IS_CMD_FLAG( wargv[ i + 1 ] ) ) 
               {
                     i++;
                     DsAclsArgs[ j ].SkipCount++;
               }

               if ( DsAclsArgs[ j ].SkipCount == 0 ) 
               {
                  DisplayMessageEx( 0, MSG_DSACLS_NO_UA,
                                    wargv[i] );
                  dwErr = ERROR_INVALID_PARAMETER;
                                goto CLEAN_RETURN;
                }
            }        
         }
         else
         {
            DisplayMessageEx( 0, MSG_DSACLS_PARAM_UNEXPECTED, wargv[i] );
            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
         }   

      } else 
      {
            DisplayMessageEx( 0, MSG_DSACLS_PARAM_UNEXPECTED, wargv[i] );
            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
      }

      i++;
   }//While

   //Validate the command line argument

   /*
      if ( !FLAG_ON( Options, MSG_TAG_CR | MSG_TAG_CD | MSG_TAG_CG | MSG_TAG_CT | MSG_TAG_CS ) ) 
      {
         if ( FLAG_ON( Options, MSG_TAG_GETSDDL ) ) 
         {
     
            if ( dwErr == ERROR_SUCCESS ) 
            {

               if ( !ConvertSecurityDescriptorToStringSecurityDescriptorA(      pSD,
                                                                                SDDL_REVISION,
                                                                                SecurityInformation,
                                                                                &SddlString,
                                                                                NULL ) )
               {                  
                  dwErr = GetLastError();
               } else 
               {
                  //
                  // Get the file name to write it to if necessary
                  //
                  for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
                  {
                     if ( DsAclsArgs[ j ].Flag == MSG_TAG_GETSDDL ) 
                     {
                        FileName = wcschr( wargv[ DsAclsArgs[ j ].StartIndex ] , L':' );
                        if ( FileName ) 
                        {
                           FileName++;
                        }
                        break;
                      }
                  }

                  if ( FileName ) 
                  {
                     HANDLE FileHandle = CreateFile( FileName,
                                                             GENERIC_WRITE,
                                                             0,
                                                             NULL,
                                                             CREATE_ALWAYS,
                                                             FILE_ATTRIBUTE_NORMAL,
                                                             NULL );

                     if ( FileHandle == INVALID_HANDLE_VALUE ) 
                     {

                                   dwErr = GetLastError();

                     } else 
                     {

                                   ULONG BytesWritten;

                        if ( WriteFile( FileHandle,
                                        ( PVOID )SddlString,
                                        strlen( SddlString ),
                                        &BytesWritten,
                                        NULL ) == FALSE ) 
                        {
                           dwErr = GetLastError();
                        } else 
                        {
                           ASSERT( strlen( SddlString ) == BytesWritten );
                        }
                        CloseHandle( FileHandle );
                     }
                  } else 
                  {

                            printf( "%s\n", SddlString );
                  }
                        LocalFree( SddlString );
                }

                  //LocalFree( SD );
               }

            } else {

                    DumpAccess( pSD,
                                FLAG_ON( Options, MSG_TAG_CA ),
                                sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ),
                                DsAclsInherit,
                                sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                DsAclsRights );
            }
        }
   */

/*
    //
    // If we are parsing an SDDL file, go ahead and do that now...
    //
    if ( FLAG_ON( Options, MSG_TAG_SETSDDL ) ) 
    {

        //
        // First, open the file
        //
        HANDLE FileHandle = INVALID_HANDLE_VALUE;

        //
        // Get the file name to write it to if necessary
        //
        for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

            if ( DsAclsArgs[ j ].Flag == MSG_TAG_SETSDDL ) {

                FileName = wcschr( wargv[ DsAclsArgs[ j ].StartIndex ] , L':' );
                if ( FileName ) {

                    FileName++;
                }
                break;
            }
        }

        if ( !FileName ) {

            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
        }

        FileHandle = CreateFile( FileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {

            dwErr = GetLastError();
            goto CLEAN_RETURN;
        }

        //
        // Now, parse it...
        //
        SddlStringLength = 0;
        SddlString = NULL;
        while ( TRUE ) {

            ULONG Read = 0, Len = 0;
            PSTR ReadPtr, TempPtr;

            if ( ReadFile( FileHandle,
                           ReadString,
                           sizeof( ReadString ) / sizeof( CHAR ),
                           &Read,
                           NULL ) == FALSE ) {

                dwErr = GetLastError();
                break;
            }

            if ( Read == 0 ) {

                break;
            }

            if ( *ReadString == ';' ) {

                continue;
            }

            Len = SddlStringLength + ( Read / sizeof( CHAR ) );

            TempString = (LPSTR)LocalAlloc( LMEM_FIXED,
                                     Len + sizeof( CHAR ) );

            if ( TempString ) {

                if ( SddlString ) {

                    strcpy( TempString, SddlString );

                } else {

                    *TempString = '\0';
                }

                TempPtr = TempString + SddlStringLength;
                ReadPtr = ReadString;

                while( Read-- > 0 ) {

                    if ( !isspace( *ReadPtr ) ) {

                        *TempPtr++ = *ReadPtr;
                        SddlStringLength++;
                    }

                    ReadPtr++;
                }

                *TempPtr = '\0';

                LocalFree( SddlString );
                SddlString = TempString;

            } else {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

        }

        if ( dwErr == ERROR_SUCCESS ) {

            //
            // Convert it to a security descriptor, then to an access list, then set it.
            //
            if ( ConvertStringSecurityDescriptorToSecurityDescriptorA( SddlString,
                                                                       SDDL_REVISION,
                                                                       &pTempSD,
                                                                       NULL ) == FALSE ) {

                dwErr = GetLastError();

            } else {

                    dwErr = WriteObjectSecurity( pszObjectPath,
                                                    DACL_SECURITY_INFORMATION,
                                                    pTempSD );

                     LocalFree( pTempSD );
            }
        }

        LocalFree( SddlString );

        if ( FileHandle != INVALID_HANDLE_VALUE ) {

            CloseHandle( FileHandle );
        }

        goto CLEAN_RETURN;
    }
*/

   //
   // Get the inheritance flags set
   //
   if ( FLAG_ON( Options, MSG_TAG_CI ) ) 
   {

        for (  j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
        {
            if ( DsAclsArgs[ j ].Flag == MSG_TAG_CI ) 
            {
               CurrentInherit = wargv[ DsAclsArgs[ j ].StartIndex ] + 3;
               while ( CurrentInherit && *CurrentInherit && dwErr == ERROR_SUCCESS ) 
               {
                  for ( i = 0; i < ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ); i++ ) 
                  {
                     if ( !_wcsnicmp( CurrentInherit,
                                      DsAclsInherit[ i ].String,
                                      DsAclsInherit[ i ].Length ) ) 
                     {

                        if ( !DsAclsInherit[ i ].ValidForInput ) 
                        {
                           dwErr = ERROR_INVALID_PARAMETER;
                           break;
                        }
                        Inheritance |= DsAclsInherit[ i ].InheritFlag;
                        CurrentInherit += DsAclsInherit[ i ].Length;
                        break;
                     }
                  }

                  if ( i == ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ) ) 
                  {
                     dwErr = ERROR_INVALID_PARAMETER;
                     goto CLEAN_RETURN;
                  }
               }
               break;
            }
        }
   }

   //Get the protection flag
   if ( FLAG_ON( Options, MSG_TAG_CP ) ) 
   {

        for (  j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
        {
            if ( DsAclsArgs[ j ].Flag == MSG_TAG_CP ) 
            {
               CurrentProtect = wargv[ DsAclsArgs[ j ].StartIndex ] + DsAclsArgs[ j ].Length + 2;
               while ( CurrentProtect && *CurrentProtect ) 
               {
                  for ( i = 0; i < ( sizeof( DsAclsProtect ) / sizeof( DSACLS_PROTECT ) ); i++ ) 
                  {
                     if ( !_wcsnicmp( CurrentProtect,
                                      DsAclsProtect[ i ].String,
                                      DsAclsProtect[ i ].Length ) ) 
                     {

                        Protection |= DsAclsProtect[ i ].Right;
                        CurrentProtect += DsAclsProtect[ i ].Length;
                        break;
                     }
                  }

                  if ( i == ( sizeof( DsAclsProtect ) / sizeof( DSACLS_PROTECT ) ) ) 
                  {
                     dwErr = ERROR_INVALID_PARAMETER;
                     goto CLEAN_RETURN;
                  }
               }
               break;
            }
        }
   }




   //
   // Start processing them in order
   //
   if ( FLAG_ON( Options, MSG_TAG_CR | MSG_TAG_CD | MSG_TAG_CG | MSG_TAG_CP ) ) 
   {
      //
      // Get the current information, if required
      //
      if( !FLAG_ON( Options, MSG_TAG_CN ) )
      {
         SecurityInformation = DACL_SECURITY_INFORMATION;

         dwErr = GetNamedSecurityInfo(   pszLDAPObjectPath,
                                         SE_DS_OBJECT_ALL,
                                         SecurityInformation,
                                         NULL,
                                         NULL,
                                         &pDacl,
                                         NULL,
                                         &pSD );
                                         
         if ( dwErr != ERROR_SUCCESS ) {
            goto CLEAN_RETURN;
         }
         //pCAclOld represents existing ACL
         pCAclOld = new CAcl();
         CHECK_NULL( pCAclOld, CLEAN_RETURN );
         dwErr = pCAclOld->Initialize( FALSE, pDacl,0 ,0 );
         if( dwErr != ERROR_SUCCESS )
            goto CLEAN_RETURN;

         if( !FLAG_ON( Options, MSG_TAG_CP ) )
         {
            dwErr = GetProtection( pSD, &Protection );
            if( dwErr != ERROR_SUCCESS )
               goto CLEAN_RETURN;
         }
      }

      pCAclNew = new CAcl();
      CHECK_NULL( pCAclNew, CLEAN_RETURN );

        //
        // Grant
        //
        if ( dwErr == ERROR_SUCCESS && FLAG_ON( Options, MSG_TAG_CG ) ) {

            for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

                if ( DsAclsArgs[ j ].Flag == MSG_TAG_CG ) {

                    dwErr = ProcessCmdlineUsers( wargv,
                                                 &DsAclsArgs[ j ],
                                                 GRANT,
                                                 Inheritance,
                                                 sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                                 DsAclsRights,
                                                 pCAclNew );

                    if ( dwErr != ERROR_SUCCESS ) {
                        goto CLEAN_RETURN;
                    }
                    break;
                }
            }
        }

        if ( dwErr == ERROR_SUCCESS && FLAG_ON( Options, MSG_TAG_CD ) ) {

            for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

                if ( DsAclsArgs[ j ].Flag == MSG_TAG_CD ) {

                    dwErr = ProcessCmdlineUsers( wargv,
                                                 &DsAclsArgs[ j ],
                                                 DENY,
                                                 Inheritance,
                                                 sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                                 DsAclsRights,
                                                 pCAclNew );

                    if ( dwErr != ERROR_SUCCESS ) {
                        goto CLEAN_RETURN;
                    }
                    break;
                }

            }
        }

        if ( dwErr == ERROR_SUCCESS && FLAG_ON( Options, MSG_TAG_CR ) ) {

            for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

                if ( DsAclsArgs[ j ].Flag == MSG_TAG_CR ) {

                    dwErr = ProcessCmdlineUsers( wargv,
                                                    &DsAclsArgs[ j ],
                                                    REVOKE,
                                                    Inheritance,
                                                    sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                                    DsAclsRights,
                                                    pCAclNew );

                    if ( dwErr != ERROR_SUCCESS ) {
                     goto CLEAN_RETURN;

                    }

                    break;
                }

            }
        }

        //Build Cache
        g_Cache->BuildCache();
        //Verify that we have been able to convert all ObjectType and InheritedObjectType
        // names to GUIDs
        pCAclNew->GetInfoFromCache();
        if( !pCAclNew->VerifyAllNames() )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
        }
        if( pCAclOld )
         pCAclOld->GetInfoFromCache();
         
        if( pCAclOld )
        {
            pCAclOld->MergeAcl( pCAclNew );
            if(( dwErr = pCAclOld->BuildAcl( &pNewDacl ) ) != ERROR_SUCCESS )
               goto CLEAN_RETURN;
        }
        else
        {
            if( ( dwErr = pCAclNew->BuildAcl( &pNewDacl ) ) != ERROR_SUCCESS )
               goto CLEAN_RETURN;
        }
            SecurityInformation = DACL_SECURITY_INFORMATION | Protection;
            dwErr = SetNamedSecurityInfo  (    pszLDAPObjectPath,
                                               SE_DS_OBJECT_ALL,
                                               SecurityInformation,
                                               NULL,
                                               NULL,
                                               pNewDacl,
                                               NULL );
            if( dwErr != ERROR_SUCCESS )
               goto CLEAN_RETURN;

   }

    //
    // Now, see if we have to restore any security to the defaults
    //
    if ( FLAG_ON( Options, MSG_TAG_CS ) ) {

        dwErr = SetDefaultSecurityOnObjectTree( pszObjectPath,
                                                   ( BOOLEAN )( FLAG_ON( Options, MSG_TAG_CT )  ?
                                                                                 TRUE : FALSE ),Protection );
         if( dwErr != ERROR_SUCCESS )
            goto CLEAN_RETURN;


    }

   

    //Display the security
      if( pSD )
      {
         LocalFree( pSD );
         pSD = NULL;
      }

      SecurityInformation = DACL_SECURITY_INFORMATION;
      if ( FLAG_ON( Options, MSG_TAG_CA ) )
      {
         SecurityInformation |= SACL_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                OWNER_SECURITY_INFORMATION;
      }
      dwErr = GetNamedSecurityInfo(   pszLDAPObjectPath,
                                      SE_DS_OBJECT_ALL,
                                      SecurityInformation,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &pSD );
          
     if( dwErr != ERROR_SUCCESS )
     {
        if( dwErr == ERROR_FILE_NOT_FOUND )
        {
            DisplayMessageEx( 0, MSG_INVALID_OBJECT_PATH );
            bErrorShown = TRUE;
        }                      
         goto CLEAN_RETURN;
    }

    dwErr = DumpAccess( pSD,
                FLAG_ON( Options, MSG_TAG_CA )
              );

CLEAN_RETURN:

    if ( dwErr == ERROR_SUCCESS ) 
    {
        DisplayMessageEx( 0, MSG_DSACLS_SUCCESS );
    } else {
       if(!bErrorShown)
            DisplayErrorMessage( dwErr );
       DisplayMessageEx( 0, MSG_DSACLS_FAILURE );
    }

   //Free Unicode Command Line Arguments
   if( wargv )
   {
      //delete wargv and stuff
      for( j = 0; j < argc; ++ j )
      {
         if( wargv[j] )
            LocalFree(wargv[j] );
      }
      LocalFree( wargv );
   }
      

   if( pszObjectPath )
      LocalFree( pszObjectPath );

   if( pSD )
      LocalFree( pSD );

   if( pNewDacl )
      LocalFree( pNewDacl );

   //Free the Global Stuff
   for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {
        if( DsAclsArgs[ j ].String )
            LocalFree( DsAclsArgs[ j ].String );
   }

   for ( j = 0; j < ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ); j++ ) {
        if( DsAclsInherit[ j ].String )
            LocalFree( DsAclsInherit[ j ].String );
   }

   for ( j = 0; j < ( sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ) ); j++ ) {
      if( DsAclsRights[ j ].String )
         LocalFree( DsAclsRights[ j ].String );

      if( DsAclsRights[ j ].StringEx )
         LocalFree( DsAclsRights[ j ].StringEx );

   }

   if( pCAclOld )
      delete pCAclOld ;
   if( pCAclNew )
      delete pCAclNew;

   if( g_szSchemaNamingContext )
      LocalFree( g_szSchemaNamingContext );
   if( g_szConfigurationNamingContext )
      LocalFree( g_szConfigurationNamingContext );
   if( g_szServerName )
      LocalFree( g_szServerName );
   if( g_Cache )
      delete g_Cache;


    return( dwErr );
}




DWORD 
InitializeGlobalArrays()
{

HMODULE hCurrentModule;
WCHAR LoadBuffer[ 1024 ];
int j = 0;

   hCurrentModule = GetModuleHandle( NULL );

   for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG )); j++ )
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsArgs[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );

      if ( Length == 0 )
      {
         return GetLastError();         
      } else {
         
         DsAclsArgs[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                              ( Length + 1 )*sizeof(WCHAR) );
         if ( !DsAclsArgs[ j ].String )
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         
         DsAclsArgs[ j ].Length = Length;
         wcsncpy( DsAclsArgs[ j ].String, LoadBuffer, Length + 1 );
        }
   }

    //
    // Load the inherit strings
    //
   for (  j = 0; j < ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ); j++ ) 
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsInherit[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );

      if ( Length == 0 ) {
         return GetLastError();            
      } else 
      {
         DsAclsInherit[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 ( Length + 1 ) * sizeof( WCHAR ) );
         if ( !DsAclsInherit[ j ].String ) 
            return  ERROR_NOT_ENOUGH_MEMORY;

         wcsncpy( DsAclsInherit[ j ].String, LoadBuffer, Length + 1 );
         DsAclsInherit[ j ].Length = Length;

     }
   }

   //
   //Load The protect flags
   //

   for( j = 0; j < ( sizeof( DsAclsProtect ) / sizeof( DSACLS_PROTECT ) ); j++ )
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsProtect[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );

      if ( Length == 0 ) {
         return GetLastError();            
      } else 
      {
         DsAclsProtect[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 ( Length + 1 ) * sizeof( WCHAR ) );
         if ( !DsAclsProtect[ j ].String ) 
            return  ERROR_NOT_ENOUGH_MEMORY;

         wcsncpy( DsAclsProtect[ j ].String, LoadBuffer, Length + 1 );
         DsAclsProtect[ j ].Length = Length;
      }
   }
    //
    // Load the access rights
    //
   for ( j = 0; j < ( sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ) ); j++ ) 
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsRights[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );
      if ( Length == 0 ) {
         return GetLastError();         
      } else 
      {
         DsAclsRights[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                              ( Length + 1 ) * sizeof( WCHAR ) );
         if ( !DsAclsRights[ j ].String ) {
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         wcsncpy( DsAclsRights[ j ].String, LoadBuffer, Length + 1 );
         DsAclsRights[ j ].Length = Length;

      }

      //Load Ex . Ex String are used for displaying the access rights
      if( DsAclsRights[ j ].ResourceIdEx != -1 )
      {
         Length = LoadString( hCurrentModule,
                     DsAclsRights[ j ].ResourceIdEx,
                     LoadBuffer,
                     sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );
      
         if ( Length == 0 ) {
            return GetLastError();         
         } else 
         {
            DsAclsRights[ j ].StringEx = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 ( Length + 1 ) * sizeof( WCHAR ) );
            if ( !DsAclsRights[ j ].StringEx ) {
               return ERROR_NOT_ENOUGH_MEMORY;
            }

            wcsncpy( DsAclsRights[ j ].StringEx, LoadBuffer, Length + 1 );

         }
      }

   }

   return ERROR_SUCCESS;

}

/*******************************************************************

    NAME:       ConvertArgvToUnicode

    SYNOPSIS:   Converts Command Line Arguments to UNICODE
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY

********************************************************************/
DWORD
ConvertArgvToUnicode( LPWSTR * wargv, char ** argv, int argc ) 
{

DWORD dwErr = ERROR_SUCCESS;
int i = 0;

   for ( i = 0; i < argc ; ++i )
      if( ( dwErr = ConvertStringAToStringW( argv[i], wargv + i ) ) != ERROR_SUCCESS )
         return dwErr;

   return ERROR_SUCCESS;
}

/*
Sets Security Descriptor for pszObject
*/
DWORD
WriteObjectSecurity( IN LPWSTR pszObject,
                     IN SECURITY_INFORMATION si,
                     IN PSECURITY_DESCRIPTOR pSD )
{
		DWORD dwErr;
		SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
		DWORD dwRevision;
		PSID psidOwner = NULL;
		PSID psidGroup = NULL;
		PACL pDacl = NULL;
		PACL pSacl = NULL;
		BOOL bDefaulted;
		BOOL bPresent;
      LPWSTR pszLDAPObjectPath = NULL;

      if( ( dwErr = BuildLdapPath( &pszLDAPObjectPath,
                                   g_szServerName,
                                   pszObject ) ) != ERROR_SUCCESS )
            return dwErr;            
		//
		// Get pointers to various security descriptor parts for
		// calling SetNamedSecurityInfo
		//
		;
		if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
		{
			return GetLastError();
		}
		if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
		{
			return GetLastError();		
      }
		if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
		{
			return GetLastError();
		}
		if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
		{
			return GetLastError();
		}
		if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
		{
			return GetLastError();
		}

		if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
				si |= PROTECTED_DACL_SECURITY_INFORMATION;
		if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
				si |= PROTECTED_SACL_SECURITY_INFORMATION;

		return SetNamedSecurityInfo(    (LPWSTR)pszLDAPObjectPath,
													SE_DS_OBJECT_ALL,
													si,
													psidOwner,
													psidGroup,
													pDacl,
													pSacl);

				
}



/*******************************************************************

    NAME:       DisplayAccessRights

    SYNOPSIS:   Displays Access Rights in Acess Mask
    RETURNS:    NONE

********************************************************************/
void DisplayAccessRights( UINT nSpace, ACCESS_MASK m_Mask )
{    
   for (  int j = 0; j < ( sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ) ); j++ ) 
   {
      if( FlagOn( m_Mask,DsAclsRights[j].Right ) )
      {
         DisplayStringWithNewLine( nSpace,DsAclsRights[j].StringEx );
      }
   }
}

/*******************************************************************

    NAME:       ConvertAccessMaskToGenericString

    SYNOPSIS:   Map access mask to FULL CONTROL or SPECIAL
    RETURNS:    NONE

********************************************************************/

void ConvertAccessMaskToGenericString( ACCESS_MASK m_Mask, LPWSTR szLoadBuffer, UINT nBuffer )
{
   szLoadBuffer[0] = 0;
   WCHAR szTemp[1024];
   if( GENERIC_ALL_MAPPING == ( m_Mask & GENERIC_ALL_MAPPING ) )
   {
      LoadString( g_hInstance, MSG_TAG_GA_EX, szLoadBuffer, nBuffer );
   }
   else
   {
      LoadString( g_hInstance, MSG_DSACLS_SPECIAL, szLoadBuffer, nBuffer );
   }
}

/*******************************************************************
    NAME:       MapGeneric
********************************************************************/
void MapGeneric( ACCESS_MASK * pMask )
{
   GENERIC_MAPPING m = DS_GENERIC_MAPPING;
   MapGenericMask( pMask, &m );
}

/*******************************************************************

    NAME:       BuildExplicitAccess

    SYNOPSIS:   Builds Explicit Access 
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY

********************************************************************/

DWORD BuildExplicitAccess( IN PSID pSid,
                           IN GUID* pGuidObject,
                           IN GUID* pGuidInherit,
                           IN ACCESS_MODE AccessMode,
                           IN ULONG Access,
                           IN ULONG Inheritance,
                           OUT PEXPLICIT_ACCESS pExplicitAccess )
{
DWORD dwErr = ERROR_SUCCESS;

PSID pSidLocal = NULL;
DWORD cbSid = 0;
POBJECTS_AND_SID pOAS = NULL;


   cbSid = GetLengthSid( pSid );
   pSidLocal = (PSID) LocalAlloc( LMEM_FIXED, cbSid );
   CHECK_NULL( pSidLocal,FAILURE_RETURN );
   CopySid( cbSid,pSidLocal, pSid );
   if( pGuidObject  || pGuidInherit )
   {
      pOAS = (POBJECTS_AND_SID)LocalAlloc( LMEM_FIXED, sizeof( OBJECTS_AND_SID ) );
      CHECK_NULL( pOAS, FAILURE_RETURN );
      BuildTrusteeWithObjectsAndSid(   &pExplicitAccess->Trustee,
                                       pOAS,
                                       pGuidObject, 
                                       pGuidInherit,
                                       pSidLocal );
   }
   else
      BuildTrusteeWithSid( &pExplicitAccess->Trustee,
                           pSidLocal );
   MapGeneric( &Access );
   pExplicitAccess->grfAccessMode = AccessMode;
   pExplicitAccess->grfAccessPermissions =Access;
   pExplicitAccess->grfInheritance = Inheritance;

   goto SUCCESS_RETURN;

FAILURE_RETURN:
   if(pSidLocal)
      LocalFree(pSidLocal);

   if( pOAS )
      LocalFree( pOAS );

SUCCESS_RETURN:
   return dwErr;
}    

/*******************************************************************

    NAME:       ParseUserAndPermissons

    SYNOPSIS:   Parses <GROUP\USER>:Access;[object\property];[inheritid]
********************************************************************/
DWORD ParseUserAndPermissons( IN LPWSTR pszArgument,
                              IN DSACLS_OP Op,
                              IN ULONG RightsListCount,
                              IN PDSACLS_RIGHTS RightsList,
                              OUT LPWSTR * ppszTrusteeName,
                              OUT PULONG  pAccess,
                              OUT LPWSTR * ppszObjectId,
                              OUT LPWSTR * ppszInheritId )
{

LPWSTR pszTempString = NULL;
LPWSTR pszTempString2 = NULL;
DWORD dwErr = ERROR_SUCCESS;
ULONG j = 0;

   *ppszTrusteeName = NULL;
   *pAccess = 0;
   *ppszObjectId = NULL;
   *ppszInheritId = NULL;

   if ( Op != REVOKE ) 
   {
      pszTempString = wcschr( pszArgument, L':' );
      if ( !pszTempString ) 
      {
         dwErr = ERROR_INVALID_PARAMETER;
         goto FAILURE_RETURN;
      }
      *pszTempString = L'\0';
   }

   dwErr = CopyUnicodeString( ppszTrusteeName, pszArgument );

   if ( dwErr != ERROR_SUCCESS ) 
   {
      goto FAILURE_RETURN;
   }

   if ( Op != REVOKE ) 
   {
      *pszTempString = L':';
      pszTempString++;

      // Now, process all of the user rights
      *pAccess = 0;
      while ( pszTempString && !( *pszTempString == L';' || *pszTempString == L'\0' ) ) 
      {
         for ( j = 0; j < RightsListCount; j++ ) 
         {                 
            if ( !_wcsnicmp( pszTempString,
                             RightsList[ j ].String,
                             RightsList[ j ].Length ) )                 
            {
               *pAccess |= RightsList[ j ].Right;
               pszTempString += RightsList[ j ].Length;
               break;
            }
         }

         if ( j == RightsListCount ) 
         {
            dwErr = ERROR_INVALID_PARAMETER;
            goto FAILURE_RETURN;
         }
      }

      if ( *pAccess == 0 ) 
      {
         dwErr = ERROR_INVALID_PARAMETER;
         goto FAILURE_RETURN;
      }

      //
      // Object id
      //
      if ( pszTempString && *pszTempString != L'\0' ) 
      {
         pszTempString++;           
         if ( pszTempString && *pszTempString != L';' && *pszTempString != L'\0' ) 
         {
            pszTempString2 = wcschr( pszTempString, L';' );
            if ( pszTempString2 ) 
            {
               *pszTempString2 = L'\0';
            }
            dwErr = CopyUnicodeString( ppszObjectId,pszTempString );

            if ( dwErr != ERROR_SUCCESS ) 
            {
               goto FAILURE_RETURN;
            }

            if ( pszTempString2 ) 
            {
               *pszTempString2 = L';';
            }
            pszTempString = pszTempString2;
         }
      }
      else
         *ppszObjectId = NULL;

      //
      // Inherit id
      //
      if ( pszTempString && *pszTempString != L'\0' ) 
      {
         pszTempString++;
         if ( pszTempString &&  *pszTempString != L'\0' ) 
         {
            dwErr = CopyUnicodeString( ppszInheritId,  
                                          pszTempString );

            if ( dwErr != ERROR_SUCCESS ) 
            {
               goto FAILURE_RETURN;
            }
         }

      } else 
         *ppszInheritId = NULL;
                
   }


FAILURE_RETURN:
if( dwErr != ERROR_SUCCESS )
{
   if( *ppszTrusteeName )
   {
      LocalFree( *ppszTrusteeName );
      *ppszTrusteeName = NULL;
   }
   if( *ppszObjectId )
   {
      LocalFree( *ppszObjectId );
      *ppszObjectId = NULL;
   }
   if( *ppszInheritId )
   {
      LocalFree( *ppszInheritId );
      *ppszInheritId = NULL;
   }
   *pAccess = 0;
}

return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\refresh.cpp ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name:

    refresh.c

Abstract:

    This Module implements the delegation tool, which allows for the management
    of access to DS objects

Author:

    Mac McLain  (MacM)    10-15-96

Environment:

    User Mode

Revision History:

--*/
#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"


typedef struct _DEFAULT_SD_NODE  {

    PWSTR ObjectClass;
    PSECURITY_DESCRIPTOR DefaultSd;
    struct _DEFAULT_SD_NODE *Next;

} DEFAULT_SD_NODE, *PDEFAULT_SD_NODE;

typedef struct _DEFAULT_SD_INFO {

    LDAP *Ldap;
    PWSTR SchemaPath;
    PSID DomainSid;
    PDEFAULT_SD_NODE SdList;
} DEFAULT_SD_INFO, *PDEFAULT_SD_INFO;

#define DSACL_ALL_FILTER        L"(ObjectClass=*)"
#define DSACL_SCHEMA_NC         L"schemaNamingContext"
#define DSACL_OBJECT_CLASS      L"objectClass"
#define DSACL_LDAP_DN           L"(ldapDisplayName="
#define DSACL_LDAP_DN_CLOSE     L")"
#define DSACL_DEFAULT_SD        L"defaultSecurityDescriptor"




DWORD
FindDefaultSdForClass(
    IN PWSTR ClassId,
    IN PDEFAULT_SD_INFO SdInfo,
    IN OUT PDEFAULT_SD_NODE *DefaultSdNode
    )
/*++

Routine Description:

    This routine will search the SD_INFO list for an existing entry that matches the current
    class type.  If no such entry is found, one will be created from information from the schema

Arguments:

    ClassId - ClassId to find the default SD node for
    SdInfo - Current list of default SDs and associated information
    DefaultSdNode - Where the locted node is returned

Returns:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        NULL,
        NULL
        };
    LDAPMessage *Message = NULL, *Entry;
    PWSTR Filter = NULL, SchemaObjectDn = NULL, DefaultSd = NULL, *DefaultSdList = NULL;
    PDEFAULT_SD_NODE Node;

    *DefaultSdNode = NULL;

    Node = SdInfo->SdList;

    while ( Node ) {

        if ( !_wcsicmp( Node->ObjectClass, ClassId ) ) {

            *DefaultSdNode = Node;
            break;
        }

        Node = Node->Next;
    }

    //
    // If it wasn't found, we'll have to go out and load it out of the Ds.
    //
    if ( !Node ) {

        Filter = (LPWSTR)LocalAlloc( LMEM_FIXED,
                             sizeof( DSACL_LDAP_DN ) - sizeof( WCHAR ) +
                                ( wcslen( ClassId ) * sizeof( WCHAR ) ) +
                                sizeof( DSACL_LDAP_DN_CLOSE ) );
        if ( !Filter ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto FindDefaultExit;
        }

        swprintf( Filter,
                  L"%ws%ws%ws",
                  DSACL_LDAP_DN,
                  ClassId,
                  DSACL_LDAP_DN_CLOSE );

        //
        // Now, do the search
        //
        Win32Err = LdapMapErrorToWin32( ldap_search_s( SdInfo->Ldap,
                                                       SdInfo->SchemaPath,
                                                       LDAP_SCOPE_SUBTREE,
                                                       Filter,
                                                       Attributes,
                                                       0,
                                                       &Message ) );

        if ( Win32Err != ERROR_SUCCESS ) {

            goto FindDefaultExit;
        }

        Entry = ldap_first_entry( SdInfo->Ldap, Message );

        if ( Entry ) {

            SchemaObjectDn = ldap_get_dn( SdInfo->Ldap, Entry );

            if ( !SchemaObjectDn ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                goto FindDefaultExit;

            }
        } else {

            Win32Err = LdapMapErrorToWin32( SdInfo->Ldap->ld_errno );
            goto FindDefaultExit;
        }

		  ldap_msgfree( Message );
		  Message = NULL;

        //
        // Ok, now we can read the default security descriptor
        //
        Attributes[ 0 ] = DSACL_DEFAULT_SD;
        Win32Err = LdapMapErrorToWin32( ldap_search_s( SdInfo->Ldap,
                                                       SchemaObjectDn,
                                                       LDAP_SCOPE_BASE,
                                                       DSACL_ALL_FILTER,
                                                       Attributes,
                                                       0,
                                                       &Message ) );
        Entry = ldap_first_entry( SdInfo->Ldap, Message );

        if ( Entry ) {

            //
            // Now, we'll have to get the values
            //
            DefaultSdList = ldap_get_values( SdInfo->Ldap, Entry, Attributes[ 0 ] );

            if ( DefaultSdList ) {

                DefaultSd = DefaultSdList[ 0 ];

            } else {

                Win32Err = LdapMapErrorToWin32( SdInfo->Ldap->ld_errno );
                goto FindDefaultExit;
            }        
        }


        //
        // Find a new node and insert it
        //
        Node = (DEFAULT_SD_NODE*)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                           sizeof( DEFAULT_SD_NODE ) );
        if ( !Node ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto FindDefaultExit;
        }


        if ( !ConvertStringSDToSDRootDomain( SdInfo->DomainSid,
                                             DefaultSd,
                                             SDDL_REVISION,
                                             &Node->DefaultSd,
                                             NULL ) ) {


            Win32Err = GetLastError();
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Node->ObjectClass =(LPWSTR) LocalAlloc( LMEM_FIXED,
                                            ( wcslen( ClassId ) + 1 ) * sizeof( WCHAR ) );

            if ( Node->ObjectClass == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                wcscpy( Node->ObjectClass, ClassId );

                Node->Next = SdInfo->SdList;
                SdInfo->SdList = Node;
            }
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            LocalFree( Node->DefaultSd );
            LocalFree( Node->ObjectClass );
            LocalFree( Node );

        } else {

            *DefaultSdNode = Node;
        }




    }



FindDefaultExit:

    LocalFree( Filter );

	 if(Message)
		  ldap_msgfree( Message );


    if ( SchemaObjectDn ) {

        ldap_memfree( SchemaObjectDn );
    }

    if ( DefaultSdList ) {

        ldap_value_free( DefaultSdList );
    }
    return( Win32Err );
}




DWORD
SetDefaultSdForObject(
    IN LDAP *Ldap,
    IN PWSTR ObjectPath,
    IN PDEFAULT_SD_INFO SdInfo,
	IN SECURITY_INFORMATION Protection
    )
/*++

Routine Description:

    This routine set the default security descriptor on the indicated object

Arguments:

    Ldap - Ldap connect to the server holding the object
    ObjectPath - 1779 style path to the object
    SdInfo - Current list of default SDs and associated information

Returns:

    ERROR_SUCCESS - Success
    ERROR_DS_NAME_TYPE_UNKNOWN - Unable to determine the class id of the object

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        DSACL_OBJECT_CLASS,
        NULL
        };
    LDAPMessage *Message = NULL, *Entry;
    PWSTR ClassId = NULL;
    PWSTR *ClassList = NULL;
    ULONG i;
    PDEFAULT_SD_NODE DefaultSdNode = NULL;
    PACTRL_ACCESS NewAccess = NULL;
    PACTRL_AUDIT NewAudit = NULL;

    //
    // First, get the class id off of the object
    //
    Win32Err = LdapMapErrorToWin32( ldap_search_s( Ldap,
                                                   ObjectPath,
                                                   LDAP_SCOPE_BASE,
                                                   DSACL_ALL_FILTER,
                                                   Attributes,
                                                   0,
                                                   &Message ) );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto SetDefaultExit;
    }

    Entry = ldap_first_entry( Ldap, Message );

    if ( Entry ) {

        //
        // Now, we'll have to get the values
        //
        ClassList = ldap_get_values( Ldap, Entry, Attributes[ 0 ] );

        if ( ClassList ) {

            //
            // Get the class id
            //
            i = 0;
            while ( TRUE ) {

                if ( ClassList[ i ] ) {

                    i++;

                } else {

                    break;
                }
            }

//            ASSERT( i > 0 );
            if ( i == 0 ) {

                Win32Err = ERROR_DS_NAME_TYPE_UNKNOWN;
                goto SetDefaultExit;
            }
            ClassId = ClassList[ i - 1 ];

        } else {

            Win32Err = LdapMapErrorToWin32( Ldap->ld_errno );
            goto SetDefaultExit;
        }

        ldap_msgfree( Message );
        Message = NULL;
    }

    if ( !ClassId ) {

        Win32Err = ERROR_DS_NAME_TYPE_UNKNOWN;
                goto SetDefaultExit;
    }
    //
    // Now, see if we have a cache entry for that...
    //
    Win32Err =  FindDefaultSdForClass( ClassId,
                                       SdInfo,
                                       &DefaultSdNode );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto SetDefaultExit;
    }


    if ( Win32Err == ERROR_SUCCESS ) {


          Win32Err = WriteObjectSecurity(ObjectPath,
                                         DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION | Protection,
                                         DefaultSdNode->DefaultSd
                                          );
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        DisplayMessageEx( 0, MSG_DSACLS_PROCESSED, ObjectPath );
    }


SetDefaultExit:

    if ( ClassList ) {

        ldap_value_free( ClassList );
    }

    if ( Message ) {

        ldap_msgfree( Message );
    }

    LocalFree( NewAccess );
    LocalFree( NewAudit );

    return( Win32Err );
}




DWORD
SetDefaultSdForObjectAndChildren(
    IN LDAP *Ldap,
    IN PWSTR ObjectPath,
    IN PDEFAULT_SD_INFO SdInfo,
    IN BOOLEAN Propagate,
	IN SECURITY_INFORMATION Protection
    )
/*++

Routine Description:

    This routine will set the security descriptor on the object and potentially all of its
    children to the default security as obtained from the schema

Arguments:

    Ldap - Ldap connect to the server holding the object
    ObjectPath - 1779 style path to the object
    SdInfo - Current list of default SDs and associated information
    Propagate - If TRUE, reset the security on the children as well

Returns:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        NULL
        };
    LDAPMessage *Message = NULL, *Entry;
    PWSTR ChildName = NULL;
    PLDAPSearch SearchHandle = NULL;
    ULONG Count;

    //
    // First, get the class id off of the object
    //
    SearchHandle = ldap_search_init_pageW( Ldap,
                                           ObjectPath,
                                           Propagate ? LDAP_SCOPE_SUBTREE : LDAP_SCOPE_BASE,
                                           DSACL_ALL_FILTER,
                                           Attributes,
                                           FALSE,
                                           NULL,
                                           NULL,
                                           0,
                                           2000,
                                           NULL );

    if ( SearchHandle == NULL ) {

        Win32Err = LdapMapErrorToWin32( LdapGetLastError( ) );

    } else {

        while ( Win32Err == ERROR_SUCCESS ) {

            Count = 0;

            //
            // Get the next page
            //
            Win32Err = ldap_get_next_page_s( Ldap,
                                             SearchHandle,
                                             NULL,
                                             100,
                                             &Count,
                                             &Message );

            if ( Message ) {

                Entry = ldap_first_entry( Ldap, Message );

                while ( Entry ) {

                    ChildName = ldap_get_dn( SdInfo->Ldap, Entry );

                    if ( !ChildName ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;

                    }


                    Win32Err = SetDefaultSdForObject( Ldap,
                                                      ChildName,
                                                      SdInfo,
													  Protection);

                    ldap_memfree( ChildName );
                    if ( Win32Err != ERROR_SUCCESS ) {

                        break;
                    }

                    Entry = ldap_next_entry( Ldap, Entry );
                }

                Win32Err = Ldap->ld_errno;
                ldap_msgfree( Message );
                Message = NULL;
            }

            if ( Win32Err == LDAP_NO_RESULTS_RETURNED ) {

                Win32Err = ERROR_SUCCESS;
                break;
            }

        }

        ldap_search_abandon_page( Ldap,
                                  SearchHandle );
    }

    return( Win32Err );
}




DWORD
BindToDsObject(
    IN PWSTR ObjectPath,
    OUT PLDAP *Ldap,
    OUT PSID *DomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine will bind to the ldap server on a domain controller that holds the specified
    object path.  Optionally, the sid of the domain hosted by that domain controller is returned

Arguments:

    ObjectPath - 1779 style path to the object
    Ldap - Where the ldap connection handle is returned
    DomainSid - Sid of the domain hosted by the domain controller.

Returns:

    ERROR_SUCCESS - Success
    ERROR_PATH_NOT_FOUND - A domain controller for this path could not be located
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR ServerName = NULL;
    PWSTR Separator = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    PWSTR Path = NULL;
    HANDLE DsHandle = NULL;
    PDS_NAME_RESULT NameRes = NULL;
    BOOLEAN NamedServer = FALSE;
    UNICODE_STRING ServerNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPDI = NULL;
    NTSTATUS Status;

    //
    // Get a server name
    //
/*    if ( wcslen( ObjectPath ) > 2 && *ObjectPath == L'\\' && *( ObjectPath + 1 ) == L'\\' ) {

        Separator = wcschr( ObjectPath + 2, L'\\' );

        if ( Separator ) {

            *Separator = L'\0';
            Path = Separator + 1;
        }

        ServerName = ObjectPath + 2;
        NamedServer = TRUE;

    } else {

        Path = ObjectPath;

        Win32Err = DsGetDcName( NULL,
                                NULL,
                                NULL,
                                NULL,
                                DS_IP_REQUIRED |
                                    DS_DIRECTORY_SERVICE_REQUIRED,
                                &DcInfo );
        if ( Win32Err == ERROR_SUCCESS ) {

            ServerName = DcInfo[ 0 ].DomainControllerName + 2;
        }

    }

    //
    // Do the bind and crack
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsBind( ServerName,
                           NULL,
                           &DsHandle );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsCrackNames( DsHandle,
                                     DS_NAME_NO_FLAGS,
                                     DS_FQDN_1779_NAME,
                                     DS_FQDN_1779_NAME,
                                     1,
                                     &Path,
                                     &NameRes );

            if ( Win32Err == ERROR_SUCCESS ) {

                if ( NameRes->cItems != 0  && !NamedServer &&
                     NameRes->rItems[ 0 ].status == DS_NAME_ERROR_DOMAIN_ONLY ) {

                    NetApiBufferFree( DcInfo );
                    DcInfo = NULL;

                    Win32Err = DsGetDcNameW( NULL,
                                             NameRes->rItems[ 0 ].pDomain,
                                             NULL,
                                             NULL,
                                             DS_IP_REQUIRED |
                                                DS_DIRECTORY_SERVICE_REQUIRED,
                                             &DcInfo );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        DsUnBindW( &DsHandle );
                        DsHandle = NULL;

                        ServerName = DcInfo->DomainControllerName + 2;

                        //Win32Err = DsBind( DcInfo->DomainControllerAddress,
                        //                   NULL,
                        //                   &DsHandle );
                        //

                        Win32Err = DsBind( ServerName,
                                           NULL,
                                           &DsHandle );
                        
                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = DsCrackNames( DsHandle,
                                                     DS_NAME_NO_FLAGS,
                                                     DS_FQDN_1779_NAME,
                                                     DS_FQDN_1779_NAME,
                                                     1,
                                                     &Path,
                                                     &NameRes);
                        }

                    }

                }
            }

        }
    }
*/
    //
    // Now, do the bind
    //



            *Ldap = ldap_open( g_szServerName,
                               LDAP_PORT );

            if ( *Ldap == NULL ) {

                Win32Err = ERROR_PATH_NOT_FOUND;

            } else {

                Win32Err = LdapMapErrorToWin32( ldap_bind_s( *Ldap,
                                                             NULL,
                                                             NULL,
                                                             LDAP_AUTH_SSPI ) );
            }




    //
    // If specified, get the sid for the domain
    //
    if ( DomainSid ) {

        RtlInitUnicodeString( &ServerNameU, g_szServerName );
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

        //
        // Get the sid of the domain
        //
        Status = LsaOpenPolicy( &ServerNameU,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LsaHandle );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( LsaHandle,
                                                PolicyPrimaryDomainInformation,
                                                ( PVOID * )&PolicyPDI );

            if ( NT_SUCCESS( Status ) ) {

                *DomainSid = (PSID)LocalAlloc( LMEM_FIXED,
                                         RtlLengthSid( PolicyPDI->Sid ) );

                if ( *DomainSid == NULL ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopySid( RtlLengthSid( PolicyPDI->Sid ), *DomainSid, PolicyPDI->Sid );
                }

                LsaFreeMemory( PolicyPDI );
            }
            LsaClose( LsaHandle );
        }

        if ( !NT_SUCCESS( Status ) ) {

            Win32Err = RtlNtStatusToDosError( Status );
            ldap_unbind( *Ldap );
            *Ldap = NULL;
        }

    }



    return( Win32Err );
}




DWORD
SetDefaultSecurityOnObjectTree(
    IN PWSTR ObjectPath,
    IN BOOLEAN Propagate,
	IN SECURITY_INFORMATION Protection
    )
/*++

Routine Description:

    This routine will set the security descriptor on the object and potentially all of its
    children to the default security as obtained from the schema

Arguments:

    ObjectPath - 1779 style path to the object
    Propagate - If TRUE, reset the security on the children as well

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        DSACL_SCHEMA_NC,
        NULL
        };
    LDAPMessage *Message = NULL;
    LDAPMessage *Entry = NULL;
    PWSTR *PathList = NULL;
    DEFAULT_SD_INFO SdInfo = {
        NULL,
        NULL,
        NULL,
        NULL
        };
    PDEFAULT_SD_NODE CleanupNode;

    //
    // Bind to the ds object
    //
    Win32Err = BindToDsObject( ObjectPath,
                               &SdInfo.Ldap,
                               &SdInfo.DomainSid );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto SetDefaultExit;
    }

    //
    // Get the schema path
    //

    Win32Err = LdapMapErrorToWin32( ldap_search_s( SdInfo.Ldap,
                                                   NULL,
                                                   LDAP_SCOPE_BASE,
                                                   DSACL_ALL_FILTER,
                                                   Attributes,
                                                   0,
                                                   &Message ) );

    if ( Win32Err == ERROR_SUCCESS ) {

        Entry = ldap_first_entry( SdInfo.Ldap, Message );

        if ( Entry ) {

            //
            // Now, we'll have to get the values
            //
            PathList = ldap_get_values( SdInfo.Ldap, Entry, Attributes[ 0 ] );

            if ( PathList ) {

                SdInfo.SchemaPath = PathList[ 0 ];

            } else {

                Win32Err = LdapMapErrorToWin32( SdInfo.Ldap->ld_errno );
            }

        }
    }

    if( SdInfo.Ldap )
    {
        Win32Err = SetDefaultSdForObjectAndChildren( SdInfo.Ldap,
                                                     ObjectPath,
                                                     &SdInfo,
                                                     Propagate,
													 Protection);
    }

SetDefaultExit:

	 if( Message )
		 ldap_msgfree( Message );

    //
    // Unbind from the DS
    //
    if ( SdInfo.Ldap ) {

        ldap_unbind( SdInfo.Ldap );
    }

    if ( PathList ) {

        ldap_value_free( PathList );
    }

    //
    // Clean up the Default SD Info list
    //
    LocalFree( SdInfo.DomainSid );


    while ( SdInfo.SdList ) {

        CleanupNode = SdInfo.SdList;
        LocalFree( CleanupNode->ObjectClass );
        LocalFree( CleanupNode->DefaultSd );
        SdInfo.SdList = SdInfo.SdList->Next;
        LocalFree( CleanupNode );
    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\dsacls.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsacls.h

Abstract:

    The main header file for the dsacls tool

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:


--*/

#ifndef _DSACLS_H
#define _DSACLS_H

#include <caclsmsg.h>
#include "accctrl.h"

#define FLAG_ON(flags,bit)        ((flags) & (bit))
//Some Error Checking Macros
#define CHECK_NULL( ptr, jump_loc )  \
if( ptr == NULL ) \
{  \
   dwErr = ERROR_NOT_ENOUGH_MEMORY; \
   goto jump_loc; \
}  


#define CHECK_HR( hr, jump_loc ) \
if( hr != S_OK )  \
{  \
   dwErr = HRESULT_CODE( hr );   \
   goto jump_loc; \
}  \

//
// Local prototypes
//
#if DSACL_DBG
ULONG gfDebug;
#endif

//
// Type of operation to perform
//
typedef enum _DSACLS_OP
{
    REVOKE = 0,
    GRANT,
    DENY
} DSACLS_OP;

#define DSACLS_EXTRA_INFO_NONE      0
#define DSACLS_EXTRA_INFO_REQUIRED  1
#define DSACLS_EXTRA_INFO_OPTIONAL  2

typedef struct _DSACLS_ARG {
    ULONG ResourceId;
    PWSTR String;
    ULONG Length;
    ULONG StartIndex;
    ULONG Flag;
    ULONG SkipCount;
    BOOLEAN SkipNonFlag;
    WORD ExtraInfo;
} DSACLS_ARG, *PDSACLS_ARG;

typedef struct _DSACLS_INHERIT {
    ULONG ResourceId;
    PWSTR String;
    ULONG Length;
    BOOLEAN ValidForInput;
    ULONG InheritFlag;

} DSACLS_INHERIT, *PDSACLS_INHERIT;

typedef struct _DSACLS_RIGHTS {
    ULONG ResourceId;
    PWSTR String;
    ULONG ResourceIdEx;
    PWSTR StringEx;
    ULONG Length;
    ULONG Right;

} DSACLS_RIGHTS, *PDSACLS_RIGHTS;

typedef struct _DSACLS_PROTECT {
   ULONG ResourceId;
   PWSTR String;
   ULONG Length;
   ULONG Right;
} DSACLS_PROTECT, *PDSACLS_PROTECT;

extern LPWSTR g_szSchemaNamingContext;
extern LPWSTR g_szConfigurationNamingContext;
extern HMODULE g_hInstance;
extern LPWSTR g_szServerName;
extern CCache *g_Cache;

//
// Prototypes from dsacls.c
//


DWORD 
InitializeGlobalArrays();

DWORD
ConvertArgvToUnicode( LPWSTR * wargv, 
                      char ** argv, 
                      int argc ) ;

DWORD
WriteObjectSecurity( IN LPWSTR pszObject,
                     IN SECURITY_INFORMATION si,
                     IN PSECURITY_DESCRIPTOR pSD );





//
// prototypes from refresh.c
//
DWORD
SetDefaultSecurityOnObjectTree(
    IN PWSTR ObjectPath,
    IN BOOLEAN Propagate,
	IN SECURITY_INFORMATION Protection
    );


void MapGeneric( ACCESS_MASK * pMask );
void DisplayAccessRights( UINT nSpace, ACCESS_MASK m_Mask );

void ConvertAccessMaskToGenericString( ACCESS_MASK m_Mask, LPWSTR szLoadBuffer, UINT nBuffer );
DWORD BuildExplicitAccess( IN PSID pSid,
                           IN GUID* pGuidObject,
                           IN GUID* pGuidInherit,
                           IN ACCESS_MODE AccessMode,
                           IN ULONG Access,
                           IN ULONG Inheritance,
                           OUT PEXPLICIT_ACCESS pExplicitAccess );


DWORD ParseUserAndPermissons( IN LPWSTR pszArgument,
                              IN DSACLS_OP Op,
                              IN ULONG RightsListCount,
                              IN PDSACLS_RIGHTS RightsList,
                              OUT LPWSTR * ppszTrusteeName,
                              OUT PULONG  pAccess,
                              OUT LPWSTR * ppszObjectId,
                              OUT LPWSTR * ppszInheritId );

//
// Define the rights used in the DS
//

#define RIGHT_DS_CREATE_CHILD     ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_WRITE_PROPERTY_EXTENDED  ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP
#define RIGHT_DS_DELETE_TREE      ACTRL_DS_DELETE_TREE
#define RIGHT_DS_LIST_OBJECT      ACTRL_DS_LIST_OBJECT
#ifndef ACTRL_DS_CONTROL_ACCESS
#define ACTRL_DS_CONTROL_ACCESS   ACTRL_PERM_9
#endif
#define RIGHT_DS_CONTROL_ACCESS   ACTRL_DS_CONTROL_ACCESS
//
// Define the generic rights
//

// generic read
#define GENERIC_READ_MAPPING     ((STANDARD_RIGHTS_READ)     | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_LIST_OBJECT))

// generic execute
#define GENERIC_EXECUTE_MAPPING  ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (RIGHT_DS_LIST_CONTENTS))
// generic right
#define GENERIC_WRITE_MAPPING    ((STANDARD_RIGHTS_WRITE)    | \
                                  (RIGHT_DS_WRITE_PROPERTY_EXTENDED)  | \
                  (RIGHT_DS_WRITE_PROPERTY))
// generic all

#define GENERIC_ALL_MAPPING      ((STANDARD_RIGHTS_REQUIRED) | \
                                  (RIGHT_DS_CREATE_CHILD)    | \
                                  (RIGHT_DS_DELETE_CHILD)    | \
                                  (RIGHT_DS_DELETE_TREE)     | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_WRITE_PROPERTY)  | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_LIST_OBJECT)     | \
                                  (RIGHT_DS_CONTROL_ACCESS)  | \
                                  (RIGHT_DS_WRITE_PROPERTY_EXTENDED))

//
// Standard DS generic access rights mapping
//

#define DS_GENERIC_MAPPING {GENERIC_READ_MAPPING,    \
                GENERIC_WRITE_MAPPING,   \
                GENERIC_EXECUTE_MAPPING, \
                GENERIC_ALL_MAPPING}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\utils.cpp ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name: utils.cpp
Abstract: This Module implements the utility routines for dsacls
Author: hitesh raigandhi (hiteshr )
Environment:User Mode
Revision History:

--*/


#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"

/*******************************************************************
    NAME:       GetAccountNameFromSid

    SYNOPSIS:   Convert Sid to Account Name

    ENTRY:      pszServerName: Server name at which to look for
                pSid : Pointer to Sid
                
    EXIT:       ppszName : Gets pointer to Account Name

    RETURNS:    ERROR_SUCCESS if Successful
                ERROR_NOT_ENOUGH_MEMORY 


    NOTES:      If LookupAccountName resolve the sid, it is
                converted in to string and returned
                
    HISTORY:
        hiteshr    July-1999     Created

********************************************************************/
DWORD GetAccountNameFromSid( LPWSTR pszServerName,
                             PSID pSid, 
                             LPWSTR * ppszName )
{
LPWSTR pszAccountName = NULL;
LPWSTR pszDomainName = NULL;
DWORD cbAccountName = 0 ;
DWORD cbDomainName = 0;
SID_NAME_USE Use ;
DWORD dwErr = ERROR_SUCCESS;

   *ppszName = NULL;
    
   if(  LookupAccountSid( pszServerName,  // name of local or remote computer
                          pSid,              // security identifier
                          NULL,           // account name buffer
                          &cbAccountName,
                          NULL ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      if( dwErr != ERROR_INSUFFICIENT_BUFFER )
      {
         //Convert Sid to String
         if( !ConvertSidToStringSid( pSid, ppszName ) )
            dwErr = GetLastError();
         else
            dwErr = ERROR_SUCCESS;

         goto FAILURE_RETURN;
      }
      else
         dwErr = ERROR_SUCCESS;
   }

   pszAccountName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbAccountName +1 ) * sizeof( WCHAR ) );
   if( pszAccountName == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   pszDomainName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbDomainName + 1 )* sizeof( WCHAR ) );
   if( pszDomainName == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   if(  LookupAccountSid( pszServerName,  // name of local or remote computer
                          pSid,              // security identifier
                          pszAccountName,           // account name buffer
                          &cbAccountName,
                          pszDomainName ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      goto FAILURE_RETURN;
   }

   *ppszName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbAccountName + cbDomainName + 2 ) * sizeof( WCHAR ) );
   if( *ppszName == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   *ppszName[0] = NULL;
   if( cbDomainName )
   {
      wcscpy( *ppszName, pszDomainName );
      wcscat( *ppszName, L"\\" );
   }
   wcscat( *ppszName, pszAccountName );
   

FAILURE_RETURN:
   if( pszDomainName )
      LocalFree( pszDomainName );
   if( pszAccountName )
      LocalFree( pszAccountName );
   return dwErr;
}
   
/*******************************************************************

    NAME:       GetSidFromAccountName

    SYNOPSIS:   Converts AccountName into SID
********************************************************************/
DWORD GetSidFromAccountName( LPWSTR pszServerName,
                             PSID *ppSid, 
                             LPWSTR  pszName )
{
LPWSTR pszDomainName = NULL;
DWORD cbSid = 0 ;
DWORD cbDomainName = 0;
SID_NAME_USE Use ;
DWORD dwErr = ERROR_SUCCESS;

    
   if(  LookupAccountName(pszServerName,  // name of local or remote computer
                          pszName,              // security identifier
                          NULL,           // account name buffer
                          &cbSid,
                          NULL ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      if( dwErr != ERROR_INSUFFICIENT_BUFFER )
         goto FAILURE_RETURN;
      else
         dwErr = ERROR_SUCCESS;
   }

   *ppSid = (PSID)LocalAlloc( LMEM_FIXED, cbSid );
   CHECK_NULL( *ppSid, FAILURE_RETURN );


   pszDomainName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbDomainName + 1 )* sizeof( WCHAR ) );
   CHECK_NULL( pszDomainName, FAILURE_RETURN );

   if(  LookupAccountName( pszServerName,  // name of local or remote computer
                          pszName,              // security identifier
                          *ppSid,           // account name buffer
                          &cbSid,
                          pszDomainName ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      goto FAILURE_RETURN;
   }
  
   goto SUCCESS_RETURN;

FAILURE_RETURN:
   if( pszDomainName )
      LocalFree( pszDomainName );
   if( *ppSid )
      LocalFree( *ppSid );
SUCCESS_RETURN:
   return dwErr;
}
 

/*******************************************************************

    NAME:       GetAceSid

    SYNOPSIS:   Gets pointer to SID from an ACE

    ENTRY:      pAce - pointer to ACE

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
PSID
GetAceSid(PACE_HEADER pAce)
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        return (PSID)&((PKNOWN_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        return RtlObjectAceSid(pAce);
    }

    return NULL;
}


/*******************************************************************

    NAME:       GetGlobalNamingContexts

    SYNOPSIS:   Gets LDAP path for Schema and Extendend-Rights

    ENTRY:      pszServerName, Server to bind to for query

    EXIT:       pszSchemaNamingContext: Schema name in 
                "LDAP:\\cn=schema,cn=..." format
                pszConfigurationNamingContext: Extendend rights path
                in "LDAP:\\CN=Extended-Rights,CN=Configuration..formats

    RETURNS:    WIN32 Error Code

********************************************************************/
DWORD GetGlobalNamingContexts( LPWSTR pszServerName,
                               LPWSTR * pszSchemaNamingContext,
                               LPWSTR * pszConfigurationNamingContext )
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR szSNC = NULL;

    ULONG uLen = 0;
    IADs *spRootDSE = NULL;
    LPWSTR pszRootDsePath = NULL;

   *pszSchemaNamingContext = NULL;
   *pszConfigurationNamingContext = NULL;
   
   if( pszServerName )
      uLen = wcslen(L"LDAP://")  +
             wcslen( pszServerName ) + 
             wcslen( L"/RootDSE") + 1;
             

   else
      uLen = wcslen(L"LDAP://RootDSE");


   pszRootDsePath = (LPWSTR)LocalAlloc( LMEM_FIXED, uLen * sizeof(WCHAR) );
   CHECK_NULL( pszRootDsePath,FAILURE_RETURN );
   wcscpy(pszRootDsePath, L"LDAP://");
   if( pszServerName )
   {
      wcscat( pszRootDsePath, pszServerName );
      wcscat( pszRootDsePath, L"/" );
   }
   wcscat( pszRootDsePath, L"RootDSE" );

   hr = ::ADsGetObject( pszRootDsePath,
                        IID_IADs,
                        (void**)&spRootDSE );

   CHECK_HR( hr, FAILURE_RETURN );

   //NTRAID#NTBUG9-537319-2002/03/20-hiteshr
   VARIANT varSchemaNamingContext;
   hr = spRootDSE->Get(AutoBstr(L"schemaNamingContext"),
                        &varSchemaNamingContext);

   CHECK_HR( hr, FAILURE_RETURN );

   if(VT_BSTR != varSchemaNamingContext.vt)
   {
       hr = E_INVALIDARG;
       goto FAILURE_RETURN;
   }

   WCHAR szLdapPrefix[] = L"LDAP://";
   szSNC = (LPWSTR)varSchemaNamingContext.bstrVal;
   //For "LDAP:// + 1, ARRAYSIZE includes terminating null char
   uLen = wcslen( szSNC ) + ARRAYSIZE(szLdapPrefix); //For "LDAP:// + 1
   *pszSchemaNamingContext = (LPWSTR) LocalAlloc( LMEM_FIXED, uLen* sizeof(WCHAR) );
   CHECK_NULL( *pszSchemaNamingContext, FAILURE_RETURN );

   hr = StringCchCopy(*pszSchemaNamingContext, uLen, szLdapPrefix);
   CHECK_HR( hr, FAILURE_RETURN );
   hr = StringCchCat( *pszSchemaNamingContext, uLen, szSNC );
   CHECK_HR( hr, FAILURE_RETURN );

   //NTRAID#NTBUG9-537319-2002/03/20-hiteshr
   hr = spRootDSE->Get(AutoBstr(L"configurationNamingContext"),
                           &varSchemaNamingContext);

   CHECK_HR( hr, FAILURE_RETURN );   

   if(VT_BSTR != varSchemaNamingContext.vt)
   {
       hr = E_INVALIDARG;
       goto FAILURE_RETURN;
   }
   
   WCHAR szExtendedPrefix[] = L"LDAP://CN=Extended-Rights,";
   szSNC = (LPWSTR)varSchemaNamingContext.bstrVal;
   //For "LDAP://CN=Extended-Rights,". ARRAYSIZE include terminating NULL CHAR
   uLen = wcslen( szSNC ) + ARRAYSIZE(szExtendedPrefix);
   *pszConfigurationNamingContext = (LPWSTR) LocalAlloc( LMEM_FIXED, uLen* sizeof(WCHAR) );

   CHECK_NULL( *pszConfigurationNamingContext,FAILURE_RETURN );
   
   hr = StringCchCopy(*pszConfigurationNamingContext,uLen,szExtendedPrefix);
   CHECK_HR( hr, FAILURE_RETURN );   
   
   hr = StringCchCat(*pszConfigurationNamingContext, uLen, szSNC);
   CHECK_HR( hr, FAILURE_RETURN );   

   goto SUCCESS_RETURN;

FAILURE_RETURN:
   if( *pszSchemaNamingContext )
      LocalFree( *pszSchemaNamingContext );
   if( *pszConfigurationNamingContext )
      LocalFree( *pszConfigurationNamingContext );

SUCCESS_RETURN:
   if( spRootDSE )
        spRootDSE->Release();
   if( pszRootDsePath )
      LocalFree( pszRootDsePath );
    
   return dwErr;
}





/*******************************************************************

    NAME:       FormatStringGUID

    SYNOPSIS:   Given a GUID struct, it returns a GUID in string format,
                without {}
    //Function copied from marcoc code 
********************************************************************/
BOOL FormatStringGUID(LPWSTR lpszBuf, UINT nBufSize, const GUID* pGuid)
{
  lpszBuf[0] = NULL;

  // if it is a NULL GUID*, just return an empty string
  if (pGuid == NULL)
  {
    return FALSE;
  }

/*
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
}

  int _snwprintf( wchar_t *buffer, size_t count, const wchar_t *format [, argume
nt] ... );
*/
  return (_snwprintf(lpszBuf, nBufSize,
            L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            pGuid->Data1, pGuid->Data2, pGuid->Data3,
            pGuid->Data4[0], pGuid->Data4[1],
            pGuid->Data4[2], pGuid->Data4[3], pGuid->Data4[4], pGuid->Data4[5],
pGuid->Data4[6], pGuid->Data4[7]) > 0);
}

/*
Returns A string with n spaces
*/
void StringWithNSpace( UINT n, LPWSTR szSpace )
{
   for( UINT i = 0; i < n ; ++ i )
      szSpace[i] = L' ';
   szSpace[n] = 0;
}

/*
Loads the string from Resource Table and 
Formats it 
*/
DWORD
LoadMessage( IN DWORD MessageId, LPWSTR *ppszLoadString,...)
{

    va_list ArgList;
    DWORD dwErr = ERROR_SUCCESS;
    
    va_start( ArgList, ppszLoadString );
   
    WCHAR szBuffer[1024];
    if( LoadString( g_hInstance, 
                    MessageId, 
                    szBuffer,
                    1023 ) == 0 )
   {
      dwErr = GetLastError();
      goto CLEAN_RETURN;
   }

   if( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szBuffer,
                      MessageId,
                      0,
                      ( PWSTR )ppszLoadString,
                      0,
                      &ArgList ) == 0 )
   {
      dwErr = GetLastError();
      goto CLEAN_RETURN;
   }

CLEAN_RETURN:
   va_end( ArgList );
   return dwErr;

}

/*******************************************************************

    NAME:       DisplayString

    SYNOPSIS:   Displays a string after inserting nIdent spaces
********************************************************************/
VOID DisplayString( UINT nIdent, LPWSTR pszDisplay )
{
   for ( UINT i = 0; i < nIdent; i++ )
      wprintf( L" " );

   wprintf(L"%s",pszDisplay);
}

VOID DisplayStringWithNewLine( UINT nIdent, LPWSTR pszDisplay )
{
   DisplayString( nIdent, pszDisplay );
   wprintf(L"\n");
}
VOID DisplayNewLine()
{
   wprintf(L"\n");
}

/*******************************************************************

    NAME:       DisplayMessageEx

    SYNOPSIS:   Loads Message from Resource and Formats its 
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
DWORD
DisplayMessageEx( DWORD nIndent, IN DWORD MessageId,...)
{

   va_list ArgList;
   LPWSTR pszLoadString = NULL;

   va_start( ArgList, MessageId );
   
   WCHAR szBuffer[1024];
   if( LoadString( g_hInstance, 
                   MessageId, 
                   szBuffer,
                   1023 ) == 0 )
   {
      va_end( ArgList );
      return GetLastError();
   }


    if( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            szBuffer,
                            MessageId,
                            0,
                            ( PWSTR )&pszLoadString,
                            0,
                            &ArgList ) == 0 )
   {
      va_end( ArgList );
      return GetLastError();
   }
   
   DisplayStringWithNewLine( nIndent, pszLoadString );
   LocalFree( pszLoadString );
   return ERROR_SUCCESS;
}


BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString)
{
  ZeroMemory(pGuid, sizeof(GUID));
  if (lpszGuidString == NULL)
  {
    return FALSE;
  }

  int nLen = lstrlen(lpszGuidString);
  // the string length should be 36
  if (nLen != 36)
    return FALSE;

  // add the braces to call the Win32 API
  LPWSTR lpszWithBraces = (LPWSTR)LocalAlloc(LMEM_FIXED,((nLen+1+2)*sizeof(WCHAR)) ); // NULL plus {}
  
 if(!lpszWithBraces)
    return FALSE;
  wsprintf(lpszWithBraces, L"{%s}", lpszGuidString);

  return SUCCEEDED(::CLSIDFromString(lpszWithBraces, pGuid));
}

/*******************************************************************

    NAME:       GetServerName

    SYNOPSIS:   Get the name of the server. If Obeject Path is in form
                \\ADSERVER\CN=John..., then it gets the server name
                from Object Path and changes Object Path to CN=John...
********************************************************************/

DWORD GetServerName( IN LPWSTR ObjectPath, 
                     OUT LPWSTR * ppszServerName )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Separator = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo1 = NULL;
    PWSTR Path = NULL;
    HANDLE DsHandle = NULL;
    PDS_NAME_RESULT NameRes = NULL;
    BOOLEAN NamedServer = FALSE;
    NTSTATUS Status;
    LPWSTR ServerName = NULL;
    //
    // Get a server name
    //
    if ( wcslen( ObjectPath ) > 2 && *ObjectPath == L'\\' && *( ObjectPath + 1 ) == L'\\' ) {

        Separator = wcschr( ObjectPath + 2, L'\\' );

        if ( Separator ) {

            *Separator = L'\0';
            Path = Separator + 1;
        }
        else
            return ERROR_INVALID_PARAMETER;

        ServerName = ObjectPath + 2;
        *ppszServerName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                                     sizeof(WCHAR) * (wcslen(ServerName) + 1) );
        if( *ppszServerName == NULL )
        {
            if( Separator )
               *Separator = L'\\';
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy( *ppszServerName, ServerName );
        //Remove server name from object path
        memmove( ObjectPath, Path, ( wcslen(Path) + 1) * sizeof(WCHAR) );
        return ERROR_SUCCESS;

    } else {

        Path = ObjectPath;

        Win32Err = DsGetDcName( NULL,
                                NULL,
                                NULL,
                                NULL,
                                DS_DIRECTORY_SERVICE_REQUIRED,
                                &DcInfo );
        if ( Win32Err == ERROR_SUCCESS ) {

            ServerName = DcInfo[ 0 ].DomainControllerName + 2;
        }

    }

    //
    // Do the bind and crack
    //
    if ( Win32Err == ERROR_SUCCESS  ) {

          Win32Err = DsBind( ServerName,
                                    NULL,
                                    &DsHandle );

          if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = DsCrackNames( DsHandle,
                                                 DS_NAME_NO_FLAGS,
                                                 DS_FQDN_1779_NAME,
                                                 DS_FQDN_1779_NAME,
                                                 1,
                                                 &Path,
                                                 &NameRes );

                if ( Win32Err == ERROR_SUCCESS ) {

                     if ( NameRes->cItems != 0   &&
                            NameRes->rItems[ 0 ].status == DS_NAME_ERROR_DOMAIN_ONLY ) {

    
                          Win32Err = DsGetDcNameW( NULL,
                                                            NameRes->rItems[ 0 ].pDomain,
                                                            NULL,
                                                            NULL,
                                                            DS_DIRECTORY_SERVICE_REQUIRED,
                                                            &DcInfo1 );

                          if ( Win32Err == ERROR_SUCCESS ) {


                                ServerName = DcInfo1->DomainControllerName + 2;
                            }

                            if( Win32Err == ERROR_INVALID_DOMAINNAME ||
                                Win32Err == ERROR_NO_SUCH_DOMAIN  )
                                ServerName = NULL;
                        }
                    }
                }
            }
         
         
         if( ServerName )      
         {
            *ppszServerName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                                           sizeof(WCHAR) * (wcslen(ServerName) + 1) );
            if( *ppszServerName == NULL )
               return ERROR_NOT_ENOUGH_MEMORY;
            wcscpy( *ppszServerName, ServerName );
            Win32Err = ERROR_SUCCESS;
         }


        if( DcInfo )
              NetApiBufferFree( DcInfo );
        if( DcInfo1 )
              NetApiBufferFree( DcInfo1 );
        if( DsHandle )
            DsUnBindW( &DsHandle );
         if ( NameRes )
            DsFreeNameResult( NameRes );

         return Win32Err;
}

/*******************************************************************

    NAME:       DisplayMessage

    SYNOPSIS:   Loads Message from Message Table and Formats its 
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
VOID
DisplayMessage(
    IN DWORD Indent,
    IN DWORD MessageId,
    ...
    )
/*++

Routine Description:

    Loads the resource out of the executable and displays it.

Arguments:

    Indent - Number of tabs to indent
    MessageId - Id of the message to load
    ... - Optional list of parameters

Return Value:

    VOID

--*/
{
    PWSTR MessageDisplayString;
    va_list ArgList;
    ULONG Length, i;

    va_start( ArgList, MessageId );

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            MessageId,
                            0,
                            ( PWSTR )&MessageDisplayString,
                            0,
                            &ArgList );

    if ( Length != 0 ) {

        for ( i = 0; i < Indent; i++ ) {

            printf( "\t" );
        }
        printf( "%ws", MessageDisplayString );
        LocalFree( MessageDisplayString );

    }

    va_end( ArgList );
}


/*******************************************************************

    NAME:       DisplayErrorMessage

    SYNOPSIS:   Displays Error Message corresponding to Error
    RETURNS:    NONE

********************************************************************/
VOID
DisplayErrorMessage(
    IN DWORD Error
    )
{
    ULONG Size = 0;
    PWSTR DisplayString;
    ULONG Options = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;


    Size = FormatMessage( Options,
                          NULL,
                          Error,
                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                          ( LPTSTR )&DisplayString,
                          0,
                          NULL );

    if ( Size != 0 ) {

        printf( "%ws\n", DisplayString );
        LocalFree( DisplayString );
    }

}


/*******************************************************************

    NAME:       ConvertStringAToStringW

    SYNOPSIS:   Converts MBYTE stirng to UNICODE
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY

********************************************************************/
DWORD
ConvertStringAToStringW (
    IN  PSTR            AString,
    OUT PWSTR          *WString
    )
{
    DWORD Win32Err = ERROR_SUCCESS, Length;
    if ( AString == NULL ) {

        *WString = NULL;

    } else {

        Length = strlen( AString );

        *WString = ( PWSTR )LocalAlloc( LMEM_FIXED,
                                        ( mbstowcs( NULL, AString, Length + 1 ) + 1 ) *
                                                                                sizeof( WCHAR ) );
        if(*WString != NULL ) {

            mbstowcs( *WString, AString, Length + 1);

        } else {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return( Win32Err );
}

/*******************************************************************

    NAME:       CopyUnicodeString

    SYNOPSIS:   Copy Unicode string from Source to Destination
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY
********************************************************************/
DWORD CopyUnicodeString( LPWSTR * strDst, LPWSTR strSrc )
{
            *strDst = (LPWSTR)LocalAlloc( LMEM_FIXED , ( wcslen(strSrc) + 1 ) * sizeof(WCHAR ) );
            if ( !*strDst ) {

                    return ERROR_NOT_ENOUGH_MEMORY;                    
            }            
            
            wcscpy( *strDst, strSrc );
            return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       GetProtection

    SYNOPSIS:   Sets PROTECTED_DACL_SECURITY_INFORMATION in pSI,
                if SE_DACL_PROTECTED is set pSD
    RETURNS:    ERROR_SUCCESS if success
                
********************************************************************/

DWORD GetProtection( PSECURITY_DESCRIPTOR pSD, SECURITY_INFORMATION * pSI )
{

        SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
        DWORD dwRevision;
        //
        ;
        if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
        {
            return GetLastError();
        }
        if ( wSDControl & SE_DACL_PROTECTED )
                *pSI |= PROTECTED_DACL_SECURITY_INFORMATION;
        
      return ERROR_SUCCESS;
}
/*******************************************************************

    NAME:       BuildLdapPath

    SYNOPSIS:   Builds a LDAP path using servername and path
    RETURNS:    ERROR_SUCCESS if success
                
********************************************************************/

DWORD BuildLdapPath( LPWSTR * ppszLdapPath,
                     LPWSTR pszServerName,
                     LPWSTR pszPath )
{

   ULONG uLen = 0;

   if( pszServerName )
      uLen = wcslen( pszServerName ) + wcslen( pszPath );
   else
      uLen = wcslen( pszPath );

   WCHAR szLDAPPrefix[] = L"LDAP://";
   //+1 for '/' after server name.ArraySize includes null char
   uLen += ARRAYSIZE(szLDAPPrefix) + 1;    //LDAP://ServerName/path

   *ppszLdapPath = (LPWSTR)LocalAlloc( LMEM_FIXED, uLen * sizeof(WCHAR) );
   if( NULL == *ppszLdapPath )
      return ERROR_NOT_ENOUGH_MEMORY;


   HRESULT hr = StringCchCopy( * ppszLdapPath, uLen, L"LDAP://" );
   if(FAILED(hr))
   {
       LocalFree(*ppszLdapPath);
       return HRESULT_CODE(hr);
   }
   if( pszServerName )
   {
       hr = StringCchCat( * ppszLdapPath, uLen, pszServerName );
       if(FAILED(hr))
       {
           LocalFree(*ppszLdapPath);
           return HRESULT_CODE(hr);
       }

       hr = StringCchCat(* ppszLdapPath, uLen, L"/");
       if(FAILED(hr))
       {
           LocalFree(*ppszLdapPath);
           return HRESULT_CODE(hr);
       }

   }

   hr = StringCchCat(* ppszLdapPath, uLen, pszPath );
   if(FAILED(hr))
   {
       LocalFree(*ppszLdapPath);
       return HRESULT_CODE(hr);
   }

return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dsacls\utils.h ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name: utils.h
Abstract: This Module implements the utility routines for dsacls
Author: hitesh raigandhi (hiteshr )
Environment:User Mode
Revision History:

--*/
#ifndef _DSACLS_UTIL_H
#define _DSACLS_UTIL_H
#include "accctrl.h"

DWORD GetAccountNameFromSid( LPWSTR pszServerName,
                             PSID pSid, 
                             LPWSTR *pszName );
DWORD GetSidFromAccountName( LPWSTR pszServerName,
                             PSID *ppSid, 
                             LPWSTR  pszName );


DWORD GetGlobalNamingContexts( LPWSTR szObjectPath,
                               LPWSTR * pszSchemaNamingContext ,
                               LPWSTR * pszConfigurationNamingContext );


BOOL FormatStringGUID( LPWSTR lpszBuf, 
                       UINT nBufSize, 
                       const GUID* pGuid);

PSID GetAceSid(PACE_HEADER pAce);



BOOL GuidFromString( GUID* pGuid, 
                     LPCWSTR lpszGuidString);

DWORD GetServerName( IN LPWSTR pszObjectName, 
                     OUT LPWSTR *pszServerName );

DWORD LoadMessage( IN DWORD MessageId,
                   LPWSTR *ppszLoadString,
                   ... );
DWORD BuildLdapPath( LPWSTR * ppszLdapPath,
                     LPWSTR pszServerName,
                     LPWSTR pszPath );


void StringWithNSpace( UINT n, 
                       LPWSTR szSpace );


VOID DisplayString( UINT nIdent, 
                    LPWSTR pszDisplay );


VOID DisplayStringWithNewLine( UINT nIdent, 
                               LPWSTR pszDisplay );
VOID DisplayNewLine();


DWORD DisplayMessageEx( IN DWORD Indent,
                       IN DWORD MessageId,
                       ... );

VOID DisplayMessage( IN DWORD Indent,
                     IN DWORD MessageId,
                     ... );

VOID DisplayErrorMessage( IN DWORD Error );

DWORD ConvertStringAToStringW ( IN  PSTR            AString,
                                OUT PWSTR          *WString );

DWORD CopyUnicodeString( LPWSTR * strDst, 
                         LPWSTR strSrc );
DWORD GetProtection( PSECURITY_DESCRIPTOR pSD, 
                     SECURITY_INFORMATION * pSI );

//AutoBstr taken from burnslib
// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:
        
   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\dssetdc\dssetdc.c ===
/*--

Copyright (c) 1997-1997  Microsoft Corporation

Module Name:

    dssetdc.c

Abstract:

    Command line tool for promoting/demoting servers into and out of the Ds

Author:

    1-Apr-1997   Mac McLain (macm)   Created

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <stdio.h>
#include <stdlib.h>
#include <dsrole.h>
#include <dsrolep.h>

#define TAG_DNS         "dns"
#define TAG_FLAT        "flat"
#define TAG_SITE        "site"
#define TAG_DB          "db"
#define TAG_LOG         "log"
#define TAG_SYSVOL      "sysvol"
#define TAG_PARENT      "parent"
#define TAG_REPLICA     "replica"
#define TAG_USER        "user"
#define TAG_PASSWORD    "password"
#define TAG_SERVER      "server"
#define TAG_OPTIONS     "options"
#define TAG_LEVEL       "level"
#define TAG_ROLE        "role"
#define TAG_LASTDC      "lastdc"
#define TAG_ADMINPWD    "adminpwd"
#define TAG_WAIT        "wait"
#define TAG_FIXDC       "fixdc"

//
// Macro to help command line parsing...
//
#define PARSE_CMD_VALUE_AND_CONTINUE( tag, value, buff, ptr )                   \
if ( !_strnicmp( value, tag, sizeof( tag ) - 1 ) ) {                            \
    value += sizeof(tag) - 1;                                                   \
    if ( *value == ':' ) {                                                      \
        value++;                                                                \
        mbstowcs(buff, value, strlen(value) + 1);                               \
        ptr = buff;                                                             \
        continue;                                                               \
    }                                                                           \
}

VOID
Usage (
    PWSTR DefaultDns,
    PWSTR DefaultFlat,
    PWSTR DefaultSite,
    PWSTR DefaultPath
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    printf("dssetdc -promote <parameters>\n");
    printf("        -info <parameters>\n");
    printf("        -demote <parameters>\n");
    printf("        -save\n");
    printf("        -abort <parameters>\n");
    printf("        -upgrade <parameters>\n");
    printf("        -fixdc <parameters>\n");
    printf("     where:\n");
    printf("        promote parameters are:\n");
    printf("            -%s:dns domain name of the new domain/domain to install as replica "
           "of.  Defaults to %ws\n", TAG_DNS, DefaultDns);
    printf("            -%s:NetBIOS domain name.  Defaults to %ws\n", TAG_FLAT, DefaultFlat);
    printf("            -%s:site name.  Defaults to %ws\n", TAG_SITE, DefaultSite);
    printf("            -%s:db path  Defaults to %ws.\n", TAG_DB, DefaultPath);
    printf("            -%s:log path  Defaults to %ws.\n", TAG_LOG, DefaultPath);
    printf("            -%s:sysvol path.  Defaults to %ws. [Must be NT5 NTFS]\n", TAG_SYSVOL, DefaultPath);
    printf("            [-%s:parent dns domain name if this is a child domain]\n", TAG_PARENT);
    printf("            [-%s:replica partner]\n", TAG_REPLICA);
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("            [-%s:if 1, block until the call has completed\n",TAG_WAIT);
    printf("        info parameters are:\n");
    printf("            -%s:Remote server to obtain the information for\n", TAG_SERVER);
    printf("            -%s:info level\n", TAG_LEVEL);
    printf("                Valid info levels are:\n");
    printf("                    1   -   PrimaryDomainInformation\n");
    printf("                    2   -   Upgrade State information\n");
    printf("        demote parameters are:\n");
    printf("            -%s:server role\n", TAG_ROLE);
    printf("                Valid server roles are:\n");
    printf("                    2   -   Member server\n");
    printf("                    3   -   Standalone server\n");
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("            [-%s:Whether this is the last dc in the domain]\n", TAG_LASTDC);
    printf("                Valid options are:\n");
    printf("                    0   -   Not the last dc in the domain\n");
    printf("                    1   -   Last DC in the domain\n");
    printf("            [-%s:if 1, block until the call has completed\n",TAG_WAIT);
    printf("        -abort parameters are:\n");
    printf("            -%s:new administrator password.  Defaults to NULL\n", TAG_ADMINPWD );
    printf("        -upgrade parameters are:\n");
    printf("            -%s:dns domain name of the new domain.  Defaults to %ws\n", TAG_DNS, DefaultDns);
    printf("            -%s:site name.  Defaults to %ws\n", TAG_SITE, DefaultSite);
    printf("            -%s:db path  Defaults to %ws.\n", TAG_DB, DefaultPath);
    printf("            -%s:log path  Defaults to %ws.\n", TAG_LOG, DefaultPath);
    printf("            -%s:sysvol path.  Defaults to %ws. [Must be NT5 NTFS]\n", TAG_SYSVOL, DefaultPath);
    printf("            [-%s:parent dns domain]\n", TAG_PARENT);
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("        -fixdc parameters are:\n");
    printf("            [-%s:server]Remote server to obtain the information for\n", TAG_SERVER);
    printf("            [-%s:server]Remote server to sync with\n", TAG_REPLICA);
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("                Valid options (in HEX) are:\n");
    printf("                    0x00000001   -   Create the machine account if necessary\n");
    printf("                    0x00000002   -   Sync the machine password\n");
    printf("                    0x00000004   -   Change the account time\n");
    printf("                    0x00000008   -   Re-init the time service\n");
    printf("                    0x00000010   -   Reconfigure the default services\n");
    printf("                    0x00000020   -   Force a DS replication cycle\n");
    printf("                    0x00000040   -   Fixup NTFRS\n");
}


DWORD
GetAndDumpInfo(
    IN PWSTR Server,
    IN ULONG Level
    )
{
    DWORD Win32Error = ERROR_SUCCESS;
    PDSROLE_UPGRADE_STATUS_INFO UpgradeInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC DomainInfo = NULL;
    PBYTE Buffer = NULL;
    PWSTR Roles[ ] = {
        L"DsRole_RoleStandaloneWorkstation",
        L"DsRole_RoleMemberWorkstation",
        L"DsRole_RoleStandaloneServer",
        L"DsRole_RoleMemberServer",
        L"DsRole_RoleBackupDomainController",
        L"DsRole_RolePrimaryDomainController"
        };
    PWSTR ServerRoles[ ] = {
        L"Unknown",
        L"Primary",
        L"Backup"
        };


    Win32Error = DsRoleGetPrimaryDomainInformation( Server,
                                                    Level,
                                                    ( PBYTE * )&Buffer );
    if ( Win32Error == ERROR_SUCCESS ) {

        switch ( Level ) {
        case DsRolePrimaryDomainInfoBasic:

            DomainInfo = ( PDSROLE_PRIMARY_DOMAIN_INFO_BASIC )Buffer;
            printf( "Machine Role: %lu ( %ws )\n", DomainInfo->MachineRole,
                     Roles[ DomainInfo->MachineRole ] );
            printf( "Flags: 0x%lx\n", DomainInfo->Flags );
            printf( "Flat name: %ws\n", DomainInfo->DomainNameFlat );
            printf( "Dns Domain name: %ws\n", DomainInfo->DomainNameDns );
            printf( "Dns Forest name: %ws\n", DomainInfo->DomainForestName );
            break;

        case DsRoleUpgradeStatus:
            UpgradeInfo = ( PDSROLE_UPGRADE_STATUS_INFO )Buffer;

            printf( "Upgrade: %s\n",
                     ( UpgradeInfo->OperationState & DSROLE_UPGRADE_IN_PROGRESS ) ?
                                                                            "TRUE" : "FALSE" );
            printf( "Previous server role: %ws\n", ServerRoles[ UpgradeInfo->PreviousServerState ] );

        }

        DsRoleFreeMemory( DomainInfo );

    } else {

        printf( "DsRoleGetPrimaryDomainInformation failed with %lu\n", Win32Error );
    }


    return( Win32Error );
}




DWORD
BuildDefaults(
    IN PWSTR Dns,
    IN PWSTR Flat,
    IN PWSTR Site,
    IN PWSTR Path
    )
{
    DWORD Win32Error = ERROR_SUCCESS;
    PWSTR Scratch;
    ULONG Options;

    //
    // First, the easy ones
    //
    wcscpy( Site, L"First Site" );

    ExpandEnvironmentStrings( L"%systemroot%\\ntds", Path, MAX_PATH );

    return( Win32Error );
}


DWORD
CopyDsDitFiles(
    IN LPWSTR DsPath
    )
{
    DWORD Win32Error = ERROR_SUCCESS;
    WCHAR Source[MAX_PATH + 1];
    WCHAR Dest[MAX_PATH + 1];
    ULONG SrcLen, DestLen = 0;
    PWSTR DsDitFiles[] = {
        L"ntds.dit",
        L"schema.ini"
        };
    PWSTR CleanupFiles[] = {
        L"edb.chk",
        L"edb.log",
        L"hierarch.dat",
        L"ntds.dit",
        L"res1.log",
        L"res2.log",
        L"schema.ini",
        L"edb00001.log",
        L"edb00002.log",
        L"edb00003.log"
        L"edb00004.log"
        L"edb00005.log"
        L"edb00006.log"
        };
    PWSTR Current;
    ULONG i;



    if( ExpandEnvironmentStrings( L"%WINDIR%\\system32\\", Source, MAX_PATH ) == FALSE ) {

        Win32Error = GetLastError();

    } else {

        SrcLen = wcslen( Source );
        wcscpy( Dest, DsPath );

        if ( *(Dest + (wcslen( DsPath ) - 1 )) != L'\\' ) {

            wcscat( Dest, L"\\" );
        }

        DestLen = wcslen( Dest );

    }


    //
    // See if the source directory exists...
    //
    if ( Win32Error == ERROR_SUCCESS && GetFileAttributes( DsPath ) == 0x10 ) {

        for ( i = 0; i < sizeof( CleanupFiles) / sizeof( PWSTR ); i++ ) {

            wcscpy( Dest + DestLen, CleanupFiles[i] );

            if ( DeleteFile( Dest ) == FALSE ) {

                Win32Error = GetLastError();

                if ( Win32Error == ERROR_FILE_NOT_FOUND ) {

                    Win32Error = ERROR_SUCCESS;

                } else {

                    printf("Failed to remove %ws: %lu\n", Dest, Win32Error );
                    break;
                }
            }
        }

    }

    //
    // Then, create the destination directory
    //
    if ( Win32Error == ERROR_SUCCESS ) {

        Current = wcschr( DsPath + 4, L'\\' );

        while ( Win32Error == ERROR_SUCCESS ) {

            if ( Current != NULL ) {

                *Current = UNICODE_NULL;

            }

            if ( CreateDirectory( DsPath, NULL ) == FALSE ) {

                Win32Error = GetLastError();

                if ( Win32Error == ERROR_ALREADY_EXISTS) {

                    Win32Error = ERROR_SUCCESS;
                }
            }

            if ( Current != NULL ) {

                *Current = L'\\';

                Current = wcschr( Current + 1, L'\\' );

            } else {

                break;

            }

        }
    }

    return( Win32Error );
}


DWORD
Promote( LPWSTR Dns, LPWSTR Flat, LPWSTR Site, LPWSTR Db, LPWSTR Log,
         LPWSTR SysVol, LPWSTR Parent, LPWSTR Replica, LPWSTR User,
         LPWSTR Password, LPWSTR Server, ULONG Options, BOOL Block
         )
{
    DWORD Win32Error = ERROR_SUCCESS;
    DSROLE_SERVEROP_HANDLE Handle;
    PDSROLE_SERVEROP_STATUS Status;
    PDSROLE_SERVEROP_RESULTS Results;

    if ( !Server ) {
        Win32Error = CopyDsDitFiles( Db );

        if ( Win32Error != ERROR_SUCCESS ) {

            return( Win32Error );
        }
    }

    //
    // Now, do the install
    //
    if ( Replica != NULL ) {

        Win32Error = DsRoleDcAsReplica( Server,
                                        Dns,
                                        Replica,
                                        Site,
                                        Db,
                                        Log,
                                        NULL,
                                        SysVol,
                                        NULL,
                                        User,
                                        Password,
                                        NULL,
                                        Options,
                                        &Handle );

    } else {

        Win32Error = DsRoleDcAsDc( Server,
                                   Dns,
                                   Flat,
                                   NULL,
                                   Site,
                                   Db,
                                   Log,
                                   SysVol,
                                   Parent,
                                   NULL,
                                   User,
                                   Password,
                                   NULL,
                                   Options,
                                   &Handle );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        if ( !Block ) {
            do {

                Sleep( 6000 );

                Win32Error = DsRoleGetDcOperationProgress( NULL,
                                                           Handle,
                                                           &Status );

                if ( Win32Error == ERROR_SUCCESS || Win32Error == ERROR_IO_PENDING ) {

                    printf("%ws\n", Status->CurrentOperationDisplayString );
                    DsRoleFreeMemory( Status );
                }


            } while( Win32Error == ERROR_IO_PENDING);

            if ( Win32Error != ERROR_SUCCESS ) {

                printf("Failed determining the operation progress: %lu\n", Win32Error );
            }

        } else {

            printf( "Block on DsRoleGetDcOperationResutls call\n" );
        }

    } else {

        printf( "Failed to install as a Dc: %lu\n", Win32Error );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        Win32Error = DsRoleGetDcOperationResults( NULL,
                                                  Handle,
                                                  &Results );

        if ( Win32Error == ERROR_SUCCESS ) {

            Win32Error = Results->OperationStatus;;
            printf( "OperationResults->OperationStatusDisplayString: %ws\n",
                    Results->OperationStatusDisplayString );

            printf( "OperationResults->ServerInstalledSite: %ws\n",
                    Results->ServerInstalledSite );

            DsRoleFreeMemory( Results );

        } else {

            printf( "Failed to determine the operation results: %lu\n", Win32Error );
        }
    }

    return( Win32Error );
}

DWORD
Demote( LPWSTR User, LPWSTR Password, ULONG Role, ULONG Options, BOOL LastDc )
{
    DWORD Win32Error = ERROR_SUCCESS;
    DSROLE_SERVEROP_HANDLE Handle;
    PDSROLE_SERVEROP_STATUS Status;
    PDSROLE_SERVEROP_RESULTS Results;

    Win32Error = DsRoleDemoteDc( NULL, NULL, Role, User, Password, Options,
                                 LastDc, 0, NULL, NULL, &Handle );

    if ( Win32Error == ERROR_SUCCESS ) {

        do {

            Sleep( 6000 );

            Win32Error = DsRoleGetDcOperationProgress( NULL,
                                                       Handle,
                                                       &Status );

            if ( Win32Error == ERROR_SUCCESS || Win32Error == ERROR_IO_PENDING ) {

                printf("%ws\n", Status->CurrentOperationDisplayString );
                DsRoleFreeMemory( Status );
            }


        } while( Win32Error == ERROR_IO_PENDING);

        if ( Win32Error != ERROR_SUCCESS ) {

            printf("Failed determining the operation progress: %lu\n", Win32Error );
        }

    } else {

        printf( "Failed to demote a Dc: %lu\n", Win32Error );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        Win32Error = DsRoleGetDcOperationResults( NULL,
                                                  Handle,
                                                  &Results );

        if ( Win32Error == ERROR_SUCCESS ) {

            Win32Error = Results->OperationStatus;;
            printf( "OperationResults->OperationStatusDisplayString: %ws\n",
                    Results->OperationStatusDisplayString );

            printf( "OperationResults->ServerInstalledSite: %ws\n",
                    Results->ServerInstalledSite );

            DsRoleFreeMemory( Results );

        } else {

            printf( "Failed to determine the operation results: %lu\n", Win32Error );
        }
    }

    return( Win32Error );
}

DWORD
Save( VOID )
{
    DWORD Win32Error = ERROR_SUCCESS;

    Win32Error = DsRoleServerSaveStateForUpgrade( NULL );

    if ( Win32Error != ERROR_SUCCESS ) {

        printf("DsRoleServerSaveStateForUpgrade failed with %lu\n", Win32Error );
    }

    return( Win32Error );
}

DWORD
Abort(
    PWSTR AdminPwd
    )
{
    DWORD Win32Error = ERROR_SUCCESS;

    Win32Error = DsRoleAbortDownlevelServerUpgrade( AdminPwd, NULL, NULL, 0 );

    if ( Win32Error != ERROR_SUCCESS ) {

        printf("DsRoleAbortDownlevelServerUpgrade failed with %lu\n", Win32Error );
    }


    return( Win32Error );
}

DWORD
Upgrade( LPWSTR Dns, LPWSTR Site, LPWSTR Db, LPWSTR Log, LPWSTR SysVol,
         LPWSTR Parent, LPWSTR User, LPWSTR Password, ULONG Options )
{
    DWORD Win32Error = ERROR_SUCCESS;
    DSROLE_SERVEROP_HANDLE Handle;
    PDSROLE_SERVEROP_STATUS Status;
    PDSROLE_SERVEROP_RESULTS Results;

    Win32Error = DsRoleUpgradeDownlevelServer( ( LPCWSTR )Dns, ( LPCWSTR )Site, ( LPCWSTR )Db,
                                               ( LPCWSTR )Log, ( LPCWSTR )SysVol,
                                               ( LPCWSTR )Parent, NULL, ( LPCWSTR )User,
                                               ( LPCWSTR )Password, NULL, Options, &Handle );

    if ( Win32Error == ERROR_SUCCESS ) {

        do {

            Sleep( 6000 );

            Win32Error = DsRoleGetDcOperationProgress( NULL,
                                                       Handle,
                                                       &Status );

            if ( Win32Error == ERROR_SUCCESS || Win32Error == ERROR_IO_PENDING ) {

                printf("%ws\n", Status->CurrentOperationDisplayString );
                DsRoleFreeMemory( Status );
            }


        } while( Win32Error == ERROR_IO_PENDING);

        if ( Win32Error != ERROR_SUCCESS ) {

            printf("Failed determining the operation progress: %lu\n", Win32Error );
        }

    } else {

        printf( "Failed to install as a Dc: %lu\n", Win32Error );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        Win32Error = DsRoleGetDcOperationResults( NULL,
                                                  Handle,
                                                  &Results );

        if ( Win32Error == ERROR_SUCCESS ) {

            Win32Error = Results->OperationStatus;;
            printf( "OperationResults->OperationStatusDisplayString: %ws\n",
                    Results->OperationStatusDisplayString );

            printf( "OperationResults->ServerInstalledSite: %ws\n",
                    Results->ServerInstalledSite );

            DsRoleFreeMemory( Results );

        } else {

            printf( "Failed to determine the operation results: %lu\n", Win32Error );
        }
    }


    return( Win32Error );
}

INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    DWORD Win32Error = ERROR_SUCCESS, OpErr;
    WCHAR DnsBuff[MAX_PATH + 1], SiteBuff[MAX_PATH + 1];
    WCHAR DbBuff[MAX_PATH + 1], LogBuff[MAX_PATH + 1], ParentBuff[MAX_PATH + 1];
    WCHAR ReplicaBuff[MAX_PATH + 1], UserBuff[MAX_PATH + 1], PasswordBuff[MAX_PATH + 1];
    WCHAR ScratchBuff[MAX_PATH], ServerBuff[MAX_PATH], FlatBuff[MAX_PATH + 1];
    WCHAR SysVolBuff[MAX_PATH + 1], RoleBuff[ 10 ], LastDCBuff[ 10 ], WaitBuff[ 10 ];
    WCHAR AdminPwdBuff[ MAX_PATH + 1 ];
    ULONG Options = 0, Level = 0, Role = 0, FailedOperation, CompletedOperations;
    PWSTR Parent = NULL, Replica = NULL, User = NULL, Password = NULL, Dns = NULL, Flat = NULL;
    PWSTR Site = NULL, Db = NULL, Log = NULL, Scratch = NULL, Server = NULL;
    PWSTR SysVol = NULL, RoleScratch = NULL, LastDCScratch = NULL, AdminPwd = NULL, Wait = NULL;
    INT i = 1;
    BOOL LastDC = FALSE, BuildDefaultsFailed = FALSE, Block = FALSE;
    PSTR Current;

    Win32Error = BuildDefaults( DnsBuff, FlatBuff, SiteBuff, DbBuff );

    if ( Win32Error == ERROR_SUCCESS ) {

        Dns = DnsBuff;
        Site = SiteBuff;
        Db = DbBuff;
        Log = DbBuff;
        Flat = FlatBuff;

    } else {

        BuildDefaultsFailed = TRUE;

    }


    if (argc > 1 && (_stricmp( argv[1], "-?") == 0 || _stricmp( argv[1], "/?") == 0 ) ) {

        if ( BuildDefaultsFailed ) {

            printf( "Failed to get the defaults: %lu\n", Win32Error );
        }
        Usage( Dns, Flat, Site, Db );
        goto Done;


    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-info" ) == 0 || _stricmp( argv[ 1 ], "/info" ) == 0 ) ) {

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SERVER, Current, ServerBuff, Server );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LEVEL, Current, ScratchBuff, Scratch );
        }

        if ( Win32Error == ERROR_SUCCESS && Scratch ) {

            Level = wcstol( Scratch, &Scratch, 10 );
        }

        Win32Error = GetAndDumpInfo( Server, Level );
        goto Done;

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-promote" ) == 0 || _stricmp( argv[ 1 ], "/promote" ) == 0) ) {

        if ( BuildDefaultsFailed ) {

            printf( "Failed to get the defaults: %lu\n", Win32Error );
            goto Done;

        }

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DNS, Current, DnsBuff, Dns );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_FLAT, Current, FlatBuff, Flat );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SITE, Current, SiteBuff, Site );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DB, Current, DbBuff, Db );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LOG, Current, LogBuff, Log );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SYSVOL, Current, SysVolBuff, SysVol );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PARENT, Current, ParentBuff, Parent );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_REPLICA, Current, ReplicaBuff, Replica );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_USER, Current, UserBuff, User );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PASSWORD, Current, PasswordBuff, Password );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SERVER, Current, ServerBuff, Server );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_OPTIONS, Current, ScratchBuff, Scratch );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_WAIT, Current, WaitBuff, Wait );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }

        if ( Scratch != NULL ) {

            Options = wcstoul( Scratch, &Scratch, 0 );
        }

        //
        // Validate the parameters
        //
        if ( Dns == NULL || Db == NULL || Log == NULL || Flat == NULL ) {

            Win32Error = ERROR_INVALID_PARAMETER;
        }

        if( Win32Error == ERROR_INVALID_PARAMETER ) {

            Usage( Dns, Flat, Site, Db );
            goto Done;
        }

        if ( Wait && wcscmp( Wait, L"1" ) ) {

            Block = TRUE;
        }

        Win32Error = Promote( Dns, Flat, Site, Db, Log, SysVol, Parent,
                              Replica, User, Password, Server, Options, Block );
    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-demote" ) == 0 || _stricmp( argv[ 1 ], "/demote" ) == 0 ) ) {

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_USER, Current, UserBuff, User );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PASSWORD, Current, PasswordBuff, Password );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_ROLE, Current, RoleBuff, RoleScratch );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_OPTIONS, Current, ScratchBuff, Scratch );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LASTDC, Current, LastDCBuff, LastDCScratch );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }

        if ( Scratch != NULL ) {

            Options = wcstoul( Scratch, &Scratch, 0 );
        }

        if ( RoleScratch == NULL ) {

            Win32Error = ERROR_INVALID_PARAMETER;

        } else {

            Role = wcstoul( RoleScratch, &RoleScratch, 0);
        }

        if ( LastDCScratch != NULL ) {

            LastDC = ( BOOL )wcstoul( LastDCScratch, &LastDCScratch, 0);
        }

        if( Win32Error == ERROR_INVALID_PARAMETER ) {

            Usage( Dns, Flat, Site, Db );
            goto Done;
        }

        Win32Error = Demote( User, Password, Role, Options, LastDC );

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-save" ) == 0 || _stricmp( argv[ 1 ], "/save" ) == 0 ) ) {

        Win32Error = Save();

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-abort" ) == 0 || _stricmp( argv[ 1 ], "/abort" ) == 0 ) ) {

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_ADMINPWD, Current, AdminPwdBuff, AdminPwd );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }


        Win32Error = Abort( AdminPwd );

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-upgrade" ) == 0 || _stricmp( argv[ 1 ], "/upgrade" ) == 0) ) {

        if ( BuildDefaultsFailed ) {

            printf( "Failed to get the defaults: %lu\n", Win32Error );
            goto Done;

        }

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DNS, Current, DnsBuff, Dns );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SITE, Current, SiteBuff, Site );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DB, Current, DbBuff, Db );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LOG, Current, LogBuff, Log );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SYSVOL, Current, SysVolBuff, SysVol );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PARENT, Current, ParentBuff, Parent );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_USER, Current, UserBuff, User );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PASSWORD, Current, PasswordBuff, Password );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_OPTIONS, Current, ScratchBuff, Scratch );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }

        if ( Scratch != NULL ) {

            Options = wcstoul( Scratch, &Scratch, 0 );
        }

        //
        // Validate the parameters
        //
        if ( Dns == NULL || Db == NULL || Log == NULL ) {

            Win32Error = ERROR_INVALID_PARAMETER;
        }

        if( Win32Error == ERROR_INVALID_PARAMETER ) {

            Usage( Dns, Flat, Site, Db );
            goto Done;
        }

        Win32Error = Upgrade( Dns, Site, Db, Log, SysVol, Parent, User,
                              Password, Options );
    }


Done:
    if( Win32Error == ERROR_SUCCESS ) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error %lu\n", Win32Error );

    }

    return( Win32Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\joindom\joindom.c ===
/*++

Copyright (c) 1997 - 1997  Microsoft Corporation

Module Name:

    joindom.c

Abstract:

    Unit test for NetJoinDomain and NetUnjoinDomain APIs

Author:

    Mac McLain   (MacM)     19-Feb-1997

Environment:

    User mode only.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <lmapibuf.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define JOIN_TAG    "join"
#define UNJOIN_TAG  "unjoin"
#define NAME_TAG    "name"
#define RENAME_TAG  "rename"
#define INFO_TAG    "info"
#define OU_TAG      "ous"
#define ADD_ALT_NAME "addaltname"
#define DEL_ALT_NAME "delaltname"
#define SET_PRI_NAME "setpriname"
#define GET_PRI_NAME "getpriname"
#define GET_ALT_NAMES "getaltnames"
#define GET_ALL_NAMES "getallnames"

NET_API_STATUS
NET_API_FUNCTION
NetpGetListOfJoinableOUs(
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN LPWSTR Password,
    OUT PULONG Count,
    OUT PWSTR **OUs
    );

void
Usage(
    VOID
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

    None

Return Value:

    VOID

--*/
{
    printf("joindom -operation options domain/server [account] [password] [new/alt name] [OU]\n");
    printf("   where:\n");
    printf("        operation indicates what joindom should do:\n");
    printf("            -%s  Joins a workstation to a domain/workgroup\n", JOIN_TAG);
    printf("            -%s  Unjoins a workstation from a domain\n", UNJOIN_TAG);
    printf("            -%s  Renames the machine to a new name\n", RENAME_TAG);
    printf("            -%s  Validates the give name for validity\n", NAME_TAG);
    printf("            -%s  Returns information about the state of the join\n", INFO_TAG );
    printf("            -%s  Returns information about the joinable ous\n", OU_TAG );
    printf("            -%s  Add alternative computer name\n", ADD_ALT_NAME );
    printf("            -%s  Delete alternative computer name\n", DEL_ALT_NAME );
    printf("            -%s  Set primary computer name\n", SET_PRI_NAME );
    printf("            -%s  Get primary computer name\n", GET_PRI_NAME );
    printf("            -%s  Get altername computer names\n", GET_ALT_NAMES );
    printf("            -%s  Get all computer names\n", GET_ALL_NAMES );
    printf("        options specifies the flags for the command\n");
    printf("                0x000000001     Joins a domain instead of workgroup\n");
    printf("                0x000000002     Creates the account on the domain\n");
    printf("                0x000000004     Deletes the account when leaving a domain\n");
    printf("        domain/server specifies the domain (or server for alt name APIs) path to operate on\n" );
    printf("        [account] is the name of the account to use for accessing domain objects\n");
    printf("        [password] is the password of the account to use while "
           "accessing domain objects\n");
    printf("        [newname] is the new computer name \n");
    printf("        [OU] is the name of the ou to create the machine account in\n");
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    See main comment.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    WCHAR           wszDomain[MAX_PATH + 1];
    WCHAR           rgwszOpts[3][MAX_PATH + 1];
    PWSTR           ppwszOpts[3] = { NULL, NULL, NULL };
    PWSTR           ppwszJoinTypes[ ] = { L"NetSetupUnknownStatus",
                                          L"NetSetupUnjoined",
                                          L"NetSetupWorkgroupName",
                                          L"NetSetupDomainName" };
    WCHAR           wszMachine[MAX_COMPUTERNAME_LENGTH + 1];
    PWSTR           pwszJoinInfo;
    WCHAR           wszInfo[256];
    ULONG           i, Options = 0, cLen, Count;
    PWSTR           *OUs;
    PSTR            pszNext;
    NETSETUP_JOIN_STATUS JoinType;

    BOOLEAN EnumerateComputerName = FALSE;
    NET_COMPUTER_NAME_TYPE ComputerNameType;
    LPSTR ComputerNameTypeString = NULL;
    BOOLEAN PrintUsage = FALSE;


    if (argc < 4) {

        PrintUsage = TRUE;
        goto Cleanup;

    } else {

        cLen  = MAX_COMPUTERNAME_LENGTH + 1;
        if ( GetComputerNameW( wszMachine, &cLen ) == FALSE ) {

            NetStatus = GetLastError();
            printf("Failed to get the local computer name: %lu\n", NetStatus );
        }

    }

    if ( NetStatus == NERR_Success) {

        //
        // Process the command line
        //
        Options = strtoul( argv[2], &pszNext, 0 );
        mbstowcs( wszDomain, argv[3], strlen(argv[3]) + 1 );

        for ( i = 4 ; i < (ULONG)argc && i < 7 ; i++ ) {

            mbstowcs(rgwszOpts[i - 4], argv[i], strlen( argv[i] ) + 1 );
            ppwszOpts[i - 4] = rgwszOpts[i - 4];
        }

    }

    //
    // Now, do the operations
    //
    if ( NetStatus == NERR_Success && (*argv[1] == '/' || *argv[1] == '-' ) ) {

        if ( _stricmp( argv[1] + 1, JOIN_TAG ) == 0 ) {

            //
            // Do the call
            //
            NetStatus = NetJoinDomain( wszMachine, wszDomain, ppwszOpts[2],
                                       ppwszOpts[0], ppwszOpts[1],
                                       Options );

            if ( NetStatus != NERR_Success ) {

                printf( "NetJoinDomain [%ws] [%ws] [%ws] [0x%lx] failed with %lu\n",
                        wszDomain,
                        ppwszOpts[0] == NULL ? L"NULL" : ppwszOpts[0],
                        ppwszOpts[1] == NULL ? L"NULL" : ppwszOpts[1],
                        Options,
                        NetStatus );
            }


        } else if ( _stricmp( argv[1] + 1, UNJOIN_TAG ) == 0 ) {

            NetStatus = NetUnjoinDomain( NULL, ppwszOpts[0], ppwszOpts[1], Options );

            if ( NetStatus != NERR_Success ) {

                printf( "NetUnjoinDomain [%ws] [%ws] [0x%lx] failed with %lu\n",
                        ppwszOpts[0] == NULL ? L"NULL" : ppwszOpts[0],
                        ppwszOpts[1] == NULL ? L"NULL" : ppwszOpts[1],
                        Options,
                        NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, RENAME_TAG ) == 0 ) {

            //
            // First, set the computer name
            //
            if ( ppwszOpts[2] == NULL ) {

                PrintUsage = TRUE;
                goto Cleanup;

            } else {

                if( SetComputerName( ppwszOpts[2] ) == FALSE ) {

                    NetStatus = GetLastError();

                } else {

                    NetStatus = NetRenameMachineInDomain( NULL, ppwszOpts[ 2 ],
                                                          ppwszOpts[0], ppwszOpts[1],
                                                          Options );
                    if ( NetStatus != NERR_Success ) {

                        printf( "NetRenameMachineInDomain [%ws] [%ws] [%ws] [%ws] [0x%lx] failed with %lu\n",
                                ppwszOpts[2],
                                wszDomain,
                                ppwszOpts[0] == NULL ? L"NULL" : ppwszOpts[0],
                                ppwszOpts[1] == NULL ? L"NULL" : ppwszOpts[1],
                                Options,
                                NetStatus );

                    }

                }

            }

        } else if ( _stricmp( argv[1] + 1, NAME_TAG ) == 0 ) {

            //
            // Validate name as all four types
            //
            if ( NetStatus == NERR_Success ) {

                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupMachine );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as machine name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as machine name: %lu\n",
                            wszDomain, NetStatus );

                }

                //
                // workgroup name
                //
                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupWorkgroup );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as workgroup name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as workgroup name: %lu\n",
                            wszDomain, NetStatus );

                }

                //
                // Domain name
                //

                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupDomain );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as domain name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as domain name: %lu\n",
                            wszDomain, NetStatus );

                }

                //
                // Domain name
                //

                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupNonExistentDomain );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as non existent domain name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as nonexistent domain name: %lu\n",
                            wszDomain, NetStatus );

                }
            }


        } else if ( _stricmp( argv[1] + 1, INFO_TAG ) == 0 ) {

            //
            // Call it 3 times, 1: NULL buffer, 2: valid ptr, 3: remotely
            //
#if 0
            NetStatus = NetGetJoinInformation( NULL, NULL, &JoinType );

            if ( NetStatus == ERROR_INVALID_PARAMETER ) {

                NetStatus = NERR_Success;
                printf( "JoinInfo with NULL buffer returned correctly\n" );

            } else {

                printf( "JoinInfo with NULL buffer incorrectly returned %lu\n", NetStatus );
                NetStatus = ERROR_INVALID_DATA;
            }
#endif

            NetStatus = NetGetJoinInformation( NULL, &pwszJoinInfo, &JoinType );
            if ( NetStatus == NERR_Success ) {

                printf( "Join type: %ws\n", ppwszJoinTypes[ JoinType ] );
                printf( "Joined to %ws\n", pwszJoinInfo );
                NetApiBufferFree( pwszJoinInfo );

            } else {

                printf(" NetGetJoinInformation,  failed with %lu\n", NetStatus );

            }

#if 0
            NetStatus = NetGetJoinInformation( wszMachine, &pwszJoinInfo, &JoinType );
            if ( NetStatus == NERR_Success ) {

                printf( "Joined to %ws\n", pwszJoinInfo );
                NetApiBufferFree( pwszJoinInfo );

            } else {

                printf(" NetGetJoinInformation, remotely, failed with %lu\n", NetStatus );

            }
#endif

        } else if ( _stricmp( argv[1] + 1, OU_TAG ) == 0 ) {

            NetStatus =  NetGetJoinableOUs( NULL, ( LPCWSTR )wszDomain, ( LPCWSTR )ppwszOpts[0],
                                            ( LPCWSTR )ppwszOpts[1], &Count, &OUs );

            if ( NetStatus != NERR_Success ) {

                printf( "NetGetJoinableOUs returned %lu\n", NetStatus );

            } else {

                printf( "NetGetJoinableOUs returned %lu ous\n", Count );
                for ( i = 0; i < Count; i++ ) {

                    printf("  %ws\n", OUs[ i ] );
                }

                NetApiBufferFree( OUs );
            }

        } else if ( _stricmp( argv[1] + 1, ADD_ALT_NAME ) == 0 ) {

            printf( "\nAdding alternate computer name with following parameters:\n" );
            printf( "   Server:         %ws\n", wszDomain );
            printf( "   Alternate name: %ws\n", ppwszOpts[2] );
            printf( "   Options:        0x%lx\n", Options );
            printf( "   Account:        %ws\n", ppwszOpts[0] );
            printf( "   Password:       %ws\n\n", ppwszOpts[1] );

            NetStatus = NetAddAlternateComputerName(
                                wszDomain,     // treated as server name
                                ppwszOpts[2],  // alternate name
                                ppwszOpts[0],  // domain account
                                ppwszOpts[1],  // domain account pwd
                                Options );

            if ( NetStatus != NERR_Success ) {
                printf( "NetAddAlternateComputerName failed: 0x%lx\n", NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, DEL_ALT_NAME ) == 0 ) {

            printf( "\nDeleting alternate computer name with following parameters:\n" );
            printf( "   Server:         %ws\n", wszDomain );
            printf( "   Alternate name: %ws\n", ppwszOpts[2] );
            printf( "   Options:        0x%lx\n", Options );
            printf( "   Account:        %ws\n", ppwszOpts[0] );
            printf( "   Password:       %ws\n\n", ppwszOpts[1] );

            NetStatus = NetRemoveAlternateComputerName(
                                wszDomain,     // treated as server name
                                ppwszOpts[2],  // alternate name
                                ppwszOpts[0],  // domain account
                                ppwszOpts[1],  // domain account pwd
                                Options );

            if ( NetStatus != NERR_Success ) {
                printf( "NetRemoveAlternateComputerName failed: 0x%lx\n", NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, SET_PRI_NAME ) == 0 ) {

            printf( "\nSetting primary computer name with following parameters:\n" );
            printf( "   Server:       %ws\n", wszDomain );
            printf( "   Primary name: %ws\n", ppwszOpts[2] );
            printf( "   Options:      0x%lx\n", Options );
            printf( "   Account:      %ws\n", ppwszOpts[0] );
            printf( "   Password:     %ws\n\n", ppwszOpts[1] );

            NetStatus = NetSetPrimaryComputerName(
                                wszDomain,     // treated as server name
                                ppwszOpts[2],  // alternate name
                                ppwszOpts[0],  // domain account
                                ppwszOpts[1],  // domain account pwd
                                Options );

            if ( NetStatus != NERR_Success ) {
                printf( "NetSetPrimaryComputerName failed: 0x%lx\n", NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, GET_PRI_NAME ) == 0 ) {
            EnumerateComputerName = TRUE;
            ComputerNameType = NetPrimaryComputerName;
            ComputerNameTypeString = "primary";

        } else if ( _stricmp( argv[1] + 1, GET_ALT_NAMES ) == 0 ) {
            EnumerateComputerName = TRUE;
            ComputerNameType = NetAlternateComputerNames;
            ComputerNameTypeString = "alternate";

        } else if ( _stricmp( argv[1] + 1, GET_ALL_NAMES ) == 0 ) {
            EnumerateComputerName = TRUE;
            ComputerNameType = NetAllComputerNames;
            ComputerNameTypeString = "all";

        } else {

            PrintUsage = TRUE;
            goto Cleanup;
        }

    } else {

        PrintUsage = TRUE;
        goto Cleanup;
    }

    if ( EnumerateComputerName ) {
        ULONG EntryCount = 0;
        LPWSTR *ComputerNames = NULL;

        printf( "\nGetting %s computer name(s) for server %ws with options 0x%lx:\n",
                ComputerNameTypeString,
                wszDomain,  // treated as server name
                Options );

        NetStatus = NetEnumerateComputerNames(
                        wszDomain,        // treated as server name
                        ComputerNameType, // name type
                        Options,
                        &EntryCount,
                        &ComputerNames );

        if ( NetStatus != NERR_Success ) {
            printf( "NetEnumerateComputerNames failed: 0x%lx\n", NetStatus );
        } else {
            ULONG i;

            if ( EntryCount > 0 ) {
                for ( i = 0; i < EntryCount; i++ ) {
                    printf( "%ws\n", ComputerNames[i] );

                }
            } else {
                printf( "No names returned.\n" );
            }
            NetApiBufferFree( ComputerNames );
        }
    }

Cleanup:

    if ( PrintUsage ) {
        Usage();
    }

    if ( NetStatus == NERR_Success ) {

        printf( "The command completed successfully\n" );

    } else {

        printf( "The command failed with error %lu\n", NetStatus );
    }


    return( NetStatus == NERR_Success );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\expired\expired.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        expired.cxx
//
// Contents:    Program to test if a NT account is about to expire.
//
//
// History:     10-Nov-94   Created         MikeSw
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <lmaccess.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
}


VOID
DoMsvStuff(
    PWSTR Domain
    )
{
    HKEY hKey ;
    DWORD dwType, dwSize ;
    int err ;
    WCHAR DomainBuffer[ 64 ];

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0" ),
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey );

    if ( err == 0 )
    {
        dwSize = sizeof( DomainBuffer );

        err = RegQueryValueEx( hKey,
                               TEXT("PreferredDomain"),
                               NULL,
                               &dwType,
                               (PBYTE) DomainBuffer,
                               &dwSize );

        if ( err == 0 )
        {
            //
            // Already set, we're done.
            //

            RegCloseKey( hKey );

            return ;
        }

        dwSize = wcslen( Domain ) * sizeof( WCHAR ) + 2;

        err = RegSetValueEx( hKey,
                             TEXT("PreferredDomain"),
                             NULL,
                             REG_SZ,
                             (PBYTE) Domain,
                             dwSize );

        err = RegSetValueEx( hKey,
                             TEXT("MappedDomain"),
                             NULL,
                             REG_SZ,
                             (PBYTE) TEXT("NTDEV"),
                             sizeof( TEXT("NTDEV") ) );

        RegCloseKey( hKey );

        return ;

    }

    if ( err == ERROR_ACCESS_DENIED )
    {
        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0" ),
                            0,
                            KEY_READ,
                            &hKey );

        if ( err == 0 )
        {
            err = RegQueryValueEx( hKey,
                                   TEXT("PreferredDomain"),
                                   NULL,
                                   &dwType,
                                   (PBYTE) DomainBuffer,
                                   &dwSize );

            if ( err == 0 )
            {
                //
                // Already set, we're done.
                //

                RegCloseKey( hKey );

                return ;
            }

            OutputDebugStringW( TEXT("[SECURITY] Unable to set IDW Domain Mapping") );

            RegCloseKey( hKey );

            return ;
        }
    }
}

void _cdecl
main(int argc, char *argv[])
{
    WCHAR DomainName[100];
    WCHAR UserBuffer[100];
    WCHAR TestDCName[100];
    LPWSTR UserName = NULL;
    LPWSTR DCName = NULL;
    NTSTATUS Status;
    ULONG BufSize = 100;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING UnicodeName;
    SAM_HANDLE SamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    PULONG RelativeIds = NULL;
    PSID_NAME_USE Use = NULL;
    PUSER_LOGON_INFORMATION LogonInfo = NULL;
    LARGE_INTEGER CurrentTime;
    ULONG CurrentSeconds;
    ULONG ExpireSeconds;
    ULONG DiffSeconds;
    ULONG ExpiryDays;
    WCHAR TextBuffer[100];

    if (argc != 2)
    {
        printf("Usage: %s domainname\n",argv[0]);
        return;
    }
    mbstowcs(DomainName,argv[1],100);

    DoMsvStuff( DomainName );

    if (!GetUserName(UserBuffer,&BufSize))
    {
        printf("Failed to get user name: %d\n",GetLastError());
        return;

    }
    UserName = wcsrchr(UserBuffer,L'\\');
    if (UserName != NULL)
    {
        UserName++;
    }
    else UserName = UserBuffer;
//    printf("Checking account %ws\\%ws\n",DomainName,UserName);

    Status = NetGetDCName(
                    NULL,
                    DomainName,
                    (PBYTE *) &DCName
                    );
    if (Status != 0)
    {
        printf("Failed to find a DC: %d\n",Status);
        return;
    }

    //
    // Connect to the LSA on the DC
    //

    RtlInitUnicodeString(&UnicodeName,DCName);

//    printf("Connecting to DC %wZ\n",&UnicodeName);

    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    Status = LsaOpenPolicy(
                &UnicodeName,
                &oa,
                POLICY_VIEW_LOCAL_INFORMATION,
                &LsaHandle
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to open lsa: 0x%x\n",Status);
        goto Cleanup;
    }

    Status = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyAccountDomainInformation,
                (PVOID *) &DomainInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query information policy: 0x%x\n",Status);
        goto Cleanup;
    }

//    printf("Found account domain %wZ\n",&DomainInfo->DomainName);


    Status = SamConnect(
                &UnicodeName,
                &SamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &oa);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to connect to sam: 0x%x\n",Status);
        goto Cleanup;
    }

    Status = SamOpenDomain(
                SamHandle,
                DOMAIN_LOOKUP,
                DomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to open domain: 0x%x\n",Status);
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &UnicodeName,
        UserName
        );

    Status = SamLookupNamesInDomain(
                DomainHandle,
                1,
                &UnicodeName,
                &RelativeIds,
                &Use
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup names in domain: 0x%x\n",Status);
        goto Cleanup;
    }
    if (Use[0] != SidTypeUser)
    {
        printf("Sid type for user %wZ is not user, is %d\n",&UnicodeName,Use[0]);
        goto Cleanup;
    }

    Status = SamOpenUser(
                DomainHandle,
                USER_READ_GENERAL | USER_READ_LOGON | USER_READ_ACCOUNT | USER_READ_PREFERENCES,
                RelativeIds[0],
                &UserHandle
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to open user: 0x%x\n",Status);
        goto Cleanup;
    }

    Status = SamQueryInformationUser(
                UserHandle,
                UserLogonInformation,
                (PVOID *) &LogonInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query logon information: 0x%x\n",Status);
        goto Cleanup;
    }

    //
    // We got the PasswordMustChange field.  Now do something with it.
    //

    Status = NtQuerySystemTime( &CurrentTime );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query system time: 0x%x\n",Status);
        goto Cleanup;
    }

    if (!RtlTimeToSecondsSince1980(&CurrentTime,&CurrentSeconds))
    {
        printf("Cannot convert current time to seconds since 1980\n");
        goto Cleanup;
    }
    if (!RtlTimeToSecondsSince1980(&LogonInfo->PasswordMustChange,&ExpireSeconds))
    {
        printf("No password expiry date\n");
        goto Cleanup;
    }
    if (ExpireSeconds < CurrentSeconds)
    {
        DiffSeconds = 0;
        printf("Password has expired\n");
    }
    else
    {

#define SECONDS_PER_DAY (60 * 60 * 24)
        DiffSeconds = ExpireSeconds - CurrentSeconds;
        ExpiryDays = DiffSeconds/SECONDS_PER_DAY;
        wsprintf(TextBuffer,L"Password will expire in %d days\n",ExpiryDays);
        if (ExpiryDays <= 14)
        {
            MessageBox(NULL,TextBuffer,L"Password Will Expire",MB_OK );
        }
        else
        {
            printf("%ws",TextBuffer);
        }
    };




Cleanup:
    if (LsaHandle != NULL)
    {
        LsaClose(LsaHandle);
    }
    if (UserHandle != NULL)
    {
        SamCloseHandle(UserHandle);
    }
    if (DomainHandle != NULL)
    {
        SamCloseHandle(DomainHandle);
    }
    if (SamHandle != NULL)
    {
        SamCloseHandle(SamHandle);
    }
    if (DomainInfo != NULL)
    {
        LsaFreeMemory(DomainInfo);
    }
    if (RelativeIds != NULL)
    {
        SamFreeMemory(RelativeIds);
    }
    if (Use != NULL)
    {
        SamFreeMemory(Use);
    }
    if (LogonInfo != NULL)
    {
        SamFreeMemory(LogonInfo);
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbconf\kerbconf.c ===
/*
 * Registry keys for compat:
 *	HKLM\System\CurrentControlSet\Control\Lsa\Kerberos\Domains
 *	Keys:
 *		<Realm>
 *		Values:
 *			REG_MULTI_SZ KdcNames
 *				Names of KDCs for realm
 *			REG_MULTI_SZ KpasswdNames
 *				Names of Kpasswd servers for realm
 *			REG_MULTI_SZ AlternateDomainNames
 *				Other names for realm (aliases)
 *			REG_DWORD RealmFlags
 *				Send address = 1
 *				TCP Supported = 2
 *				Delegate ok = 4
 *			REG_DWORD ApReqChecksumType
 *				Default AP-REQ checksum type for this realm
 *			REG_DWORD PreAuthType
 *				Default preauth type for this realm
 *
 *	HKLM\System\CurrentControlSet\Control\Lsa\Kerberos\UserList
 *	Each value represents a Kerberos principal to be mapped to
 *	a local user.
 *	Values:
 *		<principal name> :  <local user>
 *			Specific principal to this local user
 *		<domain name> :  <local user>
 *			All users in this domain to this local user
 *		'*' : <local user>
 *			All users to this local user
 *		'*' : '*'
 *			All users to a corresponding local user by name
 *
 *	HKLM\System\CurrentControlSet\Control\Lsa\Kerberos
 *	Values:
 *		REG_DWORD SkewTime (5 min)
 *			Clock skew time
 *		REG_DWORD MaxPacketSize (4000)
 *			KerbGlobalMaxDatagramSize
 *		REG_DWORD StartupTime (120 sec)
 *		REG_DWORD KdcWaitTime (5 sec)
 *		REG_DWORD KdcBackoffTime (5 sec)
 *		REG_DWORD KdcSendRetries (3)
 *		REG_DWORD UseSidCache (False)
 *		REG_DWORD LogLevel (o)
 *			KerbGlobalLoggingLevel
 *		REG_DWORD DefaultEncryptionType (RC4_HMAC)
 *			KerbGlobalDefaultPreauthEtype - Use this etype
 *				for preauth data
 *		REG_DWORD FarKdcTimeout (10 min)
 *		REG_DWORD StronglyEncryptDatagram (False)
 *			KerbGlobalUseStrongEncryptionForDatagram
 *		REG_DWORD MaxReferralCount (6)
 *		REG_DWORD SupportNewPkinit (True)
 */
//#define UNICODE
//#define _UNICODE
#define STRICT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#define ERR_NDI_LOW_MEM ERROR_NOT_ENOUGH_MEMORY
#define OK ERROR_SUCCESS
#include <commctrl.h>
//#include <winnetwk.h>
#include <stdarg.h>
#define SECURITY_WIN32
#include <security.h>
//#include <ntsecapi.h>
#include <wincrypt.h>
#include <kerbcon.h>
#include <kerbcomm.h>
#include <secpkg.h>
#include <kerbdefs.h>
#include <mitutil.h>

#include "kerbconf.h"
#include "kerbconfres.h"

HINSTANCE hInstance;
krb5_rgy_t *rgy;
LPTSTR default_domain;

INT_PTR CALLBACK Krb5NdiRealmsProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AddRealmProc(HWND, UINT, WPARAM, LPARAM);

#define Message(s) \
	MessageBox(NULL, s, TEXT("Error"), MB_OK)

#ifdef DBG
#define DPRINTF(s) dprintf s

int debug = 0;

void dprintf(const TCHAR *fmt, ...)
{
    static TCHAR szTemp[512];
    va_list ap;
    
    va_start (ap, fmt);
    wvsprintf(szTemp, fmt, ap);
    OutputDebugString(szTemp);
    if (debug)
	MessageBox(NULL, szTemp, TEXT("Debug"), MB_OK);
    va_end (ap);
}
#else
#define DPRINTF(s)
#endif

#define PFREE(p) \
    if ((p)) { \
	free((p)); \
       (p) = NULL; \
    }
    

void
FreeRealm(krb5_realm_t *rp)
{
    name_list_t *np, *cp;
    
    np = rp->kdc.lh_first; 
    while(np) {
	cp = np;
	np = np->list.le_next;
	if (cp->name)
	    free(cp->name);
	free(cp);
    }
    np = rp->kpasswd.lh_first; 
    while(np) {
	cp = np;
	np = np->list.le_next;
	if (cp->name)
	    free(cp->name);
	free(cp);
    }
    np = rp->altname.lh_first; 
    while(np) {
	cp = np;
	np = np->list.le_next;
	if (cp->name)
	    free(cp->name);
	free(cp);
    }
    free(rp);
}

void
FreeRgy(krb5_rgy_t *rgy)
{
    krb5_realm_t *rp, *crp;
    
    if (rgy) {
	rp = rgy->realms.lh_first;
	while(rp) {
	    crp = rp;
	    rp = rp->list.le_next;	
	    FreeRealm(crp);
	}
	free(rgy);
    }
}

DWORD
RegGetInt(const HKEY hKey, LPCTSTR value)
{
    DWORD retCode;
    DWORD dwType;
    DWORD dataLen;
    DWORD keyData;
    
    dataLen = sizeof(keyData);
    retCode = RegQueryValueEx(hKey, value, 0,
				&dwType, (LPBYTE)&keyData, &dataLen);
    if (retCode == ERROR_SUCCESS &&
	dwType == REG_DWORD) {
	return(keyData);
    }
    return((DWORD)-1);
}

DWORD
RegSetInt(LPCTSTR key, const DWORD val)
{
    HKEY hKey;
    DWORD retCode = (DWORD)-1;

    retCode = RegCreateKey(HKEY_LOCAL_MACHINE,
			     REGKEY,
			     &hKey);
    if (retCode == ERROR_SUCCESS) {
	retCode = RegSetValueEx(hKey, key, 0,
				REG_DWORD, (LPBYTE)&val, sizeof(val));
	if (retCode == ERROR_SUCCESS) {
	    RegCloseKey(hKey);
	    return(0);
	}
    }

    RegCloseKey(hKey);
    return(retCode);
}

LPTSTR
RegGetStr(const HKEY hKey, LPCTSTR value)
{
    DWORD retCode;
    DWORD dwType;
    DWORD dataLen;
    LPBYTE keyData = NULL;

    dataLen = 0;
    retCode = RegQueryValueEx(hKey, value, 0,
				&dwType, (LPBYTE)NULL, &dataLen);
    if (retCode == ERROR_SUCCESS) {
	keyData = malloc(dataLen);
	if (!keyData)
	    return(NULL);
	
	retCode = RegQueryValueEx(hKey, value, 0,
				    &dwType, keyData, &dataLen);
	if (retCode == ERROR_SUCCESS) {
	    return((LPTSTR)keyData);
	}
    }
    if (keyData)
	free(keyData);
    return(NULL);
}

DWORD
RegSetStr(LPCTSTR key, LPCTSTR val, INT len)
{
    HKEY hKey;
    DWORD retCode = (DWORD)-1;

    if (len == 0)
	len = lstrlen(val) + 1;
    retCode = RegCreateKey(HKEY_LOCAL_MACHINE,
			     REGKEY,
			     &hKey);
    if (retCode == ERROR_SUCCESS) {
	retCode = RegSetValueEx(hKey, key, 0,
				((lstrlen(val)+1) != len)?
				REG_MULTI_SZ:REG_SZ,
				  (LPBYTE)val, len);
	if (retCode == ERROR_SUCCESS) {
	    RegCloseKey(hKey);
	    return(0);
	}
    }

    RegCloseKey(hKey);
    return(retCode);
}

DWORD
RegDelete(LPCTSTR key)
{
    HKEY hKey;
    DWORD retCode;

    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
			   REGKEY,
			   &hKey);
    if (retCode == ERROR_SUCCESS)
	retCode = RegDeleteValue(hKey, key);

    RegCloseKey(hKey);
    return(retCode);
}

LPTSTR
lstrdup(LPCTSTR s)
{
    LPTSTR sp;

    sp = malloc(lstrlen(s)*sizeof(TCHAR));
    if (sp) {
	lstrcpy(sp, s);
    }
    return sp;
}


// Read in krb5 conf properties and attach to ndi object
UINT
Krb5NdiCreate(void)
{
    LPTSTR pStr, key;
    HKEY hKey, hKeyRealm;
    DWORD retCode;
    DWORD i, dwVal;
    static TCHAR FAR keyValue[255], valData[255];
    DWORD keyLen;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    
    rgy = (krb5_rgy_t *)malloc(sizeof(krb5_rgy_t));
    if (!rgy)
	return ERR_NDI_LOW_MEM;
    memset(rgy, 0, sizeof(krb5_rgy_t));

    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
			 KERB_DOMAINS_KEY,
			 &hKey);
    if (retCode == ERROR_SUCCESS) {
	krb5_realm_t *pRealm;
	name_list_t *pName;
	for (i = 0; retCode == ERROR_SUCCESS; i++) {
	    keyLen = sizeof(keyValue);
	    retCode = RegEnumKey(hKey, i, keyValue, keyLen);
	    if (retCode != ERROR_SUCCESS)
		continue;
	    pRealm = NewRealm(lstrlen(keyValue)+1);
	    if (!pRealm) {
		RegCloseKey(hKey);
		return ERR_NDI_LOW_MEM;
	    }
	    lstrcpy((LPTSTR)&pRealm->name, keyValue);
	    key = (LPTSTR)malloc(lstrlen(REGKEY)+10+lstrlen(keyValue));
	    if (!key) {
		RegCloseKey(hKey);
		return ERR_NDI_LOW_MEM;
	    }
	    lstrcpy(key, KERB_DOMAINS_KEY TEXT("\\"));
	    lstrcat((LPTSTR)key, keyValue);
	    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
				   key,
				   &hKeyRealm);
	    if (retCode == ERROR_SUCCESS) {
		pStr = RegGetStr(hKeyRealm, KERB_DOMAIN_KDC_NAMES_VALUE);
		while (pStr && *pStr) {
		    pName = NewNameList();
		    if (!pName) {
			RegCloseKey(hKeyRealm);
			RegCloseKey(hKey);
			return ERR_NDI_LOW_MEM;
		    }
		    pName->name = lstrdup(pStr);
		    LIST_INSERT_HEAD(&pRealm->kdc, pName, list);
		    pStr += lstrlen(pStr)+1;
		}
		pStr = RegGetStr(hKeyRealm, KERB_DOMAIN_KPASSWD_NAMES_VALUE);
		while (pStr && *pStr) {
		    pName = NewNameList();
		    if (!pName) {
			RegCloseKey(hKeyRealm);
			RegCloseKey(hKey);
			return ERR_NDI_LOW_MEM;
		    }
		    pName->name = lstrdup(pStr);
		    LIST_INSERT_HEAD(&pRealm->kpasswd, pName, list);
		    pStr += lstrlen(pStr)+1;
		}
		pStr = RegGetStr(hKeyRealm, KERB_DOMAIN_ALT_NAMES_VALUE);
		while (pStr && *pStr) {
		    pName = NewNameList();
		    if (!pName) {
			RegCloseKey(hKeyRealm);
			RegCloseKey(hKey);
			return ERR_NDI_LOW_MEM;
		    }
		    pName->name = lstrdup(pStr);
		    LIST_INSERT_HEAD(&pRealm->altname, pName, list);
		    pStr += lstrlen(pStr)+1;
		}
		dwVal = RegGetInt(hKeyRealm, KERB_DOMAIN_FLAGS_VALUE);
		if (dwVal == -1) {
		    dwVal = 0;
		}
		pRealm->realm_flags = dwVal;
		dwVal = RegGetInt(hKeyRealm, KERB_DOMAIN_AP_REQ_CSUM_VALUE);
		if (dwVal == -1) {
		    dwVal = KERB_DEFAULT_AP_REQ_CSUM;
		}
		pRealm->ap_req_chksum = dwVal;
		dwVal = RegGetInt(hKeyRealm, KERB_DOMAIN_PREAUTH_VALUE);
		if (dwVal == -1) {
		    dwVal = KERB_DEFAULT_PREAUTH_TYPE;
		}
		pRealm->preauth_type = dwVal;
		RegCloseKey(hKeyRealm);
		free(key);
	    }
	    LIST_INSERT_HEAD(&rgy->realms, pRealm, list);
	}
	RegCloseKey(hKey);

	// 
    }
#if 1
    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
			 TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
			 &hKey);
    if (retCode == ERROR_SUCCESS) {
	default_domain = RegGetStr(hKey, TEXT("Domain"));
	RegCloseKey(hKey);
    }
#else
    retCode = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyDnsDomainInformation,
                (PVOID *) &DnsDomainInfo
                );
    if (!NT_SUCCESS(retCode))
    {
        printf("Failed to query dns domain info: 0x%x\n",Status);
        goto Cleanup;
    }

    if ( DnsDomainInfo->DnsDomainName.Length == 0 ) {

        printf("Machine is not configured to log on to an external KDC.  Probably a workgroup member\n");
        goto Cleanup;

    } else { // nonempty dns domain, but no sid.  Assume we're in an RFC1510 domain.

      printf( "default realm = %wZ ",
		&DnsDomainInfo->DnsDomainName );

      if ( DnsDomainInfo->Sid != NULL ) {

	printf( "(NT Domain)\n" );

      } else {

	printf( "(external)\n" );

      }

#endif    
    return OK;
}

/* Write out any conf parameters */

static void
SaveRealm(krb5_realm_t *rp)
{
    name_list_t *np;
    
    DPRINTF((TEXT("\n%s: %s\n\t"), rp->name, KERB_DOMAIN_KDC_NAMES_VALUE));
    for (np = rp->kdc.lh_first; np; np = np->list.le_next) {
	DPRINTF((TEXT("%s "), np->name));
    }

    DPRINTF((TEXT("\n%s: %s\n\t"), rp->name, KERB_DOMAIN_KPASSWD_NAMES_VALUE));
    for (np = rp->kpasswd.lh_first; np; np = np->list.le_next) {
	DPRINTF((TEXT("%s "), np->name));
    }

    DPRINTF((TEXT("\n%s: %s\n\t"), rp->name, KERB_DOMAIN_ALT_NAMES_VALUE));
    for (np = rp->altname.lh_first; np; np = np->list.le_next) {
	DPRINTF((TEXT("%s "), np->name));
    }
    DPRINTF((TEXT("\n%s: 0x%x\n"), KERB_DOMAIN_FLAGS_VALUE,
	     rp->realm_flags));
    DPRINTF((TEXT("\n%s: 0x%x\n"), KERB_DOMAIN_AP_REQ_CSUM_VALUE,
	     rp->ap_req_chksum));
    DPRINTF((TEXT("\n%s: 0x%x\n"), KERB_DOMAIN_PREAUTH_VALUE,
	     rp->preauth_type));
}

UINT
Krb5NdiInstall(krb5_rgy_t *rgy)
{
    krb5_realm_t *rp;
    
    if (rgy) {
	DPRINTF((TEXT("Realms\n")));
	for (rp = rgy->realms.lh_first; rp; rp = rp->list.le_next) {
	    DPRINTF((TEXT("%s\n"), rp->name));
	    SaveRealm(rp);
	}
    }

    return OK;
}

/* Destroy any conf parameters */
UINT
Krb5NdiDestroy(krb5_rgy_t *rgy)
{
    FreeRgy(rgy);
    
    return OK;
}

void
ShowRealm(HWND hDlg)
{
    INT_PTR idx;
    krb5_realm_t *pRealm;
    name_list_t *pNlist;
    
    SendDlgItemMessage(hDlg, IDC_REALM_KDC, CB_RESETCONTENT, 0, 0L);
    SendDlgItemMessage(hDlg, IDC_REALM_ADMIN, CB_RESETCONTENT, 0, 0L);
    SendDlgItemMessage(hDlg, IDC_REALM_ALT_NAMES, CB_RESETCONTENT, 0, 0L);
    SetDlgItemText(hDlg, IDC_REALM_DEF_DOMAIN, TEXT(""));

    idx = (int)SendDlgItemMessage(hDlg, IDC_REALMS, LB_GETCURSEL, 0, 0L);
    if (idx == LB_ERR)
	return;
    
    pRealm = (krb5_realm_t FAR *)SendDlgItemMessage(hDlg, IDC_REALMS,
						    LB_GETITEMDATA, idx, 0L);
    for (pNlist = pRealm->kdc.lh_first; pNlist; pNlist = pNlist->list.le_next) {
	idx = SendDlgItemMessage(hDlg, IDC_REALM_KDC, CB_ADDSTRING, 0,
			   (LPARAM)pNlist->name);
	SetDlgItemText(hDlg, IDC_REALM_KDC, pNlist->name);
	SendDlgItemMessage(hDlg, IDC_REALM_KDC, CB_SETITEMDATA, idx,
			   (LPARAM)(name_list_t FAR *)pNlist);
    }
    for (pNlist = pRealm->kpasswd.lh_first; pNlist; pNlist = pNlist->list.le_next) {
	idx = SendDlgItemMessage(hDlg, IDC_REALM_ADMIN, CB_ADDSTRING, 0,
			   (LPARAM)pNlist->name);
	SetDlgItemText(hDlg, IDC_REALM_ADMIN, pNlist->name);
	SendDlgItemMessage(hDlg, IDC_REALM_ADMIN, CB_SETITEMDATA, idx,
			   (LPARAM)(name_list_t FAR *)pNlist);
    }
    for (pNlist = pRealm->altname.lh_first; pNlist; pNlist = pNlist->list.le_next) {
	idx = SendDlgItemMessage(hDlg, IDC_REALM_ALT_NAMES, CB_ADDSTRING, 0,
			   (LPARAM)pNlist->name);
	SetDlgItemText(hDlg, IDC_REALM_ALT_NAMES, pNlist->name);
	SendDlgItemMessage(hDlg, IDC_REALM_ALT_NAMES, CB_SETITEMDATA, idx,
			   (LPARAM)(name_list_t FAR *)pNlist);
    }
    CheckDlgButton(hDlg, IDC_KDC_TCP,
		   (pRealm->realm_flags & KERB_MIT_REALM_TCP_SUPPORTED)?
		   BST_CHECKED:BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_ADDRREQ,
		   (pRealm->realm_flags & KERB_MIT_REALM_SEND_ADDRESS)?
		   BST_CHECKED:BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_KDC_DELEG,
		   (pRealm->realm_flags & KERB_MIT_REALM_TRUSTED_FOR_DELEGATION)?
		   BST_CHECKED:BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_KDC_CANONICALIZE,
		   (pRealm->realm_flags & KERB_MIT_REALM_DOES_CANONICALIZE)?
		   BST_CHECKED:BST_UNCHECKED);
    SetDlgItemInt(hDlg, IDC_CHKSUM, pRealm->ap_req_chksum, FALSE);
    SetDlgItemText(hDlg, IDC_REALM_DEF_DOMAIN,
		   STRDEF(default_domain, TEXT("")));
}

INT_PTR CALLBACK
AddRealmProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR realm_name[255];
    krb5_realm_t *pRealm;
    
    switch (message) {
    case WM_INITDIALOG:
	SetFocus(GetDlgItem(hDlg, IDC_NEW_REALM));
	return 0;

    case WM_COMMAND:
	switch (LOWORD(wParam)) {
	case IDOK:
	    GetDlgItemText(hDlg, IDC_NEW_REALM,
			   realm_name, sizeof(realm_name));
	    pRealm = NewRealm(lstrlen(realm_name));
	    if (pRealm)
		lstrcpy(pRealm->name, realm_name);
	    EndDialog(hDlg, (int)pRealm);
	    return TRUE;
	
	case IDCANCEL:
	    EndDialog(hDlg, 0);
	    return TRUE;
	}
	break;
    }
	
    return FALSE;
}

void
AddRealm(HWND hDlg, krb5_rgy_t *rgy)
{
    krb5_realm_t *pRealm;
    
    if (pRealm = (krb5_realm_t *) DialogBox(hInstance,
					    MAKEINTRESOURCE(IDD_REALM_ADD),
					    hDlg,
					    AddRealmProc)) {
	int idx;
	LIST_INSERT_HEAD(&rgy->realms, pRealm, list);
	idx = SendDlgItemMessage(hDlg, IDC_REALMS, LB_ADDSTRING, 0,
				 (LPARAM)(LPSTR)pRealm->name);
	SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETITEMDATA, idx,
			   (LPARAM)(krb5_realm_t FAR *)pRealm);
	SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETCURSEL, idx, 0L);
	ShowRealm(hDlg);
    }
}

void
RemoveRealm(HWND hDlg)
{
    TCHAR *msg;
    int idx;
    krb5_realm_t *pRealm;

    idx = (int) SendDlgItemMessage(hDlg, IDC_REALMS, LB_GETCURSEL, 0, 0L);
    pRealm = (krb5_realm_t FAR *)SendDlgItemMessage(hDlg, IDC_REALMS,
						    LB_GETITEMDATA, idx, 0L);
#define FMT TEXT("You are about to remove the realm \"%s\"\n\rDo you want to continue ?")
    msg = malloc(lstrlen(FMT) + lstrlen(pRealm->name));
    if (!msg)
	return;
    wsprintf(msg, FMT, pRealm->name);
#undef FMT
    if (MessageBox(hDlg, msg, TEXT("Confirm Delete"),
		   MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2|MB_SETFOREGROUND) == IDYES) {
	idx = SendDlgItemMessage(hDlg, IDC_REALMS, LB_DELETESTRING, idx, 0L);
	LIST_REMOVE(pRealm, list);
	FreeRealm(pRealm);
	SendDlgItemMessage(hDlg, IDC_REALMS, CB_SETCURSEL, 0, 0L);
	ShowRealm(hDlg);
    }
    free(msg);
}

INT_PTR CALLBACK
Krb5NdiRealmsProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE *ps;
    krb5_realm_t *pRealm;
    
    switch (message) {
    case WM_INITDIALOG:
	for (pRealm = rgy->realms.lh_first; pRealm; pRealm = pRealm->list.le_next) {
	    int idx = SendDlgItemMessage(hDlg, IDC_REALMS, LB_ADDSTRING, 0,
					 (LPARAM)(LPSTR)pRealm->name);
	    SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETITEMDATA, idx,
			       (LPARAM)(krb5_realm_t FAR *)pRealm);
	}
	SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETCURSEL, 0, 0L);
	ShowRealm(hDlg);
	ps = (PROPSHEETPAGE *)lParam;
	return TRUE;

    case WM_COMMAND:
	switch (LOWORD(wParam)) {
        case IDC_REALMS:
	    switch (HIWORD(wParam)) {
	    case LBN_SELCHANGE:
		ShowRealm(hDlg);
		break;
            }
            return 0;
            /* NOTREACHED */

	case IDC_REALM_ADD:
	    AddRealm(hDlg, rgy);
	    break;
	    
	case IDC_REALM_REMOVE:
	    RemoveRealm(hDlg);
	    break;
	}
	break;
	    
    case WM_NOTIFY:
	switch (((NMHDR *)lParam)->code) {

	case PSN_SETACTIVE:
	case PSN_RESET:
	    /* reset button states */
	    if (((NMHDR *)lParam)->code == PSN_RESET)
		SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
	    break;
	    
	case PSN_APPLY:
	    /* Save the settings */
	    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
	    break;

	case PSN_KILLACTIVE:
	    SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
	    return 1;
	}
	break;
    }

    return FALSE;
}

int WINAPI
WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLn, int nShowCmd)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[1];
    int err = 0;
    
    hInstance = hInst;
    
    if ((err = Krb5NdiCreate()) != OK)
	return err;

    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = 0;
    psp[0].hInstance = hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_REALMS);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = Krb5NdiRealmsProc;
    psp[0].lParam = (LPARAM)rgy;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = NULL;
    psh.hInstance = hInst;
    psh.pszIcon = NULL;
    psh.pszCaption = (LPTSTR)TEXT("Kerberos v5 Configuration");
    psh.pStartPage = 0;
    psh.nPages = sizeof(psp)/sizeof(psp[0]);
    psh.ppsp = (LPCPROPSHEETPAGE)psp;

    if (PropertySheet(&psh))
	Krb5NdiInstall(rgy);

    Krb5NdiDestroy(rgy);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\k5import\k5import.cxx ===
#define UNICODE
#define INC_OLE2
#include <windows.h>
#include <activeds.h>
#include <ntsecapi.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <assert.h>
#define SECURITY_WIN32
#include <security.h>   // General definition of a Security Support Provider
#include <shlwapi.h>

typedef	int	krb5_int32;
typedef	short	krb5_int16;

typedef	unsigned int krb5_kvno;	
typedef	unsigned char	krb5_octet;
typedef unsigned int 	krb5_enctype;

typedef krb5_int32	krb5_deltat;
typedef	krb5_int32	krb5_flags;
typedef krb5_int32	krb5_timestamp;
typedef	krb5_int32	krb5_error_code;

typedef	char FAR * krb5_principal;
typedef	void FAR * krb5_pointer;

/*
 * Note --- these structures cannot be modified without changing the
 * database version number in libkdb.a, but should be expandable by
 * adding new tl_data types.
 */
typedef struct _krb5_tl_data {
    struct _krb5_tl_data* tl_data_next;		/* NOT saved */
    krb5_int16 		  tl_data_type;		
    krb5_int16		  tl_data_length;	
    krb5_octet 	        * tl_data_contents;	
} krb5_tl_data;

/* 
 * If this ever changes up the version number and make the arrays be as
 * big as necessary.
 *
 * Currently the first type is the enctype and the second is the salt type.
 */
typedef struct _krb5_key_data {
    krb5_int16 		  key_data_ver;		/* Version */
    krb5_int16		  key_data_kvno;	/* Key Version */
    krb5_int16		  key_data_type[2];	/* Array of types */
    krb5_int16		  key_data_length[2];	/* Array of lengths */
    krb5_octet 	        * key_data_contents[2];	/* Array of pointers */
} krb5_key_data;

#define KRB5_KDB_V1_KEY_DATA_ARRAY	2	/* # of array elements */

typedef struct _krb5_db_entry_new {
    krb5_int16		  len;			
    krb5_flags 		  attributes;
    krb5_deltat		  max_life;
    krb5_deltat		  max_renewable_life;
    krb5_timestamp 	  expiration;	  	/* When the client expires */
    krb5_timestamp 	  pw_expiration;  	/* When its passwd expires */
    krb5_timestamp 	  last_success;		/* Last successful passwd */
    krb5_timestamp 	  last_failed;		/* Last failed passwd attempt */
    krb5_kvno 	 	  fail_auth_count; 	/* # of failed passwd attempt */
    krb5_int16 		  n_tl_data;
    krb5_int16 		  n_key_data;
    krb5_int16		  e_length;		/* Length of extra data */
    krb5_octet		* e_data;		/* Extra data to be saved */

    krb5_principal 	  princ;		/* Length, data */	
    krb5_tl_data	* tl_data;		/* Linked list */
    krb5_key_data       * key_data;		/* Array */
} krb5_db_entry;

typedef struct _krb5_keyblock {
    krb5_enctype enctype;
    int length;
    krb5_octet FAR *contents;
} krb5_keyblock;

krb5_keyblock mkey;


/* Strings */

static const char k5_dump_header[] = "kdb5_util load_dump version 4\n";

/* Message strings */
static const char regex_err[] = "%s: regular expression error - %s\n";
static const char regex_merr[] = "%s: regular expression match error - %s\n";
static const char pname_unp_err[] = "%s: cannot unparse principal name (%s)\n";
static const char mname_unp_err[] = "%s: cannot unparse modifier name (%s)\n";
static const char nokeys_err[] = "%s: cannot find any standard key for %s\n";
static const char sdump_tl_inc_err[] = "%s: tagged data list inconsistency for %s (counted %d, stored %d)\n";
static const char stand_fmt_name[] = "Kerberos version 5";
static const char old_fmt_name[] = "Kerberos version 5 old format";
static const char b6_fmt_name[] = "Kerberos version 5 beta 6 format";
static const char ofopen_error[] = "%s: cannot open %s for writing (%s)\n";
static const char oflock_error[] = "%s: cannot lock %s (%s)\n";
static const char dumprec_err[] = "%s: error performing %s dump (%s)\n";
static const char dumphdr_err[] = "%s: error dumping %s header (%s)\n";
static const char trash_end_fmt[] = "%s(%d): ignoring trash at end of line: ";
static const char read_name_string[] = "name string";
static const char read_key_type[] = "key type";
static const char read_key_data[] = "key data";
static const char read_pr_data1[] = "first set of principal attributes";
static const char read_mod_name[] = "modifier name";
static const char read_pr_data2[] = "second set of principal attributes";
static const char read_salt_data[] = "salt data";
static const char read_akey_type[] = "alternate key type";
static const char read_akey_data[] = "alternate key data";
static const char read_asalt_type[] = "alternate salt type";
static const char read_asalt_data[] = "alternate salt data";
static const char read_exp_data[] = "expansion data";
static const char store_err_fmt[] = "%s(%d): cannot store %s(%s)\n";
static const char add_princ_fmt[] = "%s\n";
static const char parse_err_fmt[] = "%s(%d): cannot parse %s (%s)\n";
static const char read_err_fmt[] = "%s(%d): cannot read %s\n";
static const char no_mem_fmt[] = "%s(%d): no memory for buffers\n";
static const char rhead_err_fmt[] = "%s(%d): cannot match size tokens\n";
static const char err_line_fmt[] = "%s: error processing line %d of %s\n";
static const char head_bad_fmt[] = "%s: dump header bad in %s\n";
static const char read_bytecnt[] = "record byte count";
static const char read_encdata[] = "encoded data";
static const char n_name_unp_fmt[] = "%s(%s): cannot unparse name\n";
static const char n_dec_cont_fmt[] = "%s(%s): cannot decode contents\n";
static const char read_nint_data[] = "principal static attributes";
static const char read_tcontents[] = "tagged data contents";
static const char read_ttypelen[] = "tagged data type and length";
static const char read_kcontents[] = "key data contents";
static const char read_ktypelen[] = "key data type and length";
static const char read_econtents[] = "extra data contents";
static const char k5beta_fmt_name[] = "Kerberos version 5 old format";
static const char standard_fmt_name[] = "Kerberos version 5 format";
static const char no_name_mem_fmt[] = "%s: cannot get memory for temporary name\n";
static const char ctx_err_fmt[] = "%s: cannot initialize Kerberos context\n";
static const char stdin_name[] = "standard input";
static const char restfail_fmt[] = "%s: %s restore failed\n";
static const char close_err_fmt[] = "%s: cannot close database (%s)\n";
static const char dbinit_err_fmt[] = "%s: cannot initialize database (%s)\n";
static const char dblock_err_fmt[] = "%s: cannot initialize database lock (%s)\n";
static const char dbname_err_fmt[] = "%s: cannot set database name to %s (%s)\n";
static const char dbdelerr_fmt[] = "%s: cannot delete bad database %s (%s)\n";
static const char dbunlockerr_fmt[] = "%s: cannot unlock database %s (%s)\n";
static const char dbrenerr_fmt[] = "%s: cannot rename database %s to %s (%s)\n";
static const char dbcreaterr_fmt[] = "%s: cannot create database %s (%s)\n";
static const char dfile_err_fmt[] = "%s: cannot open %s (%s)\n";

static const char oldoption[] = "-old";
static const char b6option[] = "-b6";
static const char verboseoption[] = "-verbose";
static const char updateoption[] = "-update";
static const char ovoption[] = "-ov";
static const char dump_tmptrail[] = "~";

#define	ENCTYPE_NULL		0x0000
#define	ENCTYPE_DES_CBC_CRC	0x0001	/* DES cbc mode with CRC-32 */
#define	ENCTYPE_DES_CBC_MD4	0x0002	/* DES cbc mode with RSA-MD4 */
#define	ENCTYPE_DES_CBC_MD5	0x0003	/* DES cbc mode with RSA-MD5 */
#define	ENCTYPE_DES_CBC_RAW	0x0004	/* DES cbc mode raw */
#define	ENCTYPE_DES3_CBC_SHA	0x0005	/* DES-3 cbc mode with NIST-SHA */
#define	ENCTYPE_DES3_CBC_RAW	0x0006	/* DES-3 cbc mode raw */
#define ENCTYPE_RC4_MD4          -128
#define ENCTYPE_RC4_PLAIN2       -129
#define ENCTYPE_RC4_LM           -130
#define ENCTYPE_RC4_SHA          -131
#define ENCTYPE_DES_PLAIN        -132
#define ENCTYPE_RC4_HMAC_OLD     -133
#define ENCTYPE_RC4_PLAIN_OLD    -134
#define ENCTYPE_RC4_HMAC_OLD_EXP -135
#define ENCTYPE_RC4_PLAIN_OLD_EXP -136
#define ENCTYPE_DES_CBC_MD5_EXP  -137
#define ENCTYPE_DES_PLAIN_EXP    -138
#define ENCTYPE_RC4_PLAIN        -140
#define ENCTYPE_RC4_PLAIN_EXP    -141
#define ENCTYPE_UNKNOWN		0x01ff

/* Salt types */
#define KRB5_KDB_SALTTYPE_NORMAL	0
#define KRB5_KDB_SALTTYPE_V4		1
#define KRB5_KDB_SALTTYPE_NOREALM	2
#define KRB5_KDB_SALTTYPE_ONLYREALM	3
#define KRB5_KDB_SALTTYPE_SPECIAL	4
#define KRB5_KDB_SALTTYPE_AFS3		5

/* Attributes */
#define	KRB5_KDB_DISALLOW_POSTDATED	0x00000001
#define	KRB5_KDB_DISALLOW_FORWARDABLE	0x00000002
#define	KRB5_KDB_DISALLOW_TGT_BASED	0x00000004
#define	KRB5_KDB_DISALLOW_RENEWABLE	0x00000008
#define	KRB5_KDB_DISALLOW_PROXIABLE	0x00000010
#define	KRB5_KDB_DISALLOW_DUP_SKEY	0x00000020
#define	KRB5_KDB_DISALLOW_ALL_TIX	0x00000040
#define	KRB5_KDB_REQUIRES_PRE_AUTH	0x00000080
#define KRB5_KDB_REQUIRES_HW_AUTH	0x00000100
#define	KRB5_KDB_REQUIRES_PWCHANGE	0x00000200
#define KRB5_KDB_DISALLOW_SVR		0x00001000
#define KRB5_KDB_PWCHANGE_SERVICE	0x00002000
#define KRB5_KDB_SUPPORT_DESMD5         0x00004000
#define	KRB5_KDB_NEW_PRINC		0x00008000

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21

LPSTR
get_error_text(DWORD dwError)
{
    PCHAR pBuf = NULL;
    DWORD cMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
				  FORMAT_MESSAGE_ALLOCATE_BUFFER | 40,
				  NULL,
				  dwError,
				  MAKELANGID(0, SUBLANG_ENGLISH_US),
				  (LPSTR) &pBuf,
				  128,
				  NULL);
    if (!cMsgLen) {
	pBuf = (LPSTR)malloc(30);
	sprintf(pBuf, "(%d)", dwError);
    }
    return(pBuf);
}

void
print_salt_string(
    int stype,
    int len,
    char *str
)
{
    int i;
    
    switch (stype) {
    case KRB5_KDB_SALTTYPE_NORMAL:
	printf("Normal\n");
	break;
	
    case KRB5_KDB_SALTTYPE_V4:
	printf("V4\n");
	break;
	
    case KRB5_KDB_SALTTYPE_NOREALM:
	printf("No Realm : \"%*s\"\n", len, str);
	break;
	
    case KRB5_KDB_SALTTYPE_ONLYREALM:
	printf("Only Realm : \"%*s\"\n", len, str);
	break;
	
    case KRB5_KDB_SALTTYPE_AFS3:
	printf("AFS3 : \"%*s\"\n", len, str);
	break;
	
    case KRB5_KDB_SALTTYPE_SPECIAL:
	printf("Special [%d]:", len);
	goto dump;

    default:
	printf("salttype %d [%d]:", stype, len);
    dump:;
	for (i=0; i < len; i++)
	    printf(" %02x", str[i]);
	printf("\n");
	break;
    }
}

char *
etype_string(
    int enctype
)
{
    static char buf[32];
    
    switch (enctype) {
    case ENCTYPE_DES_CBC_CRC:
	return "DES-CBC-CRC";
	break;
    case ENCTYPE_DES_CBC_MD4:
	return "DES-CBC-MD4";
	break;
    case ENCTYPE_DES_CBC_MD5:
	return "DES-CBC-MD5";
	break;
    case ENCTYPE_DES3_CBC_SHA:
	return "DES3-CBC-SHA";
	break;
    case ENCTYPE_RC4_MD4:
	return "RC4-MD4";
	break;
    case ENCTYPE_RC4_PLAIN2:
	return "RC4-PLAIN2";
	break;
    case ENCTYPE_RC4_LM:
	return "RC4-LM";
	break;
    case ENCTYPE_RC4_SHA:
	return "RC4-SHA";
	break;
    case ENCTYPE_DES_PLAIN:
	return "DES-PLAIN";
	break;
    case ENCTYPE_RC4_HMAC_OLD:
	return "RC4-HMAC-OLD";
	break;
    case ENCTYPE_RC4_PLAIN_OLD:
	return "RC4-PLAIN-OLD";
	break;
    case ENCTYPE_RC4_HMAC_OLD_EXP:
	return "RC4-HMAC-OLD-EXP";
	break;
    case ENCTYPE_RC4_PLAIN_OLD_EXP:
	return "RC4-PLAIN-OLD-EXP";
	break;
    case ENCTYPE_DES_CBC_MD5_EXP:
	return "DES-CBC-MD5-40bit";
	break;
    case ENCTYPE_DES_PLAIN_EXP:
	return "DES-PLAIN-40bit";
	break;
    case ENCTYPE_RC4_PLAIN:
	return "RC4-PLAIN";
	break;
    case ENCTYPE_RC4_PLAIN_EXP:
	return "RC4-PLAIN-EXP";
	break;
	
    default:
	sprintf(buf, "etype %d", enctype);
	return buf;
	break;
    }
}

void
print_tl_data(
    int n_data,
    krb5_tl_data *tl_data
)
{
    krb5_tl_data *tlp;
    int i;
    
    if (n_data) {
	printf("\ttl_data:\n");
	
	for (tlp = tl_data; tlp; tlp = tlp->tl_data_next) {
	    printf("\t\ttype=%d len=%d ",
		   tlp->tl_data_type, tlp->tl_data_length);
	    for (i = 0; i < tlp->tl_data_length; i++)
		printf(" %02x", tlp->tl_data_contents[i]);
	    printf("\n");
	}
    }
}

int
decrypt_key(
    krb5_keyblock *key,
    void *indata,
    int inlen,
    void *outdata,
    int *outlen
)
{
#define SEC_SUCCESS(Status) ((Status) >= 0)
    static const UCHAR iVec[8] = {0};
    static HANDLE lsaHandle = NULL;
    static ULONG packageId = 0;
    NTSTATUS Status, SubStatus;
    LSA_STRING Name;
    PKERB_DECRYPT_REQUEST DecryptRequest;
    ULONG OutLen, DecryptReqLength;
    PUCHAR OutBuf;
    int retval = 0;

    if (!lsaHandle) {
	Status = LsaConnectUntrusted(&lsaHandle);
	if (!SEC_SUCCESS(Status)) {
	    fprintf(stderr, "Failed to create LsaHandle - 0x%x\n", Status);
	    exit(3);
	}

	Name.Buffer = MICROSOFT_KERBEROS_NAME_A;
	Name.Length = (USHORT)strlen(Name.Buffer);
	Name.MaximumLength = Name.Length + 1;

	Status = LsaLookupAuthenticationPackage(lsaHandle,
						&Name,
						&packageId);
	if (!SEC_SUCCESS(Status)) {
	    LsaDeregisterLogonProcess(lsaHandle);
	    fprintf(stderr, "Failed to register LsaHandle - 0x%x\n", Status);
	    exit(3);
	}
    }

    DecryptReqLength = 
	sizeof(KERB_DECRYPT_REQUEST) + key->length + 8 + inlen;
    DecryptRequest = (PKERB_DECRYPT_REQUEST)LocalAlloc(LMEM_ZEROINIT, DecryptReqLength);

    DecryptRequest->MessageType = KerbDecryptDataMessage;
    DecryptRequest->LogonId.LowPart = 0;
    DecryptRequest->LogonId.HighPart = 0;
    DecryptRequest->Flags = 0;
    DecryptRequest->KeyUsage = KERB_TICKET_SALT;
    DecryptRequest->CryptoType = key->enctype;
    DecryptRequest->Key.KeyType = key->enctype;
    DecryptRequest->Key.Length = key->length;
    DecryptRequest->Key.Value = (PUCHAR) (DecryptRequest + 1);
    memcpy(DecryptRequest->Key.Value, key->contents, key->length);
    DecryptRequest->InitialVectorSize = 8;
    DecryptRequest->InitialVector = (PUCHAR)
	((PUCHAR)DecryptRequest->Key.Value + DecryptRequest->Key.Length);
    memcpy(DecryptRequest->InitialVector, iVec, 8);
    DecryptRequest->EncryptedDataSize = inlen;
    DecryptRequest->EncryptedData = (PUCHAR)
	((PUCHAR)DecryptRequest->InitialVector + DecryptRequest->InitialVectorSize);
    memcpy(DecryptRequest->EncryptedData, indata, inlen);

    Status = LsaCallAuthenticationPackage(lsaHandle,
					  packageId,
					  DecryptRequest,
					  DecryptReqLength,
					  (PVOID *)&OutBuf,
					  &OutLen,
					  &SubStatus);

    if (!SEC_SUCCESS(Status) || !SEC_SUCCESS(SubStatus)) {
	fprintf(stderr, "Decrypt: LsaCallAuthPackage failed: %s\n",
		get_error_text(SubStatus));
	exit(4);
    }

    if ((long)OutLen > *outlen) {
	fprintf(stderr, "Decrypt: outbuf too small (%d < %d)\n",
		OutLen, *outlen);
	*outlen = OutLen;
	retval = -1;
    }
    else if (outdata) {
	*outlen = OutLen;
	memcpy(outdata, OutBuf, OutLen);
    }
    
    LsaFreeReturnBuffer(OutBuf);

    return(retval);
}


void
print_key_data(
    int n_key_data,
    krb5_key_data *kd
)
{
    int n, i;
    krb5_keyblock key;
    krb5_octet *ptr;
    int tmplen;
    
    for (n = 0; n < n_key_data; n++) {
	ptr = kd[n].key_data_contents[0];
	key.enctype = kd[n].key_data_type[0];
	key.length = *(short *)ptr;
	ptr += 2;

	printf("\tkey[%d]: ver=%d kvno=%d\n",
	       n, kd[n].key_data_ver,
	       kd[n].key_data_kvno);
	printf("\t\tetype=%s [%d]: ", 
	       etype_string(key.enctype),
	       key.enctype);
	printf(" keylength=%d ", key.length);

	printf("\n\t\tEncrypted key: ");
	for (i = 0; i < kd[n].key_data_length[0]; i++)
	    printf(" %02x", kd[n].key_data_contents[0][i]);

	if (mkey.length) {
	    // First get the length needed
	    decrypt_key(&mkey, ptr, (kd[n].key_data_length[0] - 2),
			NULL, &tmplen);
	    key.contents = (krb5_octet *)malloc(tmplen);
	    assert(key.contents != 0);

	    // Now decrypt it
	    decrypt_key(&mkey, ptr, (kd[n].key_data_length[0] - 2),
			key.contents, &tmplen);

	    printf("\n\t\tDecrypted key: ");
	    for (i = 0; i < key.length; i++)
		printf(" %02x", key.contents[i]);
	}
	
	printf("\n\t\tsalt=");
	print_salt_string(kd[n].key_data_type[1], kd[n].key_data_length[1],
			  (char *)kd[n].key_data_contents[1]);
    }
}


int 
ds_put_principal(
    IADs *ds,
    krb5_db_entry &dbentry
    )
{
    // Check for accounts that we can't import
    if ((strncmp(dbentry.princ, "K/M", 3) == 0) ||
	(strncmp(dbentry.princ, "krbtgt/", 7) == 0) ||
	(strncmp(dbentry.princ, "kadmin/", 7) == 0)) {

	return -1;
    }
    
    char *cp;
    char *SAMName = StrDupA(dbentry.princ);
    
    // Zap the realm
    if (cp = strrchr(SAMName, '@'))
	*cp = '\0';
    
    // Check if this princ has an instance - likely SPN
    if (cp = strchr(SAMName, '/')) {
	// We don't do anything with SPN's right now
	return (-1);
    }

    printf(add_princ_fmt, SAMName);
    
    // Search for the entry in the domain

    // If this is to be an SPN; create the base account
    // (or use an existing one)

    // Now create the user

    return 0;
}


/*
 * Read a string of bytes while counting the number of lines passed.
 */
static int
read_string(
    FILE	*f,
    char	*buf,
    int		len,
    int		*lp
)
{
    int c;
    int i, retval;

    retval = 0;
    for (i=0; i<len; i++) {
	c = fgetc(f);
	if (c < 0) {
	    retval = 1;
	    break;
	}
	if (c == '\n')
	    (*lp)++;
	buf[i] = (char) c;
    }
    buf[len] = '\0';
    return(retval);
}

/*
 * Read a string of two character representations of bytes.
 */
static int
read_octet_string(
    FILE	*f,
    krb5_octet	*buf,
    int		len
)
{
    int c;
    int i, retval;

    retval = 0;
    for (i=0; i<len; i++) {
	if (fscanf(f, "%02x", &c) != 1) {
	    retval = 1;
	    break;
	}
	buf[i] = (krb5_octet) c;
    }
    return(retval);
}

/*
 * Find the end of an old format record.
 */
static void
find_record_end(
    FILE	*f,
    const char	*fn,
    int		lineno
)
{
    int	ch;

    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\n')) {
	fprintf(stderr, trash_end_fmt, fn, lineno);
	while (ch != '\n') {
	    putc(ch, stderr);
	    ch = fgetc(f);
	}
	putc(ch, stderr);
    }
}

/*
 * process_k5beta6_record()	- Handle a dump record in krb5b6 format.
 *
 * Returns -1 for end of file, 0 for success and 1 for failure.
 */
static int
process_k5beta6_record(
    const char		*fname,
    IADs 	*ds,
    FILE		*filep,
    int			verbose,
    int			*linenop
)
{
    int			retval;
    krb5_db_entry	dbentry;
    krb5_int32		t1, t2, t3, t4, t5, t6, t7, t8, t9;
    int			nread;
    int			error;
    int			i, j;
    char		*name;
    krb5_key_data	*kp, *kdatap;
    krb5_tl_data	**tlp, *tl;
    krb5_octet 		*op;
    krb5_error_code	kret;
    const char		*try2read;

    try2read = (char *) NULL;
    memset((char *) &dbentry, 0, sizeof(dbentry));
    (*linenop)++;
    retval = 1;
    name = (char *) NULL;
    kp = (krb5_key_data *) NULL;
    op = (krb5_octet *) NULL;
    error = 0;
    kret = 0;
    nread = fscanf(filep, "%d\t%d\t%d\t%d\t%d\t", &t1, &t2, &t3, &t4, &t5);
    if (nread == 5) {
	/* Get memory for flattened principal name */
	if (!(name = (char *) malloc((size_t) t2 + 1)))
	    error++;

	/* Get memory for and form tagged data linked list */
	tlp = &dbentry.tl_data;
	for (i=0; i<t3; i++) {
	    if ((*tlp = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {
		memset(*tlp, 0, sizeof(krb5_tl_data));
		tlp = &((*tlp)->tl_data_next);
		dbentry.n_tl_data++;
	    }
	    else {
		error++;
		break;
	    }
	}

	/* Get memory for key list */
	if (t4 && !(kp = (krb5_key_data *) malloc((size_t)
						  (t4*sizeof(krb5_key_data)))))
	    error++;

	/* Get memory for extra data */
	if (t5 && !(op = (krb5_octet *) malloc((size_t) t5)))
	    error++;

	if (!error) {
	    dbentry.len = (krb5_int16)t1;
	    dbentry.n_key_data = (krb5_int16)t4;
	    dbentry.e_length = (krb5_int16)t5;
	    if (kp) {
		memset(kp, 0, (size_t) (t4*sizeof(krb5_key_data)));
		dbentry.key_data = kp;
		kp = (krb5_key_data *) NULL;
	    }
	    if (op) {
		memset(op, 0, (size_t) t5);
		dbentry.e_data = op;
		op = (krb5_octet *) NULL;
	    }

	    /* Read in and parse the principal name */
	    if (!read_string(filep, name, t2, linenop)) {

		dbentry.princ = StrDupA(name);
		
		/* Get the fixed principal attributes */
		nread = fscanf(filep, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t",
			       &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9);
		if (nread == 8) {
		    dbentry.attributes = (krb5_flags) t2;
		    dbentry.max_life = (krb5_deltat) t3;
		    dbentry.max_renewable_life = (krb5_deltat) t4;
		    dbentry.expiration = (krb5_timestamp) t5;
		    dbentry.pw_expiration = (krb5_timestamp) t6;
		    dbentry.last_success = (krb5_timestamp) t7;
		    dbentry.last_failed = (krb5_timestamp) t8;
		    dbentry.fail_auth_count = (krb5_kvno) t9;
		} else {
		    try2read = read_nint_data;
		    error++;
		}

		/*
		 * Get the tagged data.
		 *
		 * Really, this code ought to discard tl data types
		 * that it knows are special to the current version
		 * and were not supported in the previous version.
		 * But it's a pain to implement that here, and doing
		 * it at dump time has almost as good an effect, so
		 * that's what I did.  [krb5-admin/89/
		 */
		if (!error && dbentry.n_tl_data) {
		    for (tl = dbentry.tl_data; tl; tl = tl->tl_data_next) {
			nread = fscanf(filep, "%d\t%d\t", &t1, &t2);
			if (nread == 2) {
			    tl->tl_data_type = (krb5_int16) t1;
			    tl->tl_data_length = (krb5_int16) t2;
			    if (tl->tl_data_length) {
				if (!(tl->tl_data_contents =
				      (krb5_octet *) malloc((size_t) t2+1)) ||
				    read_octet_string(filep,
						      tl->tl_data_contents,
						      t2)) {
				    try2read = read_tcontents;
				    error++;
				    break;
				}
			    }
			    else {
				/* Should be a null field */
				nread = fscanf(filep, "%d", &t9);
				if ((nread != 1) || (t9 != -1)) {
				    error++;
				    try2read = read_tcontents;
				    break;
				}
			    }
			}
			else {
			    try2read = read_ttypelen;
			    error++;
			    break;
			}
		    }
		}

		/* Get the key data */
		if (!error && dbentry.n_key_data) {
		    for (i=0; !error && (i<dbentry.n_key_data); i++) {
			kdatap = &dbentry.key_data[i];
			nread = fscanf(filep, "%d\t%d\t", &t1, &t2);
			if (nread == 2) {
			    kdatap->key_data_ver = (krb5_int16) t1;
			    kdatap->key_data_kvno = (krb5_int16) t2;

			    for (j=0; j<t1; j++) {
				nread = fscanf(filep, "%d\t%d\t", &t3, &t4);
				if (nread == 2) {
				    kdatap->key_data_type[j] = (krb5_int16)t3;
				    kdatap->key_data_length[j] = (krb5_int16)t4;
				    if (t4) {
					if (!(kdatap->key_data_contents[j] =
					      (krb5_octet *)
					      malloc((size_t) t4+1)) ||
					    read_octet_string(filep,
							      kdatap->key_data_contents[j],
							      t4)) {
					    try2read = read_kcontents;
					    error++;
					    break;
					}
				    }
				    else {
					/* Should be a null field */
					nread = fscanf(filep, "%d", &t9);
					if ((nread != 1) || (t9 != -1)) {
					    error++;
					    try2read = read_kcontents;
					    break;
					}
				    }
				}
				else {
				    try2read = read_ktypelen;
				    error++;
				    break;
				}
			    }
			}
		    }
		}

		/* Get the extra data */
		if (!error && dbentry.e_length) {
		    if (read_octet_string(filep,
					  dbentry.e_data,
					  (int) dbentry.e_length)) {
			try2read = read_econtents;
			error++;
		    }
		}
		else {
		    nread = fscanf(filep, "%d", &t9);
		    if ((nread != 1) || (t9 != -1)) {
			error++;
			try2read = read_econtents;
		    }
		}

		/* Finally, find the end of the record. */
		if (!error)
		    find_record_end(filep, fname, *linenop);

		/*
		 * We have either read in all the data or choked.
		 */
		if (!error) {
		    retval = 0;
		    if (verbose == 2) {
			printf("%s\n", dbentry.princ);
			printf("\tattr=0x%x\n", dbentry.attributes);
			printf("\tmax_life=%d, max_renewable_life=%d\n",
			       dbentry.max_life, dbentry.max_renewable_life);
			printf("\texpiration=%d, pw_exp=%d\n",
			       dbentry.expiration, dbentry.pw_expiration);
			printf("\te_length=%d n_tl_data=%d, n_key_data=%d\n",
			       dbentry.e_length, dbentry.n_tl_data,
			       dbentry.n_key_data);
			print_tl_data(dbentry.n_tl_data, dbentry.tl_data);
			print_key_data(dbentry.n_key_data, dbentry.key_data);
		    }
		    
		    if ((kret = ds_put_principal(ds,
						 dbentry))) {
			fprintf(stderr, store_err_fmt,
				fname, *linenop,
				name, ""/*error_message(kret)*/);
		    }
		    else
		    {
			retval = 0;
		    }
		}
		else {
		    fprintf(stderr, read_err_fmt, fname, *linenop, try2read);
		}
	    }
	    else {
		if (kret)
		    fprintf(stderr, parse_err_fmt,
			    fname, *linenop, name, ""/*error_message(kret)*/);
		else
		    fprintf(stderr, no_mem_fmt, fname, *linenop);
	    }
	}
	else {
	    fprintf(stderr, rhead_err_fmt, fname, *linenop);
	}

	if (op)
	    free(op);
	if (kp)
	    free(kp);
	if (name)
	    free(name);
	if (dbentry.princ)
	    free(dbentry.princ);
    }
    else {
	if (nread == EOF)
	    retval = -1;
    }
    return(retval);
}

int process_k5beta7_policy(
    const char		*fname,
    IADs 	*ds,
    FILE		*filep,
    int			verbose,
    int			*linenop,
    void *pol_db
)
{
    char namebuf[1024];
    int nread;
    struct krb5_policy {
	char *name;
	int pw_min_life;
	int pw_max_life;
	int pw_min_length;
	int pw_min_classes;
	int pw_history_num;
	int policy_refcnt;
    } rec;
    
    (*linenop)++;
    rec.name = namebuf;

    nread = fscanf(filep, "%1024s\t%d\t%d\t%d\t%d\t%d\t%d", rec.name,
		   &rec.pw_min_life, &rec.pw_max_life,
		   &rec.pw_min_length, &rec.pw_min_classes,
		   &rec.pw_history_num, &rec.policy_refcnt);
    if (nread == EOF)
	 return -1;
    else if (nread != 7) {
	 fprintf(stderr, "cannot parse policy on line %d (%d read)\n",
		 *linenop, nread);
	 return 1;
    }

#if 0
    if (ret = osa_adb_create_policy(pol_db, &rec)) {
	 if (ret == OSA_ADB_DUP &&
	     (ret = osa_adb_put_policy(pol_db, &rec))) {
	      fprintf(stderr, "cannot create policy on line %d: %s\n",
		      *linenop, error_message(ret));
	      return 1;
	 }
    }
#else
    fprintf(stderr, "Policy %s : min_life=%d max_life=%d min_len=%d min_classes=%d histnum=%d refcnt=%d\n",
	    rec.name,
	    rec.pw_min_life, rec.pw_max_life,
	    rec.pw_min_length, rec.pw_min_classes,
	    rec.pw_history_num, rec.policy_refcnt);
#endif
    if (verbose)
	 fprintf(stderr, "created policy %s - \n", rec.name);
    
    return 0;
}

/*
 * process_k5beta7_record()	- Handle a dump record in krb5b6 format.
 *
 * Returns -1 for end of file, 0 for success and 1 for failure.
 */
static int
process_k5beta7_record(
    const char		*fname,
    IADs 	*ds,
    FILE		*filep,
    int			verbose,
    int			*linenop,
    void *pol_db
)
{
     int nread;
     char rectype[100];

     nread = fscanf(filep, "%100s\t", rectype);
     if (nread == EOF)
	  return -1;
     else if (nread != 1)
	  return 1;
     if (strcmp(rectype, "princ") == 0)
	  process_k5beta6_record(fname, ds, filep, verbose,
				 linenop);
     else if (strcmp(rectype, "policy") == 0)
	  process_k5beta7_policy(fname, ds, filep, verbose,
				 linenop, pol_db);
     else {
	  fprintf(stderr, "unknown record type \"%s\" on line %d\n",
		  rectype, *linenop);
	  return 1;
     }

     return 0;
}

/*
 * restore_dump()	- Restore the database from a standard dump file.
 */
static int
restore_dump(
    const char		*programname,
    const char		*dumpfile,
    IADs 	*ds,
    FILE		*f,
    FILE		*k,
    int			verbose
)
{
    int		error;	
    int		lineno;
    char	buf[2*sizeof(k5_dump_header)];
    short	enctype;
    int		i;
    int pol_db;
    
    if (k) {
	/*
     * Read the master key file
     */
	if (fread(&enctype, 2, 1, k) != 1) {
	    perror("Unable to read master key file");
	    exit(2);
	}
	mkey.enctype = enctype;
	if (fread((krb5_pointer) &mkey.length,
		  sizeof(mkey.length), 1, k) != 1) {
	    perror("Cannot read master key length");
	    exit(2);
	}
	if (!mkey.length || mkey.length < 0) {
	    fprintf(stderr, "Bad stored master key.\n");
	    exit(2);
	}
	if (!(mkey.contents = (krb5_octet *)malloc(mkey.length))) {
	    fprintf(stderr, "Read mkey memory allocation failure.\n");
	    exit(2);
	}
	if (fread(mkey.contents,
		  sizeof(mkey.contents[0]), mkey.length, k) != mkey.length) {
	    memset(mkey.contents, 0, mkey.length);
	    perror("Cannot read master key");
	    exit(2);
	}
	fclose(k);

	printf("Master key: etype=%s [%d]: ",
	       etype_string(mkey.enctype), mkey.enctype);
	for (i = 0; i < mkey.length; i++)
	    printf(" %02x", mkey.contents[i]);
	printf("\n");
    }
    
    /*
     * Get/check the header.
     */
    error = 0;
    if (fgets(buf, sizeof(buf), f) == NULL) {
	return(1);
    }
    
    if (!strcmp(buf, k5_dump_header)) {
	lineno = 1;
	/*
	 * Process the records.
	 */
	while (!(error = process_k5beta7_record(dumpfile,
						ds,
						f,
						verbose,
						&lineno, (void *)&pol_db)))
	    ;
	if (error != -1)
	    fprintf(stderr, err_line_fmt, programname, lineno, dumpfile);
	else
	    error = 0;

	/*
	 * Close the input file.
	 */
	if (f != stdin)
	    fclose(f);
    }
    else {
	printf("buf=\"%s\"\n", buf);
	fprintf(stderr, head_bad_fmt, programname, dumpfile);
	error++;
    }
    return(error);
}

void __cdecl
main(int argc, char *argv[])
{
    FILE *kdbFile, *mkeyFile = NULL;
    int retval;
    IADs *pDS;
    int n = 1;
    int	verbose = 1;
    HRESULT hr;
    
    if (argc < 2 || argc > 5) {
	printf("Usage: %s [-m <mkey>] <dumpfile>\n", argv[0]);
	exit(1);
    }

    if (argc == 4) {
	if (strcmp(argv[1], "-m") == 0) {
	    mkeyFile = fopen(argv[2], "rb");
	    if (!mkeyFile) {
		perror("Unable to open master key file");
		exit(1);
	    }
	    n = 3;
	}
    }
    
    kdbFile = fopen(argv[n], "rb");
    if (!kdbFile) {
	perror("Unable to open dump file");
	exit(1);
    }

    // need to open DS and pass that in
    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
	fprintf(stderr, "Unable to init com - %s\n", get_error_text(hr));
	exit(2);
    }
    
    hr = ADsGetObject(TEXT("LDAP://rootDSE"), IID_IADs,
		      (void **)&pDS);
    if (FAILED(hr)) {
	fprintf(stderr, "Unable to bind to DS - %s\n", get_error_text(hr));
	exit(2);
    }
    
    retval = restore_dump(argv[0], argv[1], pDS, kdbFile, mkeyFile, verbose);

    fclose(kdbFile);
    exit(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\getcerts\getcerts.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        secret.cxx
//
// Contents:    test program to check the setup of a Cairo installation
//
//
// History:     22-Dec-92       Created         MikeSw
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <string.h>
#include <stdlib.h>

}

void _cdecl
main(int argc, char *argv[])
{
    LPSTR KeyName;
    LPSTR ValueName;
    FILE * File;
    DWORD RegStatus;
    HKEY Key = NULL;
    PBYTE Buffer = NULL;
    ULONG Size;
    ULONG Type;
    CHAR FileName[20];
    ULONG Index;
    ULONG CertCount;
    CHAR NameBuffer[10];
    ULONG NameBufferSize;
    BYTE VerisignCert[] = {
        0x30, 0x82, 0x02, 0x79, 0x30, 0x82, 0x01, 0xE2,
        0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x35,
        0x11, 0xA5, 0x52, 0x90, 0x6F, 0xE7, 0xD0, 0x29,
        0xA4, 0x40, 0x19, 0xD4, 0x11, 0xFC, 0x3E, 0x30
        };


    //
    // Open the key with the list of certificates
    //


    RegStatus = RegOpenKeyExA(
                    HKEY_CURRENT_USER,
                    "Software\\Microsoft\\Cryptography\\PersonalCertificates\\ClientAuth\\Certificates",
                    0,
                    KEY_QUERY_VALUE,
                    &Key
                    );
    if (RegStatus != ERROR_SUCCESS)
    {
        printf("No certificates found\n");
        return;
    }

    //
    // Enumerate throught the values
    //

    CertCount = 1;
    for (Index = 0; ; Index++ )
    {

        NameBufferSize = sizeof(NameBuffer);
        RegStatus = RegEnumValueA(
                        Key,
                        Index,
                        NameBuffer,
                        &NameBufferSize,
                        0,
                        &Type,
                        NULL,
                        &Size );
        if ((RegStatus != STATUS_SUCCESS) &&
            (RegStatus != ERROR_MORE_DATA))
        {
            break;
        }

        //
        // We only want binary values
        //

        if (Type != REG_BINARY)
        {
            continue;
        }

        Buffer = (PBYTE) LocalAlloc(LMEM_ZEROINIT, Size);
        if (Buffer == NULL)
        {
            goto Cleanup;
        }

        NameBufferSize = sizeof(NameBuffer);

        RegStatus = RegEnumValueA(
                        Key,
                        Index,
                        NameBuffer,
                        &NameBufferSize,
                        0,
                        &Type,
                        Buffer,
                        &Size );

        if (RegStatus != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        //
        // Skip the verisign certificate.
        //

        if (memcmp(Buffer,VerisignCert, sizeof(VerisignCert)) == 0)
        {
            LocalFree(Buffer);
            Buffer = NULL;
            continue;
        }
        if (CertCount == 1)
        {
            sprintf(FileName,"mycerts.cer");
        }
        else
        {
            sprintf(FileName,"mycerts%d.cer",CertCount);
        }
        File = fopen(FileName,"wb");
        if (File == NULL)
        {
            printf("Error opening file %s\n",FileName);
            goto Cleanup;
        }

        fwrite(Buffer, Size, 1, File);
        fclose(File);
        LocalFree(Buffer);
        Buffer = NULL;
        CertCount++;
    }

Cleanup:
    if (Key != NULL)
    {
        RegCloseKey(Key);
    }
    if (Buffer != NULL)
    {
        LocalFree(Buffer);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbconf\kerbconfres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbconf.rc
//
#define IDD_REALM_ADD                   104
#define IDB_CHECK                       106
#define IDD_ADD_DOMAIN                  107
#define IDB_NOCHECK                     111
#define IDD_LIB_DEFAULTS                1001
#define IDD_REALMS                      1002
#define IDD_DOMAIN_REALM                1003
#define IDC_CKSUM_TYPES                 1005
#define IDC_ENC_TYPES                   1006
#define IDC_DCE_COMPAT                  1007
#define IDC_CCACHE_1                    1008
#define IDC_CCACHE_2                    1009
#define IDC_CCACHE_3                    1010
#define IDC_CCACHE_4                    1011
#define IDC_REALM_ADD                   1012
#define IDC_REALM_REMOVE                1013
#define IDC_REALM_KDC                   1014
#define IDC_REALM_ADMIN                 1015
#define IDC_REALM_K4_CONVERT            1016
#define IDC_REALM_ALT_NAMES             1016
#define IDC_REALM_DEF_DOMAIN            1017
#define IDC_REALMS                      1018
#define IDC_NEW_REALM                   1019
#define IDC_DEFAULT_REALM               1020
#define IDC_DOMAINS                     1021
#define IDC_DOMAIN_ADD                  1022
#define IDC_DOMAIN_REMOVE               1023
#define IDC_TKT_ENCTYPE                 1024
#define IDC_TGS_ENCTYPE                 1025
#define IDC_KDC_CKSUM                   1027
#define IDC_AP_CKSUM                    1028
#define IDC_SAFE_CKSUM                  1029
#define IDC_CLOCK_SKEW                  1031
#define IDC_CKSUM_SAFE                  1032
#define IDC_CKSUM_AP                    1033
#define IDC_CKSUM_KDC                   1034
#define IDC_CLOCK_SKEW_SPIN             1035
#define IDC_KDC_TIMESYNC                1036
#define IDC_DOMAIN_REALM                1037
#define IDC_ADD_DOM_HOST                1038
#define IDC_ADD_DOM_REALM               1039
#define IDC_ADDRREQ                     1041
#define IDC_KDC_TCP                     1042
#define IDC_CHKSUM                      1043
#define IDC_KDC_DELEG                   1044
#define IDC_KDC_CANONICALIZE            1045
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbpol\kerbpol.c ===
/*++

Managing user privileges can be achieved programmatically using the
following steps:

1. Open the policy on the target machine with LsaOpenPolicy(). To grant
   privileges, open the policy with POLICY_CREATE_ACCOUNT and
   POLICY_LOOKUP_NAMES access. To revoke privileges, open the policy with
   POLICY_LOOKUP_NAMES access.

2. Obtain a SID (security identifier) representing the user/group of
   interest. The LookupAccountName() and LsaLookupNames() APIs can obtain a
   SID from an account name.

3. Call LsaAddAccountRights() to grant privileges to the user(s)
   represented by the supplied SID.

4. Call LsaRemoveAccountRights() to revoke privileges from the user(s)
   represented by the supplied SID.

5. Close the policy with LsaClose().

To successfully grant and revoke privileges, the caller needs to be an
administrator on the target system.

The LSA API LsaEnumerateAccountRights() can be used to determine which
privileges have been granted to an account.

The LSA API LsaEnumerateAccountsWithUserRight() can be used to determine
which accounts have been granted a specified privilege.

Documentation and header files for these LSA APIs is provided in the
Windows 32 SDK in the MSTOOLS\SECURITY directory.

NOTE: These LSA APIs are currently implemented as Unicode only.

This sample will grant the privilege SeServiceLogonRight to the account
specified on argv[1].

This sample is dependant on these import libs

   advapi32.lib (for LsaXxx)
   user32.lib (for wsprintf)

This sample will work properly compiled ANSI or Unicode.



You can use domain\account as argv[1]. For instance, mydomain\scott will
grant the privilege to the mydomain domain account scott.

The optional target machine is specified as argv[2], otherwise, the
account database is updated on the local machine.

The LSA APIs used by this sample are Unicode only.

Use LsaRemoveAccountRights() to remove account rights.

Scott Field (sfield)    12-Jul-95

--*/

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#include <windows.h>
#include <stdio.h>
#include <ntsecapi.h>
#include <shlwapi.h>

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#endif

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

LPTSTR
ConvertTimeToString(
    LARGE_INTEGER time              // Kerberos time value
    );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );

void
DisplayNtStatus(
    LPSTR szAPI,                // pointer to function name (ANSI)
    NTSTATUS Status             // NTSTATUS error value
    );

void
DisplayWinError(
    LPSTR szAPI,                // pointer to function name (ANSI)
    DWORD WinError              // DWORD WinError
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

static LPCTSTR dt_output_dhms   = TEXT("%d %s %02d:%02d:%02d");
static LPCTSTR dt_day_plural    = TEXT("days");
static LPCTSTR dt_day_singular  = TEXT("day");
static LPCTSTR dt_output_donly  = TEXT("%d %s");
static LPCTSTR dt_output_hms    = TEXT("%d:%02d:%02d");

LPTSTR
ConvertTimeToString(
    LARGE_INTEGER time
    )
{
    int days, hours, minutes, seconds;
    DWORD tt;
    static TCHAR buf2[40];
#define TPS (10*1000*1000)
    DWORD dt = (long)(time.QuadPart / TPS);

    days = (int) (dt / (24*3600l));
    tt = dt % (24*3600l);
    hours = (int) (tt / 3600);
    tt %= 3600;
    minutes = (int) (tt / 60);
    seconds = (int) (tt % 60);

    if (days) {
        if (hours || minutes || seconds) {
            wnsprintf(buf2, sizeof(buf2)/sizeof(buf2[0]),
                      dt_output_dhms, days,
                      (days > 1) ? dt_day_plural : dt_day_singular,
                      hours, minutes, seconds);
        }
        else {
            wnsprintf(buf2, sizeof(buf2)/sizeof(buf2[0]),
                      dt_output_donly, days,
                      (days > 1) ? dt_day_plural : dt_day_singular);
        }
    }
    else {
        wnsprintf(buf2, sizeof(buf2)/sizeof(buf2[0]),
                  dt_output_hms, hours, minutes, seconds);
    }
    return(buf2);
}

int _cdecl main(
    int argc,
    char *argv[]
    )
{
    LSA_HANDLE PolicyHandle;
    WCHAR wComputerName[256]=L"";   // static machine name buffer
    NTSTATUS Status;
    int iRetVal=RTN_ERROR;          // assume error from main
    PPOLICY_DOMAIN_KERBEROS_TICKET_INFO KerbInfo;
    
    if (argc > 2)
    {
        fprintf(stderr,"Usage: %s [TargetMachine]\n",
            argv[0]);
        return RTN_USAGE;
    }

    //
    // Pick up machine name on argv[2], if appropriate
    // assumes source is ANSI. Resultant string is Unicode.
    //
    if (argc == 2)
        wnsprintf(wComputerName, sizeof(wComputerName)/sizeof(wComputerName[0]),
                  L"%hS", argv[1]);

    //
    // Default is to use the LOGONSERVER
    //

    if (argc==1)
    {
        GetEnvironmentVariable(
            L"LOGONSERVER",
            wComputerName,
            sizeof(wComputerName)/sizeof(wComputerName[0]));
    }

    //
    // Open the policy on the target machine.
    //
    if((Status=OpenPolicy(
                wComputerName,      // target machine
                MAXIMUM_ALLOWED,
                &PolicyHandle       // resultant policy handle
                )) != STATUS_SUCCESS) {
        DisplayNtStatus("OpenPolicy", Status);
        return RTN_ERROR;
    }

    //
    // Get the Kerberos policy
    //
    if ((Status=LsaQueryDomainInformationPolicy(
                    PolicyHandle,
                    PolicyDomainKerberosTicketInformation,
                    &KerbInfo)) != STATUS_SUCCESS)
    {
        DisplayNtStatus("LsaQueryDomainInformationPolicy", Status);
        return RTN_ERROR;
    }

    //
    // Print out the Kerberos information
    //
    printf("Authentication options: 0x%x\n", KerbInfo->AuthenticationOptions);
    printf("MaxServiceTicketAge: %S\n",
           ConvertTimeToString(KerbInfo->MaxServiceTicketAge));
    printf("MaxTicketAge: %S\n", ConvertTimeToString(KerbInfo->MaxTicketAge));
    printf("MaxRenewAge: %S\n", ConvertTimeToString(KerbInfo->MaxRenewAge));
    printf("MaxClockSkew: %S\n", ConvertTimeToString(KerbInfo->MaxClockSkew));

    //
    // Free buffer
    //
    LsaFreeMemory(KerbInfo);

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    return iRetVal;
}

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

void
DisplayNtStatus(
    LPSTR szAPI,
    NTSTATUS Status
    )
{
    //
    // Convert the NTSTATUS to Winerror. Then call DisplayWinError().
    //
    DisplayWinError(szAPI, LsaNtStatusToWinError(Status));
}

void
DisplayWinError(
    LPSTR szAPI,
    DWORD WinError
    )
{
    LPSTR MessageBuffer;
    DWORD dwBufferLength;

    if(dwBufferLength = FormatMessageA(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            WinError,
                            GetUserDefaultLangID(),
                            (LPSTR) &MessageBuffer,
                            0,
                            NULL
                            ))
    {
        DWORD dwBytesWritten; // unused

        //
        // Output message string on stderr.
        //
        WriteFile(
            GetStdHandle(STD_ERROR_HANDLE),
            MessageBuffer,
            dwBufferLength,
            &dwBytesWritten,
            NULL
            );

        //
        // Free the buffer allocated by the system.
        //
        LocalFree(MessageBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbtray\kerbtray.c ===
/*--

Copyright (c) 1998  Microsoft Corporation

Module Name:

    kerbtray.c

Abstract:

    Displays a dialog with list of Kerberos tickets for the current user.

Author:

    14-Dec-1998 (jbrezak)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

   12-Apr-2002 JBrezak  Cleanup prefast issues and security review.

--*/

#define UNICODE
#define _UNICODE
#define STRICT
#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <commdlg.h>
#include <time.h>
#include <assert.h>
#include <string.h>
#include <malloc.h>
#define SECURITY_WIN32
#include <security.h>
#include <ntsecapi.h>

#ifndef NO_CRYPTDLL
#include "cryptdll.h"
#endif
#include "kerbtray.h"

#define SEC_SUCCESS(Status) ((Status) >= 0)
#define TSIZE(b) (sizeof(b)/sizeof(TCHAR))

#define IDI_FIRST_CLOCK IDI_0_MIN
#define IDI_LAST_CLOCK  IDI_TICKET
#define MAX_ICONS (IDI_LAST_CLOCK - IDI_FIRST_CLOCK + 1)

#define KWIN_UPDATE_PERIOD 60000       // Every 60 seconds update the screen

#define PPAGE_NAMES     0
#define PPAGE_TIMES     1
#define PPAGE_FLAGS     2
#define PPAGE_ETYPES    3
#define C_PAGES 4

#define CX_ICON 20
#define CY_ICON 20

#define TPS (10*1000*1000)

typedef struct
{
    HWND hwndTab;
    HWND hwndDisplay;
    RECT rcDisplay;
    DLGTEMPLATE *apRes[C_PAGES];
    PKERB_QUERY_TKT_CACHE_RESPONSE Tickets;
} DLGTABHDR;

OSVERSIONINFO osvers;
HWND hWnd, hDlgTickets;
HINSTANCE hInstance;
HANDLE hModule;
#define SHORTSTRING 40
#define LONGSTRING 256
TCHAR progname[SHORTSTRING];
ULONG PackageId;
HANDLE LogonHandle = NULL;
HWND hWndUsers;
HIMAGELIST himl;
HTREEITEM tgt = NULL;

static HICON kwin_icons[MAX_ICONS];    // Icons depicting time
static INT domain_icon;
static LPCTSTR dt_output_dhms   = TEXT("%d %s %02d:%02d:%02d");
static LPCTSTR dt_day_plural    = TEXT("days");
static LPCTSTR dt_day_singular  = TEXT("day");
static LPCTSTR dt_output_donly  = TEXT("%d %s");
static LPCTSTR dt_output_hms    = TEXT("%d:%02d:%02d");
static LPCTSTR ftime_default_fmt        = TEXT("%02d/%02d/%02d %02d:%02d");

#define WM_NOTIFY_ICON  (WM_APP+100)

#ifndef NO_CRYPTDLL
typedef NTSTATUS (NTAPI *CDLOCATECSYSTEM)(ULONG dwEtype, PCRYPTO_SYSTEM * ppcsSystem);

CDLOCATECSYSTEM pCDLocateCSystem;
#endif

LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK AboutProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK TicketsProc(HWND, UINT, WPARAM, LPARAM);
void About(void);
void Tickets(void);
void PurgeCache(void);
void PropsheetDisplay(HWND hDlg);
void SelectTicket(HWND hDlg);
void FillinTicket(HWND hDlg);
LPTSTR etype_string(int enctype);
LPTSTR GetStringRes(int);

#ifdef DEBUG
#define DPRINTF(s) dprintf s

int debug = 1;

void dprintf(LPCTSTR fmt, ...)
{
    TCHAR szTemp[512];
    va_list ap;

    if (!debug)
        return;

    va_start (ap, fmt);
#ifdef UNICODE
    _vsnwprintf(szTemp, TSIZE(szTemp), fmt, ap);
#else
    _vsnprintf(szTemp, TSIZE(szTemp), fmt, ap);
#endif
    szTemp[TSIZE(szTemp)-1] = 0;

    OutputDebugString(szTemp);
    va_end (ap);
}
#else
#define DPRINTF(s)
#endif

void
ShowMessage(int level, LPCTSTR msg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    if (level)
        MessageBeep(level);
    MessageBox(NULL, msg, progname,
               level | MB_OK | MB_TASKMODAL | MB_SETFOREGROUND);
}

void
Error(LPCTSTR fmt, ...)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TCHAR szTemp[512];

    va_list ap;
    va_start (ap, fmt);
#ifdef UNICODE
    _vsnwprintf(szTemp, TSIZE(szTemp), fmt, ap);
#else
    _vsnprintf(szTemp, TSIZE(szTemp), fmt, ap);
#endif
    szTemp[TSIZE(szTemp)-1] = 0;
    
    OutputDebugString(szTemp);
    ShowMessage(MB_ICONINFORMATION, szTemp);
    va_end (ap);
}

void
ErrorExit(LPCTSTR lpszMessage)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MessageBox(hWnd, lpszMessage, TEXT("Error"), MB_OK);
    ExitProcess(0);
}

int
GetIconIndex(long dt)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    int ixicon;

    dt = dt / 60;                       // convert to minutes
    if (dt <= 0)
        ixicon = IDI_EXPIRED - IDI_FIRST_CLOCK;
    else if (dt > 60)
        ixicon = IDI_TICKET - IDI_FIRST_CLOCK;
    else
        ixicon = (int)(dt / 5);

    return ixicon;
}

void
SetTray(
    HWND hwnd,
    HICON hIcon,
    LPCTSTR tip
    )
/*++

Routine Description:

    Activate or update the tray icon

Arguments:

Return Value:

--*/
{
    static tray_inited = 0;
    NOTIFYICONDATA tnd;

    tnd.cbSize = sizeof(NOTIFYICONDATA);
    tnd.hWnd = hwnd;
    tnd.uID = IDI_KDC;
    tnd.uFlags = NIF_MESSAGE|NIF_ICON|NIF_TIP;
    tnd.uCallbackMessage = WM_NOTIFY_ICON;
    tnd.hIcon = hIcon;

    StrNCpy(tnd.szTip, tip, TSIZE(tnd.szTip));

    Shell_NotifyIcon((tray_inited)?NIM_MODIFY:NIM_ADD, &tnd);

    if (tray_inited == 0)
        tray_inited++;

    DestroyIcon(tnd.hIcon);
}

void
DeleteTray(HWND hwnd)
/*++

Routine Description:

    Remove the tray icon

Arguments:

Return Value:

--*/
{
    NOTIFYICONDATA tnd;

    tnd.cbSize = sizeof(NOTIFYICONDATA);
    tnd.hWnd = hwnd;
    tnd.uID = IDI_KDC;
    tnd.uFlags = NIF_MESSAGE|NIF_ICON|NIF_TIP;
    tnd.uCallbackMessage = WM_NOTIFY_ICON;
    tnd.hIcon = NULL;
    tnd.szTip[0] = '\0';

    Shell_NotifyIcon(NIM_DELETE, &tnd);
}

BOOL
UpdateTray(HWND hwnd)
/*++

Routine Description:

    Update the tray icon based on the time to live of the TGT

Arguments:

Return Value:

--*/
{
    HICON hicon;
    TCHAR buf[SHORTSTRING];
    BOOL expired = FALSE;
    NTSTATUS Status, SubStatus;
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_RETRIEVE_TKT_RESPONSE TicketEntry = NULL;
    PKERB_EXTERNAL_TICKET Ticket;
    ULONG ResponseSize;
    FILETIME CurrentFileTime;
    LARGE_INTEGER Quad;
    long dt = 0L;
    int days, hours, minutes, seconds;
    DWORD tt;
    TCHAR buf2[SHORTSTRING];

    StrNCpy(buf, progname, TSIZE(buf));

    //
    // Get the TGT from the ticket cache
    //
    CacheRequest.MessageType = KerbRetrieveTicketMessage;
    CacheRequest.LogonId.LowPart = 0;
    CacheRequest.LogonId.HighPart = 0;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          (PVOID *) &TicketEntry,
                                          &ResponseSize,
                                          &SubStatus);

    //
    // If no TGT, display the correct icon
    //
    if (!SEC_SUCCESS(Status) || !SEC_SUCCESS(SubStatus)) {
        hicon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_KDC));
        StrCatBuff(buf, GetStringRes(IDS_NO_CREDS), TSIZE(buf));
    }
    else {

    //
    // Select the correct icon based on the time left of the TGT
    //
        Ticket = &(TicketEntry->Ticket);

        GetSystemTimeAsFileTime(&CurrentFileTime);

        Quad.LowPart = CurrentFileTime.dwLowDateTime;
        Quad.HighPart = CurrentFileTime.dwHighDateTime;

        dt = (long)((Ticket->EndTime.QuadPart - Quad.QuadPart) / TPS);

        LsaFreeReturnBuffer(TicketEntry);

        hicon = kwin_icons[GetIconIndex(dt)];

        StrCatBuff(buf, TEXT(" - "), TSIZE(buf));

        if (dt <= 0) {
            StrCatBuff(buf, GetStringRes(IDS_EXPIRED), TSIZE(buf));
            expired = TRUE;
        }
        else {

            days = (int) (dt / (24*3600l));
            tt = dt % (24*3600l);
            hours = (int) (tt / 3600);
            tt %= 3600;
            minutes = (int) (tt / 60);
            seconds = (int) (tt % 60);

            if (days) {
                if (hours || minutes || seconds) {
                    _snwprintf(buf2, TSIZE(buf2), dt_output_dhms, days,
                   (days > 1) ? dt_day_plural : dt_day_singular,
                   hours, minutes, seconds);
                }
                else {
                    _snwprintf(buf2, TSIZE(buf2), dt_output_donly, days,
                   (days > 1) ? dt_day_plural : dt_day_singular);
                }
            }
            else {
                _snwprintf(buf2, TSIZE(buf2), dt_output_hms,
               hours, minutes, seconds);
            }
            _snwprintf(buf, TSIZE(buf), TEXT("%s %s"), progname, buf2);
        }
    }

    SetTray(hwnd, hicon, buf);
    return(expired);
}


BOOL
InitializeApp(
    HANDLE hInstance,
    int nCmdShow
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LSA_STRING Name;
    NTSTATUS Status;
    WNDCLASSEX wc;
    HWND hwnd;
    int i;

    //
    // Check for an existing instance
    //
    hwnd = FindWindow(TEXT("MainWindowClass"), TEXT("KerbTray"));
    if (hwnd) {
    //
        // Popup the tickets dialog, if one found
        // Run only one instance of kerbtray
    //
        SendMessage(hwnd, WM_NOTIFY_ICON, 0, WM_LBUTTONDBLCLK);
        ExitProcess(0);
    }

    hModule = GetModuleHandle(NULL);

    InitCommonControls();

    LoadString(hInstance, IDS_KRB5_NAME, progname, TSIZE(progname));

    //
    // Setup connection for LSA to Kerberos package
    //
    Status = LsaConnectUntrusted(&LogonHandle);
    if (!SEC_SUCCESS(Status)) {
        Error(TEXT("Failed to register as a logon process: 0x%x"), Status);
        return FALSE;
    }

    Name.Buffer = MICROSOFT_KERBEROS_NAME_A;
    Name.Length = (USHORT) strlen(Name.Buffer);
    Name.MaximumLength = Name.Length + 1;

    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!SEC_SUCCESS(Status)){
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return FALSE;
    }

    //
    // Create the image list.
    //
    if ((himl = ImageList_Create(CX_ICON, CY_ICON, ILC_COLOR, MAX_ICONS, 0)) == NULL)
        return FALSE;

    ImageList_SetBkColor(himl, CLR_NONE);

    for (i = IDI_FIRST_CLOCK; i <= IDI_LAST_CLOCK; i++) {
#ifndef COLOR_ICONS
        kwin_icons[i - IDI_FIRST_CLOCK] = LoadIcon(hInstance,
                                                   MAKEINTRESOURCE(i));
#else
        kwin_icons[i - IDI_FIRST_CLOCK] = LoadImage(hInstance,
                            MAKEINTRESOURCE(i),
                            IMAGE_ICON, 0, 0,
                            LR_DEFAULTCOLOR|LR_DEFAULTSIZE|LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS);
#endif
        (void) ImageList_AddIcon(himl, kwin_icons[i - IDI_FIRST_CLOCK]);
    }

#ifndef COLOR_ICONS
    domain_icon =  ImageList_AddIcon(himl,
                       LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DOMAIN)));
#else
    domain_icon =  ImageList_AddIcon(himl,
                       LoadImage(hInstance, MAKEINTRESOURCE(IDI_DOMAIN),
                 IMAGE_ICON, 0, 0,
                 LR_DEFAULTCOLOR|LR_DEFAULTSIZE|LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS));
#endif

    //
    // Register a window class for the main window.
    //
    wc.cbSize           = sizeof(WNDCLASSEX);
    wc.style            = CS_HREDRAW|CS_VREDRAW;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hModule, MAKEINTRESOURCE(IDI_EXPIRED));
    wc.hIconSm          = LoadIcon(hModule, MAKEINTRESOURCE(IDI_EXPIRED));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName     = 0;
    wc.lpszClassName    = TEXT("MainWindowClass");

    if (!RegisterClassEx(&wc)) {
        Error(TEXT("RegisterClassEx failed"));
        return FALSE;
    }

    //
    // Create the main window
    //
    hWnd = CreateWindowEx(WS_EX_APPWINDOW,
                          TEXT("MainWindowClass"),
                          TEXT("KerbTray"),
                          WS_OVERLAPPEDWINDOW,
                          0, 0,
                          5, 5,
                          NULL,
                          NULL,
                          hModule,
                          NULL);
    if (hWnd == NULL) {
        Error(TEXT("CreateWindowEx failed"));
        return FALSE;
    }

    ShowWindow(hWnd, SW_HIDE);

    return TRUE;
}

int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpszCmdLn,
    int nShowCmd
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MSG msg;
    HANDLE hAccelTable, hCryptDll;

    hInstance = hInst;
    hModule = GetModuleHandle(NULL);

    osvers.dwOSVersionInfoSize = sizeof(osvers);
    GetVersionEx(&osvers);

#ifndef NO_CRYPTDLL
    hCryptDll = LoadLibrary(TEXT("CRYPTDLL.DLL"));
    if (!hCryptDll)
        ErrorExit(TEXT("Unable to load cryptdll.dll"));

    pCDLocateCSystem = (CDLOCATECSYSTEM) GetProcAddress(hCryptDll, "CDLocateCSystem");
    if (!pCDLocateCSystem)
        ErrorExit(TEXT("Unable to link cryptdll.dll::CDLocateCSystem"));
#endif

    if (! InitializeApp(hInst, nShowCmd))
        ErrorExit(TEXT("InitializeApp failure"));

    hAccelTable = LoadAccelerators(hInst, TEXT("KerbTray"));

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(hDlgTickets, &msg)) {
            if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    return 1;

    UNREFERENCED_PARAMETER(hPrevInst);
    UNREFERENCED_PARAMETER(lpszCmdLn);
}

LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    POINT pos;
    static HMENU hPopupMenu;

    switch (uiMessage) {

    //
    // Someone clicked the icon
    //
    case WM_NOTIFY_ICON:
        switch (lParam) {

        case WM_LBUTTONDBLCLK:
            Tickets();
            return 0L;

        case WM_RBUTTONDOWN:
            if (hPopupMenu) {
                if (GetCursorPos(&pos)) {
                    if (TrackPopupMenu(hPopupMenu,
                       TPM_RIGHTALIGN|TPM_LEFTBUTTON,
                       pos.x, pos.y,
                       0, hwnd, NULL) == 0)
            Error(TEXT("TrackPopupMenuFailed: 0x%x"),
                  GetLastError());
        }
            }
            return 0L;
        }
        break;

    //
        // Create a client windows
    //
    case WM_CREATE:
        hPopupMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
        if (!hPopupMenu)
            Error(TEXT("LoadMenu failed %d"), GetLastError());

        hPopupMenu = GetSubMenu(hPopupMenu, 0);
        if (!hPopupMenu)
            Error(TEXT("LoadMenu failed %d"), GetLastError());

        (void) UpdateTray(hwnd);

    //
        // Start timer for watching the TGT
    //
        if (!SetTimer(hwnd, 1, KWIN_UPDATE_PERIOD, NULL)) {
            ErrorExit(TEXT("SetTimer failed"));
        }
        return 0L;


    //
    // Update the tray icon
    //
    case WM_TIMER:
        (void) UpdateTray(hwnd);
        return(0L);

    case WM_ENDSESSION:
        return(0L);

        //
    // Close the main window.  First set fKillAll to TRUE to
    // terminate all threads.  Then wait for the threads to exit
    // before passing a close message to a default handler.  If you
    // don't wait for threads to terminate, process terminates
    // with no chance for thread cleanup.
    //
    case WM_CLOSE:
    exit:;
    {
        DeleteTray(hWnd);
        KillTimer(hWnd, 1);
        PostQuitMessage(0);
        return 0L;
    }

        //
        // Terminate the process
        //
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0L;


        //
        // Handle the menu commands
    //

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case ID_ABOUT:
            About();
            return 0L;

        case ID_TICKETS:
            Tickets();
            return 0L;

        case ID_PURGE:
            PurgeCache();
            return 0L;

        case ID_EXIT:
            goto exit;
        }
    }
    return DefWindowProc(hwnd, uiMessage, wParam, lParam);
}


LPTSTR
GetStringRes(int id)
/*++

Routine Description:

    Load a string from the resources

Arguments:

Return Value:

--*/
{
  static TCHAR buffer[MAX_PATH];

  buffer[0] = 0;
  LoadString(GetModuleHandle (NULL), id, buffer, MAX_PATH);
  return buffer;
}

LRESULT CALLBACK
AboutProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static  HFONT hfontDlg;             // Font for dialog text
    DWORD   dwVerInfoSize;              // Size of version information block
    LPTSTR  lpVersion;                  // String pointer to 'version' text
    DWORD   dwVerHnd = 0;               // An 'ignored' parameter, always '0'
    UINT    uVersionLen;
    DWORD   wRootLen;
    BOOL    bRetCode;
    int     i;
    TCHAR    szFullPath[LONGSTRING];
    TCHAR    szResult[LONGSTRING];
    TCHAR    szGetName[LONGSTRING];
    TCHAR    szVersion[SHORTSTRING];
    DWORD   dwResult;
    int     resmap[6] = {
        IDC_COMPANY,
        IDC_FILEDESC,
        IDC_PRODVER,
        IDC_COPYRIGHT,
        IDC_OSVERSION,
    };
    LPSTR   lpstrVffInfo;
    HANDLE  hMem;

    switch (message) {
    case WM_INITDIALOG:
        ShowWindow(hDlg, SW_HIDE);
        hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              VARIABLE_PITCH | FF_SWISS, TEXT(""));
        GetModuleFileName(hInstance, szFullPath, TSIZE(szFullPath));
        szFullPath[TSIZE(szFullPath) - 1] = 0;

    //
        // Now lets dive in and pull out the version information:
    //
        dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &dwVerHnd);
        if (dwVerInfoSize) {

            hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);

        if (!hMem) {
        ErrorExit(TEXT("Unable to allocate memory"));
        }
            lpstrVffInfo  = GlobalLock(hMem);
        if (!lpstrVffInfo) {
        ErrorExit(TEXT("Unable to lock memory"));
        }
    
            GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo);
            //
        // The below 'hex' value looks a little confusing, but
        // essentially what it is, is the hexidecimal representation
        // of a couple different values that represent the language
        // and character set that we are wanting string values for.
        // 040904E4 is a very common one, because it means:
        // US English, Windows MultiLingual characterset
        // Or to pull it all apart:
        // 04------        = SUBLANG_ENGLISH_USA
        // --09----        = LANG_ENGLISH
        // ----04E4 = 1252 = Codepage for Windows:Multilingual
        //
            StrNCpy(szGetName, GetStringRes(IDS_VER_INFO_LANG), TSIZE(szGetName));

            wRootLen = lstrlen(szGetName); // Save this position

        //
            // Set the title of the dialog
        //
            StrCatBuff(szGetName, TEXT("ProductName"), TSIZE(szGetName));
            bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
                                     (LPTSTR)szGetName,
                                     (LPVOID)&lpVersion,
                                     (UINT *)&uVersionLen);
            StrNCpy(szResult, TEXT("About "), TSIZE(szResult));
            StrCatBuff(szResult, lpVersion, TSIZE(szResult));
            SetWindowText(hDlg, szResult);

            //
        // Walk through the dialog items that we want to replace
        //
            for (i = 0; i < 6; i++) {
                GetDlgItemText(hDlg, resmap[i], szResult, TSIZE(szResult));
                szGetName[wRootLen] = TEXT('\0');
                StrCatBuff(szGetName, szResult, TSIZE(szGetName));
                uVersionLen = 0;
                lpVersion = NULL;
                bRetCode =  VerQueryValue((LPVOID)lpstrVffInfo,
                                          (LPTSTR)szGetName,
                                          (LPVOID)&lpVersion,
                                          (UINT *)&uVersionLen);

                if ( bRetCode && uVersionLen && lpVersion) {
                    // Replace dialog item text with version info
                    StrNCpy(szResult, lpVersion, TSIZE(szResult));
                    SetDlgItemText(hDlg, resmap[i], szResult);
                } else {
                    dwResult = GetLastError();
                    _snwprintf(szResult, TSIZE(szResult),
                   TEXT("Error %lu"), dwResult);
                    SetDlgItemText (hDlg, resmap[i], szResult);
                }
                SendMessage(GetDlgItem(hDlg, resmap[i]), WM_SETFONT,
                            (WPARAM)hfontDlg,
                            TRUE);
            }
            GlobalUnlock(hMem);
            GlobalFree(hMem);

        }
    else {

            // No version information available
        }

        SendMessage(GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT,
                    (WPARAM)hfontDlg,(LPARAM)TRUE);

        _snwprintf(szVersion, TSIZE(szVersion),
           TEXT("Microsoft Windows %u.%u (Build: %u)"),
           osvers.dwMajorVersion,
           osvers.dwMinorVersion,
           osvers.dwBuildNumber);
        
        szVersion[SHORTSTRING - 1] = 0;

        SetWindowText(GetDlgItem(hDlg, IDC_OSVERSION), szVersion);
        ShowWindow(hDlg, SW_SHOW);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        }
    }
    return FALSE;
}

void
About(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_ABOUT), hWnd, AboutProc);
}

#define CheckDlgButtonFlag(b, f) \
    CheckDlgButton(hDlg, b, (flags & f)?BST_CHECKED:BST_UNCHECKED)

VOID
ShowFlags(HWND hDlg, ULONG flags)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CheckDlgButtonFlag(IDC_FORWARDABLE, KERB_TICKET_FLAGS_forwardable);
    CheckDlgButtonFlag(IDC_FORWARDED, KERB_TICKET_FLAGS_forwarded);
    CheckDlgButtonFlag(IDC_PROXIABLE, KERB_TICKET_FLAGS_proxiable);
    CheckDlgButtonFlag(IDC_PROXY, KERB_TICKET_FLAGS_proxy);
    CheckDlgButtonFlag(IDC_MAY_POSTDATE, KERB_TICKET_FLAGS_may_postdate);
    CheckDlgButtonFlag(IDC_POSTDATED, KERB_TICKET_FLAGS_postdated);
    CheckDlgButtonFlag(IDC_INVALID, KERB_TICKET_FLAGS_invalid);
    CheckDlgButtonFlag(IDC_RENEWABLE, KERB_TICKET_FLAGS_renewable);
    CheckDlgButtonFlag(IDC_INITIAL, KERB_TICKET_FLAGS_initial);
    CheckDlgButtonFlag(IDC_HWAUTH, KERB_TICKET_FLAGS_hw_authent);
    CheckDlgButtonFlag(IDC_PREAUTH, KERB_TICKET_FLAGS_pre_authent);
    CheckDlgButtonFlag(IDC_OK_AS_DELEGATE, KERB_TICKET_FLAGS_ok_as_delegate);
}

LPTSTR
ETypeString(
    int enctype
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
#ifndef NO_CRYPTDLL
    static PCRYPTO_SYSTEM pcsSystem;
    static TCHAR buf[12] = {0};

    if (pCDLocateCSystem(enctype, &pcsSystem) == S_OK)
        return pcsSystem->Name;
    else {
        _snwprintf(buf, TSIZE(buf), TEXT("etype %d"), enctype);
        buf[11] = 0;
        return buf;
    }
#else
    static TCHAR buf[12];

    switch (enctype) {
    case KERB_ETYPE_NULL:
        return TEXT("NULL");
        break;
    case KERB_ETYPE_DES_CBC_CRC:
        return TEXT("Kerberos DES-CBC-CRC");
        break;
    case KERB_ETYPE_DES_CBC_MD5:
        return TEXT("Kerberos DES-CBC-MD5");
        break;
    case KERB_ETYPE_RC4_MD4:
        return TEXT("RSADSI RC4-MD4");
        break;
    case KERB_ETYPE_RC4_PLAIN2:
        return TEXT("RSADSI RC4-PLAIN");
        break;
    case KERB_ETYPE_RC4_LM:
        return TEXT("RSADSI RC4-LM");
        break;
    case KERB_ETYPE_DES_PLAIN:
        return TEXT("Kerberos DES-Plain");
        break;
#ifdef KERB_ETYPE_RC4_HMAC
    case KERB_ETYPE_RC4_HMAC:
        return TEXT("RSADSI RC4-HMAC");
        break;
#endif
    case KERB_ETYPE_RC4_PLAIN:
        return TEXT("RSADSI RC4");
        break;
#ifdef KERB_ETYPE_RC4_HMAC_EXP
    case KERB_ETYPE_RC4_HMAC_EXP:
        return TEXT("RSADSI RC4-HMAC(Export)");
        break;
#endif
    case KERB_ETYPE_RC4_PLAIN_EXP:
        return TEXT("RSADSI RC4(Export)");
        break;
    case KERB_ETYPE_DES_CBC_MD5_EXP:
        return TEXT("Kerberos DES-CBC-MD5-EXP(Export)");
        break;
    case KERB_ETYPE_DES_PLAIN_EXP:
        return TEXT("Kerberos DES-Plain(Export)");
        break;
    default:
        _snwprintf(buf, TSIZE(buf), TEXT("etype %d"), enctype);
        buf[11] = 0;
        return buf;
        break;
    }
#endif
}

LPTSTR
TimeString(TimeStamp ConvertTime)
/*++

Routine Description:

    Convert a TimeStamp into something readable

Arguments:

Return Value:

--*/
{
    SYSTEMTIME SystemTime;
    FILETIME LocalFileTime;
    static TCHAR buf[LONGSTRING];

    if (ConvertTime.HighPart == 0x7FFFFFFF &&
        ConvertTime.LowPart == 0xFFFFFFFF) {

        return(GetStringRes(IDS_INFINITE));
    }

    if (FileTimeToLocalFileTime(
        (PFILETIME) &ConvertTime,
        &LocalFileTime) &&
        FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime)) {

        _snwprintf(buf, TSIZE(buf), ftime_default_fmt,
           SystemTime.wMonth,
           SystemTime.wDay,
           SystemTime.wYear,
           SystemTime.wHour,
           SystemTime.wMinute);

    buf[TSIZE(buf)-1] = 0;

    }
    else
        return(GetStringRes(IDS_INVALID));

    return(buf);
}

DLGTEMPLATE * WINAPI
DoLockDlgRes(LPCTSTR lpszResName)
/*++

Routine Description:

    loads and locks a dialog template resource

Arguments:

    lpszResName - name of the resource

Return Value:

    Returns the address of the locked resource.

--*/
{
    HRSRC hrsrc;
    HGLOBAL hglb;
    DLGTEMPLATE *pDlg;

    hrsrc = FindResource(NULL, lpszResName, RT_DIALOG);
    if (!hrsrc) {
        Error(TEXT("Unable to locate resource '%s'"), lpszResName);
    ExitProcess(0);
    }

    hglb = LoadResource(hInstance, hrsrc);
    if (!hglb) {
        Error(TEXT("Unable to load resource '%s'"), lpszResName);
    ExitProcess(0);
    }

    pDlg = (DLGTEMPLATE *)LockResource(hglb);
    if (!pDlg) {
        Error(TEXT("Unable to lock resource '%s'"), lpszResName);
    ExitProcess(0);
    }

    return pDlg;
}


void
PurgeCache(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KERB_PURGE_TKT_CACHE_REQUEST CacheRequest;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS Status, SubStatus;

    memset(&CacheRequest, 0, sizeof(CacheRequest));

    //
    // Purge all tickets in the cache
    //
    CacheRequest.MessageType = KerbPurgeTicketCacheMessage;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          &Response,
                                          &ResponseSize,
                                          &SubStatus);

    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {
        ShowMessage(MB_ICONINFORMATION, GetStringRes(IDS_PURGED));
    }
    else {
        Error(TEXT("Failed to purge ticket cache - 0x%x"), Status);
    }

    if (Response != NULL) {
        LsaFreeReturnBuffer(Response);
    }
}

HTREEITEM
AddOneItem(
    HTREEITEM hParent,
    LPTSTR szText,
    HTREEITEM hInsAfter,
    int iImage,
    HWND hwndTree,
    LPARAM lParam
)
/*++

Routine Description:

    Add the item to the specified TreeView

Arguments:

Return Value:

--*/
{
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;

    tvI.mask = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_PARAM;
    tvI.pszText = szText;
    tvI.cchTextMax = lstrlen(szText);
    tvI.lParam = lParam;
    tvI.iImage = iImage;
    tvI.iSelectedImage = iImage;

    tvIns.item = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;

    hItem = TreeView_InsertItem(hwndTree, &tvIns);
    return(hItem);
}

HTREEITEM
FindDomainByName(LPTSTR name)
/*++

Routine Description:

    Find the tree for the specified Domain

Arguments:

Return Value:

--*/
{
    HTREEITEM dom = NULL;
    TVITEM item;
    TCHAR buf[LONGSTRING];

    dom = TreeView_GetRoot(hWndUsers);
    if (!dom)
        return NULL;

    do {

        item.mask = TVIF_TEXT;
        item.pszText = buf;
        item.cchTextMax = sizeof(buf);
        item.hItem = dom;
        if (TreeView_GetItem(hWndUsers, &item)) {
            if (wcscmp(name, buf) == 0) {
                return dom;
            }
        }
    } while (dom = TreeView_GetNextSibling(hWndUsers, dom));

    return NULL;
}

HTREEITEM
AddDomain(
    LPTSTR name
)
/*++

Routine Description:

   Add the named Domain to the tree

Arguments:

Return Value:

--*/
{
    HTREEITEM hItem;

    if (!(hItem = FindDomainByName(name))) {
        hItem = AddOneItem(NULL, _wcsdup(name), TVI_ROOT,
                                        domain_icon, hWndUsers, 0);
    }
    return(hItem);
}

HTREEITEM
FindTicketByName(HTREEITEM lip, LPTSTR name)
/*++

Routine Description:

    Find a ticket by name in the tree

Arguments:

Return Value:

--*/
{
    HTREEITEM tick = NULL;
    TVITEM item;
    TCHAR buf[LONGSTRING];

    tick = TreeView_GetChild(hWndUsers, lip);
    if (!tick)
        return NULL;

    do {
        item.mask = TVIF_TEXT;
        item.pszText = buf;
        item.cchTextMax = sizeof(buf);
        item.hItem = tick;
        if (TreeView_GetItem(hWndUsers, &item)) {
            if (wcscmp(name, buf) == 0) {
                return tick;
            }
        }
    } while (tick = TreeView_GetNextSibling(hWndUsers, tick));

    return NULL;
}

HTREEITEM
AddTicket(
    HTREEITEM dom,
    LPTSTR name,
    int idx,
    LPARAM lParam
)
/*++

Routine Description:

    Add a ticket to the domain branch.

Arguments:

Return Value:

--*/
{
    HTREEITEM hItem;

    hItem = AddOneItem(dom, name, TVI_SORT, idx, hWndUsers, lParam);
    TreeView_Expand(hWndUsers, dom, TVE_EXPAND);

    return(hItem);
}

void
ShowTicket(
    HWND hDlg,
    PKERB_TICKET_CACHE_INFO tix,
    int i,
    BOOL ShowExpiredTickets
    )
/*++

Routine Description:

    Updates a Ticket for display

Arguments:

Return Value:

--*/
{
    TCHAR sname[LONGSTRING];
    HTREEITEM dom, tick;
    FILETIME CurrentFileTime;
    LARGE_INTEGER Quad;
    long dt = 0L;

    memset(sname, 0, sizeof(sname));

    //
    // Calculate ticket lifetime
    //
    GetSystemTimeAsFileTime(&CurrentFileTime);

    Quad.LowPart = CurrentFileTime.dwLowDateTime;
    Quad.HighPart = CurrentFileTime.dwHighDateTime;

    dt = (long)((tix->EndTime.QuadPart - Quad.QuadPart) / TPS);

    //
    // Only display valid tickets
    //
    if (dt > 0 || ShowExpiredTickets)
    {
        //
        // Add realm to tree control
        //
        swprintf(sname, TEXT("%wZ"), &tix->RealmName);
        dom = AddDomain(sname);

        //
        // Add ticket under realm
        //
        swprintf(sname, TEXT("%wZ"), &tix->ServerName);

        tick = AddTicket(dom, sname, GetIconIndex(dt), (LPARAM)tix);

        //
        // Look for initial TGT
        //
        if (tix->TicketFlags & KERB_TICKET_FLAGS_initial)
            tgt = tick;
    }
}

void
DisplayCreds(
    HWND hDlg
    )
/*++

Routine Description:

    Get the list of tickets to display

Arguments:

Return Value:

--*/
{
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_RETRIEVE_TKT_RESPONSE TicketEntry = NULL;
    PKERB_EXTERNAL_TICKET Ticket;
    NTSTATUS Status, SubStatus;
    ULONG ResponseSize;
    DWORD i;
    DLGTABHDR *pHdr;
    TCITEM tie;
    DWORD dwDlgBase = GetDialogBaseUnits();
    int cxMargin = LOWORD(dwDlgBase) / 4;
    int cyMargin = HIWORD(dwDlgBase) / 8;
    RECT rcTab;
    static TCHAR princ[LONGSTRING];

    pHdr  = (DLGTABHDR *) LocalAlloc(LPTR|LMEM_ZEROINIT, sizeof(DLGTABHDR));
    if (!pHdr)
        ErrorExit(TEXT("Unable to allocate memory"));

    //
    // Save a pointer to the DLGHDR structure.
    //
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pHdr);

    pHdr->hwndTab = GetDlgItem(hDlg, IDC_TAB_ATTRIBUTES);

    hWndUsers = GetDlgItem(hDlg, IDC_TICKETS);

    //
    // Associate the image list with the tree view control.
    //
    //TreeView_SetImageList(hWndUsers, himl, TVSIL_NORMAL);

    //
    // Add a tab for each of the three child dialog boxes.
    //
    tie.mask = TCIF_TEXT | TCIF_IMAGE;
    tie.iImage = -1;
    tie.pszText = GetStringRes(IDS_LNAMES);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_NAMES, &tie);
    tie.pszText = GetStringRes(IDS_LTIMES);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_TIMES, &tie);
    tie.pszText = GetStringRes(IDS_LFLAGS);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_FLAGS, &tie);
    tie.pszText = GetStringRes(IDS_LENCTYPE);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_ETYPES, &tie);

    //
    // Lock the resources for the three child dialog boxes.
    //
    pHdr->apRes[PPAGE_NAMES] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_NAMES));
    pHdr->apRes[PPAGE_TIMES] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_TIMES));
    pHdr->apRes[PPAGE_FLAGS] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_TKT_FLAGS));
    pHdr->apRes[PPAGE_ETYPES] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_ENCTYPES));

    //
    // Determine the bounding rectangle for all child dialog boxes.
    //
    SetRectEmpty(&rcTab);
    for (i = 0; i < C_PAGES; i++) {
        if (pHdr->apRes[i]->cx > rcTab.right)
            rcTab.right = pHdr->apRes[i]->cx;
        if (pHdr->apRes[i]->cy > rcTab.bottom)
            rcTab.bottom = pHdr->apRes[i]->cy;
    }
    rcTab.right = rcTab.right * LOWORD(dwDlgBase) / 4;
    rcTab.bottom = rcTab.bottom * HIWORD(dwDlgBase) / 8;

    //
    // Calculate how large to make the tab control, so
    // the display area can accommodate all the child dialog boxes.
    //
    TabCtrl_AdjustRect(pHdr->hwndTab, TRUE, &rcTab);
    OffsetRect(&rcTab, cxMargin - rcTab.left,
            cyMargin - rcTab.top);

    //
    // Calculate the display rectangle.
    //
    CopyRect(&pHdr->rcDisplay, &rcTab);
    TabCtrl_AdjustRect(pHdr->hwndTab, FALSE, &pHdr->rcDisplay);

    //
    // Get the User's TGT for the client name
    //
    CacheRequest.MessageType = KerbRetrieveTicketMessage;
    CacheRequest.LogonId.LowPart = 0;
    CacheRequest.LogonId.HighPart = 0;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          (PVOID *) &TicketEntry,
                                          &ResponseSize,
                                          &SubStatus);

    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {

    //
    // Got the cname/crealm format it and display
    //
        Ticket = &(TicketEntry->Ticket);
        memset(princ, 0, sizeof(princ));
        swprintf(princ, TEXT("%wZ@%wZ"),
                 &Ticket->ClientName->Names[0],
                 &Ticket->DomainName);
        SetDlgItemText(hDlg, IDC_PRINC_LABEL, princ);
    }
    else {

    //
    // No TGT, clear out the client name
    //
        SetDlgItemText(hDlg, IDC_PRINC_LABEL,
                       GetStringRes(IDS_NO_NET_CREDS));
        SetDlgItemText(hDlg, IDC_PRINC_START,
                       TEXT(""));

        if (TicketEntry)
            LsaFreeReturnBuffer(TicketEntry);

        return;
    }

    //
    // Done with the TGT
    //
    if (TicketEntry) {
        LsaFreeReturnBuffer(TicketEntry);
        TicketEntry = NULL;
    }

    //
    // Get the list of cached tickets
    //
    CacheRequest.MessageType = KerbQueryTicketCacheMessage;
    CacheRequest.LogonId.LowPart = 0;
    CacheRequest.LogonId.HighPart = 0;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          (PVOID *) &pHdr->Tickets,
                                          &ResponseSize,
                                          &SubStatus);

    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {

        for (i = 0; i < pHdr->Tickets->CountOfTickets; i++) {

            ShowTicket(hDlg, &pHdr->Tickets->Tickets[i], i, FALSE);
        }
    }

    //
    // Position the selection on the initial TGT
    //
    if (tgt)
        TreeView_SelectItem(hWndUsers, tgt);

    PropsheetDisplay(hDlg);
    SelectTicket(hDlg);
}

LRESULT CALLBACK
PropSheetProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DLGTABHDR *pHdr;
    HWND hwndParent = GetParent(hDlg);

    hwndParent = GetParent(hwndParent);
    pHdr = (DLGTABHDR *) GetWindowLongPtr(hwndParent, GWLP_USERDATA);

    switch (message) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOP,
                     pHdr->rcDisplay.left, pHdr->rcDisplay.top,
                     0, 0, SWP_NOSIZE);
        return TRUE;
    }

    return FALSE;
}

void
PropsheetDisplay(HWND hDlg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DLGTABHDR *pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int iSel = TabCtrl_GetCurSel(pHdr->hwndTab);

    //
    // Destroy the current child dialog box, if any.
    //
    if (pHdr->hwndDisplay != NULL)
        DestroyWindow(pHdr->hwndDisplay);

    //
    // Create the new child dialog box.
    //
    pHdr->hwndDisplay = CreateDialogIndirect(hInstance, pHdr->apRes[iSel],
                                             pHdr->hwndTab, PropSheetProc);

}

INT
UnparseExternalName(
    PKERB_EXTERNAL_NAME iName,
    PUNICODE_STRING *np
)
/*++

Routine Description:

    Format the name list into a "/" seperated name for display.

Arguments:

Return Value:

--*/
{
    int len, cnt;
    PUNICODE_STRING name;

    for (len = 0, cnt = 0; cnt < iName->NameCount; cnt++) {
        len += iName->Names[cnt].Length;
        if ((cnt + 1) < iName->NameCount)
            len += 2;
    }

    name = malloc(sizeof(UNICODE_STRING));
    if (!name)
        return -1;

    name->Buffer = malloc(len + 2);
    if (!name->Buffer) {
        free(name);
        return -1;
    }
    name->Length = 0;
    name->MaximumLength = len+2;
    memset(name->Buffer, 0, len + 2);

    for (cnt = 0; cnt < iName->NameCount; cnt++) {
        wcsncat(name->Buffer, iName->Names[cnt].Buffer, iName->Names[cnt].Length/2);
        name->Length += iName->Names[cnt].Length;
        if ((cnt + 1) < iName->NameCount) {
            wcsncat(name->Buffer, L"/", 1);
            name->Length += 2;
        }
    }
    *np = name;

    return 0;
}

VOID
FreeUnicodeString(
    PUNICODE_STRING ustr
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    if (ustr) {
        free(ustr->Buffer);
        free(ustr);
    }
}

void
SelectTicket(HWND hDlg)
/*++

Routine Description:

    Respond to the user clicking on a ticket in the tree

Arguments:

Return Value:

--*/
{
    DLGTABHDR *pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int iSel = TabCtrl_GetCurSel(pHdr->hwndTab);
    HTREEITEM hItem = TreeView_GetSelection(hWndUsers);
    TVITEM item;
    TCHAR sname[LONGSTRING];
    PKERB_TICKET_CACHE_INFO tix;
    FILETIME CurrentFileTime;
    LARGE_INTEGER Quad;
    long dt = 0L;

    //
    // No selection
    //
    if (!hItem)
        return;

    item.hItem = hItem;
    item.mask = TVIF_PARAM;
    item.lParam = 0;

    TreeView_GetItem(hWndUsers, &item);

    //
    // No info on the leaf
    //
    if (!item.lParam) {
        SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL,
                       GetStringRes(IDS_DOMAIN));
        SetDlgItemText(hDlg, IDC_SERVICE_PRINC, TEXT(""));
        FillinTicket(hDlg);
        return;
    }

    SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL,
                   GetStringRes(IDS_SERVICE_PRINCIPAL));

    tix = (PKERB_TICKET_CACHE_INFO)item.lParam;


    //
    // Calculate lifetime
    //
    GetSystemTimeAsFileTime(&CurrentFileTime);

    Quad.LowPart = CurrentFileTime.dwLowDateTime;
    Quad.HighPart = CurrentFileTime.dwHighDateTime;

    dt = (long)((tix->EndTime.QuadPart - Quad.QuadPart) / TPS);
    if (dt > 0) {

    swprintf(sname, TEXT("%wZ@%wZ"),
         &tix->ServerName,
         &tix->RealmName);

    SetDlgItemText(hDlg, IDC_SERVICE_PRINC, sname);
    }
    else {
    SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL,
               GetStringRes(IDS_EXPIRED));
        SetDlgItemText(hDlg, IDC_SERVICE_PRINC,
               TEXT(""));
    }

    FillinTicket(hDlg);
}


void
FillinTicket(HWND hDlg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PKERB_TICKET_CACHE_INFO tix;
    DLGTABHDR *pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int iSel = TabCtrl_GetCurSel(pHdr->hwndTab);
    HTREEITEM hItem = TreeView_GetSelection(hWndUsers);
    TVITEM item;
    PKERB_RETRIEVE_TKT_REQUEST TicketRequest;
    ULONG ResponseSize;
    NTSTATUS Status, SubStatus;
    PKERB_EXTERNAL_TICKET ticket;
    int sz;
    TCHAR sname[LONGSTRING];
    PUNICODE_STRING svc;

    if (!hItem)
        return;

    item.hItem = hItem;
    item.mask = TVIF_PARAM;
    item.lParam = 0;

    TreeView_GetItem(hWndUsers, &item);

    switch(iSel) {
    case PPAGE_NAMES:
        SetDlgItemText(pHdr->hwndDisplay, IDC_SERVICENAME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_TARGETNAME,
                       TEXT(""));
#if 0
        SetDlgItemText(pHdr->hwndDisplay, IDC_CLIENTNAME,
                       TEXT(""));
#endif
        break;

    case PPAGE_TIMES:
        SetDlgItemText(pHdr->hwndDisplay, IDC_STARTTIME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_ENDTIME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_RENEW_UNTIL,
                       TEXT(""));
        break;

    case PPAGE_ETYPES:
        SetDlgItemText(pHdr->hwndDisplay, IDC_TKT_ENCTYPE,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_KEY_ENCTYPE,
                       TEXT(""));
        break;

    case PPAGE_FLAGS:
        ShowFlags(pHdr->hwndDisplay, 0);
        break;
    }

    if (!item.lParam) {
        return;
    }


    //
    // Retrieve full ticket for properties
    //
    tix = (PKERB_TICKET_CACHE_INFO)item.lParam;

    swprintf(sname, TEXT("%wZ@%wZ"),
             &tix->ServerName,
             &tix->RealmName);

    sz = sizeof(WCHAR)*(wcslen(sname) + 1);

    TicketRequest = LocalAlloc(LMEM_ZEROINIT,
                               sizeof(KERB_RETRIEVE_TKT_REQUEST) + sz);

    if (!TicketRequest)
    ErrorExit(TEXT("Unable to allocate memory"));

    TicketRequest->MessageType = KerbRetrieveEncodedTicketMessage;
    TicketRequest->LogonId.LowPart = 0;
    TicketRequest->LogonId.HighPart = 0;
    TicketRequest->TargetName.Length = wcslen(sname) * sizeof(WCHAR);
    TicketRequest->TargetName.MaximumLength =
    TicketRequest->TargetName.Length + sizeof(WCHAR);
    TicketRequest->TargetName.Buffer = (LPWSTR) (TicketRequest + 1);
    wcsncpy(TicketRequest->TargetName.Buffer, sname, wcslen(sname));
    TicketRequest->CacheOptions = KERB_RETRIEVE_TICKET_USE_CACHE_ONLY;
    TicketRequest->EncryptionType = 0L;
    TicketRequest->TicketFlags = 0L;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          TicketRequest,
                                          (sizeof(KERB_RETRIEVE_TKT_REQUEST) + sz),
                                          (PVOID *)&ticket,
                                          &ResponseSize,
                                          &SubStatus);

    //
    // Don't need the request buffer anymore
    //
    LocalFree(TicketRequest);

    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {

        switch(iSel) {
        case PPAGE_NAMES:

        //
        // Get the service name for the ticket
        //
            if (ticket->ServiceName && ticket->DomainName.Length &&
                !UnparseExternalName(ticket->ServiceName, &svc)) {

                swprintf(sname, TEXT("%wZ@%wZ"),
                         svc,
                         &ticket->DomainName);
                SetDlgItemText(pHdr->hwndDisplay, IDC_SERVICENAME,
                               sname);
                FreeUnicodeString(svc);
            }

#if 0
        //
        // Get the client name from the buffer
        //
        // Bug - client name is wrong from the kerberos ssp. Use
        //   the TGT client name.
        //
            if (ticket->ClientName && ticket->DomainName.Length &&
                !UnparseExternalName(ticket->ClientName, &svc)) {

                swprintf(sname, TEXT("%wZ@%wZ"),
                         svc,
                         &ticket->DomainName);
                SetDlgItemText(pHdr->hwndDisplay, IDC_CLIENTNAME,
                               sname);
                FreeUnicodeString(svc);
            }
#endif

        //
        // Get the requested target name for the ticket
        //
            if (ticket->TargetName && ticket->TargetDomainName.Length &&
                !UnparseExternalName(ticket->TargetName, &svc)) {
                swprintf(sname, TEXT("%wZ@%wZ"),
                         svc,
                         &ticket->TargetDomainName);
                SetDlgItemText(pHdr->hwndDisplay, IDC_TARGETNAME,
                               sname);
                FreeUnicodeString(svc);
            }
            break;

        case PPAGE_TIMES:
        //
        // Display the ticket times
        //
            SetDlgItemText(pHdr->hwndDisplay, IDC_STARTTIME,
                           TimeString(tix->StartTime));
            SetDlgItemText(pHdr->hwndDisplay, IDC_ENDTIME,
                           TimeString(tix->EndTime));

            if (tix->TicketFlags & KERB_TICKET_FLAGS_renewable) {

                SetDlgItemText(pHdr->hwndDisplay, IDC_RENEW_UNTIL,
                               TimeString(tix->RenewTime));
                ShowWindow(GetDlgItem(pHdr->hwndDisplay, IDC_RENEW_UNTIL),
                           SW_SHOW);
            }
            else {

                ShowWindow(GetDlgItem(pHdr->hwndDisplay, IDC_RENEW_UNTIL),
                           SW_HIDE);
            }
            break;

        case PPAGE_ETYPES:
        //
        // Display ticket and session key enctype
        //
            SetDlgItemText(pHdr->hwndDisplay, IDC_TKT_ENCTYPE,
                           ETypeString(tix->EncryptionType));
            SetDlgItemText(pHdr->hwndDisplay, IDC_KEY_ENCTYPE,
                           ETypeString(ticket->SessionKey.KeyType));
            break;

        case PPAGE_FLAGS:
        //
        // Display the ticket flags
        //
            ShowFlags(pHdr->hwndDisplay, tix->TicketFlags);
            break;
        }

        LsaFreeReturnBuffer(ticket);
    }
}

LRESULT CALLBACK
TicketsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LPNMHDR nm;
    DLGTABHDR *pHdr;

    switch (message) {
    case WM_INITDIALOG:
        DisplayCreds(hDlg);
        ShowWindow(hDlg, SW_SHOW);
        return TRUE;

    case WM_NOTIFY: {
        nm = (LPNMHDR)lParam;

        switch (nm->code) {

        case TCN_SELCHANGING:
            return FALSE;

        case TCN_SELCHANGE:
            PropsheetDisplay(hDlg);
            FillinTicket(hDlg);
            return TRUE;

        case TVN_SELCHANGED:
            SelectTicket(hDlg);
            break;
        }
    }
    break;

    case WM_SYSCOMMAND:
        switch (wParam) {
        case SC_CLOSE:
            goto close_tix;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_CLOSE:
        close_tix:
            pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (pHdr->hwndDisplay != NULL)
                DestroyWindow(pHdr->hwndDisplay);

            DestroyWindow(hDlgTickets);
            LsaFreeReturnBuffer(pHdr->Tickets);
            LocalFree(pHdr);
            hDlgTickets = NULL;
            break;
        }
        break;
    }

    return FALSE;
}

void
Tickets(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    if (!hDlgTickets)
        hDlgTickets = CreateDialog(hInstance,
                                   MAKEINTRESOURCE(IDD_TICKETS),
                                   hWnd,
                                   TicketsProc);
    else {
        ShowWindow(hDlgTickets, SW_SHOW);
        SetForegroundWindow(hDlgTickets);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbtray\kerbtray.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbtray.rc
//
#define IDS_KRB5_NAME                   1
#define IDS_VER_INFO_LANG               2
#define IDS_NO_CREDS			3
#define IDS_EXPIRED			4
#define IDS_INFINITE			5
#define IDS_PURGED			6
#define IDS_NO_NET_CREDS		7
#define IDS_LTIMES			8
#define IDS_LEXPIRES			9
#define IDS_LFLAGS			10
#define IDS_LENCTYPE			11
#define IDS_INVALID			12
#define IDS_DOMAIN			13
#define IDS_SERVICE_PRINCIPAL           14
#define IDS_TARGET_NAME                 15
#define IDS_LNAMES                      16
#define IDR_MENU                        101
#define IDD_PROP_TKT_FLAGS              102
#define IDD_ABOUT                       103
#define IDD_TICKETS                     104
#define IDD_PROP_ENCTYPES               105
#define IDD_PROP_TIMES                  106
#define IDD_PROP_NAMES                  107

#define IDI_KWIN                        103
#define IDI_0_MIN                       104
#define IDI_5_MIN                       105
#define IDI_10_MIN                      106
#define IDI_15_MIN                      107
#define IDI_20_MIN                      108
#define IDI_25_MIN                      109
#define IDI_30_MIN                      110
#define IDI_35_MIN                      111
#define IDI_40_MIN                      112
#define IDI_45_MIN                      113
#define IDI_50_MIN                      114
#define IDI_55_MIN                      115
#define IDI_60_MIN                      116
#define IDI_EXPIRED                     117
#define IDI_TICKET                      118
#define IDI_DOMAIN                      119

#define IDD_REAUTH                      121
#define IDD_SETUP                       122
#define IDC_TICKETS                     122
#define IDI_KDC                         124
#define IDI_CHECK                       126
#define IDC_REAUTH_PRINC                1001
#define IDC_AUTO_REAUTH                 1003
#define IDC_FILEDESC                    1004
#define IDC_PRODVER                     1005
#define IDC_COPYRIGHT                   1006
#define IDC_OSVERSION                   1007
#define IDC_TRADEMARK                   1008
#define IDC_FORWARDABLE                 1009
#define IDC_PROXIABLE                   1010
#define IDC_COMPANY                     1011
#define IDC_CLOSE                       1011
#define IDC_LABEL                       1012
#define IDC_MAY_POSTDATE                1012
#define IDC_PRINC_LABEL                 1013
#define IDC_PRINC_START                 1014
#define IDC_INVALID                     1014
#define IDC_RENEWABLE                   1015
#define IDC_PREAUTH                     1016
#define IDC_FORWARDED                   1017
#define IDC_PROXY                       1018
#define IDC_POSTDATED                   1019
#define IDC_INITIAL                     1020
#define IDC_HWAUTH                      1021
#define IDC_OK_AS_DELEGATE              1022
#define IDC_TAB_ATTRIBUTES              1023
#define IDC_STARTTIME                   1024
#define IDC_ENDTIME                     1025
#define IDC_RENEW_UNTIL                 1026
#define IDC_TKT_ENCTYPE                 1027
#define IDC_KEY_ENCTYPE                 1028
#define IDC_SERVICE_PRINC               1030
#define IDC_SERVICE_PRINC_LABEL         1031
#define IDC_SERVICENAME                 1032
#define IDC_TARGETNAME                  1033
#define ID_NEW                          40001
#define ID_ABOUT                        40002
#define ID_EXIT                         40003
#define ID_TICKETS                      40004
#define ID_PURGE                        40005
#define IDL_RENEW_UNTIL                 40006

// Next default values for new objects
// 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbconf\kerbconf.h ===
#define STRDEF(s, d) (s && (s)[0] != '\0')?(s):(d)

#define LIST_HEAD(name, type)						\
struct name {								\
	struct type *lh_first;	/* first element */			\
}

#define LIST_ENTRY(type)						\
struct {								\
	struct type *le_next;	/* next element */			\
	struct type **le_prev;	/* address of previous next element */	\
}

#define	LIST_INIT(head) {						\
	(head)->lh_first = NULL;					\
}

#define LIST_INSERT_HEAD(head, elm, field) {				\
	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
	(head)->lh_first = (elm);					\
	(elm)->field.le_prev = &(head)->lh_first;			\
}

#define LIST_REMOVE(elm, field) {					\
	if ((elm)->field.le_next != NULL)				\
		(elm)->field.le_next->field.le_prev = 			\
		    (elm)->field.le_prev;				\
	*(elm)->field.le_prev = (elm)->field.le_next;			\
}

struct name_list {
    LIST_ENTRY(name_list) list;
    LPTSTR name;
};
typedef struct name_list name_list_t;
#define NewNameList()							\
		(name_list_t *)calloc(sizeof(name_list_t), 1)

struct krb5_realm {
    LIST_ENTRY(krb5_realm) list;
    LIST_HEAD(kdc, name_list) kdc;
    LIST_HEAD(kpasswd, name_list) kpasswd;
    LIST_HEAD(altname, name_list) altname;
    DWORD realm_flags;
    DWORD ap_req_chksum;
    DWORD preauth_type;
    TCHAR name[1];
};
typedef struct krb5_realm krb5_realm_t;
#define NewRealm(l) (krb5_realm_t *)calloc(sizeof(krb5_realm_t) + (l*sizeof(TCHAR)), 1)

struct krb5_rgy {
    LIST_HEAD(realms, krb5_realm) realms;
};
typedef struct krb5_rgy krb5_rgy_t;

struct enctype_entry 
{
    const struct enctype_lookup_entry *ktt;
    BOOL used;
};
typedef struct enctype_entry enctype_entry_t;


#define REGKEY TEXT("system\\currentcontrolset\\control\\lsa\\kerberos")

#ifndef REG_SZ
#define REG_SZ		0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY	0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef REG_MULTI_SZ
#define REG_MULTI_SZ    0x0007
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_DYN_DATA		0x80000006
#endif

UINT Krb5NdiCreate(void);
UINT Krb5NdiInstall(krb5_rgy_t*);
UINT Krb5NdiDestroy(krb5_rgy_t*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\kerbtray\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbtray.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\inc\macros.h ===
/*++             Copyright (c) 1996-1997 Microsoft Corporation          --*/
/*++

  MACROS.H

  useful macros I didn't want to declare in every file. 

  first incarnation in EXTENDED: DAVIDCHR 11/4/1996
  next incarnation in k5 compat: DAVIDCHR 1/8/1997
  modified to be more portable:  DAVIDCHR 4/8/1997

  --*/


/* Note that all of these macros use "HopefullyUnusedVariableName" 
   for a local variable to prevent the unintentional "capture" of 
   a passed parameter by the same name.  Hopefully, we'll never use
   a variable by that name.  If so, the variable can be made even
   more longer and less convenient to use.  :-)  */

#define EQUALS TRUE
#define NOT_EQUALS FALSE

/* BREAK_AND_LOG_IF is for use with actual test results.  When you
   absolutely must have the results logged... */

#define BREAK_AND_LOG_IF( variable, loglevel, data, message, label ) {  \
    BOOL   HopefullyUnusedVariableName;                                 \
    unsigned long HopefullyUnusedVariableName_SaveData;                 \
                                                                        \
    HopefullyUnusedVariableName          = (variable);                  \
    HopefullyUnusedVariableName_SaveData = data;                        \
                                                                        \
    if (HopefullyUnusedVariableName) {                                  \
      if ( HopefullyUnusedVariableName_SaveData == 0 ) {                \
         HopefullyUnusedVariableName_SaveData =                         \
	   HopefullyUnusedVariableName;                                 \
      }                                                                 \
      LOGMSG( loglevel, HopefullyUnusedVariableName_SaveData, message );\
      goto label;                                                       \
    }}

#define BREAK_EXPR( variable, operator, test, message, label ) BREAK_HOOK_EXPR( variable, operator, test, "%hs", message, label)

#ifdef USE_NTLOG /* the other macros MAY or MAY NOT use the logger */

#ifndef BREAK_LOG_LEVEL
#define BREAK_LOG_LEVEL LOGLEVEL_INFO
#endif

#define BREAK_HOOK_EXPR( variable, operator, test, formatmessage, hook, label ) {\
    BOOL          HopefullyUnusedVariableName;\
    unsigned long HopefullyUnusedVariableName_Save;\
    CHAR          HopefullyUnusedVariableName_Buffer[1024];\
   /*    unsigned long HopefullyUnusedVariableName_szBuffer = 1024; */\
\
    HopefullyUnusedVariableName_Save = (ULONG) (variable);\
    HopefullyUnusedVariableName = (operator == EQUALS) ? \
      (HopefullyUnusedVariableName_Save == (ULONG) test) :\
      (HopefullyUnusedVariableName_Save != (ULONG) test);\
\
    if (HopefullyUnusedVariableName) {\
      sprintf( HopefullyUnusedVariableName_Buffer, formatmessage, hook );\
      LOGMSG(BREAK_LOG_LEVEL, HopefullyUnusedVariableName_Save,  HopefullyUnusedVariableName_Buffer );\
      goto label;\
    }}

#else

#define BREAK_HOOK_EXPR( variable, operator, test, formatmessage, hook, label ) {\
    BOOL  HopefullyUnusedVariableName;\
    ULONG HopefullyUnusedVariableName_Save;\
\
    HopefullyUnusedVariableName_Save = (ULONG) (variable);\
    HopefullyUnusedVariableName = (operator == EQUALS) ? \
      (HopefullyUnusedVariableName_Save == (ULONG) test) :\
      (HopefullyUnusedVariableName_Save != (ULONG) test);\
\
    if (HopefullyUnusedVariableName) {\
      fprintf(stderr, "\n** 0x%x \t ", HopefullyUnusedVariableName_Save );\
      fprintf(stderr, formatmessage, hook);\
      fprintf(stderr, "\n");\
      goto label;\
    }}

#endif



#define BREAK_IF( variable, message, label ) BREAK_EXPR((variable), NOT_EQUALS, 0L, message, label)

#define BREAK_EQ( variable, equals, message, label ) \
     BREAK_EXPR(variable, EQUALS, equals, message, label )

#define WSA_BREAK( variable, invalidator, message, label ) \
     BREAK_HOOK_EXPR( variable, EQUALS, invalidator, \
		      message "\n\tWSAGetLastError() returns (dec) %d.",\
		      WSAGetLastError(),  label )

#define NT_BREAK_ON BREAK_IF

/*++ MYALLOC

  used 

  whom:     variable to put the memory into.  
  what:     what kind of memory it points to.. the integral denomination of 
            memory we are allocating (char for a string, int for an int *...)
  howmany:  integral size of "what"s we are allocating (see below)
  withwhat: routine to use in allocation (eg malloc, LocalAlloc...).
            this routine must return NULL on failure to allocate.

  EXAMPLE:  I want to allocate a string of 15 characters with malloc

  {
   PCHAR mystring;
   
   if (! MYALLOC( mystring, CHAR, 15, malloc )) {
      fprintf(stderr, "failed to allocate!");
      exit(0);
   }
  }
  --*/

#define MYALLOC( whom, what, howmany, withwhat ) \
( ( (whom) = (what *) (withwhat)( (howmany) * sizeof(what)) ) != NULL )


  /* ONEALLOC is a special case of MYALLOC, where howmany is 1 */

#define ONEALLOC( whom, what, withwhat ) MYALLOC( whom, what, 1, withwhat)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\inc\common.h ===
/*++
  
  COMMON.H

  General routines shared between sserver and sclient.

  Copyright (C) 1997 Microsoft Corporation
  
  Created 01-08-1997 by DavidCHR

  --*/

#ifdef _KERBCOMM_H_

/* we want kerberos stuff */

typedef KERB_AP_REPLY   *PKERB_AP_REPLY;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;

#endif

#ifdef CPLUSPLUS
extern "C" {
#endif

/* if remote_host is NULL, start as a server, listening on "port".  */
BOOL
ConfigureNetwork( IN OPTIONAL PCHAR            remote_host,
		  IN          SHORT            port, /* must be host short */
		  OUT         SOCKET          *ReturnedSocket,
		  OUT         struct sockaddr *sockname,
		  OUT         int             *szSockaddr,
		  OUT         WSADATA         *wsaData );
	
BOOL
NetWrite( IN SOCKET connection_to_write_on,
	  IN PVOID  data_to_send,
	  IN ULONG  how_much_data );

BOOL
NetRead(  IN          SOCKET listening_connection,
	  OUT         PVOID  buffer_for_inbound_data,
	  IN          PULONG sizes, /* IN: how big is buffer, 
				       OUT: how many bytes were really read */
	  IN OPTIONAL ULONG  seconds_to_wait_before_timeout
#ifdef CPLUSPLUS
	  =0L
#endif
	  );


#ifdef CPLUSPLUS
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\inc\keytab.h ===
/*++

  KEYTAB.H

  Unix Keytab routines and data structures

  Copyright(C) 1997 Microsoft Corporation

  Created, 01-10-1997 DavidCHR

  --*/

typedef unsigned char  krb5_octet,     K5_OCTET,     *PK5_OCTET;
typedef unsigned short krb5_int16,     K5_INT16,     *PK5_INT16;
typedef unsigned long  krb5_timestamp, K5_TIMESTAMP, *PK5_TIMESTAMP;
typedef unsigned long  krb5_int32,     K5_INT32,     *PK5_INT32;

typedef struct _raw_ktcomp {

  K5_INT16 szComponentData; /* string length (including NULL) of component */
  PCHAR    Component;       /* key component name, like "host" */

} KTCOMPONENT, *PKTCOMPONENT;

/* this is the structure of a single kerberos service key entry */

typedef struct _raw_ktent {

  K5_INT32     keySize;    /* I am guessing that this is the keysize */
  K5_INT16     cEntries;   /* number of KTCOMPONENTs */
  K5_INT16     szRealm;    /* string length of Realm (including null) */
  PCHAR        Realm;      /* Kerberos realm in question */
  PKTCOMPONENT Components; /* kerberos key components.  For example:
			      host/davidchr_unix1.microsoft.com -->
			      host and davidchr_unix1.microsoft.com are
			      separate key components. */
  K5_INT32     PrincType;  /* Principal type-- not sure what this is */
  K5_TIMESTAMP TimeStamp;  /* Timestamp (seconds since the epoch) */
  K5_OCTET     Version;    /* key version number */
  K5_INT16     KeyType;    /* Key Type -- not sure what this is either */

#if 0                      /* For some reason, the documentation I was reading
			      erroneously listed this as a 32-bit value. */

  K5_INT32     KeyLength;  /* size of key data (next field) */
#else
  K5_INT16     KeyLength;  /* size of key data (next field) */
  K5_INT16     foo_padding;  // padding for alpha compilers.
#endif

  PK5_OCTET    KeyData;    /* raw key data-- might as well be an LPBYTE */

  struct _raw_ktent *nextEntry;

} KTENT, *PKTENT;

/* this is the rough structure of the keytab file */

typedef struct _raw_keytab {

  K5_INT16 Version;

#if 0
  ULONG    cEntries; /* this is not actually stored.  It's the number of
			pktents we have in memory (below) */
  PKTENT   KeyEntries;
#else

  PKTENT   FirstKeyEntry; /* This is a pointer to the first key in the
			     linked list.  In the file, they're just there,
			     in no particular order though. */
  PKTENT   LastKeyEntry;  /* This is the list tail. */

#endif

} KTFILE, *PKTFILE;



VOID 
FreeKeyTab( PKTFILE pktfile_to_free );

BOOL
ReadKeytabFromFile( PKTFILE *ppktfile, // free with FreeKeyTab when done
		    PCHAR    filename );

BOOL
WriteKeytabToFile(  PKTFILE ktfile,
		    PCHAR   filename );

/* These are the values to use for the OPTION_MASK to DisplayKeytab : */

#define KT_COMPONENTS 0x001 /* key components (key's name) */
#define KT_REALM      0x002 /* key realm-- useful */
#define KT_PRINCTYPE  0x004 /* Principal type */
#define KT_VNO        0x008 /* Key version number */
#define KT_KTVNO      0x010 /* Keytab version number */
#define KT_KEYTYPE    0x020 /* type of key (encryption type) */
#define KT_KEYLENGTH  0x040 /* length of key-- not useful */
#define KT_KEYDATA    0x080 /* key data -- not generally useful */
#define KT_TIMESTAMP  0x100 /* timestamp (unix timestamp) */
#define KT_RESERVED   0x200 /* wierd ULONG at the beginning of every key */

#define KT_ENCTYPE    KT_KEYTYPE
#define KT_EVERYTHING 0x3ff
#define KT_DEFAULT (KT_COMPONENTS | KT_REALM | KT_VNO | KT_KTVNO | KT_KEYTYPE | KT_PRINCTYPE )


#ifdef __cplusplus
#define OPTIONAL_PARAMETER( param, default_value ) param=default_value
#else
#define OPTIONAL_PARAMETER( param, default_value ) param
#endif

VOID
DisplayKeytab( FILE   *stream,
	       PKTFILE ktfile,
	       OPTIONAL_PARAMETER( ULONG   options, KT_DEFAULT) );

PVOID 
KEYTAB_ALLOC ( ULONG numBytes );

VOID
KEYTAB_FREE  ( PVOID toFree );

K5_INT32
ComputeKeytabLength ( PKTENT thisKeyEntry );

/* base linklist operations */

BOOL
AddEntryToKeytab( PKTFILE Keytab, 
		  PKTENT  Entry,
		  OPTIONAL_PARAMETER( BOOL copy, FALSE ));

BOOL
RemoveEntryFromKeytab( PKTFILE Keytab,
		       PKTENT  Entry,
		       OPTIONAL_PARAMETER( BOOL dealloc, FALSE ) );


VOID 
FreeKeyEntry( PKTENT pEntry );

PKTENT
CloneKeyEntry( PKTENT pEntry );


BOOL
KtCreateKey( PKTENT  *ppKeyEntry,
	     PCHAR    principal,
	     PCHAR    password,
	     PCHAR    realmname,
	     
	     K5_OCTET keyVersionNumber,  
	     ULONG    principalType,
	     ULONG    keyType,
	     ULONG    cryptosystem  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\inc\master.h ===
/*++

  MASTER.H

  master include file for this project.

  Created by Davidchr 1/8/1997, 
  Copyright (C) 1997 Microsoft Corporation

  --*/


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

/* These contortions work around an irritation in asn1code.h, where
   DEBUG gets defined.  Uhhh, hello... that's kind of a common word
   to just define for use in a header not relating to debuggers... 

   (just My Humble Opinion) */

#ifdef DEBUG
#define DEBUGOLD DEBUG
#undef DEBUG
#endif

#include <sspi.h>
#include <kerberos.h>
  /* #include "krb5.h" */


#undef DEBUG
#ifdef DEBUGOLD 
#define DEBUG DEBUGOLD

#if DBG || CHECKED_BUILD // WASBUG 73896 
#define debug printf
#else
#define debug // nothing
#endif

#undef DEBUGOLD

#else

#define debug /* nothing */

#endif /* end of asn1code.h hackaround */

#include ".\macros.h"
#include ".\common.h"
#include "common.h"

#define ASSERT_NOTREACHED( message ) /* nothing */
#define Verbage( flag, printflist ) if ( flag ) { printf( printflist ); }

#ifdef __cplusplus
} /* extern "C" */

// #include ".\globals.hxx"

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\inc\keyfunc.h ===
/*++

  KEYFUNC.H

  function reference for the keytab library

  created 4/22/1997 by DavidCHR 

  --*/

VOID
FreeKeyEntry( PKTENT pEntry );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ktpass\main.c ===
/*++

  MAIN.C

  main program for the ktPass program

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

--*/

#include "master.h"
#include <winldap.h>
#include "keytab.h"
#include "keytypes.h"
#include "secprinc.h"
#include <kerbcon.h>
#include <lm.h>
#include "options.h"
#include "delegtools.h"
#include "delegation.h"
#include <rpc.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <windns.h>

LPSTR KvnoAttribute = "msDS-KeyVersionNumber";
#define KVNO_DETECT_AT_DC ( (ULONG) -1 )

PVOID
MIDL_user_allocate( size_t size ) {

    return malloc( size );
}

VOID
MIDL_user_free( PVOID pvFree ) {

    free( pvFree );
}

// this global is set by the command line options.

K5_INT16 ktvno = 0x0502; // kerberos 5, keytab v.2

PKTFILE
NewKt() {

    PKTFILE ret;

    ret = (PKTFILE) malloc (sizeof(KTFILE));

    if (!ret) {

      return NULL;
    }

    memset(ret, 0L, sizeof(KTFILE));

    ret->Version = ktvno;

    return ret;
}

#define MAYBE 2

USHORT
PromptResponse = MAYBE;

BOOL
UserWantsToDoItAnyway( IN LPSTR fmt,
                       ... ) {
    
    va_list va;
    CHAR    Buffer[ 5 ] = { '\0' }; /* == %c\r\n\0 */
    INT     Response;
    BOOL    ret = FALSE;
    BOOL    keepGoing = TRUE;
    ULONG   i;

    do {

        va_start( va, fmt );
      
        fprintf( stderr, "\n" );
        vfprintf( stderr,
                  fmt,
                  va );

        fprintf( stderr, " [y/n]?  " );

        if ( PromptResponse != MAYBE ) {

            fprintf( stderr,
                     "auto: %hs\n", 
                     PromptResponse ? "YES" : "NO" );

            return PromptResponse;
        }

        if ( !fgets( Buffer,
                     sizeof( Buffer ),
                     stdin ) ) {

            fprintf( stderr,
                     "EOF on stdin.  Assuming you mean no.\n" );

            return FALSE;
        }

        for ( i = 0; i < sizeof( Buffer ); i++ ) {

            if ( Buffer[i] == '\n' ) {

                Buffer[i] = '\0';
                break;
            }
        }
          
        Response = Buffer[ 0 ];

        switch( Response ) {

        case 'Y':
        case 'y':

            ret = TRUE;
            keepGoing = FALSE;
            break;

        case EOF:

            fprintf( stderr,
                     "EOF at console.  I assume you mean no.\n" );

            // fallthrough

        case 'N':
        case 'n':

            ret = FALSE;
            keepGoing = FALSE;
            break;

        default:

            printf( "Your response, %02x ('%c'), doesn't make sense.\n"
                    "'Y' and 'N' are the only acceptable responses.",
                    Response,
                    Response );
        }
    } while ( keepGoing );

    if ( !ret ) {

      printf( "Exiting.\n" );
      exit( -1 );
    }

    return ret;
}

BOOL
GetTargetDomainFromUser( IN  LPSTR   UserName,
                         OUT LPSTR  *ppRealUserName,
                         OUT OPTIONAL LPWSTR *ppTargetDC ) {

    HANDLE           hDS;
    DWORD            dwErr;
    DWORD            StringLength;
    BOOL             ret = FALSE;
    PDS_NAME_RESULTA pResults;
    LPWSTR           DcName; /* BUGBUG: this implementation takes ANSI
                                parameters and converts them to unicode.

                                This is an artifact of this being a 
                                proof-of-concept app that later became a 
                                support tool.  

                                Someday, we should use unicode throughout and
                                convert to ANSI as needed. */

    PDOMAIN_CONTROLLER_INFO pDCName;
    LPSTR                   DomainName;
    LPSTR                   Cursor;

    ASSERT( ppRealUserName != NULL );

    *ppRealUserName = UserName;

    if (ppTargetDC) {
        *ppTargetDC = NULL;
    }

    dwErr = DsBind( NULL, NULL, &hDS );

    if ( dwErr != ERROR_SUCCESS ) {

        fprintf( stderr,
                 "Cannot bind to default domain: 0x%x\n",
                 dwErr );

    } else {

        dwErr = DsCrackNamesA( hDS,
                               DS_NAME_NO_FLAGS,
                               DS_UNKNOWN_NAME,
                               DS_NT4_ACCOUNT_NAME,
                               1,
                               &UserName,
                               &pResults );
  
        DsUnBind( hDS );
  
        if ( dwErr == ERROR_FILE_NOT_FOUND ) {
  
            fprintf( stderr,
                     "Cannot locate the user %hs.  Will try the local domain.\n",
                     UserName );
    
            ret         = TRUE;
  
        } else if ( dwErr != ERROR_SUCCESS ) {
  
            fprintf( stderr,
                     "Cannot DsCrackNames %hs: 0x%x\n",
                     UserName,
                     dwErr );
  
        } else {
  
            if ( pResults->cItems != 1 ) {
  
                fprintf( stderr,
                         "\"%hs\" has %ld matches -- it needs to be unique!\n",
                         UserName,
                         pResults->cItems );
  
            } else if ( pResults->rItems[0].status != DS_NAME_NO_ERROR ) {
  
                fprintf( stderr,
                "DsCrackNames returned 0x%x in the name entry for %hs.\n",
                pResults->rItems[ 0 ].status,
                UserName );

            } else {

                DomainName = pResults->rItems[0].pDomain;

                Cursor = strchr( pResults->rItems[ 0 ].pName, '\\' );

                ASSERT( Cursor != NULL ); /* dscracknames wouldn't give back
                                             an NT4_ACCOUNT_NAME that is not
                                             of the form DOMAIN\user */

                Cursor++;

                *ppRealUserName = _strdup( Cursor );

                if ( !*ppRealUserName ) {

                    /* Note that I'm reading from the output parameter after
                       writing to it, which might be dangerous if this weren't
                       just an app. */

                    fprintf( stderr,
                             "Couldn't return username portion of \"%hs\""
                             " -- out of memory.\n",
                             pResults->rItems[0].pName );

                } else if ( !ppTargetDC ) {

                  // user has already selected a DC,
                  // so he doesn't need us to hunt for one.

                  ret = TRUE;


                } else {

                  // next, hunt for a DC in that domain.

                  dwErr = DsGetDcNameA( NULL, // perform locally
                                        DomainName,
                                        NULL, // domain GUID: don't care
                                        NULL, // site name: use closest site
                                        DS_DIRECTORY_SERVICE_REQUIRED |
                                        DS_RETURN_DNS_NAME |
                                        DS_WRITABLE_REQUIRED,
                                        &pDCName );

                  if ( dwErr != ERROR_SUCCESS ) {

                    fprintf( stderr,
                             "Cannot DsGetDcName for \"%hs\": 0x%x\n",
                             DomainName,
                             dwErr );

                  } else {

                    while( pDCName->DomainControllerName[0] == '\\' ) {

                      pDCName->DomainControllerName++;
                    }

                    /* Retrieve the string length, +1 for terminating null. */

                    StringLength = strlen( pDCName->DomainControllerName ) +1;

                    DcName = (LPWSTR) malloc( StringLength * sizeof( WCHAR ) );

                    if ( !DcName ) {

                      fprintf( stderr,
                               "cannot allocate %ld WCHARs.",
                               StringLength );

                    } else {

                      swprintf( DcName,
                                L"%hs",
                                pDCName->DomainControllerName );

                      *ppTargetDC = DcName;

                      printf( "Targeting domain controller: %ws\n",
                              DcName );

                      ret = TRUE;

                    }

                    NetApiBufferFree( pDCName );

                  }

                  if ( !ret ) { 

                    free( *ppRealUserName );
                  }   

                }
            }

            DsFreeNameResult( pResults );
        }
    }

    if ( !ret ) {

        *ppRealUserName = UserName;
    }

    return ret;
}

VOID
GetKeyVersionFromDomain( IN PLDAP      pLdap,
                         IN LPSTR      UserName,
                         IN OUT PULONG pkvno ) {

    ASSERT( pLdap != NULL );

    if ( *pkvno == KVNO_DETECT_AT_DC ) {

        if ( !LdapQueryUlongAttributeA( pLdap,
                                        NULL, // ignored
                                        UserName,
                                        KvnoAttribute,
                                        pkvno ) ) {

            // a win2k DC would fail with attribute not found.

            if ( GetLastError() == LDAP_NO_SUCH_ATTRIBUTE ) {

                fprintf(
                    stderr,
                    "The %hs attribute does not exist on the target DC.\n"
                    " Assuming this is a Windows 2000 domain, and setting\n"
                    " the Key Version Number in the Keytab to 1.\n"
                    "\n"
                    " Supply \"/kvno 1\" on the command line to skip this message.\n",
                    KvnoAttribute );

                *pkvno = 1;

            } else {

                fprintf( stderr,
                        "Failed to query kvno attribute from the DC.\n"
                        "Ktpass cannot continue.\n" );

                exit( -1 );
            }
        }
    }
}

VOID
CheckKeyVersion( IN ULONG BigVer ) {

    BYTE LittleVer;

    LittleVer = (BYTE) BigVer;

    if ( LittleVer != BigVer ) {

        if ( !UserWantsToDoItAnyway( 
                  "WARNING: The Key version used by Windows (%ld) is too big\n"
                  " to be encoded in a keytab without truncating it to %ld.\n"
                  " This is due to a limitation of the keytab file format\n"
                  " and may lead to interoperability issues.\n"
                  "\n"
                  "Do you want to proceed and truncate the version number",
                  BigVer,
                  LittleVer ) ) {

          exit( -1 );

        }
    }
}

extern BOOL KtDumpSalt; // in ..\lib\mkkey.c
extern LPWSTR RawHash; // in mkkey.c

// #include "globals.h"
// #include "commands.h"

int __cdecl
main( int   argc,
      PCHAR argv[] ) {

    LPSTR    Principal     = NULL;
    LPSTR    UserName      = NULL;
    LPSTR    Password      = NULL;
    PLDAP    pLdap         = NULL;
    LPSTR    UserDn        = NULL;

    BOOL     SetUpn        = TRUE;
    
    ULONG    BigKvno       = KVNO_DETECT_AT_DC;
    ULONG    Crypto        = KERB_ETYPE_DES_CBC_MD5;
    ULONG    ptype         = KRB5_NT_PRINCIPAL;
    ULONG    uacFlags      = 0;
    PKTFILE  pktFile       = NULL;
    PCHAR    KtReadFile    = NULL;
    PCHAR    KtWriteFile   = NULL;
    BOOL     DesOnly       = TRUE;
    ULONG    LdapOperation = LDAP_MOD_ADD;
    HANDLE   hConsole      = NULL;
    BOOL     SetPassword   = TRUE;
    BOOL     WarnedAboutAccountStrangeness = FALSE;
    PVOID    pvTrash       = NULL;
    DWORD    dwConsoleMode;
    LPWSTR   BindTarget    = NULL; // local domain (see ldlib\delegtools.c)

    optEnumStruct CryptoSystems[] = {

        { "DES-CBC-CRC", (PVOID) KERB_ETYPE_DES_CBC_CRC, "for compatibility" },
        { "DES-CBC-MD5", (PVOID) KERB_ETYPE_DES_CBC_MD5, "default" },

        TERMINATE_ARRAY
    };

#define DUPE( type, desc ) { "KRB5_NT_" # type,         \
                             (PVOID) KRB5_NT_##type,    \
                             desc }

    optEnumStruct PrincTypes[] = {

        DUPE( PRINCIPAL, "The general ptype-- recommended" ),
        DUPE( SRV_INST,  "user service instance" ),
        DUPE( SRV_HST,   "host service instance" ),
        DUPE( SRV_XHST,  NULL ),

        TERMINATE_ARRAY
    };

    optEnumStruct MappingOperations[] = {

        { "add", (PVOID) LDAP_MOD_ADD,     "add value (default)" },
        { "set", (PVOID) LDAP_MOD_REPLACE, "set value" },

        TERMINATE_ARRAY
    };

#if DBG
#undef  OPT_HIDDEN
#define OPT_HIDDEN 0 /* no hidden options on debug builds. */
#endif

    optionStruct Options[] = {

      { "?",      NULL, OPT_HELP | OPT_HIDDEN },
      { "h",      NULL, OPT_HELP | OPT_HIDDEN },
      { "help",   NULL, OPT_HELP | OPT_HIDDEN },
      { NULL,      NULL,         OPT_DUMMY,    "most useful args" },
      { "out",     &KtWriteFile, OPT_STRING,   "Keytab to produce" },
      { "princ",   &Principal,   OPT_STRING,   "Principal name (user@REALM)" },
      { "pass",    &Password,    OPT_STRING,   "password to use" },
      { NULL,      NULL,         OPT_CONTINUE, "use \"*\" to prompt for password." },
      { NULL,      NULL,         OPT_DUMMY,    "less useful stuff" },
      { "mapuser", &UserName,    OPT_STRING,   "map princ (above) to this user account (default: don't)" },
      { "mapOp",   &LdapOperation, OPT_ENUMERATED, "how to set the mapping attribute (default: add it)", MappingOperations },
      { "DesOnly", &DesOnly,     OPT_BOOL,     "Set account for des-only encryption (default:do)" },
      { "in",      &KtReadFile,  OPT_STRING,   "Keytab to read/digest" },
      { NULL,      NULL,         OPT_DUMMY,    "options for key generation" },
      { "crypto",  &Crypto,   OPT_ENUMERATED,  "Cryptosystem to use", CryptoSystems },
      { "ptype",   &ptype,    OPT_ENUMERATED,  "principal type in question", PrincTypes },
      { "kvno",    &BigKvno,      OPT_INT,     "Override Key Version Number"},
      { NULL,      NULL,        OPT_CONTINUE,  "Default: query DC for kvno.  Use /kvno 1 for Win2K compat." },
      /* It is best NOT to mess with the keytab version number.
         We use this for debugging only. */

      /* Use /target to hit a specific DC.  This is good if you just
         created a user there, for example.  It also eliminates the
         network traffic used to locate the DC */

      { "Answer",  &PromptResponse, OPT_BOOL, "+Answer answers YES to prompts.  -Answer answers NO." },
      { "Target",  &BindTarget,  OPT_WSTRING,   "Which DC to use.  Default:detect" },
      { "ktvno",   &ktvno,       OPT_INT | OPT_HIDDEN,     "keytab version (def 0x502).  Leave this alone." },
      // { "Debug",   &DebugFlag, OPT_BOOL | OPT_HIDDEN },
      { "RawSalt", &RawHash,     OPT_WSTRING | OPT_HIDDEN, "raw salt to use when generating key (not needed)" },
      { "DumpSalt", &KtDumpSalt, OPT_BOOL | OPT_HIDDEN,   "show us the MIT salt being used to generate the key" },
      { "SetUpn",   &SetUpn,     OPT_BOOL | OPT_HIDDEN,   "Set the UPN in addition to the SPN.  Default DO." },
      { "SetPass",  &SetPassword, OPT_BOOL | OPT_HIDDEN,  "Set the user's password if supplied." },

      TERMINATE_ARRAY
    };

    FILE *f;

    // DebugFlag = 0;

    ParseOptionsEx( argc-1,
                    argv+1,
                    Options,
                    OPT_FLAG_TERMINATE,
                    &pvTrash,
                    NULL,
                    NULL );

    if ( ( Principal ) &&
         ( strlen( Principal ) > BUFFER_SIZE ) ) {

        fprintf( stderr,
                 "Please submit a shorter principal name.\n" );
        
        return 1;
    }

    if ( Password && 
        ( strlen( Password ) > BUFFER_SIZE ) ) {

        fprintf( stderr,
                 "Please submit a shorter password.\n" );

        return 1;
    }

    if ( KtReadFile ) {

        if ( ReadKeytabFromFile( &pktFile, KtReadFile ) ) {

            fprintf( stderr,
                    "Existing keytab: \n\n" );

            DisplayKeytab( stderr, pktFile, 0xFFFFFFFF );

        } else {

            fprintf( stderr,
                     "Keytab read failed!\n" );
            return 5;
        }
    }

    if ( !UserName && 
         ( BigKvno == KVNO_DETECT_AT_DC ) ) {

      // 
      // if the user doesn't pass /kvno, we want to
      // detect the kvno at the DC.  However, if no
      // /mapuser is passed, there's no DC to do this
      // at.  Win2K ktpass provided '1' as the default,
      // so this is what we do here.
      //

      BigKvno = 1;
      
    }

    if ( Principal ) {

        LPSTR realm, cp;
        CHAR tempBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
  
        realm = strchr( Principal, '@' );
  
        if ( realm ) {

            ULONG length;

            realm++;

            length = lstrlenA( realm );

            if ( length >= sizeof( tempBuffer )) {

                length = sizeof( tempBuffer ) - 1;
            }

            memcpy( tempBuffer, realm, ( length + 1 ) * sizeof( realm[0] )  );

            tempBuffer[sizeof( tempBuffer ) - 1] = '\0';

            CharUpperBuffA( realm, length );

            if ( lstrcmpA( realm, tempBuffer ) != 0 ) {

                fprintf( stderr,
                         "WARNING: realm \"%hs\" has lowercase characters in it.\n"
                         "         We only currently support realms in UPPERCASE.\n"
                         "         assuming you mean \"%hs\"...\n",
                         tempBuffer, realm );

                // now "realm" will be all uppercase.
            }

            *(realm-1) = '\0'; // separate the realm from the principal

            if ( UserName ) {

                /* Crack the domain name (507151).  Without this call
                   the DC we target may not contain the user object. 
                   Note that UserName is modified by this operation. */

                if ( !GetTargetDomainFromUser( UserName,
                                               &UserName,
                                               BindTarget ?
                                               NULL : 
                                               &BindTarget ) ) {

                    return 1;
                }

                // connect to the DSA.

                if ( pLdap ||
                     ConnectAndBindToDefaultDsa( BindTarget,
                                                 &pLdap ) ) {

                    // locate the User

                    if ( UserDn ||
                         FindUser( pLdap,
                                   UserName,
                                   &uacFlags,
                                   &UserDn ) ) {

                        if ( ( LdapOperation == LDAP_MOD_REPLACE ) &
                            !( uacFlags & UF_NORMAL_ACCOUNT ) ) {

                            /* 97282: the user is not UF_NORMAL_ACCOUNT, so 
                               check to see that the caller *really* wants to
                               blow away the non-user's SPNs. */

                            if ( uacFlags ) {

                                fprintf( stderr, 
                                         "WARNING: Account %hs is not a normal user "
                                         "account (uacFlags=0x%x).\n",
                                         UserName,
                                         uacFlags );

                            } else {

                                fprintf( stderr,
                                         "WARNING: Cannot determine the account type"
                                         " for %hs.\n",
                                         UserName );
                            }

                            WarnedAboutAccountStrangeness = TRUE;

                            if ( !UserWantsToDoItAnyway( 
                                    "Do you really want to delete any previous "
                                    "servicePrincipalName values on %hs",
                                    UserName ) ) {

                                /* Abort the operation, but try to do whatever
                                   else the user asked us to do. */

                                goto abortedMapping;
                            }
                        }

                        /* 97279: check to see if there are other SPNs
                           by the same name already registered.  If so,
                           we don't want to blow away those accounts. 
                           If/when we decide to do this, we'd do it here. */

                        // set/add the user property

                        if ( SetStringProperty( pLdap,
                                                UserDn,
                                                "servicePrincipalName",
                                                Principal,
                                                LdapOperation ) ) {

                            if ( SetUpn ) {

                                *(realm-1) = '@'; // UPN includes the '@'

                                if ( !SetStringProperty( pLdap,
                                                         UserDn,
                                                         "userPrincipalName",
                                                         Principal,
                                                         LDAP_MOD_REPLACE ) ) {

                                    fprintf( stderr, 
                                             "WARNING: Failed to set UPN %hs on %hs.\n"
                                             "  kinits to '%hs' will fail.\n",
                                             Principal,
                                             UserDn,
                                             Principal );
                                }

                                *(realm -1 ) = '\0'; // where it was before
                            }

                            fprintf( stderr,
                                     "Successfully mapped %hs to %hs.\n",
                                     Principal,
                                     UserName );

abortedMapping:

                            ; /* Need a semicolon so we can goto here. */

                        } else {

                            fprintf( stderr,
                                     "WARNING: Unable to set SPN mapping data.\n"
                                     "  If %hs already has an SPN mapping installed for "
                                     " %hs, this is no cause for concern.\n",
                                     UserName,
                                     Principal );
                        }
                    } // else a message will be printed.
                }   // else a message will be printed.
            } // if ( UserName )

            if ( Password ) {

                PKTENT pktEntry;
                CHAR   TempPassword[ 255 ], ConfirmPassword[ 255 ];

                if ( lstrcmpA( Password, "*" ) == 0 ) {

                    hConsole = GetStdHandle( STD_INPUT_HANDLE );

                    if ( GetConsoleMode( hConsole,
                                         &dwConsoleMode ) ) {

                        if ( SetConsoleMode( hConsole,
                                             dwConsoleMode & ~ENABLE_ECHO_INPUT ) ) {

                            do {

                                fprintf( stderr,
                                         "Type the password for %hs: ",
                                         Principal );

                                if ( !fgets( TempPassword, 
                                             sizeof( TempPassword ), 
                                             stdin ) ) {

                                    fprintf( stderr,
                                             "failed to read password.\n" );

                                    exit( GetLastError() );
                                }

                                fprintf( stderr,
                                         "\nType the password again to confirm:" );

                                if ( !fgets( ConfirmPassword, 
                                             sizeof( ConfirmPassword ), 
                                             stdin ) ) {

                                    fprintf( stderr,
                                             "failed to read confirmation password.\n" );
                                    exit( GetLastError() );
                                }

                                if ( lstrcmpA( ConfirmPassword,
                                               TempPassword ) == 0 ) {

                                    printf( "\n" );

                                    break;

                                } else {

                                    fprintf( stderr, 
                                             "The passwords you type must match exactly.\n" );
                                }
                            } while ( TRUE );

                            Password = TempPassword;

                            SetConsoleMode( hConsole, dwConsoleMode );

                        } else { 

                            fprintf( stderr,
                                     "Failed to turn off echo input for password entry:"
                                     " 0x%x\n",

                            GetLastError() );

                            return -1;
                        }

                    } else {

                        fprintf( stderr,
                                 "Failed to retrieve console mode settings: 0x%x.\n",
                                 GetLastError() );

                        return -1;
                    }
                }

                if ( SetPassword && UserName ) {

                    DWORD          err;
                    NET_API_STATUS nas;
                    PUSER_INFO_1   pUserInfo;
                    WCHAR          wUserName[ MAX_PATH ];
                    DOMAIN_CONTROLLER_INFOW * DomainControllerInfo = NULL;

                    /* WASBUG 369: converting ascii to unicode
                       This is safe, because RFC1510 doesn't do
                       UNICODE, and this tool is specifically for 
                       unix interop support; unix machines don't
                       do unicode. */

                    if ( strlen( UserName ) >= MAX_PATH ) {

                        UserName[MAX_PATH] = '\0';
                    }

                    wsprintfW( wUserName,
                               L"%hs",
                               UserName );

                    nas = NetUserGetInfo( BindTarget,
                                          wUserName,
                                          1, // level 1
                                          (PBYTE *) &pUserInfo );

                    if ( nas == NERR_Success ) {

                        WCHAR wPassword[ PWLEN ];

                        uacFlags = pUserInfo->usri1_flags;

                        if ( !( uacFlags & UF_NORMAL_ACCOUNT ) ) {

                            /* 97282: For abnormal accounts (these include
                               workstation trust accounts, interdomain
                               trust accounts, server trust accounts),
                               ask the user if he/she really wants to
                               perform this operation. */

                            if ( !WarnedAboutAccountStrangeness ) {

                                fprintf( stderr,
                                         "WARNING: Account %hs is not a user account"
                                         " (uacflags=0x%x).\n",
                                         UserName,
                                         uacFlags );

                                WarnedAboutAccountStrangeness = TRUE;
                            }

                            fprintf( stderr,
                                     "WARNING: Resetting %hs's password may"
                                     " cause authentication problems if %hs"
                                     " is being used as a server.\n",
                                     UserName,
                                     UserName );

                            if ( !UserWantsToDoItAnyway( "Reset %hs's password",
                                                           UserName ) ) {

                                /* Skip it, but try to do anything else the user
                                   requested. */

                                goto skipSetPassword;
                            }
                        }

                        if ( strlen( Password ) >= PWLEN ) {

                            Password[PWLEN] = '\0';
                        }

                        wsprintfW( wPassword,
                                   L"%hs",
                                   Password );

                        pUserInfo->usri1_password = wPassword;

                        nas = NetUserSetInfo( BindTarget,
                                              wUserName,
                                              1, // level 1
                                              (LPBYTE) pUserInfo,
                                              NULL );

                        if ( nas == NERR_Success ) {

skipSetPassword:

                            NetApiBufferFree( pUserInfo );

                            GetKeyVersionFromDomain( pLdap,
                                                     UserName,
                                                     &BigKvno );

                            goto skipout;

                        } else {

                            fprintf( stderr,
                                     "Failed to set password for %ws: 0x%x.\n",
                                     wUserName,
                                     nas );

                        }

                    } else {

                        fprintf( stderr,
                                 "Failed to retrieve user info for %ws: 0x%x.\n",
                                 wUserName,
                                 nas );
                    }

                    fprintf( stderr,
                             "Aborted.\n" );

                    return nas;
                }

skipout:

                ASSERT( realm != NULL );

                // physically separate the realm data.

                ASSERT( *( realm -1 ) == '\0' );

                CheckKeyVersion( BigKvno );

                if ( KtCreateKey( &pktEntry,
                                  Principal,
                                  Password,
                                  realm,
                                  (K5_OCTET) BigKvno,
                                  ptype,
                                  Crypto, // this is the "fake" etype
                                  Crypto ) ) {

                    if ( pktFile == NULL ) {

                        pktFile = NewKt();

                        if ( !pktFile ) {

                            fprintf( stderr,
                                     "Failed to allocate keytable.\n" );

                            return 4;
                        }
                    }

                    if ( AddEntryToKeytab( pktFile,
                                           pktEntry,
                                           FALSE ) ) {

                        fprintf( stderr,
                                 "Key created.\n" );

                    } else {

                        fprintf( stderr,
                                 "Failed to add entry to keytab.\n" );
                        return 2;
                    }

                    if ( KtWriteFile ) {

                        fprintf( stderr,
                                 "Output keytab to %hs:\n",
                                 KtWriteFile );

                        DisplayKeytab( stderr, pktFile, 0xFFFFFFFF );

                        if ( !WriteKeytabToFile( pktFile, KtWriteFile ) ) {

                            fprintf( stderr, "\n\n"
                                     "Failed to write keytab file %hs.\n",
                                     KtWriteFile );

                            return 6;
                        }

                        // write keytab.
                    }

                } else {

                    fprintf( stderr,
                             "Failed to create key for keytab.  Quitting.\n" );

                    return 7;
                }

                if ( UserName && DesOnly ) {

                    ASSERT( pLdap  != NULL );
                    ASSERT( UserDn != NULL );

                    // set the DES_ONLY flag

                    // first, query the account's account flags.

                    if ( uacFlags /* If we already queried the user's
                                     AccountControl flags, no need to do it
                                     again */
                        || QueryAccountControlFlagsA( pLdap,
                                                       NULL, // domain name is ignored
                                                       UserName,
                                                       &uacFlags ) ) {

                        uacFlags |= UF_USE_DES_KEY_ONLY;

                        if ( SetAccountControlFlagsA( pLdap,
                                                    NULL, // domain name is ignored
                                                    UserName,
                                                    uacFlags ) ) {

                            fprintf( stderr, 
                                     "Account %hs has been set for DES-only encryption.\n",
                                     UserName );

                            if ( !SetPassword ) {

                                fprintf( stderr,
                                         "To make this take effect, you must change "
                                         "%hs's password manually.\n",
                                         UserName );
                            }
                        } // else message printed.
                    } // else message printed
                }
            } // else user doesn't want me to make a key

            if ( !Password && !UserName ) {

              fprintf( stderr,
                       "doing nothing.\n"
                       "specify /pass and/or /mapuser to either \n"
                       "make a key with the given password or \n"
                       "map a user to a particular SPN, respectively.\n" );
            }

        } else {

            fprintf( stderr,
                     "principal %hs doesn't contain an '@' symbol.\n"
                     "Looking for something of the form:\n"
                     "  foo@BAR.COM  or  xyz/foo@BAR.COM \n"
                     "     ^                    ^\n"
                     "     |                    |\n"
                     "     +--------------------+---- I didn't find these.\n",
                     Principal );

            return 1;
        }

    } else {

      //
      // if no principal is specified, we should find a way to warn
      // the user.  The only real reason to do this is when importing
      // a keytab and not saving a key; admittedly not a likely scenario.
      // 

        printf( "\n"
                "WARNING: No principal name specified.\n" );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\delegation.h ===
/*+
 *	FileName: delegation.h
 *	Author:   RuiM
 *	Copyright (c) 1998 Microsoft Corp.
 *
 *	Description:
 *	Simple API to either turn on or off a computer's
 *	delegation trust flag through ldap.
-*/


#ifdef __cplusplus
extern "C" {
#endif

BOOL
TrustComputerForDelegationW(
        IN LPWSTR lpComputerName,
        IN BOOL   OnOff
    );

BOOL
TrustComputerForDelegationA(
        IN LPSTR  lpComputerName,
        IN BOOL   OnOff
    );

/*++

Routine Description:

    This API turns on or off the computer
    delegation trust value in the domain.
    The computer name is passed in, and the
    operation is performed through the ldap
    provider.

Arguments:

    lpComputerName - computer name to turn on
        off the delegation trust.

    OnOff - boolean to specify whether to turn
        on or off the delegation trust.

Return Value:

    TRUE if the operation succeeded,
    FALSE otherwise.

--*/

#ifdef LDAP_CLIENT_DEFINED /* need to have included <winldap.h>
			      to use these related functions--
			      these are underlying functions for
			      the delegation trust. */

BOOL
SetAccountControlFlagsA( IN OPTIONAL PLDAP  pLdap,
			 IN OPTIONAL LPSTR DomainName,
			 IN          LPSTR SamAccountName,
			 IN          ULONG  AccountControlFlags );

BOOL
SetAccountControlFlagsW( IN OPTIONAL PLDAP  pLdap,
			 IN OPTIONAL LPWSTR DomainName,
			 IN          LPWSTR SamAccountName,
			 IN          ULONG  AccountControlFlags );
			     

BOOL
QueryAccountControlFlagsA( IN OPTIONAL PLDAP  pLdap,
			   IN OPTIONAL LPSTR DomainName, // ignored
			   IN          LPSTR SamAccountName,
			   OUT         PULONG pulControlFlags );


BOOL
QueryAccountControlFlagsW( IN OPTIONAL PLDAP  pLdap,
			   IN OPTIONAL LPWSTR DomainName, // ignored
			   IN          LPWSTR SamAccountName,
			   OUT         PULONG pulControlFlags );

BOOL
LdapQueryUlongAttributeA( IN OPTIONAL PLDAP  pLdap,
			  IN OPTIONAL LPSTR DomainName, // ignored
			  IN          LPSTR SamAccountName,
			  IN          LPSTR AttributeName,
			  OUT         PULONG pulAttributeContents );
BOOL
LdapQueryUlongAttributeW( IN OPTIONAL PLDAP  pLdap,
			  IN OPTIONAL LPWSTR DomainName, // ignored
			  IN          LPWSTR SamAccountName,
			  IN          LPWSTR AttributeName,
			  OUT         PULONG pulAttributeContents );
#endif

#ifdef UNICODE
#define QueryAccountControlFlags   QueryAccountControlFlagsW
#define SetAccountControlFlags     SetAccountControlFlagsW
#define TrustComputerForDelegation TrustComputerForDelegationW
#define LdapQueryUlongAttribute    LdapQueryUlongAttributeW
#else // ANSI
#define QueryAccountControlFlags   QueryAccountControlFlagsA
#define SetAccountControlFlags     SetAccountControlFlagsA
#define TrustComputerForDelegation TrustComputerForDelegationA
#define LdapQueryUlongAttribute    LdapQueryUlongAttributeA
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\delegation.c ===
/*++

  The original filename was created in RuiM's EFS common library.
  I have since changed it severely.

 *	FileName: delegation.c
 *	Author:   RuiM
 *	Copyright (c) 1998 Microsoft Corp.
 *
  CONTENTS: U(QueryAccountControlFlags)
            U(SetAccountControlFlags)
            U(LdapFindAttributeInMessage)
            U(LdapSearchForUniqueDn)

--*/


#pragma warning(disable:4057) /* indirection to slightly different
                                  base types.  Useless warning that hits
                                  thousands of times in this file. */
#pragma warning(disable:4221) /* allow nonstandard extension (automatic 
                                  initialization of a variable with 
                                  address of another automatic variable) */

#include "unimacro.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>   // required to keep winbase.h from breaking
#include <ntpoapi.h> // required to keep winbase.h from breaking
#include <windows.h>
#include <winbase.h>
#include <lmaccess.h>
#include <winldap.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include "delegation.h"
#include "delegtools.h"

// These constants are required for queries below.

TCHAR U(SamAccountAttribute)   [] = TEXT("samAccountName");
TCHAR U(UserAccountAttribute)  [] = TEXT("userAccountControl");
TCHAR U(NamingContextAttribute)[] = TEXT("defaultNamingContext");

/*++**************************************************************
  NAME:      U(LdapFindAttributeInMessage)

  This searches for a given attribute in a message (via 
  ldap_get_values_len) and returns the value.  Note that this function
  will fail if the attribute has multiple values.

  MODIFIES:  pcbData      -- receives length of the data (in bytes)
             ppvData      -- receives pointer to the data

  TAKES:     pLdap        -- ldap connection handle
             pMessage     -- message to search
             PropertyName -- property to find in the message


  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   printf on error

  CALLED BY: anyone
  FREE WITH: ppvdata should be freed with free()
  
 **************************************************************--*/

BOOL
U(LdapFindAttributeInMessage)( IN  PLDAP            pLdap,
                               IN  PLDAPMessage     pMessage,
                               IN  LPTSTR           PropertyName,
                               OUT OPTIONAL PULONG  pcbData,
                               OUT OPTIONAL PVOID  *ppvData ) {

    PLDAP_BERVAL *ppBerVals;
    BOOL          ret = FALSE;

    ppBerVals = ldap_get_values_len( pLdap,
                                     pMessage,
                                     PropertyName );

    if ( ppBerVals ) {
      
      if ( ppBerVals[ 0 ] == NULL ) {

        printf( "ERROR: empty berval structure returned when parsing "
                STRING_FMTA " attribute.\n",
                PropertyName );

        SetLastError( ERROR_INVALID_DATA );

      } else if ( ppBerVals[ 1 ] != NULL ) {

        printf( "ERROR: nonunique berval structure returned "
                "when parsing "	STRING_FMTA " attribute.\n",
                PropertyName );

        SetLastError( ERROR_DS_NAME_ERROR_NOT_UNIQUE );

      } else {

        /* this sequence is arranged in such a way that
           the important stuff comes last, keeping us
           from having to free ppvData after we've alloc'd it. */

        ret = TRUE;

        if ( pcbData ) {

          *pcbData = ppBerVals[ 0 ]->bv_len;
        }

        if ( ppvData ) {

          *ppvData = malloc( ppBerVals[ 0 ]->bv_len );

          if ( *ppvData ) {

            memcpy( *ppvData,
                    ppBerVals[ 0 ]->bv_val,
                    ppBerVals[ 0 ]->bv_len );

          } else {

            printf( "Failed to allocate %ld bytes.\n",
                    ppBerVals[ 0 ]->bv_len );

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );

            ret = FALSE;
          }
        }
      }

      ldap_value_free_len( ppBerVals );

    } else {

      printf( "Failed to retrieve values for property " STRING_FMTA 
              ": 0x%x.\n",
              PropertyName,
              pLdap->ld_errno );

      SetLastError( pLdap->ld_errno );
    }

    return ret;
}

/*++**************************************************************
  NAME:      U(LdapSearchForUniqueDn)

  Searches the DS for a DN with a match for the given search term.

  MODIFIES:  pDnOfObject -- if requested, receives the object's DN
             ppMessage   -- if requested, receives the message data

  TAKES:     pLdap                 -- ldap handle returned by ldap_open
             SearchTerm            -- what to search, e.g. "(foo=bar)"
             rzRequestedAttributes -- attributes to return in ppMessage


  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise or if the result is nonunique (WASBUG 73899).
  LASTERROR: not set

  LOGGING:   printf on failure

  CALLED BY: anyone
  FREE WITH: free pDnOfObject with ldap_memfree
             free ppMessage   with ldap_msgfree
  
 **************************************************************--*/

BOOL
U(LdapSearchForUniqueDn)( IN  PLDAP                  pLdap,
                          IN  LPTSTR                 SearchTerm,
                          IN  LPTSTR                *rzRequestedAttributes,
                          OUT OPTIONAL LPTSTR       *pDnOfObject,
                          OUT OPTIONAL PLDAPMessage *ppMessage ) {

    DWORD        dwErr;
    PLDAPMessage pMessage  = NULL;
    PLDAPMessage pResult   = NULL;
    LPTSTR       pDn       = NULL;
    LPTSTR       *ppAttrs  = NULL;
    BOOL         ret       = FALSE;
    LPTSTR       Attrs[]   = { U(NamingContextAttribute), NULL };

    /* First, determine the default naming context property for the base
       of the DSA. */

    dwErr = ldap_search_s( pLdap,
                           NULL,
                           LDAP_SCOPE_BASE,
                           TEXT("objectClass=*"),
                           Attrs,
                           FALSE,
                           &pResult );

    if ( dwErr == LDAP_SUCCESS ) {

      ppAttrs = ldap_get_values( pLdap,
                                 pResult,
                                 U(NamingContextAttribute) );

      if ( ppAttrs ) {

        dwErr = ldap_search_s( pLdap,
                               ppAttrs[ 0 ],
                               LDAP_SCOPE_SUBTREE, // search the whole tree
                               SearchTerm,
                               rzRequestedAttributes,
                               FALSE, // don't only return attr names
                               &pMessage );

        /* ldap_search_s can return a whole bunch of potential
           "success" errors.  So, I'll check to see that pMessage
           is nonnull.  This may or may not be a good thing to do,
           but it's bound to be safer than checking the error output. */

        if ( pMessage != NULL ) {

          // make sure the response is unique

          if ( !ldap_first_entry( pLdap,
                                  pMessage ) ) {

            printf( "WARNING: search term \"" STRING_FMTA "\" "
                    "produced no results.\n",
                    SearchTerm );

          } else if ( ldap_next_entry( pLdap,
                                       ldap_first_entry( pLdap,
                                                         pMessage ) ) ) {

            /* Nonunique search result.  Warn the user and 
               drop out. */

            PLDAPMessage p = pMessage;
            ULONG        i = 1;

            printf( "WARNING: search term \"" STRING_FMTA "\" returns "
                    "multiple results (should be unique).\n"
                    "\n"
                    "The results follow:\n",
                    SearchTerm );


            for ( p = ldap_first_entry( pLdap,
                                        pMessage );
                  p != NULL ;
                  p = ldap_next_entry( pLdap,
                                       p ),
                  i++ ) {

              pDn = ldap_get_dn( pLdap,
                                 p );

              if ( !pDn ) {

                printf( "%2ld. <Unknown DN: 0x%x>\n",
                        i,
                        pLdap->ld_errno );

              } else {

                printf( "%2ld. %hs\n",
                        i,
                        pDn );

                ldap_memfreeA( pDn );
              }
            }

          } else {

            ret = TRUE; // go optimistic

            if ( pDnOfObject ) {
            
              pDn = ldap_get_dn( pLdap,
                                 pMessage );

              if ( pDn ) {

                *pDnOfObject = pDn;

              } else {

                printf( "Failed to get DN from search result: 0x%x\n",
                        pLdap->ld_errno );

                SetLastError( pLdap->ld_errno );

                ret = FALSE;
              }
            }

            if ( ret && ppMessage ) {

              *ppMessage = pMessage;
              pMessage = NULL;

            }
          }

          if ( pMessage ) {
    
              ldap_msgfree( pMessage );
          }

        } else {

          printf( "FAILED: ldap_search_s failed for search term \""
                  STRING_FMTA "\": 0x%x",
                  SearchTerm,
                  dwErr );

          SetLastError( dwErr );
        }

      } else {

        printf( "FAILED: default naming context does not include"
                " requisite attribute " STRING_FMTA ".\n",

                U(NamingContextAttribute) );

        SetLastError( ERROR_CLASS_DOES_NOT_EXIST );
      }

      ldap_msgfree( pResult );

    } else {

      printf( "FAILED: unable to query default naming context: 0x%x.\n",
              dwErr );

      SetLastError( dwErr );
    }

    return ret;
}

#pragma warning(disable:4100) /* unreferenced formal parameter */

BOOL
U(LdapQueryUlongAttribute)( IN OPTIONAL PLDAP  pLdap,
                            IN OPTIONAL LPTSTR DomainName, // ignored
                            IN          LPTSTR SamAccountName,
                            IN          LPTSTR AttributeName,
                            OUT         PULONG pulAttributeContents ) {

    BOOL         CloseLdap  = FALSE;
    BOOL         ret        = FALSE;
    LPTSTR       Query      = NULL;
    LPTSTR       StringAttr = NULL;
    LPTSTR       ArrayOfAttributes[] = { AttributeName, NULL };
    PLDAPMessage pMessage   = NULL;

#if 1
    ASSERT( pLdap != NULL ); /* Change from the spec. */
#else
    if ( !pLdap ) {

      CloseLdap = ConnectAndBindToDefaultDsa( &pLdap );
    }
#endif

    if ( pLdap ) {
#define EXTRA_STUFF TEXT("(objectClass=*)")

      Query = (LPTSTR) malloc( ( lstrlen( SamAccountName ) + 
                                 sizeof( "( & (=) )") /* remaining 
                                                          components */ )
                                 * sizeof( TCHAR ) +
                                 sizeof( U(SamAccountAttribute )) +
                                 sizeof( EXTRA_STUFF ) );

      if ( Query ) {

        wsprintf( Query,
                  TEXT("(& ")
                  EXTRA_STUFF
                  TEXT("(%s=%s))"),
                  U(SamAccountAttribute),
                  SamAccountName );

        if ( U(LdapSearchForUniqueDn)( pLdap,
                                       Query,
                                       ArrayOfAttributes,
                                       NULL, // don't need the DN back.
                                       &pMessage )) {

          if ( U(LdapFindAttributeInMessage)( pLdap,
                                              pMessage,
                                              AttributeName,
                                              NULL, // don't care about length
                                              &StringAttr ) ) {

            *pulAttributeContents = _tcstoul( StringAttr, 
                                             NULL, // no endpoint
                                             0     /* use hex or dec as 
                                                      appropriate */ );

            ret = TRUE;
          }  // else message already printed

          ldap_msgfree( pMessage );
        } // else message already printed.

        free( Query );

      } else {

        printf( "FAILED: couldn't allocate memory.\n" );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
      }
      
      // close the ldap handle if we opened it.

      if ( CloseLdap ) ldap_unbind( pLdap );

    } // else printf'd already.

    return ret;
}

/*++**************************************************************
  NAME:      U(QueryAccountControlFlags)

  Opens a user and retrieves the user account control flags for it,
  using the DS.

  MODIFIES:  pulControlFlags - returned control flags on the user.

  TAKES:     pLdap          -- optional LDAP connection; if null, we'll
                               make our own and close it when finished.
             DomainName     -- domain in which to search for that account.
                               This is not currently implemented-- for
                               future use in order to support nonunique
                               accountnames that differ only by domain name.
             SamAccountName -- accountname to query (with $ for computers)

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: set.

  LOGGING:   printf on failure.

  CALLED BY: anyone
  FREE WITH: n/a
  
 **************************************************************--*/

BOOL
U(QueryAccountControlFlags)( IN OPTIONAL PLDAP  pLdap,
                             IN OPTIONAL LPTSTR DomainName, // ignored
                             IN          LPTSTR SamAccountName,
                             OUT         PULONG pulControlFlags ) {

    return U(LdapQueryUlongAttribute)( pLdap,
                                       DomainName,
                                       SamAccountName,
                                       U(UserAccountAttribute),
                                       pulControlFlags );
}


/*++**************************************************************
  NAME:      U(SetAccountControlFlags)

  Sets the accountcontrolflags on a specified account.
  Pretty much what the function name says.

  MODIFIES:  account's control flags

  TAKES:     pLdap               -- if specified, DS handle to use
             DomainName          -- account's domain (mbz)
             SamAccountName      -- account for which to search
             AccountControlFlags -- flags to set on the account

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: set

  LOGGING:   printf on failure

  CALLED BY: anyone
  FREE WITH: n/a
  
 **************************************************************--*/

BOOL
U(SetAccountControlFlags)( IN OPTIONAL PLDAP  pLdap,
                           IN OPTIONAL LPTSTR DomainName,
                           IN          LPTSTR SamAccountName,
                           IN          ULONG  AccountControlFlags ) {

    BOOL         CloseLdap  = FALSE;
    BOOL         ret        = FALSE;
    LPTSTR       Query      = NULL;
    LPTSTR       StringAttr = NULL;
    LPTSTR       ArrayOfAttributes[] = { U(UserAccountAttribute), NULL };
    LPTSTR       Dn;
    DWORD        dwErr;

#if 1
    ASSERT( pLdap != NULL ); /* Change from the spec. */
#else
    if ( !pLdap ) {

      CloseLdap = ConnectAndBindToDefaultDsa( &pLdap );

    }
#endif

    if ( pLdap ) {

      Query = (LPTSTR) malloc( ( lstrlen( SamAccountName ) + 
                                 sizeof( "( & (=) )") /* remaining 
                                                          components */ )
                                * sizeof( TCHAR ) +
                                sizeof( U(SamAccountAttribute )) +
                                sizeof( EXTRA_STUFF ) );

      if ( Query ) {

        wsprintf( Query,
                  TEXT("(& ")
                  EXTRA_STUFF
                  TEXT("(%s=%s))"),
                  U(SamAccountAttribute),
                  SamAccountName );

        if ( U(LdapSearchForUniqueDn)( pLdap,
                                       Query,
                                       ArrayOfAttributes,
                                       &Dn,
                                       NULL /* don't need the message
                                               back */ ) ) {

#pragma warning(disable:4204) /* nonstandard extension:
                                  non-constant aggregate initializer
                                  (e.g. assign an array in the initialization
                                  of a structure) */

          TCHAR   Buffer[ 50 ]; // arbitrary
          LPTSTR  Strings[] = { Buffer, NULL };
          LDAPMod TheMod   = {
            LDAP_MOD_REPLACE,
            U(UserAccountAttribute),
            Strings,
          };
          PLDAPMod rzMods[] = {
            &TheMod,
            NULL
          };

          wsprintf( Buffer, 
                    TEXT("%ld"),
                    AccountControlFlags );

          dwErr = ldap_modify_s( pLdap,
                                 Dn,
                                 rzMods );

          if ( dwErr == LDAP_SUCCESS ) {

            ret = TRUE;

          } else {

            printf( "Failed to modify " STRING_FMTA
                    " attribute to %ld (0x%x)"
                    " on " STRING_FMTA 
                    ": 0x%x\n",
                    U(UserAccountAttribute),
                    AccountControlFlags,
                    AccountControlFlags,
                    Dn,
                    dwErr );

            SetLastError( dwErr );
          }

          ldap_memfree( Dn );
        } // else message already printed.

        free( Query );

      } else {

        printf( "FAILED: couldn't allocate memory.\n" );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
      }
      
      // close the ldap handle if we opened it.

      if ( CloseLdap ) ldap_unbind( pLdap );
    } // else printf'd already.

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\delegtools.h ===
/*++

  DELEGTOOLS.H

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  DESCRIPTION: tools for delegation.  These are required to make
               the delegation library work, and should make for
	       useful tools, so I separated the header in case
	       others wanted to use them.

  Created, Dec 22, 1998 by DavidCHR.

--*/ 

BOOL
ConnectAndBindToDefaultDsa( IN OPTIONAL LPWSTR BindTarget,
			    OUT         PLDAP *ppLdap );


BOOL
LdapSearchForUniqueDnA( IN  PLDAP                  pLdap,
			IN  LPSTR                 SearchTerm,
			IN  LPSTR                *rzRequestedAttributes,
			OUT OPTIONAL LPSTR       *pDnOfObject,
			OUT OPTIONAL PLDAPMessage *ppMessage );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\secprinc.h ===
/*++

  SECPRINC.H

  convenience routines for doing a few useful things

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

--*/

BOOL
ConnectToDsa( OUT PLDAP  *ppLdap,
	      OUT LPSTR *BaseDN );

BOOL
SetStringProperty( IN PLDAP  pLdap,
		   IN LPSTR Dn,
		   IN LPSTR PropertyName,
		   IN LPSTR Property,
		   IN ULONG  Operation );

BOOL
FindUser( IN  PLDAP  pLdap,
	  IN  LPSTR  UserName,
	  OUT PULONG puacFlags,
	  OUT LPSTR *pDn );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\delegtools.c ===
/*++

  DELEGTOOLS.C

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  DESCRIPTION: tools required to support the delegation library

  Created, Dec 22, 1998 by DavidCHR.

  CONTENTS: ConnectAndBindToDefaultDsa

--*/ 


#pragma warning(disable:4057) /* indirection to slightly different
				 base types.  Useless warning that hits
				 thousands of times in this file. */
#pragma warning(disable:4221) /* allow nonstandard extension (automatic 
				 initialization of a variable with 
				 address of another automatic variable) */

#include "unimacro.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>   // required to keep winbase.h from breaking
#include <ntpoapi.h> // required to keep winbase.h from breaking
#include <windows.h>
#include <winbase.h>
#include <lmaccess.h>
#include <winldap.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include "delegtools.h"


/*++**************************************************************
  NAME:      ConnectAndBindToDefaultDsa

  does just what the function name says.  We call the default
  DSA and bind to it.  We then return the ldap handle

  MODIFIES:  ppLdap -- PLDAP returned that describes the connection
                       (now bound) to the DSA as requested
  TAKES:     BindTarget -- target (domain name or DC name) passed to ldap_open

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set.

  LOGGING:   printf is called on failure

  CALLED BY: anyone
  FREE WITH: ldap_unbind
  
 **************************************************************--*/

BOOL
ConnectAndBindToDefaultDsa( IN OPTIONAL LPWSTR BindTarget,
			    OUT         PLDAP *ppLdap ) {

    PLDAP pLdap;
    DWORD dwErr = (DWORD) STATUS_INTERNAL_ERROR;

    pLdap = ldap_openW( BindTarget, LDAP_PORT );

    if ( pLdap ) {

      dwErr = ldap_bind_s( pLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE );

      if ( dwErr == LDAP_SUCCESS ) {

	*ppLdap = pLdap;
	return TRUE;

      } else {

	printf( "FAIL: ldap_bind_s failed: 0x%x.\n",
		dwErr );

	SetLastError( dwErr );

      }

      /* note that there is no ldap_close-- we must unbind, 
	 even though we aren't actually bound.  */

      ldap_unbind( pLdap );
      
    } else {

      // ldap_open() sets lastError on failure. 

      printf( "FAIL: ldap_open failed for default server: 0x%x.\n",
	      GetLastError() );

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\secprinc.c ===
/*++

  SECPRINC.C

  Code for setting security principal data in the DS--
  specifically, the UPN, SPN, and AltSecurityIdentity

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

  CONTENTS: SetStringProperty
            FindUser
            SetUserData

--*/

#include "master.h"
#include "keytab.h"

#include <winldap.h>
#include <malloc.h>
#include "secprinc.h"
#include "delegtools.h"

extern BOOL /* delegation.c */
LdapFindAttributeInMessageA( IN  PLDAP            pLdap,
			     IN  PLDAPMessage     pMessage,
			     IN  LPSTR            PropertyName,
			     OUT OPTIONAL PULONG  pcbData,
			     OUT OPTIONAL PVOID  *ppvData );

/*****************************************************************
  NAME:      ConnectToDsa

  connects to the DSA, binds, and searches for the base DN.
  
  TAKES:     nothing
  RETURNS:   TRUE ( and a pLdap and wide-string baseDn ) on success
             FALSE and a stderr message on failure.
  CALLED BY: 
  FREE WITH: BaseDN should be freed with free(),
             the ldap handle should be closed with ldap_unbind.
  
 *****************************************************************/


BOOL
ConnectToDsa( OUT PLDAP  *ppLdap,
	      OUT LPSTR *BaseDN ) { // free with free()
	      
    PLDAP pLdap;
    BOOL  ret = FALSE;
    ULONG lderr;

    pLdap = ldap_open( NULL, LDAP_PORT );
    
    if ( pLdap ) {

      lderr = ldap_bind_s( pLdap, NULL, NULL, LDAP_AUTH_SSPI );

      if ( lderr == LDAP_SUCCESS ) {

	LPSTR       Context      = "defaultNamingContext";
	LPSTR       Attributes[] = { Context, NULL };
	PLDAPMessage pMessage, pEntry;
	LPSTR      *pValue;

	// now, guess the DSA Base:

	lderr = ldap_search_sA( pLdap,
				NULL,
				LDAP_SCOPE_BASE,
				"objectClass=*",
				Attributes,
				FALSE, // just return attributes
				&pMessage );

	if ( lderr == LDAP_SUCCESS ) {

	  pEntry = ldap_first_entry( pLdap, pMessage );

	  if ( pEntry ) {
	    
	    pValue = ldap_get_valuesA( pLdap, pEntry, Context );

	    if ( pValue ) {

	      ULONG size;

	      size = ldap_count_valuesA( pValue );

	      if ( 1 == size ) {
		
		LPSTR dn;
		size = ( lstrlenA( *pValue ) +1 /*null*/) * sizeof( WCHAR );

		dn = (LPSTR) malloc( size );
		
		if ( dn ) {

		  memcpy( dn, *pValue, size );
		  
		  *BaseDN = dn;
		  *ppLdap = pLdap;
		  ret     = TRUE;

		} else fprintf( stderr,
				"failed to malloc to duplicate \"%s\".\n",
				*pValue );

	      } else fprintf( stderr,
			      "too many values (expected one, got %ld) for"
			      " %s.\n",
			      size,
			      Context );

	      ldap_value_freeA( pValue );

	    } else fprintf( stderr,
			    "ldap_get_values failed: 0x%x.\n",
			    GetLastError() );

	  } else fprintf( stderr,
			  "ldap_first_entry failed: 0x%x.\n",
			  GetLastError() );

	  ldap_msgfree( pMessage );

	} else fprintf( stderr,
			"ldap_search failed (0x%x).  "
			"Couldn't search for base DN.\n",
			lderr );

	if ( !ret ) ldap_unbind_s( pLdap );

      } else fprintf( stderr,
		      "Failed to bind to DSA: 0x%x.\n",
		      lderr );

      // there is no ldap_disconnect.

    } else fprintf( stderr,
		    "Failed to contact DSA: 0x%x.\n",
		    GetLastError() );

    return ret;

}
	      
/*++**************************************************************
  NAME:      SetStringProperty

  sets the given property of the given object to the given string

  MODIFIES:  object's property value

  TAKES:     pLdap        -- ldap connection handle
             Dn           -- FQDN of the object whose property is munged
             PropertyName -- property to modify
             Property     -- value to put in the property
             Operation    -- set / add / delete, etc.


  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: set

  LOGGING:   on failure
  CREATED:   Jan 22, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a  -- no resources are returned
  
 **************************************************************--*/

BOOL
SetStringProperty( IN PLDAP  pLdap,
		   IN LPSTR Dn,
		   IN LPSTR PropertyName,
		   IN LPSTR Property,
		   IN ULONG  Operation ) {

    LPSTR    Vals[] = { Property, NULL };
    LDAPModA  Mod    = { Operation,
			 PropertyName,
			 Vals };
    PLDAPModA Mods[] = { &Mod, NULL };
    ULONG     lderr;


    lderr = ldap_modify_sA( pLdap,
			    Dn,
			    Mods );

    if ( lderr == LDAP_SUCCESS ) {

      return TRUE;

    } else {
      
      fprintf( stderr, 
	       "Failed to set property \"%hs\" to \"%hs\" on Dn \"%hs\": "
	       "0x%x.\n",

	       PropertyName, 
	       Property,
	       Dn,
	       lderr );

      SetLastError( lderr );

    }
    
    return FALSE;
    
}

/*++**************************************************************
  NAME:      FindUser

  searches the DS for the given user.

  MODIFIES:  pDn       -- returned DN for that user.
	     puacflags -- receives the user's AccountControl flags

  TAKES:     pLdap     -- LDAP handle
             UserName  -- user samaccountname for which to search

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not explicitly set
  LOGGING:   on failure
  CREATED:   Jan 22, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: free the dn with ldap_memfree
  
 **************************************************************--*/

BOOL
FindUser( IN  PLDAP pLdap,
	  IN  LPSTR UserName,
	  OUT PULONG puacFlags,
	  OUT LPSTR *pDn ) {

    LPSTR Query;
    BOOL  ret = FALSE;
    LPSTR Attributes[] = { "userAccountControl", 
			   NULL }; // what attributes to fetch; none
    PLDAPMessage pMessage = NULL;
    LPSTR        StringUac;

    Query = (LPSTR) malloc( lstrlenA( UserName ) + 100 ); // arbitrary

    if ( Query ) {

      wsprintfA( Query,
		 "(& (objectClass=person) (samaccountname=%hs))",
		 UserName );

      if( LdapSearchForUniqueDnA( pLdap,
				  Query,
				  Attributes,
				  pDn,
				  &pMessage ) ) {

	if ( LdapFindAttributeInMessageA( pLdap,
					  pMessage,
					  Attributes[ 0 ],
					  NULL, // length doesn't matter
					  &StringUac ) ) {

	  *puacFlags = strtoul( StringUac,
				NULL,
				0 );

	} else {

	  /* Signal the caller that we don't know the uacflags. */
	  *puacFlags = 0;

	}

	ret = TRUE;

      } else {

	fprintf( stderr, 
		 "Failed to locate user \"%hs\".\n",
		 Query );

      }

      if ( pMessage ) ldap_msgfree( pMessage );
      free( Query );

    } else {

      fprintf( stderr,
	       "allocation failed building query for LDAP search.\n" );

    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\unimacro.h ===
/*++

  UNIMACRO.H

  Macros to handle unicode conversions and naming schemes for 
  unicode independent files.

  4/17/1997 DavidCHR, Created

  --*/

#ifdef UNICODE
#define U(functionName)           functionName##W
#define NU(functionName)          functionName##A
#define NTEXT( text )             text
#define LPNSTR                    LPSTR

#define UAWA                       "W"
#define UAWW                      L"W"
#define STR_FMTA                   "ws"
#define STR_FMTW                  L"ws"
#define STRING_FMTA                "%ws" // "%" STR_FMTA causes problems
#define STRING_FMTW               L"%ws" // L"%" STR_FMTW causes problems
#define WIDE_OR_ASCII( testname ) Wide_##testname 


#else /* NOT UNICODE */

#define U(functionName)           functionName##A
#define NU(functionName)          functionName##W
#define NTEXT( text )             L##text
#define LPNSTR                    LPWSTR

#define UAWA                       "A"
#define UAWW                      L"A"
#define STR_FMTA                   "hs"
#define STR_FMTW                  L"hs"
#define STRING_FMTA                "%hs" // "%" STR_FMTA causes problems
#define STRING_FMTW               L"%hs" // L"%" STR_FMTW causes problems
#define WIDE_OR_ASCII( testname ) Ascii_##testname 


#endif /* UNICODE */

/* define these so that you can use TEXT(UAW) and TEXT(STRING_FMT) */

#define LUAW                      UAWW
#define UAW                       UAWA
#define LSTRING_FMT               STRING_FMTW
#define STRING_FMT                STRING_FMTA

/* evidently someone has failed to put these definitions
   where I could find them.  So I'm putting them all here. */

#define TFGETC                      U(TFGETC_)
#define TFGETC_W                    fgetwc
#define TFGETC_A                    fgetc

#define TFPUTC                      U(TFPUTC_)
#define TFPUTC_W                    fputwc
#define TFPUTC__A                    fputc

#define TGETCHAR                    U(TGETCHAR_)
#define TGETCHAR_A                  getchar
#define TGETCHAR_W                  getwchar

#define TPUTCHAR                    U(TPUTCHAR_)
#define TPUTCHAR_A                  putchar
#define TPUTCHAR_W                  putwchar

#define TFGETS                      U(TFGETS_)
#define TFGETS_A                    fgets
#define TFGETS_W                    fgetws

#define TFPUTS                      U(TFPUTS_)
#define TFPUTS_A                    fputs
#define TFPUTS_W                    fputws

#define TFPRINTF                    U(TFPRINTF_)
#define TFPRINTF_A                  fprintf
#define TFPRINTF_W                  fwprintf

#define TPRINTF                     U(TPRINTF_)
#define TPRINTF_A                   printf
#define TPRINTF_W                   wprintf

#define TSNPRINTF                   U(TSNPRINTF_)
#define TSNPRINTF_A                 snprintf
#define TSNPRINTF_W                 _snwprintf

#define TSPRINTF                    U(TSPRINTF_)
#define TSPRINTF_A                  sprintf
#define TSPRINTF_W                  swprintf

#define TVSNPRINTF                  U(TVSNPRINTF_)
#define TVSNPRINTF_A                _vsnprintf
#define TVSNPRINTF_W                _vsnwprintf

#define TVSPRINTF                   U(TVSPRINTF_)
#define TVSPRINTF_A                 vsprintf
#define TVSPRINTF_W                 vswprintf

#define TFSCANF                     U(TFSCANF_)
#define TFSCANF_A                   fscanf
#define TFSCANF_W                   fwscanf

#define TSSCANF                     U(TSSCANF_)
#define TSSCANF_A                   sscanf
#define TSSCANF_W                   swscanf

#define TSCANF                      U(TSCANF_)
#define TSCANF_A                    scanf
#define TSCANF_W                    wscanf

#define TFOPEN                      U(TFOPEN_)
#define TFOPEN_A                    fopen
#define TFOPEN_W                    _wfopen

#define TFREOPEN                    U(TFREOPEN_)
#define TFREOPEN_A                  freopen
#define TFREOPEN_W                  _wfreopen

#define TATOI                       U(TATOI_)
#define TATOI_A                     atoi
#define TATOI_W                     _wtoi

#define TATOL                       U(TATOL_)
#define TATOL_A                     atol
#define TATOL_W                     _wtol

#define TATOLD                      U(TATOLD_)
#define TATOLD_A                    atold
#define TATOLD_W                    _wtold

#define TSTRTOD                     U(TSTRTOD_)
#define TSTRTOD_A                   strtod
#define TSTRTOD_W                   wcstod

#define TSTRTOL                     U(TSTRTOL_)
#define TSTRTOL_A                   strtol
#define TSTRTOL_W                   wcstol

#define TSTRTOUL                    U(TSTRTOUL_)
#define TSTRTOUL_A                  strtoul
#define TSTRTOUL_W                  wcstoul

#define TVFPRINTF                   U(TVFPRINTF_)
#define TVFPRINTF_A                 vfprintf
#define TVFPRINTF_W                 vfwprintf

#define TVPRINTF                    U(TVPRINTF_)
#define TVPRINTF_A                  vprintf
#define TVPRINTF_W                  vwprintf

#define TSTRCAT                     U(TSTRCAT_)
#define TSTRCAT_A                   strcat
#define TSTRCAT_W                   wcscat

#define TSTRCHR                     U(TSTRCHR_)
#define TSTRCHR_A                   strchr
#define TSTRCHR_W                   wcschr

#define TSTRRCHR                     U(TSTRRCHR_)
#define TSTRRCHR_A                   strrchr
#define TSTRRCHR_W                   wcsrchr

#define TSTRCMP                     U(TSTRCMP_)
#define TSTRCMP_A                   strcmp
#define TSTRCMP_W                   wcscmp

#define TSTRCPY                     U(TSTRCPY_)
#define TSTRCPY_A                   strcpy
#define TSTRCPY_W                   wcscpy

#define TSTRLEN                     U(TSTRLEN_)
#define TSTRLEN_A                   strlen
#define TSTRLEN_W                   wcslen

#define TSTRNCMP                    U(TSTRNCMP_)
#define TSTRNCMP_A                  strncmp
#define TSTRNCMP_W                  wcsncmp

#define TSTRCMPI                    U(TSTRCMPI_)
#define TSTRCMPI_A                  strcmpi
#define TSTRCMPI_W                  wcscmpi

#define TSTRSTR                     U(TSTRSTR_)
#define TSTRSTR_A                   strstr
#define TSTRSTR_W                   wcsstr

#define TSTRTOK                     U(TSTRTOK_)
#define TSTRTOK_A                   strtok
#define TSTRTOK_W                   wcstok

#define TSTRDUP                     U(TSTRDUP_)
#define TSTRDUP_A                   strdup
#define TSTRDUP_W                   wcsdup

#define TSTRICMP                    U(TSTRICMP_)
#define TSTRICMP_A                  strcmpi
#define TSTRICMP_W                  wcscmpi

#define TSTRNICMP                   U(TSTRNICMP_)
#define TSTRNICMP_A                 strnicmp
#define TSTRNICMP_W                 wcsnicmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\ldlib\setprop.c ===
/*++

  SETPROP.C

  umappl to set properties.

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

--*/


#include "master.h"
#include "keytab.h"

#include <winldap.h>
#include <malloc.h>
#include "secprinc.h"

#include "options.h"

int __cdecl
main( int argc,
      PCHAR argv[] ) {

    LPSTR TargetDn      = NULL;
    LPSTR PropertyName  = NULL;
    LPSTR PropertyValue = NULL;
    ULONG  Operation     = LDAP_MOD_ADD;

    optEnumStruct Operations[] = {

      { "Add",     (PVOID) LDAP_MOD_ADD,     "Add the value (default)" },
      { "Replace", (PVOID) LDAP_MOD_REPLACE, "change the value" },
      { "Delete",  (PVOID) LDAP_MOD_DELETE,  "Delete the value" },

      TERMINATE_ARRAY

    };

    optionStruct options[] = {

      { "?",  NULL, OPT_HELP },
      { "TargetDn", &TargetDn, OPT_STRING | OPT_NONNULL | OPT_DEFAULT,
	"target to set property of." },
      
      { "PropertyName", &PropertyName, 
	OPT_STRING | OPT_NONNULL | OPT_DEFAULT,
	"Name of the property we're setting." },

      { "PropertyVal",  &PropertyValue,
	OPT_STRING | OPT_NONNULL | OPT_DEFAULT,
	"Value we'll set the property to." },

      { "op", &Operation, OPT_ENUMERATED | OPT_ENUM_IS_MASK,
	"What to do to the object property",
	Operations },

      TERMINATE_ARRAY

    };
    
    PVOID  pvTrash;
    PLDAP  pLdap;
    LPSTR BaseDn;
    int    ret;

    ParseOptionsEx( argc-1,
		    argv+1,
		    options,
		    OPT_FLAG_TERMINATE,
		    &pvTrash,
		    NULL, NULL );

    if ( ConnectToDsa( &pLdap,
		       &BaseDn ) ) {

      free( BaseDn );

      if ( SetStringProperty( pLdap,
			      TargetDn,
			      PropertyName,
			      PropertyValue,
			      Operation ) ) {

	ret = 0;

	fprintf( stderr,
		 "success!\n" );

      } else ret = GetLastError();

      ldap_unbind( pLdap );

    } else ret = 3;

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\lib\keytab.c ===
/*++

  KEYTAB.C

  Implementation of the actual keytab routines.

  Copyright (C) 1997 Microsoft Corporation
  Created 01-10-1997 DavidCHR

  --*/

#include "master.h"
#include "keytab.h"
#include "keytypes.h"
#include "defs.h"

/* declaring KEYTAB_ALLOC and KEYTAB_FREE lets me hook into these
   routines whenever I want.  when it's done, I'll just #def them. */

PVOID
KEYTAB_ALLOC ( KTLONG32 numBytes ) {

    return malloc(numBytes);

}

VOID
KEYTAB_FREE  ( PVOID toFree ) {

    free(toFree);

}

PKTENT
CloneKeyEntry( PKTENT pEntry ) {

    KTLONG32  i;
    PKTENT p=NULL;
    BOOL   ret=FALSE;

    p = (PKTENT) KEYTAB_ALLOC( sizeof( KTENT ) );
    BREAK_IF( p == NULL,
          "Failed to alloc base key struct",
          cleanup );
    memcpy(   p, pEntry, sizeof(KTENT) );

    p->Components = NULL; // initialize these in case of failure.
    p->KeyData    = NULL;

    p->Realm = (PCHAR) KEYTAB_ALLOC( p->szRealm );
    BREAK_IF( p->Realm == NULL, "Failed to alloc realm data", cleanup );
    memcpy(   p->Realm, pEntry->Realm, p->szRealm );

    p->Components = (PKTCOMPONENT) KEYTAB_ALLOC( p->cEntries *
                         sizeof(KTCOMPONENT) );

    BREAK_IF( p->Components == NULL, "Failed to alloc components", cleanup );

    for ( i = 0 ; i < p->cEntries ; i++ ) {

      p->Components[i].szComponentData =
    pEntry->Components[i].szComponentData;

      memcpy( p     ->Components[i].Component,
          pEntry->Components[i].Component,
          p     ->Components[i].szComponentData );
    }

    p->KeyData = (PK5_OCTET) KEYTAB_ALLOC ( p->KeyLength );
    BREAK_IF( p->KeyData == NULL, "Failed to alloc keydata", cleanup );
    memcpy( p->KeyData, pEntry->KeyData, p->KeyLength );

    return p;

cleanup:

    FreeKeyEntry(p);
    return NULL;
}


/* base linklist operations */

BOOL
AddEntryToKeytab( PKTFILE Keytab,
          PKTENT  Entry,
          BOOL    copy ) {

    PKTENT p;

    if (copy) {
      p = CloneKeyEntry( Entry );
    } else {
      p = Entry;
    }

    if (p == NULL ) {
      return FALSE;
    }

    if ( NULL == Keytab->FirstKeyEntry ) {

      Keytab->FirstKeyEntry = Keytab->LastKeyEntry = p;

    } else {
      Keytab->LastKeyEntry->nextEntry = p;
      Keytab->LastKeyEntry = p;
    }

    return TRUE;

}

BOOL
RemoveEntryFromKeytab( PKTFILE Keytab,
               PKTENT  Entry,
               BOOL    dealloc ) {

    if ( (NULL == Keytab) || ( NULL == Entry ) ) {
      return FALSE;
    }

    if ( Keytab->FirstKeyEntry == Entry ) {

      // removing the first key

      Keytab->FirstKeyEntry = Entry->nextEntry;

      if ( Entry->nextEntry == NULL ) {
    // we're the ONLY entry.

    Keytab->LastKeyEntry = NULL;

      }

    } else {
      BOOL found=FALSE;
      PKTENT p;

      // scroll through the keys, looking for this one.
      // not very efficient, but keytabs shouldn't get very big.

      for (p =  Keytab->FirstKeyEntry;
       p != NULL;
       p =  p->nextEntry ) {

    if (p->nextEntry == Entry) {
      found = TRUE;
      p->nextEntry = Entry->nextEntry;
      break;
    }
      }

      if (!found) {

    // wasn't in the linklist.
    return FALSE;
      }

      if (Entry->nextEntry == NULL ) {

    // removing the last key entry.
    Keytab->LastKeyEntry = p;
      }

    }

    if (dealloc) {

      FreeKeyEntry(Entry);

    }

    return TRUE;

}


VOID
FreeKeyEntry( PKTENT pEntry) {

    KTLONG32 i;

    if (pEntry != NULL) {

      if (pEntry->Realm != NULL ) {
    KEYTAB_FREE(pEntry->Realm);
      }

      if (pEntry->KeyData != NULL) {
    KEYTAB_FREE(pEntry->KeyData);
      }

      if (pEntry->Components != NULL) {
    for (i = 0; i < pEntry->cEntries ; i++ ) {
      if ( pEntry->Components[i].Component != NULL ) {
        KEYTAB_FREE(pEntry->Components[i].Component);
      }
    }
    KEYTAB_FREE(pEntry->Components);
      }

      KEYTAB_FREE(pEntry );
    }

}

VOID
FreeKeyTab( PKTFILE pktf ) {

    PKTENT pEntry=NULL;
    PKTENT next=NULL;

    if (pktf != NULL) {
      for (pEntry = pktf->FirstKeyEntry ;
       pEntry != NULL;
       pEntry = next ) {
    KTLONG32 i;

    next = pEntry->nextEntry; /* must do this, because we're freeing
                     as we go */
    FreeKeyEntry( pEntry );

    KEYTAB_FREE(pEntry );

      }
      KEYTAB_FREE(pktf);
    }

}

/* These macros make this somewhat LESS painful */

#define READ(readwhat, errormsg, statusmsg) { \
    debug(statusmsg); \
    BREAK_IF( !Read(hFile, &(readwhat), sizeof(readwhat), 1), \
          errormsg, cleanup); \
    debug("ok\n"); \
}

#define READSTRING(readwhat, howlong, errormsg, statusmsg) { \
    debug(statusmsg); \
    BREAK_IF( !Read(hFile, readwhat, sizeof(CHAR), howlong), \
          errormsg, cleanup); \
    debug("ok\n"); \
}

#define WRITE(writewhat, description) { \
    debug("writing %hs...", description); \
    BREAK_IF( !Write(hFile, &(writewhat), sizeof(writewhat), 1), \
          "error writing " description, cleanup); \
    debug("ok\n"); \
}

#define WRITE_STRING(writewhat, howlong, description) { \
    debug("writing %hs...", description); \
    BREAK_IF( !Write(hFile, writewhat, sizeof(CHAR), howlong), \
          "error writing " description, cleanup); \
    debug("ok\n"); \
}

#define WRITE_X( size, marshaller, writewhat, description ) { \
    K5_INT##size k5_marshaller_variable; \
    k5_marshaller_variable = marshaller( writewhat );\
    WRITE( k5_marshaller_variable, description );\
}

// NBO-- Network Byte Order

#define WRITE_NBO( writewhat, description) {\
    switch( sizeof( writewhat ) ) {\
     case 1: /* marshall a char? */\
     debug("marshalling a char(?)...");\
     WRITE( writewhat, description );\
     break;\
     case 2:\
     debug( #writewhat ": marshalling a short...");\
     WRITE_X( 16, htons, ((unsigned short)writewhat), description);\
     break;\
     case 4:\
     debug( #writewhat ": marshalling a long...");\
     WRITE_X( 32, htonl, writewhat, description);\
     break;\
     default:\
      fprintf(stderr, "Not written: argument is of unhandled size (%d)\n",\
          sizeof(writewhat));\
    }}



/* Write:

   helper function to write raw bytes to disk.  Takes:

   hFile:      handle to a file open for writing.
   source:     pointer to data to be written to the file
   szSource:   size of one data element in Source
   numSources: number of data elements in Source

   (basically, it tries to write szSource * numSources of raw bytes
    from source to the file at hFile).

   returns TRUE if it succeeds, and FALSE otherwise.

   */

BOOL
Write( IN HANDLE hFile,
       IN PVOID  source,
       IN KTLONG32  szSource,
       IN KTLONG32  numSources /* =1 */ ) {

#ifdef WINNT /* Windows NT implementation of the file write call */

    KTLONG32 temp;
    KTLONG32 i;

    temp = szSource * numSources;

    debug("(writing %d bytes: ", temp );
    for (i = 0; i < temp ; i++ ) {

      unsigned char byte;

      byte = ((PCHAR) source)[i];

      debug("%02x", byte );
    }
    debug(")");

    return WriteFile( hFile, source, temp, &temp, NULL );

#else

    ssize_t bytesToWrite, bytesWritten;

    bytesToWrite = szSource * numSources;
    bytesWritten = write( hFile, (const void *)source,
              bytesToWrite );

    if( bytesWritten == -1 ) {
      debug("WARNING: nothing written to the file!  Errno = 0x%x / %d\n",
        errno , errno );
      return FALSE;
    }

    if ( bytesWritten != bytesToWrite ) {
      debug("WARNING: not all bytes made it to the file (?)\n"
        "         errno = 0x%x / %d\n", errno, errno );
      return FALSE;
    }

    return TRUE;

#endif

}

/* Read:

   Semantics and return are the same as for "Write", except that
   target is filled with szTarget*numTargets bytes from hFile, and that
   hFile must be open for read access.

   */

BOOL
Read( IN  HANDLE hFile,
      OUT PVOID  target,
      IN  KTLONG32  szTarget,
      IN  KTLONG32  numTargets/* =1 */) {

    BOOL ret = FALSE;

#ifdef WINNT /* the SetFilePointer shinanigens are me trying to check on
                how many bytes have ACTUALLY been read/written from the
                file */

    KTLONG32 temp;
    KTLONG32 filepos;
    LONG  zero=0L;

    filepos = SetFilePointer( hFile, 0, &zero, FILE_CURRENT);

    debug("reading %d bytes from pos 0x%x...", szTarget * numTargets,
      filepos);

    ret = ReadFile( hFile, 
                    target, 
                    (szTarget*numTargets),
                    &temp, 
                    NULL );

    if ( !ret ) {

      debug( "ReadFile failed: 0x%x\n",
             GetLastError() );

    } else if ( !temp ) {

      debug( "ReadFile read zero bytes.  Assuming EOF\n" );

      SetLastError( ERROR_HANDLE_EOF );
      ret = FALSE;

    } else {

      temp = SetFilePointer( hFile, 0, &zero, FILE_CURRENT);
      
      if ( filepos == temp ) {
        debug("WARNING!  file position has not changed!");
        SetLastError( ERROR_NO_DATA );
        return FALSE;
      }
    }

#else /* UNIX IMPLEMENTATION-- since read() returns the number of bytes
         that we actually read from the file, the
         SetFilePointer (fseek) nonsense is not
         required. */

    ssize_t bytesRead;
    ssize_t bytesToRead;

    bytesToRead = szTarget * numTargets;

    bytesRead = read( hFile, target, bytesToRead );

    if ( bytesRead == -1 ) {
      debug("WARNING!  An error occurred while writing to the file!\n"
        "ERRNO: 0x%x / %d.\n", errno, errno );

    }

    ret = (bytesRead == bytesToRead );

#endif

    return ret;
}

BOOL
ReadKeytabFromFile( PKTFILE *ppktfile, // free with FreeKeyTab when done
            PCHAR    filename ) {

    PKTFILE  ktfile=NULL;
    HANDLE   hFile = NULL;
    BOOL     ret=FALSE;
    KTLONG32    i;

    BREAK_IF( ppktfile == NULL,
          "passed a NULL save-pointer",
          cleanup );

    debug("Opening keytab file \"%hs\"...", filename);

#ifdef WINNT
    hFile = CreateFileA( filename,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             FILE_ATTRIBUTE_NORMAL,
             NULL );

    BREAK_IF ( (NULL == hFile) || ( INVALID_HANDLE_VALUE == hFile ),
           "Failed to open file!", cleanup );

#else

    hFile = open( filename, O_RDONLY,
          /* file mask is 0x550: read-write by user and group */
          S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP );

    BREAK_IF( hFile == -1,
          "Failed to open file!", cleanup );

#endif

    debug("ok!\n");

    ktfile = (PKTFILE) KEYTAB_ALLOC (sizeof(KTFILE));

    /* Prefix bug 439480 resulted from the below BREAK_IF
       being interchanged with initialization code.  Duhhh. */

    BREAK_IF( ktfile == NULL,
          "Failed to allocate ktfile",
          cleanup );

    ktfile->FirstKeyEntry = ktfile->LastKeyEntry = NULL;

    READ( ktfile->Version, "Failed to read KTVNO",
      "reading KTVNO");

    /* Version number is stored in network byte order */

    ktfile->Version = ntohs( ktfile->Version);

    debug("Keytab version 0x%x\n", ktfile->Version );

    do {
      PKTENT entry=NULL;

      entry             = (PKTENT) KEYTAB_ALLOC(sizeof(KTENT));

      // PREFIX bug 439481: not checking the result of KEYTAB_ALLOC.

      BREAK_IF( !entry,
        "Unable to alloc a new KTENT.",
        cleanup );

      entry->Realm      = NULL;
      entry->Components = NULL;
      entry->KeyData    = NULL;
      entry->nextEntry  = NULL;

#if 1
      if ( !Read( hFile, 
                  &(entry->keySize),
                  sizeof( entry->keySize ),
                  1 ) ) {

        if ( GetLastError() != ERROR_HANDLE_EOF ) {

          fprintf( stderr,
                   "\n ** Failed to read Keytab %hs's leading bytes: 0x%x\n",
                   filename,
                   GetLastError() );

        } else {

          ret = TRUE;

        }

        break;
      }

#else
      BREAK_IF( !Read( hFile, &(entry->keySize), sizeof(entry->keySize), 1),
        "Failed to read leading bytes (probably done)",
        no_more_entries );
#endif

      entry->keySize = htonl(entry->keySize);
      debug("trash bytes: 0x%x\n", entry->keySize );

      /* Quickly perform linklist operation on the new node */

      if (NULL == ktfile->FirstKeyEntry) {
    ktfile->FirstKeyEntry = ktfile->LastKeyEntry = entry;
      } else {
    ktfile->LastKeyEntry->nextEntry = entry;
    ktfile->LastKeyEntry = entry;
      }

      READ( entry->cEntries,
        "Failed to read key's number of components",
        "reading key components...");

      entry->cEntries = ntohs( entry->cEntries );
      debug("components number %d\n", entry->cEntries );

      READ( entry->szRealm,
        "Failed to read key's realm size",
        "reading key realm size...");

      entry->szRealm = ntohs( entry->szRealm );
      debug("realm size %d\n", entry->szRealm);

      entry->Realm = (PCHAR) KEYTAB_ALLOC( ( entry->szRealm +1 ) 
                                           * sizeof(CHAR) );

      BREAK_IF ( !entry->Realm,
         "Could not allocate key's realm storage",
         cleanup );

      READSTRING( entry->Realm, entry->szRealm,
          "Could not read key's realmname",
          "reading realmname...");

      entry->Realm[ entry->szRealm ] = '\0';
      
      debug("realm: \"%hs\"\n", entry->Realm );
      entry->Components = (PKTCOMPONENT) KEYTAB_ALLOC (entry->cEntries *
                        sizeof(KTCOMPONENT));

      BREAK_IF( !entry->Components,
        "Could not allocate key components!",
        cleanup );

      for (i = 0 ; i < entry->cEntries ; i++ ) {

    READ( entry->Components[i].szComponentData,
          "Failed to read component size for one entry",
          "reading key component size...");

    entry->Components[i].szComponentData =
      ntohs( entry->Components[i].szComponentData );

    debug("Component size: %d\n",
          entry->Components[i].szComponentData );

    entry->Components[i].Component = (PCHAR) KEYTAB_ALLOC (
         ( entry->Components[i].szComponentData +1 ) *
         sizeof(CHAR) );

    entry->Components[i].Component[ 
         entry->Components[i].szComponentData ] = '\0';

    BREAK_IF( !entry->Components[i].Component,
          "Could not allocate entry component storage",
          cleanup );

    READSTRING( entry->Components[i].Component,
            entry->Components[i].szComponentData,
            "Failed to read component data",
            "reading component data...");

    debug("Component data: \"%hs\"\n",
          entry->Components[i].Component );

      }

      READ( entry->PrincType,
        "Failed to read principal type",
        "reading principal type...");

      entry->PrincType = ntohl( entry->PrincType ); // in network byte order
      debug("princtype: %d\n", entry->PrincType);

      READ( entry->TimeStamp,
        "Failed to read entry timestamp",
        "reading timestamp...");

      entry->TimeStamp = ntohl( entry->TimeStamp ); // also network bytes.
      debug("Timestamp 0x%x\n", entry->TimeStamp );

      READ( entry->Version,
        "Failed to read kvno",
        "reading kvno...");

      // kvno is in host order already.

      READ( entry->KeyType,
        "Failed to read entry encryption type",
        "reading encryption type...");

      entry->KeyType = ntohs( entry->KeyType );

      READ( entry->KeyLength,
        "Failed to read entry keylength",
        "reading keylength... ");

#if 1
      entry->KeyLength = ntohs ( entry->KeyLength );

#else // I used to think this was 32-bit.

      entry->KeyLength = ntohl ( entry->KeyLength );
#endif

      debug("KeyLength is %d\n", entry->KeyLength);

      entry->KeyData = (PK5_OCTET) KEYTAB_ALLOC (entry->KeyLength *
                      sizeof(K5_OCTET));

      BREAK_IF( !entry->KeyData,
        "Could not allocate entry keydata storage",
        cleanup );

      READSTRING( entry->KeyData, entry->KeyLength,
          "Failed to read entry key data",
          "reading key data")

    } while (1);

cleanup:

#ifdef WINNT
    if ((hFile != NULL) && ( hFile != INVALID_HANDLE_VALUE)) {
      CloseHandle(hFile);
    }
#else
    if (hFile != -1 ) {
      close(hFile);
    }
#endif

    if (ret) {
      *ppktfile = ktfile;
    } else {
      FreeKeyTab( ktfile );
    }
    return ret;

}

/* define this macro only for DisplayKeytab.
   It's a convenience routine to print this field only if the option
   is set. */

#define PRINTFIELD( option, format, value ) { if (options & option) { fprintf(stream, format, value); } }

/* DisplayKeytab:

   prints out the keytab, using options to define which fields we want
   to actually see.  (see keytab.hxx for what to put in "options") */

VOID
DisplayKeytab( FILE   *stream,
           PKTFILE ktfile,
           KTLONG32   options) {

    KTLONG32  i;
    PKTENT ent;



    if (options == 0L) {
      return;
    }

    PRINTFIELD(KT_KTVNO, "Keytab version: 0x%x\n", ktfile->Version);

    for (ent = ktfile->FirstKeyEntry ;
     ent != NULL;
     ent = ent->nextEntry ) {

      PRINTFIELD( KT_RESERVED, "keysize %d ", ent->keySize );

      for (i = 0 ; i < ent->cEntries ; i++ ) {
    PRINTFIELD( KT_COMPONENTS,
            (i == 0 ? "%hs" : "/%hs"),
            ent->Components[i].Component );
      }

      PRINTFIELD( KT_REALM, "@%hs", ent->Realm );
      PRINTFIELD( KT_PRINCTYPE, " ptype %d", ent->PrincType );
      PRINTFIELD( KT_PRINCTYPE, " (%hs)", LookupTable( ent->PrincType, &K5PType_Strings ).string);
      PRINTFIELD( KT_VNO, " vno %d", ent->Version );
      PRINTFIELD( KT_KEYTYPE, " etype 0x%x", ent->KeyType );
      PRINTFIELD( KT_KEYTYPE, " (%hs)", LookupTable( ent->KeyType,
                             &K5EType_Strings ).string );
      PRINTFIELD( KT_KEYLENGTH, " keylength %d", ent->KeyLength );

      if (options & KT_KEYDATA ) {

    fprintf(stream, " (0x" );
    for ( i = 0 ; i < ent->KeyLength ; i++ ) {
      fprintf(stream, "%02x", ent->KeyData[i] );
    }
    fprintf(stream, ")" );
      }

      fprintf(stream, "\n");
    }
}

#undef PRINTFIELD // we only need it for that function

/* computes the length of a kerberos keytab for the keySize field */

K5_INT32
ComputeKeytabLength( PKTENT p ) {

    K5_INT32 ret=0L;
    KTLONG32    i;

    // these are the variables within this level

    ret = p->szRealm + p->KeyLength;

    // these are static

    ret += ( sizeof( p->cEntries )  + sizeof(p->szRealm)     +
         sizeof( p->PrincType ) + sizeof( p->TimeStamp ) +
         sizeof( p->Version )   + sizeof (p->KeyLength ) +
         sizeof( p->KeyType )   );

    for (i = 0 ; i < p->cEntries; i++ ) {
      ret += ( p->Components[i].szComponentData +
           sizeof(p->Components[i].szComponentData) );
    }

    debug("ComputeKeytabLength: returning %d\n", ret);

    return ret;
}

/* This depends very much on the same keytab model that
   the other functions do */

BOOL
WriteKeytabToFile(  PKTFILE ktfile,
            PCHAR   filename ) {

    HANDLE   hFile = NULL;
    BOOL     ret=FALSE;
    KTLONG32    i;
    PKTENT   entry;

    BREAK_IF( ktfile == NULL,
          "passed a NULL save-pointer",
          cleanup );

    debug("opening keytab file \"%hs\" for write...", filename);

#ifdef WINNT

    hFile = CreateFileA( filename,
             GENERIC_WRITE,
             0L,
             NULL,
             CREATE_ALWAYS,
             FILE_ATTRIBUTE_NORMAL,
             NULL );

    BREAK_IF( ( hFile == INVALID_HANDLE_VALUE ),
          "Failed to create file!", cleanup );

#else
    hFile = open( filename, O_WRONLY | O_CREAT | O_TRUNC,
          /* file mask is 0x550: read-write by user and group */
          S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP );

    BREAK_IF( hFile == -1,
          "Failed to create file!", cleanup );

#endif

    debug("ok\n");

    WRITE_NBO( ktfile->Version, "KTFVNO" );

    for( entry = ktfile->FirstKeyEntry ;
     entry != NULL ;
     entry = entry->nextEntry ) {

      WRITE_NBO( entry->keySize, "key size (in bytes)");

      WRITE_NBO( entry->cEntries, "number of components" );
      WRITE_NBO( entry->szRealm,  "Realm length" );
      WRITE_STRING( entry->Realm, entry->szRealm, "Realm data" );

      for (i = 0 ; i < entry->cEntries ; i++ ) {
    WRITE_NBO( entry->Components[i].szComponentData,
           "component datasize");
    WRITE_STRING( entry->Components[i].Component,
              entry->Components[i].szComponentData,
              "component data");
      }

      WRITE_NBO( entry->PrincType, "Principal Type");
      WRITE_NBO( entry->TimeStamp, "Timestamp" );
      WRITE( entry->Version,      "Key Version Number" );
      WRITE_NBO( entry->KeyType,   "Key Encryption Type" );

#if 0 // eh?
      /* again, this is a kludge to get around the keylength
     problem we can't explain */
#endif

      ASSERT( sizeof( entry->KeyLength ) == 2 );

      WRITE_NBO(entry->KeyLength, "key length" );

      WRITE_STRING( entry->KeyData,
            entry->KeyLength,
            "key data itself" );
    }

    ret = TRUE;

cleanup:
    CloseHandle(hFile);

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\lib\keytypes.c ===
/*++

  Keytypes.cxx

  mostly large tables and table manipulation functions

  Copyright(C) 1997 Microsoft Corporation

  Created 01-15-1997 DavidCHR

  --*/


#include "master.h"
#include "defs.h"

#ifdef WINNT
#include <kerbcon.h>

#define PREFIX(POSTFIX) KERB_ETYPE_##POSTFIX

#else
#include <krb5.h>

#define PREFIX(POSTFIX) ENCTYPE_##POSTFIX

#endif

#include "keytypes.h"


static TRANSLATE_ENTRY NTKtype_to_MITKtypes[] = {

  PREFIX(NULL),        (PVOID) ENCTYPE_NULL,         
  PREFIX(DES_CBC_CRC), (PVOID) ENCTYPE_DES_CBC_CRC,  
  PREFIX(DES_CBC_MD4), (PVOID) ENCTYPE_DES_CBC_MD4,  
  PREFIX(DES_CBC_MD5), (PVOID) ENCTYPE_DES_CBC_MD5,  

  // ENCTYPE_DES_CBC_RAW,  
  // ENCTYPE_DES3_CBC_SHA, 
  // ENCTYPE_DES3_CBC_RAW, 
};

TRANSLATE_TABLE 
NTK_MITK5_Etypes = {
  
  sizeof( NTKtype_to_MITKtypes ) / sizeof( TRANSLATE_ENTRY ) ,
  NTKtype_to_MITKtypes,

  (PVOID) ENCTYPE_UNKNOWN

};

static TRANSLATE_ENTRY kerberos_NameTypes[] = {

  KRB5_NT_UNKNOWN,   "KRB5_NT_UNKNOWN",
  KRB5_NT_PRINCIPAL, "KRB5_NT_PRINCIPAL",
  KRB5_NT_SRV_INST,  "KRB5_NT_SRV_INST",
  KRB5_NT_SRV_HST,   "KRB5_NT_SRV_HST",
  KRB5_NT_SRV_XHST,  "KRB5_NT_SRV_XHST",
  KRB5_NT_UID,       "KRB5_NT_UID"

};

TRANSLATE_TABLE
K5PType_Strings = {

  sizeof( kerberos_NameTypes ) / sizeof (TRANSLATE_ENTRY),
  kerberos_NameTypes,
  /* DEFAULT */ "**Unknown**"

};

static TRANSLATE_ENTRY kerberos_keystringtypes[] = {

  ENCTYPE_NULL,         "None",
  ENCTYPE_DES_CBC_CRC,  "DES-CBC-CRC",
  ENCTYPE_DES_CBC_MD4,  "DES-CBC-MD4",
  ENCTYPE_DES_CBC_MD5,  "DES-CBC-MD5",
  ENCTYPE_DES_CBC_RAW,  "DES-CBC-RAW",
  ENCTYPE_DES3_CBC_SHA, "DES3-CBC-SHA",
  ENCTYPE_DES3_CBC_RAW, "DES3-CBC-RAW",

};

TRANSLATE_TABLE 
K5EType_Strings = {
  
  sizeof( kerberos_keystringtypes ) / sizeof (TRANSLATE_ENTRY),
  kerberos_keystringtypes,

  /* DEFAULT */ "Unknown"
};


/* LookupTable:

   returns the union in the table we're passed corresponding to
   the passed value.

   the wierd pointer tricks near both the returns are due to C++ being too
   picky with me.  Since I have to store the values as PVOIDs (can't auto-
   initialize a union, apparently), I have to cast a PVOID into a 
   TRANSLATE_VALUE, which is a difference of indirection.  

   So, instead, I cast its deref into a PTRANSLATE_VAL and reference it,
   which is apparently legal enough.  */

TRANSLATE_VAL 
LookupTable( IN KTLONG32            value ,
	     IN PTRANSLATE_TABLE table ) {

    KTLONG32 i;

    for (i = 0;
	 i < table->cEntries ;
	 i ++ ) {
      if (table->entries[i].value == value ) {
	return *( (PTRANSLATE_VAL) &(table->entries[i].Translation) );
      }
    }
	
    return * ( (PTRANSLATE_VAL) &(table->Default) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\lib\keytypes.h ===
/*++

  Keytypes.hxx

  mostly large tables and table manipulation functions

  Copyright(C) 1997 Microsoft Corporation

  Created 01-15-1997 DavidCHR

  --*/


/* The following values are taken directly from <krb5.h> of the MIT
   Kerberos Distribution.  */

/* per Kerberos v5 protocol spec */
#define ENCTYPE_NULL            0x0000
#define ENCTYPE_DES_CBC_CRC     0x0001  /* DES cbc mode with CRC-32 */
#define ENCTYPE_DES_CBC_MD4     0x0002  /* DES cbc mode with RSA-MD4 */
#define ENCTYPE_DES_CBC_MD5     0x0003  /* DES cbc mode with RSA-MD5 */
#define ENCTYPE_DES_CBC_RAW     0x0004  /* DES cbc mode raw */
#define ENCTYPE_DES3_CBC_SHA    0x0005  /* DES-3 cbc mode with NIST-SHA */
#define ENCTYPE_DES3_CBC_RAW    0x0006  /* DES-3 cbc mode raw */
#define ENCTYPE_UNKNOWN         0x01ff

#define CKSUMTYPE_CRC32         0x0001
#define CKSUMTYPE_RSA_MD4       0x0002
#define CKSUMTYPE_RSA_MD4_DES   0x0003
#define CKSUMTYPE_DESCBC        0x0004
/* des-mac-k */
/* rsa-md4-des-k */
#define CKSUMTYPE_RSA_MD5       0x0007
#define CKSUMTYPE_RSA_MD5_DES   0x0008
#define CKSUMTYPE_NIST_SHA      0x0009
#define CKSUMTYPE_HMAC_SHA      0x000a

#define KRB5_NT_UNKNOWN   0
#define KRB5_NT_PRINCIPAL 1
#define KRB5_NT_SRV_INST  2
#define KRB5_NT_SRV_HST   3
#define KRB5_NT_SRV_XHST  4
#define KRB5_NT_UID       5

  
// (end of inclusion)


typedef union {

  PVOID raw;
  PCHAR string;
  ULONG integer;

} TRANSLATE_VAL, *PTRANSLATE_VAL;

typedef struct {
  
  ULONG value;
  PVOID Translation;

} TRANSLATE_ENTRY, *PTRANSLATE_ENTRY;

typedef struct {

  ULONG            cEntries;
  PTRANSLATE_ENTRY entries;
  PVOID            Default;

} TRANSLATE_TABLE, *PTRANSLATE_TABLE;

extern TRANSLATE_TABLE NTK_MITK5_Etypes;
extern TRANSLATE_TABLE K5EType_Strings;
extern TRANSLATE_TABLE K5PType_Strings;


TRANSLATE_VAL 
LookupTable( IN ULONG            valueToLookup,
	     IN PTRANSLATE_TABLE tableToLookupIn );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\lib\utest.c ===
#include "master.h"
#include "keytab.h"

int __cdecl 
main( int argc,
    PCHAR argv[] ) {


    fprintf( stderr, "sizeof K5_INT16 = %d.\n", 
            sizeof( K5_INT16 ));

    return 0;    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\lib\mkkey.c ===
/*++

  mkkey.c

  routines to create the key in the keytab.

  3/27/1997 - Created from routines in munge.c,  DavidCHR

  CONTENTS: CreateUnicodeStringFromAnsiString

  --*/

#include "master.h"
#include "defs.h"
#include "keytab.h"
#include "keytypes.h"

/******************************************************************
 * hack to preserve our debugging macro because asn1code.h        *
 *  will redefine it... egads, I thought everyone used DEBUG      *
 *  only for debugging... (it still ends up redefined...)         *
 ******************************************************************/
#ifdef DEBUG
#define OLDDEBUG DEBUG
#endif

#include <kerbcon.h>
#undef _KERBCOMM_H_    /* WASBUG 73905 */
#include "kerbcomm.h"

#undef DEBUG

#ifdef OLDDEBUG
#define DEBUG OLDDEBUG
#endif

/******************************************************************/
BOOL KtDumpSalt = (
#if DBG
     TRUE
#else
     FALSE
#endif
     );

/* This is the character we separate principal components with */

#define COMPONENT_SEPARATOR '/'

/*++**************************************************************
  NAME:      CreateUnicodeStringFromAnsiString

  allocates a unicode string from an ANSI string.

  MODIFIES:  ppUnicodeString -- returned unicode string
  TAKES:     AnsiString      -- ansi string to convert

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   fprintf on failure
  CREATED:   Feb 8, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: free()

 **************************************************************--*/

BOOL
CreateUnicodeStringFromAnsiString( IN  PCHAR           AnsiString,
				   OUT PUNICODE_STRING *ppUnicodeString ) {

    USHORT          StringLength;
    LPBYTE          pbString;
    PUNICODE_STRING pu;

    StringLength = (USHORT)lstrlen( AnsiString ); // does not include null byte

    pbString = (PBYTE) malloc( ( ( ( StringLength ) +1 ) * sizeof( WCHAR ) ) +
			       sizeof( UNICODE_STRING ) );

    if ( pbString ) {

      pu                = (PUNICODE_STRING) pbString;
      pbString         += sizeof( *pu );
      pu->Buffer        = (LPWSTR) pbString;
      pu->Length        = StringLength * sizeof( WCHAR );
      pu->MaximumLength = pu->Length + sizeof( WCHAR );

      wsprintfW( pu->Buffer,
		 L"%hs",
		 AnsiString );

      *ppUnicodeString = pu;

      return TRUE;

    } else {

      fprintf( stderr,
	       "Failed to make unicode string from \"%hs\".\n",
	       AnsiString );

    }

    return FALSE;

}
			



/*  KtCreateKey:

    create a keytab entry from the given data.
    returns TRUE on success, FALSE on failure.

    *ppKeyEntry must be freed with FreeKeyEntry when you're done with it.

    */

LPWSTR RawHash = NULL;

BOOL
KtCreateKey( PKTENT  *ppKeyEntry,
	     PCHAR    principal,
	     PCHAR    password,
	     PCHAR    realmname,
	
	     K5_OCTET keyVersionNumber,
	     ULONG    principalType,
	     ULONG    keyType,
	     ULONG    cryptosystem
	
	     ) {

    PKTENT              pEntry           = NULL;
    PCHAR               ioBuffer         = NULL;
    ULONG               i;
    ULONG               compCounter      = 0;
    USHORT              buffCounter      = 0;
    BOOL                ret              = FALSE;
    BOOL                FreeUnicodeSalt  = FALSE;

    UNICODE_STRING      UnicodePassword  = { 0 };
    UNICODE_STRING      UnicodePrincipal = { 0 };
    UNICODE_STRING      UnicodeSalt      = { 0 };
    PWCHAR              tmpUnicodeBuffer = NULL;
    KERB_ENCRYPTION_KEY KerbKey          = { 0 };
    WCHAR               wSaltBuffer      [BUFFER_SIZE];

#ifdef BUILD_SALT
    LONG32              saltCounter      = 0;
    CHAR                saltBuffer       [BUFFER_SIZE];
#endif

    /* you must actually provide these parameters */

    ASSERT( ppKeyEntry != NULL );
    ASSERT( principal  != NULL );
    ASSERT( realmname  != NULL );
    ASSERT( password   != NULL );

    ASSERT( strlen( password ) < BUFFER_SIZE );
    ASSERT( strlen( principal ) < BUFFER_SIZE );
    ASSERT( strlen( realmname ) < BUFFER_SIZE );

#ifdef BUILD_SALT
    /* if we're building the salt ourselves, initialize the keysalt */
    sprintf( saltBuffer, "%s", realmname );
    saltCounter = strlen( realmname );
#endif

    BREAK_IF( !ONEALLOC( pEntry, KTENT, KEYTAB_ALLOC),
	      "Failed to allocate base keytab element",
	      cleanup );

    /* zero out the structure, so we know what we have and
       haven't allocated if the function fails */

    memset( pEntry, 0, sizeof( KTENT ) );

    /* first, count the principal components */

    for( i = 0 ; principal[i] != '\0' ; i++ ) {
      if (principal[i] == COMPONENT_SEPARATOR) {
	pEntry->cEntries++;
      }
    }

    pEntry->cEntries++; /* don't forget the final component, which is not
			   bounded by the separator, but by the NULL */

    BREAK_IF( !MYALLOC( pEntry->Components, KTCOMPONENT,
			pEntry->cEntries,   KEYTAB_ALLOC ),
	      "Failed to allocate keytab component vector",
	      cleanup );

    /* allocate the buffer for the principal components.
       We allocate it the same size as the principal, because
       that's the maximum size any single component could be--
       the principal could be a one component princ. */

    BREAK_IF( !MYALLOC( ioBuffer,            CHAR,
			strlen(principal)+1, KEYTAB_ALLOC ),
	      "Failed to allocate local buffer for storage",
	      cleanup );

    /* now, we copy the components themselves, using the iobuffer to
       marshall the individual data elements--

       basically, add a char to the iobuffer for every char in the principal
       until you hit a / (component separator) or the trailing null.

       in those cases, we now know the size of the component and we have
       the text in a local buffer.  allocate a buffer for it, save the size
       and strcpy the data itself.  */

    i = 0;

    do {

      debug( "%c", principal[i] );

      if( (principal[i] == COMPONENT_SEPARATOR) ||
	  (principal[i] == '\0' /* delimit final component */ ) ) {
	
	/* this component is done. Save and reset the buffer. */

	pEntry->Components[compCounter].szComponentData = buffCounter;
	
#if 0
	debug( " --> component boundary for component %d.\n"
	       " size = %d, value = %*s\n",

	       compCounter, 
	       buffCounter, 
	       buffCounter,
	       ioBuffer );
#endif

	BREAK_IF( !MYALLOC( pEntry->Components[compCounter].Component,
			    CHAR,   buffCounter+1,      KEYTAB_ALLOC ),
		  "Failed to allocate marshalled component data",
		  cleanup );

	memcpy( pEntry->Components[compCounter].Component,
		ioBuffer, buffCounter );

	pEntry->Components[compCounter].Component[buffCounter] = '\0';
	buffCounter                                           = 0;
	compCounter ++;

      } else {

	ioBuffer[buffCounter] = principal[i];
	buffCounter++;

#ifdef BUILD_SALT

	/* also send the principal characters WITHOUT SLASHES
	   to the salt initializer.

	   WASBUG 73909: the %wc doesn't look right here.
	   Sure enough, it wasn't.  So we removed it. */
	
	sprintf( saltBuffer+saltCounter,  "%c",  principal[i] );
	ASSERT( saltCounter < BUFFER_SIZE );  /* not a very strong assert,
						 but useful */
	saltCounter ++;
	ASSERT( saltBuffer[saltCounter] == '\0' ); /* assert that it stays
						       null terminated at the
						       saltCounter */
						
#endif

      }

      i++;

    } while ( principal[i-1] != '\0' );


    /* there's still a component in the buffer.  Save that component
       by assigning the pointer, rather than allocating more memory.

       WASBUG 73911: may waste large amounts of memory if the principal is
       really big.  However, it probably won't be-- we're talking about
       strings that humans would generally have to type, so the waste is
       going to be in bytes.  Also, most of the time, the last component
       is the biggest; of the form:

       sample/<hostname>  or host/<hostname>

       ...hostname is generally going to be much larger than sample or host.

       */

    pEntry->Components[compCounter].szComponentData = buffCounter;
    pEntry->Components[compCounter].Component       = ioBuffer;
    ioBuffer[buffCounter]                           = '\0';
    ioBuffer                                        = NULL; /* keep from
							       deallocating */
    pEntry->Version                                 = keyVersionNumber;
    pEntry->szRealm                                 = (K5_INT16) strlen(realmname);
    pEntry->KeyType                                 = (unsigned short)keyType;
    pEntry->PrincType                               = principalType;

    /* copy the realm name */

    BREAK_IF( !MYALLOC( pEntry->Realm, CHAR, pEntry->szRealm+1, KEYTAB_ALLOC),
	      "Failed to allocate destination realm data", cleanup );

    memcpy( pEntry->Realm, realmname, pEntry->szRealm+1 ); /* copy the null */



    /***********************************************************************/
    /***                                                                 ***/
    /***                  Windows NT Key Creation Side                   ***/
    /***                                                                 ***/
    /***********************************************************************/

    /* create unicode variants of the input parameters */

    BREAK_IF( !MYALLOC( tmpUnicodeBuffer,     WCHAR,
			strlen( password )+1, KEYTAB_ALLOC ),
	      "Failed to alloc buffer for password", cleanup );

    wsprintfW( tmpUnicodeBuffer, L"%hs", password );
    RtlInitUnicodeString( &UnicodePassword, tmpUnicodeBuffer );


    BREAK_IF( !MYALLOC( tmpUnicodeBuffer,     WCHAR,
			strlen( principal )+1, KEYTAB_ALLOC ),
	      "Failed to alloc buffer for principal", cleanup );

    wsprintfW( tmpUnicodeBuffer, L"%hs", principal );
    RtlInitUnicodeString( &UnicodePrincipal, tmpUnicodeBuffer );

    wsprintfW( wSaltBuffer, L"%hs", realmname );

    RtlInitUnicodeString( &UnicodeSalt, wSaltBuffer );

    {
      KERB_ACCOUNT_TYPE acctType;

      acctType = UnknownAccount;

      if ( RawHash ) {

	if ( KtDumpSalt ) {

	  fprintf( stderr,
		   "Using supplied salt.\n" );

	}

	RtlInitUnicodeString( &UnicodeSalt,
			      RawHash );

      } else {

	PUNICODE_STRING pRealmString;

	if ( CreateUnicodeStringFromAnsiString( realmname,
						&pRealmString ) ) {

	  KERBERR kerberr;

	  if ( KtDumpSalt ) {

	    fprintf( stderr,
		     "Building salt with principalname %wZ"
		     " and domain %wZ...\n",
		     &UnicodePrincipal,
		     pRealmString );

	  }

	  debug( "KerbBuildKeySalt( Realm    = %wZ\n"
		 "                  Princ    = %wZ\n"
		 "                  acctType = %d.\n",
	
		 pRealmString,
		 &UnicodePrincipal,
		 acctType );

	  kerberr = KerbBuildKeySalt( pRealmString,
				      &UnicodePrincipal,
				      acctType,
				      &UnicodeSalt );

	  free( pRealmString );

	  BREAK_IF( kerberr,
		    "Failed to KerbBuildKeySalt",
		    cleanup );

	  FreeUnicodeSalt = TRUE;

	}
      }
    } // scope block.

    if ( KtDumpSalt ) {

      fprintf( stderr,
	       "Hashing password with salt \"%wZ\".\n",
	       &UnicodeSalt );

    }

    debug( "KerbHashPasswordEx( UnicodePassword = %wZ \n"
	   "                    UnicodeSalt     = %wZ \n"
	   "                    cryptosystem    = 0x%x\n"
	   "                    &KerbKey        = 0x%p )...\n",

	   &UnicodePassword,
	   &UnicodeSalt,
	   cryptosystem,
	   &KerbKey );

    BREAK_IF( KerbHashPasswordEx( &UnicodePassword,
				  &UnicodeSalt,
				  cryptosystem,
				  &KerbKey ),
	      "KerbHashPasswordEx failed.",
	      cleanup );

    pEntry->KeyLength = (USHORT)KerbKey.keyvalue.length;

    BREAK_IF( !MYALLOC( pEntry->KeyData, K5_OCTET,
			pEntry->KeyLength, KEYTAB_ALLOC ),
	      "Failed to allocate keydata", cleanup );

    memcpy( pEntry->KeyData, KerbKey.keyvalue.value,
	    pEntry->KeyLength );

    /* NOTE:  no keyentry changes beyond this line.
              we must compute the key size LAST!  */

    pEntry->keySize = ComputeKeytabLength( pEntry );

    *ppKeyEntry     = pEntry; /* save this */
    pEntry          = NULL;   /* save us from freeing it */

    ret = TRUE;

cleanup:
#define FREE_IF_NOT_NULL( element ) { if ( element != NULL ) { KEYTAB_FREE( element ); } }

    if ( pEntry ) {
      FreeKeyEntry (pEntry );
    }

    WINNT_ONLY( FREE_IF_NOT_NULL( UnicodePassword.Buffer ) );
    WINNT_ONLY( FREE_IF_NOT_NULL( UnicodePrincipal.Buffer ) );

#ifndef BUILD_KEYSALT
    /* WASBUG 73915: how to free UnicodeSalt?
       ...with KerbFreeString. */

    ASSERT( FreeUnicodeSalt );
    KerbFreeString( &UnicodeSalt );

#else

    /* Check my logic. */

    ASSERT( !FreeUnicodeSalt );

#endif

    /* WASBUG 73918: how do I get rid of the data in KerbKey?
       ...with KerbFreeKey. */

    KerbFreeKey( &KerbKey );

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\cleanup.c ===
/*++

  CLEANUP.C

  CleanupOptionData code.

  Created, 6/25/1997 when it was impossible to keep making myself believe
  that I could go without allocating any memory in the option parser.

  Now, if you care, you're supposed to call CleanupOptionData().

  --*/


#include "private.h"

/* OptionDealloc:

   same as free() right now.  It should change if/when OptionAlloc
   changes */

VOID
OptionDealloc( IN PVOID pTarget ) {

    ASSERT( pTarget != NULL );

    free ( pTarget );

}


BOOL
OptionAddToList( IN PVOID          pQueue,
		 IN PVOID          pItem,
		 IN DEALLOC_METHOD eDealloc) {

    PSAVENODE pNode;
    PSAVEQUEUE pList;

    if ( !pQueue ) {

      return TRUE; // vacuous

    } else {

      pList = (PSAVEQUEUE) pQueue;

    }

    if( OptionAlloc( NULL, &pNode, sizeof( SAVENODE ) ) ) {

      pNode->DataElement   = pItem;
      pNode->DeallocMethod = eDealloc;
      pNode->next          = NULL;

      if ( pList->FirstNode == NULL ) {
	
	ASSERT( pList->LastNode == NULL );
	
	pList->FirstNode = pNode;

      } else {

	pList->LastNode->next = pNode;

      }

      pList->LastNode = pNode;
      return TRUE;
    }

    return FALSE;

}


BOOL
OptionResizeMemory( IN  PVOID  pSaveQueue,
                    OUT PVOID *ppResizedMemory,
                    IN  ULONG  newSize ) {

    ASSERT( ppResizedMemory != NULL );
    ASSERT( newSize         > 0 );
    // ASSERT( *ppResizedMemory != NULL ); // unuseful assertion.

    if ( *ppResizedMemory ) {

      PSAVENODE  pNode = NULL;
      PVOID      pDataElement, pTemp = NULL;

      pDataElement = *ppResizedMemory;
      
      if ( pSaveQueue ) {

	PSAVEQUEUE pQ;
	pQ = (PSAVEQUEUE) pSaveQueue;
	
	for ( pNode = pQ->FirstNode ;
	      pNode != NULL;
	      pNode = pNode->next ) {
	  
	  if ( pNode->DataElement == pDataElement ) {
	    break;
	  }
	  
	}
	
	if ( !pNode ) {
	  return FALSE;
	}
      }
      
      pTemp = realloc( pDataElement, newSize ) ;

      if ( pTemp == NULL ) {
	
	fprintf( stderr, 
		 "OptionResizeMemory failed to realloc for %d bytes.\n",
		 newSize );
	
	// allocation failed.
	
	return FALSE;
	
      } else {

	*ppResizedMemory = pTemp;
	
	if ( pNode ) {
	  
	  // must change this within the list as well.
	  
	  pNode->DataElement = pTemp;
	  
	}
	
	return TRUE;

      }

    } else {

      /* just like realloc, if you pass NULL, we'll just malloc the data
	 anyway.  This is just more convenient. */

      return OptionAlloc( pSaveQueue, ppResizedMemory, newSize );

    }
}


/* OptionAlloc:

   currently, malloc.
   
   if you change the method of allocation, you must also change
   OptionDealloc above */
   

BOOL
OptionAlloc( IN  PSAVEQUEUE pQueue,
	     OUT PVOID     *pTarget,
	     IN  ULONG      size ) {

    PVOID ret;

    ASSERT( pTarget != NULL );
    ASSERT( size    >  0 );

    ret = malloc( size );

    if ( ret ) {

      memset( ret, 0, size );

      if ( OptionAddToList( pQueue, ret, DeallocWithOptionDealloc ) ) {

	*pTarget = ret;

	return TRUE;
      } else {

	free( ret );

	// fallthrough

      }
    }

    *pTarget = NULL;
    
    return FALSE;

}


VOID
CleanupOptionDataEx( IN PVOID pVoid ) {

    ULONG      i;
    PSAVEQUEUE pQueue;

    ASSERT( pVoid != NULL );

    pQueue = ( PSAVEQUEUE ) pVoid;

    if ( pQueue->FirstNode != NULL ) {

      PSAVENODE p;
      PSAVENODE q;

      ASSERT( pQueue->LastNode != NULL );
      OPTIONS_DEBUG( "CleanupOptionDataEx: Freelist is nonempty.\n" );

      for ( p = pQueue->FirstNode ;
	    p != NULL ;
	    p = q ) {

	q = p->next;
	
	switch( p->DeallocMethod ) {

	 case DeallocWithFree:
	   
	   free( p->DataElement );
	   break;

	 case DeallocWithLocalFree:
	   LocalFree( p->DataElement );
	   break;
	   
	 case DeallocWithOptionDealloc:
	   
	   OptionDealloc( p->DataElement );
	   break;

	 default:

	   ASSERT_NOTREACHED( "unknown dealloc flag.  Bleah!" );
	   return;

	}
	
	OptionDealloc( p );

      }
      

    } else {

      OPTIONS_DEBUG( "CleanupOptionDataEx: Freelist is empty.\n" );

      ASSERT( pQueue->LastNode == NULL );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\keytab\lib\utest2.c ===
#include "master.h"
#include "keytab.h"


#define CHECK( what, fieldname ) {         \
    printf( "\n" #what " " #fieldname ".\n" );   \
    printf( "sizeof " #what " is %d.\n", sizeof( what ) );  \
    printf( "sizeof k." #fieldname " is %d.\n", sizeof( k.fieldname ) ); \
    printf( "sizeof pk->" #fieldname " is %d.\n", sizeof( pk->fieldname ) );\
}

int __cdecl
main( int argc, PCHAR argv[] ) {

    KTENT k;
    PKTENT pk;

    pk = &k;

    CHECK( K5_INT32, keySize );
    CHECK( K5_INT16, cEntries );
    CHECK( K5_INT16, szRealm );
    CHECK( K5_INT32, PrincType );
    CHECK( K5_TIMESTAMP, TimeStamp );
    CHECK( K5_INT16, KeyType );
    CHECK( K5_INT16, KeyLength );

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\debug.c ===
/*++

  DEBUG.C

  interface to my regular debugging library.

  Created, 9/13/1997 by DavidCHR

  --*/

#ifdef DEBUG_OPTIONS

#include ".\private.h"

VOID
OptionDebugPrint( PCHAR fmt, ... ){

    va_list v;
    va_start( v, fmt );

    vdebug( OPTION_DEBUGGING_LEVEL, fmt, v );

}

VOID
OptionHelpDebugPrint( PCHAR fmt, ... ){

    va_list v;
    va_start( v, fmt );

    vdebug( OPTION_HELP_DEBUGGING_LEVEL, fmt, v );

}

#endif //don't compile it in if the user doesn't specify.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\client.h ===
/*++

  CLIENT.H

  header file for OPT_FUNC2 or better functions.

  This file exposes the freelist API used internally by the program.  This
  assures the caller that CleanupDataEx will obliterate any memory used by
  the option system.

  It is important that client code not corrupt the internal freelist, or
  unpredictable results may occur.  

  Created, 9/6/1997 by DavidCHR

  Copyright (C) 1997 Microsoft Corporation, all rights reserved.

  --*/


/* When a FUNC2 function is called, it will be passed a SaveQueue.
   This queue is guaranteed not to be null by the calling function (unless 
   the HELP parameter is TRUE) and should be considered opaque.
   The only means of accessing the queue are with OptionAlloc and
   CleanupOptionDataEx. */

BOOL
OptionAlloc( IN  PVOID   pSaveQueue,  /* if NULL, no list is used, and you
					 must call OptionDealloc to free the
					 memory */
	     OUT PVOID  *ppTarget,
	     IN  ULONG   size );

VOID
OptionDealloc( IN PVOID pTarget );

/* note that ppResizedMemory must have been allocated with OptionAlloc--
   
   e.g.: 

   OptionAlloc( pSave, &pTarget, sizeof( "foo" ) );
   OptionResizeMemory( pSave, &pTarget, sizeof( "fooooooo" ) );

   */

BOOL
OptionResizeMemory( IN  PVOID  pSaveQueue,      // same as in OptionAlloc
		    OUT PVOID *ppResizedMemory, // same as in OptionAlloc
		    IN  ULONG  newSize );       // same as in OptionAlloc

/* PrintUsageEntry:

   formats a single line of text and sends it out.
   This is where all the output goes, so we can be assured that it all ends
   up formatted the same.   It uses the following globals so that clients
   can adjust the values if needed.  The defaults are in comments */

extern ULONG OptMaxHeaderLength      /* 5  */;
extern ULONG OptMaxCommandLength     /* 13 */;
extern ULONG OptMaxSeparatorLength   /* 3  */;
extern ULONG OptMaxDescriptionLength /* 58 */;

VOID
PrintUsageEntry( FILE  *output,      // output file stream (must be stderr)
                 PCHAR  Header,     // usually SlashVector, BoolVector or NULL
		 PCHAR  Command,     // command name or NULL
		 PCHAR  aSeparator,  // between command and description
		 PCHAR  Description, // description string
		 BOOL   fRepeatSeparator );


/* PrintUsage should be used to print the usage data for an option vector.
   Useful if your function takes suboptions. */

VOID
PrintUsage( FILE         *output,   // output file stream (must be stderr)
	    ULONG         flags,    // option flags (as ParseOptionsEx)
	    optionStruct *options,  // option vector, 
	    PCHAR         prefix ); // prefix (optional; currently ignored)


#define OPT_FUNC_PARAMETER_VERSION 1

typedef struct {

  IN  ULONG  optionVersion;    // will be set to OPT_FUNC_PARAMETER_VERSION.
  IN  PVOID  dataFieldPointer; // points to the variable in the optStruct
  IN  INT    argc;             // argc following the option calling the func
  IN  PCHAR *argv;             /* argv (argv[0] is the command invoked)
				  NOTE: this pointer will ALWAYS exist, even
				  if the Help Flag is set.  HOWEVER, it is
				  the only option that's guaranteed to be 
				  there. */
  IN  ULONG  optionFlags;      // as ParseOptionsEx
  IN  PVOID  pSaveQueue;       // input memorylist.  
  OUT INT    argsused;         // set this to the number of args you used.

  /* parameters may be added to the end, depending on the optionVersion.
     an option function should only be concerned if the optionVersion is
     LESS than the optionVersion it knows about.  If greater, no big deal. */
  
} OPT_FUNC_PARAMETER_DATA, *POPT_FUNC_PARAMETER_DATA;

// this is the function expected by OPT_FUNC2
typedef BOOL (OPTFUNC2)( IN BOOL, // if TRUE, just print help.  
			 IN POPT_FUNC_PARAMETER_DATA );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\compare.c ===
/*++

  COMPARE.C

  Checks to see if a command line option matches a given expectation.

  Created, DavidCHR 6/9/1997

  --*/

#include "private.h"

/* ParseCompare:

   returns TRUE if the argument matches the expectation of pEntry */

BOOL
ParseCompare( optionStruct *pEntry,
	      ULONG         flags,
	      PCHAR         arg ) {

    CHAR  buffer[ 255 ];

    switch( pEntry->flags & OPT_MUTEX_MASK ) {

     case OPT_CONTINUE:
     case OPT_PAUSE:
     case OPT_DUMMY:
	 
       if ( pEntry->cmd ) {
	 OPTIONS_DEBUG( "ParseCompare: skipping useless option ( %s, 0x%x)\n",
			pEntry->cmd,
			pEntry->flags & OPT_MUTEX_MASK );
       }

       return FALSE;

     case OPT_STRING:
     case OPT_INT:
     case OPT_STOP_PARSING:
     case OPT_LONG:
     case OPT_BOOL:
     case OPT_HELP:
     case OPT_FLOAT:
     case OPT_FUNC:
     case OPT_ENUMERATED:
     case OPT_FUNC2:

#ifdef WINNT
     case OPT_USTRING:
     case OPT_WSTRING:
#endif	 

       if ( pEntry->cmd ) {
	 OPTIONS_DEBUG( "ParseCompare: option ( %s, 0x%x) is \"normal\".\n",
			pEntry->cmd,
			pEntry->flags & OPT_MUTEX_MASK );
       } else {

	 ASSERT_NOTREACHED( "Nobody should EVER specify a NULL command field"
			    " in an option structure.  "
			    "It's just plain dumb." );
	 return FALSE;
       }

       break;

     case OPT_SUBOPTION:

	 /* copy everything before the colon into a buffer, then 
	    string-compare the buffer-- suboptions have the form:

	    [+|-|/]option:suboption:suboption */

	 OPTIONS_DEBUG( "ParseCompare: Suboption... " );

     {
       ULONG i;

       for ( i = 0 ; arg[i] != ':' ; i++ ) {
	 if ( arg[i] == '\0' ) {
	   OPTIONS_DEBUG(" no colon.  This cannot be a suboption.\n" );
	   return FALSE;
	 }
	 OPTIONS_DEBUG("%c", arg[i] );
	 buffer[i] = arg[i];
       }

       buffer[i] = '\0';

       arg = buffer;
       break;
     }


     default:

#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch statement or bad things will happen."
#endif

	 ASSERT_NOTREACHED( "unknown option type-- your COMPAT library is "
			    "probably out of date.  ssync security\\compat "
			    "and rebuild, then relink your project." );
	 return FALSE;

    }

    OPTIONS_DEBUG( "Comparing \"%s\" against \"%s\"...",
		   arg, pEntry->cmd );


    if ( STRCASECMP( arg, pEntry->cmd ) == 0 ) {

      OPTIONS_DEBUG( "equal!\n" );
      return TRUE;

    } else {
      
      OPTIONS_DEBUG( "not equal\n" );
      return FALSE;

    }
    
    ASSERT_NOTREACHED( "Should never get here" );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\help.c ===
/*++

  HELP.C
  
  PrintHelp function

  split from options.c, 6/9/1997 by DavidCHR

  --*/

#include "private.h"
#include <malloc.h>

PCHAR SlashVector    = "[- /]"; /* These should all be the same */
PCHAR BoolVector     = "[- +]"; /* size-- for formatting reasons */
PCHAR ColonVector    = " : ";   /* Separator */

#ifdef DEBUG_OPTIONS
VOID OptionHelpDebugPrint( PCHAR fmt, ... );
#define HELPDEBUG OptionHelpDebugPrint
#else
#define HELPDEBUG
#endif


VOID
FillBufferWithRepeatedString( IN  PCHAR  repeated_string,
			      IN  PCHAR  buffer,
			      IN  ULONG  bufferLength /* without null */ ){

    ULONG stringi, bufferj = 0;
    ULONG size;

    size = strlen( repeated_string );

    if ( size == 0 ) {

      memset( buffer, ' ', bufferLength );

    } else {

      for ( stringi = 0 ; stringi < bufferLength ; stringi++, bufferj++ ) {
	
	buffer[ bufferj ] = repeated_string[ bufferj % size ];
	
      }

    }
      
    buffer[ bufferLength ] = '\0';

}



/* PrintUsageEntry:

   formats a single line of text and sends it out.
   This is where all the output goes, so we can be assured that it all ends
   up formatted the same.   It uses the following globals so that clients
   can adjust the values if needed.  */

ULONG OptMaxHeaderLength      = 5;  
ULONG OptMaxCommandLength     = 13;
ULONG OptMaxSeparatorLength   = 3;
ULONG OptMaxDescriptionLength = 58; 

VOID
PrintUsageEntry( FILE  *out,        // output file stream
                 PCHAR  aHeader,    // usually SlashVector, BoolVector or NULL
		 PCHAR  aCommand,   // command name or NULL
		 PCHAR  aSeparator, // between command and description
		 PCHAR  Description, //  NULL-terminated string vector 
		 BOOL   fRepeatSeparator ) {

    PCHAR output_line;                               // sick.  see below
    PCHAR Separator;
    PCHAR Header;
    PCHAR Command;

    HELPDEBUG( "PrintUsageEntry( aHeader = \"%s\"\n"
		   "                 aCommand = \"%s\"\n"
		   "                 aSeparator = \"%s\"\n"
		   "                 Description = \"%s\"\n"
		   "                 fRepeat = %d )...\n",

		   aHeader, aCommand, aSeparator, Description, 
		   fRepeatSeparator );
    
    ASSERT( aSeparator != NULL );
      
    if ( fRepeatSeparator ) {
     
#define EXPAND_TO_SEPARATOR( arg ) {                                        \
      PCHAR local_arg;                                                      \
      arg = aSeparator;                                                     \
      ASSERT( arg != NULL );                                                \
      if ( strlen( arg ) < OptMax##arg##Length ) {                          \
        arg = (PCHAR) alloca( ( OptMax##arg##Length+1 ) * sizeof( CHAR ) ); \
        if ( arg ) {                                                        \
          HELPDEBUG( "filling " #arg " with \"%s\"...", aSeparator );   \
          FillBufferWithRepeatedString( aSeparator, arg,                    \
					OptMax##arg##Length );              \
          HELPDEBUG( "results in \"%s\".\n", arg );                     \
        } else {                                                            \
	  arg = a##arg;                                                     \
	}                                                                   \
      } else {                                                              \
        arg = a##arg;                                                       \
      }                                                                     \
      }  

      /* BEWARE:

	 if you are using emacs, this next statement may not automatically 
	 format correctly.  Set it manually and the other lines will fix 
	 themselves.

	 This is a bug in emacs's macro-handling code.  :-) */
    								   
      EXPAND_TO_SEPARATOR( Separator ); // separator may need expanding anyway
      
      if ( !aHeader) {
	EXPAND_TO_SEPARATOR( Header );
      } else {
	Header = aHeader;
      }
      if ( !aCommand ) {
	EXPAND_TO_SEPARATOR( Command );
      } else {
	Command = aCommand;
      }

    } else {

      Separator = aSeparator;
      Header    = aHeader;
      Command   = aCommand;

      ASSERT( Separator != NULL );
      ASSERT( Header    != NULL );
      ASSERT( Command   != NULL );
    
    }

    /* before we try to do all this sick string manipulation, try to 
       allocate the buffer.  If this fails, well... it'll save us the 
       trouble.  :-) */

    output_line = (PCHAR) alloca( ( OptMaxHeaderLength         +
				    OptMaxCommandLength        +
				    OptMaxSeparatorLength      +
				    OptMaxDescriptionLength    +
				    2 /* NULL-termination */ ) * 
				  sizeof( CHAR ) );
    if ( output_line ) {

      PCHAR index;
      CHAR  outputFormatter[ 10 ] = { 0 }; // "%50hs" and the like

#ifdef WINNT // ugh.  Why can't we support this function?  I can't find it...
#define snprintf _snprintf
#endif

#define FORMAT_FORMAT( arg ) {                                             \
	snprintf( outputFormatter, sizeof( outputFormatter),               \
		  "%%%ds", OptMax##arg##Length );                          \
        HELPDEBUG( #arg ": formatter = \"%s\"\n ", outputFormatter );  \
        HELPDEBUG( "input value = \"%s\"\n", arg );                    \
	snprintf( index, OptMax##arg##Length,                              \
		  outputFormatter, arg );                                  \
	index[ OptMax##arg##Length ] = '\0';                               \
        HELPDEBUG( "output = \"%s\"\n", index );                       \
        index += OptMax##arg##Length;                                      \
      }
	
      index = output_line;
      
      FORMAT_FORMAT( Header );
      FORMAT_FORMAT( Command );
      FORMAT_FORMAT( Separator );

      // the description does not want to be right-justified.

      snprintf( index, OptMaxDescriptionLength, "%s", Description );
      index[OptMaxDescriptionLength] = '\0';

#undef FORMAT_FORMAT

      fprintf( out, "%s\n", output_line );

    } else {

      fprintf( stderr, 
	       "ERROR: cannot format for %s %s %s -- "
	       "STACK SPACE EXHAUSTED\n",
	       Header, Command, Description );

      fprintf( out, "%s%s%s%s\n", Header, Command, 
	       aSeparator, Description );

    }
    
}

VOID
PrintUsage( FILE         *out,
	    ULONG         flags,
	    optionStruct *options,
	    PCHAR         prefix /* can be NULL */) {

    ULONG i;
    BOOL  PrintAnything = TRUE;
    PCHAR Syntax        = NULL;
    PCHAR CommandName   = NULL;
    PCHAR Description   = NULL;
    PCHAR Separator     = NULL;

    fprintf(out, "Command line options:\n\n");


    for (i = 0 ; !ARRAY_TERMINATED( options+i ); i++ ) {

      Description   = options[i].helpMsg;

      HELPDEBUG("option %d has flags 0x%x\n",  i, options[i].flags );

      if ( options[i].flags & OPT_HIDDEN ) {
	continue;
      }

      if ( options[i].flags & OPT_NOSWITCH ) {
	Syntax = "";
      } else {
	Syntax = SlashVector;
      }

      if ( options[i].flags & OPT_NOCOMMAND ) {
	CommandName = "";
      } else {
	CommandName = options[i].cmd;
      }

      if ( options[i].flags & OPT_NOSEPARATOR ) {
	Separator = "";
      } else {
	Separator     = ColonVector;
      }

      switch (options[i].flags & OPT_MUTEX_MASK) {

       case OPT_ENUMERATED:

       {

	 // special case.

	 CHAR HeaderBuffer[ 22 ]; // formatting = 21 chars wide + null

	 HELPDEBUG("[OPT_ENUM]");
	 
	 PrintAnything = FALSE;
	 
	 sprintf( HeaderBuffer, "%5hs%13hs%3hs", SlashVector,
		  CommandName, Separator );

	 fprintf( out, "%hs%hs\n", HeaderBuffer, Description );
	 
	 fprintf( out, "%hs is one of: \n", HeaderBuffer );

	 PrintEnumValues( out, HeaderBuffer, 
			  ( optEnumStruct * ) options[i].optData );
	 
	 break;

       }

       case OPT_PAUSE:

	   HELPDEBUG("[OPT_PAUSE]");

	   PrintAnything = FALSE;

	   if ( !Description ) {
	     Description = "Press [ENTER] to continue";
	   }

	   fprintf( stderr, "%hs\n", Description );

	   getchar();

	   break;
	   
       case OPT_DUMMY:

	 PrintUsageEntry( out, 
			  ( options[i].flags & OPT_NOSWITCH    ) ?
			  ""  : NULL,
			  ( options[i].flags & OPT_NOCOMMAND   ) ? 
			  ""  : NULL,
			  ( options[i].flags & OPT_NOSEPARATOR ) ?
			  "" : "-" , 
			  Description, TRUE  );
	
	   break;
	   
       case OPT_CONTINUE:

	 PrintUsageEntry( out, "", "", "", Description, FALSE );

	   break;


       case OPT_HELP:

	   if ( !Description ) {
	     Description = "Prints this message.";
	   }

	   PrintUsageEntry( out, Syntax, CommandName,
			    ColonVector, Description, FALSE );

	   break;

       case OPT_SUBOPTION:

	   if ( !Description ) {
	     Description = "[ undocumented suboption ]";
	   }

	   PrintUsageEntry( out, Syntax, CommandName,
			    ColonVector, Description, FALSE );

	   break;
	   
       case OPT_BOOL:

	   PrintUsageEntry( out, 
			    ( ( options[i].flags & OPT_NOSWITCH ) ?
			      Syntax : BoolVector ), CommandName,
			    ColonVector, Description, FALSE );

	   break;

       case OPT_STOP_PARSING:

	 if ( !Description ) {
	   Description = "Terminates optionlist.";
	 }
	 goto defaulted;

       case OPT_FUNC2:

	 if ( !Description ) {
	   OPT_FUNC_PARAMETER_DATA optFuncData = { 0 };

	   optFuncData.argv = &( options[i].cmd );

	   HELPDEBUG("Jumping to OPT_FUNC2 0x%x...", 
			 ((POPTU) &options[i].data)->raw_data );

	   ( (POPTU)&options[i].data)->func2( TRUE, &optFuncData );

	   break;
	 }

	 /* fallthrough-- if this one has no description,
	    they both will, so the next if will not be taken. */
	 
       case OPT_FUNC:
	 
	 if ( !Description ) {

	   HELPDEBUG("Jumping to OPTFUNC 0x%x...", 
			 ((POPTU) &options[i].data)->raw_data );

	   ( (POPTU) &options[i].data )->func( 0, NULL );
	   break;
	 }

	 // fallthrough

#ifdef WINNT
       case OPT_WSTRING:
       case OPT_USTRING:
#endif
       case OPT_STRING:
       case OPT_INT:
       case OPT_FLOAT:

	 // fallthrough

       default: // this is the default means.
defaulted:

#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch statement or bad things will happen."
#endif

	 PrintUsageEntry( out, Syntax, CommandName,
			  ColonVector, Description, FALSE );

      }

      if ( options[i].flags & OPT_ENVIRONMENT ) {
	  
	CHAR buffer[ MAX_PATH ];
	  
	sprintf( buffer, " (or set environment variable \"%hs\")",
		 options[i].optData );

	PrintUsageEntry( out, "", CommandName, ColonVector,
			 buffer, FALSE );
      }

    } // for-loop
} // function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\enum.c ===
/*++

  ENUM.C

  Option Enumerated Types

  Copyright (C) 1997 Microsoft Corporation, all rights reserved

  Created, 7/29/1997 by DavidCHR

  --*/


#include "private.h"

BOOL
PrintEnumValues( FILE          *out,
		 PCHAR          header,
		 optEnumStruct *pStringTable ) {

    ULONG index;

    for( index = 0 ; pStringTable[index].UserField != NULL ; index++ ) {

      if ( pStringTable[index].DescriptionField ) {
	fprintf( stderr, "%hs%10hs : %hs \n",
		 header,
		 pStringTable[index].UserField,
		 pStringTable[index].DescriptionField );

      }
    }

    return TRUE;

}

BOOL
IsMaskChar( IN CHAR ch ) {

    return ( ch == '|' ) || ( ch == ',' );
	
}


BOOL
ResolveEnumFromStrings( ULONG         cStrings,
			PCHAR        *strings, // remaining args.
			optionStruct *opt,
			PULONG        pcArgsUsed ) {

    optEnumStruct *pStringTable;
    ULONG          TableIndex;
    ULONG          StringIndex;
    ULONG          cArgsUsed  = 0;
    BOOL           wasFound = FALSE;
    BOOL           moreComing = TRUE;

    pStringTable = ( optEnumStruct *) opt->optData;

#if 1

    for ( StringIndex = 0 ;
	  (StringIndex < cStrings) && moreComing ;
	  StringIndex++ ) {

      PCHAR theString;    // points to the current argument

      theString  = strings[ StringIndex ];

      do {

	OPTIONS_DEBUG( "Start of maskable loop.  theString = %s\n",
		       theString );

	wasFound   = FALSE;
	moreComing = FALSE;

	for( TableIndex = 0 ;
	     pStringTable[ TableIndex ].UserField != NULL;
	     TableIndex ++ ) {
	
	  ULONG StringLength; // set to the string length of the option cmd

	  StringLength = strlen( pStringTable[ TableIndex ].UserField );

	  // string-compare up to the StringLength.

	  if ( STRNCASECMP( pStringTable[ TableIndex ].UserField,
			    theString, StringLength ) != 0  ) {

	    continue; // this entry doesn't match.

	  } // else...

	  // found a partial match!  Verify the remainder if there is any.

	  if ( theString [ StringLength ] != '\0' ) {

	    if ( opt->flags & OPT_ENUM_IS_MASK ) {
		
	      if ( IsMaskChar( theString[ StringLength ] ) ) {
		
		// more are coming.
		moreComing = TRUE;

	      } else continue; // inexact match.
	    } else continue;   // inexact match.
	  }

	  wasFound = TRUE;

	  if ( cArgsUsed ) {
	
	    *(POPTU_CAST( *opt )->integer) |= ( ( ULONG )((ULONG_PTR)
						pStringTable[ TableIndex ].
						VariableField ));

	  } else {

	    *(POPTU_CAST( *opt )->raw_data) = ( pStringTable[ TableIndex ].
						VariableField );

	  }

	  if ( theString == strings[ StringIndex ] ) {
	
	    /* we modify theString if it includes multiple mask values.
	       So, this way we only increase the number of used arguments
	       ONCE per actual argument.  */

	    cArgsUsed++;
	  }
	
	  if ( opt->flags & OPT_ENUM_IS_MASK ) {

	    if ( moreComing ) {

	      // check to see if the user input "xxx|yyy", or just "xxx|"

	      ASSERT( StringLength > 0 );

	      // theString[ StringLength ] == '|' or something.

	      for ( theString += StringLength+1; // +1 to go past '|'
		    theString != NULL ;
		    theString ++ ) {
		
		if ( *theString == '\0' ) {

		  OPTIONS_DEBUG( "Mask is of the form 'XXX|'\n" );
		
		  // case = xxx| -- no more coming.

		  theString = NULL; //
		  break;

		}

		if ( isspace( *theString ) ) {
		  continue;
		}

		OPTIONS_DEBUG( "nonspace character '%c' hit.\n"
			       "mask component is of the form XXX|YYY.\n",
			
			       *theString );
		break;

	      }

	      ASSERT( !theString || ( (*theString != '\0') &&
				      !isspace(*theString) ) );

	      break;

	    } else { // !moreComing

	      theString = NULL;  // no more args in *this* string.

	      /* check to see if the mask character is or is in the NEXT
		 argument: "xxx" "|yyy" or "xxx" "|" "yyy" */
	
	      if ( strings[ StringIndex+1 ] ) {

		if ( IsMaskChar( strings[ StringIndex+1 ][0] ) ) {
		
		  moreComing = TRUE;
		
		  if ( strings[ StringIndex+1 ][1] == '\0' ) {

		    // xxx | yyy

		    cArgsUsed++;
		    StringIndex++;

		  } else {

		    // xxx |yyy

		    strings[ StringIndex +1 ]++;

		  }

		}

	      } // strings[ StringIndex +1 ]

	    } // !moreComing

	    break; // found what we wanted.  stop checking the table.

	  } else { // !OPT_ENUM_IS_MASK

	    // found the only argument we were expecting.  Just return.

	    *pcArgsUsed = cArgsUsed;
	    return TRUE;

	  } // moreComing check

	} // for each table entry

      } while ( ( theString != NULL ) && wasFound );

      if ( !wasFound ) { // option was not recognized.

	fprintf( stderr,
		 "%s: enum value '%s' is not known.\n",
		 opt->cmd, strings[ StringIndex ] );
	break;
		
      }
    }

#else

    for( index = 0 ; pStringTable[index].UserField != NULL; index++ ) {
      if ( STRCASECMP( pStringTable[index].UserField, string ) == 0 ) {
	
	// found a match!
	*(POPTU_CAST( *opt )->raw_data) = pStringTable[index].VariableField;

	OPTIONS_DEBUG( "Enum resolves to #%d, \"%s\" = 0x%x \n",
		       index,
		       pStringTable[index].DescriptionField,
		       pStringTable[index].VariableField  );

	return TRUE;
      }
    }


#endif

    if ( wasFound ) {

      *pcArgsUsed = cArgsUsed;

    } else {

      fprintf( stderr, "Error: argument for option \"%hs\" must be %s:\n",
	       opt->cmd,
	       ( opt->flags & OPT_ENUM_IS_MASK ) ?
	       "one or more of the\n following, separated by '|' or ','" :
	       "one of the following values" );

      PrintEnumValues( stderr, "", pStringTable );

    }

    return wasFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\obsolete.c ===
/*++

  OBSOLETE.C
  
  functions that are obsolete.

  Created, 8/19/1997 from other files by DavidCHR 

  --*/


#include "private.h"

PSAVEQUEUE OptionsGlobalSaveQueue = NULL;

/* Included for compatibility.  DO NOT USE */

int
ParseOptions( int           argc,
	      char        **argv,
	      optionStruct *options ) {

    PCHAR *newargv;
    int    newargc;

    ASSERT( options != NULL );
    ASSERT( argv    != NULL );

    OptionsGlobalSaveQueue = NULL;
    
    if ( ParseOptionsEx( argc, argv, options,
			 0L,   &OptionsGlobalSaveQueue, 
			 &newargc, &newargv)) {

      OPTIONS_DEBUG( "ParseOptionsEx returns newargc as  %d\n"
		     "                      old argc was %d\n",
		     
		     newargc, argc );

      return argc-newargc;

    } else {
      
      return 0;

    }

}


VOID
CleanupOptionData( VOID ) {

    if ( OptionsGlobalSaveQueue ) {
      CleanupOptionDataEx(  OptionsGlobalSaveQueue );
      OptionsGlobalSaveQueue = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\nonnull.c ===
/*++

  NONNULL.C

  Code for finding unused OPT_NONNULLs

  Copyright (C) 1997 Microsoft Corporation

  Created, 6/10/1997 by DavidCHR

  --*/

#include "private.h"

BOOL
FindUnusedOptions( optionStruct         *options,
		   ULONG                 flags,
		   /* OPTIONAL */ PCHAR  prefix,
		   PSAVEQUEUE            pQueue ) {

    PCHAR  newprefix;
    BOOL   freeprefix;
    BOOL   ret        = TRUE;
    ULONG  i;

    for ( i = 0 ; !ARRAY_TERMINATED( options+i ); i++ ) {

      if ( ( options[i].flags & OPT_MUTEX_MASK ) == OPT_SUBOPTION ) {

	OPTIONS_DEBUG( "%s: OPT_SUBSTRUCT.  ", options[i].cmd );

	if (options[i].flags & OPT_RECURSE ) {
	
	  /* suboptions must be reparsed.  we recurse on this structure,
	     copying the prefix into a newly allocated buffer.  */
	  
	  OPTIONS_DEBUG( "descending into substructure.\n" );
	  
	  /* allocate the new prefix */
	  
	  if ( prefix ) {
	    
	    /* oldprefix:optionname = newprefix */
	    
	    newprefix = (PCHAR) malloc( ( strlen( prefix ) +
					  strlen( options[i].cmd ) +
					  2 /* : and \0 */ ) * 
					sizeof( CHAR ) );
	    
	    if ( !newprefix ) {
	      fprintf( stderr, "Failed to allocate new prefix-- cannot "
		       "parse suboption %s:%s.\n", prefix, options[i].cmd );
	      return FALSE;
	    }
	    
	    sprintf( newprefix, "%s:%s", prefix, options[i].cmd );
	    freeprefix = TRUE;
	    
	  } else {
	    
	    /* optionname = prefix */
	    
	    newprefix  = options[i].cmd;
	    freeprefix = FALSE;
	    
	  }
	  
	  ASSERT( newprefix != NULL );
	  
	  if ( !FindUnusedOptions( POPTU_CAST( options[i] )->optStruct,
				   flags,
				   newprefix,
				   pQueue ) ) {
	    ret = FALSE;
	  }
	  
	  if ( freeprefix ) {
	    free( newprefix );
	  }
	  
	} else {

	  OPTIONS_DEBUG( "!OPT_RECURSE, so not descending.\n" );
	  
	}

	continue;

      }
      
      
      if ( ( options[i].flags & OPT_NONNULL ) || 
	   ( options [i].flags & OPT_ENVIRONMENT ) ) {

	OPTIONS_DEBUG( "%s: OPT_NONNULL or OPT_ENV.  pointer is 0x%x, ", 
		       options[i].cmd,
		       POPTU_CAST( options[i] )->raw_data );
	
	if ( *(POPTU_CAST( options[i] )->raw_data) == NULL ) {

	  OPTIONS_DEBUG( " *= NULL.\n" );

	  if ( ( options[i].flags & OPT_ENVIRONMENT ) &&
	       StoreEnvironmentOption( options+i, flags, pQueue ) ) {


	    OPTIONS_DEBUG( "found environment variable for %s...",
			  options[i].cmd );

	  } else if ( options[i].flags & OPT_NONNULL ) {

	    if ( prefix ) {
	      
	      fprintf( stderr,
		       "option %s:%s must be specified and is missing.\n",
		       prefix, options[i].cmd );

	    } else {
	      
	      fprintf( stderr,
		       "option %s must be specified and is missing.\n",
		       options[i].cmd );

	    }

	    ret = FALSE;

	  }
	  
	} else { 
	  
	  OPTIONS_DEBUG( "data is not null.\n" );
	  
	}
      }  
#if 0 // not really necessary debug info.

      else if ( options[i].cmd ) {

	OPTIONS_DEBUG( "%s is ok.\n", options[i].cmd );

      }
#endif
    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\private.h ===
/*++

  PRIVATE.H

  Header files and privates for the options project

  Created, DavidCHR 6/9/1997 

  --*/

#include "..\inc\master.h"
#include ".\options.h"
#include ".\client.h"

#define STRCASECMP  lstrcmpiA
#define STRNCASECMP _strnicmp

#ifdef DEBUG_OPTIONS
#define OPTIONS_DEBUG printf
#else
#define OPTIONS_DEBUG /* nothing */
#endif

typedef struct savenode {

  PVOID            DataElement;
  ULONG            DeallocMethod;
  struct savenode *next;

} SAVENODE, *PSAVENODE;

typedef struct {

  PSAVENODE FirstNode;
  PSAVENODE LastNode;

} SAVEQUEUE, *PSAVEQUEUE;


typedef union _optionUnion {

  PVOID          *raw_data;              
  OPTFUNC        *func;
  OPTFUNC2       *func2;
  int            *integer;
  float          *real;
  PCHAR          *string;
  BOOL           *boolean;
  optionStruct   *optStruct;
  
#ifdef WINNT
  UNICODE_STRING *unicode_string;
  PWCHAR         *wstring;
#endif

} optionUnion, OPTU, *POPTU;


#define OPT_FLAG_INTERNAL_JUMPOUT 0x10 // for internal use only.

/* The DeallocationMethods are: */

typedef enum {

  DEALLOC_METHOD_TOO_SMALL = 0, /* MUST BE FIRST */

  DeallocWithFree,
  DeallocWithLocalFree,
  DeallocWithOptionDealloc,
  
  DEALLOC_METHOD_TOO_LARGE /* MUST BE LAST */

} DEALLOC_METHOD;


BOOL
ParseSublist( POPTU      Option,
	      PCHAR     *argv,
	      int        argc,
	      int        theIndex,

	      int        *argsused,
	      ULONG      flags,
	      PBOOL      pbStopParsing,
	      PSAVEQUEUE pQueue ); /* sublist.c */

BOOL
StoreOption( optionStruct *opt, 
	     PCHAR        *argv,
	     int           argc,
	     int           argi,
	     int           opti,
	     ULONG         flags,
	     int          *argsused,
	     BOOL          includes_arg,
	     PBOOL         pbStopParsing,
	     PSAVEQUEUE    pQueue ); /* store.c */

BOOL
ParseOneOption( int           argc,
		PCHAR        *argv,
		int           argi,
		ULONG         flags,
		optionStruct *options,
		int          *argsused,
		PBOOL         pbStopParsing,
		PSAVEQUEUE    pSaveQueue ); // parse.c

BOOL
ParseCompare( optionStruct *optionEntry,
	      ULONG         flags,
	      PCHAR         argument );  /* compare.c */


/* Use this macro to easily get an option union from the necessarily-
   obscured structure_entry. */

#define POPTU_CAST( structure_entry ) ( (POPTU) &((structure_entry).data) )

// EXAMPLE:    POPTU_CAST( options[opti] )->string 

BOOL
FindUnusedOptions( optionStruct         *options,
		   ULONG                 flags,
		   /* OPTIONAL */ PCHAR  prefix,
		   PSAVEQUEUE            pQueue ) ; // nonnull.c

BOOL
StoreEnvironmentOption( optionStruct *opt,
			ULONG         flags,
			PSAVEQUEUE    pQueue); // store.c

BOOL
ResolveEnumFromStrings( ULONG          cStrings,
			PCHAR         *strings,
			optionStruct  *theOpt,
			ULONG         *pcArgsUsed ); // enum.c

BOOL
PrintEnumValues( FILE          *out,
		 PCHAR          header,
		 optEnumStruct *pStringTable ); // enum.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\options.h ===
/*++

  OPTIONS.HXX

  My option parsing system

  Copyright (C) 1997 Microsoft Corporation
  
  Created 01/13/1997 DavidCHR

  --*/
#ifndef INCLUDED_OPTIONS_H

/* IMPORTANT! IMPORTANT! IMPORTANT!

   If you add option types, you MUST change this #define to point at
   your new type.  The symbol used internally for certain assertions and at 
   compile-time to find forgotten areas. 

   IMPORTANT! IMPORTANT! IMPORTANT! */

#define HIGHEST_OPTION_SUPPORTED OPT_STOP_PARSING

#define INCLUDED_OPTIONS_HXX

#define OPTION_DEBUGGING_LEVEL      0x10000000 /* set your DebugFlag to this
						  if you want OPTIONS_DEBUG */
#define OPTION_HELP_DEBUGGING_LEVEL 0x20000000 /* most people REALLY will not
						  want to see this. */

typedef int (OPTFUNC)(int, char **); /* this is what's expected of OPT_FUNC*/

// OPT_FUNC2 and beyond will be defined in client.h

/* NOTE that when defining this structure statically, you MUST use 
   curly braces ({}), since the structure may change in size! */

typedef struct {

  PCHAR cmd;         /* this is what we call from the command line eg "h" 
			for -h  or /h */
  PVOID data;        /* this is where we store the results of that, 
			OR a function
			that can be called to store it (see below), OR null if
			this option is ignored or doesn't need storage */
  ULONG flags;       /* flags describing this option (see below for flags) */
  PCHAR helpMsg;     /* description of this option (example: "prints help 
			screen" or "specifies a file to read") */
  PVOID optData;    /* if we specify OPT_ENVIRONMENT (for example), 
		       this is the environment variable we'll take the 
		       data from */

  /* any/all remaining fields should be left alone */

  BOOL  Initialized; /* initially FALSE */

} optionStruct;


/* use this macro to determine if you're at the end of the array or not--
   it will change if the array termination conditions change. */

#define ARRAY_TERMINATED( poptions ) ( ( (poptions)->cmd     == NULL ) &&  \
                                       ( (poptions)->helpMsg == NULL ) &&  \
				       ( (poptions)->data    == NULL ) &&  \
				       ( (poptions)->flags == 0 ) )

  /* put this as the last element of your array.  It will change if/when
     the termination conditions change */

#define TERMINATE_ARRAY { 0 }

/*  FLAGS

    these tell ParseOptions and PrintHelpMessage what the option is: */

/* These are mutually-exclusive, so they are set in a manner such that
   defining them together causes wierd results. */

#define OPT_HELP      0x01 /* print the help message */
#define OPT_STRING    0x02 /* option is a string */ 
#define OPT_INT       0x03 /* an integer (can be hex) */
#define OPT_LONG      0x04 /* a long integer */
#define OPT_BOOL      0x05 /* boolean */
#define OPT_FLOAT     0x06 /* a float */
#define OPT_FUNC      0x07 /* needs a function to parse and store */
#define OPT_DUMMY     0x08 /* don't store the result anywhere-- basically,
			    a separator that appears in the help message */

#define OPT_CONTINUE  0x09 /* line is a continuation of the previous line--
			     useful for breaking really long descriptions
			     into multiple short lines */

#define OPT_PAUSE     0x0A /* wait for the user to press RETURN */

#ifdef WINNT /* only available under Windows NT */

#define OPT_USTRING   0x0B /* UNICODE_STRING */
#define OPT_WSTRING   0x0C /* string of wide characters */

#ifdef UNICODE /* use OPT_TSTRING for TCHAR strings */
#define OPT_TSTRING OPT_WSTRING
#else
#define OPT_TSTRING OPT_STRING
#endif

#endif /* WINNT-- OPT_{U|W}STRING */

#define OPT_SUBOPTION 0x0D /* suboptions-- format is:
			      [+|-|/](optname):(subopt),
			      
			      optname is the name of THIS OPTION (serves as
			      a kind of "routing option".  This gets converted
			      to:

			      [+|-|/](subopt) 

			      and is reparsed with the optionStruct that is
			      given as data to this parameter within this
			      structure.  Nesting IS supported.

			      Example follows.  */

#if 0 /* EXAMPLE of OPT_SUBOPTION */
  

static optionStruct RoutedOptions[] = {
  
  /* note that each suboption must have its own OPT_HELP-- the help
     code will not browse the substructure. */
  
  { "help",    NULL,           OPT_HELP, NULL },
  { "myroute", &some_variable, OPT_BOOL, "set this to enable routing" },
  { "nofoo",   &defeat_foo,    OPT_BOOL, "down with foo!" },
  
  TERMINATE_ARRAY
  
}

static optionStruct myOptions[] = {
  
  { "help",  NULL,          OPT_HELP,      NULL },
  { "route", RoutedOptions, OPT_SUBOPTION, "Routing options" },
  
  TERMINATE_ARRAY
  
};

/* in this example, to get help with the routing options, one would specify
   
   -route:help 

   to enable routing, the user would do:

   +route:myroute */

#endif
			      
#define OPT_ENUMERATED 0x0E /* Enumerated type.  Depending on what the user
			       enters for the field, we enter a user-defined
			       value for the specified variable.  We
			       deliberately ignore the type of the values,

			       the mapping-vector goes into the optData
			       field, so we can't use OPT_ENVIRONMENT with
			       this.
			       
			       and the array is currently terminated by
			       a NULL UserField.  Since this may change,
			       use TERMINATE_ARRAY as above.  

			       the options are not case-sensitive, but
			       if the user specifies an unknown value,
			       an error will occur. */
typedef struct {

  PCHAR UserField;     
  PVOID VariableField;
  PCHAR DescriptionField;  /* if the description is left blank, the field
			      will not be mentioned in help */

} optEnumStruct;

#if 0 /* Example of OPT_ENUMERATED option */

typedef enum {

  UseUdpToConnect = 1,
  UseTcpToConnect = 2,

} MyEnumType;

optEnumStruct MyEnumerations[] = {

  { "udp", (PVOID) UseUdpToConnect, // casting will likely be needed if
    "Specifies a UDP connection" },
  { "tcp", (PVOID) UseTcpToConnect, // your assignment is not a pointer
    "Specifies a TCP connection" },

  TERMINATE_ARRAY

};

MyEnumType MethodOfConnection;

optionStruct MyOptions[] = {

  /* ... */

  { "MyEnum", OPT_ENUMERATED, &MethodOfConnection, 
    "example of an enumerated type-- -myEnum Tcp for tcp connections",
    MyEnumerations },

  /* ... */

};
#endif

#define OPT_FUNC2 0x0F      /* enhanced function-- goes in the 
			       optData field, instead of the data field.
			       See OPTFUNC2 above.  */

#define OPT_STOP_PARSING 0x10 /* tells the parser to stop here.  This is
				 the equivalent of the ';' argument to 
				 -exec in unix's find command:

				 find . -exec echo {} ; -something.

				 the ; terminates parsing for the -exec 
				 option.  However, parsing for find is 
				 unaffected. */

#define OPT_MUTEX_MASK 0xff /* mask for mutually exclusive options */

#define OPT_NONNULL 0x100 /* option cannot be zero or NULL after parsing--
			     not useful for BOOLs, DUMMYs, or HELP.
			     
			     This is a way of ensuring that an option DOES 
			     get specified. */

#define OPT_DEFAULT 0x200 /* option may be specified without the cmd--
			     multiple OPT_DEFAULTs may be specified.  They
			     get "filled in" in the order they exist in the
			     options array.  See the examples for more */

#define OPT_HIDDEN  0x400 /* option does not appear in help.  I'm not
			     sure if this ends up being useful or not,
			     but I'm including it for completeness. */

#define OPT_ENVIRONMENT 0x800 /* use the optData field as an environment
				 string from which to extract the default */

#define OPT_RECURSE  0x1000 /* define this if you want FindUnusedOptions
			       to reparse the given substructure.

			       Otherwise, it'll be ignored */
#define OPT_NOSWITCH  0x2000 /* do not print the leading [switches] line */
#define OPT_NOCOMMAND 0x4000 /* do not print the command name--
				I don't know if you'd ever really want to do
				JUST this, but here it is.. */
#define OPT_NOALIGN   0x8000 /* don't even print alignment spaces.  This will
				make your output REALLY UGLY if you're not
				careful */
#define OPT_NOSEPARATOR 0x10000 /* don't use a separator sequence (by
				   default, I think it's ": ".  Again, this
				   is REALLY UGLY */

// should have named the below option "OPT_RAW", because that's what it is.
#define OPT_NOHEADER ( OPT_NOSWITCH | OPT_NOCOMMAND | OPT_NOALIGN | \
		       OPT_NOSEPARATOR )

#define OPT_ENUM_IS_MASK 0x20000 /* force enumerated types to also accept
				    enums of the form XXX | YYY | ZZZ  */


#if 0 /* EXAMPLE */

optionStruct my_options[] = {

  { "default1", &myDefaultInt,     OPT_INT | OPT_DEFAULT, "an int value"},
  {"default2", &myOtherInteger,   OPT_INT | OPT_DEFAULT,    "another int" },
  {"required", &myRequiredString, OPT_STRING | OPT_NONNULL, "a must have" },

  TERMINATE_ARRAY
};

/*++

  in the example above, if your app was named "foo", the following would
  be equivalent:
  
  foo -default1 0 -default2 13 -required bleah 
  foo 0 13 -required bleah
  foo 0 -default2 13 -required bleah
  foo -required bleah -default2 13 0
  
  ...and failing to specify "-required" would always result in an error
  if myRequiredString is NULL to begin with.  Note that the options must
  be in order.  If you mix types (if default2 were a string, and you run
  "foo bleah 0 for example"), the results are undefined.

  --*/

#endif

/* ParseOptionsEx:

   initializes the option structure, which is a sentinally-terminated
   vector of optionStructs.  

   argc, argv:       arguments to main() (see K&R)
   pOptionStructure: vector of optionStructs, terminated with TERMINATE_ARRAY
   optionFlags:      optional flags to control api behavior
   ppReturnedMemory: returned handle to a list of memory to be freed before
                     program exit.  Use CleanupOptionDataEx to free it. 

   new_arg[c,v]:     if nonnull, a new argc and argv are returned here.
                     if all the options were used up, argc = 0 and argv is
		     NULL.  Note that it is safe to provide pointers to the
		     original argv/argc if so desired.
   
   The function's behavior is complex:
   
   the function will always return FALSE on any critical error (unable to
   allocate memory, or invalid argument).  On WINNT, Last Error will be
   set to the appropriate error.

   if new_argc AND new_argv are specified, 
      ParseOptionsEx will always return TRUE unless help was called, and
      the two parameters will be updated to reflect new values.

   otherwise:
      ParseOptionsEx will return TRUE if it was able to recognize ALL args
      on the command line given.  It will return FALSE if any of the options
      were unknown.  This will probably be what most people want.

*/

BOOL
ParseOptionsEx( int            argc,
		char         **argv,
		optionStruct  *pOptionStructure,
		
		ULONG          optionFlags,
		void         **ppReturnedMemory,
		int           *new_argc,       // optional
		char        ***new_argv );     // optional

/* These are the flags that ParseOptionsEx accepts: */

#define OPT_FLAG_TERMINATE      0x01 // call exit() on error

// these next two are not yet fully supported and are mutually exclusive.

#define OPT_FLAG_SKIP_UNKNOWNS  0x02 // skip unknown parameters
#define OPT_FLAG_REASSEMBLE     0x04 /* assemble new argv/argc with
					unknown parameters in it-- only
					valid if new_argc and new_argv
					are specified 

					this is useless with SKIP_UNKNOWNS. */
#define OPT_FLAG_MEMORYLIST_OK  0x08 /* this means ParseOptionsEx should not
					return a new memory list-- it should
					use the provided one.  */

#define OPT_FLAG_INTERNAL_RESERVED 0xf0 /* flags 0x80, 0x40, 0x20 and 0x10
					   are reserved for internal use */

// if you add flags, update this #define.

#define HIGHEST_OPT_FLAG        OPT_FLAG_INTERNAL_RESERVED

/* CleanupOptionDataEx:

   frees data in the given list, which may be empty ( but not NULL ) */

VOID
CleanupOptionDataEx( PVOID pMemoryListToFree );


/* UnparseOptions:

   creates an argc/argv-like structure from a flat command.
   This is needed particularly for unix clients, although nt clients
   can use it without pulling in SHELL32.LIB.  :-) */

BOOL
UnparseOptions( PCHAR    flatCommand,
		int     *pargc,
		PCHAR   *pargv[] );

#ifndef OPTIONS_NO_BACKWARD_COMPATIBILITY

/* ParseOptions initializes the option structure-- note that the vector
   (optionStruct *) must be terminated with a sentinal value.

   This function is obsolete and is included for compatibility with older
   code.  Call ParseOptionsEx instead.  */

int
ParseOptions(
    /* IN */     int           argc,
    /* IN */     char        **argv,
    /* IN */ /* OUT */optionStruct *options );
     
/* call cleanupOptionData at the end of your program.  This will clear
   all memory used by the option parsing and returning system. */

VOID
CleanupOptionData( VOID );

#endif


#define ISSWITCH( ch /*character*/ ) ( (ch=='-') || (ch=='+') || (ch=='/') )


#endif // file inclusion check.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\parse.c ===
/*++

  PARSE.C

  Option parser

  Split from options.c 6/9/1997 by DavidCHR

  --*/

#include "private.h"
#include <malloc.h>

/* ParseOneOption:

   parses a single option from argv.  
   returns: number of arguments eaten, or zero on error */

BOOL
ParseOneOption( int           argc,     // number of arguments, total 
		PCHAR        *argv,     // vector of arguments 
		int           argi,     // which argument we're to parse
		ULONG         flags,    // applicable flags
		optionStruct *options,  // option structure 
		int          *argsused, // arguments we've eaten
		PBOOL         pbStop,   // Stop Parsing 
		PSAVEQUEUE    pQueue    // memory save area
		) {

    PCHAR p;           // argument pointer copy 
    int   opti;        // which option we're examining
    BOOL  ret  = FALSE; // return value 
    int   tmp  = 0;     // temporary inbound value
    int   used = 0;

    ASSERT( argc     >  0    ); // there must be arguments                   
    ASSERT( argv     != NULL ); // the vector must exist                     
    ASSERT( argi     <  argc ); // argument number must be INSIDE the vector 
    ASSERT( options  != NULL ); // passed option structure must be valid     
    ASSERT( argsused != NULL );

    p     = argv[argi];

    if( ISSWITCH( p[0] ) ) {
      p++; /* skip the switch character */
    }

    OPTIONS_DEBUG("Checking option %d: \"%hs\"...", argi, p);

    for (opti = 0 ; !ARRAY_TERMINATED( options+opti ) ; opti++ ) {
	
      OPTIONS_DEBUG("against [%d]%hs...", opti, options[opti].cmd);

      if ( ParseCompare( options+opti, flags, p ) ) {
	  /* we have a match! */
	
	ret = StoreOption( options, argv, argc, argi, opti, 
			   flags, &tmp, TRUE, pbStop, pQueue );

	OPTIONS_DEBUG( "StoreOption returned %d, args=%d, *pbStop = %d\n", 
		       ret, tmp, *pbStop  );

	if ( !ret ) {

	  /* failed to store options for some reason.  This is
	     critical. */

	  PrintUsage( stderr, flags, options, "" );
	  
	  if ( flags & OPT_FLAG_TERMINATE ) {
	    exit( -1 );
	  } else {
	    return FALSE;
	  }

	}

	OPTIONS_DEBUG( "ParseOneOption now returning TRUE, argsused = %d.\n",
		       tmp );

	*argsused = tmp;
	return ret; /* successful StoreOptions parses our one option. */

      } /* if ParseCompare... */

      OPTIONS_DEBUG( "nope.\n" );

    } /* options for-loop */
    
    OPTIONS_DEBUG( "did not find the option.  Checking for OPT_DEFAULTs.\n" );

    for (opti = 0 ; !ARRAY_TERMINATED( options+opti ) ; opti++ ) {

      if ( options[opti].flags & OPT_DEFAULT ) {

	/* WASBUG 73922: should check to see if the option is also an
	   OPT_SUBOPTION, then parse the suboption for OPT_DEFAULTs.
	   However, as it stands, this will just fail for OPT_SUBOPTIONS,
	   because the first pointer will probably be nonnull. 

	   The dev enlistment doesn't contain any OPT_SUBOPTIONS, so
	   this is not an issue. */

	ASSERT( ( options[ opti ].flags & OPT_MUTEX_MASK ) != OPT_SUBOPTION );

	if ( *( ((POPTU) &options[opti].data)->raw_data) == NULL ) {

	  OPTIONS_DEBUG("Storing %hs in unused OPT_DEFAULT %hs\n",
			argv[argi],
			options[opti].cmd );

	  ret = StoreOption( options, argv, argc, argi, opti, 
			     flags, &tmp, FALSE, pbStop, pQueue );
	  OPTIONS_DEBUG("OPT_DEFAULT: StoreOptions returned %d\n", ret);

	  if ( !ret ) {
	    PrintUsage( stderr, flags, options, "" );
	    exit( -1 );
	  }

	  *argsused = tmp;
	  return ret;

	}
      }
    }

    *argsused = 0;

    if ( ( flags & OPT_FLAG_SKIP_UNKNOWNS )  ||
	 ( flags & OPT_FLAG_REASSEMBLE )     ||
	 ( flags & OPT_FLAG_INTERNAL_JUMPOUT )) {

      return TRUE; // skip this option

    } else {

      fprintf(stderr, "unknown option \"%hs\".\n", argv[argi]);
      PrintUsage(stderr, flags,  options, "");

      if ( flags & OPT_FLAG_TERMINATE ) {
	exit( -1 );
      }

      return FALSE;

    }

    ASSERT_NOTREACHED( "should be no path to this code" );

}


/* ParseOptionsEx:

   initializes the option structure, which is a sentinally-terminated
   vector of optionStructs.  

   argc, argv:       arguments to main() (see K&R)
   pOptionStructure: vector of optionStructs, terminated with TERMINATE_ARRAY
   optionFlags:      optional flags to control api behavior
   ppReturnedMemory: returned handle to a list of memory to be freed before
                     program exit.  Use CleanupOptionDataEx to free it. 

   new_arg[c,v]:     if nonnull, a new argc and argv are returned here.
                     if all the options were used up, argc = 0 and argv is
		     NULL.  Note that it is safe to provide pointers to the
		     original argv/argc if so desired.
   
   The function's behavior is complex:
   
   the function will always return FALSE on any critical error (unable to
   allocate memory, or invalid argument).  On WINNT, Last Error will be
   set to the appropriate error.

   if new_argc AND new_argv are specified, 
      ParseOptionsEx will always return TRUE unless help was called, and
      the two parameters will be updated to reflect new values.

   otherwise:
      ParseOptionsEx will return TRUE if it was able to recognize ALL args
      on the command line given.  It will return FALSE if any of the options
      were unknown.  This will probably be what most people want.
*/

BOOL
ParseOptionsEx( int           argc,
		char        **argv,
		optionStruct *options,

		ULONG         flags,
		PVOID         *ppReturnedMemory,
		int           *new_argc,
		char        ***new_argv ) {
    
    BOOL       bStopParsing  = FALSE;
    BOOL       ret           = FALSE;
    LONG       argi;                 // argument index
    LONG       tmp;                  // temporary return variable
    PSAVEQUEUE pSaveQueue    = NULL; // memory save area
    PCHAR     *pUnknowns     = NULL; // will alloc with alloca
    int        cUnknowns     = 0;

    flags = flags & ~OPT_FLAG_INTERNAL_RESERVED; /* mask off flags that
						    the user shouldn't set. */

    if ( new_argc && new_argv &&
	 !( flags & ( OPT_FLAG_SKIP_UNKNOWNS |
		      OPT_FLAG_REASSEMBLE    |
		      OPT_FLAG_TERMINATE ) ) ) {

      OPTIONS_DEBUG( "\nSetting internal jumpout flag.\n" );
      flags |= OPT_FLAG_INTERNAL_JUMPOUT;
    }

    OPTIONS_DEBUG( "ParseOptionsEx( argc  = %d\n"
		   "                argv  = 0x%x\n"
		   "                opts  = 0x%x\n"
		   "                flags = 0x%x\n"
		   "                ppMem = 0x%x\n"
		   "                pargc = 0x%x\n"
		   "                pargv = 0x%x\n",

		   argc, argv, options, flags, ppReturnedMemory, new_argc,
		   new_argv );

    ASSERT( ppReturnedMemory != NULL );
    
    // first, we need to ensure we have a save area.

    if ( flags & OPT_FLAG_MEMORYLIST_OK ) {

      pSaveQueue = (PSAVEQUEUE) *ppReturnedMemory;
      
    } else if ( !OptionAlloc( NULL, &pSaveQueue, sizeof( SAVEQUEUE ) ) ) {
      fprintf( stderr, 
	       "ParseOptionsEx: unable to allocate save area\n" );
      return FALSE;
    }
    
    ASSERT( pSaveQueue != NULL );

    /* We must initialize pUnknowns if the user specified command-line
       reassembly.  Otherwise, it can stay NULL. */

    if ( (flags & OPT_FLAG_REASSEMBLE) && ( argc > 0 ) ) {
     
      pUnknowns = (PCHAR *) alloca( argc * sizeof( PCHAR ) );

      ASSERT( pUnknowns != NULL ); /* yes, this assertion is invalid.  
				      However, there is no clean solution if
				      we run out of stack space.  Something 
				      else will just fail even more
				      spectacularly. */
    }

    OPTIONS_DEBUG("options are at 0x%x\n", options);

#ifdef DEBUG_OPTIONS
    
    if (DebugFlag) {

      for (argi = 0; argi < argc ; argi++  ) {
	OPTIONS_DEBUG("option %d is %hs\n", argi, argv[argi]);
      }
    }

#endif

    for (argi = 0 ; argi < argc ; /* NOTHING */ ) {

      int tmp;

      if ( bStopParsing ) { // this gets set in the PREVIOUS iteration.
	
	OPTIONS_DEBUG( "bStopParsing is TRUE.  Terminating parse run.\n");
	
	/* WASBUG 73924: now what do we do with the unused options?
	   They get leaked.  This is okay, because the app terminates. */
	
	break;
      }

      if ( ParseOneOption( argc, argv, argi, flags, options, &tmp,
			   &bStopParsing, pSaveQueue ) ) {

	OPTIONS_DEBUG( "ParseOneOption succeeded with %d options.\n", tmp );

	if ( tmp > 0 ) {

	  // we were able to successfully parse one or more options.

	  argi += tmp;

	  OPTIONS_DEBUG( "advancing argi by %d to %d\n", tmp, argi );

	  continue;

	} else { 

	  if ( flags & OPT_FLAG_REASSEMBLE ) {

	    ASSERT( pUnknowns != NULL );
	    ASSERT( cUnknowns <  argc );

	    OPTIONS_DEBUG( "OPT_FLAG_REASSEMBLE: this is unknown %d\n",
			   cUnknowns );

	    pUnknowns[ cUnknowns ] = argv[ argi ];
	    cUnknowns              ++;
	    argi                   ++; // skipping this option
	    
	  } else if ( !( flags & OPT_FLAG_SKIP_UNKNOWNS ) ) {

	    if ( new_argv && new_argc ) {
	      
	      OPTIONS_DEBUG( "new argv and argc-- breakout at "
			     "argi=%d\n", argi );

	      break; /* we're not skipping the unknown values or
			reassembling the command line.  We're just
			supposed to quit on unknown options. */
	      
	    }

	  }

	  continue;

	}

      } else {

	/* error or unknown option, depending on our flags.  Regardless,
	   an error message has already been printed. */

	ret = FALSE;
	goto cleanup;

      }

    } /* command-line for-loop */

    /* if we make it this far, all the options were ok.
       Check for unused OPT_NONNULLs... */
    
    OPTIONS_DEBUG( "\n*** Searching for unused options ***\n\n" );

    if (!FindUnusedOptions( options, flags, NULL, pSaveQueue ) ) {
      
      /* unused OPT_NONNULLS are a critical error.  Even if the user
	 specifies OPT_FLAG_SKIP_UNKNOWNS, he/she still told us not to
	 let the user unspecify the option.  We default to returning FALSE.*/

      if ( flags & OPT_FLAG_TERMINATE ) {

	exit( -1 );

      } else {
	  
	ret  = FALSE;
	goto cleanup;

      }
    } 
    
    OPTIONS_DEBUG( "All variables are OK.  Checking reassembly flag:\n" );

    if ( new_argv && new_argc ) {

      int i;

      // we may have skipped some of the options.

      if ( flags & OPT_FLAG_REASSEMBLE ) {
      
	OPTIONS_DEBUG( "REASSEMBLY: " );

	for( i = 0 ; argi + i < argc ; i++ ) {
	  
	  /* tack arguments we never parsed ( OPT_STOP_PARSING can cause 
	     this ) onto the end of the Unknown array */
	 
	  OPTIONS_DEBUG( "Assembling skipped option %d (%s) as unknown %d.\n",
			 i, argv[ argi+i ], cUnknowns+i );
	  
	  pUnknowns[ cUnknowns+i ] = argv[ argi+i ];
	  cUnknowns++;

	}

	if ( cUnknowns > 0 ) {

	  OPTIONS_DEBUG( "There were %d unknowns.\n", cUnknowns);

	  for ( i = 0 ; i < cUnknowns ; i++ ) {
	    
	    ASSERT( pUnknowns != NULL );
	    
	    (*new_argv)[i] = pUnknowns[i];
	    
	  }

	} else OPTIONS_DEBUG( "There were no unknowns. \n" );

	(*new_argv)[cUnknowns] = NULL;
	*new_argc              = cUnknowns;

#if 0 // same outcome as if the flag didn't exist
      } else if ( flags & OPT_FLAG_SKIP_UNKNOWNS ) {

	OPTIONS_DEBUG( "User asked us to skip unknown options.\n"
		       "zeroing argv and argc.\n" );
#endif
	
      } else if ( argi != argc ) {

	/* normal operation-- go until we hit unknown options.

	   argi is the index of the first unknown option, so we add
	   it to argv and subtract it from argc. */

	*new_argv = argv+argi;
	*new_argc = argc-argi;

	OPTIONS_DEBUG( "normal operation-- parsing was halted.\n"
		       "new_argv = %d.  new_argc = 0x%x.\n",

		       *new_argv, *new_argc );
      } else {

	*new_argv = NULL;
	*new_argc = 0;

      }

    } else {

#if 0
      if ( new_argv && new_argc ) {

	OPTIONS_DEBUG( "Catch-all case.  Zeroing argv and argc.\n" );

	*new_argv = NULL;
	*new_argc = 0;

      }
#else

      OPTIONS_DEBUG( "User didn't request new argv or argc.\n" );

#endif

    }

    OPTIONS_DEBUG( "command line survived the parser.\n" );

    ret = TRUE;

cleanup:

    ASSERT( pSaveQueue != NULL );

    if (!( flags & OPT_FLAG_MEMORYLIST_OK ) ) {

      if ( ret ) {
	
	OPTIONS_DEBUG( "Returning SaveQueue = 0x%x\n", pSaveQueue );

	*ppReturnedMemory = (PVOID) pSaveQueue;
	
      } else {
	
	OPTIONS_DEBUG( "function failing.  cleaning up local data..." );
	CleanupOptionDataEx( pSaveQueue );
	OPTIONS_DEBUG( "ok.\n" );

	*ppReturnedMemory  = NULL;
	
      }
    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\store.c ===
/*++

  STORE.C

  code for StoreOption

  moved from options.c, 6/9/1997 

  --*/

#include "private.h"

#ifdef WINNT
#include <winuser.h>
#endif

typedef struct {

  PCHAR word;
  BOOL  value;

} SYNONYMS;

static SYNONYMS BoolSynonyms[] = {

  "on", TRUE,
  "off", FALSE

};

static int szBoolSynonyms = sizeof(BoolSynonyms) / sizeof(SYNONYMS);

BOOL
StoreOptionStrings( optionStruct *opt,  /* pointer to the entry */
		    ULONG         argc,  // count of strings to try to store
		    PCHAR         *argv, // argv[0] --> first string to store
		    ULONG         flags,
		    PULONG        pcStored,
		    PSAVEQUEUE    pQueue ) {

    PCHAR tostore;

    *pcStored      = 1;     // default.
    tostore   = argv[0];
    

    OPTIONS_DEBUG( "StoreOptionString: opt=0x%x, toStore=\"%s\"...",
		   opt, tostore );

    if ( !tostore ) {
      fprintf( stderr, "Parser: option \"%s\" is missing its argument.\n",
	       opt->cmd );
      return FALSE;
    }

    switch( opt->flags & OPT_MUTEX_MASK ) {

     case OPT_ENUMERATED:

	 OPTIONS_DEBUG("[OPT_ENUMERATED]");

	 return ResolveEnumFromStrings( argc, argv, opt, pcStored );

     case OPT_STRING:

	 OPTIONS_DEBUG("[OPT_STRING]");

	 *( POPTU_CAST( *opt )->string  ) = tostore;

	 return TRUE;

#ifdef WINNT  /* Wide-Character Strings and UNICODE strings */

	 /* note that we add one (at least) to argi when referencing 
	    wargv.  This is because wargv includes the executable name.

	    This problem is solved in a later drop of the argument lib. */

     case OPT_WSTRING:

     { 
       PWCHAR p;
       ULONG  len;
       
       len = strlen( tostore ) +1;
       
       if ( OptionAlloc( pQueue, &p, len * sizeof( WCHAR ) ) ) {

	 wsprintfW( p, L"%hs", tostore );

	 *(POPTU_CAST( *opt )->wstring ) = p;
		  
	 return TRUE;

       } else {

	 fprintf( stderr, "ERROR: cannot allocate WCHAR memory\n" );
	 return FALSE;
       }

     }

     case OPT_USTRING:
	 
     { 

       PWCHAR p;
       ULONG  len;

       len = strlen( tostore ) +1;
       
       if ( OptionAlloc( pQueue, &p, len * sizeof( WCHAR ) ) ) {

	 wsprintfW( p, L"%hs", tostore );

	 RtlInitUnicodeString( ( POPTU_CAST( *opt ) -> unicode_string ), p );
	 
	 return TRUE;

       } else {

	 fprintf( stderr, "ERROR: cannot allocate Unicode memory\n" );
	 return FALSE;
       }

     }

#endif

     case OPT_INT:
	 OPTIONS_DEBUG("[OPT_INT]");

	 if ( !isxdigit( tostore[0] ) ) {
	   fprintf( stderr, "Parser: argument \"%s\" is not a number.\n",
		    tostore );
	   return FALSE;
	 }

	 *( POPTU_CAST( *opt ) ->integer ) = strtol( tostore, NULL, 0 ) ;

	 return TRUE;

     case OPT_BOOL:

     {

       int i;
	   
       for (i = 0 ; i < szBoolSynonyms ; i++ ) {
	 
	 OPTIONS_DEBUG( "Comparing %hs against synonym %hs...",
			tostore,
			BoolSynonyms[i].word );
	 
	 if (STRCASECMP( BoolSynonyms[i].word,
			 tostore ) == 0 ) {
	   
	   *(POPTU_CAST( *opt )->boolean ) = BoolSynonyms[i].value;
	   
	   return TRUE;
	     
	 }
       }

       // if we get here, we had no idea.  toggle the option.

       *(POPTU_CAST( *opt )->boolean ) = ! *(POPTU_CAST( *opt )->boolean );
       return TRUE;
     }


	 
     default: /* unknown or unspecified option type */

       /* while we don't see all the options in this switch, to store a 
	  single string option, you would have to modify this one, so we
	  hook this switch into all of them. */
	 
#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch if your option uses 1 string."
#endif

	 fprintf(stderr, 
		 "Internal error: option \"%hs\" has bad type 0x%x."
		 "  Skipping this option.\n",
		 opt->cmd, opt->flags & OPT_MUTEX_MASK );

	 return FALSE;

    } /* options switch */
    
    
    ASSERT_NOTREACHED( "*Everything* should be handled by the switch" );

}



/*++ StoreOption:
   
   Stores a single option within the structure.

   Returns the number of arguments used (including this one).
   If none were used (or an error occurs), returns zero.

   opt         : pointer to the option vector we're using-- the whole 
                 thing must be passed for OPT_HELP.
   argv, argc  : as in main()
   argi        : current index in argv[].  For example, if our command line 
                 were:
   
		 foo -bar 99 -baz 1
		
		 and we're trying to store the -bar 99 argument, we'd pass 1 
		 for argi, since foo is arg 0.
  opti         : index into opt we're storing

  includes_arg : if argi points to the argument (-bar above) itself, set this
                 to TRUE.  If argi points to the value of the argument (99 in
		 this case), set this to FALSE.


   We only handle the special cases here, and pass the normal cases off
   on StoreOptionString above

		 --*/

#define ARG(x) (includes_arg? (x) : ((x)-1)) /* local to StoreOption only */

BOOL
StoreOption( optionStruct *opt, 
	     PCHAR        *argv,
	     int           argc,
	     int           argi,
	     int           opti,
	     ULONG         flags,
	     int           *argsused,
	     BOOL          includes_arg /* set to true if we include the 
					   command argument (example: -foo BAR
					   would be TRUE but just BAR would 
					   not) */,
	     PBOOL         pbStopParsing,
	     PSAVEQUEUE    pQueue  ) {

    BOOL   ret  = FALSE;
    int    used = 0;
    ULONG  local_argc;
    PCHAR *local_argv;
	 
    *pbStopParsing = FALSE; // default.
    local_argc     = (includes_arg ? argi+1 : argi );
    local_argv     = argv + local_argc;
    local_argc     = argc - local_argc;

    OPTIONS_DEBUG( "StoreOption( opt=0x%x argv=0x%x argc=%d "
		   "argi=%d include=%d)",
		   opt, argv, argc, argi, includes_arg );

    switch( opt[opti].flags & OPT_MUTEX_MASK ) {

     case OPT_HELP:
	 PrintUsage( stderr, flags, opt, "" );

	 if ( flags & OPT_FLAG_TERMINATE ) {
	   exit( -1 );
	 } else {
	   *argsused = 1;
	   return TRUE;
	 }

     case OPT_CONTINUE:
     case OPT_DUMMY:
	 OPTIONS_DEBUG("[OPT_DUMMY or OPT_HELP]");
	 *argsused = ARG(1); /* just eat this parameter */
	 return TRUE;

     case OPT_FUNC:
     case OPT_FUNC2:
	
       {
	 PCHAR       *localargv;
	 unsigned int localargc;
	 int i;

	 if (includes_arg) {
	   localargv = &(argv[argi]);
	   localargc = argc - argi;
	 } else {
	   localargv = &(argv[argi-1]);
	   localargc = argc - argi -1;
	 }

	 if ( (opt[opti].flags & OPT_MUTEX_MASK)  == OPT_FUNC ) {

	   OPTIONS_DEBUG("Jumping to OPTFUNC 0x%x...", 
			 ((POPTU) &opt[opti].data)->raw_data );

	   i = ((POPTU) &opt[opti].data)->func(localargc, localargv);

	   if ( i <= 0 ) {
	     return FALSE;
	   }

	 } else {

	   OPT_FUNC_PARAMETER_DATA ParamData = { 0 };

	   ASSERT( ( opt[opti].flags & OPT_MUTEX_MASK) == OPT_FUNC2 );
	   OPTIONS_DEBUG( " Jumping to OPTFUNC2 0x%x...", 
			  opt[opti].optData );

	   ParamData.optionVersion    = OPT_FUNC_PARAMETER_VERSION;
	   ParamData.dataFieldPointer = POPTU_CAST( opt[opti] )->raw_data;
	   ParamData.argc             = localargc;
	   ParamData.argv             = localargv;
	   ParamData.optionFlags      = ( ( flags & ~OPT_FLAG_REASSEMBLE ) |
					  OPT_FLAG_MEMORYLIST_OK |
					  OPT_FLAG_INTERNAL_JUMPOUT );
	   ParamData.pSaveQueue       = pQueue;

#if OPT_FUNC_PARAMETER_VERSION > 1
#error "New OPT_FUNC_PARAMETERs?  change initialization code here."
#endif	   

	   OPTIONS_DEBUG( "data for OPT_FUNC2 is:\n"
			  "ParamData.optionVersion    = %d\n"
			  "ParamData.dataFieldPointer = 0x%x\n"
			  "ParamData.argc             = %d\n"
			  "ParamData.argv             = 0x%x\n"
			  "ParamData.optionFlags      = 0x%x\n"
			  "ParamData.pSaveQueue       = 0x%x\n",

			  ParamData.optionVersion,
			  ParamData.dataFieldPointer,
			  ParamData.argc,
			  ParamData.argv,
			  ParamData.optionFlags,
			  ParamData.pSaveQueue );			  

	   if ( ! (((OPTFUNC2 *)(opt[opti].optData))( FALSE, &ParamData ))) {
	     return FALSE;
	   }

	   i = ParamData.argsused;

	 }

	 OPTIONS_DEBUG("return from function: %d\n", i );

	 ASSERT( i > 0 );
	 *argsused = ARG( i );
	 return TRUE;

       }

     case OPT_SUBOPTION:

	 OPTIONS_DEBUG("[OPT_SUBOPTION]" );

	 return ParseSublist( ((POPTU) &opt[opti].data),
			      argv, argc, argi,
			      argsused, flags, pbStopParsing, pQueue );

     case OPT_STOP_PARSING:

       *pbStopParsing = TRUE;
       *argsused      = 1;   
       return           TRUE;

     case OPT_INT:
     case OPT_ENUMERATED:
     case OPT_STRING:
	 
#ifdef WINNT
     case OPT_WSTRING:
     case OPT_USTRING:
#endif
       if ( StoreOptionStrings( //argv[ includes_arg ? argi+1: argi],
				opt+opti, 
				local_argc,
				local_argv,
				flags, 
				&local_argc,
				pQueue ) ) {
	 
	 *argsused = ARG( local_argc +1 );
	 return TRUE;
	 
       } else {
	 
	 return FALSE;
       }
       
	       
     case OPT_BOOL:

	 OPTIONS_DEBUG("[OPT_BOOL]");

	 if (includes_arg) {

	   switch (argv[argi][0]) {
	    case '-':
		OPTIONS_DEBUG("option is negative.");
		
		*( ((POPTU) &opt[opti].data)->boolean ) = FALSE;

		*argsused = 1;
		return TRUE;
		
	    case '+':
		OPTIONS_DEBUG("option is positive.");
		*( ((POPTU) &opt[opti].data)->boolean ) = TRUE;

		*argsused = 1;
		return TRUE;

	  default:
	      
	      OPTIONS_DEBUG("skipping bool...");
	      break;
	   }
	 }

	 if (argi < argc-1) {

	   if ( StoreOptionStrings( opt+opti,
				    local_argc,
				    local_argv,
				    flags, 
				    // argv[ includes_arg ? argi+1 : argi ],
				    &local_argc,
				    pQueue) ) {

	     *argsused = ARG( 1 );
	     return TRUE;
	   }
	 }
	 /* else, if nothing else works, just toggle the option */
	 
	 OPTIONS_DEBUG("toggling option.");

	 *( ((POPTU) &opt[opti].data)->boolean ) = 
	   ! *( ((POPTU) &opt[opti].data)->boolean );
	 
	 *argsused = 1; // exactly one.
	 return TRUE;

     default: /* unknown or unspecified option type */
	 

#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch statement or bad things will happen."
#endif

	 fprintf(stderr, 
		 "Internal error: option \"%hs\" has unknown type 0x%x."
		 "  Skipping this option.\n",
		 opt[opti].cmd, opt[opti].flags & OPT_MUTEX_MASK );

	 return FALSE;

    } /* options switch */
    
}

BOOL
StoreEnvironmentOption( optionStruct *opt,
			ULONG         flags,
			PSAVEQUEUE    pQueue) {


    PCHAR p;
    ULONG dummy;

    ASSERT( opt->optData != NULL );

    p = getenv( opt->optData );

    if ( !p ) {

      return FALSE;

    }

    return StoreOptionStrings( opt, 1, &p, flags, &dummy, pQueue );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\unparse.c ===
/*++

  UNPARSE.C

  utility function to convert a flat command back into an argc/argv pair.
  Scavenged from the Keytab subdirectory because it makes more sense here,
  on 8/19/1997 by DavidCHR

  --*/

#include "private.h"

/* UnparseOptions:

   cmd --> argc/argv.  Free argv with free().  */

BOOL
UnparseOptions( PCHAR  cmd,
                int   *pargc,
                PCHAR *pargv[] ) {

    int    argc=0;
    PCHAR *argv=NULL;
    char   prevChar='\0';
    int    szBuffer;
    int    i=0;
    PCHAR  heapBuffer=NULL;

    szBuffer = lstrlenA(cmd);

    for (i = 0; cmd[i] != '\0' ; i++ ) {

      /* count the characters while we count the words.
         could use strlen, but then we'd parse it twice,
         which is kind of unnecessary if the string can
         get fairly long */

      OPTIONS_DEBUG("[%d]'%c' ", i, cmd[i]);

      if (isspace(prevChar) && !isspace(cmd[i]) ) {
        /* ignore multiple spaces */
        OPTIONS_DEBUG("[New word boundary]");
        argc++;
      }

      prevChar = cmd[i];

    }

    if (!isspace(prevChar)) {
      argc++; /* trailing null is also a word boundary if the last
                 character was non-whitespace */
      OPTIONS_DEBUG("Last character is not a space.  Argc = %d.\n", argc);
    }
    OPTIONS_DEBUG("done parsing.  i = %d.  buffer-->%hs\n",
		  i, cmd);

    OPTIONS_DEBUG("saving argc...");

    *pargc = argc; // save argc.

    /* ok, argc is our wordcount, so we must allocate argc+1 
	 (null terminate) pointers and i+1 (null terminate) characters */

    argv = (PCHAR *) malloc( ((argc+1) * sizeof( PCHAR )) +
			     ((i+1) * sizeof(CHAR)) );

    if ( !argv ) {
      return FALSE;
    }
    
    OPTIONS_DEBUG("ok.\nsaving argv (0x%x)...", argv);
    *pargv = argv; // save the argv.

    OPTIONS_DEBUG( "ok.\n"
		   "Assigning heapBuffer as argv[argc+1 = %d] = 0x%x...",
		   argc+1, argv+argc+1);

    /* now we've got this glob of memory, separate the pointers from
	 the characters.  The pointers end at argv[argc], so &(argv[argc+1])
	 should start the rest */

    heapBuffer = (PCHAR) &(argv[argc+1]);

    /* now, copy the string, translating spaces to null characters and
	 filling in pointers at the same time */

    OPTIONS_DEBUG("ok\ncopying the string manually...");

    argc = 0; // reuse argc, since it's saved.

    prevChar = ' ';

    for (i = 0 ; cmd[i] != '\0' ; i++ ) {

      if (isspace(cmd[i])) {

	OPTIONS_DEBUG("[%d]'%c' --> NULL\n", i, cmd[i]);
	heapBuffer[i] = '\0';

      } else { // current char is not a space.

	heapBuffer[i] = cmd[i];

	OPTIONS_DEBUG("[%d]'%c' ", i, cmd[i]);

	if (isspace(prevChar)) {
	  /* beginning of a word.  Set the current word pointer
	     (argv[argc]) in addition to the regular stuff */

	  OPTIONS_DEBUG("[word boundary %d]", argc);

	  argv[argc] = &(heapBuffer[i]);
	  argc++;
	}
      }

      prevChar = cmd[i];

    }

    heapBuffer[i] = '\0'; // copy the null character too.
    OPTIONS_DEBUG("[%d] NULL\n", i );

    OPTIONS_DEBUG("returning:\n");
    for (i = 0 ; i < argc ; i++ ) {
      OPTIONS_DEBUG("[%d]%hs\n", i, argv[i]);
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\sync\common\defs.h ===
/*++

  DEFS.H

  definitions common to the unix side and the NT side.

  2/9/1997 -DavidCHR

  This file is the interface between the unix compiler and the nt 
  compiler.  It ensures that we can use the same basic stuff under
  both platforms (e.g. do not use ULONG, use LONG32... ).

  This file must build on NT and UNIX systems both.
  DO NOT include NT-specific code without ensuring that it will
  ONLY be seen by the NT compiler.

  --*/

#ifndef DEFS_H_INCLUDED
#define DEFS_H_INCLUDED 1

typedef ULONG KTLONG32, *PKTLONG32;
typedef BYTE  CHAR8,    *PCHAR8;

#ifndef TIMEOUT /* timeout values for all the netreads-- 0 = forever */
#define TIMEOUT 0 
#endif

#define WE_ARE_USELESS 10000 /* collides with some error values, but none that
				we happen to be using */



/* compiling under NT. */

#include "master.h"

#define WINNT_ONLY(statement) statement
#define UNIX_ONLY( statement) /* nothing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\sublist.c ===
/*++

  SUBLIST.C

  Code for parsing a suboption list

  DavidCHR 6/6/1997

  --*/

#include "private.h"


/*
  ParseSublist:

  Handler code for parsing a sublist entry.

  */

BOOL
ParseSublist( POPTU  Option,
	      PCHAR *argv,
	      int    argc,
	      int    theIndex,

	      int        *argsused,
	      ULONG      flags,
	      PBOOL      pbDoneParsing,
	      PSAVEQUEUE pQueue ) {
	
    PCHAR TheOption;
    ULONG i;

    ASSERT( Option   != NULL );
    ASSERT( argv     != NULL );
    ASSERT( argc     != 0    );
    ASSERT( theIndex < argc  );

    OPTIONS_DEBUG( "ParseSublist: Option = 0x%x, argv=0x%x, "
		   "argc=%d, theIndex=%d",
		   Option, argv, argc, theIndex );

    TheOption = argv[ theIndex ];

    OPTIONS_DEBUG( "TheOption = [%d] %s... ", theIndex, TheOption );

    for ( i = 0 ; TheOption[i] != ':' ; i++ ) {
      if ( TheOption[i] == '\0' ) {
	fprintf( stderr,
		 "ParseOptions: %s should be of the form "
		 "%s:option (:option:option...)\n",
		
		 TheOption, TheOption );
	return FALSE;
      }
    }

    ASSERT( TheOption[i] == ':' ); /* algorithm check */

    if ( !ISSWITCH( TheOption[0] ) ) {

      /* The easy side--
	 just send the argc and argv structure in, MANGLING
	 the first option */

      /* we do not deal with pbStopParsing in this branch, because it seems
	 somehow unlikely that deep down in a nested substructure, someone
	 would bury an option like this:

	 opt:foo:bar:baz:terminate

	 to stop the toplevel parser.  */

      OPTIONS_DEBUG( "ISSWITCH: easy case (%c is not a switch)",
		     TheOption[0] );

      ASSERT( argv[ theIndex ][i] == ':' );

      argv[ theIndex ] += i+1;

      ASSERT( argv[ theIndex ][0] != ':' );

      return ParseOptionsEx( argc-theIndex,
			     argv+theIndex,
			     Option->optStruct,
			     flags | OPT_FLAG_MEMORYLIST_OK,
			     &pQueue,
			     NULL, NULL );
    } else {

      /* The Hard part--

	 create a new vector of argv, pointing the first at the local buffer.
	 Since the first buffer PROBABLY won't be used as a string
	 (NOTE: if it's OPT_DEFAULT, it could be), it's safe to use this
	 on the stack. */
		
      PCHAR *newargv;
      ULONG  j;
      ULONG  total; /* total elements in the new list */
      CHAR   LocalBuffer[ 255 ];
      BOOL   ret;
      int    tmp;

      OPTIONS_DEBUG( "Hard case (%c is a switch): ", TheOption[0] );

      sprintf( LocalBuffer, "%c%s",
	       TheOption[0],
	       TheOption+i+1 );

      OPTIONS_DEBUG( "LocalBuffer = %s\n", LocalBuffer );

      total   = argc - theIndex ; /* 2? */
      newargv = malloc( total * sizeof(PCHAR) );

      if (!newargv) {
	fprintf(stderr, "Failed to allocate memory in ParseOptions\n");
	return 0;
      }

      newargv[0] = LocalBuffer;

      for( j = 1 ; j < total ; j++ ) {
	
	OPTIONS_DEBUG( "j == %d, total == %d\n", j, total );

	ASSERT( argv[j]    != NULL );
	ASSERT( (int)(j+theIndex) <  argc );
	
	newargv[j] = argv[j+theIndex ];

	OPTIONS_DEBUG( "assign [%d] %s --> [%d] %s\n",
		       j+theIndex, argv[j+theIndex],
		       j, newargv[j] );
	
      }

      ret = ParseOneOption( total, newargv, 0 /* parse the first option */,
			    flags, Option->optStruct, argsused, pbDoneParsing,
			    pQueue );


      free( newargv );

      OPTIONS_DEBUG( "done.  returning %d...\n", ret );

      return ret;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\utest3.c ===
/*++

  UTEST.C

  Test program for the options subsystem.  Must compile under
  NT and UNIX

  Created, 5/24/1997 by DavidCHR

  --*/

#include "private.h"

optEnumStruct enums[] = {

  { "one",    (PVOID) 1,                          "should end up 1" },
  { "two",    (PVOID) 2,                          "should end up 2" },
  { "beef",   (PVOID)(UINT_PTR)(UINT) 0xdeadbeef, "should be 0xdeadbeef" },
  { "beefs",  (PVOID)(UINT_PTR)(UINT) 0xbadf00d,  "should be 0xbadf00d" },
  { "secret", (PVOID) 60,         },              // shouldn't show in help

  TERMINATE_ARRAY

};

ULONG enumTestVariable=0;

PCHAR SubString = NULL;


optionStruct substructOptions[] = {

  { "h",      NULL,       OPT_HELP },
  { "substr", &SubString, OPT_STRING, "Substring option" },

  TERMINATE_ARRAY
};

PCHAR          FuncString1         = NULL;
PCHAR          FuncString2         = NULL;
PCHAR          StringOption        = NULL;
int            IntegerOption       = 0L;
BOOL           BooleanOption       = FALSE;
float          FloatOption         = 0.0;
PCHAR          UndocumentedString  = NULL;
PWCHAR         WideCharOption      = NULL;
UNICODE_STRING UnicodeStringOption = { 0 };

int            MyOptFunc( IN  int argc,
			  IN  PCHAR *argv );
BOOL           MyOptFunc2( IN BOOL fHelp,
			   IN POPT_FUNC_PARAMETER_DATA pData );

optionStruct sampleOptions[ ] = {

  { "help",  NULL, OPT_HELP },
  { "?",     NULL, OPT_HELP },

  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },
  { NULL, NULL, OPT_CONTINUE, "These are the useful options:" },
  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },

  { "enum",      &enumTestVariable, OPT_ENUMERATED,
    "Test enumerated type", enums },

  { "mask",      &enumTestVariable, OPT_ENUMERATED | OPT_ENUM_IS_MASK,
    "Test enumerated type with OPT_ENUM_IS_MASK", enums },

  { "substruct", substructOptions, OPT_SUBOPTION | OPT_RECURSE,
    "substruct:help for help" },
  { "recurse",   sampleOptions,    OPT_SUBOPTION, "recurse:help for help" },

  { "string", &StringOption,  OPT_STRING | OPT_ENVIRONMENT, "String Option",
    "StringOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request a string" },

  { "int",    &IntegerOption,  OPT_INT | OPT_ENVIRONMENT,   "integer option",
    "IntegerOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request an integer" },

  { "func",   MyOptFunc,           OPT_FUNC,   "function option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request two strings" },

  { "func2",  &IntegerOption,      OPT_FUNC2,  "FUNC2 option",
    MyOptFunc2 },

  { "bool",   &BooleanOption,      OPT_BOOL,   "boolean option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a boolean" },

  { "float",  &FloatOption,        OPT_FLOAT,  "floating point option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a float" },

  { "wstring",&WideCharOption, OPT_WSTRING | OPT_ENVIRONMENT,
    "Wide Char String option", "WideCharOption" },

  { "ustring",&UnicodeStringOption, OPT_USTRING | OPT_ENVIRONMENT,
    "Unicode String Option",  "UnicodeStringOption" },

  { "hidden", &UndocumentedString, OPT_STRING | OPT_HIDDEN,
    "you should never see this line.  This option is OPT_HIDDEN" },

  { "stop",   NULL,                OPT_STOP_PARSING,
    "halts parsing of the command line." },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER, "" },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER,
    "Example: utest /string \"foo bar baz\" /int 0x15 +bool /float 3.14" },

  { NULL, NULL, OPT_PAUSE },

  TERMINATE_ARRAY

};

int
MyOptFunc( int argc,
	   PCHAR *argv ) {

    if ( ( argv == NULL ) || (argc < 3 ) ) {
      /* this means the user requested help */
      fprintf( stderr, "func [string1] [string2]\n" );
      return 0;
    }

    printf( "MyOptFunc was called.  argc=%d.\n", argc );

    FuncString1 = argv[1];
    FuncString2 = argv[2];

    return 3; /* number of arguments eaten--
		 -func argv[1] argv[2] == 3 options */

}

VOID
DumpArgs( int argc,
	  PCHAR argv[] ) {

    int i;

    for ( i = 0 ; i < argc ; i++ ) {
      fprintf( stderr, "arg %d = %s\n", i, argv[i] );
    }

}

BOOL
MyOptFunc2( IN BOOL                     fHelp,
	    IN POPT_FUNC_PARAMETER_DATA pData ) {

#if OPT_FUNC_PARAMETER_VERSION != 1
#error "OptFuncParameterVersion has changed.  Update this function."
#endif

    optionStruct OptFunc2Options[] = {

      { "help",        NULL,          OPT_HELP },
      { "FuncString1", &FuncString1,  OPT_INT },
      { "FuncString2", &FuncString2,  OPT_INT },
      { "recurse",     sampleOptions, OPT_SUBOPTION,
	"points back to the toplevel structure.  Very amusing.  :-)" },
      { "STOP",        NULL,          OPT_STOP_PARSING,
	"halts parsing within the Func2." },

      TERMINATE_ARRAY

    };

    if ( fHelp ) {

      CHAR buffer[ 255 ];

      PrintUsageEntry( stderr,
		       "[-/+]",         // switch characters
		       pData->argv[0],  // command GUARANTEED TO EXIST
		       "->",           // separator
		       "Exercises the OPT_FUNC2 interface.  Options follow",
		       FALSE );         // FALSE--> do not repeat switch.

      sprintf( buffer, "-> options %s takes ", pData->argv[0] );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-=",   // the NULLs will fill with this string.
		       buffer,
		       TRUE );

      sprintf( buffer, "(%s) ", pData->argv[0] );

      PrintUsage( stderr,
		  0L, // flags
		  OptFunc2Options,
		  buffer );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-*",
		       "-> (end of OPT_FUNC2 options)",
		       TRUE );

      return TRUE;

    } else {

      if ( pData->optionVersion != OPT_FUNC_PARAMETER_VERSION ) {
	fprintf( stderr,
		 "WARNING: option library out of sync with header\n" );
      }

      fprintf( stderr,
	       "MyOptFunc2 called.  Data follows:\n"
	       "pData->optionVersion = %d\n"
	       "pData->dataField     = 0x%p\n"
	       "pData->argc          = %d\n"
	       "pData->argv          = 0x%p\n"
	       "pData->optionFlags   = 0x%x\n"
	       "pData->pSaveQueue    = 0x%p\n",

	       pData->optionVersion,
	       pData->dataFieldPointer,
	       pData->argc,
	       pData->argv,
	       pData->optionFlags,
	       pData->pSaveQueue );

      fprintf( stderr, "%s arguments are:\n", pData->argv[0] );

      DumpArgs( pData->argc, pData->argv );

      if ( ParseOptionsEx( pData->argc-1,
			   pData->argv+1,
			   OptFunc2Options,
			   pData->optionFlags,
			   &pData->pSaveQueue,
			   &pData->argsused,
			   &pData->argv ) ) {

	fprintf( stderr,
		 "pData->argsused IN   = %d\n", pData->argsused );

	pData->argsused = pData->argc - pData->argsused;

	fprintf( stderr,
		 "pData->argsused OUT  = %d\n", pData->argsused );

      } else return FALSE;

    }

    fprintf( stderr, "\n Leaving OPT_FUNC2. \n\n" );

    return TRUE;

}


int
__cdecl
main( int  argc,
      char *argv[] ) {

    BOOL  foo;
    PVOID pCleanup = NULL;
    optEnumStruct parserOptions[] = {

      { "skip",       (PVOID) OPT_FLAG_SKIP_UNKNOWNS,
	"OPT_FLAG_SKIP_UNKNOWNS" },
      { "reassemble", (PVOID) OPT_FLAG_REASSEMBLE,
	"OPT_FLAG_REASSEMBLE" },
      { "terminate",  (PVOID) OPT_FLAG_TERMINATE,
	"OPT_FLAG_TERMINATE" },

      TERMINATE_ARRAY
    };

    ULONG ParserFlag = OPT_FLAG_REASSEMBLE;

#ifndef DEBUG_OPTIONS
    BOOL DebugFlag = 0; // will be ignored... just here for convenience
#endif
    optionStruct singleOption[] = {

      { "utestHelp",  NULL, OPT_HELP },

      { "parserFlag", &ParserFlag, OPT_ENUMERATED,
	"flags to pass to ParseOptionsEx", parserOptions },
      { "headerlength", &OptMaxHeaderLength, OPT_INT,
	"OptMaxHeaderLength value (formatting)" },
      { "commandLength", &OptMaxCommandLength, OPT_INT,
	"OptMaxCommandLength value (formatting)" },
      { "separatorLength", &OptMaxSeparatorLength, OPT_INT,
	"OptMaxSeparatorLength value (formatting)" },
      { "descriptionLength", &OptMaxDescriptionLength, OPT_INT,
	"OptMaxDescriptionLength value (formatting)" },
      { "debug",      &DebugFlag,  OPT_INT, "Debugger status" },

      TERMINATE_ARRAY

    };

    DebugFlag |= OPTION_DEBUGGING_LEVEL;

    foo = ParseOptionsEx( argc-1, argv+1, singleOption,
			  0, &pCleanup, &argc, &argv );

    ParserFlag |= OPT_FLAG_MEMORYLIST_OK;

    fprintf( stderr,

	     "first ParseOptionsEx returned 0x%x \n"
	     "                    saveQueue 0x%p \n"
	     "             passing in flags 0x%x \n",

	     foo, pCleanup, ParserFlag );

    if ( argc ) {

      ULONG i;

      fprintf( stderr, "%d new options: \n", argc );
      DumpArgs( argc, argv );

      fprintf( stderr, "\n" );
    }

    foo = ParseOptionsEx( argc, argv, sampleOptions, ParserFlag,
			  &pCleanup, &argc, &argv );

    fprintf( stderr,
	     "ParseOptionsEx returns %d\n"
	     "          new argv = 0x%p\n"
	     "          new argc = %d \n",
	     foo, argv, argc );


    DumpArgs( argc, argv );

    printf( "Formatting values were:\n"
	    "\tOptMaxHeaderLength      = %d\n"
	    "\tOptMaxCommandLength     = %d\n"
	    "\tOptMaxSeparatorLength   = %d\n"
	    "\tOptMaxDescriptionLength = %d\n",

	    OptMaxHeaderLength,
	    OptMaxCommandLength,
	    OptMaxSeparatorLength,
	    OptMaxDescriptionLength );

    printf( "\nOptions used:\n"
	    "\tstring           = \"%hs\"\n"
	    "\tint              = %d \n"
	    "\tBool             = 0x%x \n"
	    /* "Float   = %f \n" */
	    "\twstring          = L\"%ws\"\n"
	    "\tustring          = (unicode string) %wZ \n"
	    "\thidden           = \"%hs\"\n"
	    "\tsubstruct:substr = \"%hs\"\n"
	    "\tfuncString1      = \"%hs\"\n"
	    "\tfuncString2      = \"%hs\"\n"
	    "\tenum             = %d (0x%x)\n",

	    StringOption,
	    IntegerOption,
	    BooleanOption,
	    /* FloatOption, */ /* floating point not loaded?
	                          What does that mean?! */
	    WideCharOption,
	    &UnicodeStringOption,
	    UndocumentedString,
	    SubString,
	
	    FuncString1,
	    FuncString2,

	    enumTestVariable, enumTestVariable  );

    CleanupOptionDataEx( pCleanup );

    return foo;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\keytab2\opt\utest.c ===
/*++

  UTEST.C

  Test program for the options subsystem.  Must compile under
  NT and UNIX

  Created, 5/24/1997 by DavidCHR

  --*/

#include "private.h"

optEnumStruct enums[] = {

  { "one",    (PVOID) 1,          "should end up 1" },
  { "two",    (PVOID) 2,          "should end up 2" },
  { "beef",   (PVOID) 0xdeadbeef, "should be 0xdeadbeef" },
  { "beefs",  (PVOID) 0xbadf00d,  "should be 0xbadf00d" },
  { "secret", (PVOID) 60,         }, // shouldn't show in help

  TERMINATE_ARRAY

};

ULONG enumTestVariable=0;

PCHAR SubString = NULL;


optionStruct substructOptions[] = {

  { "h",      NULL,       OPT_HELP },
  { "substr", &SubString, OPT_STRING, "Substring option" },

  TERMINATE_ARRAY
};

PCHAR          FuncString1         = NULL;
PCHAR          FuncString2         = NULL;
PCHAR          StringOption        = NULL;
int            IntegerOption       = 0L;
BOOL           BooleanOption       = FALSE;
float          FloatOption         = 0.0;
PCHAR          UndocumentedString  = NULL;
PWCHAR         WideCharOption      = NULL;
UNICODE_STRING UnicodeStringOption = { 0 };

int            MyOptFunc( IN  int argc,
			  IN  PCHAR *argv );
BOOL           MyOptFunc2( IN BOOL fHelp,
			   IN POPT_FUNC_PARAMETER_DATA pData );

optionStruct sampleOptions[ ] = {

  { "help",  NULL, OPT_HELP },
  { "?",     NULL, OPT_HELP },

  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },
  { NULL, NULL, OPT_CONTINUE, "These are the useful options:" },
  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },

  { "enum",      &enumTestVariable, OPT_ENUMERATED,
    "Test enumerated type", enums },

  { "mask",      &enumTestVariable, OPT_ENUMERATED | OPT_ENUM_IS_MASK,
    "Test enumerated type with OPT_ENUM_IS_MASK", enums },

  { "substruct", substructOptions, OPT_SUBOPTION | OPT_RECURSE,
    "substruct:help for help" },
  { "recurse",   sampleOptions,    OPT_SUBOPTION, "recurse:help for help" },

  { "string", &StringOption,  OPT_STRING | OPT_ENVIRONMENT, "String Option",
    "StringOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request a string" },

  { "int",    &IntegerOption,  OPT_INT | OPT_ENVIRONMENT,   "integer option",
    "IntegerOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request an integer" },

  { "func",   MyOptFunc,           OPT_FUNC,   "function option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request two strings" },

  { "func2",  &IntegerOption,      OPT_FUNC2,  "FUNC2 option",
    MyOptFunc2 },

  { "bool",   &BooleanOption,      OPT_BOOL,   "boolean option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a boolean" },

  { "float",  &FloatOption,        OPT_FLOAT,  "floating point option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a float" },

  { "wstring",&WideCharOption, OPT_WSTRING | OPT_ENVIRONMENT,
    "Wide Char String option", "WideCharOption" },

  { "ustring",&UnicodeStringOption, OPT_USTRING | OPT_ENVIRONMENT,
    "Unicode String Option",  "UnicodeStringOption" },

  { "hidden", &UndocumentedString, OPT_STRING | OPT_HIDDEN,
    "you should never see this line.  This option is OPT_HIDDEN" },

  { "stop",   NULL,                OPT_STOP_PARSING,
    "halts parsing of the command line." },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER, "" },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER,
    "Example: utest /string \"foo bar baz\" /int 0x15 +bool /float 3.14" },

  { NULL, NULL, OPT_PAUSE },

  TERMINATE_ARRAY

};

int
MyOptFunc( int argc,
	   PCHAR *argv ) {

    if ( ( argv == NULL ) || (argc < 3 ) ) {
      /* this means the user requested help */
      fprintf( stderr, "func [string1] [string2]\n" );
      return 0;
    }

    printf( "MyOptFunc was called.  argc=%d.\n", argc );

    FuncString1 = argv[1];
    FuncString2 = argv[2];

    return 3; /* number of arguments eaten--
		 -func argv[1] argv[2] == 3 options */

}

VOID
DumpArgs( int argc,
	  PCHAR argv[] ) {

    int i;

    for ( i = 0 ; i < argc ; i++ ) {
      fprintf( stderr, "arg %d = %s\n", i, argv[i] );
    }

}

BOOL
MyOptFunc2( IN BOOL                     fHelp,
	    IN POPT_FUNC_PARAMETER_DATA pData ) {

#if OPT_FUNC_PARAMETER_VERSION != 1
#error "OptFuncParameterVersion has changed.  Update this function."
#endif

    optionStruct OptFunc2Options[] = {

      { "help",        NULL,          OPT_HELP },
      { "FuncString1", &FuncString1,  OPT_INT },
      { "FuncString2", &FuncString2,  OPT_INT },
      { "recurse",     sampleOptions, OPT_SUBOPTION,
	"points back to the toplevel structure.  Very amusing.  :-)" },
      { "STOP",        NULL,          OPT_STOP_PARSING,
	"halts parsing within the Func2." },

      TERMINATE_ARRAY

    };

    if ( fHelp ) {

      CHAR buffer[ 255 ];

      PrintUsageEntry( stderr,
		       "[-/+]",         // switch characters
		       pData->argv[0],  // command GUARANTEED TO EXIST
		       "->",           // separator
		       "Exercises the OPT_FUNC2 interface.  Options follow",
		       FALSE );         // FALSE--> do not repeat switch.

      sprintf( buffer, "-> options %s takes ", pData->argv[0] );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-=",   // the NULLs will fill with this string.
		       buffer,
		       TRUE );

      sprintf( buffer, "(%s) ", pData->argv[0] );

      PrintUsage( stderr,
		  0L, // flags
		  OptFunc2Options,
		  buffer );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-*",
		       "-> (end of OPT_FUNC2 options)",
		       TRUE );

      return TRUE;

    } else {

      if ( pData->optionVersion != OPT_FUNC_PARAMETER_VERSION ) {
	fprintf( stderr,
		 "WARNING: option library out of sync with header\n" );
      }

      fprintf( stderr,
	       "MyOptFunc2 called.  Data follows:\n"
	       "pData->optionVersion = %d\n"
	       "pData->dataField     = 0x%p\n"
	       "pData->argc          = %d\n"
	       "pData->argv          = 0x%p\n"
	       "pData->optionFlags   = 0x%x\n"
	       "pData->pSaveQueue    = 0x%p\n",

	       pData->optionVersion,
	       pData->dataFieldPointer,
	       pData->argc,
	       pData->argv,
	       pData->optionFlags,
	       pData->pSaveQueue );

      fprintf( stderr, "%s arguments are:\n", pData->argv[0] );

      DumpArgs( pData->argc, pData->argv );

      if ( ParseOptionsEx( pData->argc-1,
			   pData->argv+1,
			   OptFunc2Options,
			   pData->optionFlags,
			   &pData->pSaveQueue,
			   &pData->argsused,
			   &pData->argv ) ) {

	fprintf( stderr,
		 "pData->argsused IN   = %d\n", pData->argsused );

	pData->argsused = pData->argc - pData->argsused;

	fprintf( stderr,
		 "pData->argsused OUT  = %d\n", pData->argsused );

      } else return FALSE;

    }

    fprintf( stderr, "\n Leaving OPT_FUNC2. \n\n" );

    return TRUE;

}



int
main( int  argc,
      char *argv[] ) {

    BOOL  foo;
    PVOID pCleanup = NULL;
    optEnumStruct parserOptions[] = {

      { "skip",       (PVOID) OPT_FLAG_SKIP_UNKNOWNS,
	"OPT_FLAG_SKIP_UNKNOWNS" },
      { "reassemble", (PVOID) OPT_FLAG_REASSEMBLE,
	"OPT_FLAG_REASSEMBLE" },
      { "terminate",  (PVOID) OPT_FLAG_TERMINATE,
	"OPT_FLAG_TERMINATE" },

      TERMINATE_ARRAY
    };

    ULONG ParserFlag = OPT_FLAG_REASSEMBLE;

#ifndef DEBUG_OPTIONS
    BOOL DebugFlag = 0; // will be ignored... just here for convenience
#endif
    optionStruct singleOption[] = {

      { "utestHelp",  NULL, OPT_HELP },

      { "parserFlag", &ParserFlag, OPT_ENUMERATED,
	"flags to pass to ParseOptionsEx", parserOptions },
      { "headerlength", &OptMaxHeaderLength, OPT_INT,
	"OptMaxHeaderLength value (formatting)" },
      { "commandLength", &OptMaxCommandLength, OPT_INT,
	"OptMaxCommandLength value (formatting)" },
      { "separatorLength", &OptMaxSeparatorLength, OPT_INT,
	"OptMaxSeparatorLength value (formatting)" },
      { "descriptionLength", &OptMaxDescriptionLength, OPT_INT,
	"OptMaxDescriptionLength value (formatting)" },
      { "debug",      &DebugFlag,  OPT_INT, "Debugger status" },

      TERMINATE_ARRAY

    };

    DebugFlag |= OPTION_DEBUGGING_LEVEL;

    foo = ParseOptionsEx( argc-1, argv+1, singleOption,
			  0, &pCleanup, &argc, &argv );

    ParserFlag |= OPT_FLAG_MEMORYLIST_OK;

    fprintf( stderr,

	     "first ParseOptionsEx returned 0x%x \n"
	     "                    saveQueue 0x%p \n"
	     "             passing in flags 0x%x \n",

	     foo, pCleanup, ParserFlag );

    if ( argc ) {

      ULONG i;

      fprintf( stderr, "%d new options: \n", argc );
      DumpArgs( argc, argv );

      fprintf( stderr, "\n" );
    }

    foo = ParseOptionsEx( argc, argv, sampleOptions, ParserFlag,
			  &pCleanup, &argc, &argv );

    fprintf( stderr,
	     "ParseOptionsEx returns %d\n"
	     "          new argv = 0x%p\n"
	     "          new argc = %d \n",
	     foo, argv, argc );


    DumpArgs( argc, argv );

    printf( "Formatting values were:\n"
	    "\tOptMaxHeaderLength      = %d\n"
	    "\tOptMaxCommandLength     = %d\n"
	    "\tOptMaxSeparatorLength   = %d\n"
	    "\tOptMaxDescriptionLength = %d\n",

	    OptMaxHeaderLength,
	    OptMaxCommandLength,
	    OptMaxSeparatorLength,
	    OptMaxDescriptionLength );

    printf( "\nOptions used:\n"
	    "\tstring           = \"%hs\"\n"
	    "\tint              = %d \n"
	    "\tBool             = 0x%x \n"
	    /* "Float   = %f \n" */
	    "\twstring          = L\"%ws\"\n"
	    "\tustring          = (unicode string) %wZ \n"
	    "\thidden           = \"%hs\"\n"
	    "\tsubstruct:substr = \"%hs\"\n"
	    "\tfuncString1      = \"%hs\"\n"
	    "\tfuncString2      = \"%hs\"\n"
	    "\tenum             = %d (0x%x)\n",

	    StringOption,
	    IntegerOption,
	    BooleanOption,
	    /* FloatOption, */ /* floating point not loaded?
	                          What does that mean?! */
	    WideCharOption,
	    &UnicodeStringOption,
	    UndocumentedString,
	    SubString,
	
	    FuncString1,
	    FuncString2,

	    enumTestVariable, enumTestVariable  );

    CleanupOptionDataEx( pCleanup );

    return foo;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\dmpstate.cxx ===
/*++

  DMPSTATE.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: code and support for DumpState()

  Created, May 21, 1999 by DavidCHR.

  --*/

#include "everything.hxx"

extern NTSTATUS // realmflags.cxx
GetRealmFlags( IN  LPWSTR RealmName,
	       OUT PULONG pulRealmFlags );

extern VOID  // realmflags.cxx
PrintRealmFlags( IN ULONG RealmFlags );


DWORD
LoadAndPrintNames( IN LPSTR  KeyName,
		   IN HKEY   DomainKey,
		   IN BOOL   bPrintEmptyIfMissing,
		   IN LPWSTR ValueName ) {

    ULONG  KdcNameSize = 0, i;
    LPWSTR KdcNames;
    DWORD  WinError = STATUS_UNSUCCESSFUL;
    DWORD  Type;
    CMULTISTRING StringClass;

    if ( StringClass.ReadFromRegistry( DomainKey,
				       ValueName ) ) {
      
      if ( StringClass.cEntries != 0 ) {
	
	for ( i = 0 ;
	      i < StringClass.cEntries ;
	      i ++ ) {

	  printf( "\t%hs = %ws\n",
		  KeyName,
		  StringClass.pEntries[ i ] );

	}
	
      } else {

	if ( bPrintEmptyIfMissing ) {
	  
	  printf( "\t(no %hs entries for this realm)\n",
		  KeyName );
	  
	}
      }

    }

    return WinError;
}


NTSTATUS
PrintRealmList( VOID ) {

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG WinError;
    HKEY DomainRootKey = NULL;
    HKEY DomainKey = NULL;
    LPWSTR KdcNames = NULL;
    LPWSTR AlternateRealmNames = NULL;
    TCHAR DomainName[128];              // max domain name length
    ULONG Index,Index2;
    ULONG Type;
    ULONG NameSize;
    ULONG KdcNameSize = 0;
    ULONG AltRealmSize = 0;
    LPWSTR Where;
    ULONG NameCount;
    UNICODE_STRING TempString;
    ULONG          RealmFlags;

    //
    // Open the domains root key - if it is not there, so be it.
    //

    WinError = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                KERB_DOMAINS_KEY,
                &DomainRootKey
                );

    switch( WinError ) {

     case ERROR_FILE_NOT_FOUND:
	printf( "(No RFC1510 Kerberos Realms are defined).\n" );
	goto Cleanup;

     case ERROR_SUCCESS:
       break;

     default:
       printf("Failed to open key %ws: 0x%x\n", KERB_DOMAINS_KEY, WinError );
       goto Cleanup;
    }

    //
    // If it is there, we now want to enumerate all the child keys.
    //

    Index = 0;
    for (Index = 0; TRUE ; Index++ )
    {
        //
        // Enumerate through all the keys
        //
        NameSize = sizeof(DomainName) / sizeof( DomainName[ 0 ] );
        WinError = RegEnumKeyEx(
                    DomainRootKey,
                    Index,
                    DomainName,
                    &NameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

        if (WinError != ERROR_SUCCESS)
        {

	  if ( WinError != ERROR_NO_MORE_ITEMS ) {

	    printf( "Registry error 0x%x while enumerating domains.  Stopping here.\n",
		    WinError );

	  }
            break;
        }

        //
        // Open the domain key to tread the values under it
        //

        WinError = RegOpenKey(
                    DomainRootKey,
                    DomainName,
                    &DomainKey
                    );
        if (WinError != ERROR_SUCCESS)
        {
            printf("Failed to open key %ws \\ %ws: 0x%x\n",
                KERB_DOMAINS_KEY, DomainName, WinError );
            break;
        }

	printf( "%ws:\n",
		DomainName );

	LoadAndPrintNames( "kdc",
			   DomainKey,
			   TRUE,
			   KERB_DOMAIN_KDC_NAMES_VALUE );

	LoadAndPrintNames( "AlternateRealmName",
			   DomainKey,
			   FALSE,
			   KERB_DOMAIN_ALT_NAMES_VALUE );

	LoadAndPrintNames( "kpasswd",
			   DomainKey,
			   FALSE,
			   KERB_DOMAIN_KPASSWD_NAMES_VALUE );
	
	if ( NT_SUCCESS( GetRealmFlags( DomainName,
					&RealmFlags ) ) ) {

	  printf( "\tRealm Flags = 0x%x",
		  RealmFlags );

	  PrintRealmFlags( RealmFlags );
	  printf( "\n" );

	}
    }

Cleanup:

    if (KdcNames != NULL)
    {
        LocalFree(KdcNames);
    }
    if (AlternateRealmNames != NULL)
    {
        LocalFree(AlternateRealmNames);
    }
    return(Status);

}

NTSTATUS
PrintNameMapping( VOID ) 
{
    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY UserListHandle = NULL;

    WCHAR ValueNameBuffer[500];
    WCHAR ValueDataBuffer[500];
    PWSTR ValueName;
    PWSTR ValueData;
    ULONG NameLength;
    ULONG DataLength;
    ULONG Index;
    ULONG Type;
    BOOL  FoundAnyMappings = FALSE;
    CMULTISTRING StringClass;

    RegErr = OpenKerberosKey(&KerbHandle);
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = RegOpenKeyEx(
                KerbHandle,
                L"UserList",
                0,              // no options
                KEY_QUERY_VALUE,
                &UserListHandle
                );

    switch( RegErr ) {

     case ERROR_FILE_NOT_FOUND:

       goto NoMappingsWereFound;

     case ERROR_SUCCESS:

       break; // success condition.

     default:

        printf("Failed to create UserList key: 0x%x\n",RegErr);
        goto Cleanup;

    }

    for ( Index = 0;
	  ; // forever
	  Index++ ) {
      
      NameLength = sizeof(ValueNameBuffer); 
      DataLength = sizeof(ValueDataBuffer); 
      ValueName  = ValueNameBuffer;         
      ValueData  = ValueDataBuffer;
      
      RtlZeroMemory(
	   ValueName,
	   NameLength
	   );

      RtlZeroMemory(
            ValueData,
            DataLength
            );

      // 279626: this value should be in bytes 

      NameLength /= sizeof( WCHAR );

      RegErr = RegEnumValue( UserListHandle,
			     Index,
			     ValueName,
			     &NameLength,
			     NULL,
			     &Type,
			     (PBYTE) ValueData,
			     &DataLength
			     );
      if ( RegErr == ERROR_SUCCESS ) {

	if ( _wcsicmp( ValueName , L"*" ) == 0 ) {
	  ValueName = L"all users (*)";
	}

        if (_wcsicmp(ValueData,L"*") == 0) {
	  ValueData = L"a local account by the same name (*)";
	}

	FoundAnyMappings = TRUE;

	printf( "Mapping %ws to %ws.\n",
		ValueName,
		ValueData );
      } else {

	if ( RegErr != ERROR_NO_MORE_ITEMS ) {

	  printf( "Registry error 0x%x while enumerating user mappings.  Stopping here.\n",
		  RegErr );

	}

	break;
      }
    }

    if ( !FoundAnyMappings ) {

 NoMappingsWereFound:

      printf( "No user mappings defined.\n" );

    }


Cleanup:

    if (KerbHandle)
    {
        RegCloseKey(KerbHandle);
    }
    if (UserListHandle)
    {
        RegCloseKey(UserListHandle);
    }
    return(STATUS_SUCCESS);

}



NTSTATUS
DumpState(LPWSTR * Parameters)
{
    NTSTATUS Status;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;

    Status = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyDnsDomainInformation,
                (PVOID *) &DnsDomainInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query dns domain info: 0x%x\n",Status);
        goto Cleanup;
    }

    if ( DnsDomainInfo->DnsDomainName.Length == 0 ) {

        printf("Machine is not configured to log on to an external KDC.  Probably a workgroup member\n");

        /* goto Cleanup;
	   101055: Don't do this-- not having joined the domain doesn't
	   preclude us from having KDC entries defined. */

    } else { // nonempty dns domain, but no sid.  Assume we're in an RFC1510 domain.

      printf( "default realm = %wZ ",
		&DnsDomainInfo->DnsDomainName );

      if ( DnsDomainInfo->Sid != NULL ) {

	printf( "(NT Domain)\n" );

      } else {

	printf( "(external)\n" );

      }

    }

    PrintRealmList();
    PrintNameMapping();

Cleanup:
    if (DnsDomainInfo != NULL)
    {
        LsaFreeMemory(DnsDomainInfo);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\domain.cxx ===
/*++

  DOMAIN.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: 

  Created, May 21, 1999 by DavidCHR.

  CONTENTS: GetComputerRoleInformation
            DoItAnyway

--*/  

#include "everything.hxx"

extern "C" {
#include "..\keytab2\keytab\ldlib\delegtools.h"
#include <dsgetdc.h>
#include <lm.h>
}

PLDAP  GlobalLdap          = NULL;
LPWSTR GlobalClientName    = NULL;
LPWSTR GlobalDomainSetting = NULL; /* if NULL, we're not doing anything
                                      in the domain.  if Nonnull, this 
                                      is the DNS domain we want. */


BOOL
ConnectedToDsa( VOID ) {

    BOOL   ret            = ( GlobalLdap != NULL );
    LPWSTR TargetComputer = NULL;
    DWORD  dwErr;
    PLDAP  pLdap;

    if ( !ret ) {

      if ( GlobalDomainSetting ) {
        
        PDOMAIN_CONTROLLER_INFOW pDcInfo;

        dwErr = DsGetDcNameW( NULL, // computername (don't care)
                              GlobalDomainSetting,
                              NULL, // guid (don't care)
                              NULL, // site (don't care)
                              
                              DS_DIRECTORY_SERVICE_REQUIRED |
                              DS_IP_REQUIRED |
                              DS_ONLY_LDAP_NEEDED,

                              &pDcInfo );

        if ( ERROR_SUCCESS == dwErr ) {

          TargetComputer = pDcInfo->DomainControllerName; 

          DEBUGPRINT( DEBUG_DOMAIN,
                      ( "Found Domain Controller: %ws\n",
                        TargetComputer ) );
                      
          /* Sometimes, inexplicably, DsGetDcName returns
             a DC name that starts with "\\\\".  It doesn't
             seem to happen all the time, so I'll workaround. */

          while ( TargetComputer[ 0 ] == L'\\' ) {

            TargetComputer++;

            DEBUGPRINT( DEBUG_DOMAIN,
                        ( "Changed to %ws...\n",
                          TargetComputer ) );

            /* assert that we were not given a DCname that's just
               a bunch of slashes. */

            ASSERT( TargetComputer[ 0 ] != L'\0' );

          }

          /* WASBUG 73940: leaks, but we don't care.  it's an app, so
	     any leaked memory will be short-lived. */

        } else {

          printf( "Failed to locate a DC for %ws: 0x%x.\n",
                  GlobalDomainSetting,
                  dwErr );

          return FALSE;

        }

      }

      pLdap = ldap_openW( TargetComputer,
                          LDAP_PORT );

      if ( pLdap ) {

        dwErr = ldap_bind_s( pLdap,
                             NULL,
                             NULL,
                             LDAP_AUTH_NEGOTIATE );

        if ( LDAP_SUCCESS == dwErr ) {

          GlobalLdap = pLdap;
          ret        = TRUE;

        } else {

          ldap_unbind( pLdap );

          printf( "Ldap bind failed for %ws: 0x%x\n",
                  TargetComputer ? TargetComputer : L"default DC",
                  dwErr );

        }

      } else {

        printf( "Ldap open failed for %ws: 0x%x.\n",
                TargetComputer ? TargetComputer : L"default DC",
                GetLastError() ); 

      }
    }
    
    if ( !ret ) {

      GlobalLdap = NULL;

    }

    return ret;

}

NTSTATUS
AssignUnicodeStringToWideString( IN  PUNICODE_STRING pString,
                                 OUT LPWSTR          *Buffer ) {

    LPWSTR p;

    p = (LPWSTR) malloc( pString->Length + sizeof( WCHAR ) );

    if ( p ) {

      memcpy( p,
              pString->Buffer,
              pString->Length );

      p[ pString->Length / sizeof( WCHAR ) ] = L'\0';
      
      *Buffer = p;

      return STATUS_SUCCESS;

    } else {

      printf( "unable to allocate string copy of %wZ.\n",
              pString );

      return STATUS_NO_MEMORY;

    }

}

/*++**************************************************************
  NAME:      ChooseDomain

  specifies to use either the given domain (if Parameter 0 is
  nonnull) or the caller's domain.

  MODIFIES:  the global UserDomain variable (above)

  TAKES:     Parameters -- ripped from argv

  RETURNS:   a status code indicating success or failure
  LOGGING:   printf on failure
  CREATED:   Apr 23, 1999
  LOCKING:   none
  CALLED BY: main
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

NTSTATUS
ChooseDomain( LPWSTR *Parameters ) {

    NTSTATUS ret = STATUS_UNSUCCESSFUL;
    KERB_QUERY_TKT_CACHE_REQUEST TicketRequest = { 
      KerbRetrieveTicketMessage
    };
    
    PKERB_RETRIEVE_TKT_RESPONSE pTicketResponse;
    ULONG                       cbTicketResponse;
    
    if ( Parameters[ 0 ] ) {

      GlobalDomainSetting = Parameters[ 0 ];
      printf( "Connecting to specified domain %ws...\n",
              GlobalDomainSetting );


    }


    // first, bind to the default DSA for this realm.

    if ( TRUE ) { /* 73944: this was ConnectedToDsa(), but we don't
		     necessarily have to connect to a DSA before
		     calling the package. */

      // now, determine who we are.

      ret = CallAuthPackage( &TicketRequest,
                             sizeof( TicketRequest ),
                             (PVOID *) &pTicketResponse,
                             &cbTicketResponse );
                             
      if ( NT_SUCCESS( ret ) ) {

        /* WASBUG 73946: leaks, but the app doesn't run for more
	   than a second.  "Leaked" memory goes away on exit, so we
	   don't care. */

        if ( !GlobalDomainSetting ) {
          
          /* only set this if we haven't set it ourselves.
             The reason being that the specified domain (above)
             is NOT the same as this one, which came from the cache. */

          AssignUnicodeStringToWideString( 
               &pTicketResponse->Ticket.DomainName,
               &GlobalDomainSetting
               );

        }
        ASSERT( pTicketResponse->Ticket.ClientName->NameCount == 1 );

        AssignUnicodeStringToWideString( 
             &pTicketResponse->Ticket.ClientName->Names[ 0 ],
             &GlobalClientName 
             );

        ret = STATUS_SUCCESS;

      } else {

        printf( "Ticket cache query failed.  Error 0x%x\n",
                ret );

      }

    }

    if ( NT_SUCCESS( ret ) ) {

      ASSERT( GlobalDomainSetting != NULL );
      
      printf( "Using domain %ws.\n",
              GlobalDomainSetting );

    } else {

      printf( "Could not guess user's domain.\n"
              "  Please specify domain on command line and try again.\n" );

    }

    return ret;
}

/*++**************************************************************
  NAME:      GetComputerRoleInformation

  Queries the target server for its role information-- basically,
  we use this to determine whether the machine is a domain
  controller.

  MODIFIES:  pulRoleData

  RETURNS:   a status code indicating success or failure
  LOGGING:   
  CREATED:   Jan 25, 2000
  LOCKING:   
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

NTSTATUS 
GetComputerRoleInformation( PULONG pulRoleData ) {

    NTSTATUS N;
    NET_API_STATUS NetStatus;
    PSERVER_INFO_101 pServerInfo;

    NetStatus = NetServerGetInfo( ServerName, // global.
                                  101,        // level
                                  (LPBYTE *) &pServerInfo );

    if ( NetStatus != STATUS_SUCCESS ) {

      printf( "Cannot determine %ws's Server Role: 0x%x.\n",
              ServerName ? ServerName : L"this computer",
              NetStatus );

      N = STATUS_UNSUCCESSFUL;

    } else {

      N = STATUS_SUCCESS;

      if ( pulRoleData ) *pulRoleData = pServerInfo->sv101_type;

      NetApiBufferFree( pServerInfo );

    }

    return N;

}

/*++**************************************************************
  NAME:      DoItAnyway

  prompts the user-- "Do it anyway?"

  MODIFIES:  nothing

  RETURNS:   TRUE  if the user decided to do it anyway
             FALSE if the user decided to abort.

  CREATED:   Jan 25, 2000
  CALLED BY: anyone (most notably SetDnsDomain)
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
DoItAnyway( VOID ) {

    int Response;

    while ( TRUE ) {

      printf( "Do it anyway [y/n]? " );
      
      Response = '\0';

      do { 

        Response = getchar();

      } while ( isspace( Response ) );

      switch( Response ) {

       case 'Y':
       case 'y':

         return TRUE;
         break;

       case 'N':
       case 'n':

         return FALSE;
         break;

       case EOF:
         
         printf( "EOF at console.  Assuming no.\n" );
         return FALSE;
         break;

       default:

         printf( "[unknown: %02x '%c']\n",
                 Response,
                 Response );
         break;

      }
    }

    // NOTREACHED
}

NTSTATUS
SetDnsDomain( LPWSTR * Parameter)
{
    NTSTATUS               Status;
    POLICY_DNS_DOMAIN_INFO DnsDomainInformation = {0};
    LPSTR                  Description;
    ULONG                  Index, Role;
    BOOL                   PromptTheUser = FALSE;
    LPWSTR                 Arg;

    //
    // If no parameter is passed, prepare to unjoin from all domains/realms.  
    // Print a scary message, but don't give the user a chance to abort.
    //

    if( Parameter[0] == NULL )
    {
	Arg = L"WORKGROUP";
	fprintf( stderr, "No parameter to /SetRealm - unjoining computer from all domains/realms.\n" );
    }
    else
    {
	Arg = Parameter[0];
    }

    if( !CheckUppercase( Arg ) )
    {
	return STATUS_UNSUCCESSFUL;
    }

    /* 453781: don't fiddle with DNS domain information if the
       machine is a Domain Controller -- results in a dead machine. */

    Status = GetComputerRoleInformation( &Role );

    if ( !NT_SUCCESS( Status ) ) {

      Description = "Cannot verify.  If %ws is a domain controller, ";
      PromptTheUser = TRUE;

      goto WarnMe;

    } else if ( Role & ( SV_TYPE_DOMAIN_CTRL |
                         SV_TYPE_DOMAIN_BAKCTRL ) ) {

      Description = "%ws is a domain controller-- ";
      
 WarnMe:

      printf( "*** WARNING! ***\n" );
      
      printf( Description,
              ServerName ? ServerName : L"this computer" );
              
      printf( "resetting its\n"
              "DNS Domain Information may render it unusable.\n" );

      if ( !PromptTheUser ) {

        printf( "This operation is not supported.\n" );

        return EPT_NT_CANT_PERFORM_OP; // cannot perform.

      } else if ( !DoItAnyway() ) {

        return Status;

      }
    }
        
    Status = STATUS_SUCCESS; // by default

    printf("Setting Dns Domain\n");

    //
    // set the netbios name to be the portion before the first '.' and
    // truncate to 14 characters
    //

    RtlInitUnicodeString(
        &DnsDomainInformation.Name,
        Arg
        );

    for (Index = 0; Index < DnsDomainInformation.Name.Length/sizeof(WCHAR) ; Index++ )
    {
        if (DnsDomainInformation.Name.Buffer[Index] == L'.')
        {
            DnsDomainInformation.Name.Length = (USHORT) (Index * sizeof(WCHAR));
            break;
        }
    }
    if (DnsDomainInformation.Name.Length > DNLEN * sizeof(WCHAR))
    {
        DnsDomainInformation.Name.Length = DNLEN * sizeof(WCHAR);
    }

    RtlInitUnicodeString(
        &DnsDomainInformation.DnsDomainName,
        Arg
        );

    Status = LsaSetInformationPolicy(
                LsaHandle,
                PolicyDnsDomainInformation,
                (PVOID) &DnsDomainInformation
                );


    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set dns domain info: 0x%x\n",Status);
        return(Status);
    }

    //
    // Set the value in tcpip
    //

    if (!SetComputerNameEx(
            ComputerNamePhysicalDnsDomain,
            Arg))
    {
        printf("Failed to update host dns domain: %d (0x%x) \n",
	       GetLastError(), GetLastError() );
        return(STATUS_UNSUCCESSFUL);
    }

    return(Status);
}

BOOL CheckUppercase( LPWSTR wszRealmName )
{
    PWCHAR c = wszRealmName;

    while( *c != L'\0' )
    {
	if( iswalpha(*c) && !iswupper(*c) )
	{
	    fprintf( stderr, "Your realm name \"%ws\" has lowercase letters.\nTraditionally, Kerberos Realms are in UPPERCASE. Please verify.\n", wszRealmName );
	    if( DoItAnyway() )
	    {
		return TRUE;
	    }
	    else
	    {
		return FALSE;
	    }
	}
	c++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\main.cxx ===
/*++

  MAIN.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: main() for ksetup

  Created, May 21, 1999 by DavidCHR.

--*/

#define EXTERN // nothing
#include "everything.hxx"

extern
CommandPair Commands[ ANYSIZE_ARRAY ];

extern
ULONG       cCommands;

extern TestFunc DumpState;

extern NTSTATUS
OpenLsa( VOID ); // in support.cxx


BOOL
FindCommand( IN  LPWSTR CommandName,
         OUT PULONG pulCommandId ) {

    ULONG iCommand;

    for (iCommand = 0; iCommand < cCommands ; iCommand++ ) {

      if ( 0 == lstrcmpi( CommandName,
              Commands[iCommand].Name) ) {

    // found the command.

    DEBUGPRINT( DEBUG_OPTIONS,
            ( "Found %ws (command %ld)",
              CommandName,
              iCommand ) );

    *pulCommandId = iCommand;

    return TRUE;

      }
    }

    printf( "%ws: no such argument.\n",
        CommandName );

    return FALSE;
}

BOOL
StoreArguments( IN     ULONG   iArg,
        IN     LPWSTR *argv,
        OUT    PULONG  piArg,
        IN OUT PAction pAction ) {


    ULONG        iCommand    = pAction->CommandNumber;
    PCommandPair pCommand    = Commands + iCommand;
    ULONG        iParam      = 0;
    BOOL         ret         = TRUE;
    BOOL         KeepParsing = FALSE;

    DEBUGPRINT( DEBUG_OPTIONS, ( "Building %ld-arg array.\n",
                 Commands[ iCommand ].Parameter ) );

    if ( pCommand->Parameter != 0 ) {

      /* this command has required parameters.
     Copy them as we go. */

      for ( iParam = 0;
        ret && argv[ iArg ] && ( iParam < MAX_COMMANDS -1 );
        iArg++, iParam ++ ) {

    ASSERT( argv[ iArg ] != NULL );

    DEBUGPRINT( DEBUG_OPTIONS,
            ( "Evaluating iParam=%ld, iArg=%ld, \"%ws\"\n",
              iParam,
              iArg,
              argv[ iArg ] ) );

    if ( argv[ iArg ][ 0 ] == L'/' ) {

      // this parameter is a switch.  We're done.

      break;

    }

    // if we don't need any more arguments, don't consume this one.

    if ( ( iParam > pCommand->Parameter ) &&
         !( pCommand->flags & CAN_HAVE_MORE_ARGUMENTS ) ) {

      printf( "%ws only takes %ld arguments.\n",
          pCommand->Name,
          pCommand->Parameter );

      ret = FALSE;
      break;

    }

    // at this point, the options are consumable.

    pAction->Parameter[ iParam ] = argv[ iArg ];

    DEBUGPRINT( DEBUG_OPTIONS,
            ( "%ws's arg %ld is %ws\n",
              pCommand->Name,
              iParam,
              pAction->Parameter[ iParam ] ) );

      } // for loop

      if ( ret ) {

    // left the loop without error

    if ( ( iParam < pCommand->Parameter ) &&
         !( pCommand->flags &
        CAN_HAVE_FEWER_ARGUMENTS ) ) {

      // too few options.

      printf( "%ws requires %ld options (only %ld supplied).\n",
          pCommand->Name,
          pCommand->Parameter,
          iParam );

      ret = FALSE;

    }

      }
    } // parameter count check.

    if ( ret ) {
      pAction->Parameter[ iParam ] = NULL; /* null-terminate
                          in all success cases. */
      *piArg = iArg;

#if DBG
      DEBUGPRINT( DEBUG_OPTIONS,
          ( "Leaving StoreOptions-- %ws with iArg=%ld.  %ld args:\n",
            pCommand->Name,
            iArg,
            iParam ));

      for ( iParam = 0;
        pAction->Parameter[ iParam ] != NULL ;
        iParam++ ) {

    DEBUGPRINT( DEBUG_OPTIONS,
            ( "arg %ld: %ws\n",
              iParam,
              pAction->Parameter[ iParam ] ) );

      }
#endif
    }

    return ret;

}

VOID
PrintUsage(
    IN ULONG iCommand
    );

/*++**************************************************************
  NAME:      main()

  main() function, the primary entry point into the program.
  When this function exits, the program exits.

  TAKES:     argc : count of string entries in argv
             argv : array of space-delimited strings on the command line
  RETURNS:   the exit code (or errorlevel) for the process
  CALLED BY: the system
  FREE WITH: n/a

 **************************************************************--*/

extern "C"
int __cdecl
wmain(ULONG  argc,
      LPWSTR argv[]) {

    ULONG    Command = 0;
    ULONG    iAction, iArg, iCommand, iParam ;
    BOOLEAN  Found;
    NTSTATUS Status;
    PAction  Actions;
    ULONG    ActionCount = 0;
    BOOL     StuffToDo = FALSE; // used only for debugging

    // GlobalDebugFlags = 0xFF;

    // lazy way to do this.

    Actions = (PAction) malloc( argc * sizeof( *Actions ) );

    if ( !Actions ) {

        printf( "Failed to allocate array.\n" );
        return -1;
    }

    ZeroMemory( Actions, argc * sizeof( *Actions ));

    for ( iArg = 1; iArg < argc; /* iArg++ */ ) {
        Found = FALSE;

        DEBUGPRINT( DEBUG_OPTIONS,
                ( "Searching for iArg=%ld, %ws..\n",
                  iArg,
                  argv[ iArg ] ) );

        // first, find the command.

        if ( FindCommand( argv[ iArg ],
                  &iCommand ) ) {

            iArg++;

            Actions[ActionCount].CommandNumber = iCommand;

            if ( StoreArguments( iArg, // starting here
                    argv,
                    &iArg,  // moves past last arg
                    &Actions[ ActionCount ] ) ) {

                if ( Commands[iCommand].flags & DO_COMMAND_IMMEDIATELY ) {

                    DEBUGPRINT( DEBUG_LAUNCH,
                      ( "Doing %ws immediately:\n",
                        Commands[ iCommand ].Name ) );

                    Status = Commands[iCommand].Function(
                    Actions[ActionCount].Parameter );

                    DEBUGPRINT( DEBUG_OPTIONS,
                      ( "%ws returned 0x%x\n",
                        Commands[ iCommand ].Name,
                        Status ) );

                    if ( NT_SUCCESS( Status ) ) {
                        if ( Commands[ iCommand ].ConfirmationText ) {

                          printf( "NOTE: %ws %hs\n",
                              Commands[ iCommand ].Name,
                              Commands[ iCommand ].ConfirmationText );
                        }
                    } else  {
                        if ( Status == STATUS_INVALID_PARAMETER ) {
                            PrintUsage( iCommand );
                        } else {
                            printf( "%ws failed: 0x%x.\n",
                                Commands[ iCommand ].Name,
                                Status);
                        }
                        goto Cleanup;
                    }
                } else {

                    // need to do this command later.

                    StuffToDo = TRUE;
                    ActionCount++;
                }
            } else { // StoreArgs

                printf( "use %ws /? for help.\n",
                    argv[ 0 ] );
                return -1;
            }
        } else {
            printf( "use %ws /? for help.\n",
              argv[ 0 ] );

            return -1;
        }
    } // argument loop.

    Status = OpenLsa();
    if (!NT_SUCCESS(Status)) {
        printf("Failed to open lsa: 0x%x\n",Status);
        goto Cleanup;
    }

    if ( StuffToDo ) {

        DEBUGPRINT( DEBUG_OPTIONS,
          ( "------------------ %hs -------------------\n",
            "performing delayed actions now" ) );
    }

    for (iAction = 0; iAction < ActionCount ; iAction++ ) {
        if (!( Commands[Actions[iAction].CommandNumber].flags &
            DO_COMMAND_IMMEDIATELY )) {

            DEBUGPRINT( DEBUG_LAUNCH,
                    ( "Doing %ws:\n",
                      Commands[ Actions[ iAction ].CommandNumber ].Name ) );

            Status = Commands[Actions[iAction].CommandNumber].Function(
               Actions[iAction].Parameter);

            DEBUGPRINT( DEBUG_OPTIONS,
                    ( "%ws: 0x%x\n",
                      Commands[ Actions[ iAction ].CommandNumber ].Name,
                      Status ) );

            if (!NT_SUCCESS(Status)) {

                if (Status == STATUS_INVALID_PARAMETER) {
                    PrintUsage( Actions[ iAction ].CommandNumber );
                } else {
                    printf("Failed %ws : 0x%x\n",
                        Commands[ Actions[ iAction ].CommandNumber ].Name,
                        Status);
                }
                goto Cleanup;
            } else {

                if ( Commands[ Actions[ iAction ].CommandNumber ].ConfirmationText ) {

                    printf( "NOTE: %ws %hs\n",
                        Commands[ Actions[ iAction ].CommandNumber ].Name,
                        Commands[ Actions[ iAction ].CommandNumber ].ConfirmationText );
                }
            }
        }
    }

    if (ActionCount == 0) {
        DumpState(NULL);
    }

Cleanup:
    if (LsaHandle != NULL) {
        Status = LsaClose(LsaHandle);
        if (!NT_SUCCESS(Status)) {
            printf("Failed to close handle: 0x%x\n",Status);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\mapuser.cxx ===
/*++

  MAPUSER.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: code for MapUser()

  Created, May 21, 1999 by DavidCHR.

--*/

#include "everything.hxx"

extern "C" {
#include <malloc.h> // alloca
#include "..\keytab2\keytab\ldlib\delegtools.h"
}

static CHAR AltSecId[]     = "AltSecurityIdentities";
static CHAR AltSecPrefix[] = "KERBEROS:";
static CHAR PreQuery[]     = "(objectClass=user)"; /* For performance
                              reasons, we should
                              query an indexed type */

NTSTATUS
MapUserInDirectory( IN          LPWSTR Principal,
            IN OPTIONAL LPWSTR Account ) {

    LPSTR     Attributes[]  = { NULL }; // request no attributes
    PCHAR     PrincValues[] = { NULL, NULL };
    LDAPModA  TheMod        = { LDAP_MOD_DELETE,
                   AltSecId,
                   PrincValues };
    PLDAPModA Mods[]        = { &TheMod, NULL };
    CHAR      SearchBuffer  [ UNLEN + 100 ]; /* The most we could have to
                        search for is UNLEN (for either
                        the principalname or the
                        accountname) + 100 for the
                        semantics of the query */
    NTSTATUS  ret           = STATUS_INTERNAL_ERROR;
    LPSTR     ObjectDn;
    ULONG     lderr;

    if ( ( lstrcmpW( Principal, L"*" ) == 0 ) ||
     ( Account && ( lstrcmpW( Account, L"*" ) == 0 ) ) ) {

      printf( "Wildcard account mappings are not supported"
          " at the domain level.\n" );

      return STATUS_NOT_SUPPORTED;

    }

    if ( ConnectedToDsa() ) {

      if ( Account ) { // changing the attribute -- search for the account

        wsprintfA( SearchBuffer,
             "(& %hs (samAccountName=%ws))",
             PreQuery,
             Account );

      } else {         // deleting the attribute -- search for the attr

        wsprintfA( SearchBuffer,
             "(& %hs (%hs=%hs%ws))",
             PreQuery,
             AltSecId,
             AltSecPrefix,
             Principal );

      }

      if ( LdapSearchForUniqueDnA( GlobalLdap,
                   SearchBuffer,
                   Attributes,
                   &ObjectDn,
                   NULL ) ) {

        PrincValues[ 0 ] = (PCHAR)malloc( lstrlenW( Principal ) + 30 );
        if ( !PrincValues[ 0 ] ) {

          return STATUS_NO_MEMORY; /* NOTE: 73954: This leaks, but the
                      app terminates immediately afterwards,
                      so we don't actually care. */

        }

        wsprintfA( PrincValues[ 0 ],
             "%hs%ws",
             AltSecPrefix,
             Principal );


        if ( Account ) {

          TheMod.mod_op = LDAP_MOD_ADD;

        } else {

          TheMod.mod_op = LDAP_MOD_DELETE;

        }

        lderr = ldap_modify_sA( GlobalLdap,
                  ObjectDn,
                  Mods );

        // special-case output here:

        switch( lderr ) {

        case LDAP_SUCCESS:

          printf( "Mapping %hs successfully.\n",
             Account ? "created" : "deleted" );

          ret = STATUS_SUCCESS;
          break;

        default:

          printf( "Failed to %hs %hs on %hs; error 0x%x.\n",
              Account ? "set" : "delete",
              AltSecId,
              ObjectDn,
              lderr );

          ret = STATUS_UNSUCCESSFUL;

          break;

        }

        free( ObjectDn );
        free( PrincValues[0] );

      } else {

        printf( "Could not locate the account mapping in the directory.\n" );

      }

    }

    return ret;
}


NTSTATUS
MapUserInRegistry( IN          LPWSTR Principal,
           IN OPTIONAL LPWSTR Account ) {

    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY UserListHandle = NULL;
    DWORD Disposition;

    RegErr = OpenKerberosKey(&KerbHandle);
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = RegCreateKeyEx(
                KerbHandle,
                L"UserList",
                0,
                NULL,
                0,              // no options
                KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                NULL,
                &UserListHandle,
                &Disposition
                );
    if (RegErr)
    {
        printf("Failed to create UserList key: %d\n",RegErr);
        goto Cleanup;
    }

    if ( Account && Account[0] ) {

      RegErr = RegSetValueEx( UserListHandle,
                  Principal,
                  0,
                  REG_SZ,
                  (PBYTE) Account,
                  (wcslen(Account) + 1) * sizeof(WCHAR)
                  );

      if (RegErr)
    {
      printf("Failed to set name mapping  value: %d\n",RegErr);
      goto Cleanup;
    }

    } else {

      /* if no second parameter was supplied,
     delete the mapping. */

      RegErr = RegDeleteValue( UserListHandle,
                   Principal );

      switch( RegErr ) {

       case ERROR_PATH_NOT_FOUND:
       case ERROR_FILE_NOT_FOUND:

     RegErr = ERROR_SUCCESS;
     // fallthrough to success case

       case ERROR_SUCCESS:
     break;

       default:

     printf( "Failed to delete mapping for %ws: error 0x%x.\n",
         Principal,
         RegErr );

     goto Cleanup;

      }
    }

Cleanup:
    if (KerbHandle)
    {
        RegCloseKey(KerbHandle);
    }
    if (UserListHandle)
    {
        RegCloseKey(UserListHandle);
    }
    if (RegErr)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
MapUser( IN LPWSTR * Parameters ) {

    //
    // Mapuser needs at least one none-empty argument
    //

    if (!Parameters[ 0 ] || !*Parameters[ 0 ])
    {
        return STATUS_INVALID_PARAMETER;
    }

    return ( GlobalDomainSetting ?
         MapUserInDirectory :
         MapUserInRegistry )( Parameters[ 0 ],
                  Parameters[ 1 ] );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\realmflags.cxx ===
/*++

  REALMFLAGS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: realm-flag manipulation code.

  Created, Jan 10, 2000 by DavidCHR.

  CONTENTS: CompareFlagIds
            VerboselyPrintAndRemoveFlagsById
            LookupRealmFlagByName
            PrintAndRemoveFlagNames
            SearchRealmFlagListByAttribute
            CompareFlagNames

--*/  


#include "everything.hxx"

typedef struct {

  ULONG  Id;          // from kerberos\client2\mitutil.h
  LPWSTR Name;        // short string identifier
  LPSTR  Explanation; // what this flag does.
  LPSTR  MoreExplanation; // if you have to run to the next line.

} KERB_REALM_FLAG_MAPPING, *PKERB_REALM_FLAG_MAPPING;

/* These flags are defined in kerberos\client2\mitutil.h.
   However, there's other gunk in there that I'd rather not
   copy out so I'll just duplicate them.

   I'd consider auto-generating code fragments from the file
   to keep this file instantly up-to-date, but it wouldn't
   be guaranteed to provide human readable information */

KERB_REALM_FLAG_MAPPING
KerbRealmFlagMappings[] = {

  /* The order of "none" in the list is important.  It must be
     before any of the other flags so that code that handles
     multiple flags as a mask will not hit this unless the 
     whole mask is zero. */

  { 0x0,
    L"None",
    "No Realm Flags"
  },

  { 0x1, 
    L"SendAddress",
    "Include IP numbers within tickets.",
    "Useful for solving SOME compatibility issues."
  },

  { 0x2,
    L"TcpSupported",
    "Indicates that this realm supports TCP.",
    "(as opposed to just UDP)" },

  { 0x4,
    L"Delegate",
    "Everyone in this realm is trusted for delegation" },

  { 0x8,
    L"NcSupported",
    "This realm supports Name Canonicalization" },

};

ULONG
RealmFlagCount = ( sizeof( KerbRealmFlagMappings ) / 
                   sizeof( KerbRealmFlagMappings[ 0 ] ) );


/* NOTES on REALMLISTCOMPAREFUNCTION:

   If your REALMLISTCOMPAREFUNCTION is designed to return multiple
   mappings or interpret multiple mappings (e.g. as a mask), then
   you must special case "None" in the array above.  Otherwise,
   your output may include "none", which doesn't make any sense. */

typedef BOOL REALMLISTCOMPAREFUNCTION( IN PVOID, // pvAttribute
                                       IN PKERB_REALM_FLAG_MAPPING );


/*++**************************************************************
  NAME:      CompareFlagIds

  compares a flag map to a flag id.  
  pvAttribute is a pointer to the desired flag id.

  RETURNS:   TRUE  if this is the correct flagid
             FALSE otherwise.
  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL // REALMLISTCOMPAREFUNCTION
CompareFlagIds( IN PVOID                    pvAttribute,
                IN PKERB_REALM_FLAG_MAPPING pMap ) {

    return ( pMap->Id == *(( PULONG ) pvAttribute) );

}


/*++**************************************************************
  NAME:      CompareFlagNames

  Compares a mapping to a string for the flagname.

  RETURNS:   TRUE  if this mapping corresponds to the given string
             FALSE otherwise.
  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL // REALMLISTCOMPAREFUNCTION
CompareFlagNames( IN PVOID                    pvAttribute,
                  IN PKERB_REALM_FLAG_MAPPING pMap ) {

    return ( 0 == _wcsicmp( (LPWSTR) pvAttribute,
                            pMap->Name ) );
}

/*++**************************************************************
  NAME:      PrintAndRemoveFlagsById

  if the flag id matches, it is removed from the passed-in value,
  and the flagname is printed.

  MODIFIES:  pvAttribute -- may be stripped of a bit

  TAKES:     pvAttribute -- flagId to check
             pMap        -- table entry to check against

  RETURNS:   TRUE  if pvAttribute is zero (stop searching)
             FALSE otherwise (keep searching)

  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
PrintAndRemoveFlagsById( IN PVOID pvAttribute,
                         IN PKERB_REALM_FLAG_MAPPING pMap ) {

    if ( !pMap->Id ) {

      /* We special-case "none" so that we only print it
	 if there are no other flags-- if other flags exist,
	 "none" will be skipped over in the array */

      if ( !*(( PULONG ) pvAttribute ) ) {
	printf( " %ws",
		pMap->Name );

	return TRUE;
      } else {
	return FALSE;
      }
    }

    if ( ( *(( PULONG ) pvAttribute) & pMap->Id )
         == pMap->Id ) {

      *( (PULONG) pvAttribute ) &= ~pMap->Id;
      printf( " %ws",
              pMap->Name );

    }

    return *( (PULONG) pvAttribute ) == 0;

}

/*++**************************************************************
  NAME:      VerboselyPrintAndRemoveFlagsById

  like PrintAndRemoveFlagsById, but it also dumps the
  flag id and explanation field.

  LOGGING:   lots of it.
  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
VerboselyPrintAndRemoveFlagsById( IN PVOID pvAttribute,
                                  IN PKERB_REALM_FLAG_MAPPING pMap ) {

#if 0
    if ( !pMap->Id ) {

      /* We special-case "none" so that we only print it
	 if there are no other flags-- if other flags exist,
	 "none" will be skipped over in the array */

      if ( !*(( PULONG ) pvAttribute ) ) {
	printf( "0x%02x %ws   \t%hs\n",
		pMap->Id,
		pMap->Name,
		pMap->Explanation );
	
	return TRUE;
      } else {
	return FALSE;
      }
    }
#endif

    if ( ( *(( PULONG ) pvAttribute) & pMap->Id )
         == pMap->Id ) {

      *( (PULONG) pvAttribute ) &= ~pMap->Id;
      printf( "0x%02x %-12ws %hs\n",
              pMap->Id,
              pMap->Name,
              pMap->Explanation );

      if ( pMap->MoreExplanation ) {

	printf( "%-17hs %hs\n",
		"",
		pMap->MoreExplanation );
      }

    }

    return *( (PULONG) pvAttribute ) == 0;

}
      

/*++**************************************************************
  NAME:      SearchRealmFlagListByAttribute

  searches the realmlist for a particular attribute.

  MODIFIES:  ppMapping -- receives the given mapping.

  TAKES:     pvAttribute -- attribute value to search for
             pFunc       -- function to use to find it

  RETURNS:   TRUE  if the value could be found
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   none
  CREATED:   Jan 10, 2000
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL
SearchRealmFlagListByAttribute( IN  PVOID                     pvAttribute,
                                IN  REALMLISTCOMPAREFUNCTION *pFunc,
                                OUT PKERB_REALM_FLAG_MAPPING *ppMapping ) {

    ULONG i;
    PKERB_REALM_FLAG_MAPPING pMapping = &KerbRealmFlagMappings[ 0 ];

    for ( i = 0 ; 
          i < RealmFlagCount ;
          i ++, pMapping++ ) {

      if ( pFunc( pvAttribute,
                  pMapping ) ) {

        if ( ppMapping ) *ppMapping = pMapping;
        return TRUE;

      }
    }

    return FALSE;

}


/*++**************************************************************
  NAME:      LookupRealmFlagByName

  given a name, maps it to a realm flag mapping structure

  MODIFIES:  ppMapping     -- receives the entry pointer
  TAKES:     RealmFlagName -- name for which to search

  RETURNS:   TRUE  if the realmflag could be found.
             FALSE otherwise.
  LASTERROR: 

  LOGGING:   
  CREATED:   Jan 10, 2000
  LOCKING:   
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
LookupRealmFlagByName( IN  LPWSTR RealmFlagName,
                       OUT PKERB_REALM_FLAG_MAPPING *ppMapping ) {

    return SearchRealmFlagListByAttribute( RealmFlagName,
                                           CompareFlagNames,
                                           ppMapping );

}

VOID
PrintRealmFlags( IN ULONG RealmFlags ) {

    ULONG i;
    ULONG ioFlags = RealmFlags;

    if ( RealmFlags == 0 ) {

      printf( " none" );

    } else {

      if ( !SearchRealmFlagListByAttribute( &ioFlags,
                                            PrintAndRemoveFlagsById,
                                            NULL ) ) {
        printf( " [unknown" );

        if ( ioFlags != RealmFlags ) {

          printf( ": 0x%x",
                  ioFlags );

        }

        printf( "]" );

      }

    }
}
    
    
      

NTSTATUS
ListRealmFlags( LPWSTR * Ignored) {

    ULONG RealmFlags = ~0;

    printf( "\n"
            "Ksetup knows the following realm flags: \n" );
    
    SearchRealmFlagListByAttribute( &RealmFlags,
                                    VerboselyPrintAndRemoveFlagsById,
                                    NULL );
    printf( "\n" );

    exit( 0 ); /* Jump out. */

    return STATUS_SUCCESS;

}

NTSTATUS
GetRealmFlags( IN  LPWSTR RealmName,
               OUT PULONG pulRealmFlags ) {

    HKEY  hKey;
    NTSTATUS N = STATUS_UNSUCCESSFUL;
    DWORD dwErr, Type, Len = sizeof( *pulRealmFlags );

    dwErr = OpenSubKey( &RealmName,
                        &hKey );

    if ( dwErr == ERROR_SUCCESS ) {

      dwErr = RegQueryValueEx( hKey,
                               KERB_DOMAIN_REALM_FLAGS_VALUE,
                               NULL, // mbz
                               &Type,
                               (LPBYTE) pulRealmFlags,
                               &Len );

      switch ( dwErr ) {

       case ERROR_SUCCESS:
         
         N = STATUS_SUCCESS;
         break;

       case ERROR_FILE_NOT_FOUND:
       case ERROR_PATH_NOT_FOUND:

         /*  453545: if the realm flags aren't specified,
             don't complain about it. */

         N = STATUS_SUCCESS;
         *pulRealmFlags = 0;
         break;

       default:
         
         printf( "Failed to query %ws for %ws: 0x%x\n",
                 KERB_DOMAIN_REALM_FLAGS_VALUE,
                 RealmName,
         dwErr );
      }

      RegCloseKey( hKey );

    } // else error has already been printed.

    return N;
}

NTSTATUS
SetRealmFlags( IN LPWSTR RealmName,
               IN ULONG  ulRealmFlags ) {

    HKEY  hKey;
    NTSTATUS N = STATUS_UNSUCCESSFUL;
    DWORD dwErr, Len = sizeof( ulRealmFlags );

    dwErr = OpenSubKey( &RealmName,
                        &hKey );

    if ( dwErr == ERROR_SUCCESS ) {

      dwErr = RegSetValueEx( hKey,
                             KERB_DOMAIN_REALM_FLAGS_VALUE,
                             NULL, // mbz
                             REG_DWORD,
                             (LPBYTE) &ulRealmFlags,
                             Len );
      
      switch ( dwErr ) {

       case ERROR_SUCCESS:

         DEBUGPRINT( DEBUG_REGISTRY,
                     ( "Set Realm Flags for %ws to 0x%x\n",
                       RealmName,
                       ulRealmFlags ) ) ;
         
         N = STATUS_SUCCESS;
         break;

       default:
         
         printf( "Failed to write %ws for %ws: 0x%x\n",
                 KERB_DOMAIN_REALM_FLAGS_VALUE,
                 RealmName,
         dwErr );
      }

      RegCloseKey( hKey );

    } // else error has already been printed.

    return N;
}



NTSTATUS
ResolveRealmFlags( IN     LPWSTR *Params,
                   IN OUT PULONG pulFlags ) {

    ULONG                    id;
    LPWSTR                   Cursor, *pFlagCursor = Params;
    PKERB_REALM_FLAG_MAPPING pMap;
    NTSTATUS                 N = STATUS_SUCCESS;

    do {

      DEBUGPRINT( DEBUG_OPTIONS,
                  ( "Checking realmflag \"%ws\"...\n",
                    *pFlagCursor ) );

      // first, try to convert to hex.  

      id = wcstoul( *pFlagCursor,
                    &Cursor,
                    0 ); // use defaults

      if ( *Cursor != '\0' ) {

        if ( !LookupRealmFlagByName( *pFlagCursor,
                                     &pMap ) ) {

          printf( "Unknown Realm Flag: \"%ws\"\n",
                  *pFlagCursor );

          N = STATUS_INVALID_PARAMETER;
          break;

        } else {

          id = pMap->Id;

        }

      } // otherwise, the work's already been done.

      pFlagCursor++;
      *pulFlags |= id;

    } while( *pFlagCursor != NULL );

    return N;

}

NTSTATUS
SetRealmFlags( IN LPWSTR *Params ) {

    LPWSTR   RealmName  = Params[ 0 ];
    ULONG    RealmFlags = 0;
    NTSTATUS N          = STATUS_SUCCESS; // 279621: this was uninitialized.

    if( Params[1] != NULL )
    {
	N = ResolveRealmFlags( Params+1,
			       &RealmFlags );

	if ( NT_SUCCESS( N ) ) 
	{
	    N = SetRealmFlags( RealmName,
			       RealmFlags );
	}
    }
    else // Clear all realm flags
    {
	SetRealmFlags( RealmName, 0 );
    }
    
    return N;

}

NTSTATUS
AddRealmFlags( IN LPWSTR *Params ) {

    LPWSTR   RealmName  = Params[ 0 ];
    ULONG    RealmFlags = 0;
    NTSTATUS N;

    N = GetRealmFlags( RealmName,
                       &RealmFlags );

    if ( NT_SUCCESS( N ) ) {
      N = ResolveRealmFlags( Params+1,
                             &RealmFlags );

      if ( NT_SUCCESS( N ) ) {
        
        N = SetRealmFlags( RealmName,
                           RealmFlags );

      }
    }

    return N;

}

    

NTSTATUS
DelRealmFlags( IN LPWSTR *Params ) {

    LPWSTR   RealmName  = Params[ 0 ];
    ULONG    RealmFlags = 0;
    ULONG    DeleteFlags = 0;
    NTSTATUS N;

    N = GetRealmFlags( RealmName,
                       &RealmFlags );
    
    if ( NT_SUCCESS( N ) ) {
      N = ResolveRealmFlags( Params+1,
                             &DeleteFlags );

      if ( NT_SUCCESS( N ) ) {
        
        N = SetRealmFlags( RealmName,
                           RealmFlags &~ DeleteFlags );

      }
    }

    return N;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\servers.cxx ===
/*++

  SERVERS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: adding/removing servers

  Created, May 21, 1999 by DavidCHR.

--*/ 

#include "everything.hxx"

NTSTATUS
RemoveDomainName( IN LPWSTR *pRealmToRemove ) {

    LPWSTR   TargetRealm = *pRealmToRemove;
    DWORD    dwErr;
    HKEY     hDomainsKey;
    NTSTATUS N = STATUS_UNSUCCESSFUL;

    dwErr = OpenSubKey( NULL,
                        &hDomainsKey );
    
    if ( ERROR_SUCCESS == dwErr ) {

      dwErr = RegDeleteKeyW( hDomainsKey,
                             TargetRealm );

      switch( dwErr ) {

       case ERROR_SUCCESS:

         N = STATUS_SUCCESS;
         break;

       case ERROR_FILE_NOT_FOUND:
       case ERROR_PATH_NOT_FOUND:

         printf( "No realm mappings found for %ws.\n",
                 TargetRealm );
         break;

       default:

         printf( "Failed to delete registry mapping for %ws.  Error 0x%x.\n",
                 TargetRealm,
                 dwErr );

      }

      RegCloseKey( hDomainsKey );

    } // else an error was already logged.

    return N;

}

NTSTATUS 
RemoveServerName( IN  LPWSTR *Parameters,
                  IN  LPWSTR KeyName,
                  OUT PBOOL  pbDeletedLastEntry OPTIONAL ) {

    DWORD RegErr;
    HKEY DomainHandle = NULL;
    DWORD Disposition;
    LPWSTR OldServerNames = NULL;
    LPWSTR NewServerNames = NULL;
    ULONG TotalKdcLength, OldKdcLength = 0;
    ULONG NewKdcLength = 0;
    ULONG Type, Length;
    BOOL  PrintedNewServers = FALSE;
    CMULTISTRING StringClass;

    RegErr = OpenSubKey( Parameters,
                         &DomainHandle );
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = STATUS_UNSUCCESSFUL;

    if ( StringClass.ReadFromRegistry( DomainHandle,
                                       KeyName ) ) {

      if ( StringClass.RemoveString( Parameters[ 1 ] ) ) {

        if ( StringClass.WriteToRegistry( DomainHandle,
                                          KeyName ) ) {
          
          RegErr = ERROR_SUCCESS;
          if ( pbDeletedLastEntry ) {
            *pbDeletedLastEntry = ( StringClass.cEntries == 0 );
          }
        }
      }

    }

Cleanup:
    if (NewServerNames)
    {
        LocalFree(NewServerNames);
    }
    if (OldServerNames)
    {
        LocalFree(OldServerNames);
    }
    if (DomainHandle)
    {
        RegCloseKey(DomainHandle);
    }

    if (RegErr)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);

}



NTSTATUS
AddServerName(IN LPWSTR * Parameters, 
              IN LPWSTR   KeyName
              )
{
    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY DomainHandle = NULL;
    HKEY DomainRoot = NULL;
    DWORD Disposition;
    LPWSTR OldServerNames = NULL;
    LPWSTR NewServerNames = NULL;
    ULONG OldKdcLength = 0;
    ULONG NewKdcLength = 0;
    ULONG Type;
    CMULTISTRING StringClass;

    RegErr = OpenSubKey( Parameters,
                         &DomainHandle );
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = STATUS_UNSUCCESSFUL;

    if ( StringClass.ReadFromRegistry( DomainHandle,
                                       KeyName ) ) {

      StringClass.AddString( Parameters[ 1 ] );
      
      if ( StringClass.WriteToRegistry( DomainHandle,
                                        KeyName ) ) {
        
        RegErr = ERROR_SUCCESS;

      }

    }

Cleanup:
    if (NewServerNames)
    {
        LocalFree(NewServerNames);
    }
    if (OldServerNames)
    {
        LocalFree(OldServerNames);
    }
    if (DomainHandle)
    {
        RegCloseKey(DomainHandle);
    }
    if (DomainRoot)
    {
        RegCloseKey(DomainRoot);
    }
    if (KerbHandle)
    {
        RegCloseKey(KerbHandle);
    }
    if (RegErr)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);

}

NTSTATUS
AddKdcName(
    LPWSTR * Parameters
    )
{
    if( !CheckUppercase( Parameters[0] ) )
    {
	return STATUS_UNSUCCESSFUL;
    }    
    
    if( Parameters[1] == NULL )
    {
	HKEY DomainHandle = NULL;
	NTSTATUS Status;
	
	Status = OpenSubKey( Parameters, &DomainHandle );
	if( DomainHandle )
	{
	    RegCloseKey( DomainHandle );
	}
	return Status;
    }
    else
    {
	return(AddServerName(Parameters, KERB_DOMAIN_KDC_NAMES_VALUE));
    }
}

NTSTATUS
DeleteKdcName( IN LPWSTR * Parameters ) {

    NTSTATUS                N;
    BOOL                    bLastOne, bRemoveFromDomain;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    UNICODE_STRING          tempDomain;
    
    if( Parameters[1] == NULL )
    {
	return( RemoveDomainName( Parameters ) );
    }

    N = RemoveServerName( Parameters, 
                          KERB_DOMAIN_KDC_NAMES_VALUE,
                          &bLastOne );

    if ( NT_SUCCESS( N ) && bLastOne ) {

      fprintf( stderr,
               "NOTE: no kdc's are currently defined for the %ws realm.\n",
               Parameters[ 0 ] );

      /* we removed the last KDC; check to see if we're directly "joined"
         to this domain. */

      N = LsaQueryInformationPolicy( LsaHandle,
                                     PolicyDnsDomainInformation,
                                     (PVOID *) &DnsDomainInfo
                                     );

      if ( NT_SUCCESS( N ) ) {

        RtlInitUnicodeString( &tempDomain,
                              Parameters[ 0 ] );

        if ( RtlCompareUnicodeString( &tempDomain,
                                      &DnsDomainInfo->DnsDomainName,
                                      TRUE )  // case insensitive
             == 0 ) {

          if ( DnsDomainInfo->Sid != NULL ) {

            fprintf( stderr,
                     "NOTE: %wZ is an NT domain.\n"
                     "  If you want to leave the domain, use the SYSTEM Control Panel applet.\n",
                     &DnsDomainInfo->DnsDomainName );

          } else {

            // this was our primary domain.  Unjoin from it.

          }

        } // else, this was not our primary domain.  Do nothing further.


        LsaFreeMemory( DnsDomainInfo );

      } else {

        fprintf( stderr,
                 "Unable to determine domain membership (error 0x%x).\n",
                 N );

      }

    }

    return N;

}

NTSTATUS
AddKpasswdName(
    LPWSTR * Parameters
    )
{
    return(AddServerName(Parameters, KERB_DOMAIN_KPASSWD_NAMES_VALUE));
}

NTSTATUS
DelKpasswdName( IN LPWSTR * Parameters ) {

    return RemoveServerName( Parameters,
                             KERB_DOMAIN_KPASSWD_NAMES_VALUE,
                             NULL );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\misccmds.cxx ===
/*++

  MISCCMDS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: miscellaneous command callbacks and the command vector

  Created, May 21, 1999 by DavidCHR.

--*/

#include "Everything.hxx"

/* these are the callback functions invoked by the option parser.
   We declare them here so that they can be called from the array
   below */

TestFunc
  SetDnsDomain,       // domain.cxx
  AddKdcName,         // servers.cxx
  AddKpasswdName,     // servers.cxx
  MapUser,            // mapuser.cxx
  SetMachinePassword, // below in this file
  DumpState,          // dmpstate.cxx
  ChooseDomain  ,     // domain.cxx
  DeleteKdcName,      // servers.cxx
  DelKpasswdName,     // servers.cxx
  ChangeViaKpasswd,   // support.cxx
  SetRealmFlags,      // realmflags.cxx
  AddRealmFlags,      // realmflags.cxx
  DelRealmFlags,      // realmflags.cxx
  ListRealmFlags,     // realmflags.cxx
  RemoveDomainName,   // servers.cxx
  PrintHelp;          // below in this file



NTSTATUS
SetMachinePassword( LPWSTR * Parameter)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING MachinePassword;
    UNICODE_STRING KeyName;
    LPWSTR         Password;

    if ( !ReadOptionallyStarredPassword( Parameter[ 0 ],
                                         PROMPT_FOR_PASSWORD_TWICE,
                                         L"new computer",
                                         &Password ) ) {

      return STATUS_UNSUCCESSFUL;

    }

    printf("Setting computer password\n");

    RtlInitUnicodeString(
        &MachinePassword,
        Password
        );

    RtlInitUnicodeString(
        &KeyName,
        L"$MACHINE.ACC"
        );

    Status = LsaStorePrivateData(
                LsaHandle,
                &KeyName,
                &MachinePassword
                );


    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set machine password: 0x%x\n",Status);
    }

    free( Password );


    return(Status);
}


NTSTATUS
SetServer(LPWSTR * Parameter)
{
    printf("Targeting server %ws\n",Parameter[0]);
    wcscpy(ServerBuffer,Parameter[0]);
    ServerName = ServerBuffer;
    return(STATUS_SUCCESS);
}

#if DBG /* This function and its corresponding variable
           are only useful on debug builds. */

ULONG GlobalDebugFlags = ~DEBUG_OPTIONS;

NTSTATUS
SetDebugFlags( LPWSTR *Params ) {

    ASSERT( *Params != NULL );
    GlobalDebugFlags = wcstoul( *Params,
                                0,
                                NULL );

    printf( "Debug Print Flags set to 0x%x.\n",
            GlobalDebugFlags );

    return STATUS_SUCCESS;
}
#endif


/*------------------------------------------------------------

  Here's the array of callbacks.  It's read by the command
  line interpreter in main()

  ------------------------------------------------------------*/

CommandPair Commands[] = {

  // argument           argc doNow? argFunction   description

  {L"/SetDomain",           1, SetDnsDomain,       NULL, // renamed -- hidden from help
   0,
   NULL, // no arguments
   "requires a reboot to take effect" },

  {L"/SetRealm",            1, SetDnsDomain,       "<DnsDomainName>",
   CAN_HAVE_FEWER_ARGUMENTS,
   "Makes this computer a member of an RFC1510 Kerberos Realm",
   "requires a reboot to take effect" },

  {L"/MapUser",             2, MapUser,            "<Principal> [Account]",
   CAN_HAVE_FEWER_ARGUMENTS,
   "Maps a Kerberos Principal ('*' = any principal)\n"
   "\tto an account ('*' = an account by same name);\n"
   "\tIf account name is omitted, mapping is deleted \n"
   "\tfor the specified principal"
  },

  {L"/AddKdc",              1, AddKdcName,         "<RealmName> [KdcName]",
   CAN_HAVE_MORE_ARGUMENTS,
   "Defines a KDC entry for the given realm.\n"
   "\tIf KdcName omitted, DNS may be used to locate KDCs."},

  {L"/DelKdc",              1, DeleteKdcName,      "<RealmName> [KdcName]",
   CAN_HAVE_MORE_ARGUMENTS,
   "deletes a KDC entry for the realm.\n"
   "\tIf KdcName omitted, the realm entry itself is deleted.",
   "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/AddKpasswd",          2, AddKpasswdName,     "<Realmname> <KpasswdName>",
   0, // no flags
   "Add Kpasswd server address for a realm"},

  {L"/DelKpasswd",          2, DelKpasswdName,     "<Realmname> <KpasswdName>",
   0, // no flags
   "Delete Kpasswd server address for a realm",
   "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/Server",              1, SetServer,          "<Servername>",
   DO_COMMAND_IMMEDIATELY,
   "specify name of a Windows machine to target the changes."
  },

  {L"/SetMachPassword",     1, SetMachinePassword, NULL, // renamed; hidden from help
   0, // no flags
   NULL, // no description -- this option is depricated.
   "requires a reboot to take effect." },

  {L"/SetComputerPassword", 1, SetMachinePassword, "<Password>",
   0, // no flags
   "Sets the password for the computer's domain account\n"
   "\t(or \"host\" principal)",
   "requires a reboot to take effect." },

  { L"/RemoveRealm",        1, RemoveDomainName,   "<RealmName>",
    0, // no flags
    "delete all information for this realm from the registry.",
    "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/Domain",              1, ChooseDomain,       "[DomainName]",
   DO_COMMAND_IMMEDIATELY |
   CAN_HAVE_FEWER_ARGUMENTS,
   "use this domain (if DomainName is unspecified, detect it)" },

  {L"/ChangePassword",      2, ChangeViaKpasswd,   "<OldPasswd> <NewPasswd>",
   DO_COMMAND_IMMEDIATELY,
   "Use Kpasswd to change the logged-on user's password.\n"
   "\tUse '*' to be prompted for passwords." },

  // realm flag stuff:

  { L"/ListRealmFlags",     0, ListRealmFlags,
    "(no args)",
    DO_COMMAND_IMMEDIATELY,
    "Lists the available Realm flags that ksetup knows"
  },

  { L"/SetRealmFlags",      2, SetRealmFlags,
    "<realm> <flag> [flag] [flag] [...]",
    CAN_HAVE_MORE_ARGUMENTS,
    "Sets RealmFlags for a specific realm" },

  { L"/AddRealmFlags",      2, AddRealmFlags,
    "<realm> <flag> [flag] [flag] [...]",
    CAN_HAVE_MORE_ARGUMENTS,
    "Adds additional RealmFlags to a realm"
  },

  { L"/DelRealmFlags",      2, DelRealmFlags,
    "<realm> <flag> [flag] [flag] [...]",
    CAN_HAVE_MORE_ARGUMENTS,
    "Deletes RealmFlags from a realm." },

  {L"/DumpState",           0, DumpState,
   "(no args)",
   0,
   "Analyze the kerberos configuration on the given machine." },

  {L"/?",                   0, PrintHelp,          NULL }, // hidden from help
  {L"/help",                0, PrintHelp,          NULL }, // hidden from help

#if DBG
  {L"/debugflag",           1, SetDebugFlags,      "<flags>",
   DO_COMMAND_IMMEDIATELY,
   "Set debugging flags" },
#endif

};

ULONG cCommands = sizeof( Commands ) / sizeof( Commands[ 0 ] );

VOID
PrintUsage(
    IN ULONG iCommand
    )
{
    if ( Commands[ iCommand ].Arguments ) {
        printf( "\n"
            "USAGE:\n" );

        printf( "%ws %hs\n",
              Commands[ iCommand ].Name,
              Commands[ iCommand ].Arguments );

        if ( Commands[ iCommand ].ExtendedDescription ) {
            printf( "\t%hs\n", Commands[ iCommand ].ExtendedDescription );
        }
    }
}

NTSTATUS
PrintHelp(LPWSTR * Parameter)
{

    ULONG i;
    LPSTR pDesc;

    printf( "\n"
            "USAGE:\n" );

    for ( i = 0 ;
          i < cCommands ;
          i ++ ) {

      if ( Commands[ i ].Arguments ) {

        printf( "%ws %hs\n",
                Commands[ i ].Name,
                Commands[ i ].Arguments );

#if 1
    if ( Commands[ i ].ExtendedDescription ) {

      printf( "\t%hs\n",
          Commands[ i ].ExtendedDescription );

    }
#else

    for ( pDesc = Commands[ i ].ExtendedDescription;
          pDesc && *pDesc ;
          /* No increment */
          ) {

      printf( "%-20hs %hs\n",
          "",
          pDesc );

      pDesc = strchr( pDesc, '\0' );
      if ( pDesc ) pDesc++;
    }

#endif


      }
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\strings.cxx ===
/*++

  STRINGS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: MultiString class

  Created, Dec 29, 1999 by DavidCHR.

  CONTENTS: CMULTISTRING
            WriteToRegistry
            ReadFromRegistry
            RemoveString
            AddString
            ~CMULTISTRING

--*/  

#include "everything.hxx"

/*++**************************************************************
  NAME:      CMULTISTRING

  constructor for the class.  

 **************************************************************--*/

CMULTISTRING::
CMULTISTRING( VOID ) {

    this->cEntries         = 0;
    this->pEntries         = NULL;
    this->TotalStringCount = 0;

}

/*++**************************************************************
  NAME:      ~CMULTISTRING

  destructor for the class.  Frees any strings still around.
  
 **************************************************************--*/

CMULTISTRING::
~CMULTISTRING( VOID ) {

    ULONG i;

    if ( this->cEntries &&
	 this->pEntries ) {

      for ( i = 0 ;
	    i < this->cEntries ;
	    i ++ ) {

	if ( this->pEntries[ i ] ) {
	  free( this->pEntries[ i ] );
	}

      }

      free( this->pEntries );

    }

}


/*++**************************************************************
  NAME:      AddString

  adds a string to the end of string table

  MODIFIES:  this->pEntries, this->cEntries

  TAKES:     String -- string to add (duplicated)

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.

  LOGGING:   printf on failure
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: ~CMULTISTRING
  
 **************************************************************--*/

BOOL CMULTISTRING::
AddString( IN LPWSTR String ) {

    LPWSTR *tempString;

    tempString = (LPWSTR *) realloc( this->pEntries,
				     ( this->cEntries + 1 ) *
				     sizeof( LPWSTR ) );

    if ( tempString ) {

      this->pEntries               = tempString;
      tempString[ this->cEntries ] = _wcsdup( String );
			  
      if ( tempString[ this->cEntries ] ) {

	this->cEntries         ++;
	this->TotalStringCount += wcslen( String );

	return TRUE;

      } else {

	printf( "Cannot add string %ld (%ws).  Not enough memory.\n",
		this->cEntries,
		String );

	SetLastError( ERROR_NOT_ENOUGH_MEMORY );

      }

      // don't free the string.

    }

    return FALSE;

}

/*++**************************************************************
  NAME:      RemoveString

  removes a string from the list

  MODIFIES:  this->pEntries, this->cEntries

  TAKES:     String -- string to remove (case-insensitive)

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LOGGING:   printf if the string doesn't exist
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL CMULTISTRING::
RemoveString( IN LPWSTR String ) {

    ULONG i, DeleteCount = 0;
    BOOL  ret = TRUE;

    // first, go through and free the matches
 
    for ( i = 0 ;
	  i < this->cEntries ;
	  i ++ ) {

      if ( _wcsicmp( String,
		     this->pEntries[ i ] ) == 0 ) {

	// match.  Free it.

	free( this->pEntries[ i ] );
	this->pEntries[ i ] = NULL;
	DeleteCount++;

      } else if ( DeleteCount > 0 ) {

	/* If we've deleted stuff already, and we're not deleting
	   this one, then move this entry earlier in the array. */

	this->pEntries[ i - DeleteCount ] = this->pEntries[ i ];

#if DBG

	/* For the sake of debugging, set this to a known
	   bad value. */
#ifdef _WIN64 // to avoid ia64 compile-time error, give it a qword for a pointer
	this->pEntries[ i ] = (LPWSTR) 0xdeadbeefdeadbeef;
#else	
	this->pEntries[ i ] = (LPWSTR) ULongToPtr( 0xdeadbeef );
#endif // _WIN64

#endif // DBG

      }
    }

    if ( DeleteCount ) {

      this->cEntries         -= DeleteCount;
      this->TotalStringCount -= DeleteCount * wcslen( String );

      /* We could realloc the array down to the correct cEntries now,
	 but there's no pressing need. */

    } else {

      printf( "No match for %ws.\n",
	      String );

      ret = FALSE;

    }

    return ret;

}
	

/*++**************************************************************
  NAME:      ReadFromRegistry

  reads a string vector from a REG_MULTI_SZ in the registry

  MODIFIES:  this, indirectly

  TAKES:     hKey      -- handle to open parent key
             ValueName -- value to read

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LOGGING:   printf on failure
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL CMULTISTRING::
ReadFromRegistry( IN HKEY   hKey,
		  IN LPWSTR ValueName ) {
    
    ULONG   RegistrySize = 0;
    ULONG   cEntries     = 0;
    LPWSTR  RegistryStrings;
    LPWSTR *StringTable = NULL;
    LPWSTR *pTempTable, Cursor;
    DWORD   WinError;
    DWORD   Type;
    BOOL    ret = FALSE;

    WinError = RegQueryValueEx( hKey,
				ValueName,
				NULL,
				&Type,
				NULL,
				&RegistrySize );
               
    if (WinError == ERROR_SUCCESS) {
      
      RegistryStrings = (LPWSTR) malloc( RegistrySize );
      
      if ( RegistryStrings ) {

	WinError = RegQueryValueEx( hKey,
				    ValueName,
				    NULL,
				    &Type,
				    (PUCHAR) RegistryStrings,
				    &RegistrySize );

	if (WinError == ERROR_SUCCESS) {

	  ret = TRUE;

	  if ( RegistrySize > 2 * sizeof( WCHAR ) ) { /* 2 == two nulls
							 which would indicate
							 that the value is
							 empty. */

	    /* Now, allocate a string vector, counting the strings
	       as we go. */

	    for ( Cursor = RegistryStrings ;
		  *Cursor != L'\0' ;
		  Cursor = wcschr( Cursor, '\0' ) +1 ) {

	      if ( !this->AddString( Cursor ) ) {

		ret = FALSE;
		break;

	      }

	    }

	  } // else the value was empty -- nothing to do.

	} else {

	  printf("Failed to query value %ws: 0x%x\n",
		 ValueName,
		 WinError );
	}

	free( RegistryStrings );

      } else {

	printf( "Failed to allocate buffer of size (0x%x)\n",
		RegistrySize );

      }
    } else if ( WinError == ERROR_FILE_NOT_FOUND ) {

      /* The key doesn't exist-- no mappings. */
      
      // WinError = ERROR_SUCCESS;
      ret = TRUE;

    } else {

      /* an actual error. */

      printf( "Failed to query %ws: 0x%x\n",
	      ValueName,
	      WinError );

    }

    return ret;
}
	


/*++**************************************************************
  NAME:      WriteToRegistry

  dumps the string vector to a REG_MULTI_SZ in the registry

  MODIFIES:  the registry only

  TAKES:     hKey      -- handle to open parent key
             ValueName -- value to write

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LOGGING:   printf on failure
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL CMULTISTRING::
WriteToRegistry( IN HKEY   hKey,
		 IN LPWSTR ValueName ) {

    LPWSTR StringVector;
    ULONG  StringIndex, EntryIndex, Length, VectorLength;
    DWORD  dwErr;
    BOOL   ret = FALSE;

    VectorLength = ( this->TotalStringCount + // string characters
		     this->cEntries +         // null characters
		     2                        // trailing nulls
		     ) * sizeof( WCHAR );


    StringVector = (LPWSTR) malloc( VectorLength );

    if ( !StringVector ) {

      printf( "Failed to allocate string blob to write %ws.\n",
	      ValueName );

    } else {

      for ( StringIndex = EntryIndex = 0 ;
	    EntryIndex < this->cEntries ;
	    EntryIndex++ ) {

	Length = wcslen( this->pEntries[ EntryIndex ] ) +1; /* include the
							       null */

	memcpy( StringVector + StringIndex,   // to
		this->pEntries[ EntryIndex ], // from
		Length * sizeof( WCHAR ) );   // byte count

	StringIndex += Length;

      }

      StringVector[ StringIndex   ] = L'\0';
      StringVector[ StringIndex+1 ] = L'\0';
	
      dwErr = RegSetValueExW( hKey,
			      ValueName,
			      0, // mbz
			      REG_MULTI_SZ,
			      (PBYTE) StringVector,
			      VectorLength );

      free( StringVector );

      if ( dwErr != ERROR_SUCCESS ) {

	printf( "Failed to write %ws value to registry: 0x%x.\n",
		ValueName,
		dwErr );

      } else {

	ret = TRUE;

      }

    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\ksetup\support.cxx ===
/*++

  SUPPORT.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: support functions for ktpass

  Created, May 21, 1999 by DavidCHR.

  CONTENTS: ReadRegistryStrings

--*/  

#include "everything.hxx"

NTSTATUS
OpenLsa( VOID )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS Status;
    UNICODE_STRING ServerString;

    RtlInitUnicodeString(
        &ServerString,
        ServerName
        );

    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    Status = LsaOpenPolicy(&ServerString,&oa,MAXIMUM_ALLOWED,&LsaHandle);
    return(Status);
}

NTSTATUS
OpenLocalLsa( OUT PLSA_HANDLE phLsa ) {

    static LSA_HANDLE hLsa = NULL;
    NTSTATUS          N    = STATUS_SUCCESS;

    if ( !hLsa ) {

      N = LsaConnectUntrusted( &hLsa );

      if ( !NT_SUCCESS( N ) ) {
        
        printf( "Failed to connect to the local LSA: 0x%x\n",
                N );
        
      }

    }

    if ( NT_SUCCESS( N ) ) {

      *phLsa = hLsa;

    } else {

      hLsa = NULL;

    }

    return N;

}
    



/*++**************************************************************
  NAME:      ReadActualPassword

  convenience routine for reading the password for a particular
  account.  Disables command line echo for the duration.

  MODIFIES:  Password  -- receives the new password

  TAKES:     Description -- descriptive string to insert
                            into prompts and error messages.
	     flags       -- see everything.h: 
	                    PROMPT_USING_POSSESSIVE_CASE
			    PROMPT_FOR_PASSWORD_TWICE

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   printf on failure
  CREATED:   Apr 7, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
  CONTENTS: CallAuthPackage

 **************************************************************--*/

BOOL
ReadActualPassword( IN  LPWSTR Description,
                    IN  ULONG  flags,
                    IN  ULONG  PasswordLength,
                    OUT LPWSTR Password ) {

    HANDLE hConsole;
    DWORD  dwMode;
    BOOL   ret = FALSE;
    ULONG  Length;
    WCHAR  TempPassword[ MAX_PASSWD_LEN ];
    ULONG i;

    hConsole = GetStdHandle( STD_INPUT_HANDLE );
    
    if ( hConsole ) {

      // get the old console settings.

      if ( GetConsoleMode( hConsole,
                           &dwMode ) ) {

        // now turn off typing echo

        if ( SetConsoleMode( hConsole,
                             dwMode &~ ENABLE_ECHO_INPUT ) ) {

          fprintf( stderr,
                   ( flags & PROMPT_USING_POSSESSIVE_CASE ) ?
		   "Enter password for %ws: " :
		   "Enter %ws password: ",
                   Description );

          if ( !fgetws( Password, PasswordLength, stdin ) ) {

            fprintf( stderr, 
                     "EOF on input.  Aborted.\n" );

            goto restoreConsoleMode;
          }

          for ( i = 0; i < PasswordLength; i++ )
          {
            if ( Password[i] == L'\n' )
            {
                Password[i] = L'\0';
                break;
            }
          }

	  if ( flags & PROMPT_FOR_PASSWORD_TWICE ) {

	    fprintf( stderr,
		     "\nNow re-enter password to confirm: " );
	    
	    if ( !fgetws( TempPassword, MAX_PASSWD_LEN, stdin ) ) {

	      fprintf( stderr, 
		       "EOF on input.  Aborted.\n" );
	      
	      goto restoreConsoleMode;
	      
	    }

        for ( i = 0; i < MAX_PASSWD_LEN; i++ )
        {
          if ( TempPassword[i] == L'\n' )
          {
              TempPassword[i] = L'\0';
              break;
          }
        }
	  }

	  fprintf( stderr,
		   "\n" );

	  if ( flags & PROMPT_FOR_PASSWORD_TWICE ) {

	    // verify that the two passwords are the same.
	    
	    if ( wcscmp( Password,
			 TempPassword ) == 0 ) {
	      
	      ret = TRUE;
	      
	    } else {
	      
	      fprintf( stderr,
		       "Passwords do not match.\n" );
	      
	    }

	  } else {

	    ret = TRUE;

	  }

 restoreConsoleMode:
          // restore echo
	  
          SetConsoleMode( hConsole,
                          dwMode );
	  

        } else {

          fprintf( stderr, 
                   "Failed to disable line echo for password entry of %ws: 0x%x.\n",
                   Description,
                   GetLastError() );

        }
      } else {

        fprintf( stderr,
                 "Failed to retrieve current console settings: 0x%x\n",
                 GetLastError() );

      }

    } else {

      fprintf( stderr,
               "Failed to obtain console handle so we could disable line input echo: 0x%x\n",
               GetLastError() );

    }

    SecureZeroMemory( TempPassword, sizeof( TempPassword ));

    return ret;

}

/*++**************************************************************
  NAME:      ReadOptionallyStarredPassword

  if the given password is "*", read a new password from stdin.
  Otherwise, return the given password.

  MODIFIES:  pPassword -- receives the real password

  TAKES:     Password  -- password to check for *
             Description, flags -- as ReadActualPassword

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   printf on failure
  CREATED:   Apr 7, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: free()
  
 **************************************************************--*/

BOOL
ReadOptionallyStarredPassword( IN  LPWSTR  InPassword,
                               IN  ULONG   flags,
                               IN  LPWSTR  Description,
                               OUT LPWSTR *pPassword ) {

    ULONG  Length;
    LPWSTR OutPass;
    BOOL   ReadPass;
    BOOL   ret = FALSE;

    Length = lstrlenW( InPassword );

    if ( ( 1 == Length ) &&
         ( L'*' == InPassword[ 0 ] ) ) {
      
      ReadPass = TRUE;
      Length   = MAX_PASSWD_LEN;
      
    } else {

      ReadPass = FALSE;
      
    }

    Length++; // null character
    Length *= sizeof( WCHAR );

    OutPass = (LPWSTR) malloc( Length );

    if ( OutPass != NULL ) {

      if ( ReadPass ) {

        ret = ReadActualPassword( Description,
                                  flags,
                                  Length / sizeof( WCHAR ),
                                  OutPass );

      } else {

        lstrcpyW( OutPass,
                  InPassword );

        ret = TRUE;

      }

      if ( ret ) {

        *pPassword = OutPass;
        
      } else {

        SecureZeroMemory( OutPass, Length );
        free( OutPass );

      }
    } else {

      fprintf( stderr,
               "Failed to allocate memory for %ws password.\n",
               Description );
    }

    return ret;
}
        
/*++**************************************************************
  NAME:      CallAuthPackage

  convenience routine to centralize calls to LsaCallAuthentication
  Package.

  MODIFIES:  ppvOutput     -- data returned by LsaCallAuthPackage
             pulOutputSize -- returned size of that buffer

  TAKES:     pvData        -- submission data for that same api
             ulInputSize   -- sizeof the given buffer

  RETURNS:   a status code indicating success or failure
  LOGGING:   none
  CREATED:   Apr 13, 1999
  LOCKING:   none
  CALLED BY: anyone, most notably ChangeViaKpasswd
  FREE WITH: ppvOutput with LsaFreeReturnBuffer
  
 **************************************************************--*/

NTSTATUS
CallAuthPackage( IN  PVOID  pvData,
                 IN  ULONG  ulInputSize,
                 OUT PVOID *ppvOutput,
                 OUT PULONG pulOutputSize ) {

    // These are globals that are specific to this function. 

    static STRING     Name      = { 0 };
    static ULONG      PackageId = 0;
    static BOOL       NameSetup = FALSE;
    LSA_HANDLE        hLsa;
    NTSTATUS          N;

    if ( NT_SUCCESS( N = OpenLocalLsa( &hLsa ) ) ) {

      if ( !NameSetup ) {

        RtlInitString( &Name,
                       MICROSOFT_KERBEROS_NAME_A );

        N = LsaLookupAuthenticationPackage( hLsa,
                                            &Name,
                                            &PackageId );

        NameSetup = NT_SUCCESS( N );

      }

      if ( NT_SUCCESS( N ) ) {

        NTSTATUS SubStatus;

        N = LsaCallAuthenticationPackage( hLsa,
                                          PackageId,
                                          pvData,
                                          ulInputSize,
                                          ppvOutput,
                                          pulOutputSize,
                                          &SubStatus );

        if ( !NT_SUCCESS( N ) ||
             !NT_SUCCESS( SubStatus ) ) {

          printf( "CallAuthPackage failed, status 0x%x, substatus 0x%x.\n",
                  N, SubStatus );

        }

        if ( NT_SUCCESS( N ) ) {
          N = SubStatus;
          
        }
      }

    }

    return N;
}

VOID
InitStringAndMoveOn( IN     LPWSTR           RealString,
                     IN OUT LPWSTR          *pCursor,
                     IN OUT PUNICODE_STRING  pString ) {

    ULONG Length;

    Length = lstrlenW( RealString ) +1;

    memcpy( *pCursor,
            RealString,
            Length * sizeof( WCHAR ) );

    RtlInitUnicodeString( pString,
                          *pCursor );


    *pCursor += Length;

    // ASSERT( **pCursor == L'\0' );

}

    


NTSTATUS
ChangeViaKpasswd( LPWSTR * Parameters ) {

    LPWSTR                       OldPassword = NULL, NewPassword = NULL;
    NTSTATUS                     ret     = STATUS_UNSUCCESSFUL;
    PKERB_CHANGEPASSWORD_REQUEST pPasswd = NULL;
    LPWSTR                       Cursor;
    PVOID                        pvTrash;
    ULONG                        size, ulTrash;

    if ( !GlobalDomainSetting ) {

      printf( "Can't change password without /domain.\n" );
      ret = STATUS_INVALID_PARAMETER;

    } else if ( !( ReadOptionallyStarredPassword( Parameters[ 0 ],
                                                  0, // no flags
                                                  L"your old",
                                                  &OldPassword ) &&
                   
                   ReadOptionallyStarredPassword( Parameters[ 1 ],
						  PROMPT_FOR_PASSWORD_TWICE,
                                                  L"your new",
                                                  &NewPassword ) ) ) {

      printf( "Failed to validate passwords for password change.\n" );
      ret = STATUS_INTERNAL_ERROR;

    } else {

      size  = lstrlenW( GlobalDomainSetting ) + 1;
      size += lstrlenW( GlobalClientName ) + 1;
      size += lstrlenW( OldPassword ) + 1;
      size += lstrlenW( NewPassword ) + 1;

      // all strings above this line

      size *= sizeof( WCHAR );
      size += sizeof( *pPasswd ) ; // buffer

      pPasswd = (PKERB_CHANGEPASSWORD_REQUEST) malloc( size );

      if ( pPasswd ) {

        // start at the end of the password-request buffer
        
        Cursor = (LPWSTR) &( pPasswd[1] );

        pPasswd->MessageType = KerbChangePasswordMessage;

        InitStringAndMoveOn( GlobalDomainSetting,
                             &Cursor, 
                             &pPasswd->DomainName );

        InitStringAndMoveOn( GlobalClientName,
                             &Cursor, 
                             &pPasswd->AccountName );

        InitStringAndMoveOn( OldPassword,
                             &Cursor, 
                             &pPasswd->OldPassword );

        InitStringAndMoveOn( NewPassword,
                             &Cursor, 
                             &pPasswd->NewPassword );

        pPasswd->Impersonating = FALSE; // TRUE; // FALSE;

        ret = CallAuthPackage( pPasswd,
                               size,
                               (PVOID *) &pvTrash,
                               &ulTrash );

        if ( NT_SUCCESS( ret ) ) {

          printf( "Password changed.\n" );

        } else {

          printf( "Failed to change password: 0x%x\n",
                  ret );

        }

        // zero the buffer to minimize exposure of the password.

        SecureZeroMemory(
            pPasswd,
            size );

        free( pPasswd );

      } else {

        printf( "Failed to allocate %ld-byte password change request.\n",
                size );

        ret = STATUS_NO_MEMORY;
      }
    }

    // zero the buffers to minimize exposure of the passwords
  
    if ( NewPassword )
    {
      SecureZeroMemory( NewPassword, lstrlenW( NewPassword ));
      free( NewPassword );
    }
  
    if ( OldPassword )
    {
      SecureZeroMemory( OldPassword, lstrlenW( OldPassword ));
      free( OldPassword );
    }

    return ret;
}


DWORD
OpenKerberosKey(
    OUT PHKEY KerbHandle
    )
{
    DWORD RegErr;
    HKEY ServerHandle = NULL;
    DWORD Disposition;

    RegErr = RegConnectRegistry(
                ServerName,
                HKEY_LOCAL_MACHINE,
                &ServerHandle
                );
    if (RegErr)
    {
        printf("Failed to connect to registry: %d (0x%x) \n",RegErr, RegErr);
        goto Cleanup;
    }

    RegErr = RegCreateKeyEx(
                ServerHandle,
                KERB_KERBEROS_KEY,
                0,
                NULL,
                0,              // no options
                KEY_CREATE_SUB_KEY,
                NULL,
                KerbHandle,
                &Disposition
                );
    if (RegErr)
    {
        printf("Failed to create Kerberos key: %d (0x%x)\n",RegErr, RegErr);
        goto Cleanup;
    }
Cleanup:
    if (ServerHandle)
    {
        RegCloseKey(ServerHandle);
    }
    return(RegErr);
}


DWORD
OpenSubKey( IN  LPWSTR * Parameters,
            OUT PHKEY    phKey ) {

    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY DomainHandle = NULL;
    HKEY DomainRoot = NULL;
    DWORD Disposition;
    LPWSTR OldServerNames = NULL;
    LPWSTR NewServerNames = NULL;
    ULONG OldKdcLength = 0;
    ULONG NewKdcLength = 0;
    ULONG Type;

    RegErr = OpenKerberosKey(&KerbHandle);

    if ( RegErr == ERROR_SUCCESS ) 
    {
	RegErr = RegCreateKeyEx( KerbHandle,
				 KERB_DOMAINS_SUBKEY,
				 0,
				 NULL,
				 0,              // no options
				 KEY_CREATE_SUB_KEY,
				 NULL,
				 &DomainRoot,
				 &Disposition );

	if ( RegErr == ERROR_SUCCESS ) 
	{
	    if ( Parameters && Parameters[ 0 ] ) 
	    {
		RegErr = RegCreateKeyEx(  DomainRoot,
					  Parameters[0],
					  0,
					  NULL,
					  0,              // no options
					  KEY_CREATE_SUB_KEY | KEY_SET_VALUE | KEY_QUERY_VALUE,
					  NULL,
					  &DomainHandle,
					  &Disposition );

		if ( RegErr == ERROR_SUCCESS ) 
		{
		    *phKey = DomainHandle;
		} 
		else 
		{
		    printf("Failed to create %ws key: 0x%x\n", Parameters[ 0 ], RegErr);          
		}
        
		RegCloseKey( DomainRoot );

	    } 
	    else /* return the domain root if no domain is requested. */         
	    { 
		*phKey = DomainRoot;         
	    }        
	} 
	else 
	{        
	    printf( "Failed to create key %ws: 0x%x\n", Parameters[ 0 ], RegErr );
	}

	RegCloseKey( KerbHandle );
      
    } 
    else 
    {
	printf( "Failed to open Kerberos Key: 0x%x\n", RegErr );
    }

    return RegErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "moveme.h"

#define ANSI
#include <stdarg.h>

#if DBG         // NOTE:  This file not compiled for retail builds



DEFINE_DEBUG2(MoveMe);
DEBUG_KEY   MoveMeDebugKeys[] = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_UI,         "UI"},
                                 {0, NULL},
                                 };


// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.



//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the SPMgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
InitDebugSupport(void)
{
    MoveMeInitDebug(MoveMeDebugKeys);

}




#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\dialogs.h ===
#define IDD_MAIN_DLG                100
#define IDD_GROUPBOX_1              101
#define IDD_PROFILE_CHECK           102
#define IDD_RADIO_MAKECOPY          103
#define IDD_RADIO_REFER_TO_SAME     104
#define IDD_MOVE_MACHINE            105
#define IDD_ABOUT                   106
#define IDD_ABOUT_2                 107
#define IDD_DOMAIN_LINE             108
#define IDD_WKSTA_DOMAIN            109
#define IDD_MAIN_ICON               110
#define IDD_UPDATE_SEC              111
#define IDD_RADIO_MAKE_ROAM         112
#define IDD_MIGRATING               200
#define IDD_MIGRATING_TEXT          201
#define IDD_MIGRATING_PROGRESS      202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <dsysdbg.h>

// The following Debug Flags can be turned on to trace different areas to
// trace while executing.  Feel free to add more levels.

#define DEB_TRACE_UI        0x00000008

#if DBG

DECLARE_DEBUG2(MoveMe);


#define DebugLog(x) MoveMeDebugPrint x



#else   // Not DBG

#define DebugLog(x)

#endif

VOID
InitDebugSupport(
    VOID );


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\moveme.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       moveme.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __MOVEME_H__
#define __MOVEME_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include <commctrl.h>
#include <userenv.h>
#include <userenvp.h>

#include <lm.h>
#include <dsgetdc.h>
#include <lmjoin.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include "debug.h"
#include "strings.h"

#define MOVE_CHANGE_DOMAIN  0x00000001
#define MOVE_COPY_PROFILE   0x00000002
#define MOVE_DO_PROFILE     0x00000004
#define MOVE_UPDATE_SECURITY 0x00000008
#define MOVE_MAKE_ROAM      0x00000010
#define MOVE_NO_UI          0x80000000
#define MOVE_SOURCE_SUPPLIED 0x40000000
#define MOVE_NO_PROFILE     0x20000000
#define MOVE_WHACK_PSTORE   0x10000000

extern DWORD MoveOptions ;


BOOL
WINAPI
GetUserProfileDirectoryFromSid(
    PSID Sid,
    LPTSTR lpProfileDir,
    LPDWORD lpcchSize
    );

BOOL
CreateUiThread(
    VOID
    );


VOID
StopUiThread(
    VOID
    );

VOID
RaiseUi(
    HWND Parent,
    LPWSTR Title
    );

VOID
UpdateUi(
    DWORD   StringId,
    DWORD   Percentage
    );

LONG
MyRegSaveKey(
    HKEY Key,
    LPTSTR File,
    LPSECURITY_ATTRIBUTES lpsa
    );

BOOL
GetPrimaryDomain(
    PWSTR Domain
    );

BOOL
SetUserProfileDirectory(
    PSID Base,
    PSID Copy
    );

VOID
Fail(
    HWND hWnd,
    PWSTR Failure,
    PWSTR Description,
    DWORD Code,
    PWSTR Message
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\moveme.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       moveme.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "moveme.h"
#include "dialogs.h"
#include <stdlib.h>

#define APPNAME TEXT("fail")
#define FILENAME TEXT("moveme.ini")

ULONG MoveOptions = MOVE_UPDATE_SECURITY | MOVE_DO_PROFILE ;

WCHAR   MachDomain[ DNLEN * 2 ];
WCHAR   SourceDomain[ DNLEN * 2 ];
WCHAR   DestDomain[ DNLEN * 2 ];
WCHAR   UserName[ UNLEN * 2 ];
PSID    OldSid ;
PSID    NewSid ;
HICON   MyIcon ;
PDOMAIN_CONTROLLER_INFO DcInfo ;
PDOMAIN_CONTROLLER_INFO DestDcInfo ;

OSVERSIONINFOEX VersionInfo ;

DWORD   ProfileSection[] = { IDD_RADIO_MAKECOPY, IDD_RADIO_REFER_TO_SAME, IDD_RADIO_MAKE_ROAM };

VOID
EnableSection(
    HWND hDlg,
    BOOL Enable,
    PDWORD IdList,
    DWORD Count
    )
{
    DWORD i ;
    for ( i = 0 ; i < Count ; i++ )
    {
        EnableWindow( GetDlgItem( hDlg, IdList[ i ]), Enable );
    }
}

VOID
DumpState(
    VOID
    )
{
    UNICODE_STRING Sid ;
    WCHAR PrivateInt[ 16 ];

    swprintf( PrivateInt, L"%d", VersionInfo.dwBuildNumber );

    WritePrivateProfileString( APPNAME, TEXT("Build"), PrivateInt, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("MachDomain"), MachDomain, FILENAME);
    WritePrivateProfileString( APPNAME, TEXT("SourceDomain"), SourceDomain, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("DestDomain"), DestDomain, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("UserName"), UserName, FILENAME );
    if ( DcInfo )
    {
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.name"), DcInfo->DomainControllerName, FILENAME);
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.address"), DcInfo->DomainControllerAddress, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.domainname"), DcInfo->DomainName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.treename"), DcInfo->DnsForestName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.dcsite"), DcInfo->DcSiteName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.clientsite"), DcInfo->ClientSiteName, FILENAME );
        //WritePrivateProfileInt( APPNAME, TEXT("DcInfo.Flags"), DcInfo->Flags, FILENAME );
    }
    if ( DestDcInfo )
    {
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.name"), DestDcInfo->DomainControllerName, FILENAME);
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.address"), DestDcInfo->DomainControllerAddress, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.domainname"), DestDcInfo->DomainName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.treename"), DestDcInfo->DnsForestName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.dcsite"), DestDcInfo->DcSiteName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.clientsite"), DestDcInfo->ClientSiteName, FILENAME );

    }
    if ( OldSid )
    {
        RtlConvertSidToUnicodeString( &Sid, OldSid, TRUE );
        WritePrivateProfileString( APPNAME, TEXT("OldSid"), Sid.Buffer, FILENAME );
        RtlFreeUnicodeString( &Sid );
    }
    else
    {
        WritePrivateProfileString( APPNAME, TEXT("OldSid"), TEXT("<none>"), FILENAME );
    }
    if ( NewSid )
    {
        RtlConvertSidToUnicodeString( &Sid, NewSid, TRUE );
        WritePrivateProfileString( APPNAME, TEXT("NewSid"), Sid.Buffer, FILENAME );
        RtlFreeUnicodeString( &Sid );
    }
    else
    {
        WritePrivateProfileString( APPNAME, TEXT("NewSid"), TEXT("<none>"), FILENAME );
    }


}

VOID
Fail(
    HWND hWnd,
    PWSTR Failure,
    PWSTR Description,
    DWORD Code,
    PWSTR Message
    )
{
    UNICODE_STRING Sid ;
    WCHAR Msg[MAX_PATH];
    WCHAR foo[MAX_PATH];

    UpdateUi(0,100);
    StopUiThread();

    DumpState();

    WritePrivateProfileString( APPNAME, TEXT("Failure"), Failure, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("Desc"), Description, FILENAME );
    wsprintf( Msg, L"%d (%#x)", Code, Code );
    WritePrivateProfileString( APPNAME, TEXT("Code"), Msg, FILENAME );

    ExpandEnvironmentStrings( TEXT("%windir%"), foo, MAX_PATH );
    _snwprintf( Msg, MAX_PATH, TEXT("%ws  Please mail the file %ws in %ws to 'ntdsbug'"),
                    Message ? Message : TEXT("An unrecoverable error occurred, and has prevented you from joining the NTDEV rollout."),
                    FILENAME, foo );
    MessageBox( hWnd, Msg, TEXT("Error"), MB_ICONSTOP | MB_OK );

    ExitProcess( GetLastError() );
}

PSECURITY_DESCRIPTOR
MakeUserSD(
    PSID UserSid,
    ACCESS_MASK Mask
    )
{
    PSECURITY_DESCRIPTOR psd ;
    PACL Dacl ;
    DWORD DaclLen ;
    PACCESS_ALLOWED_ACE Ace ;
    PSID LocalSystem ;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY ;

    AllocateAndInitializeSid( &NtAuth, 1,
        SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0,
        &LocalSystem );

    psd = LocalAlloc( LMEM_FIXED, sizeof( SECURITY_DESCRIPTOR ) );

    DaclLen = (sizeof( ACCESS_ALLOWED_ACE ) + RtlLengthSid( UserSid )) * 2 ;

    Dacl = LocalAlloc( LMEM_FIXED, DaclLen );

    if ( !psd || !Dacl)
    {
        return NULL ;
    }

    InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );
    InitializeAcl( Dacl, DaclLen, ACL_REVISION );

    SetSecurityDescriptorDacl( psd, TRUE, Dacl, FALSE );

    AddAccessAllowedAce( Dacl, ACL_REVISION, Mask, UserSid );

    GetAce( Dacl, 0, &Ace );

    Ace->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;

    AddAccessAllowedAce( Dacl, ACL_REVISION, Mask, LocalSystem );

    GetAce( Dacl, 1, &Ace );

    Ace->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;

    return psd ;

}

RecurseWhackKey(
    HKEY ParentKey,
    PWSTR SubKey,
    PSECURITY_DESCRIPTOR psd
    )
{
    HKEY Key ;
    int err ;
    NTSTATUS Status ;
    WCHAR SubKeys[ 128 ];
    DWORD dwSize ;
    DWORD dwIndex ;
    FILETIME ftTime ;

    err = RegOpenKeyEx(
            ParentKey,
            SubKey,
            0,
            WRITE_DAC | WRITE_OWNER,
            &Key );

    if ( err == 0 )
    {
        Status = NtSetSecurityObject(   Key,
                                        OWNER_SECURITY_INFORMATION |
                                            DACL_SECURITY_INFORMATION,
                                        psd );

        if ( NT_SUCCESS( Status ) )
        {
            RegCloseKey( Key );

            err = RegOpenKeyEx(
                        ParentKey,
                        SubKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &Key );

            if ( err )
            {
                return err;
            }

            dwIndex = 0 ;
            dwSize = sizeof( SubKeys ) / sizeof( WCHAR );

            while ( RegEnumKeyEx( Key,
                                dwIndex,
                                SubKeys,
                                &dwSize,
                                NULL,
                                NULL,
                                NULL,
                                &ftTime ) == ERROR_SUCCESS )
            {
                RecurseWhackKey( Key, SubKeys, psd );
                dwIndex++ ;
                dwSize = sizeof( SubKeys ) / sizeof( WCHAR );
            }

        }

        RegCloseKey( Key );
    }

    return err ;
}


VOID
DealWithPstore(
    PSID UserSid
    )
{
    HKEY hKey = NULL;
    int err ;
    BOOLEAN WasEnabled ;
    NTSTATUS Status ;
    PSECURITY_DESCRIPTOR psd ;


    Status = RtlAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, FALSE, &WasEnabled );

    if ( !NT_SUCCESS( Status ))
    {
        return ;
    }

    err = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft"),
                0,
                KEY_READ | KEY_WRITE,
                &hKey );

    if( err != 0 )
    {
        return ;
    }

    psd = MakeUserSD( UserSid, KEY_ALL_ACCESS );

    SetSecurityDescriptorOwner( psd, UserSid, FALSE );

    RecurseWhackKey( hKey, TEXT("Protected Storage System Provider"), psd );


}

BOOL
MoveMe(
    HWND    hWnd,
    LPWSTR  OldProfile,
    LPWSTR  NewProfile
    )
{
    HKEY hKeyCU ;
    int err ;
    WCHAR TempPath[ MAX_PATH ];
    WCHAR TempFile[ MAX_PATH ];
    WCHAR TempPath2[ MAX_PATH ];
    HANDLE Token ;
    DWORD PathLength ;
    BOOL Ret ;
    WCHAR UserNameEx[ 64 ];
    DWORD Index = 0 ;
    SECURITY_ATTRIBUTES sa ;

    if ( MoveOptions & MOVE_MAKE_ROAM )
    {

        GetTempPath( MAX_PATH, TempPath );

        GetTempFileName( TempPath, TEXT("prf"), GetTickCount() & 0xFFFF, TempFile );

        UpdateUi( IDS_COPYING_USER_HIVE, 30 );

        err = MyRegSaveKey( HKEY_CURRENT_USER,
                            TempFile,
                            NULL );

        if ( err )
        {
            Fail( hWnd, TEXT("Save HKCU failed"), TEXT(""), err, NULL);
            return err ;
        }

        if (OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &Token ))
        {
            PathLength = MAX_PATH ;

            if (!GetUserProfileDirectory( Token, TempPath, &PathLength ))
            {
                Fail( hWnd, TEXT("Can't get current profile dir"), TEXT(""),
                        GetLastError(), NULL );
            }

        }
        else
        {
            Fail( hWnd, TEXT("Can't open process token?"), TEXT(""), GetLastError(), NULL );
        }

        UpdateUi( IDS_CREATING_NEW_PROFILE, 60 );


        Index = 64 ;

        GetUserName( UserNameEx, &Index );

        swprintf( TempPath2, TEXT("\\\\scratch\\scratch\\%ws\\Profile"), UserNameEx );

        sa.nLength = sizeof( sa );

        sa.bInheritHandle = FALSE ;

        sa.lpSecurityDescriptor = MakeUserSD( NewSid, FILE_ALL_ACCESS );

        if ( CreateDirectory( TempPath2, NULL ) )
        {
            UpdateUi( IDS_CREATING_NEW_PROFILE, 70 );

            if  ( ! CopyProfileDirectory( TempPath,
                                          TempPath2,
                                          CPD_FORCECOPY |
                                            CPD_IGNORECOPYERRORS |
                                            CPD_IGNOREHIVE |
                                            CPD_SHOWSTATUS ) )
            {
                if ( GetLastError() == 997 )
                {
                    //
                    // Looks like the dreaded pstore key problem.  Sigh.
                    //

                    DealWithPstore( NewSid );

                    if ( ! CopyProfileDirectory( TempPath,
                                          TempPath2,
                                          CPD_FORCECOPY |
                                            CPD_IGNORECOPYERRORS |
                                            CPD_IGNOREHIVE |
                                            CPD_SHOWSTATUS ) )
                    {
                        //
                        // Terminal, now bail:
                        //

                        Fail( hWnd, TEXT("Can't copy profile dir, even after whacking pstore key"), TempPath2, GetLastError(), NULL );

                        return GetLastError() ;
                    }


                }
                else
                {
                    Fail( hWnd, TEXT("Can't copy profile directory"), TempPath2, GetLastError(), NULL );

                    return GetLastError() ;
                }
            }
        }
        else
        {
            Fail( hWnd, TEXT("Can't create new directory"), TempPath2, GetLastError(), NULL );

            return GetLastError() ;
        }

        wcscat( TempPath2, TEXT("\\ntuser.dat") );

        if ( ! CopyFile( TempFile, TempPath2, FALSE ) )
        {
            Fail( hWnd, TEXT("Can't copy hive"), TempPath2, GetLastError(), NULL );
        }

        DeleteFile( TempFile );

        return GetLastError() ;
    }


    if ( MoveOptions & MOVE_COPY_PROFILE )
    {
        GetTempPath( MAX_PATH, TempPath );

        GetTempFileName( TempPath, TEXT("prf"), GetTickCount() & 0xFFFF, TempFile );

        UpdateUi( IDS_COPYING_USER_HIVE, 30 );

        err = MyRegSaveKey( HKEY_CURRENT_USER,
                            TempFile,
                            NULL );

        if ( err )
        {
            Fail( hWnd, TEXT("Save HKCU failed"), TEXT(""), err, NULL);
            return err ;
        }

        if (OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &Token ))
        {
            PathLength = MAX_PATH ;

            if (!GetUserProfileDirectory( Token, TempPath, &PathLength ))
            {
                Fail( hWnd, TEXT("Can't get current profile dir"), TEXT(""),
                        GetLastError(), NULL );
            }

        }
        else
        {
            Fail( hWnd, TEXT("Can't open process token?"), TEXT(""), GetLastError(), NULL );
        }

        UpdateUi( IDS_CREATING_NEW_PROFILE, 60 );

        Ret = CreateUserProfile( NewSid, UserName, TempFile, NULL, 0 );

        if ( !Ret )
        {
            if ( GetLastError() == 997 )
            {
                //
                // Looks like the dreaded pstore key problem.  Sigh.
                //

                DeleteFile( TempFile );

                DealWithPstore( OldSid );

                err = MyRegSaveKey( HKEY_CURRENT_USER,
                                    TempFile,
                                    NULL );

                if ( ! CreateUserProfile( NewSid, UserName, TempFile, NULL, 0 ) )
                {
                    //
                    // Terminal, now bail:
                    //

                    DeleteFile( TempFile );

                    Fail( hWnd, TEXT("Can't copy profile dir, even after whacking pstore key"), TEXT(""), GetLastError(), NULL );

                    return GetLastError() ;
                }

                Ret = TRUE ;

            }
            else
            {
                DeleteFile( TempFile );

                Fail( hWnd, TEXT( "CreateUserProfile failed"), TEXT(""), GetLastError(), NULL );

            }


        }

        DeleteFile( TempFile );

        UpdateUi( IDS_CREATING_NEW_PROFILE, 65 );

        if ( Ret )
        {
            //
            // Okay, we have created a shell profile based on the current
            // profile.  Now, copy the rest of the gunk over it:
            //

            PathLength = MAX_PATH ;

            GetUserProfileDirectoryFromSid( NewSid, TempPath2, &PathLength );

            UpdateUi( IDS_COPYING_OLD_PROFILE, 90 );

            if ( !CopyProfileDirectory( TempPath,
                                       TempPath2,
                                       CPD_FORCECOPY |
                                        CPD_IGNORECOPYERRORS |
                                        CPD_IGNOREHIVE ) )
            {
                Fail( hWnd, TEXT("CopyProfileDirectory failed"), TEXT(""), GetLastError(), NULL );
            }


        }
        else
        {
            //
            // Failed to create the shell profile.  Why?
            //

            Fail( hWnd, TEXT("Failed to create profile"), TEXT(""), GetLastError(), NULL );
        }

    }
    else
    {
        SetUserProfileDirectory( OldSid, NewSid );
    }


    if ( MoveOptions & MOVE_CHANGE_DOMAIN )
    {
        NET_API_STATUS NetStatus ;

        UpdateUi( IDS_MOVE_DOMAIN, 50 );

        NetStatus = NetJoinDomain( NULL, DestDomain,NULL,
                                   TEXT("ntdev"), TEXT("ntdev"),
                                   NETSETUP_JOIN_DOMAIN |
                                   NETSETUP_ACCT_CREATE );



        UpdateUi( IDS_MOVE_DOMAIN, 95 );


    }




    return TRUE ;
}

VOID
DoSecurity(
    HWND hDlg
    )
{
    int err ;
    HKEY hKey ;
    DWORD Disp ;
    NET_API_STATUS NetStatus ;
    LOCALGROUP_MEMBERS_INFO_0 LocalGroupInfo0 ;

    UpdateUi( IDS_SEC_LOCAL_SETTINGS, 50 );

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0"),
                          0,
                          TEXT(""),
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &hKey,
                          &Disp );

    if ( err == 0 )
    {
        err = RegSetValueEx( hKey,
                             TEXT("PreferredDomain"),
                             0,
                             REG_SZ,
                             (PUCHAR) SourceDomain,
                             (wcslen( SourceDomain ) + 1) * 2 );

        if ( err == 0 )
        {
            err = RegSetValueEx( hKey,
                                 TEXT("MappedDomain"),
                                 0,
                                 REG_SZ,
                                 (PUCHAR) DestDomain,
                                 (wcslen( DestDomain ) + 1 ) * 2 );
        }


        RegCloseKey( hKey );
    }
    else
    {
        Fail( hDlg, TEXT("Unable to open LSA key"), TEXT(""), err, TEXT("Unable to update rollout keys, you may not have permission.") );
    }

    UpdateUi( IDS_SEC_LOCAL_ADMIN, 90 );

    LocalGroupInfo0.lgrmi0_sid = NewSid ;

    NetStatus = NetLocalGroupAddMembers(
                        NULL,
                        L"Administrators",
                        0,
                        (LPBYTE) &LocalGroupInfo0,
                        1 );



}



BOOL
Initialize(
    VOID
    )
{
    ULONG Length ;
    HANDLE hToken ;
    PUNICODE_STRING User ;
    PUNICODE_STRING Domain ;
    UNICODE_STRING TargetDomainStr ;
    NTSTATUS Status ;
    PSID Sid ;
    PSID AdminSid ;
    PTOKEN_USER UserSid ;
    DWORD SidLength ;
    PBYTE DCName ;
    NET_API_STATUS NetStatus ;
    WCHAR RefDomain[ DNLEN + 2 ];
    ULONG RefDomainLength ;
    SID_NAME_USE NameUse ;
    BOOL IsMember ;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;

    RaiseUi( NULL, L"Initializing..." );

    UpdateUi( IDS_INIT_READ_NAMES, 5 );

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &hToken );

    if ( NT_SUCCESS( Status ) )
    {
        UserSid = LocalAlloc( LMEM_FIXED, 64 );

        if ( UserSid )
        {
            Status = NtQueryInformationToken( hToken,
                                              TokenUser,
                                              UserSid,
                                              64,
                                              &SidLength );

            if ( NT_SUCCESS( Status ) )
            {
                OldSid = UserSid->User.Sid ;
            }

        }

        AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0 ,0, 0,
                                    &AdminSid );

        if ( CheckTokenMembership( hToken, AdminSid, &IsMember ) )
        {
            if ( !IsMember )
            {
                Fail( NULL, TEXT("Not an administrator"), TEXT(""), GetLastError(),
                        TEXT( "You must be an administrator on this machine to run this utility." ) );
            }
        }

        NtClose( hToken );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        Fail( NULL, TEXT("Reading SID"), TEXT(""), Status, NULL );
    }

    UpdateUi( IDS_INIT_READ_NAMES, 25 );

    Status = LsaGetUserName( &User, &Domain );


    if ( !NT_SUCCESS( Status ) )
    {
        Fail( NULL, TEXT("Getting user name"), TEXT(""), Status, NULL );

        return FALSE ;
    }

    RtlInitUnicodeString( &TargetDomainStr, DestDomain );

    if ( RtlEqualUnicodeString( &TargetDomainStr, Domain, TRUE ) )
    {
        MoveOptions &= ~MOVE_DO_PROFILE ;
        MoveOptions |= MOVE_NO_PROFILE ;
    }

    UpdateUi( IDS_INIT_READ_NAMES, 35 );

    GetPrimaryDomain( MachDomain );

    UpdateUi( IDS_INIT_READ_NAMES, 45 );

    NetStatus = DsGetDcName( NULL, MachDomain, NULL, NULL,
                             DS_FORCE_REDISCOVERY |
                             DS_DIRECTORY_SERVICE_REQUIRED |
                             DS_KDC_REQUIRED,
                             &DcInfo );

    UpdateUi( IDS_INIT_READ_NAMES, 55 );

    if ( (MoveOptions & MOVE_SOURCE_SUPPLIED) == 0)
    {
        CopyMemory( SourceDomain, Domain->Buffer, Domain->Length );
        SourceDomain[ Domain->Length / sizeof(WCHAR) ] = L'\0';
    }

    CopyMemory( UserName, User->Buffer, User->Length );
    UserName[ User->Length / sizeof(WCHAR) ] = L'\0';

    LsaFreeMemory( User );
    LsaFreeMemory( Domain );

    //
    // Dest Domain must be filled in by caller.  So, try to look up
    // the new SID:
    //


    SidLength = RtlLengthRequiredSid( 6 );

    Sid = LocalAlloc( LMEM_FIXED, SidLength );

    if ( !Sid )
    {
        return FALSE ;
    }

    UpdateUi( IDS_INIT_DISCOVER_DCS, 75 );

    RefDomainLength = DNLEN + 2 ;

    NetStatus = DsGetDcName( NULL, DestDomain, NULL, NULL,
                             DS_FORCE_REDISCOVERY |
                             DS_DIRECTORY_SERVICE_REQUIRED |
                             DS_KDC_REQUIRED,
                             &DestDcInfo );


    if ( NetStatus == 0 )
    {
        UpdateUi( IDS_INIT_LOOKUP_ACCOUNTS, 95 );

        if ( LookupAccountName( (PWSTR) DestDcInfo->DomainControllerAddress,
                                UserName,
                                Sid,
                                &SidLength,
                                RefDomain,
                                &RefDomainLength,
                                &NameUse )
                                )
        {
            if (_wcsicmp( RefDomain, DestDomain ) == 0 )
            {
                NewSid = Sid ;
            }
            else
            {
                Fail( NULL, TEXT("No account for user"), UserName, GetLastError(),
                        TEXT( "There is no account for you on the destination domain.  Please contact NUTS for an account." ) );
            }
        }
        else
        {
            Fail( NULL, TEXT("Can't look up account name"), TEXT(""), GetLastError(), NULL );
        }
    }
    else
    {
        Fail( NULL, TEXT("No DC available"), DestDomain, NetStatus,
                    TEXT("No Domain Controllers were available for the destination domain.  Please try again later."));
    }


    UpdateUi( IDS_INIT_LOOKUP_ACCOUNTS, 100 );

    return TRUE ;

}

VOID
Usage(
    VOID
    )
{
    wprintf( TEXT("Usage:\n"));
    wprintf( TEXT("\tmoveme DOMAINNAME\n"));

    exit( 0 );
}

VOID
DoArgs(
    int argc,
    WCHAR * argv[]
    )
{
    int i;
    PWSTR Scan;

    wcscpy( DestDomain, L"NTDEV");

    i = 1 ;

    while ( i < argc )
    {
        if ( (*argv[i] != L'-') &&
             (*argv[i] != L'/') )
        {
            wcscpy( DestDomain, argv[i] );
        }
        else
        {
            switch ( *(argv[i]+1) )
            {
                case L'F':
                case L'f':
                    MoveOptions |= MOVE_NO_UI ;
                    break;

                case L'D':
                case L'd':
                    MoveOptions |= MOVE_SOURCE_SUPPLIED ;

                    Scan = argv[i];
                    while ( *Scan && (*Scan != ':'))
                    {
                        Scan++;
                    }
                    if ( *Scan )
                    {
                        Scan++;
                        wcscpy( SourceDomain, Scan );
                    }
                    break;

                case L'P':
                case L'p':
                    if ( *(argv[i]+2) == L'-' )
                    {
                        MoveOptions &= ~MOVE_DO_PROFILE ;
                    }
                    else
                    {
                        MoveOptions |= MOVE_DO_PROFILE ;
                    }
                    break;

                case L'W':
                case L'w':
                    MoveOptions = MOVE_WHACK_PSTORE ;
                    break;

                default:
                    Usage();
            }
        }

        i++ ;
    }
}

BOOL
DoIt(
    HWND hDlg
    )
{

    RaiseUi( hDlg, L"Migrating User Information...");

    if ( MoveOptions & MOVE_DO_PROFILE )
    {
        MoveMe( hDlg, NULL, NULL );
    }

    if ( MoveOptions & MOVE_UPDATE_SECURITY )
    {
        DoSecurity( hDlg );
    }

    UpdateUi( 0, 100 );

    return TRUE ;
}

INT_PTR
WINAPI
PromptDlg(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam)
{
    WCHAR Buffer[ MAX_PATH ];

    switch ( Message )
    {
        case WM_INITDIALOG:

            MyIcon = LoadImage( GetModuleHandle(NULL),
                                MAKEINTRESOURCE( 1 ),
                                IMAGE_ICON,
                                64, 72,
                                LR_DEFAULTCOLOR );

            if ( MyIcon )
            {
                SendMessage( GetDlgItem( hDlg, IDD_MAIN_ICON ),
                             STM_SETICON,
                             (WPARAM) MyIcon, 0 );
            }
            swprintf( Buffer, TEXT("Account Domain:  %ws"), SourceDomain );
            SetDlgItemText( hDlg, IDD_DOMAIN_LINE, Buffer );

            swprintf( Buffer, TEXT("Machine Domain:  %ws"), MachDomain );
            SetDlgItemText( hDlg, IDD_WKSTA_DOMAIN, Buffer );

            swprintf( Buffer, TEXT("This tool will adjust a number of settings on your machine to move to the %ws domain."),
                            DestDomain );
            SetDlgItemText( hDlg, IDD_ABOUT, Buffer );

            CheckDlgButton( hDlg, IDD_RADIO_MAKECOPY, BST_CHECKED );

            if ( MoveOptions & MOVE_NO_PROFILE )
            {
                CheckDlgButton( hDlg, IDD_PROFILE_CHECK, BST_UNCHECKED );

                EnableSection( hDlg, FALSE, ProfileSection,
                                 sizeof( ProfileSection ) /sizeof(DWORD) );
            }
            else
            {
                CheckDlgButton( hDlg, IDD_PROFILE_CHECK, BST_CHECKED );
            }

            CheckDlgButton( hDlg, IDD_UPDATE_SEC, BST_CHECKED );
            EnableWindow( GetDlgItem( hDlg, IDD_UPDATE_SEC ), FALSE );

            //
            // If we're already there, forget it.
            //

            if ( _wcsicmp( MachDomain, DestDomain ) == 0 )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MOVE_MACHINE), FALSE );
            }

            //
            // If the domain already has a DS DC, forget it.
            //

            if ( DcInfo && DcInfo->Flags & DS_DS_FLAG )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MOVE_MACHINE), FALSE );
            }

            return FALSE ;

        case WM_COMMAND:
            switch (LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;

                case IDOK:
                    //
                    // Gather settings
                    //

                    if ( IsDlgButtonChecked( hDlg, IDD_PROFILE_CHECK ) == BST_CHECKED )
                    {
                        MoveOptions |= MOVE_DO_PROFILE ;

                        if ( IsDlgButtonChecked( hDlg, IDD_RADIO_MAKECOPY ) == BST_CHECKED )
                        {
                            MoveOptions |= MOVE_COPY_PROFILE ;
                        }

                        if ( IsDlgButtonChecked( hDlg, IDD_RADIO_MAKE_ROAM ) == BST_CHECKED )
                        {
                            MoveOptions |= MOVE_MAKE_ROAM ;
                        }
                    }

                    if ( IsDlgButtonChecked( hDlg, IDD_MOVE_MACHINE ) == BST_CHECKED )
                    {
                        MoveOptions |= MOVE_CHANGE_DOMAIN ;
                    }

                    if ( IsDlgButtonChecked( hDlg, IDD_UPDATE_SEC ) == BST_CHECKED )
                    {
                        MoveOptions |= MOVE_UPDATE_SECURITY ;
                    }

                    DumpState();

                    DoIt( hDlg );


                    EndDialog( hDlg, IDOK );
                    break;

                case IDD_PROFILE_CHECK:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        if ( IsDlgButtonChecked( hDlg, IDD_PROFILE_CHECK )
                                == BST_CHECKED )
                        {
                            EnableSection( hDlg,
                                           TRUE,
                                           ProfileSection,
                                           sizeof( ProfileSection ) / sizeof(DWORD) );
                        }
                        else
                        {
                            EnableSection( hDlg, FALSE, ProfileSection,
                                            sizeof( ProfileSection ) /sizeof(DWORD) );
                        }
                        return TRUE ;
                    }
                    break;


            }
            return TRUE ;

        default:
            return FALSE ;

    }
}

void
__cdecl
wmain (int argc, WCHAR *argv[])
{
    int Result ;
    NTSTATUS Status ;
    BOOLEAN WasEnabled ;

    VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );
    GetVersionEx( (LPOSVERSIONINFOW) &VersionInfo );

#if DBG
    InitDebugSupport();
#endif
    InitCommonControls();

    DoArgs( argc, argv );

    CreateUiThread();

    if (!Initialize())
    {
        StopUiThread();

        ExitProcess( GetLastError() );
    }

    if ( MoveOptions & MOVE_WHACK_PSTORE )
    {
        DealWithPstore( NewSid );
    }

    if ( MoveOptions & MOVE_NO_UI )
    {
        MoveOptions |= MOVE_COPY_PROFILE | MOVE_UPDATE_SECURITY ;

        DoIt( NULL );
    }

    Result = (int)DialogBox( GetModuleHandle( NULL ),
                    MAKEINTRESOURCE( IDD_MAIN_DLG ),
                    NULL,
                    PromptDlg );

    if ( Result == IDOK )
    {
        Result = MessageBox( NULL, L"The changes require a reboot.  Reboot now?",
                    L"Move Tool",
                    MB_ICONINFORMATION | MB_YESNO );

        if ( Result == IDYES )
        {
            Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                         TRUE, FALSE,
                                         &WasEnabled );

            if ( NT_SUCCESS( Status ) )
            {
                ExitWindowsEx( EWX_FORCE | EWX_REBOOT, 0 );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\moveui.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       moveui.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include "moveme.h"
#include "dialogs.h"

typedef enum _UI_THREAD_STATE {
    ThreadBlock,
    ThreadRunUi,
    ThreadExit
} UI_THREAD_STATE ;

typedef struct _UI_THREAD_INFO {
    HWND    hWnd ;
    HANDLE  UiWait ;
    HANDLE  CallerWait ;
    UI_THREAD_STATE State ;
    ULONG   CurrentString ;
    ULONG   Flags ;
    ULONG   Percentage ;
    PWSTR   Title ;
} UI_THREAD_INFO ;

#define WM_READSTATE    WM_USER + 1

UI_THREAD_INFO UiThreadInfo ;
HINSTANCE Module ;


INT_PTR
CALLBACK
FeedbackDlg(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WCHAR Text[ MAX_PATH ];

    switch ( Message )
    {
        case WM_COMMAND:
            break;

        case WM_INITDIALOG:

            UiThreadInfo.hWnd = hDlg ;

            SetWindowText( hDlg, UiThreadInfo.Title );

            SetDlgItemText( hDlg, IDD_MIGRATING_TEXT, L"" );

            SendMessage( GetDlgItem( hDlg, IDD_MIGRATING_PROGRESS ),
                         PBM_SETSTEP, (WPARAM) 1, 0 );

            SetEvent( UiThreadInfo.CallerWait );

            return TRUE ;

        case WM_READSTATE:
            LoadString( Module, UiThreadInfo.CurrentString, Text, MAX_PATH );
            SetDlgItemText( hDlg, IDD_MIGRATING_TEXT, Text );

            SendMessage( GetDlgItem( hDlg, IDD_MIGRATING_PROGRESS ),
                         PBM_SETPOS, (WPARAM) UiThreadInfo.Percentage, 0 );

            UpdateWindow( GetDlgItem( hDlg, IDD_MIGRATING_PROGRESS ) );
            UpdateWindow( hDlg );

            return TRUE ;

        default:
            break;
    }

    return FALSE ;
}


DWORD
UiThread(
    PVOID Ignored
    )
{
    DebugLog(( DEB_TRACE_UI, "UI Thread starting\n" ));

    SetEvent( UiThreadInfo.CallerWait );

    while ( 1 )
    {
        DebugLog(( DEB_TRACE_UI, "State = %d\n", UiThreadInfo.State ));

        if ( UiThreadInfo.State == ThreadBlock )
        {
            WaitForSingleObjectEx( UiThreadInfo.UiWait, INFINITE, FALSE );
            continue;
        }

        if ( UiThreadInfo.State == ThreadExit )
        {
            ExitThread( 0 );
        }

        if ( UiThreadInfo.State == ThreadRunUi )
        {
            DialogBox( Module,
                       MAKEINTRESOURCE( IDD_MIGRATING ),
                       NULL,
                       FeedbackDlg );

            ResetEvent( UiThreadInfo.UiWait );

            UiThreadInfo.State = ThreadBlock ;
        }
    }

    return 0;
}



BOOL
CreateUiThread(
    VOID
    )
{
    HANDLE hThread ;
    DWORD Tid ;

    if ( MoveOptions & MOVE_NO_UI )
    {
        return TRUE ;
    }

    Module = GetModuleHandle( NULL );

    ZeroMemory( &UiThreadInfo, sizeof( UiThreadInfo ) );

    UiThreadInfo.UiWait = CreateEvent( NULL, FALSE, FALSE, NULL );
    UiThreadInfo.CallerWait = CreateEvent( NULL, FALSE, FALSE, NULL );

    UiThreadInfo.State = ThreadBlock ;

    hThread = CreateThread( NULL, 0,
                    UiThread, 0,
                    0, &Tid );

    if ( hThread )
    {
        CloseHandle( hThread );

        WaitForSingleObjectEx( UiThreadInfo.CallerWait, INFINITE, FALSE );

        return TRUE ;
    }

    return FALSE ;

}

VOID
StopUiThread(
    VOID
    )
{
    if ( MoveOptions & MOVE_NO_UI )
    {
        return ;
    }

    if ( UiThreadInfo.State == ThreadRunUi )
    {
        SendMessage( UiThreadInfo.hWnd, WM_CLOSE, 0, 0 );
    }

    UiThreadInfo.State = ThreadExit ;

    SetEvent( UiThreadInfo.UiWait );
}

VOID
RaiseUi(
    HWND Parent,
    LPWSTR Title
    )
{
    if ( MoveOptions & MOVE_NO_UI )
    {
        return;
    }
    UiThreadInfo.State = ThreadRunUi ;
    UiThreadInfo.Title = Title ;

    DebugLog(( DEB_TRACE_UI, "Raise:  State = %d, pulsing event\n",
                UiThreadInfo.State ));

    ResetEvent( UiThreadInfo.CallerWait );
    SetEvent( UiThreadInfo.UiWait );

    WaitForSingleObjectEx( UiThreadInfo.CallerWait, INFINITE, FALSE );

}

VOID
UpdateUi(
    DWORD   StringId,
    DWORD   Percentage
    )
{
    if ( MoveOptions & MOVE_NO_UI )
    {
        return;
    }
    if ( UiThreadInfo.State == ThreadRunUi )
    {
        UiThreadInfo.CurrentString = StringId ;
        UiThreadInfo.Percentage = Percentage ;

        SendMessage( UiThreadInfo.hWnd, WM_READSTATE, 0, 0 );

    }

    if ( Percentage == 100 )
    {
        EndDialog( UiThreadInfo.hWnd, IDOK );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#define IDS_COPYING_USER_HIVE       1001
#define IDS_CREATING_NEW_PROFILE    1002
#define IDS_COPYING_OLD_PROFILE     1003

#define IDS_INIT_READ_NAMES         1010
#define IDS_INIT_DISCOVER_DCS       1011
#define IDS_INIT_LOOKUP_ACCOUNTS    1012

#define IDS_MOVE_DOMAIN             1020

#define IDS_SEC_LOCAL_SETTINGS      1030
#define IDS_SEC_LOCAL_ADMIN         1031
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\moveme\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       util.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------




#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include <userenv.h>
#include <userenvp.h>

#include <lm.h>
#include "moveme.h"


#define USER_SHELL_FOLDER         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define PROFILE_LIST_PATH         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define PROFILE_FLAGS             TEXT("Flags")
#define PROFILE_STATE             TEXT("State")
#define PROFILE_IMAGE_VALUE_NAME  TEXT("ProfileImagePath")
#define PROFILE_CENTRAL_PROFILE   TEXT("CentralProfile")
#define CONFIG_FILE_PATH          TEXT("%SystemRoot%\\Profiles\\")
#define USER_PREFERENCE           TEXT("UserPreference")
#define PROFILE_BUILD_NUMBER      TEXT("BuildNumber")
#define TEMP_PROFILE_NAME_BASE    TEXT("TEMP")
#define DELETE_ROAMING_CACHE      TEXT("DeleteRoamingCache")
#define USER_PROFILE_MUTEX        TEXT("userenv:  User Profile Mutex")

LPTSTR
SidToString(
    PSID Sid
    )
{
    UNICODE_STRING String ;
    NTSTATUS Status ;

    Status = RtlConvertSidToUnicodeString( &String, Sid, TRUE );

    if ( NT_SUCCESS( Status ) )
    {
        return String.Buffer ;
    }
    return NULL ;

}

VOID
FreeSidString(
    LPTSTR SidString
    )
{
    UNICODE_STRING String ;

    RtlInitUnicodeString( &String, SidString );

    RtlFreeUnicodeString( &String );
}

//*************************************************************
//
//  GetUserProfileDirectory()
//
//  Purpose:    Returns the root of the user's profile directory.
//
//  Parameters: hToken          -   User's token
//              lpProfileDir    -   Output buffer
//              lpcchSize       -   Size of output buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              9/18/95     ericflo    Created
//
//*************************************************************

BOOL
WINAPI
GetUserProfileDirectoryFromSid(
    PSID Sid,
    LPTSTR lpProfileDir,
    LPDWORD lpcchSize
    )
{
    DWORD  dwLength = MAX_PATH * sizeof(TCHAR);
    DWORD  dwType;
    BOOL   bRetVal = FALSE;
    LPTSTR lpSidString;
    TCHAR  szBuffer[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    HKEY   hKey;
    LONG   lResult;


    //
    // Retrieve the user's sid string
    //

    lpSidString = SidToString( Sid );

    if (!lpSidString) {
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    if (lResult != ERROR_SUCCESS) {
        FreeSidString(lpSidString);
        return FALSE;
    }

    lResult = RegQueryValueEx(hKey,
                              PROFILE_IMAGE_VALUE_NAME,
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwLength);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        FreeSidString(lpSidString);
        return FALSE;
    }


    //
    // Clean up
    //

    RegCloseKey(hKey);
    FreeSidString(lpSidString);



    //
    // Expand and get the length of string
    //

    ExpandEnvironmentStrings(szBuffer, szDirectory, MAX_PATH);

    dwLength = lstrlen(szDirectory) + 1;


    //
    // Save the string if appropriate
    //

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

BOOL
SetUserProfileDirectory(
    PSID Base,
    PSID Copy
    )
{
    LPTSTR lpSidString;
    TCHAR  szBuffer[MAX_PATH];
    HKEY   hKey;
    HKEY   hNewKey ;
    LONG   lResult;
    DWORD  Disp ;
    WCHAR  CopyBuffer[ MAX_PATH ] ;
    DWORD  CopySize ;
    DWORD ValueCount ;
    DWORD ValueNameLen ;
    DWORD ValueDataLen ;
    PUCHAR Value ;
    DWORD Type ;
    DWORD Index ;
    DWORD NameSize ;
    //
    // Retrieve the user's sid string
    //

    lpSidString = SidToString( Base );

    if (!lpSidString) {
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    FreeSidString( lpSidString );

    if ( lResult != 0 )
    {
        return FALSE ;
    }


    //
    // Retrieve the user's sid string
    //

    lpSidString = SidToString( Copy );

    if (!lpSidString) {
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                              szBuffer,
                              0,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &hNewKey,
                              &Disp );


    FreeSidString( lpSidString );

    if ( lResult != 0 )
    {
        return FALSE ;
    }

    //
    // Copy Key:
    //

    lResult = RegQueryInfoKey( hKey,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ValueCount,
                               &ValueNameLen,
                               &ValueDataLen,
                               NULL,
                               NULL );

    if ( lResult != 0 )
    {
        return FALSE ;
    }

    Value = LocalAlloc( LMEM_FIXED, ValueDataLen );

    if ( Value )
    {
        Index = 0 ;

        do
        {
            CopySize = ValueDataLen ;
            NameSize = MAX_PATH ;

            lResult = RegEnumValue( hKey,
                                    Index,
                                    CopyBuffer,
                                    &NameSize,
                                    NULL,
                                    &Type,
                                    Value,
                                    &CopySize );

            if ( lResult == 0 )
            {
                lResult = RegSetValueEx( hNewKey,
                                         CopyBuffer,
                                         0,
                                         Type,
                                         Value,
                                         CopySize );
            }

            ValueCount-- ;
            Index ++ ;

        } while ( ValueCount );

        LocalFree( Value );

    }

    lResult = RegSetValueEx( hNewKey,
                             TEXT("Sid"),
                             0,
                             REG_BINARY,
                             Copy,
                             RtlLengthSid( Copy )
                             );

    if (lResult == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

LONG
MyRegSaveKey(
    HKEY Key,
    LPTSTR File,
    LPSECURITY_ATTRIBUTES lpsa
    )
{
    BOOL bResult = TRUE;
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;


    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status))
    {
        error = RegSaveKey( Key, File, lpsa );

        Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }
    else
    {
        error = RtlNtStatusToDosError( Status );
    }

    return error ;

}

BOOL
GetPrimaryDomain(
    PWSTR Domain
    )
{
    NTSTATUS Status, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
    BOOL    PrimaryDomainPresent = FALSE;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to open local LsaPolicyObject, Status = 0x%lx\n", Status));
        return(FALSE);
    }

    //
    // Get the primary domain info
    //
    Status = LsaQueryInformationPolicy(LsaHandle,
                                       PolicyPrimaryDomainInformation,
                                       (PVOID *)&PrimaryDomainInfo);
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", Status));

        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(FALSE);
    }

    //
    // Copy the primary domain name into the return string
    //

    if (PrimaryDomainInfo->Sid != NULL) {

        PrimaryDomainPresent = TRUE;

        if ( Domain )
        {
            CopyMemory( Domain, PrimaryDomainInfo->Name.Buffer,
                        PrimaryDomainInfo->Name.Length + 2 );

        }
    }

    //
    // We're finished with the Lsa
    //

    IgnoreStatus = LsaFreeMemory(PrimaryDomainInfo);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = LsaClose(LsaHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(PrimaryDomainPresent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\razacl\razacl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       razacl.c
//
//  Contents:
//
//  History:    4/16/2001    richardw     Created
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <sddl.h>
#include <lm.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

UNICODE_STRING  SddlFile ;
UNICODE_STRING  SourceDir ;
UNICODE_STRING  RootDir ;
UNICODE_STRING  ExtraDirs[] ;

BOOL    Background ;
BOOL    DoShares ;
BOOL    CreateSddl ;
BOOL    Force ;
DWORD   DebugFlag ;
BOOL    AddSelf ;
BOOL    DoSacl ;

SECURITY_INFORMATION    SecurityInfo ;

typedef DWORD
(NTAPI FS_WALK_CALLBACK)(
    PVOID Parameter,
    PWSTR File
    );

typedef struct _FS_ENGINE_STATS {

    ULONG   Files ;
    ULONG   Directories ;
    ULONG   EngineErrors ;
    ULONG   CallbackErrors ;
} FS_ENGINE_STATS, * PFS_ENGINE_STATS ;

typedef FS_WALK_CALLBACK * PFS_WALK_CALLBACK ;

typedef struct _FS_WALK_CONTROL {

    PVOID Parameter ;
    PFS_WALK_CALLBACK Callback ;
    ULONG Options ;

    PFS_ENGINE_STATS Stats ;
    HANDLE Search ;
    WCHAR CurrentPath[ MAX_PATH ];
    WCHAR SearchPath[ MAX_PATH ];
    WCHAR FilePath[ MAX_PATH ];
} FS_WALK_CONTROL, * PFS_WALK_CONTROL ;



typedef struct _PARAM {
    LPSTR   Argument ;
    ULONG   Flags ;
    PVOID   Value ;
    PVOID   Default ;
} PARAM, * PPARAM ;


#define PARAM_TYPE_STRING   0x00000001
#define PARAM_TYPE_ULONG    0x00000002
#define PARAM_TYPE_BOOL     0x00000003
#define PARAM_TYPE_MASK     0x0000FFFF

#define PARAM_TYPE_SINGLE   0x00010000          // Single value
#define PARAM_TYPE_COMMA    0x00020000          // Comma separated multi value
#define PARAM_TYPE_OPTIONAL 0x00040000          // Optional value
#define PARAM_TYPE_REQUIRED 0x00080000          // Required argument
#define PARAM_TYPE_HIDDEN   0x00100000          // Not dumped during help
#define PARAM_TYPE_MULTIPLE 0x00200000          // Can be specified multiple times

#define PARAM_TYPE_FOUND    0x10000000          // Found during arg scan


PARAM Parameters[] = {
    { "background", PARAM_TYPE_BOOL, &Background, (PVOID) FALSE },
    { "sddlfile", PARAM_TYPE_STRING | PARAM_TYPE_REQUIRED, &SddlFile, (PVOID) NULL },
    { "shares", PARAM_TYPE_BOOL | PARAM_TYPE_SINGLE | PARAM_TYPE_OPTIONAL, &DoShares, (PVOID) NULL },
    { "source", PARAM_TYPE_STRING | PARAM_TYPE_SINGLE, &SourceDir, (PVOID) NULL },
    { "createsddl", PARAM_TYPE_BOOL | PARAM_TYPE_SINGLE | PARAM_TYPE_OPTIONAL, &CreateSddl, (PVOID) NULL },
    { "root", PARAM_TYPE_STRING | PARAM_TYPE_REQUIRED, &RootDir, (PVOID) NULL },
    { "force", PARAM_TYPE_BOOL | PARAM_TYPE_SINGLE | PARAM_TYPE_OPTIONAL, &Force, (PVOID) NULL },
    { "debug", PARAM_TYPE_ULONG | PARAM_TYPE_HIDDEN, &DebugFlag, (PVOID) NULL },
    { "addself", PARAM_TYPE_BOOL | PARAM_TYPE_SINGLE | PARAM_TYPE_OPTIONAL, &AddSelf, (PVOID) TRUE },
    { "sacl", PARAM_TYPE_BOOL | PARAM_TYPE_SINGLE | PARAM_TYPE_OPTIONAL, &DoSacl, (PVOID) NULL }

};

#define ARGSET  ( (sizeof ( Parameters ) / sizeof( PARAM ) ) )

VOID
DECLSPEC_NORETURN
Usage(
    char * Me
    )
{
    int i ;
    printf("%s - usage\n", Me);
    for ( i = 0 ; i < ARGSET ; i++ )
    {
        if ( ( Parameters[ i ].Flags & PARAM_TYPE_HIDDEN ) == 0 )
        {
            printf("\t/%s%s\n", Parameters[i].Argument,
                Parameters[ i ].Flags & PARAM_TYPE_SINGLE ? "" : ":value"   );
        }
    }
    exit(1);
}

VOID
FatalError(
    PWSTR   Message,
    DWORD   Error,
    PWSTR   Object
    )
{
    if ( Object )
    {
        fprintf( stderr, "Fatal error %d while working on object %ws\n",
            Error, Object );
        fputws( Message, stderr );
        fputws( L"\n", stderr );

    }
    else
    {
        fprintf( stderr, "Fatal error %d, %s\n", Error, Message );
    }
    exit( Error );

}


VOID
DoParam(
    int argc,
    char * argv[]
    )
{
    int i ;
    int j ;
    PSTR Arg ;
    PSTR Colon;
    PSTR Format ;
    BOOL Bail = FALSE ;

    //
    // Initialize Defaults:
    //

    for ( j = 0 ; j < ARGSET ; j++ )
    {
        switch ( Parameters[ j ].Flags & PARAM_TYPE_MASK )
        {
            case PARAM_TYPE_STRING:
                if ( Parameters[ j ].Default )
                {
                    RtlInitUnicodeString( (PUNICODE_STRING) Parameters[ j ].Value,
                                          (LPWSTR) Parameters[ j ].Default );

                }
                else
                {
                    ZeroMemory( Parameters[ j ].Value, sizeof( UNICODE_STRING ) );
                }
                break;

            case PARAM_TYPE_ULONG:
                * ((PULONG) Parameters[ j ].Value) = (ULONG) ((ULONG_PTR) Parameters[ j ].Default );
                break;

            case PARAM_TYPE_BOOL:
                * ((PBOOL) Parameters[ j ].Value) = (BOOL) ((ULONG_PTR) Parameters[ j ].Default );
                break;

            default:
                break;


        }

    }

    for ( i = 1 ; i < argc ; i++ )
    {
        Arg=argv[i];

        if ( (*Arg == '/') ||
             (*Arg == '-')  )
        {

            Arg++ ;

            Colon = strchr( Arg, ':' );

            if ( Colon )
            {
                *Colon = '\0';
            }

            //
            // Scan through the possible arguments
            //

            for ( j = 0 ; j < ARGSET ; j++ )
            {
                if ( _stricmp( Arg, Parameters[ j ].Argument ) == 0 )
                {
                    //
                    // Found a parameter that matched.  Now, check the supplied type:
                    //

                    if ( ( Parameters[ j ].Flags & PARAM_TYPE_FOUND ) &&
                         ! ( Parameters[ j ].Flags & PARAM_TYPE_MULTIPLE ) )
                    {
                        printf("%s can be specified only once\n", Arg );
                        Usage( argv[0] );
                    }

                    if ( Colon )
                    {
                        *Colon++ = ':' ;
                    }

                    if ( ( (Parameters[ j ].Flags & PARAM_TYPE_OPTIONAL) == 0 ) &&
                         ( ( Colon == NULL ) || ( *Colon == '\0' ) ) )
                    {
                        printf("%s needs a value with it\n", Arg );
                        Usage( argv[0] );

                    }

                    if ( ( Colon != NULL ) &&
                        ( Parameters[ j ].Flags & PARAM_TYPE_SINGLE ) )
                    {
                        printf("%s takes no value\n", Arg );
                        Usage( argv[0] );
                    }


                    switch ( Parameters[ j ].Flags & PARAM_TYPE_MASK )
                    {
                        case PARAM_TYPE_STRING:

                            if ( !RtlCreateUnicodeStringFromAsciiz(
                                        (PUNICODE_STRING) Parameters[ j ].Value,
                                        Colon ) )
                            {
                                printf("out of memory\n");
                                Usage( argv[0] );
                            }
                            break;

                        case PARAM_TYPE_ULONG:

                            if ( !Colon )
                            {
                                *((PULONG) Parameters[ j ].Value) = 0 ;
                            }
                            else
                            {
                                Format = "%ul" ;

                                if ( *Colon == '0' )
                                {
                                    //
                                    // Possible different base.
                                    //

                                    if ( *(Colon + 1 ) )
                                    {
                                        switch ( *(Colon + 1) )
                                        {
                                            case 'x':
                                                Format = "%x" ;
                                                break;

                                            case 'X':
                                                Format = "%X" ;
                                                break;

                                            default:
                                                Format = "%ul" ;
                                                break;

                                        }
                                    }

                                }

                                sscanf( Colon, Format, Parameters[ j ].Value );
                            }
                            break;

                        case PARAM_TYPE_BOOL:
                            if ( !Colon )
                            {
                                *((PBOOL) Parameters[ j ].Value ) =  TRUE ;
                            }
                            else
                            {
                                if ( *Colon == '1' )
                                {
                                    *((PBOOL) Parameters[ j ].Value ) =  TRUE ;
                                }
                                else
                                {
                                    *((PBOOL) Parameters[ j ].Value ) =  FALSE ;
                                }
                            }
                            break;
                        default:
                            Usage( argv[ 0 ] );
                    }

                    Parameters[ j ].Flags |= PARAM_TYPE_FOUND ;

                    break;  // break out of for loop
                }

            }
            if ( j == ARGSET )
            {
                printf("-%s unrecognized\n", Arg );
                Usage( argv[ 0 ] );
            }

        }
        else
        {
            printf("%s unexpected\n", Arg );
            Usage( argv[0] );
        }


    }

    //
    // Validate input:
    //

    Bail = FALSE ;

    for ( j = 0 ; j < ARGSET ; j++ )
    {
        if ( (Parameters[ j ].Flags & PARAM_TYPE_REQUIRED)  )
        {
            if ( ! ( Parameters[ j ].Flags & PARAM_TYPE_FOUND ) )
            {
                printf(" /%s missing\n", Parameters[ j ].Argument );
                Bail = TRUE ;

            }

        }

    }

    if ( Bail )
    {
        Usage( argv[ 0 ] );
    }

}

BOOL
CheckRootFileSystem(
    VOID
    )
{
    WCHAR Volume[ 8 ];
    WCHAR Temp[ MAX_PATH ];
    DWORD Size ;
    DWORD FsFlags ;


    if ( RootDir.Buffer[ 1 ] == L':' )
    {
        Volume[ 0 ] = RootDir.Buffer[ 0 ];
        Volume[ 1 ] = RootDir.Buffer[ 1 ];
    }
    else
    {
        Size = MAX_PATH ;

        GetCurrentDirectory( MAX_PATH, Temp );

        Volume[ 0 ] = Temp[ 0 ];
        Volume[ 1 ] = Temp[ 1 ];

    }

    Volume[ 2 ] = L'\\';
    Volume[ 3 ] = L'\0';

    if ( GetVolumeInformation(
            Volume,
            NULL,
            0,
            NULL,
            &Size,
            &FsFlags,
            Temp,
            MAX_PATH ) )
    {
        if ( FsFlags & FS_PERSISTENT_ACLS )
        {
            return TRUE ;
        }
    }

    return FALSE ;
}

PWSTR
GetTargetOfReparse(
    PWSTR ReparsePoint
    )
{
    HANDLE Handle ;
    NTSTATUS Status ;
    OBJECT_ATTRIBUTES ObjA ;
    UNICODE_STRING UnicodeName ;
    NTSTATUS IgnoreStatus ;
    IO_STATUS_BLOCK IoStatusBlock ;
    PWSTR Target = NULL ;

    FILE_DISPOSITION_INFORMATION Disposition;

    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer = NULL;
    ULONG ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;
    USHORT ReparseDataLength = 0;
    ULONG DesiredAccess ;
    ULONG CreateOptions ;

    IgnoreStatus = RtlDosPathNameToNtPathName_U(
                            ReparsePoint,
                            &UnicodeName,
                            NULL,
                            NULL
                            );

    if ( !NT_SUCCESS( IgnoreStatus ) )
    {
        return NULL ;
    }


    InitializeObjectAttributes(
        &ObjA,
        &UnicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    DesiredAccess = FILE_READ_DATA | SYNCHRONIZE;
    CreateOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;


    //
    //  Open the reparse point for query.
    //

    Status = NtOpenFile(
                 &Handle,
                 DesiredAccess,
                 &ObjA,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 CreateOptions
                 );

    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeName.Buffer );

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }


    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseBuffer = RtlAllocateHeap(
                        RtlProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        ReparseDataLength
                        );

    if (ReparseBuffer == NULL) {

        FatalError( L"No memory", ERROR_OUTOFMEMORY, ReparsePoint );
    }

    //
    //  Now go and get the data.
    //

    Status = NtFsControlFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_GET_REPARSE_POINT,        // no input buffer
                 NULL,                 // input buffer length
                 0,
                 (PVOID)ReparseBuffer,
                 ReparseDataLength
                 );



    //
    //  Close the file and free the buffer.
    //

    NtClose( Handle );

    //
    //  Display the buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;

    if ((ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) ||
        (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK)) {

        if ( DebugFlag )
        {
            UNICODE_STRING NtLinkValue ;

            NtLinkValue.Buffer = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[ 0 ];
            NtLinkValue.Length = ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength;
            NtLinkValue.MaximumLength = NtLinkValue.Length ;

            printf("base path is %wZ\n", &NtLinkValue );
            
        }


        Target = LocalAlloc( LMEM_FIXED, 
                    (ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength + 1) * sizeof( WCHAR ) );

        if ( Target )
        {
            RtlCopyMemory(
                Target,
                &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[ ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof( WCHAR ) + 1 ],
                ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength
                );
            
        }

    }

    else {
    }

    //
    //  Free the buffer.
    //

    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );

    return Target ;
}




PSECURITY_DESCRIPTOR
GetRootSecurity(
    VOID
    )
{
    HANDLE hRoot ;
    NTSTATUS Status ;
    BOOLEAN WasEnabled ;
    PSECURITY_DESCRIPTOR psd ;
    ULONG Size ;
    SECURITY_INFORMATION si ;
    ACCESS_MASK access ;
    DWORD Returned ;

    si = DACL_SECURITY_INFORMATION ;
    access = READ_CONTROL ;

    if ( DoSacl )
    {
        Status = RtlAdjustPrivilege(
                        SE_SECURITY_PRIVILEGE,
                        TRUE,
                        FALSE,
                        &WasEnabled );

        if ( NT_SUCCESS( Status ) )
        {
            si |= SACL_SECURITY_INFORMATION ;
            access |= ACCESS_SYSTEM_SECURITY ;
        }
        
    }


    Size = 0 ;
    psd = NULL ;

    GetFileSecurity(
                RootDir.Buffer,
                si,
                NULL,
                0,
                &Size );

    psd = LocalAlloc( LMEM_FIXED, Size );

    if ( !GetFileSecurity(
                    RootDir.Buffer,
                    si,
                    psd,
                    Size,
                    &Size ) )
    {
        FatalError( L"Could not read security descriptor",
                    GetLastError(),
                    RootDir.Buffer );

    }



    return psd ;
}

DWORD
WriteSddlFile(
    VOID
    )
{
    PSECURITY_DESCRIPTOR psd ;
    ULONG Size ;
    LPSTR AnsiStringSD ;
    ULONG AnsiStringSDLen ;
    HANDLE hSddlFile ;
    CHAR Term[ 2 ] = { 0x0d, 0x0a };

    psd = GetRootSecurity();

    if ( !ConvertSecurityDescriptorToStringSecurityDescriptorA(
            psd,
            1,
            DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION,
            &AnsiStringSD,
            &AnsiStringSDLen ) )
    {

        FatalError( L"Cannot convert security descriptor to string\n",
                    GetLastError(),
                    NULL );

    }


    hSddlFile = CreateFile(
                    SddlFile.Buffer,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

    if ( hSddlFile == INVALID_HANDLE_VALUE )
    {
        FatalError(
            L"Cannot write security descriptor to file",
            GetLastError(),
            SddlFile.Buffer );

    }

    WriteFile(
        hSddlFile,
        AnsiStringSD,
        AnsiStringSDLen,
        &Size,
        NULL );

    LocalFree( AnsiStringSD );

    WriteFile(
        hSddlFile,
        Term, sizeof(Term),
        &Size, NULL );

    CloseHandle( hSddlFile );

    return 0;

}

PSECURITY_DESCRIPTOR
InsertMe(
    PSECURITY_DESCRIPTOR old,
    ACCESS_MASK AccessRequired
    )
{
    DWORD Size ;
    PACL OldAcl ;
    PACL NewAcl ;
    BOOL Present ;
    BOOL Ignored ;
    ACL_SIZE_INFORMATION AclSize ;
    PSID Me = NULL ;
    HANDLE hToken ;
    UCHAR Scratch[ SECURITY_MAX_SID_SIZE + sizeof( TOKEN_USER ) ];
    PTOKEN_USER User ;
    PACCESS_ALLOWED_ACE  NewAce ;
    PACCESS_ALLOWED_ACE OldAce ;
    PSECURITY_DESCRIPTOR psd ;


    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) )
    {
        if ( GetTokenInformation( hToken, TokenUser, Scratch, sizeof( Scratch ), &Size ) )
        {
            User = (PTOKEN_USER) Scratch ;

            Me = User->User.Sid ;
            
        }
        
        CloseHandle( hToken );
    }

    if ( !Me )
    {
        return NULL ;
        
    }


    GetSecurityDescriptorDacl(old, &Present, &OldAcl, &Ignored );
    if ( !Present )
    {
        return NULL ;
        
    }

    GetAclInformation( OldAcl, &AclSize, sizeof( AclSize ), AclSizeInformation );

    NewAcl = LocalAlloc(LMEM_FIXED, AclSize.AclBytesInUse + (sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( Me )));

    if ( !NewAcl )
    {
        return NULL ;
    }

    InitializeAcl( NewAcl, AclSize.AclBytesInUse + (sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( Me ) ), ACL_REVISION );

    AddAccessAllowedAce( NewAcl, ACL_REVISION, AccessRequired, Me );

    FindFirstFreeAce( NewAcl, &NewAce );

    GetAce( OldAcl, 0, &OldAce );

    CopyMemory( NewAce, OldAce, AclSize.AclBytesInUse - sizeof( ACL ));

    NewAcl->AceCount += (USHORT) AclSize.AceCount ;

    psd = LocalAlloc(LMEM_FIXED, sizeof( SECURITY_DESCRIPTOR ) );

    if ( psd )
    {
        InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );

        SetSecurityDescriptorDacl(psd, TRUE, NewAcl, FALSE );
        
    }

    return psd ;

}

//+---------------------------------------------------------------------------
//
//  Function:   ReadSecurityDescriptor
//
//  Synopsis:   
//
//  Arguments:  [SddlFileName] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
ReadSecurityDescriptor(
    PWSTR SddlFileName
    )
{

    HANDLE hFile ;
    PSECURITY_DESCRIPTOR psd ;
    ULONG Size ;
    ULONG SizeRead ;
    PUCHAR Buffer ;
    PSECURITY_DESCRIPTOR psdNew ;


    hFile = CreateFileW(
                    SddlFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        FatalError(
            L"Unable to read ACL file",
            GetLastError(),
            SddlFile.Buffer );

    }

    Size = GetFileSize( hFile, NULL );

    if ( Size == (DWORD) -1 )
    {
        FatalError(
            L"ACL file corrupt, too large",
            0,
            NULL );

    }

    Buffer = LocalAlloc( LMEM_FIXED, Size + 1 );

    if ( !Buffer )
    {
        FatalError(
            L"Out of memory",
            GetLastError(),
            NULL );

    }

    if ( !ReadFile( hFile, Buffer, Size, &SizeRead, NULL ) )
    {
        FatalError(
            L"Unable to read ACL file",
            GetLastError(),
            SddlFile.Buffer );


    }

    CloseHandle( hFile );

    Buffer[ Size ] = '\0';

    while ( ( Buffer[ Size - 1 ] == 0x0a ) ||
            ( Buffer[ Size - 1 ] == 0x0d ) ||
            ( Buffer[ Size - 1 ] == 0x1a ) )
    {
        Buffer[ Size - 1 ] = '\0' ;
        Size-- ;

    }

    if ( !ConvertStringSecurityDescriptorToSecurityDescriptorA(
                Buffer,
                1,
                &psd,
                &Size ) )
    {

        FatalError(
            L"ACL file is corrupt",
            GetLastError(),
            SddlFile.Buffer );
    }

    LocalFree( Buffer );

    if ( AddSelf )
    {
        //
        // Need to merge in a sid for "me"
        //

        psdNew = InsertMe( psd, FILE_ALL_ACCESS );

        if ( psdNew )
        {
            LocalFree( psd );
            psd = psdNew ;
            
        }
        
    }

    return psd ;

}

BOOL
WalkCallback(
    PVOID Parameter,
    PWSTR Path
    )
{


    return SetFileSecurity(
            Path,
            SecurityInfo,
            Parameter );

}

BOOL
WalkEngine(
    PFS_WALK_CONTROL Control
    )
{
    PFS_WALK_CONTROL NewControl ;
    WIN32_FIND_DATA FindData ;
    PWSTR Scan;
    BOOL CallbackStatus ;
    DWORD Status ;
    DWORD FileTest ;
    DWORD Limit ;
    PSECURITY_DESCRIPTOR psd = NULL ;
    //
    // First, check for an override file:
    //

    if ( wcslen( Control->CurrentPath ) > MAX_PATH - 7 )
    {
        return FALSE ;
        
    }

    wcsncpy( Control->SearchPath, Control->CurrentPath, MAX_PATH );
    wcscat( Control->SearchPath, L"acl.txt" );

    FileTest = GetFileAttributes( Control->SearchPath );
    if ( FileTest != (DWORD) -1 )
    {
        //
        // File exists.  Load it and use it for all files from here on down
        //

        psd = ReadSecurityDescriptor( Control->SearchPath );

        if ( psd )
        {
            Control->Parameter = psd ;
        }

    }


    wcscpy( Control->SearchPath, Control->CurrentPath );
    wcscat( Control->SearchPath, L"*.*" );

    Control->Search = FindFirstFile( Control->SearchPath, &FindData );

    if ( Control->Search )
    {
        wcscpy( Control->FilePath, Control->CurrentPath);
        Scan = &Control->FilePath[ wcslen( Control->FilePath ) ];     // one char past trailing backslash
        Limit = MAX_PATH - wcslen( Control->FilePath );

        do
        {

            if ( wcslen( FindData.cFileName ) > Limit )
            {
                Control->Stats->EngineErrors++ ;
                fprintf(stderr, "File '%ws' in directory '%ws' exceeds maximum length",
                            FindData.cFileName, Control->CurrentPath );
                continue;
                
            }
            wcscpy( Scan, FindData.cFileName );

            if ( wcscmp( Scan,L".." ) == 0 )
            {
                //
                // always immediately skip the parent link
                //
                continue;
                
            }


            CallbackStatus = Control->Callback(
                                        Control->Parameter,
                                        Control->FilePath );

            if ( !CallbackStatus )
            {
                Control->Stats->CallbackErrors ++ ;
            }

            if ( wcscmp( Scan, L".") == 0 ) 
            {
                //
                // allow for processing the current directory,
                // but do not recurse...
                //
                continue;

            }

            if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                //
                // Time to recurse (we do depth first, it's easier)
                //

                Control->Stats->Directories++ ;

                NewControl = LocalAlloc( LMEM_FIXED, sizeof( FS_WALK_CONTROL ) );

                if ( NewControl )
                {
                    NewControl->Callback = Control->Callback ;
                    NewControl->Parameter = Control->Parameter ;
                    NewControl->Options = Control->Options ;
                    NewControl->Stats = Control->Stats ;

                    wcscpy(NewControl->CurrentPath, Control->FilePath );
                    wcscat(NewControl->CurrentPath, L"\\");

                    WalkEngine( NewControl );

                    LocalFree( NewControl );

                }
                else
                {

                    Control->Stats->EngineErrors ++ ;
                }


            }
            else
            {
                Control->Stats->Files++ ;

            }

        } while ( FindNextFile( Control->Search, &FindData )  );

        FindClose( Control->Search );

    }
    else
    {
        Control->Stats->EngineErrors++ ;
    }

    if ( psd )
    {
        LocalFree( psd );
    }

    return TRUE ;

}

BOOL
WalkTree(
    PWSTR StartPath,
    ULONG Options,
    PFS_WALK_CALLBACK Callback,
    PVOID Parameter
    )
{

    PFS_WALK_CONTROL Control ;
    FS_ENGINE_STATS Stats ;
    PWSTR Scan;

    Control = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof( FS_WALK_CONTROL ) );

    if ( !Control )
    {
        return FALSE ;

    }

    ZeroMemory( &Stats, sizeof( Stats ) );

    Control->Callback = Callback ;
    Control->Parameter = Parameter ;
    Control->Options = 0 ;
    Control->Stats = &Stats ;

    wcscpy( Control->CurrentPath, StartPath );
    Scan = &Control->CurrentPath[ wcslen( Control->CurrentPath ) - 1 ];
    if ( *Scan != L'\\' )
    {
        Scan++ ;
        *Scan = L'\\';

    }

    if ( !Callback( Parameter, StartPath ) )
    {
        Stats.CallbackErrors++ ;
        
    }

    Stats.Directories = 1;

    WalkEngine(Control);

    if ( DebugFlag )
    {
        printf("Directories \t%d\n", Stats.Directories );
        printf("Files       \t%d\n", Stats.Files );
        printf("EngineErrors\t%d\n", Stats.EngineErrors );
        printf("CallbackErrors\t%d\n", Stats.CallbackErrors );



    }

    return TRUE ;
}




BOOL
UpdateAcls(
    VOID
    )
{

    PSECURITY_DESCRIPTOR psd ;
    NTSTATUS Status ;
    SECURITY_INFORMATION si ;
    SECURITY_DESCRIPTOR_CONTROL control ;
    ULONG ignored;
    BOOLEAN WasEnabled ;

    psd = ReadSecurityDescriptor( SddlFile.Buffer );


    if ( !psd )
    {
        return FALSE ;

    }

    RtlGetControlSecurityDescriptor(psd,&control,&ignored);

    si = 0 ;

    if ( control & SE_DACL_PRESENT )
    {
        si |= DACL_SECURITY_INFORMATION ;

    }

    if ( control & SE_SACL_PRESENT )
    {

        Status = RtlAdjustPrivilege(
                        SE_SECURITY_PRIVILEGE,
                        TRUE,
                        FALSE,
                        &WasEnabled );

        if ( NT_SUCCESS( Status ) )
        {
            si |= SACL_SECURITY_INFORMATION ;
        }
    }

    SecurityInfo = si ;

    printf("Updating ACLs from %ws for tree %ws\n",
        SddlFile.Buffer, RootDir.Buffer );

    WalkTree(RootDir.Buffer, 0, WalkCallback, psd );


    return TRUE ;
}

BOOL
TestAcl(
    VOID
    )
{
    PSECURITY_DESCRIPTOR Current ;
    PSECURITY_DESCRIPTOR Stored ;
    PACL CurrentAcl ;
    PACL StoredAcl ;
    ULONG CurrentLength ;
    ULONG StoredLength ;
    BOOL Match = FALSE ;
    NTSTATUS Status ;
    BOOLEAN Present ;
    BOOLEAN Defaulted ;
    ACL_SIZE_INFORMATION AclSize ;

    Stored = ReadSecurityDescriptor( SddlFile.Buffer );

    Status = RtlGetDaclSecurityDescriptor(Stored,&Present,&StoredAcl,&Defaulted);

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
        
    }

    Current = GetRootSecurity();

    Status = RtlGetDaclSecurityDescriptor(Current,&Present,&CurrentAcl,&Defaulted);
    
    if ( !NT_SUCCESS( Status ) || (CurrentAcl == NULL) )
    {
        return FALSE ;
        
    }

    Status = RtlQueryInformationAcl(StoredAcl,&AclSize,sizeof(AclSize),AclSizeInformation);

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
        
    }

    StoredLength = AclSize.AclBytesInUse ;

    Status = RtlQueryInformationAcl( CurrentAcl,&AclSize,sizeof(AclSize), AclSizeInformation );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
        
    }

    CurrentLength = AclSize.AclBytesInUse;

    if ( CurrentLength == StoredLength )
    {
        Match = RtlEqualMemory(
                    CurrentAcl, 
                    StoredAcl,
                    CurrentLength );
    }

    LocalFree( Stored );
    LocalFree( Current );

    return Match ;

}


int __cdecl main (int argc, char *argv[])
{

    DoParam( argc, argv );

    if ( DebugFlag )
    {
        printf("SDDL File   \t%ws\n", SddlFile.Buffer );
        printf("Root Dir    \t%ws\n", RootDir.Buffer );


    }

    if ( CreateSddl )
    {
        WriteSddlFile();
        return 0 ;
    }

    if ( !CheckRootFileSystem() )
    {
        printf("Volume does not support ACLs\n" );
        return 0 ;
    }

    if ( !Force )
    {
        if ( TestAcl() )
        {
            if ( DebugFlag )
            {
                printf("ACL is up-to-date\n" );
            }
            return 0 ;

        }

    }


    UpdateAcls();


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\setspn\setspn.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       setspn.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-30-98   RichardW   Created
//      8-10-99   JBrezak    Turned into setspn added list capability
//              09-22-99  Jaroslad   support for adding/removing arbitrary SPNs
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <secext.h>
#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <ntdsapi.h>
#include <ntdsapip.h>   // private DS_NAME_FORMATS
#include <stdio.h>
#include <winldap.h>
#include <shlwapi.h>

//
// General arrary count.
//

#ifndef COUNTOF
    #define COUNTOF(s) ( sizeof( (s) ) / sizeof( *(s) ) )
#endif // COUNTOF

DWORD debug = 0;

BOOL
AddSpn(
    PUNICODE_STRING Service,
    PUNICODE_STRING Server
    );

BOOL
FindDomainForAccount(
    PUNICODE_STRING Server,
    PUNICODE_STRING DomainToCheck,
    PUNICODE_STRING Domain,
    PUNICODE_STRING DC
    )
{
    ULONG NetStatus ;
    PDOMAIN_CONTROLLER_INFO DcInfo ;
    ULONG DomainNameLength;

    if ( Server->MaximumLength - Server->Length < 2 * sizeof( WCHAR ))
    {
        fprintf( stderr, "FindDomainForAccount: Server name too long\n" );
        return FALSE;
    }

    Server->Buffer[Server->Length / sizeof( WCHAR )] = L'$';
    Server->Length += sizeof( WCHAR );
    Server->Buffer[Server->Length / sizeof( WCHAR )] = L'\0';

    NetStatus = DsGetDcNameWithAccountW(
                    NULL,
                    Server->Buffer,
                    UF_ACCOUNT_TYPE_MASK,
                    DomainToCheck->Buffer,
                    NULL,
                    NULL,
                    DS_DIRECTORY_SERVICE_REQUIRED |
                        DS_RETURN_FLAT_NAME,
                    &DcInfo );

    if ( NetStatus != 0 )
    {
        Server->Length -= sizeof( WCHAR );
        Server->Buffer[Server->Length / sizeof( WCHAR )] = L'\0';

        NetStatus = DsGetDcNameWithAccountW(
                        NULL,
                        Server->Buffer,
                        UF_ACCOUNT_TYPE_MASK,
                        DomainToCheck->Buffer,
                        NULL,
                        NULL,
                        DS_DIRECTORY_SERVICE_REQUIRED |
                            DS_RETURN_FLAT_NAME,
                        &DcInfo );

        if ( NetStatus != 0 )
        {
            fprintf( stderr, "FindDomainForAccount: DsGetDcNameWithAccountW failed!\n" );
            return FALSE;
        }
    }

    DomainNameLength = wcslen( DcInfo->DomainName );

    if ( DomainNameLength * sizeof( WCHAR ) >= Domain->MaximumLength )
    {
        fprintf( stderr, "FindDomainForAccount: Domain name too short\n" );
        NetApiBufferFree( DcInfo );
        return FALSE;
    }

    wcscpy( Domain->Buffer, DcInfo->DomainName );
    Domain->Length = (USHORT)DomainNameLength * sizeof ( WCHAR );

    if (DC)
    {
        ULONG DcLength = wcslen( &DcInfo->DomainControllerName[2] );

        if ( DcLength * sizeof( WCHAR ) >= DC->MaximumLength )
        {
            fprintf( stderr, "FindDomainForAccount: DC name too short\n" );
            NetApiBufferFree( DcInfo );
            return FALSE;
        }

        wcscpy( DC->Buffer, &DcInfo->DomainControllerName[2] );
        DC->Length = (USHORT)DcLength * sizeof( WCHAR );
    }

    NetApiBufferFree( DcInfo );

    return TRUE ;
}

BOOL
AddSpn(
    PUNICODE_STRING Service,
    PUNICODE_STRING Server
    )
{
    WCHAR DomainBuffer[ MAX_PATH ];
    UNICODE_STRING Domain;
    WCHAR FlatName[ 2 * MAX_PATH + 2 ];
    WCHAR HostSpn[ 3 * MAX_PATH + 3 ];
    WCHAR FlatSpn[ 2 * MAX_PATH + 2 ];
    HANDLE hDs ;
    ULONG NetStatus ;
    PDS_NAME_RESULT Result ;
    LPWSTR Spns[2];
    UNICODE_STRING EmptyString;
    LPWSTR Flat = FlatName;

    RtlInitUnicodeString( &EmptyString, L"" );

    Domain.Length = 0;
    Domain.MaximumLength = sizeof( DomainBuffer );
    Domain.Buffer = DomainBuffer;

    if ( !FindDomainForAccount( Server, &EmptyString, &Domain, NULL ))
    {
        fprintf( stderr, "Could not find account %ws\n", Server->Buffer );
        return FALSE;
    }

    if ( Domain.Length + sizeof( WCHAR ) + Server->Length >= sizeof( FlatName ))
    {
        fprintf( stderr, "AddSpn: FlatName too short\n" );
        return FALSE;
    }

    _snwprintf(
        FlatName,
        sizeof( FlatName ) / sizeof( WCHAR ),
        L"%s\\%s",
        Domain.Buffer, Server->Buffer
        );

    // _snwprintf does not necessarily NULL-terminate its output
    FlatName[ sizeof( FlatName ) / sizeof( WCHAR ) - 1] = L'\0';

    NetStatus = DsBind( NULL, Domain.Buffer, &hDs );

    if ( NetStatus != 0 )
    {
        fprintf( stderr, "Failed to bind to DC of domain %ws, %#x\n", Domain.Buffer, NetStatus );
        return FALSE ;
    }

    NetStatus = DsCrackNames(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ||
         Result->rItems[0].status != DS_NAME_NO_ERROR ||
         Result->cItems != 1)
    {
        fprintf(stderr,
            "Failed to crack name %ws into the FQDN, (%d) %d %#x\n",
            FlatName, NetStatus, Result->cItems,
            (Result->cItems==1)?Result->rItems[0].status:-1 );

        DsUnBind( &hDs );

        return FALSE ;
    }

    if ( Service->Length + Server->Length + Domain.Length + 4 >= sizeof( HostSpn ))
    {
        fprintf( stderr, "AddSpn: HostSpn too short\n" );
        DsUnBind( &hDs );
        return FALSE;
    }

    _snwprintf(
        HostSpn,
        sizeof( HostSpn ) / sizeof( WCHAR ),
        L"%s/%s.%s",
        Service->Buffer,
        Server->Buffer,
        Domain.Buffer
        );

    // _snwprintf does not necessarily NULL-terminate its output
    HostSpn[sizeof( HostSpn ) / sizeof( WCHAR ) - 1] = L'\0';

    if ( Service->Length + 2 + Server->Length >= sizeof( FlatSpn ))
    {
        fprintf( stderr, "AddSpn: FlatSpn too short\n" );
        DsUnBind( &hDs );
        return FALSE;
    }

    _snwprintf(
        FlatSpn,
        sizeof( FlatSpn ) / sizeof( WCHAR ),
        L"%s/%s",
        Service->Buffer,
        Server->Buffer
        );

    // _snwprintf does not necessarily NULL-terminate its output
    FlatSpn[sizeof( FlatSpn ) / sizeof( WCHAR ) - 1] = L'\0';

    Spns[0] = HostSpn;
    Spns[1] = FlatSpn;

    printf("Registering ServicePrincipalNames for %ws\n", Result->rItems[0].pName);
    printf("\t%ws\n", HostSpn);
    printf("\t%ws\n", FlatSpn);

#if 0
    printf("DsWriteAccountSpn: Commented out\n");
#else
    NetStatus = DsWriteAccountSpn(
                    hDs,
                    DS_SPN_ADD_SPN_OP,
                    Result->rItems[0].pName,
                    2,
                    Spns );

    if ( NetStatus != 0 )
    {
        fprintf(stderr,
        "Failed to assign SPN to account '%ws', %#x\n",
        Result->rItems[0].pName, NetStatus );
        return FALSE;
    }
#endif
    DsFreeNameResult( Result );

    DsUnBind( &hDs );

    return NetStatus == 0 ;
}

// added by jaroslad on 09/22/99
BOOL
AddRemoveSpn(
    PUNICODE_STRING HostSpn,
    PUNICODE_STRING HostDomain,
    PUNICODE_STRING Server,
    DS_SPN_WRITE_OP Operation

)
{
    WCHAR DomainBuffer[ MAX_PATH ];
    UNICODE_STRING Domain;
    WCHAR FlatName[ 2 * MAX_PATH + 2 ];
    HANDLE hDs ;
    ULONG NetStatus ;
    PDS_NAME_RESULT Result ;
    LPWSTR Spns[2];
    LPWSTR Flat = FlatName;

    Domain.Length = 0;
    Domain.MaximumLength = sizeof( DomainBuffer );
    Domain.Buffer = DomainBuffer;

    if ( !FindDomainForAccount( Server, HostDomain, &Domain, NULL ))
    {
        fprintf(stderr,
            "Unable to locate account %ws\n", Server->Buffer);
        return FALSE ;
    }

    if ( Domain.Length + Server->Length + sizeof( WCHAR ) >= sizeof( FlatName ))
    {
        fprintf( stderr, "AddRemoveSpn: FlatName too short\n" );
        return FALSE;
    }

    _snwprintf(
        FlatName,
        sizeof( FlatName ) / sizeof( WCHAR ),
        L"%s\\%s",
        Domain.Buffer,
        Server->Buffer
        );

    NetStatus = DsBind( NULL, Domain.Buffer, &hDs );
    if ( NetStatus != 0 )
    {
        fprintf(stderr,
            "Failed to bind to DC of domain %ws, %#x\n",
            Domain.Buffer, NetStatus );
        return FALSE ;
    }

    NetStatus = DsCrackNames(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ||
         Result->rItems[0].status != DS_NAME_NO_ERROR ||
         Result->cItems != 1)
    {
        fprintf(stderr,
            "Failed to crack name %ws into the FQDN, (%d) %d %#x\n",
            FlatName, NetStatus, Result->cItems,
            (Result->cItems==1)?Result->rItems[0].status:-1 );

        DsUnBind( &hDs );

        return FALSE ;
    }

    Spns[0] = HostSpn->Buffer;

    printf("%s ServicePrincipalNames for %ws\n",
       (Operation==DS_SPN_DELETE_SPN_OP)?"Unregistering":"Registering", Result->rItems[0].pName);
    printf("\t%ws\n", HostSpn->Buffer);

#if 0
    printf("DsWriteAccountSpn: Commented out\n");
#else
    NetStatus = DsWriteAccountSpn(
                    hDs,
                    Operation,
                    Result->rItems[0].pName,
                    1,
                    Spns );

    if ( NetStatus != 0 )
    {
        fprintf(stderr,
            "Failed to %s SPN on account '%ws', %#x\n",
            (Operation==DS_SPN_DELETE_SPN_OP)?"remove":"assign",
            Result->rItems[0].pName, NetStatus );
        DsUnBind( &hDs );
        return FALSE;
    }
#endif

    DsFreeNameResult( Result );

    DsUnBind( &hDs );

    return NetStatus == 0 ;
}


BOOL
LookupHostSpn(
    PUNICODE_STRING ServerDomain,
    PUNICODE_STRING Server
    )
{
    WCHAR FlatName[ MAX_PATH + 1 ] = {0};
    HANDLE hDs ;
    ULONG NetStatus ;
    PDS_NAME_RESULT Result ;
    LDAP *ld;
    int rc;
    LDAPMessage *e, *res = NULL;
    WCHAR *base_dn;
    WCHAR *search_dn, search_ava[256];
    WCHAR DomainBuffer[ MAX_PATH ];
    UNICODE_STRING Domain;
    WCHAR DcBuffer[ MAX_PATH ];
    UNICODE_STRING DC;
    LPWSTR Flat = FlatName;

    Domain.Length = 0;
    Domain.MaximumLength = sizeof( DomainBuffer );
    Domain.Buffer = DomainBuffer;

    DC.Length = 0;
    DC.MaximumLength = sizeof( DcBuffer );
    DC.Buffer = DcBuffer;

    if ( !FindDomainForAccount( Server, ServerDomain, &Domain, &DC ))
    {
        fprintf(stderr, "Cannot find account %ws\n", Server->Buffer);
        return FALSE ;
    }

    if (debug)
        printf("Domain=%ws DC=%ws\n", Domain.Buffer, DC.Buffer);

    ld = ldap_open(DC.Buffer, LDAP_PORT);
    if (ld == NULL) {
        fprintf(stderr, "ldap_init failed = %x", LdapGetLastError());
        return FALSE;
    }

    rc = ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (rc != LDAP_SUCCESS) {
        fprintf(stderr, "ldap_bind failed = %x", LdapGetLastError());
        ldap_unbind(ld);
        return FALSE;
    }

    NetStatus = DsBind( NULL, Domain.Buffer, &hDs );
    if ( NetStatus != 0 )
    {
        fprintf(stderr, "Failed to bind to DC of domain %ws, %#x\n",
               Domain.Buffer, NetStatus );
        ldap_unbind(ld);
        return FALSE ;
    }

    if ( Domain.Length + sizeof( WCHAR ) + Server->Length >= sizeof( FlatName ))
    {
        fprintf( stderr, "LookupHostSpn: FlatName too short\n" );
        ldap_unbind(ld);
        return FALSE;
    }

    _snwprintf(
        FlatName,
        sizeof( FlatName ) / sizeof( WCHAR ),
        L"%s\\%s",
        Domain.Buffer,
        Server->Buffer
        );

    // _snwprintf does not necessarily NULL-terminate its output
    FlatName[sizeof( FlatName ) / sizeof( WCHAR ) - 1] = L'\0';

    NetStatus = DsCrackNames(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ||
         Result->rItems[0].status != DS_NAME_NO_ERROR ||
         Result->cItems != 1)
    {
        if (Result->rItems[0].status == DS_NAME_ERROR_NOT_FOUND)
        {
            fprintf(stderr,
                "Requested name \"%ws\" not found in directory.\n",
                FlatName);
        }
        else if (Result->rItems[0].status == DS_NAME_ERROR_NOT_UNIQUE)
        {
            fprintf(stderr,
                "Requested name \"%ws\" not unique in directory.\n",
                FlatName);
        }
        else
            fprintf(stderr,
                "Failed to crack name %ws into the FQDN, (%d) %d %#x\n",
                FlatName, NetStatus, Result->cItems,
                (Result->cItems==1)?Result->rItems[0].status:-1 );

        DsUnBind( &hDs );

        return FALSE ;
    }

    search_dn = Server->Buffer;

    base_dn = StrChr(Result->rItems[0].pName, L',');
    if (!base_dn)
        base_dn = Result->rItems[0].pName;
    else
        base_dn++;

    if (debug) {
        printf("BASE_DN=%S\n", base_dn);
        printf("SEARCH_DN=%S\n", search_dn);
    }

    DsUnBind( &hDs );

    _snwprintf(
        search_ava,
        sizeof( search_ava ) / sizeof( WCHAR ),
        L"(sAMAccountName=%s)",
        search_dn);

    // _snwprintf does not necessarily NULL-terminate its output
    search_ava[sizeof( search_ava ) / sizeof( WCHAR ) - 1] = L'\0';

    if (debug)
        printf("FILTER=\"%S\"\n", search_ava);

    rc = ldap_search_s(ld, base_dn, LDAP_SCOPE_SUBTREE,
                       search_ava, NULL, 0, &res);

    DsFreeNameResult( Result );

    if (rc != LDAP_SUCCESS) {
        fprintf(stderr, "ldap_search_s failed: %S", ldap_err2string(rc));
        if ( res ) {
            ldap_msgfree(res);
        }
        ldap_unbind(ld);
        return 1;
    }

    for (e = ldap_first_entry(ld, res);
         e;
         e = ldap_next_entry(ld, e)) {

        BerElement *b;
        WCHAR *attr;
        WCHAR *dn = ldap_get_dn(ld, res);

        printf("Registered ServicePrincipalNames");
        if (dn)
            printf(" for %S", dn);

        printf(":\n");

        ldap_memfree(dn);

        for (attr = ldap_first_attribute(ld, e, &b);
             attr;
             attr = ldap_next_attribute(ld, e, b)) {

            WCHAR **values, **p;
            values = ldap_get_values(ld, e, attr);
            for (p = values; *p; p++) {

                if (StrCmp(attr, L"servicePrincipalName") == 0)
                    printf("    %S\n", *p);
            }

            ldap_value_free(values);
            ldap_memfree(attr);
        }

        //ber_free(b, 1);
    }

    ldap_msgfree(res);
    ldap_unbind(ld);

    return TRUE;
}

void Usage( PWSTR name)
{
    printf("\
Usage: %S [switches data] computername \n\
  Where \"computername\" can be the name or domain\\name\n\
\n\
  Switches:\n\
   -R = reset HOST ServicePrincipalName\n\
    Usage:   setspn -R computername\n\
   -A = add arbitrary SPN  \n\
    Usage:   setspn -A SPN computername\n\
   -D = delete arbitrary SPN  \n\
    Usage:   setspn -D SPN computername\n\
   -L = list registered SPNs  \n\
    Usage:   setspn [-L] computername   \n\
Examples: \n\
setspn -R daserver1 \n\
   It will register SPN \"HOST/daserver1\" and \"HOST/{DNS of daserver1}\" \n\
setspn -A http/daserver daserver1 \n\
   It will register SPN \"http/daserver\" for computer \"daserver1\" \n\
setspn -D http/daserver daserver1 \n\
   It will delete SPN \"http/daserver\" for computer \"daserver1\" \n\
", name);
    ExitProcess(0);
}

void __cdecl wmain (int argc, wchar_t *argv[])
{
    int resetSPN = FALSE, addSPN = FALSE, deleteSPN = FALSE, listSPN = TRUE;
    UNICODE_STRING Service, Host,HostSpn, HostDomain ;
    wchar_t *ptr;
    int i;
    DS_SPN_WRITE_OP Operation;
    PWSTR Scan;
    DWORD Status = 1;

    for (i = 1; i < argc; i++)
    {
        if ((argv[i][0] == L'-') || (argv[i][0] == L'/'))
        {
            for (ptr = (argv[i] + 1); *ptr; ptr++)
            {
                switch(towupper(*ptr))
                {
                case L'R':
                    resetSPN = TRUE;
                    break;
                case L'A':
                    addSPN = TRUE;
                    break;
                case L'D':
                    deleteSPN = TRUE;
                    break;
                case L'L':
                    listSPN = TRUE;
                    break;
                case L'V':
                    debug = TRUE;
                    break;
                case L'?':
                default:
                    Usage(argv[0]);
                    break;
                }
            }
        }
        else
            break;
    }

    if ( resetSPN )
    {
        UNICODE_STRING Service, Server;
        WCHAR ServerBuffer[MAX_PATH];

        if ( ( argc - i ) != 1 )
        {
            Usage( argv[0] );
        }

        wcsncpy( ServerBuffer, argv[i], MAX_PATH-1 );
        ServerBuffer[MAX_PATH-2] = L'\0'; // leave space for trailing $

        RtlInitUnicodeString( &Service, L"HOST" );
        RtlInitUnicodeString( &Server, ServerBuffer );
        Server.MaximumLength = MAX_PATH;

        if ( AddSpn( &Service, &Server ))
        {
            printf("Updated object\n");
            Status = 0;
        }
    }
    else if ( addSPN || deleteSPN )
    {
        WCHAR HostBuffer[MAX_PATH];

        if ( ( argc - i ) != 2 )
        {
            Usage( argv[0] );
        }

        RtlInitUnicodeString( &HostSpn, argv[i] );

        Scan = argv[ i + 1 ];

        if ( Scan = wcschr( Scan, L'\\' ) )
        {
            *Scan++ = L'\0';
            RtlInitUnicodeString( &HostDomain, argv[i+1] );
            wcsncpy( HostBuffer, Scan, MAX_PATH-1 );
            HostBuffer[MAX_PATH-2] = L'\0';
            RtlInitUnicodeString( &Host, HostBuffer );
            Host.MaximumLength = MAX_PATH;
        }
        else
        {
            RtlInitUnicodeString( &HostDomain, L"" );
            wcsncpy( HostBuffer, argv[i+1], MAX_PATH-1 );
            HostBuffer[MAX_PATH-2] = L'\0';
            RtlInitUnicodeString