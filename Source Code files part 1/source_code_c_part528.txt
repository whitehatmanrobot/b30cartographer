CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    }; // class CIterator


    // Const iterators for readonly access.  You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    }; // class CConstIterator


private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };

#endif // LKR_DEPRECATED_ITERATORS


#ifdef LKR_STL_ITERATORS

private:
    bool _Erase(Iterator& riter, DWORD dwSignature);
    bool _Find(DWORD_PTR pnKey, DWORD dwSignature, Iterator& riterResult);

    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH:_IsValidIterator(%p)\n"), &riter);
        bool fValid = ((riter.m_plht == this)
                       &&  (riter.m_dwBucketAddr < m_cActiveBuckets)
                       &&  riter.IsValid());
        IRTLASSERT(fValid);
        return fValid;
    }

public:
    // Return iterator pointing to first item in table
    Iterator
    Begin();

    // Return a one-past-the-end iterator. Always empty.
    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::End\n"));
        return Iterator();
    }

    // Insert a record
    // Returns `true' if successful; iterResult points to that record
    // Returns `false' otherwise; iterResult == End()
    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    // Erase the record pointed to by the iterator; adjust the iterator
    // to point to the next record. Returns `true' if successful.
    bool
    Erase(
        /* in,out */ Iterator& riter);

    // Erase the records in the range [riterFirst, riterLast).
    // Returns `true' if successful.
    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    // Find the (first) record that has its key == pnKey.
    // If successful, returns `true' and iterator points to (first) record.
    // If fails, returns `false' and iterator == End()
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    // Find the range of records that have their keys == pnKey.
    // If successful, returns `true', iterFirst points to first record,
    //     and iterLast points to one-beyond-the last such record.
    // If fails, returns `false' and both iterators == End().
    // Primarily useful when m_fMultiKey == true
    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRLinearHashTable



#ifdef LKR_STL_ITERATORS

// These functions have to be defined after CLKRLinearHashTable

inline void
CLKRLinearHashTable_Iterator::_AddRef(
    int nIncr) const
{
    // TODO: should iterator call _AddRefRecord at all
    if (m_plht != NULL  &&  m_iNode != NODE_BEGIN - NODE_STEP)
    {
        IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
                   &&  (unsigned) m_iNode < NODES_PER_CLUMP
                   &&  m_pnc != NULL
                   &&  (nIncr == -1 ||  nIncr == +1));
        const void* pvRecord = m_pnc->m_pvNode[m_iNode];
        IRTLASSERT(pvRecord != NULL);
        LKR_ITER_TRACE(_TEXT("  LKLH::AddRef, this=%p, Rec=%p\n"),
                       this, pvRecord);
        m_plht->_AddRefRecord(pvRecord, nIncr);
    }
} // CLKRLinearHashTable_Iterator::_AddRef


inline const DWORD_PTR
CLKRLinearHashTable_Iterator::Key() const
{
    IRTLASSERT(IsValid());
    return m_plht->_ExtractKey(m_pnc->m_pvNode[m_iNode]);
} // CLKRLinearHashTable_Iterator::Key

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly.  The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

    friend class CLKRLinearHashTable;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRHashTable_Iterator;
    typedef CLKRHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

    enum {
        MAX_SUBTABLES = 64,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
    int            m_nSubTableMask;

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry     m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void
    _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void
    _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&);
    CLKRHashTable& operator=(const CLKRHashTable&);


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const;

    // Find the index of pst within the subtable array
    int          _SubTableIndex(SubTable* pst) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
    );

    static bool
    _FreeSubTable(
        SubTable* plht);


public:
    CLKRHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS, // #subordinate hash tables.
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRHashTable");}

    int                NumSubTables() const  {return m_cSubTables;}

    bool               MultiKeys() const;

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false);
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey);
    LK_RETCODE     DeleteRecord(const void* pvRecord);
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const;
    LK_RETCODE     FindRecord(const void* pvRecord) const;

#ifdef LKR_APPLY_IF
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount() const;
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock() const;
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive() const;
    void        ConvertExclusiveToShared() const;


    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);

#ifdef LKR_DEPRECATED_ITERATORS

public:

    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    };

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

private:
    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT:_IsValidIterator(%p)\n"), &riter);
        bool fValid = (riter.m_pht == this);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= riter.m_ist
                              &&  riter.m_ist < (int) m_cSubTables);
        IRTLASSERT(fValid);
        IRTLASSERT(_SubTableIndex(riter.m_subiter.m_plht) == riter.m_ist);
        fValid = fValid  &&  riter.IsValid();
        IRTLASSERT(fValid);
        return fValid;
    }


public:
    Iterator
    Begin();

    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::End\n"));
        return Iterator();
    }

    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    bool
    Erase(
        /* in,out */ Iterator& riter);

    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRHashTable



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------

#define LKRHASH_HACKY_CAST(T, pv)  ((T) (UINT_PTR) (pv))

template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;

    typedef CTypedHashTable<_Derived, _Record, _Key, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;
#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_APPLY_IF
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        _Key           key  = static_cast<_Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here, but the stupid
        // Win64 compiler thinks it knows better than I do.
        return (const DWORD_PTR) (key);
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        _Key key = LKRHASH_HACKY_CAST(_Key, pnKey);
        return _Derived::CalcKeyHash(key);
    }

    static bool WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        _Key key1 = LKRHASH_HACKY_CAST(_Key, pnKey1);
        _Key key2 = LKRHASH_HACKY_CAST(_Key, pnKey2);
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls,
                            fMultiKeys)
    {
        // Ensure that _Key is no bigger than a pointer. Because we
        // support both numeric and pointer keys, the various casts
        // in the member functions unfortunately silently truncate if
        // _Key is an unacceptable numeric type, such as __int64 on x86.
        STATIC_ASSERT(sizeof(_Key) <= sizeof(DWORD_PTR));
    }

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    {
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::DeleteKey(pnKey);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change


#ifdef LKR_APPLY_IF

public:

    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }
#endif // LKR_APPLY_IF



#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

    // TODO: const_iterator

public:

    class iterator
    {
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

    protected:
        typename _BaseHashTable::Iterator            m_iter;

        iterator(
            typename _BaseHashTable::Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        reference operator*() const
        {
            void* pvRecord = const_cast<void*>(m_iter.Record());
            return reinterpret_cast<reference>(pvRecord);
        }

        pointer   operator->() const  { return &(operator*()); }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return iterator(_BaseHashTable::Begin());
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end()
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return iterator(_BaseHashTable::End());
    }

    template <class _InputIterator>
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        _InputIterator f,                     // first element in range
        _InputIterator l,                     // one-beyond-last element
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys)
    {
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return _BaseHashTable::Insert(pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return _BaseHashTable::Erase(riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return _BaseHashTable::Erase(riterFirst.m_iter, riterLast.m_iter);
    }

    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::Find(pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::EqualRange(pnKey, riterFirst.m_iter,
                                          riterLast.m_iter);
    }

    // The iterator functions for an STL hash_(|multi)_(set|map)
    //
    // Value type of a Pair-Associative Container is
    //     pair<const key_type, mapped_type>
    //
    // pair<iterator,bool> insert(const value_type& x);
    //
    // void erase(iterator pos);
    // void erase(iterator f, iterator l);
    //
    // iterator find(const key_type& k) [const];
    // const_iterator find(const key_type& k) const;
    //
    // pair<iterator,iterator> equal_range(const key_type& k) [const];
    // pair<const_iterator,const_iterator> equal_range(const key_type& k) const


#endif // LKR_STL_ITERATORS
};



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\logtype.h ===
#ifndef _LOGTYPE_H_
#define _LOGTYPE_H_

/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name:

      logtype.hxx

   Abstract:

      This module provides definitions of the server side logging object

   Author:

       Terence Kwan    ( terryk )    18-June-1996

--*/

#include "logconst.h"

//
//  MISC defines
//

# define MAX_SERVER_NAME_LEN           ( MAX_COMPUTERNAME_LENGTH + 1)
# define MAX_NT_SERVICE_NAME_LEN       ( SNLEN + 1)
# define MAX_DATABASE_NAME_LEN         (MAX_PATH)
# define IISLOG_EVENTLOG_SOURCE        TEXT("IISLOG")

//
// Max field/record lengths
//

#define MAX_LOG_RECORD_FORMAT_LEN       (  120)
#define MIN_FILE_TRUNCATION_SIZE        ( 128*1024)
#define MAX_LOG_TARGET_FIELD_LEN        ( 4096)
#define MAX_LOG_PARAMETER_FIELD_LEN     ( 4096)
#define MAX_LOG_OPERATION_FIELD_LEN     ( 100)
#define MAX_LOG_USER_FIELD_LEN          ( 255)
#define MAX_LOG_RECORD_LEN              ( 10 * 1024)
#define NO_FILE_TRUNCATION              0xffffffff


/************************************************************
 *   Type Definitions
 ************************************************************/


//
//  The following handle ( INETLOG_HANDLE) is to be used as
//     handle for processing log information.
//

typedef VOID * INETLOG_HANDLE;

# define INVALID_INETLOG_HANDLE_VALUE          ( NULL)



/*++

  struct   INETLOG_INFORMATION

     This structure specifies the information required to write
      one log record.

--*/

typedef struct  _INETLOG_INFORMATION 
{

    LPSTR     pszClientHostName;
    LPSTR     pszClientUserName;
    LPSTR     pszServerAddress;     // input ip address for connection
    LPSTR     pszOperation;         //  eg: 'get'  in FTP
    LPSTR     pszTarget;            // target path/machine name
    LPSTR     pszParameters;        // string containing parameters.
    LPSTR     pszVersion;           // protocol version string.

    DWORD     cbClientHostName;
    DWORD     cbOperation;
    DWORD     cbTarget;

    DWORD     dwBytesSent;      // count of bytes sent
    DWORD     dwBytesRecvd;     // count of bytes recvd

    DWORD     msTimeForProcessing;  // time required for processing
    DWORD     dwWin32Status;        // Win32 error code. 0 for success
    DWORD     dwProtocolStatus;     // status: whatever service wants.
    DWORD     dwPort;

    DWORD     cbHTTPHeaderSize;
    LPSTR     pszHTTPHeader;        // Header Information

} INETLOG_INFORMATION, * PINETLOG_INFORMATION;



/*++

  struct  INETLOG_CONFIGURATION

    This structure contains the configuration information used for logging.

    The configuration includes:
      Format of Log record -- specifies the order in which the log record
         is written. ( serialization of INETLOG_INFORMATION).
      Type of Logging.  ( LOG_TYPE)
      Parameters depending upon type of logging.

      Type                      Parameters:
      InetNoLog                None
      InetLogToFile            Directory containing file; truncation size +
                                period ( daily, weekly, monthly).
      INET_LOG_TO_SQL          Sql Server Name, Sql Database Name,
                               Sql Table Name.
                             ( the table has to be already created).

      for SQL and logging to remote files eg: \\logserver\logshare\logdir
      we also need information about UserName and Passwd ( LSA_SECRET)
         for logging.  NYI.

     We do not support the remote directory in present version ( 2/2/95)

--*/
typedef struct _INETLOG_CONFIGURATIONA 
{

    DWORD          inetLogType;

    union 
    {

        struct 
        {

        //
        //  Used for InetLogToFile and InetLogToPeriodicFile
        //
            CHAR       rgchLogFileDirectory[ MAX_PATH];
            DWORD      cbSizeForTruncation;
            DWORD      ilPeriod;
            DWORD      cbBatchSize; // count of bytes to batch up per write.
            DWORD      ilFormat;
            DWORD      dwFieldMask;

        } logFile;

        struct 
        {

            //
            // Used for InetLogToSql
            //  ODBC bundles DatabaseName and ServerName and ServerType
            //   using a logical name called DataSource.
            //
            CHAR       rgchDataSource[ MAX_DATABASE_NAME_LEN];
            CHAR       rgchTableName[ MAX_TABLE_NAME_LEN];
            CHAR       rgchUserName[ MAX_USER_NAME_LEN];
            CHAR       rgchPassword[ MAX_PASSWORD_LEN];
        } logSql;

    } u;

    CHAR      rgchLogRecordFormat[ MAX_LOG_RECORD_FORMAT_LEN];

}  INETLOG_CONFIGURATIONA, * PINETLOG_CONFIGURATIONA;

/*--

This type declaration is duplicated here so that the Web Server can use this
in the LOGGING object.

--*/

#ifndef _ILOGOBJ_HXX_

typedef struct _CUSTOM_LOG_DATA
{
    LPCSTR  szPropertyPath;
    PVOID   pData;
    
} CUSTOM_LOG_DATA, *PCUSTOM_LOG_DATA;

#endif 

#endif  // _LOGTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\makefile.inc ===
#
#   makefile0
#   Author: Murali R. Krishnan ( MuraliK)
#   Date:   2-Feb-1995
#
#   Describes the targets to be built first.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

#
#  The individual services build inetamsg.mc into their resources so nuke the
#  .rc and .bin file
#

$(O)\inetamsg.h: inetamsg.mc
    mc -v -h .\$(O) -r .\$(O) inetamsg.mc
    -del $(O)\inetamsg.rc $(O)\msg00001.bin

$(O)\iiscnfg.h $(O)\iiscnfgp.h: iiscnfg.x
    hsplit -e -o $(O)\iiscnfg.h $(O)\iiscnfgp.h iiscnfg.x

$(O)\iisfilt.h $(O)\iisfiltp.h: iisfilt.x
    hsplit -e -o $(O)\iisfilt.h $(O)\iisfiltp.h iisfilt.x

$(O)\iisext.h $(O)\iisextp.h: iisext.x
    hsplit -e -o $(O)\iisext.h $(O)\iisextp.h iisext.x
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\locks.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CRtlResource        NT's RTL_RESOURCE
//      CShareLock          Michael Parkes's CSharelock
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif


enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_RTLRESOURCE,
    LOCK_SHARELOCK,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CRtlResource;
class IRTL_DLLEXP CShareLock;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;



#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif

#ifdef _M_IX86
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#endif

// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a 386 (unlikely in
// 2000), you'll need to use something else.

LOCK_FORCEINLINE
LONG
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
             inc        eax                 // correct result
    }
#else
    return InterlockedIncrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
             dec        eax                 // correct result
    }
#else
    return InterlockedDecrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    [ecx]
    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#else
    return InterlockedExchange(plAddr, lNew);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
#else
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
#else
    return InterlockedExchangeAdd(plAddr, lValue);
#endif
}



#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette processors.
# define Lock_Yield()    _asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif



//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    char     m_szName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_szName[0] = '\0';
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    char            m_szName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const char* Name() const        {return m_szName;}                      \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(pszName)         \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (pszName == NULL)                            \
        m_szName[0] = '\0';                         \
    else                                            \
        strncpy(m_szName, pszName, sizeof(m_szName))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }

public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        UNREFERENCED_PARAMETER(wSpins);
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            IRTLASSERT((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        IRTLASSERT(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD)             {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD)         {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CCritSec");}
}; // CCritSec




//--------------------------------------------------------------------
// RTL_RESOURCE is a multi-reader, single-writer lock provided on NT, but
// not published as part of the Win32 API.  IIS exposes it in <tsres.hxx>.

#include <tsres.hxx>

class IRTL_DLLEXP CRtlResource :
    public CLockBase<LOCK_RTLRESOURCE, LOCK_MRSW,
                       LOCK_RECURSIVE /*??*/, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    RTL_RESOURCE    m_res;

    LOCK_INSTRUMENTATION_DECL();

public:
    CRtlResource()
    {
        InetInitializeResource(&m_res);
        CCritSec::SetSpinCount(&m_res.CriticalSection, sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CRtlResource(const char*)
    {
        InetInitializeResource(&m_res);
        CCritSec::SetSpinCount(&m_res.CriticalSection, sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CRtlResource()     { InetDeleteResource(&m_res); }

    void WriteLock()    { InetAcquireResourceExclusive(&m_res, TRUE); }
    void ReadLock()     { InetAcquireResourceShared(&m_res, TRUE); }
    bool TryWriteLock() {return !!InetAcquireResourceExclusive(&m_res, FALSE);}
    bool TryReadLock()  { return !!InetAcquireResourceShared(&m_res, FALSE); }
    void WriteUnlock()  { InetReleaseResource(&m_res); }
    void ReadUnlock()   { WriteUnlock(); }

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        InetConvertSharedToExclusive(&m_res);
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        InetConvertExclusiveToShared(&m_res);
    }
    
    bool SetSpinCount(WORD wSpins)
    {CCritSec::SetSpinCount(&m_res.CriticalSection, wSpins); return true;}
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CRtlResource";}
}; // CRtlResource




//--------------------------------------------------------------------
// CSharelock is a multi-reader, single-writer lock due to MParkes.

#include <sharelok.h>

class IRTL_DLLEXP CShareLock :
    public CLockBase<LOCK_SHARELOCK, LOCK_MRSW,
                       LOCK_RECURSIVE /* ?? */, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CSharelock      m_sl;

    LOCK_INSTRUMENTATION_DECL();

public:
    CShareLock()
        : m_sl()
    {
    }
#ifdef LOCK_INSTRUMENTATION
    CShareLock(const char*)
        : m_sl()
    {
    }
#endif // LOCK_INSTRUMENTATION

    void WriteLock()    { m_sl.ClaimExclusiveLock(INFINITE); }
    void ReadLock()     { m_sl.ClaimShareLock(INFINITE); }
    bool TryWriteLock() { return !!m_sl.ClaimExclusiveLock(0); }
    bool TryReadLock()  { return !!m_sl.ClaimShareLock(0); }
    void WriteUnlock()  { m_sl.ReleaseExclusiveLock(); }
    void ReadUnlock()   { m_sl.ReleaseShareLock(); }
    
    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return IsWriteUnlocked();}

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        m_sl.ChangeSharedLockToExclusiveLock(INFINITE);
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        m_sl.ChangeExclusiveLockToSharedLock();
    }
    
    bool SetSpinCount(WORD wSpins)
    { m_sl.UpdateMaxSpins(wSpins); return true;}
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CShareLock";}
};  // CShareLock



//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == Lock_AtomicCompareExchange(
                                 const_cast<LONG*>(&m_nState), lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock()
    {
        return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG nCurrState = m_nState;
                
        // Give writers priority
        return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
                &&  _CmpExch(nCurrState + 1, nCurrState));
    }

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const char* pszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
        
        if (_TryWriteLock())
            return;

        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    }

    inline void ReadUnlock()
    {
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    }

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        // single reader?
        if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
            return;

        // release the reader lock and spin
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
        _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock");}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent ==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                     lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const char* pszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                         l);
            l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock2");}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. =0 => free; >0 => readers; ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                    lNew, lCurrent);
    }

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        // The common case: the writelock has no owner
        if (m_lTid == 0)
        {
            // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
            LONG l = m_lRW;
            // Grab exclusive access to the lock if it's free.  Works even
            // if there are other writers queued up.
            if ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
            {
                l = Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                        _CurrentThreadId() | SL_OWNER_INCR);
                IRTLASSERT(l == 0);
                return true;
            }
        }

        return _TryWriteLock2();
    }

    // split into a separate function to make _TryWriteLock more inlineable
    bool _TryWriteLock2()
    {
        if ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
        {
            IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
            IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), SL_OWNER_INCR);
            return true;
        }

        return false;
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        // Give writers priority
        LONG l = m_lRW;
        bool fLocked = (((l & SL_WRITERS_MASK) == 0)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

    LOCK_FORCEINLINE bool _TryReadLockRecursive()
    {
        // Do *not* give writers priority. If the inner call attempts
        // to reacquire the read lock while another thread is waiting on
        // the write lock, we would deadlock if we waited for the queue
        // of writers to empty: the writer(s) can't acquire the lock
        // exclusively, as this thread holds a readlock. The inner call
        // typically releases the lock very quickly, so there is no
        // danger of writer starvation.
        LONG l = m_lRW;
        bool fLocked = (((l & SL_STATE_MASK) != SL_EXCLUSIVE)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(0)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const char* pszName)
        : m_lRW(SL_FREE),
          m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin(SPIN_READ);
    } 

    // If already locked, recursively acquires another lock of the same
    // kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    inline bool ReadOrWriteLock()
    {
        if (IsWriteLocked())
        {
            WriteLock();
            return false;   // => not read locked
        }
        else
        {
            LOCK_READLOCK_INSTRUMENTATION();
            
            if (!_TryReadLockRecursive())
                _ReadLockSpin(SPIN_READ_RECURSIVE);
            
            return true;   // => is read locked
        }
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        LONG lNew = m_lTid - SL_OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((lNew & SL_OWNER_MASK) == 0)
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
            for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
                 !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
                 l = m_lRW)
            {
                Lock_Yield();
            }
        }
        else
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNew);
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    inline void ReadOrWriteUnlock(bool fIsReadLocked)
    {
        if (fIsReadLocked)
            ReadUnlock();
        else
            WriteUnlock();
    } 

    // Does current thread hold a write lock?
    bool IsWriteLocked() const
    {
        // bool fLocked = ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
        bool fLocked = !((m_lTid ^ GetCurrentThreadId()) & SL_THREAD_MASK);
        IRTLASSERT(!fLocked  || (((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE)
                                 &&  ((m_lTid & SL_OWNER_MASK) > 0)));
        return fLocked;
    }

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                _CurrentThreadId() | SL_OWNER_INCR);
        }
        else
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    bool TryConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            InterlockedExchange(const_cast<LONG*>(&m_lTid),
                                _CurrentThreadId() | SL_OWNER_INCR);
            IRTLASSERT(IsWriteLocked());
            return true;
        }

        IRTLASSERT(!IsWriteLocked());
        IRTLASSERT(IsReadLocked());

        return false;
    }

    // There is no such window when converting from a writelock to a readlock
    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());

        // assume writelock is not held recursively
        IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);

        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                        l);
             l = m_lRW)
        {
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock3");}
}; // CReaderWriterLock3


// Global initialization and termination
// (these don't need to be called if locks functionality is used
// off the iisutil of iisrtl. 
// When static locks library is used then calling Locks_Initialize() and Locks_Cleanup()
// is required

extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

};


#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\mddef.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Tue Jun 24 13:13:55 1997
 */
/* Compiler settings for .\mddef.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __mddef_h__
#define __mddef_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "unknwn.h"
#include "mddefw.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Jun 24 13:13:55 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


/*++

Copyright (c) 1997 Microsoft Corporation

Module Name: mddef.h

    Definitions for Admin Objects and Metadata

--*/
#ifndef _MD_DEF_
#define _MD_DEF_


/*
    Events for ComMDEventNotify

        MD_EVENT_MID_RESTORE - Called when a restore is in progress. At this points
        all old handles have been invalidated, and new ones have not been opened.
        The metabase is locked when this is called. Do not call the metabase when
        processing this.
*/

enum MD_EVENTS
    {
        MD_EVENT_MID_RESTORE
    };

/*
    Change Object - The structure passed to ComMDSinkNotify.

        Path - The path of the MetaObject modified.

        ChangeType - The types of changes made, from the flags below.

        NumDataIDs - The number of data id's changed.

        DataIDs - An array of the data id's changed.
*/
#undef MD_CHANGE_OBJECT
#undef PMD_CHANGE_OBJECT

#ifdef UNICODE
#define MD_CHANGE_OBJECT     MD_CHANGE_OBJECT_W
#define PMD_CHANGE_OBJECT    PMD_CHANGE_OBJECT_W
#else  //UNICODE
#define MD_CHANGE_OBJECT     MD_CHANGE_OBJECT_A
#define PMD_CHANGE_OBJECT    PMD_CHANGE_OBJECT_A
#endif //UNICODE

typedef struct  _MD_CHANGE_OBJECT_A
    {
    /* [string] */ unsigned char __RPC_FAR *pszMDPath;
    DWORD dwMDChangeType;
    DWORD dwMDNumDataIDs;
    /* [size_is][unique] */ DWORD __RPC_FAR *pdwMDDataIDs;
    }   MD_CHANGE_OBJECT_A;

typedef struct _MD_CHANGE_OBJECT_A __RPC_FAR *PMD_CHANGE_OBJECT_A;

#endif


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\mtxpriv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:09 1997
 */
/* Compiler settings for mtxpriv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxpriv_h__
#define __mtxpriv_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IContextProperties_FWD_DEFINED__
#define __IContextProperties_FWD_DEFINED__
typedef interface IContextProperties IContextProperties;
#endif 	/* __IContextProperties_FWD_DEFINED__ */


#ifndef __IMTSCall_FWD_DEFINED__
#define __IMTSCall_FWD_DEFINED__
typedef interface IMTSCall IMTSCall;
#endif 	/* __IMTSCall_FWD_DEFINED__ */


#ifndef __IMTSActivity_FWD_DEFINED__
#define __IMTSActivity_FWD_DEFINED__
typedef interface IMTSActivity IMTSActivity;
#endif 	/* __IMTSActivity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mtx.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxpriv_0000
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------
// mtxpriv.h  -- Microsoft Transaction Server Undisclosed APIs
//
// This file provides the prototypes for those APIs and COM interfaces
// used by Microsoft Transaction Server applications which have NOT been
// disclosed or documented.
//
// Microsoft Transaction Server 2.0
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------
#include <mtx.h>

#define CONTEXT_E_EXCEPTION				0x8004E010
#define CONTEXT_E_QUEUEFULL				0x8004E011


extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0000_v0_0_s_ifspec;

#ifndef __IContextProperties_INTERFACE_DEFINED__
#define __IContextProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextProperties
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af1-cae7-11cf-be81-00aa00a2fa25")
    IContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IContextProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNames )( 
            IContextProperties __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        END_INTERFACE
    } IContextPropertiesVtbl;

    interface IContextProperties
    {
        CONST_VTBL struct IContextPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextProperties_Count(This,plCount)	\
    (This)->lpVtbl -> Count(This,plCount)

#define IContextProperties_GetProperty(This,name,pProperty)	\
    (This)->lpVtbl -> GetProperty(This,name,pProperty)

#define IContextProperties_EnumNames(This,ppenum)	\
    (This)->lpVtbl -> EnumNames(This,ppenum)

#define IContextProperties_SetProperty(This,name,property)	\
    (This)->lpVtbl -> SetProperty(This,name,property)

#define IContextProperties_RemoveProperty(This,name)	\
    (This)->lpVtbl -> RemoveProperty(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextProperties_Count_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IContextProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_GetProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pProperty);


void __RPC_STUB IContextProperties_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_EnumNames_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IContextProperties_EnumNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_SetProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT property);


void __RPC_STUB IContextProperties_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_RemoveProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IContextProperties_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextProperties_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtxpriv_0104
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#ifdef __cplusplus
extern "C"
#endif __cplusplus
EXTERN_C HRESULT __stdcall MTSCreateActivity ( REFIID riid, void** ppobj );
EXTERN_C HRESULT __stdcall CreateActivityInMTA ( REFIID riid, void** ppobj );


extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0104_v0_0_s_ifspec;

#ifndef __IMTSCall_INTERFACE_DEFINED__
#define __IMTSCall_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSCall
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IMTSCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372AEF-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCall )( 
            IMTSCall __RPC_FAR * This);
        
        END_INTERFACE
    } IMTSCallVtbl;

    interface IMTSCall
    {
        CONST_VTBL struct IMTSCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSCall_OnCall(This)	\
    (This)->lpVtbl -> OnCall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMTSCall_OnCall_Proxy( 
    IMTSCall __RPC_FAR * This);


void __RPC_STUB IMTSCall_OnCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSCall_INTERFACE_DEFINED__ */


#ifndef __IMTSActivity_INTERFACE_DEFINED__
#define __IMTSActivity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSActivity
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IMTSActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372AF0-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCall( 
            /* [in] */ IMTSCall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCall( 
            /* [in] */ IMTSCall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCallWithAdvice( 
            /* [in] */ IMTSCall __RPC_FAR *pCall,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual void STDMETHODCALLTYPE BindToCurrentThread( void) = 0;
        
        virtual void STDMETHODCALLTYPE UnbindFromThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSActivity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSActivity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCall )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AsyncCall )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AsyncCallWithAdvice )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall,
            /* [in] */ REFCLSID rclsid);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *BindToCurrentThread )( 
            IMTSActivity __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnbindFromThread )( 
            IMTSActivity __RPC_FAR * This);
        
        END_INTERFACE
    } IMTSActivityVtbl;

    interface IMTSActivity
    {
        CONST_VTBL struct IMTSActivityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSActivity_SynchronousCall(This,pCall)	\
    (This)->lpVtbl -> SynchronousCall(This,pCall)

#define IMTSActivity_AsyncCall(This,pCall)	\
    (This)->lpVtbl -> AsyncCall(This,pCall)

#define IMTSActivity_AsyncCallWithAdvice(This,pCall,rclsid)	\
    (This)->lpVtbl -> AsyncCallWithAdvice(This,pCall,rclsid)

#define IMTSActivity_BindToCurrentThread(This)	\
    (This)->lpVtbl -> BindToCurrentThread(This)

#define IMTSActivity_UnbindFromThread(This)	\
    (This)->lpVtbl -> UnbindFromThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMTSActivity_SynchronousCall_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall);


void __RPC_STUB IMTSActivity_SynchronousCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMTSActivity_AsyncCall_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall);


void __RPC_STUB IMTSActivity_AsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMTSActivity_AsyncCallWithAdvice_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IMTSActivity_AsyncCallWithAdvice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMTSActivity_BindToCurrentThread_Proxy( 
    IMTSActivity __RPC_FAR * This);


void __RPC_STUB IMTSActivity_BindToCurrentThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMTSActivity_UnbindFromThread_Proxy( 
    IMTSActivity __RPC_FAR * This);


void __RPC_STUB IMTSActivity_UnbindFromThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSActivity_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\mdcommsg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    commsg.h

Abstract:

    HRESULT <-> Win32 error mapping macros.

Author:

    Michael W. Thomas (michth)   24-Sep-1996

Revision History:

    Keith Moore (keithmo)        07-Feb-1997
        Cleanup, comment, made Metadata errors "real" HRESULTs.

--*/


#ifndef _COMMSG_H_
#define _COMMSG_H_


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))


//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#endif  // _COMMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\mbconsts.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mbconsts.h

Abstract:

    Common place for defaults and ranges to be declared
    for metabase properties used atleast by WAS.

Author:

    EmilyK 4/17/2002 

Revision History:

--*/


#ifndef _MBCONST_H_
#define _MBCONST_H_

#include <httpp.h>

//
// Internal defines to make numbers easier to understand.

#define MBCONST_UTIL_DEFINE_MAX_ULONG                   0xFFFFFFFF
#define MBCONST_UTIL_DEFINE_MAX_KB_IN_ULONG_OF_BYTES    ( MAX_ULONG / 1024 )
#define MBCONST_UTIL_DEFINE_3_GIG_IN_KB                 ( 1024 * 1024 * 3 )
#define MBCONST_UTIL_DEFINE_MAX_SECONDS_IN_ULONG_OF_MS  MBCONST_UTIL_DEFINE_MAX_ULONG / 1000
#define MBCONST_UTIL_DEFINE_MAX_MINS_IN_ULONG_OF_MS     MBCONST_UTIL_DEFINE_MAX_SECONDS_IN_ULONG_OF_MS / 60

//
// W3SVC properties
//
#define MBCONST_MAX_GLOBAL_BANDWIDTH_NAME        L"MaxGlobalBandwidth"
#define MBCONST_MAX_GLOBAL_BANDWIDTH_DEFAULT     MBCONST_UTIL_DEFINE_MAX_ULONG
#define MBCONST_MAX_GLOBAL_BANDWIDTH_LOW         1024
// value is not defined yet in the version of httpp.h that we have so 
// at some later date we should remove the above line and activate this line.
// #define MBCONST_MAX_GLOBAL_BANDWIDTH_LOW         HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE
#define MBCONST_MAX_GLOBAL_BANDWIDTH_HIGH        MBCONST_UTIL_DEFINE_MAX_ULONG

//
// Site properties
//
#define MBCONST_MAX_BANDWIDTH_NAME        L"MaxBandwidth"
#define MBCONST_MAX_BANDWIDTH_DEFAULT     MBCONST_UTIL_DEFINE_MAX_ULONG
#define MBCONST_MAX_BANDWIDTH_LOW         1024
// value is not defined yet in the version of httpp.h that we have so 
// at some later date we should remove the above line and activate this line.
// #define MBCONST_MAX_GLOBAL_BANDWIDTH_LOW         HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE
#define MBCONST_MAX_BANDWIDTH_HIGH        MBCONST_UTIL_DEFINE_MAX_ULONG

#define MBCONST_CONNECTION_TIMEOUT_NAME                   L"ConnectionTimeout"
#define MBCONST_CONNECTION_TIMEOUT_DEFAULT                120
#define MBCONST_CONNECTION_TIMEOUT_LOW                    0
#define MBCONST_CONNECTION_TIMEOUT_HIGH                   0xFFFF

#define MBCONST_HEADER_WAIT_TIMEOUT_NAME                  L"HeaderWaitTimeout"
#define MBCONST_HEADER_WAIT_TIMEOUT_DEFAULT               0
#define MBCONST_HEADER_WAIT_TIMEOUT_LOW                   0
#define MBCONST_HEADER_WAIT_TIMEOUT_HIGH                  0xFFFF

//
// AppPool poperties
//
#define MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_NAME        L"PeriodicRestartPrivateMemory"
#define MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_DEFAULT     0
#define MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_LOW         0
#define MBCONST_PERIODIC_RESTART_PRIVATE_MEMORY_HIGH        MBCONST_UTIL_DEFINE_3_GIG_IN_KB

#define MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_NAME        L"PeriodicRestartMemory"
#define MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_DEFAULT     512000
#define MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_LOW         0
#define MBCONST_PERIODIC_RESTART_VIRTUAL_MEMORY_HIGH        MBCONST_UTIL_DEFINE_MAX_KB_IN_ULONG_OF_BYTES

#define MBCONST_PERIODIC_RESTART_TIME_NAME                  L"PeriodicRestartTime"
#define MBCONST_PERIODIC_RESTART_TIME_DEFAULT               60   // every hour ( 60 minutes )
#define MBCONST_PERIODIC_RESTART_TIME_LOW                   0
#define MBCONST_PERIODIC_RESTART_TIME_HIGH                  MBCONST_UTIL_DEFINE_MAX_MINS_IN_ULONG_OF_MS

#define MBCONST_APP_POOL_QUEUE_LENGTH_NAME                  L"AppPoolQueueLength"
#define MBCONST_APP_POOL_QUEUE_LENGTH_DEFAULT               1000
#define MBCONST_APP_POOL_QUEUE_LENGTH_LOW                   10
#define MBCONST_APP_POOL_QUEUE_LENGTH_HIGH                  65535

#define MBCONST_PING_INTERVAL_NAME                          L"PingInterval"
#define MBCONST_PING_INTERVAL_DEFAULT                       30
#define MBCONST_PING_INTERVAL_LOW                           1
#define MBCONST_PING_INTERVAL_HIGH                          MBCONST_UTIL_DEFINE_MAX_SECONDS_IN_ULONG_OF_MS

#define MBCONST_RAPID_FAIL_INTERVAL_NAME                    L"RapidFailProtectionInterval"
#define MBCONST_RAPID_FAIL_INTERVAL_DEFAULT                 5
#define MBCONST_RAPID_FAIL_INTERVAL_LOW                     1
#define MBCONST_RAPID_FAIL_INTERVAL_HIGH                    MBCONST_UTIL_DEFINE_MAX_MINS_IN_ULONG_OF_MS

#define MBCONST_RAPID_FAIL_CRASHES_NAME                     L"RapidFailProtectionMaxCrashes"
#define MBCONST_RAPID_FAIL_CRASHES_DEFAULT                  5
#define MBCONST_RAPID_FAIL_CRASHES_LOW                      1
#define MBCONST_RAPID_FAIL_CRASHES_HIGH                     MBCONST_UTIL_DEFINE_MAX_ULONG

#define MBCONST_DEMAND_START_THRESHOLD_NAME                 L"DemandStartThreshold"
#define MBCONST_DEMAND_START_THRESHOLD_DEFAULT              MBCONST_UTIL_DEFINE_MAX_ULONG
#define MBCONST_DEMAND_START_THRESHOLD_LOW                  10
#define MBCONST_DEMAND_START_THRESHOLD_HIGH                 MBCONST_UTIL_DEFINE_MAX_ULONG

#define MBCONST_WP_STARTUP_TIMELIMIT_NAME                   L"StartupTimeLimit"
#define MBCONST_WP_STARTUP_TIMELIMIT_DEFAULT                90
#define MBCONST_WP_STARTUP_TIMELIMIT_LOW                    1
#define MBCONST_WP_STARTUP_TIMELIMIT_HIGH                   MBCONST_UTIL_DEFINE_MAX_SECONDS_IN_ULONG_OF_MS


#endif  // _REGCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\lstentry.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__


//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\opt_rest.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    opt_rest.h

Abstract:

    This file restores default optimizations. This pragma is placed in a
    separate file to make it easier to tune later.

    The other opt_*.h files complement this file.

Author:

    Keith Moore (keithmo)       23-Jul-1997

Revision History:

--*/

#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\mtxadmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:04 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxadmin_h__
#define __mtxadmin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICatalog_FWD_DEFINED__
#define __ICatalog_FWD_DEFINED__
typedef interface ICatalog ICatalog;
#endif 	/* __ICatalog_FWD_DEFINED__ */


#ifndef __ICatalogObject_FWD_DEFINED__
#define __ICatalogObject_FWD_DEFINED__
typedef interface ICatalogObject ICatalogObject;
#endif 	/* __ICatalogObject_FWD_DEFINED__ */


#ifndef __ICatalogCollection_FWD_DEFINED__
#define __ICatalogCollection_FWD_DEFINED__
typedef interface ICatalogCollection ICatalogCollection;
#endif 	/* __ICatalogCollection_FWD_DEFINED__ */


#ifndef __IComponentUtil_FWD_DEFINED__
#define __IComponentUtil_FWD_DEFINED__
typedef interface IComponentUtil IComponentUtil;
#endif 	/* __IComponentUtil_FWD_DEFINED__ */


#ifndef __IPackageUtil_FWD_DEFINED__
#define __IPackageUtil_FWD_DEFINED__
typedef interface IPackageUtil IPackageUtil;
#endif 	/* __IPackageUtil_FWD_DEFINED__ */


#ifndef __IRemoteComponentUtil_FWD_DEFINED__
#define __IRemoteComponentUtil_FWD_DEFINED__
typedef interface IRemoteComponentUtil IRemoteComponentUtil;
#endif 	/* __IRemoteComponentUtil_FWD_DEFINED__ */


#ifndef __IRoleAssociationUtil_FWD_DEFINED__
#define __IRoleAssociationUtil_FWD_DEFINED__
typedef interface IRoleAssociationUtil IRoleAssociationUtil;
#endif 	/* __IRoleAssociationUtil_FWD_DEFINED__ */


#ifndef __Catalog_FWD_DEFINED__
#define __Catalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class Catalog Catalog;
#else
typedef struct Catalog Catalog;
#endif /* __cplusplus */

#endif 	/* __Catalog_FWD_DEFINED__ */


#ifndef __CatalogObject_FWD_DEFINED__
#define __CatalogObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogObject CatalogObject;
#else
typedef struct CatalogObject CatalogObject;
#endif /* __cplusplus */

#endif 	/* __CatalogObject_FWD_DEFINED__ */


#ifndef __CatalogCollection_FWD_DEFINED__
#define __CatalogCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogCollection CatalogCollection;
#else
typedef struct CatalogCollection CatalogCollection;
#endif /* __cplusplus */

#endif 	/* __CatalogCollection_FWD_DEFINED__ */


#ifndef __ComponentUtil_FWD_DEFINED__
#define __ComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentUtil ComponentUtil;
#else
typedef struct ComponentUtil ComponentUtil;
#endif /* __cplusplus */

#endif 	/* __ComponentUtil_FWD_DEFINED__ */


#ifndef __PackageUtil_FWD_DEFINED__
#define __PackageUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class PackageUtil PackageUtil;
#else
typedef struct PackageUtil PackageUtil;
#endif /* __cplusplus */

#endif 	/* __PackageUtil_FWD_DEFINED__ */


#ifndef __RemoteComponentUtil_FWD_DEFINED__
#define __RemoteComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteComponentUtil RemoteComponentUtil;
#else
typedef struct RemoteComponentUtil RemoteComponentUtil;
#endif /* __cplusplus */

#endif 	/* __RemoteComponentUtil_FWD_DEFINED__ */


#ifndef __RoleAssociationUtil_FWD_DEFINED__
#define __RoleAssociationUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RoleAssociationUtil RoleAssociationUtil;
#else
typedef struct RoleAssociationUtil RoleAssociationUtil;
#endif /* __cplusplus */

#endif 	/* __RoleAssociationUtil_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxadmin_0000
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtxadmin.h  -- Microsoft Transaction Server Programming Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.													
//																			
// Microsoft Transaction Server SDK												
// Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_s_ifspec;

#ifndef __ICatalog_INTERFACE_DEFINED__
#define __ICatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalog
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22870-8a19-11d0-81b6-00a0c9231c29")
    ICatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MajorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogVtbl;

    interface ICatalog
    {
        CONST_VTBL struct ICatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalog_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection)

#define ICatalog_Connect(This,bstrConnectString,ppCatalogCollection)	\
    (This)->lpVtbl -> Connect(This,bstrConnectString,ppCatalogCollection)

#define ICatalog_get_MajorVersion(This,retval)	\
    (This)->lpVtbl -> get_MajorVersion(This,retval)

#define ICatalog_get_MinorVersion(This,retval)	\
    (This)->lpVtbl -> get_MinorVersion(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_GetCollection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_Connect_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrConnectString,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MajorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MinorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __ICatalogObject_INTERFACE_DEFINED__
#define __ICatalogObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogObject
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22871-8a19-11d0-81b6-00a0c9231c29")
    ICatalogObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyReadOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Valid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyWriteOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyReadOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Valid )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyWriteOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogObjectVtbl;

    interface ICatalogObject
    {
        CONST_VTBL struct ICatalogObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogObject_get_Value(This,bstrPropName,retval)	\
    (This)->lpVtbl -> get_Value(This,bstrPropName,retval)

#define ICatalogObject_put_Value(This,bstrPropName,val)	\
    (This)->lpVtbl -> put_Value(This,bstrPropName,val)

#define ICatalogObject_get_Key(This,retval)	\
    (This)->lpVtbl -> get_Key(This,retval)

#define ICatalogObject_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogObject_IsPropertyReadOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyReadOnly(This,bstrPropName,retval)

#define ICatalogObject_get_Valid(This,retval)	\
    (This)->lpVtbl -> get_Valid(This,retval)

#define ICatalogObject_IsPropertyWriteOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyWriteOnly(This,bstrPropName,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICatalogObject_put_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [in] */ VARIANT val);


void __RPC_STUB ICatalogObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Key_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Name_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyReadOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Valid_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Valid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyWriteOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyWriteOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogCollection_INTERFACE_DEFINED__
#define __ICatalogCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogCollection
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22872-8a19-11d0-81b6-00a0c9231c29")
    ICatalogCollection : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Populate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoveEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUtilInterface( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByKey( 
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByQuery( 
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Populate )( 
            ICatalogCollection __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RemoveEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUtilInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMajorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMinorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByKey )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByQuery )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType);
        
        END_INTERFACE
    } ICatalogCollectionVtbl;

    interface ICatalogCollection
    {
        CONST_VTBL struct ICatalogCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogCollection_get__NewEnum(This,ppEnumVariant)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumVariant)

#define ICatalogCollection_get_Item(This,lIndex,ppCatalogObject)	\
    (This)->lpVtbl -> get_Item(This,lIndex,ppCatalogObject)

#define ICatalogCollection_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define ICatalogCollection_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define ICatalogCollection_Add(This,ppCatalogObject)	\
    (This)->lpVtbl -> Add(This,ppCatalogObject)

#define ICatalogCollection_Populate(This)	\
    (This)->lpVtbl -> Populate(This)

#define ICatalogCollection_SaveChanges(This,retval)	\
    (This)->lpVtbl -> SaveChanges(This,retval)

#define ICatalogCollection_GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)

#define ICatalogCollection_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogCollection_get_AddEnabled(This,retval)	\
    (This)->lpVtbl -> get_AddEnabled(This,retval)

#define ICatalogCollection_get_RemoveEnabled(This,retval)	\
    (This)->lpVtbl -> get_RemoveEnabled(This,retval)

#define ICatalogCollection_GetUtilInterface(This,ppUtil)	\
    (This)->lpVtbl -> GetUtilInterface(This,ppUtil)

#define ICatalogCollection_get_DataStoreMajorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMajorVersion(This,retval)

#define ICatalogCollection_get_DataStoreMinorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMinorVersion(This,retval)

#define ICatalogCollection_PopulateByKey(This,aKeys)	\
    (This)->lpVtbl -> PopulateByKey(This,aKeys)

#define ICatalogCollection_PopulateByQuery(This,bstrQueryString,lQueryType)	\
    (This)->lpVtbl -> PopulateByQuery(This,bstrQueryString,lQueryType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get__NewEnum_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);


void __RPC_STUB ICatalogCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Item_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Count_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Remove_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex);


void __RPC_STUB ICatalogCollection_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Add_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Populate_Proxy( 
    ICatalogCollection __RPC_FAR * This);


void __RPC_STUB ICatalogCollection_Populate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_SaveChanges_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetCollection_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [in] */ VARIANT varObjectKey,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalogCollection_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Name_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_AddEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_AddEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_RemoveEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_RemoveEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetUtilInterface_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);


void __RPC_STUB ICatalogCollection_GetUtilInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMajorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMinorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByKey_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * aKeys);


void __RPC_STUB ICatalogCollection_PopulateByKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByQuery_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrQueryString,
    /* [in] */ long lQueryType);


void __RPC_STUB ICatalogCollection_PopulateByQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogCollection_INTERFACE_DEFINED__ */


#ifndef __IComponentUtil_INTERFACE_DEFINED__
#define __IComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponentUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22873-8a19-11d0-81b6-00a0c9231c29")
    IComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponentByName( 
            /* [in] */ BSTR bstrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCLSIDs( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponentByName )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDs )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);
        
        END_INTERFACE
    } IComponentUtilVtbl;

    interface IComponentUtil
    {
        CONST_VTBL struct IComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComponentUtil_InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)	\
    (This)->lpVtbl -> InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)

#define IComponentUtil_ImportComponent(This,bstrCLSID)	\
    (This)->lpVtbl -> ImportComponent(This,bstrCLSID)

#define IComponentUtil_ImportComponentByName(This,bstrProgID)	\
    (This)->lpVtbl -> ImportComponentByName(This,bstrProgID)

#define IComponentUtil_GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)	\
    (This)->lpVtbl -> GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_InstallComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [in] */ BSTR bstrProxyStubDLLFile);


void __RPC_STUB IComponentUtil_InstallComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IComponentUtil_ImportComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponentByName_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IComponentUtil_ImportComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_GetCLSIDs_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);


void __RPC_STUB IComponentUtil_GetCLSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IPackageUtil_INTERFACE_DEFINED__
#define __IPackageUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPackageUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IPackageUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22874-8a19-11d0-81b6-00a0c9231c29")
    IPackageUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPackage( 
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownPackage( 
            /* [in] */ BSTR bstrPackageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPackageUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPackageUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPackageUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPackageUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID);
        
        END_INTERFACE
    } IPackageUtilVtbl;

    interface IPackageUtil
    {
        CONST_VTBL struct IPackageUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPackageUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPackageUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPackageUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPackageUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPackageUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPackageUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPackageUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPackageUtil_InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)	\
    (This)->lpVtbl -> InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)

#define IPackageUtil_ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)	\
    (This)->lpVtbl -> ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)

#define IPackageUtil_ShutdownPackage(This,bstrPackageID)	\
    (This)->lpVtbl -> ShutdownPackage(This,bstrPackageID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_InstallPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ BSTR bstrInstallPath,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ExportPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_ExportPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ShutdownPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID);


void __RPC_STUB IPackageUtil_ShutdownPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPackageUtil_INTERFACE_DEFINED__ */


#ifndef __IRemoteComponentUtil_INTERFACE_DEFINED__
#define __IRemoteComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteComponentUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRemoteComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22875-8a19-11d0-81b6-00a0c9231c29")
    IRemoteComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponent( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponentByName( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponent )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponentByName )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID);
        
        END_INTERFACE
    } IRemoteComponentUtilVtbl;

    interface IRemoteComponentUtil
    {
        CONST_VTBL struct IRemoteComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteComponentUtil_InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)	\
    (This)->lpVtbl -> InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)

#define IRemoteComponentUtil_InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)	\
    (This)->lpVtbl -> InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponent_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponentByName_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageName,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IRoleAssociationUtil_INTERFACE_DEFINED__
#define __IRoleAssociationUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRoleAssociationUtil
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRoleAssociationUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22876-8a19-11d0-81b6-00a0c9231c29")
    IRoleAssociationUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRole( 
            /* [in] */ BSTR bstrRoleID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRoleByName( 
            /* [in] */ BSTR bstrRoleName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRoleAssociationUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRole )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRoleByName )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleName);
        
        END_INTERFACE
    } IRoleAssociationUtilVtbl;

    interface IRoleAssociationUtil
    {
        CONST_VTBL struct IRoleAssociationUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRoleAssociationUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRoleAssociationUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRoleAssociationUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRoleAssociationUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRoleAssociationUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRoleAssociationUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRoleAssociationUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRoleAssociationUtil_AssociateRole(This,bstrRoleID)	\
    (This)->lpVtbl -> AssociateRole(This,bstrRoleID)

#define IRoleAssociationUtil_AssociateRoleByName(This,bstrRoleName)	\
    (This)->lpVtbl -> AssociateRoleByName(This,bstrRoleName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRole_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleID);


void __RPC_STUB IRoleAssociationUtil_AssociateRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRoleByName_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleName);


void __RPC_STUB IRoleAssociationUtil_AssociateRoleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRoleAssociationUtil_INTERFACE_DEFINED__ */



#ifndef __MTSAdmin_LIBRARY_DEFINED__
#define __MTSAdmin_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSAdmin
 * at Thu Sep 11 16:03:04 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0001
    {	mtsInstallUsers	= 1
    }	MTSPackageInstallOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0002
    {	mtsExportUsers	= 1
    }	MTSPackageExportOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0003
    {	mtsErrObjectErrors	= 0x80110401,
	mtsErrObjectInvalid	= 0x80110402,
	mtsErrKeyMissing	= 0x80110403,
	mtsErrAlreadyInstalled	= 0x80110404,
	mtsErrDownloadFailed	= 0x80110405,
	mtsErrPDFWriteFail	= 0x80110407,
	mtsErrPDFReadFail	= 0x80110408,
	mtsErrPDFVersion	= 0x80110409,
	mtsErrCoReqCompInstalled	= 0x80110410,
	mtsErrBadPath	= 0x8011040a,
	mtsErrPackageExists	= 0x8011040b,
	mtsErrRoleExists	= 0x8011040c,
	mtsErrCantCopyFile	= 0x8011040d,
	mtsErrNoTypeLib	= 0x8011040e,
	mtsErrNoUser	= 0x8011040f,
	mtsErrInvalidUserids	= 0x80110410,
	mtsErrNoRegistryCLSID	= 0x80110411,
	mtsErrBadRegistryProgID	= 0x80110412,
	mtsErrAuthenticationLevel	= 0x80110413,
	mtsErrUserPasswdNotValid	= 0x80110414,
	mtsErrNoRegistryRead	= 0x80110415,
	mtsErrNoRegistryWrite	= 0x80110416,
	mtsErrNoRegistryRepair	= 0x80110417,
	mtsErrCLSIDOrIIDMismatch	= 0x80110418,
	mtsErrRemoteInterface	= 0x80110419,
	mtsErrDllRegisterServer	= 0x8011041a,
	mtsErrNoServerShare	= 0x8011041b,
	mtsErrNoAccessToUNC	= 0x8011041c,
	mtsErrDllLoadFailed	= 0x8011041d,
	mtsErrBadRegistryLibID	= 0x8011041e,
	mtsErrPackDirNotFound	= 0x8011041f,
	mtsErrTreatAs	= 0x80110420,
	mtsErrBadForward	= 0x80110421,
	mtsErrBadIID	= 0x80110422,
	mtsErrRegistrarFailed	= 0x80110423,
	mtsErrCompFileDoesNotExist	= 0x80110424,
	mtsErrCompFileLoadDLLFail	= 0x80110425,
	mtsErrCompFileGetClassObj	= 0x80110426,
	mtsErrCompFileClassNotAvail	= 0x80110427,
	mtsErrCompFileBadTLB	= 0x80110428,
	mtsErrCompFileNotInstallable	= 0x80110429,
	mtsErrNotChangeable	= 0x8011042a,
	mtsErrNotDeletable	= 0x8011042b,
	mtsErrSession	= 0x8011042c,
	mtsErrCompFileNoRegistrar	= 0x80110434
    }	MTSAdminErrorCodes;

#define E_MTS_OBJECTERRORS			 	mtsErrObjectErrors				
#define E_MTS_OBJECTINVALID				mtsErrObjectInvalid				
#define E_MTS_KEYMISSING				mtsErrKeyMissing				
#define E_MTS_ALREADYINSTALLED			mtsErrAlreadyInstalled			
#define E_MTS_DOWNLOADFAILED			mtsErrDownloadFailed			
#define E_MTS_PDFWRITEFAIL				mtsErrPDFWriteFail				
#define E_MTS_PDFREADFAIL				mtsErrPDFReadFail				
#define E_MTS_PDFVERSION				mtsErrPDFVersion				
#define E_MTS_COREQCOMPINSTALLED		mtsErrCoReqCompInstalled		
#define E_MTS_BADPATH					mtsErrBadPath					
#define E_MTS_PACKAGEEXISTS				mtsErrPackageExists				
#define E_MTS_ROLEEXISTS				mtsErrRoleExists				
#define E_MTS_CANTCOPYFILE				mtsErrCantCopyFile				
#define E_MTS_NOTYPELIB					mtsErrNoTypeLib					
#define E_MTS_NOUSER					mtsErrNoUser					
#define E_MTS_INVALIDUSERIDS			mtsErrInvalidUserids			
#define E_MTS_NOREGISTRYCLSID			mtsErrNoRegistryCLSID			
#define E_MTS_BADREGISTRYPROGID			mtsErrBadRegistryProgID			
#define E_MTS_AUTHENTICATIONLEVEL		mtsErrAuthenticationLevel		
#define E_MTS_USERPASSWDNOTVALID		mtsErrUserPasswdNotValid		
#define E_MTS_NOREGISTRYREAD			mtsErrNoRegistryRead			
#define E_MTS_NOREGISTRYWRITE			mtsErrNoRegistryWrite			
#define E_MTS_NOREGISTRYREPAIR			mtsErrNoRegistryRepair			
#define E_MTS_CLSIDORIIDMISMATCH		mtsErrCLSIDOrIIDMismatch		
#define E_MTS_REMOTEINTERFACE			mtsErrRemoteInterface			
#define E_MTS_DLLREGISTERSERVER			mtsErrDllRegisterServer			
#define E_MTS_NOSERVERSHARE				mtsErrNoServerShare				
#define E_MTS_NOACCESSTOUNC				mtsErrNoAccessToUNC				
#define E_MTS_DLLLOADFAILED				mtsErrDllLoadFailed				
#define E_MTS_BADREGISTRYLIBID			mtsErrBadRegistryLibID			
#define E_MTS_PACKDIRNOTFOUND			mtsErrPackDirNotFound			
#define E_MTS_TREATAS					mtsErrTreatAs					
#define E_MTS_BADFORWARD				mtsErrBadForward				
#define E_MTS_BADIID					mtsErrBadIID					
#define E_MTS_REGISTRARFAILED			mtsErrRegistrarFailed			
#define E_MTS_COMPFILE_DOESNOTEXIST		mtsErrCompFileDoesNotExist		
#define E_MTS_COMPFILE_LOADDLLFAIL		mtsErrCompFileLoadDLLFail		
#define E_MTS_COMPFILE_GETCLASSOBJ		mtsErrCompFileGetClassObj		
#define E_MTS_COMPFILE_CLASSNOTAVAIL	mtsErrCompFileClassNotAvail		
#define E_MTS_COMPFILE_BADTLB			mtsErrCompFileBadTLB			
#define E_MTS_COMPFILE_NOTINSTALLABLE	mtsErrCompFileNotInstallable	
#define E_MTS_NOTCHANGEABLE				mtsErrNotChangeable				
#define E_MTS_NOTDELETEABLE				mtsErrNotDeleteable				
#define E_MTS_SESSION					mtsErrSession					
#define E_MTS_COMPFILE_NOREGISTRAR		mtsErrCompFileNoRegistrar		

EXTERN_C const IID LIBID_MTSAdmin;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Catalog;

class DECLSPEC_UUID("6eb22881-8a19-11d0-81b6-00a0c9231c29")
Catalog;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogObject;

class DECLSPEC_UUID("6eb22882-8a19-11d0-81b6-00a0c9231c29")
CatalogObject;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogCollection;

class DECLSPEC_UUID("6eb22883-8a19-11d0-81b6-00a0c9231c29")
CatalogCollection;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ComponentUtil;

class DECLSPEC_UUID("6eb22884-8a19-11d0-81b6-00a0c9231c29")
ComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PackageUtil;

class DECLSPEC_UUID("6eb22885-8a19-11d0-81b6-00a0c9231c29")
PackageUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RemoteComponentUtil;

class DECLSPEC_UUID("6eb22886-8a19-11d0-81b6-00a0c9231c29")
RemoteComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RoleAssociationUtil;

class DECLSPEC_UUID("6eb22887-8a19-11d0-81b6-00a0c9231c29")
RoleAssociationUtil;
#endif
#endif /* __MTSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\opt_time.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    opt_time.h

Abstract:

    This file enables time-based (speed) optimizations. This pragma is
    placed in a separate file to make it easier to tune later.

    opt_rest.h is the complement to this file.

Author:

    Keith Moore (keithmo)       23-Jul-1997

Revision History:

--*/

#pragma optimize( "t", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\sharelok.h ===
#ifndef __SHARELOCK_H__
#define __SHARELOCK_H__

//////////////////////////////////////////////////////////////////////
//
//   The standard include files.
//
//   The standard include files setup a consistent environment
//   for all of the modules in a program.  The structure of each
//   header file is as follows:
//      1. Standard include files.
//      2. Include files for inherited classes.
//      3. Constants exported from the class.
//      4. Data structures exported from the class.
//      5. Class specification.
//      6. Inline functions.
//   Sections that are not required are omitted.
//
//////////////////////////////////////////////////////////////////////

// #include "Global.h"
// #include "NewEx.h"
// #include "Standard.h"
// #include "System.h"

#include <irtlmisc.h>

typedef int SBIT32;

//////////////////////////////////////////////////////////////////////
//
//   Sharelock and Semaphore locking.
//
//   This class provides a very conservative locking scheme.
//   The assumption behind the code is that locks will be
//   held for a very short time.  A lock can be obtained in
//   either exclusive mode or shared mode.  If the lock is not
//   available the caller waits by spinning or if that fails
//   by sleeping.
//
//////////////////////////////////////////////////////////////////////

class IRTL_DLLEXP CSharelock
{ 
	private:

		// internally used constants

		enum Internal
		{
			//   The Windows NT kernel requires a maximum wakeup count when
			//   creating a semaphore.
			m_MaxShareLockUsers      = 256
		};

        //
        //   Private data.
        //
        volatile LONG                 m_lExclusive;
        volatile LONG                 m_lTotalUsers;

		SBIT32                        m_lMaxSpins;
		SBIT32                        m_lMaxUsers;
        HANDLE                        m_hSemaphore;
        volatile LONG                 m_lWaiting;

#ifdef _DEBUG

        //
        //   Counters for debugging builds.
        //
        volatile LONG                 m_lTotalExclusiveLocks;
        volatile LONG                 m_lTotalShareLocks;
        volatile LONG                 m_lTotalSleeps;
        volatile LONG                 m_lTotalSpins;
        volatile LONG                 m_lTotalTimeouts;
        volatile LONG                 m_lTotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        CSharelock( SBIT32 lNewMaxSpins = 4096, SBIT32 lNewMaxUsers = 256 );

        inline SBIT32 ActiveUsers( void ) { return (SBIT32) m_lTotalUsers; }

        inline void ChangeExclusiveLockToSharedLock( void );

        inline BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimShareLock( SBIT32 lSleep = INFINITE );

        inline void ReleaseExclusiveLock( void );

        inline void ReleaseShareLock( void );

        BOOLEAN UpdateMaxSpins( SBIT32 lNewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 lNewMaxUsers );

        ~CSharelock( void );


	private:
        //
        //   Private functions.
        //
        BOOLEAN SleepWaitingForLock( SBIT32 lSleep );

        BOOLEAN WaitForExclusiveLock( SBIT32 lSleep );

        BOOLEAN WaitForShareLock( SBIT32 lSleep );

        void WakeAllSleepers( void );      

    private:
        //
        //   Disabled operations.
        //
        CSharelock( const CSharelock & Copy );

        void operator=( const CSharelock & Copy );
};

/********************************************************************/
/*                                                                  */
/*   Change an exclusive lock to a shread lock.                     */
/*                                                                  */
/*   Downgrade the existing exclusive lock to a shared lock.        */
/*                                                                  */
/********************************************************************/

inline void CSharelock::ChangeExclusiveLockToSharedLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );
    
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif
}

/********************************************************************/
/*                                                                  */
/*   Change a shared lock to an exclusive lock.                     */
/*                                                                  */
/*   Upgrade the existing shared lock to an exclusive lock.         */
/*                                                                  */
/********************************************************************/

inline BOOLEAN CSharelock::ChangeSharedLockToExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
    
	if ( m_lTotalUsers != 1 )
    {
		if ( ! WaitForExclusiveLock( lSleep ) )
        { return FALSE; }
    }
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//
//   Claim an exclusive lock.
//
//   Claim an exclusive lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( m_lTotalUsers != 1 )
	{
		if ( ! WaitForExclusiveLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Claim a shared lock.
//
//   Claim a shared lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimShareLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
	{
		if ( ! WaitForShareLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Release an exclusive lock.
//
//   Release an exclusive lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseExclusiveLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Release a shared lock.
//
//   Release a shared lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseShareLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

#endif // __SHARELOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\mtxrepl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:05 1997
 */
/* Compiler settings for mtxrepl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxrepl_h__
#define __mtxrepl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMTSReplicateCatalog_FWD_DEFINED__
#define __IMTSReplicateCatalog_FWD_DEFINED__
typedef interface IMTSReplicateCatalog IMTSReplicateCatalog;
#endif 	/* __IMTSReplicateCatalog_FWD_DEFINED__ */


#ifndef __ReplicateCatalog_FWD_DEFINED__
#define __ReplicateCatalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class ReplicateCatalog ReplicateCatalog;
#else
typedef struct ReplicateCatalog ReplicateCatalog;
#endif /* __cplusplus */

#endif 	/* __ReplicateCatalog_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMTSReplicateCatalog_INTERFACE_DEFINED__
#define __IMTSReplicateCatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSReplicateCatalog
 * at Thu Sep 11 16:03:05 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IMTSReplicateCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8C836AF8-FFAC-11D0-8ED4-00C04FC2C17B")
    IMTSReplicateCatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MTSComputerToComputer( 
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IISComputerToComputer( 
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSReplicateCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSReplicateCatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSReplicateCatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MTSComputerToComputer )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IISComputerToComputer )( 
            IMTSReplicateCatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrServerDest,
            /* [in] */ BSTR bstrServerSrc);
        
        END_INTERFACE
    } IMTSReplicateCatalogVtbl;

    interface IMTSReplicateCatalog
    {
        CONST_VTBL struct IMTSReplicateCatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSReplicateCatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSReplicateCatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSReplicateCatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSReplicateCatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMTSReplicateCatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMTSReplicateCatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMTSReplicateCatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMTSReplicateCatalog_MTSComputerToComputer(This,bstrServerDest,bstrServerSrc)	\
    (This)->lpVtbl -> MTSComputerToComputer(This,bstrServerDest,bstrServerSrc)

#define IMTSReplicateCatalog_IISComputerToComputer(This,bstrServerDest,bstrServerSrc)	\
    (This)->lpVtbl -> IISComputerToComputer(This,bstrServerDest,bstrServerSrc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMTSReplicateCatalog_MTSComputerToComputer_Proxy( 
    IMTSReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrServerDest,
    /* [in] */ BSTR bstrServerSrc);


void __RPC_STUB IMTSReplicateCatalog_MTSComputerToComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMTSReplicateCatalog_IISComputerToComputer_Proxy( 
    IMTSReplicateCatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrServerDest,
    /* [in] */ BSTR bstrServerSrc);


void __RPC_STUB IMTSReplicateCatalog_IISComputerToComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSReplicateCatalog_INTERFACE_DEFINED__ */



#ifndef __MTSReplLib_LIBRARY_DEFINED__
#define __MTSReplLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSReplLib
 * at Thu Sep 11 16:03:05 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MTSReplLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ReplicateCatalog;

class DECLSPEC_UUID("8C836AF9-FFAC-11D0-8ED4-00C04FC2C17B")
ReplicateCatalog;
#endif
#endif /* __MTSReplLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\package.h ===
//*****************************************************************************
//
// Microsoft Viper 97 (Microsoft Confidential)
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// Project:		MTxEx.DLL
// Module:		Package.H
// Description:	IMTSPackage et al header
// Author:		wilfr
// Create:		03/13/97
//-----------------------------------------------------------------------------
// Notes:
//
//	none
//
//-----------------------------------------------------------------------------
// Issues:
//
//	UNDONE: these methods accept a flag indicating the system package. Determining the
//			system package should be done by a lookup in our catalog instead.
//
//-----------------------------------------------------------------------------
// Architecture:
//
//  This class is a result of a CoCI -- must be done from the MTA or CoCI will fail
//
//******************************************************************************
#ifndef _Package_H_
#define _Package_H_

#include <objbase.h>


//
// IMTSPackageControl callback interface (NOTE: this is a local interface only and therefore
//												does not require HRESULTs as retvals.
//
DEFINE_GUID( IID_IMTSPackageControl, 0x51372af1,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IMTSPackageControl, IUnknown )
{
	// called when shutdown idle time has lapsed
	STDMETHOD_(void, IdleTimeExpiredForShutdown)( THIS ) PURE;

	// called when adminstrator executes "Shutdown all server processes" from MTS Explorer.
	STDMETHOD_(void, ForcedShutdownRequested)( THIS ) PURE;
};


//
// IMTSPackage
//
DEFINE_GUID( IID_IMTSPackage, 0x51372af2,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IMTSPackage, IUnknown )
{
	STDMETHOD(LoadPackageByGUID)( THIS_ GUID guidPackage ) PURE;
	STDMETHOD(LoadPackageByName)( THIS_ BSTR bstrPackage ) PURE;
	STDMETHOD(Run)( THIS_ IMTSPackageControl* pControl ) PURE;
	STDMETHOD(Shutdown)( THIS_ BOOL bForced ) PURE;
};


//
// IThreadEvents
//
DEFINE_GUID( IID_IThreadEvents, 0x51372af9,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IThreadEvents, IUnknown )
{
	STDMETHOD(OnStartup)(THIS) PURE;
	STDMETHOD(OnShutdown)(THIS) PURE;
};


//
// IThreadEventSource
//
DEFINE_GUID( IID_IThreadEventSource, 0x51372afa,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IThreadEventSource, IUnknown )
{
	// Register a thread startup callback
	STDMETHOD(RegisterThreadEventSink)(THIS_ IThreadEvents* psink) PURE;
};

//
// IFailfastControl
//
DEFINE_GUID( IID_IFailfastControl, 0x51372af8,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IFailfastControl, IUnknown )
{
	// gets configuration for runtime handling of application errors 
	STDMETHOD(GetApplFailfast)( THIS_ BOOL* bFailfast ) PURE;

	// sets configuration for runtime handling of application errors 
	STDMETHOD(SetApplFailfast)( THIS_ BOOL bFailfast ) PURE;

};


//
// INonMTSActivation (51372afb-cae7-11cf-be81-00aa00a2fa25)
//
DEFINE_GUID( IID_INonMTSActivation, 0x51372afb, 
			0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( INonMTSActivation, IUnknown )
{
	// TRUE (default) allows MTS to CoCI using CLSCTX_SERVER vs. CLSCTX_INPROC_SERVER only
	STDMETHOD(OutOfProcActivationAllowed)( THIS_ BOOL bOutOfProcOK ) PURE;
};


//
// IImpersonationControl (51372aff-cae7-11cf-be81-00aa00a2fa25)
//
DEFINE_GUID( IID_IImpersonationControl, 0x51372aff, 
			0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IImpersonationControl, IUnknown )
{
	// FALSE (default) tells us that our base clients may use impersonation
	STDMETHOD(ClientsImpersonate)( THIS_ BOOL bClientsImpersonate ) PURE;
};


// CLSID_MTSPackage
DEFINE_GUID( CLSID_MTSPackage, 0x51372af3, 
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Murali R. Krishnan    ( MuraliK )    16-Nov-1995  
         From the common code for perfmon interface (Russ Blake's).

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:

       Sophia Chung  (sophiac)  05-Nov-1996
         Added supports for mutlitple instances.

--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) ((((x)+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    );

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\pudebug.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        pudebug.h

   Abstract:

      This module declares the DEBUG_PRINTS object helpful in
       testing the programs

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994

   Revision History:
      MuraliK  13-Nov-1998  Ported over to IIS-DuctTape

--*/

#if !defined(BUILD_PUDEBUG)
//
// if we are not using this header for building the pudebug library
//  then better this be used with dbgutil.h
//
  # ifndef _DBGUTIL_H_
  // error Please make sure you included dbgutil.h!
  // error   Do not include pudebug.h directly
  #include <dbgutil.h>
  # endif // _DBGUTIL_H_
#endif  

# ifndef _PUDEBUG_H_
# define _PUDEBUG_H_

#ifndef _NO_TRACING_
# define _NO_TRACING_
#endif // _NO_TRACING_

/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# include <windows.h>

# ifndef dllexp
# define dllexp   __declspec( dllexport)
# endif // dllexp

/***********************************************************
 *    Macros
 ************************************************************/

enum  PRINT_REASONS {
    PrintNone     = 0x0,   // Nothing to be printed
    PrintError    = 0x1,   // An error message
    PrintWarning  = 0x2,   // A  warning message
    PrintLog      = 0x3,   // Just logging. Indicates a trace of where ...
    PrintMsg      = 0x4,   // Echo input message
    PrintCritical = 0x5,   // Print and Exit
    PrintAssertion= 0x6    // Printing for an assertion failure
  };


enum  DEBUG_OUTPUT_FLAGS {
    DbgOutputNone     = 0x0,            // None
    DbgOutputKdb      = 0x1,            // Output to Kernel Debugger
    DbgOutputLogFile  = 0x2,            // Output to LogFile
    DbgOutputTruncate = 0x4,            // Truncate Log File if necessary
    DbgOutputStderr   = 0x8,            // Send output to std error
    DbgOutputBackup   = 0x10,           // Make backup of debug file ?
    DbgOutputMemory   = 0x20,           // Dump to memory buffer
    DbgOutputAll      = 0xFFFFFFFF      // All the bits set.
  };


# define MAX_LABEL_LENGTH                 ( 100)


// The following flags are used internally to track what level of tracing we 
// are currently using. Bitmapped for extensibility.
#define DEBUG_FLAG_ODS          0x00000001
#define DEBUG_FLAG_INFO         0x00000002
#define DEBUG_FLAG_WARN         0x00000004
#define DEBUG_FLAG_ERROR        0x00000008
// The following are used internally to determine whether to log or not based 
// on what the current state is
#define DEBUG_FLAGS_INFO        (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO)
#define DEBUG_FLAGS_WARN        (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO | DEBUG_FLAG_WARN)
#define DEBUG_FLAGS_ERROR       (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR)

#define DEBUG_FLAGS_ANY         (DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR)

//
// user of DEBUG infrastructure may choose unique variable name for DEBUG_FLAGS
// that's specially useful for cases where DEBUG infrastructure is used within
// static library (static library may prefer to maintain it's own DebugFlags independent
// on the main program it links to
//
#ifndef DEBUG_FLAGS_VAR
#define DEBUG_FLAGS_VAR g_dwDebugFlags
#endif 

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DWORD  DEBUG_FLAGS_VAR ;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     

# define SET_DEBUG_FLAGS( dwFlags)         DEBUG_FLAGS_VAR = dwFlags
# define GET_DEBUG_FLAGS()                 ( DEBUG_FLAGS_VAR )

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
             DEBUG_FLAGS_VAR = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  \
             DEBUG_FLAGS_VAR = PuLoadDebugFlagsFromRegStr((pszRegKey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


/*++
  class DEBUG_PRINTS

  This class is responsible for printing messages to log file / kernel debugger

  Currently the class supports only member functions for <ANSI> char.
   ( not unicode-strings).

--*/


typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    BOOL         m_fBreakOnAssert;
    DWORD        m_dwOutputFlags;
    VOID        *m_pMemoryLog;
} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;


LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//
LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName, 
   IN const char *         pszFormat,
   ...);    
                           // arglist
VOID
PuDbgPrintW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName, 
   IN const WCHAR *        pszFormat,
   ...);                               // arglist

// PuDbgPrintError is similar to PuDbgPrint() but allows 
// one to print error code in friendly manner
VOID
PuDbgPrintError(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName, 
   IN DWORD                dwError,
   IN const char *         pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/
VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName, 
   IN const char *         pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//

INT
__cdecl
PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFunctionName, 
   IN const char *         pszExpression,
   IN const char *         pszMessage);

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszFunctionName
    );

VOID
PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);

DWORD
PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);


//
// Following functions return Win32 error codes.
// NO_ERROR if success
//

DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);

DWORD
PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuOpenDbgMemoryLog(
    IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuCloseDbgMemoryLog(
    IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault);

DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault);

DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);


# define PuPrintToKdb( pszOutput)    \
                    if ( pszOutput != NULL)   {   \
                        OutputDebugString( pszOutput);  \
                    } else {}



# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable



/***********************************************************
 *    Macros
 ************************************************************/


extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable

# if DBG

// For the CHK build we want ODS enabled. For an explanation of these flags see 
// the comment just after the definition of DBG_CONTEXT
# define DECLARE_DEBUG_PRINTS_OBJECT()                      \
         DEBUG_PRINTS  *  g_pDebug = NULL;                  \
         DWORD  DEBUG_FLAGS_VAR = DEBUG_FLAG_ERROR;

#else // !DBG

# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;      \
         DWORD  DEBUG_FLAGS_VAR = 0;

#endif // !DBG


//
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugStringA( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__, __FUNCTION__

// The 3 main tracing macros, each one corresponds to a different level of 
// tracing

// The 3 main tracing macros, each one corresponds to a different level of 
// tracing
# define DBGINFO(args)      {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_INFO) { PuDbgPrint args; }}
# define DBGWARN(args)      {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_WARN) { PuDbgPrint args; }}
# define DBGERROR(args)     {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_ERROR) { PuDbgPrint args; }}

# define DBGINFOW(args)     {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_INFO) { PuDbgPrintW args; }}
# define DBGWARNW(args)     {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_WARN) { PuDbgPrintW args; }}
# define DBGERRORW(args)    {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_ERROR) { PuDbgPrintW args; }}


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list));
//
# define DBGPRINTF DBGINFO 

//
//  DPERROR() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DPERROR( ( DBG_CONTEXT, error, format-string, 
//                      arguments for format list));
//
# define DPERROR( args)       {if (DEBUG_FLAGS_VAR & DEBUG_FLAGS_ERROR) { PuDbgPrintError args; }}



# if DBG

# define DBG_CODE(s)          s          /* echoes code in debugging mode */

// The same 3 main tracing macros however in this case the macros are only compiled
// into the CHK build. This is necessary because some tracing info used functions or
// variables which are not compiled into the FRE build.
# define CHKINFO(args)      { PuDbgPrint args; }
# define CHKWARN(args)      { PuDbgPrint args; }
# define CHKERROR(args)     { PuDbgPrint args; }

# define CHKINFOW(args)     { PuDbgPrintW args; }
# define CHKWARNW(args)     { PuDbgPrintW args; }
# define CHKERRORW(args)    { PuDbgPrintW args; }

# define DBG_ASSERT( exp )    ((VOID) ( (exp) || PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL)))


# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)

# define DBG_OPEN_MEMORY_LOG()   \
                    PuOpenDbgMemoryLog( g_pDebug )



# define DBGDUMP( args)       PuDbgDump  args

# define DBGPRINT_CURRENT_TIME()  PuDbgPrintCurrentTime( DBG_CONTEXT)

# else // !DBG

# define DBG_CODE(s)        ((void)0) /* Do Nothing */

# define CHKINFO(args)      ((void)0) /* Do Nothing */
# define CHKWARN(args)      ((void)0) /* Do Nothing */
# define CHKERROR(args)     ((void)0) /* Do Nothing */

# define CHKINFOW(args)     ((void)0) /* Do Nothing */
# define CHKWARNW(args)     ((void)0) /* Do Nothing */
# define CHKERRORW(args)    ((void)0) /* Do Nothing */

# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGDUMP( args)                          ((void)0) /* Do nothing */

# define DBG_LOG()                               ((void)0) /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    ((void)0) /* Do Nothing */

# define DBG_OPEN_MEMORY_LOG()                   ((void)0) /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    ((void)0) /* Do Nothing */

# define DBGPRINT_CURRENT_TIME()                 ((void)0) /* Do Nothing */

# endif // !DBG


// end_user_unmodifiable

// begin_user_unmodifiable


#ifdef ASSERT
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)


// end_user_unmodifiable

// begin_user_modifiable

//
//  Debugging constants consist of two pieces.
//  All constants in the range 0x0 to 0x8000 are reserved
//  User extensions may include additional constants (bit flags)
//

# define DEBUG_API_ENTRY                  0x00000001L
# define DEBUG_API_EXIT                   0x00000002L
# define DEBUG_INIT_CLEAN                 0x00000004L
# define DEBUG_ERROR                      0x00000008L

                   // End of Reserved Range
# define DEBUG_RESERVED                   0x00000FFFL

// end_user_modifiable



/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
// original NT4.0sp3 API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
// Otherwise errors will surface to a large extent
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);


//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (1000)

//
// Initializes a critical section and sets its spin count
// to IIS_DEFAULT_CS_SPIN_COUNT.  Equivalent to
// InitializeCriticalSectionAndSpinCount(lpCS, IIS_DEFAULT_CS_SPIN_COUNT),
// but provides a safe thunking layer for older systems that don't provide
// this API.
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
BOOL
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

//
// Macro for the calls to InitializeCriticalSection()
//
# define INITIALIZE_CRITICAL_SECTION(lpCS) IISInitializeCriticalSection(lpCS)

# endif  /* _DEBUG_HXX_ */

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IISRTL\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#if DBG
#define IIS_NAMED_WIN32_OBJECTS 1
#else
#define IIS_NAMED_WIN32_OBJECTS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );

HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );

HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEventA(                                                           \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphoreA(                                                       \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutexA(                                                           \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )

#endif  // IIS_NAMED_WIN32_OBJECTS


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\spxinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    spxinfo.h

Abstract:

    Common constants, etc, for SPX service location

Author:

    Richard L Firth (rfirth) 18-Sep-1995

Revision History:

    18-Sep-1995 rfirth
        Created

--*/

#if !defined(_SPXINFO_)
#define _SPXINFO_

#define INTERNET_SERVICE_SAP_ID         0x64e
#define GATEWAY_SERVER_SECURITY_NAME    "GatewayServerApp"
#define GATEWAY_SERVER_SECURITY         L"GatewayServerApp"
#define GATEWAY_SERVER_SECURITY_AUTH_ID 10
#define GATEWAY_SERVER_PORT_TEXT        "47"
#define GATEWAY_SERVER_PORT             L"47"

#endif // _SPXINFO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\reftrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This is the number of stack backtrace values captured in each
// trace log entry. This value is chosen to make the log entry
// exactly twelve dwords long, making it a bit easier to interpret
// from within the debugger without the debugger extension.
//

#define REF_TRACE_LOG_STACK_DEPTH   9

// No-op value for the Context1,2,3 parameters of WriteRefTraceLogEx
#define REF_TRACE_EMPTY_CONTEXT ((PVOID) -1)


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    LONG NewRefCount;
    PVOID Context;
    PVOID Context1;
    PVOID Context2;
    PVOID Context3;
    DWORD Thread;
    PVOID Stack[REF_TRACE_LOG_STACK_DEPTH];

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

LONG
__cdecl
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    );

LONG
__cdecl
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Context3
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\svcloc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcloc.h

Abstract:

    contains proto-type and data-type definitions for service location
    APIs

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SVCLOC_
#define _SVCLOC_

#include <inetcom.h>    // for internet service identifier

#ifdef __cplusplus
extern "C" {
#endif

//
// constant definitions.
//

//
// internet service identifier mask.
//  each  service is assigned a bit, so that we can
//  accomodate up to 64 service in ULONGLONG type.
//

#if 0
#define INET_FTP_SERVICE            (ULONGLONG)(INET_FTP)
#define INET_GOPHER_SERVICE         (ULONGLONG)(INET_GOPHER)
#define INET_W3_SERVICE             (ULONGLONG)(INET_HTTP)
#define INET_W3_PROXY_SERVICE       (ULONGLONG)(INET_HTTP_PROXY)
#define INET_MSN_SERVICE            (ULONGLONG)(INET_MSN)
#define INET_NNTP_SERVICE           (ULONGLONG)(INET_NNTP)
#define INET_SMTP_SERVICE           (ULONGLONG)(INET_SMTP)
#define INET_POP3_SERVICE           (ULONGLONG)(INET_POP3)
#define INET_GATEWAY_SERVICE        (ULONGLONG)(INET_GATEWAY)
#define INET_CHAT_SERVICE           (ULONGLONG)(INET_CHAT)
#define INET_LDAP_SERVICE           (ULONGLONG)(INET_LDAP)
#define INET_IMAP_SERVICE           (ULONGLONG)(INET_IMAP)
#endif

//
// IIS 3.0 Service location id
//

// When adding a new service ID, add it the INET_ALL_SERVICES_ID
#define INET_FTP_SVCLOC_ID          (ULONGLONG)(0x0000000000000001)
#define INET_GOPHER_SVCLOC_ID       (ULONGLONG)(0x0000000000000002)
#define INET_W3_SVCLOC_ID           (ULONGLONG)(0x0000000000000004)
#define INET_MW3_SVCLOC_ID          (ULONGLONG)(0x8000000000000000)
#define INET_MFTP_SVCLOC_ID         (ULONGLONG)(0x4000000000000000)

#define INET_ALL_SERVICES_ID        ( INET_FTP_SVCLOC_ID |          \
                                      INET_W3_SVCLOC_ID )

//
// default wait time for server discovery.
//

#define SVC_DEFAULT_WAIT_TIME   0x5    // 5 secs.

//
// Datatype definitions.
//
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

typedef enum _INET_SERVICE_STATE {
    INetServiceStopped,
        // the service has invoked de-registration or
        // the service has never called registration.
    INetServiceRunning,
        // the service is running.
    INetServicePaused
        //  the service is paused.
} INET_SERVICE_STATE, *LPINET_SERVICE_STATE;

typedef struct _INET_BIND_INFO {
    DWORD Length;   // length of bind data.
    PVOID BindData; // bind data, such as binding string or sock addr.
} INET_BIND_INFO, *LPINET_BIND_INFO;

typedef INET_BIND_INFO INET_SERVER_ADDRESS;
typedef LPINET_BIND_INFO LPINET_SERVER_ADDRESS;

typedef struct _INET_BINDINGS {
    DWORD NumBindings;
    LPINET_BIND_INFO BindingsInfo;  // array of bind info structures.
} INET_BINDINGS, *LPINET_BINDINGS;

typedef struct _INET_SERVICE_INFO {
    ULONGLONG ServiceMask;
    INET_SERVICE_STATE ServiceState;
    LPSTR ServiceComment;
    INET_BINDINGS Bindings;
} INET_SERVICE_INFO, *LPINET_SERVICE_INFO;

typedef struct _INET_SERVICES_LIST {
    DWORD NumServices;
    LPINET_SERVICE_INFO *Services; // array of service struct. pointers
} INET_SERVICES_LIST, *LPINET_SERVICES_LIST;

typedef union _INET_VERSION_NUM {
    DWORD VersionNumber;
    struct {
        WORD Major;
        WORD Minor;
    } Version;
} INET_VERSION_NUM, *LPINET_VERSION_NUM;

typedef struct _INET_SERVER_INFO {
    INET_SERVER_ADDRESS ServerAddress; // pointer to a sock addr.
    INET_VERSION_NUM VersionNum;
    LPSTR ServerName;
    DWORD LoadFactor; // in percentage, 0 - idle and 100 - fully loaded
    ULONGLONG ServicesMask;
    INET_SERVICES_LIST Services;
} INET_SERVER_INFO, *LPINET_SERVER_INFO;

typedef struct _INET_SERVERS_LIST {
    DWORD NumServers;
    LPINET_SERVER_INFO *Servers;
} INET_SERVERS_LIST, *LPINET_SERVERS_LIST;

//
// APIs
//

DWORD
WINAPI
INetDiscoverServers(
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API discovers all servers on the network that support and run the
    internet services  specified.

    This API is called by the client side code, such as the internet admin
    tool or wininet.dll.

Arguments:

    SevicesMask : A bit mask that specifies to discover servers with the
        these services running.

        ex: 0x0000000E, will discovers all servers running any of the
            following services :

                1. FTP_SERVICE
                2. GOPHER_SERVICE
                3. WEB_SERVICE

    DiscoverBindings : if this flag is set, this API talks to each of the
        discovered server and queries the services and bindings
        supported. If the flag is set to FALSE, it quickly returns with
        the list of servers only.

    WaitTime : Response wait time in secs. If this value is zero, it
        returns what ever discovered so far by the previous invocation of
        this APIs, otherwise it waits for the specified secs to collect
        responses from the servers.

    ServersList : Pointer to a location where the pointer to list of
        servers info is returned. The API allocates dynamic memory for
        this return data, the caller should free it by calling
        INetFreeDiscoverServerList after it has been used.

Return Value:

    Windows Error Code.

--*/
    ;

DWORD
WINAPI
INetGetServerInfo(
    IN LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API returns the server info and a list of services supported by
    the server and lists of bindings supported by each of the services.

Arguments:

    ServerName : name of the server whose info to be queried.

    ServicesMask : services to be queried

    WaitTime : Time in secs to wait.

    ServerInfo : pointer to a location where the pointer to the server
        info structure will be returned. The caller should  call
        INetFreeServerInfo to free up the list after use.

Return Value:

    Windows Error Code.

--*/
    ;

VOID
WINAPI
INetFreeDiscoverServersList(
    IN OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the servers
    list by the INetDiscoverServers call.

Arguments:

    ServersList : pointer to a location where the pointer to the server
        list to be freed is stored.

Return Value:

    NONE.

--*/
    ;

VOID
WINAPI
INetFreeServerInfo(
    IN OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the server
    info structure by the INetGetServerInfo call.

Arguments:

    ServerInfo : pointer to a location where the pointer to the server
        info structure to be freed is stored.

Return Value:

    NONE.

--*/
    ;

DWORD
WINAPI
INetRegisterService(
    IN ULONGLONG ServiceMask,
    IN INET_SERVICE_STATE ServiceState,
    IN LPSTR ServiceComment,
    IN LPINET_BINDINGS Bindings
    )
/*++

Routine Description:

    This API registers an internet service.  The service writers should
    call this API just after successfully started the service and the
    service is ready to accept incoming RPC calls.  This API accepts an
    array of RPC binding strings that the service is listening on for the
    incoming RPC connections.  This list will be distributed to the
    clients that are discovering this service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

    ServiceState : State of the service, INetServiceRunning and
        INetServicePaused are valid states to pass.

    ServiceComment : Service comment specified by the admin.

    Bindings : list of bindings that are supported by the service. The
        bindings can be binding strings are those returned by the
        RpcBindingToStringBinding call or the sockaddrs.

Return Value:

    Windows Error Code.

--*/
    ;

typedef
DWORD
(WINAPI *INET_REGISTER_SVC_FN)(
    ULONGLONG,
    INET_SERVICE_STATE,
    LPSTR,
    LPINET_BINDINGS
    );


DWORD
WINAPI
INetDeregisterService(
    IN ULONGLONG ServiceMask
    )
/*++

Routine Description:

    This API de-registers an internet service from being announced to the
    discovering clients. The service writers should call this API just
    before shutting down the service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

Return Value:

    Windows Error Code.

--*/
    ;

typedef
DWORD (WINAPI *INET_DEREGISTER_SVC_FN)(
    ULONGLONG
    );

typedef
BOOL (WINAPI * INET_INIT_CONTROL_SVC_FN)(
    VOID
    );

DWORD
DllProcessAttachSvcloc(
    VOID
    );

DWORD
DllProcessDetachSvcloc(
    VOID
    );

//
//  Initializes and terminates the service locator - must call these
//  before using the other APIs
//

BOOL
WINAPI
InitSvcLocator(
    VOID
    );

BOOL
WINAPI
TerminateSvcLocator(
    VOID
    );


extern INET_INIT_CONTROL_SVC_FN         pfnInitSvcLoc;
extern INET_INIT_CONTROL_SVC_FN         pfnTerminateSvcLoc;


#ifdef __cplusplus
}
#endif


#endif  // _SVCLOC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\smalprox.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    smalprox.h

    This module contains the small proxy common code

    FILE HISTORY:
        Johnl       04-Apr-1995     Created

*/

#ifndef _SMALPROX_H_
#define _SMALPROX_H_

#include <urlutil.h>
#include <dirlist.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef BOOL (*PFN_INTERNET_PROTOCOL)(
    IN  struct _INET_DATA_CONTEXT * pIC,
    OUT VOID *                      pBuffer,
    IN  DWORD                       cbBuffer,
    OUT DWORD *                     pcbWritten
    );

#define INET_STATE_UNINITIALIZED    0
#define INET_STATE_OPENNED          1
#define INET_STATE_DONE             2

typedef struct _INET_DATA_CONTEXT
{
    HINTERNET             hServer;         // InternetConnect handle
    HINTERNET             hRequest;        // Protocol request handle
    PFN_INTERNET_PROTOCOL pfnProtocol;
    DWORD                 dwServiceType;   // Protocol Type
    DWORD                 dwState;

    URL_DESCRIPTOR        UrlDesc;         // Various URL bits and pieces
    CHAR *                pszUrlData;      // Allocated buffer for UrlDesc

    //
    //  If an error occurred on open, dwLastError records the error
    //  so we can feed back a nice error during InternetReadFile
    //
    //  pszErrAPI will point to the API which generated the error
    //

    DWORD          dwLastError;

    //
    //  When ftp or gopher return extended errors, we store the text here.
    //  It's inline because we're not guaranteed a CloseInternetData will
    //  happen after an error
    //

    CHAR           achExtError[1024];
    DWORD dwErrorTextLength;
    DWORD dwErrorTextLeft;
    DWORD dwErrorCategory;

#if DBG
    CHAR *         pszErrAPI;
#endif

} INET_DATA_CONTEXT, *LPINET_DATA_CONTEXT;

//
//  Macro for conditionally setting the error API string
//

#if DBG
#define RECORD_ERROR_API( pIC, API )    (pIC)->pszErrAPI = (#API)
#else
#define RECORD_ERROR_API( pIC, API )
#endif

BOOL
OpenInternetData(
    IN HINTERNET               hInternet,
    IN OUT CHAR *              pszHttpProxyReq,
    IN     DWORD               cbHttpProxyReq,
    IN     VOID *              pvOptionalData,
    IN     DWORD               cbOptionalData,
    IN OUT INET_DATA_CONTEXT * pIC,
    IN     BOOL                fCheckHeaders
    );

BOOL
ReadInternetData(
    IN  INET_DATA_CONTEXT * pInetContext,
    OUT VOID *              pBuffer,
    IN  DWORD               cbBuffer,
    OUT DWORD *             pcbRead
    );

#if 0
BOOL
WriteInternetData(
    IN  INET_DATA_CONTEXT * pInetContext,
    IN  VOID *              pBuffer,
    IN  DWORD               cbBuffer,
    OUT DWORD *             pcbWritten
    );
#endif

BOOL
CloseInternetData(
    IN     INET_DATA_CONTEXT * pInetContext
    );

BOOL
FormatInternetError(
    IN  DWORD               dwWin32Error,
    IN  CHAR *              pszErrorAPI OPTIONAL,
    OUT VOID *              pBuffer,
    IN  DWORD               cbBuffer,
    OUT DWORD *             pcbRead,
    IN  const CHAR *        pszErrorMessage OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif //_SMALPROX_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\srvvarid.h ===
/*++

    Copyright    (c)    1995-1996    Microsoft Corporation

    Module  Name :
        srvvarid.h

    Abstract:
   

    Author:

        Taylor Weiss    ( TaylorW )     19-Apr-1999

    Environment:


    Project:

        w3svc.dll       private\inet\iis\svcs\w3\server
        wam.dll         private\inet\iis\svcs\wam\object

    Functions Exported:


    Revision History:

--*/

#ifndef SRVVARID_H
#define SRVVARID_H

/*

All server variables that we may want to cache for out of
process performance.

Currently this list includes the following:
    
    All HTTP 1.1 - General, Request and Content headers
    
    All the non-header server variables exposed in the ASP server variables
    collection. Except those that pose for headers (like HTTP_ALL)
    
    All the headers included in the http fast map

*/

#define ALL_SERVER_VARIABLES()              \
    DEFINE_SV( APPL_MD_PATH )               \
    DEFINE_SV( APPL_PHYSICAL_PATH )         \
    DEFINE_SV( AUTH_PASSWORD )              \
    DEFINE_SV( AUTH_TYPE )                  \
    DEFINE_SV( AUTH_USER )                  \
    DEFINE_SV( CERT_COOKIE )                \
    DEFINE_SV( CERT_FLAGS )                 \
    DEFINE_SV( CERT_ISSUER )                \
    DEFINE_SV( CERT_KEYSIZE )               \
    DEFINE_SV( CERT_SECRETKEYSIZE )         \
    DEFINE_SV( CERT_SERIALNUMBER )          \
    DEFINE_SV( CERT_SERVER_ISSUER )         \
    DEFINE_SV( CERT_SERVER_SUBJECT )        \
    DEFINE_SV( CERT_SUBJECT )               \
    DEFINE_SV( CONTENT_LENGTH )             \
    DEFINE_SV( CONTENT_TYPE )               \
    DEFINE_SV( GATEWAY_INTERFACE )          \
    DEFINE_SV( HTTPS )                      \
    DEFINE_SV( HTTPS_KEYSIZE )              \
    DEFINE_SV( HTTPS_SECRETKEYSIZE )        \
    DEFINE_SV( HTTPS_SERVER_ISSUER )        \
    DEFINE_SV( HTTPS_SERVER_SUBJECT )       \
    DEFINE_SV( INSTANCE_ID )                \
    DEFINE_SV( INSTANCE_META_PATH )         \
    DEFINE_SV( LOCAL_ADDR )                 \
    DEFINE_SV( LOGON_USER )                 \
    DEFINE_SV( PATH_INFO )                  \
    DEFINE_SV( PATH_TRANSLATED )            \
    DEFINE_SV( QUERY_STRING )               \
    DEFINE_SV( REMOTE_ADDR )                \
    DEFINE_SV( REMOTE_HOST )                \
    DEFINE_SV( REMOTE_USER )                \
    DEFINE_SV( REQUEST_METHOD )             \
    DEFINE_SV( SCRIPT_NAME )                \
    DEFINE_SV( SERVER_NAME )                \
    DEFINE_SV( SERVER_PORT )                \
    DEFINE_SV( SERVER_PORT_SECURE )         \
    DEFINE_SV( SERVER_PROTOCOL )            \
    DEFINE_SV( SERVER_SOFTWARE )            \
    DEFINE_SV( URL )                        \
    DEFINE_SV( HTTP_CACHE_CONTROL )         \
    DEFINE_SV( HTTP_CONNECTION )            \
    DEFINE_SV( HTTP_DATE )                  \
    DEFINE_SV( HTTP_PRAGMA )                \
    DEFINE_SV( HTTP_TRANSFER_ENCODING )     \
    DEFINE_SV( HTTP_UPGRADE )               \
    DEFINE_SV( HTTP_TRAILER )               \
    DEFINE_SV( HTTP_VIA )                   \
    DEFINE_SV( HTTP_ACCEPT )                \
    DEFINE_SV( HTTP_ACCEPT_CHARSET )        \
    DEFINE_SV( HTTP_ACCEPT_ENCODING )       \
    DEFINE_SV( HTTP_AUTHORIZATION )         \
    DEFINE_SV( HTTP_EXPECT )                \
    DEFINE_SV( HTTP_FROM )                  \
    DEFINE_SV( HTTP_HOST )                  \
    DEFINE_SV( HTTP_IF_MODIFIED_SINCE )     \
    DEFINE_SV( HTTP_IF_MATCH )              \
    DEFINE_SV( HTTP_IF_NONE_MATCH )         \
    DEFINE_SV( HTTP_IF_RANGE )              \
    DEFINE_SV( HTTP_IF_UNMODIFIED_SINCE )   \
    DEFINE_SV( HTTP_MAX_FORWARDS )          \
    DEFINE_SV( HTTP_PROXY_AUTHORIZATION )   \
    DEFINE_SV( HTTP_RANGE )                 \
    DEFINE_SV( HTTP_REFERER )               \
    DEFINE_SV( HTTP_TE )                    \
    DEFINE_SV( HTTP_USER_AGENT )            \
    DEFINE_SV( HTTP_ALLOW )                 \
    DEFINE_SV( HTTP_CONTENT_ENCODING )      \
    DEFINE_SV( HTTP_CONTENT_LANGUAGE )      \
    DEFINE_SV( HTTP_CONTENT_LENGTH )        \
    DEFINE_SV( HTTP_CONTENT_LOCATION )      \
    DEFINE_SV( HTTP_CONTENT_MD5 )           \
    DEFINE_SV( HTTP_CONTENT_RANGE )         \
    DEFINE_SV( HTTP_CONTENT_TYPE )          \
    DEFINE_SV( HTTP_EXPIRES )               \
    DEFINE_SV( HTTP_LAST_MODIFIED )         \
    DEFINE_SV( HTTP_VERSION )               \
    DEFINE_SV( HTTP_UA_OS )                 \

// Define ordinals for each of the cachable server variables. 

#define DEFINE_SV( token )                  \
    SVID_##token, 

#define END_SVID()                          \
    SVID_COUNT

enum SV_IDS
{
    ALL_SERVER_VARIABLES()
    END_SVID()
};

#undef DEFINE_SV


#endif // SRVVARID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\tcpproc.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    tcpproc.hxx

    Exports misc. bits of TCP services helper DLL stuff

    FILE HISTORY:
        Johnl       09-Oct-1994 Created.


        MuraliK     31-July-1995 ReadRegistryString added +
                                 Schedule items function decls moved out.

        MuraliK     23-Feb-1996  Added IslFormatDate()

*/

#ifndef _TCPPROC_H_
#define _TCPPROC_H_

//
// Heap Routines
//
#ifdef __cplusplus

#include <string.hxx>

extern "C" {

dllexp
BOOL
ReadRegistryStr(
    IN HKEY hkeyReg,
    OUT STR & str,
    IN LPCTSTR lpszValueName,
    IN LPCTSTR lpszDefaultValue = NULL,
    IN BOOL  fExpand = FALSE);

#endif // __cplusplus


#define TCP_ALLOC(cb)          (VOID *)LocalAlloc( LPTR, cb )
#define TCP_FREE(p)            LocalFree( (HLOCAL) p )
#define TCP_DUMP_RESIDUE()     /* NOTHING */

//
//  Registry functions
//


dllexp
LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode,
    IN LPSTR    lpszAnsi,
    IN DWORD    cbAnsi
    );

//
//  Quick macro to initialize a unicode string
//

#define InitUnicodeString( pUnicode, pwch )                                \
            {                                                              \
                (pUnicode)->Buffer    = pwch;                              \
                (pUnicode)->Length    = wcslen( pwch ) * sizeof(WCHAR);    \
                (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR);\
            }

dllexp
DWORD
ReadRegistryDwordA(
    HKEY     hkey,
    LPCSTR   pszValueName,
    DWORD    dwDefaultValue
    );

dllexp
DWORD
WriteRegistryDwordA(
    HKEY        hkey,
    LPCSTR      pszValueName,
    DWORD       dwDefaultValue
    );

dllexp
DWORD
WriteRegistryStringA(
    HKEY        hkey,
    LPCSTR      pszValueName,
    LPCSTR      pszValue,               // null-terminated string
    DWORD       cbValue,                // including terminating null character
    DWORD       fdwType                 // REG_SZ, REG_MULTI_SZ ...
    );

dllexp
DWORD
WriteRegistryStringW(
    HKEY        hkey,
    LPCWSTR     pszValueName,
    LPCWSTR     pszValue,               // null-terminated string
    DWORD       cbValue,                // including terminating null character
    DWORD       fdwType                 // REG_SZ, REG_MULTI_SZ ...
    );

#define ReadRegistryDword       ReadRegistryDwordA
#define WriteRegistryDword      WriteRegistryDwordA
#define WriteRegistryString     WriteRegistryStringA


dllexp
TCHAR *
ReadRegistryString(
    HKEY     hkey,
    LPCTSTR  pszValueName,
    LPCTSTR  pszDefaultValue,
    BOOL     fExpand
    );

dllexp
TCHAR *
KludgeMultiSz(
    HKEY hkey,
    LPDWORD lpdwLength
    );

//
//  Simple wrapper around ReadRegistryString that restores ppchstr if the
//  call fails for any reason.  Environment variables are always expanded
//

dllexp
BOOL
ReadRegString(
    HKEY     hkey,
    CHAR * * ppchstr,
    LPCSTR   pchValue,
    LPCSTR   pchDefault
    );


//
//  MIDL_user_allocates space for pch and does a unicode conversion into *ppwch
//

dllexp
BOOL
ConvertStringToRpc(
    WCHAR * * ppwch,
    LPCSTR    pch
    );

//
//  MIDL_user_frees string allocated with ConvertStringToRpc.  Noop if pwch is
//  NULL
//

dllexp
VOID
FreeRpcString(
    WCHAR * pwch
    );


dllexp
DWORD
InetNtoa( IN struct in_addr inaddr,
          OUT CHAR * pchBuffer  /* at least 16 byte buffer */
        );

//
// Async Socket send/recv with timeouts
//

BOOL
TcpSockSend(
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer,
    PDWORD      nSent,
    DWORD       nTimeout
    );

BOOL
TcpSockRecv(
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer,
    PDWORD      nReceived,
    DWORD       nTimeout
    );

dllexp
INT
WaitForSocketWorker(
    IN SOCKET   sockRead,
    IN SOCKET   sockWrite,
    IN LPBOOL   pfRead,
    IN LPBOOL   pfWrite,
    IN DWORD    nTimeout
    );

//
// Test socket if still connected
//

dllexp
BOOL
TcpSockTest(
    SOCKET      sock
    );

//
// Do synchronous readfile
//

dllexp
BOOL
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    );

//
//  Dll initialization and termination
//

dllexp
BOOL
InitCommonDlls(
    VOID
    );

dllexp
BOOL
TerminateCommonDlls(
    VOID
    );

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#endif // !_TCPPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\svmap.h ===
/*++

    Copyright    (c)    1995-1996    Microsoft Corporation

    Module  Name :
        svmap.h

    Abstract:
   

    Author:

        Taylor Weiss    ( TaylorW )     19-Apr-1999

    Environment:


    Project:
        
        svmap.lib       private\inet\iis\isrtl\svmap

        Clients:

        w3svc.dll       private\inet\iis\svcs\w3\server
        wam.dll         private\inet\iis\svcs\wam\object

    Functions Exported:


    Revision History:

--*/
#ifndef SVMAP_H
#define SVMAP_H

#include <srvvarid.h>

#define SV_DATA_INVALID_OFFSET      (~0)

// Possibly derive from data dictionary
class SV_CACHE_MAP
/*++

Class Description:

    Provides a lookup map for server variable names. Maps names onto
    IDs. Used to cache server variables for out of process applications.

    The interface for this class is similar to that for the HTTP header
    map.

    Note: This mapping mechanism is specific to the intended use of this
    class. May want to replace the implementation with an LKR hash.
    The assumption I made was that we would have a lower overhead mapping
    mechanism if it was customized for this purpose.

--*/
{
public:
    
    SV_CACHE_MAP()
    /*++

    Routine Description:

        Create a server variable map.
    
    --*/
    {
        // Init the memory for the cache entries - 0xFF is an empty
        // entry

        ::FillMemory( m_rgHashTable, sizeof(m_rgHashTable), ~0 );
    }

    BOOL    Initialize( VOID );

    BOOL    FindOrdinal( IN LPCSTR pszName,
                         IN INT    cchName,
                         OUT DWORD * pdwOrdinal
                         ) const;

    LPCSTR  FindName( IN DWORD dwOrdinal ) const
    /*++

    Routine Description:

        Return the name of the server variable corresponding to dwOrdinal
    
    --*/
    {
        DBG_ASSERT( dwOrdinal < SVID_COUNT );
        return SV_CACHE_MAP::sm_rgNames[dwOrdinal].name;
    }

    DWORD   NumItems( VOID ) const
    /*++

    Routine Description:

        Return the number of items held in the map.
    
    --*/
    {
        return SV_COUNT;
    }

    DWORD   FindLen( IN DWORD dwOrdinal ) const
    /*++

    Routine Description:

        Return the length of the server variable corresponding to dwOrdinal
    
    --*/
    {
        DBG_ASSERT( dwOrdinal < SVID_COUNT );
        return SV_CACHE_MAP::sm_rgNames[dwOrdinal].len;
    }

    // The Print functions are unsafe and should only be used when
    // debugging and not in regular CHK builds
    VOID    PrintToBuffer( IN CHAR *       pchBuffer,
                           IN OUT LPDWORD  pcch
                           ) const;

    VOID    Print( VOID ) const;

private:

    enum 
    { 
        SV_COUNT                = SVID_COUNT, 

        // Table size based on initial choice of which server variables
        // to cache.
        TABLE_SIZE              = 256, 
        HASH_MODULUS            = 251,
    };

    // Holds the server variable id.
    struct HASH_TABLE_ENTRY
    /*++

    Class Description:

        Since the server variables that are designated as cachable
        are preselected, we can use a simple hash entry structure.
        Each entry can handle four possible values (slots). Since
        the number of server variables is < 128 we use the high bit
        to determine if a slot is empty. 
        
        The data value is the id of the server variable.

    --*/
    {
        enum 
        { 
            MAX_ITEMS               = 4,
            ITEM_EMPTY_FLAG         = 0x80,
        };

        BOOL InsertValue( DWORD dwValue )
        {
            DBG_ASSERT( !(dwValue & ITEM_EMPTY_FLAG) );
            
            BOOL fReturn = FALSE;
            for( int i = 0; i < MAX_ITEMS; ++i )
            {
                if( items[i] & ITEM_EMPTY_FLAG )
                {
                    items[i] = (BYTE)dwValue;
                    fReturn = TRUE;
                    break;
                }
            }
            return fReturn;
        }

        BOOL IsSlotEmpty( int item ) const
        {
            DBG_ASSERT( item >= 0 && item < MAX_ITEMS );
            return ( items[item] & ITEM_EMPTY_FLAG );
        }

        DWORD GetSlotValue( int item ) const
        {
            DBG_ASSERT( item >= 0 && item < MAX_ITEMS );
            return items[item];           
        }

        BYTE    items[MAX_ITEMS];
    };

    // Internal struct used to generate a static table of the
    // server variables that we will cache.
    struct SV_NAME
    {
        LPCSTR      name;
        DWORD       len;
    };

    // String hashing routines based on those used by LKR hash.

    // These are pretty generic and should be customizable given
    // our limited data set. But I wasn't able to come up with
    // anything better.

    inline DWORD
    HashString( LPCSTR psz ) const
    {
        DWORD dwHash = 0;

        for (  ;  *psz;  ++psz)
        {
            dwHash = 37 * dwHash  +  *psz;
        }
        return dwHash % HASH_MODULUS;
    }

    inline DWORD
    HashStringWithCount( LPCSTR psz, DWORD *pch ) const
    {
        DWORD dwHash = 0;
        DWORD cch = 0;

        for (  ;  *psz;  ++psz, ++cch)
        {
            dwHash = 37 * dwHash  +  *psz;
        }
        *pch = cch;
        return dwHash % HASH_MODULUS;
    }

    inline BOOL
    StringMatches(
        IN LPCSTR   psz,
        IN DWORD    cch,
        IN DWORD    dwOrdinal
        ) const
    /*++

    Routine Description:

        Compare the given string to the server variable name corresponding
        to dwOrdinal.
    
    --*/
    {
        return ( cch == FindLen(dwOrdinal) && 
                 strcmp( psz, FindName(dwOrdinal) ) == 0 
                 );
    }
    
private:
    
    // Member data

    // Our hash table. Maps SV_NAMES to ordinals
    HASH_TABLE_ENTRY    m_rgHashTable[TABLE_SIZE];

    // Static data

    // Table of the server variables that are cachable
    static SV_NAME      sm_rgNames[SV_COUNT];
};

class SV_CACHE_LIST
/*++

Class Description:

    This actually forms the "cache" of the server variables. We don't
    store any data here only the intent to store data. 
    
    This class is a list of those server variables that we will retrieve 
    and then marshal to the remote application.

--*/
{
public:

    DWORD Size( VOID )
    {
        return SVID_COUNT;
    }

    BOOL GetCacheIt( DWORD item )
    {
        return m_rgItems[item].fCached;
    }

    VOID SetCacheIt( DWORD item, BOOL fCacheIt = TRUE )
    {
        m_rgItems[item].fCached = fCacheIt;
    }

    // This is kinda hokey

    // BUFFER_ITEM and GetBufferItems are use to initialize the
    // array that we will marshal to the remote process. There should
    // be much better way to do this, but I want to avoid any locking
    // issues so keeping around the number of cached items is
    // problematic.

    struct BUFFER_ITEM
    {
        DWORD       svid;
        DWORD       dwOffset;
    };

    VOID 
    GetBufferItems
    ( 
        IN OUT BUFFER_ITEM *    pBufferItems,
        IN OUT DWORD *          pdwBufferItemCount
    );

private:

    // We are using a single bit to indicate the cached/not-cached
    // status. We want to minimize space usage as this may end up
    // being cached on a per-url basis.
        
    struct ITEM
    {
        // Init here or zero the memory in SV_CACHE_LIST ctor
        // It looks like when this is built fre that it does a
        // pretty good job of optimizing it. But if ZeroMemory is
        // linked in locally it might be faster.
        ITEM() : fCached(FALSE) {}
        BOOL    fCached : 1;
    };

    ITEM    m_rgItems[SVID_COUNT];
};


#endif // SVMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

VOID
InitializeSecondsTimer(
    VOID
    );


VOID
TerminateSecondsTimer(
    VOID
    );


DWORD
GetCurrentTimeInSeconds(
    VOID
    );


__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\tcpcons.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    TCPcons.hxx

    This file contains the global constant definitions for the
    TCP Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     03-Mar-1995 Modified to remove old definitions for
                                    the new Internet Services DLL

*/


#ifndef _TCPCONS_H_
#define _TCPCONS_H_

//
//  No string resource IDs should be below this value.  Everything below this
//  is reserved for the system error messages
//

#define STR_RES_ID_BASE        7000


//
//  The string resource ID for the error responses is offset by this value
//

#define ID_HTTP_ERROR_BASE          (STR_RES_ID_BASE+1000)
#define ID_HTTP_ERROR_MAX           (STR_RES_ID_BASE+6999)

#define ID_GOPHER_ERROR_BASE        (ID_HTTP_ERROR_MAX+1)
#define ID_GOPHER_ERROR_MAX         (ID_HTTP_ERROR_MAX+6999)

#define ID_FTP_ERROR_BASE           ( ID_GOPHER_ERROR_MAX + 1)
#define ID_FTP_ERROR_MAX            ( ID_FTP_ERROR_BASE + 6998)
 

//
//  TCP API specific access rights.
//

#define TCP_QUERY_SECURITY              0x0001
#define TCP_SET_SECURITY                0x0002
#define TCP_ENUMERATE_USERS             0x0004
#define TCP_DISCONNECT_USER             0x0008
#define TCP_QUERY_STATISTICS            0x0010
#define TCP_CLEAR_STATISTICS            0x0020
#define TCP_QUERY_ADMIN_INFORMATION     0x0040
#define TCP_SET_ADMIN_INFORMATION       0x0080

#define TCP_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED       | \
                                 TCP_QUERY_SECURITY            | \
                                 TCP_SET_SECURITY              | \
                                 TCP_ENUMERATE_USERS           | \
                                 TCP_DISCONNECT_USER           | \
                                 TCP_QUERY_STATISTICS          | \
                                 TCP_CLEAR_STATISTICS          | \
                                 TCP_QUERY_ADMIN_INFORMATION   | \
                                 TCP_SET_ADMIN_INFORMATION       \
                                )

#define TCP_GENERIC_READ       (STANDARD_RIGHTS_READ           | \
                                 TCP_QUERY_SECURITY            | \
                                 TCP_ENUMERATE_USERS           | \
                                 TCP_QUERY_ADMIN_INFORMATION   | \
                                 TCP_QUERY_STATISTICS)

#define TCP_GENERIC_WRITE      (STANDARD_RIGHTS_WRITE          | \
                                 TCP_SET_SECURITY              | \
                                 TCP_DISCONNECT_USER           | \
                                 TCP_SET_ADMIN_INFORMATION     | \
                                 TCP_CLEAR_STATISTICS)

#define TCP_GENERIC_EXECUTE    (STANDARD_RIGHTS_EXECUTE)



#endif  // _TCPCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\tsrc.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name:
      tsrc.h

   Abstract:
      This file declares resource IDs

   Environment:

       Win32 User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

#define IDS_IIS_OP	100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\wmrgexp.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: wmrgexp.h

Owner: leijin

Note:
===================================================================*/
#ifndef _WAMREG_EXPORT_H
#define _WAMREG_EXPORT_H

#ifndef _WAMREG_DLL_
#define PACKMGR_LIBAPI __declspec(dllimport)
#else
#define PACKMGR_LIBAPI __declspec(dllexport)
#endif

#define DEFAULT_PACKAGENAME		L"IIS In-Process Applications"
#define APPCMD_NONE				0
#define APPCMD_VERIFY			1
#define APPCMD_GETSTATUS		2
#define APPCMD_CREATE			3
#define APPCMD_CREATEINPROC		4
#define APPCMD_CREATEOUTPROC	5
#define APPCMD_CHANGETOINPROC	6
#define APPCMD_CHANGETOOUTPROC	7
#define APPCMD_DELETE			8
#define APPCMD_UNLOAD			9

#define APPSTATUS_Error             0		// Error while getting status from W3SVC
#define APPSTATUS_UnLoaded          1		// App is successfully found in W3SVC and unloaded.
#define APPSTATUS_Running           2		// App is currently found in W3SVC and is running.
#define APPSTATUS_Stopped           3		// App is found in W3SVC and stopped.
#define APPSTATUS_NotFoundInW3SVC	4		// App is not found in w3svc.
#define APPSTATUS_NOW3SVC			5		// W3SVC is not running.
#define APPSTATUS_PAUSE				6		// App is in PAUSE state.(Halfway in DeleteRecoverable and Recover).

//
// Version String for WAMREG
// Used for update applications in old WAMREG into new WAMREG formats.
//
enum VS_WAMREG {VS_K2Beta2, VS_K2Beta3};

typedef HRESULT (*PFNServiceNotify)	
					(
					LPCSTR		szAppPath,
					const DWORD	dwAction,
					DWORD*	pdwResult
					);

HRESULT	PACKMGR_LIBAPI	CreateIISPackage(void);
HRESULT PACKMGR_LIBAPI	DeleteIISPackage(void);
HRESULT	PACKMGR_LIBAPI	WamReg_RegisterSinkNotify(PFNServiceNotify pfnW3ServiceSink);
HRESULT PACKMGR_LIBAPI	WamReg_UnRegisterSinkNotify(void);
HRESULT	PACKMGR_LIBAPI	UpgradePackages(VS_WAMREG vs_new, VS_WAMREG vs_old);

HRESULT	
PACKMGR_LIBAPI	
CreateCOMPlusApplication( 
    LPCWSTR      szMDPath,
    LPCWSTR      szOOPPackageID,
    LPCWSTR      szOOPWAMCLSID,
    BOOL       * pfAppCreated 
    );

#endif // _WAMREG_EXPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\w3svc.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3svc.h

    This file contains constants & type definitions shared between the
    W3 Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     Redefined service names

*/


#ifndef _W3SVC_H_
#define _W3SVC_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <inetinfo.h>

//
//  Service name.
//

#define IPPORT_W3                      0x50

//
//  Name of the log file, used for logging file accesses.
//

#define W3_LOG_FILE                    TEXT("HTTPSVC.LOG")


//
//  Configuration parameters registry key.
//

#define W3_PARAMETERS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\W3Svc\\Parameters")


//
//  Performance key.
//

#define W3_PERFORMANCE_KEY \
            TEXT("System\\CurrentControlSet\\Services\\W3Svc\\Performance")

//
//  Sub-authenticator configuration key.
//

#define W3_AUTHENTICATOR_KEY \
            TEXT("System\\CurrentControlSet\\Control\\Lsa")

//
//  Configuration value names.
//

#define W3_CHECK_FOR_WAISDB            TEXT("CheckForWAISDB")
#define W3_DEBUG_FLAGS                 TEXT("DebugFlags")
#define W3_DIR_BROWSE_CONTROL          TEXT("Dir Browse Control")
#define W3_DIR_ICON                    TEXT("Folder Image")
#define W3_DIR_ICON_W                  L"Folder Image"
#define W3_DEFAULT_FILE                TEXT("Default Load File")
#define W3_DEFAULT_FILE_W              L"Default Load File"
#define W3_SERVER_AS_PROXY             TEXT("ServerAsProxy")
#define W3_CATAPULT_USER               TEXT("CatapultUser")
#define W3_CATAPULT_USER_W             L"CatapultUser"
#define W3_SCRIPT_TIMEOUT              "ScriptTimeout"
#define W3_CACHE_EXTENSIONS            "CacheExtensions"
#define W3_SSI_ENABLED                 "ServerSideIncludesEnabled"
#define W3_SSI_EXTENSION               "ServerSideIncludesExtension"
#define W3_SSI_EXTENSION_W             L"ServerSideIncludesExtension"
#define W3_GLOBAL_EXPIRE               "GlobalExpire"
#define W3_PROVIDER_LIST               "NTAuthenticationProviders"
#define W3_SECURE_PORT                 "SecurePort"
#define W3_ENC_PROVIDER_LIST           "NTEncryptionProviders"
#define W3_ENC_FLAGS                   "EncryptionFlags"
#define W3_ACCESS_DENIED_MSG           "AccessDeniedMessage"
#define W3_DEFAULT_HOST_NAME           "ReturnUrlUsingHostName"
#define W3_ACCEPT_BYTE_RANGES          "AcceptByteRanges"
#define W3_ALLOW_GUEST                 "AllowGuestAccess"
#define W3_LOG_ERRORS                  "LogErrorRequests"
#define W3_LOG_SUCCESS                 "LogSuccessfulRequests"
#define W3_REALM_NAME                  "Realm"
#define IDC_POOL_CONN                  "PoolIDCConnections"
#define IDC_POOL_CONN_TIMEOUT          "PoolIDCConnectionsTimeout"
#define W3_UPLOAD_READ_AHEAD           "UploadReadAhead"
#define W3_USE_POOL_THREAD_FOR_CGI     "UsePoolThreadForCGI"
#define W3_ALLOW_KEEP_ALIVES           "AllowKeepAlives"
#define W3_AUTH_CHANGE_URL             "AuthChangeUrl"
#define W3_AUTH_EXPIRED_URL            "AuthExpiredUrl"
#define W3_ADV_NOT_PWD_EXP_URL         "AdvNotPwdExpUrl"
#define W3_ADV_NOT_PWD_EXP_IN_DAYS     "AdvNotPwdExpInDays"
#define W3_ADV_CACHE_TTL               "AdvNotPwdExpCacheTTL"
#define W3_TEMP_DIR_NAME               "TempDirectory"
#define W3_VERSION_11                  "ReplyWithHTTP1.1"
#define W3_USE_ANDRECV                 "UseTransmitFileAndRecv"
#define W3_PUT_TIMEOUT                 "PutDeleteTimeout"

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define W3_ANONYMOUS_SECRET         TEXT("W3_ANONYMOUS_DATA")
#define W3_ANONYMOUS_SECRET_A       "W3_ANONYMOUS_DATA"
#define W3_ANONYMOUS_SECRET_W       L"W3_ANONYMOUS_DATA"

//
//  The set of password/virtual root pairs
//

#define W3_ROOT_SECRET_W            L"W3_ROOT_DATA"

//
//  The password secret for the username to connect to the Catapult gateway if
//  the HTTP server is running as a Catapult proxy client
//

#define W3_PROXY_USER_SECRET_W      L"W3_PROXY_USER_SECRET"

//
//  This is the secret that contains the list of installed SSL keys
//

#define W3_SSL_KEY_LIST_SECRET      L"W3_KEY_LIST"

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _W3SVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\trie.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       trie.h

   Abstract:
       Declares a trie

   Author:
       George V. Reilly      (GeorgeRe)     21-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


// A trie is a multiway search tree (aka a radix tree).  See a good
// algorithms text, like Knuth or Sedgewick, for a complete description.
//
// Briefly, given a list of strings such as
//      cab, car, carts, cats, dog, doge, doggy, dogs
// you get a trie that looks like this:
//
//                /-[b]
//               /
//        <c>--<a>--[r]--<t>--[s]
//       /       \
//      /         \-<t>--[s]
//     *             
//      \              /-[e]
//       \            /
//        <d>--<o>--[g]--<g>--[y]
//                    \
//                     \-[s]
//
// where `[r]' denotes the end of a word and `<a>', the middle.
//
// A trie has several useful properties:
//  * fast
//  * easily handles longest substring matches
//  * fairly compact, especially when there are many overlapping strings
//
// The multiway tree is implemented as a binary tree with child and sibling
// pointers.
//
// The CTrie template takes three parameters:
//      class _TOKEN:        up to you
//      bool  fIgnoreCase:   case-sensitivity for searches
//      bool  fDeleteTokens: delete _TOKEN* when Flush() called?
// and it exposes three methods:
//      bool AddToken(ptszToken, _TOKEN*)
//      _TOKEN* Search(ptszSearch, pctchMatched = NULL, nMaxLen = 0)
//      void Flush()
//
// Use them like this:
//      CTrie<CToken, true, true> trie;
//      CToken* ptokHello = new CToken(...);
//
//      IRTLVERIFY(trie.AddToken(_T("Hello"), ptokHello));
//
//      CToken* ptok = trie.Search(_T("Goodbye"));
//      if (ptok != NULL) {...}
//
//      if (fIniFileChanged)
//      {
//          trie.Flush();   // will delete all tokens
//          AddTokensFromIniFile(trie);
//      }
//
// Note: If you use DUMP(&trie) or ASSERT_VALID(&trie), your _TOKEN class must
// have Dump() or AssertValid() methods, respectively, in its _DEBUG version.
//
//
// TODO:
//  * template really ought to be parameterized on ANSI/Unicode too
//  * STLify it: add iterators, turn it into a container, etc
//  * remove Win32 dependencies (TCHAR)
//  * add operator= and copy ctor
//
//
// George V. Reilly  <gvr@halcyon.com>  Oct 1995  Initial implementation
// George V. Reilly  <gvr@halcyon.com>  Sep 1996  Add CharPresent for ANSI
// George V. Reilly  <gvr@halcyon.com>  Mar 1997  Templatized; removed MFC


#ifndef __TRIE_H__
#define __TRIE_H__

#include <tchar.h>
#include <limits.h>
#include <malloc.h>
#include <irtldbg.h>

// Workaround for bool being a "reserved extension" in Visual C++ 4.x
#if _MSC_VER<1100
# ifndef bool
#  define bool  BOOL
# endif
# ifndef true
#  define true  TRUE
# endif
# ifndef false
#  define false FALSE
# endif
#endif


// forward declaration
template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens> class CTrie;


//+---------------------------------------------------------------------
//  Class:      CTrieNode (tn)
//      one node for each letter

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
class CTrieNode
{
    friend class CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>;
    typedef CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens> _Node;

public:
    CTrieNode();

    CTrieNode(
        _Node*        pParent,
        const _TOKEN* ptok,
        const TCHAR   tch,
        LPCTSTR       ptszToken);

    bool
    SetData(
        const _TOKEN* ptok,
        LPCTSTR       ptszToken);

    ~CTrieNode();

protected:
    const _Node*  m_pParent;
    _Node*        m_pSibling;
    _Node*        m_pChild;
    const _TOKEN* m_ptok;
#ifdef _DEBUG
    LPTSTR        m_ptszToken;
#endif
    const TCHAR   m_tch;
    TCHAR         m_tchMaxChild;    // Maximum m_tch of child nodes (1 level)

// Diagnostics
public:
#ifdef _DEBUG
    void
    AssertValid() const;

    virtual void
    Dump() const;

protected:
    bool
    CheckNodeToken() const;
#endif

private:
    // private, unimplemented copy ctor and op= to prevent
    // compiler synthesizing them
    CTrieNode(const CTrieNode&);
    CTrieNode& operator=(const CTrieNode&);
};



//+---------------------------------------------------------------------
//  Class:      CTrie (trie)

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
class CTrie
{
    typedef CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens> _Node;

public:
    CTrie();

    virtual
    ~CTrie();

    virtual bool
    AddToken(
        LPCTSTR             ptszToken,
        const _TOKEN* const ptok);

    virtual const _TOKEN*
    Search(
        LPCTSTR   ptszSearch,
        int*      pctchMatched = NULL,
        const int nMaxLen = 0) const;

    virtual void
    Flush();

protected:
    _Node  m_tnRoot;
    TCHAR  m_tchMinChild;
    TCHAR  m_tchMaxChild;

    void
    _DeleteTrie(
        _Node* ptn);

#ifndef _UNICODE
    // bit array for first letter of all tokens
    BYTE  m_afCharPresent[(CHAR_MAX - CHAR_MIN + 1 + 7) / 8];

    bool
    _CharPresent(
        CHAR ch) const;

    void
    _SetCharPresent(
        CHAR ch,
        bool f);
#endif // !UNICODE


// Diagnostics
public:
#ifdef _DEBUG
    virtual void
    AssertValid() const;

    virtual void
    Dump() const;

protected:
    int   m_ctchMaxTokenLen;    // length of longest token string

    void
    _AssertWalk(
        _Node* ptn,
        LPTSTR ptszName,
        int    iLevel) const;

    void
    _DumpWalk(
        _Node* ptn,
        LPTSTR ptszName,
        int    iLevel,
        int&   rcNodes,
        int&   rcTokens) const;
#endif

private:
    // private, unimplemented copy ctor and op= to prevent
    // compiler synthesizing them
    CTrie(const CTrie&);
    CTrie& operator=(const CTrie&);
};



#ifdef _UNICODE
# define TCHAR_MIN L'\0'
#else // !UNICODE
# define TCHAR_MIN CHAR_MIN
#endif // !UNICODE



//-----------------------------------------------------------------------------
// CTrieNode implementation

// CTrieNode::CTrieNode
//      default ctor (needed for CTrie::m_tnRoot)

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrieNode()
    : m_pParent(NULL),
      m_pSibling(NULL),
      m_pChild(NULL),
      m_ptok(NULL),
#ifdef _DEBUG
      m_ptszToken(NULL),
#endif
      m_tch(TCHAR_MIN),
      m_tchMaxChild(TCHAR_MIN)
{
}



// CTrieNode::CTrieNode
//      ctor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrieNode(
    _Node*        pParent,
    const _TOKEN* ptok,
    const TCHAR   tch,
    LPCTSTR       ptszToken)
    : m_pParent(pParent),
      m_pSibling(NULL),
      m_pChild(NULL),
      m_ptok(ptok),
#ifdef _DEBUG
      m_ptszToken(NULL),
#endif
      m_tch(tch),
      m_tchMaxChild(TCHAR_MIN)
{
    IRTLASSERT(m_pParent != NULL);
    IRTLASSERT(m_tch > TCHAR_MIN);
    
    _Node* ptnPrev = NULL;
    _Node* ptn = m_pParent->m_pChild;
        
    // find where in the list of pParent's children to insert `this'
    while (ptn != NULL  &&  ptn->m_tch < m_tch)
    {
        ptnPrev = ptn;
        ptn = ptn->m_pSibling;
    }
    
    IRTLASSERT(ptn == NULL  ||  ptn->m_tch != m_tch);
    
    if (ptnPrev == NULL)
    {
        IRTLASSERT(pParent->m_pChild == ptn);
        pParent->m_pChild = this;
    }
    else
        ptnPrev->m_pSibling = this;

    this->m_pSibling = ptn;

    if (pParent->m_tchMaxChild < m_tch)
        pParent->m_tchMaxChild = m_tch;

#ifdef _DEBUG
    if (ptszToken != NULL)
    {
        IRTLASSERT(m_ptok != NULL);
        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1];
        _tcscpy(m_ptszToken, ptszToken);
    }
#endif
}


    
// CTrieNode::SetData
//      sets the data if it's NULL.  Needed if you do
//      AddToken("foobar", &tokFoobar) and then AddToken("foo", &tokFoo)
//      to set the data for tokFoo.

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::SetData(
    const _TOKEN* ptok,
    LPCTSTR       ptszToken)
{
    // Don't set data if ptok is NULL
    if (ptok == NULL)
        return false;
    
    // overwrite m_ptok only if it is NULL
    if (m_ptok == NULL)
    {
        m_ptok = ptok;
#ifdef _DEBUG
        IRTLASSERT(m_ptszToken == NULL);
        IRTLASSERT(ptszToken != NULL);
        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1];
        _tcscpy(m_ptszToken, ptszToken);
#endif
    }

    return true;
}



// CTrieNode::~CTrieNode
//      dtor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::~CTrieNode()
{
#ifdef _DEBUG
    delete [] m_ptszToken;
#endif

    // Is this an auto-delete trie, i.e., do we take care of deleting
    // the _TOKENs?
    if (fDeleteTokens)
    {
        // cast away constness so that delete will work
        delete const_cast<_TOKEN*> (m_ptok);
    }

    IRTLASSERT(m_pChild == NULL);
}


    
//-----------------------------------------------------------------------------
// CTrieNode diagnostics

#ifdef _DEBUG

// CTrieNode::CheckNodeToken
//      Do the real work of validating a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CheckNodeToken() const
{
    // If there's no m_ptok, it's automatically valid
    if (m_ptok == NULL)
        return true;

    IRTLASSERT(m_ptszToken != NULL);
    const int cLen = _tcslen(m_ptszToken);
    const _Node* ptn = this;

    IRTLASSERT((m_pChild == NULL  &&  m_tchMaxChild == TCHAR_MIN)
           ||  (m_pChild != NULL  &&  m_tchMaxChild > TCHAR_MIN));

    // Walk back up towards CTrie::m_tnRoot
    for (int i = cLen;  --i >= 0;  )
    {
        IRTLASSERT(ptn != NULL);
        IRTLASSERT(ptn->m_tch != TCHAR_MIN);

        const TCHAR tch = (fIgnoreCase
                           ? (TCHAR) _totlower(this->m_ptszToken[i])
                           : this->m_ptszToken[i]);

        if (ptn->m_tch != tch)
            IRTLASSERT(false);

        IRTLASSERT(ptn->m_pParent != NULL && ptn->m_pParent->m_pChild != NULL);

        const _Node* ptn2;

        // check to see if ptn really is a child of its parent
        for (ptn2 = ptn->m_pParent->m_pChild;
             ptn2 != ptn  &&  ptn2 != NULL;
             ptn2 = ptn2->m_pSibling)
        {}
        IRTLASSERT(ptn2 == ptn);

        // check that ptn->m_pParent->m_tchMaxChild is correct
        for (ptn2 = ptn->m_pParent->m_pChild;
             ptn2->m_pSibling != NULL;
             ptn2 = ptn2->m_pSibling)
        {
            IRTLASSERT(ptn2->m_tch > TCHAR_MIN
                   &&  ptn2->m_tch < ptn2->m_pSibling->m_tch);
        }
        IRTLASSERT(ptn->m_pParent->m_tchMaxChild == ptn2->m_tch);

        ptn = ptn->m_pParent;
        IRTLASSERT(ptn->m_ptok != this->m_ptok);
    }

    // check to see if ptn == CTrie::m_tnRoot
    IRTLASSERT(ptn->m_pParent == NULL  &&  ptn->m_pSibling == NULL
           &&  ptn->m_tch == TCHAR_MIN  &&  ptn->m_ptok == NULL);

    return true;
}



// CTrieNode::AssertValid
//      Validate a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::AssertValid() const
{
    IRTLASSERT(CheckNodeToken());
}



// CTrieNode::Dump
//      Dump a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::Dump() const
{
    // TODO: flesh out
}

#endif // _DEBUG



//-----------------------------------------------------------------------------
// CTrie implementation

// CTrie::CTrie
//      ctor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrie()
{
    Flush();
}



// CTrie::~CTrie
//      dtor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::~CTrie()
{
    Flush();
}



#ifndef _UNICODE

// CTrie::_CharPresent

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
inline bool
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_CharPresent(
    CHAR ch) const
{
    IRTLASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;   // CHAR_MIN is -128 for `signed char'

    return m_afCharPresent[i >> 3] & (1 << (i & 7))  ?  true  :  false;
}



// CTrie::_SetCharPresent

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
inline void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_SetCharPresent(
    CHAR ch,
    bool f)
{
    IRTLASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;

    if (f)
        m_afCharPresent[i >> 3] |=  (1 << (i & 7));
    else
        m_afCharPresent[i >> 3] &= ~(1 << (i & 7));
}

#endif // !UNICODE



// CTrie::AddToken
//      Add search string `ptszToken' to trie, which will return `ptok'
//      if searched for in Search().

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::AddToken(
    LPCTSTR             ptszToken,
    const _TOKEN* const ptok)
{
    if (ptok == NULL  ||  ptszToken == NULL  ||  *ptszToken == _T('\0'))
    {
        IRTLASSERT(false);
        return false;
    }

    const int cLen = _tcslen(ptszToken);
    _Node* ptnParent = &m_tnRoot;
    
    for (int i = 0;  i < cLen;  ++i)
    {
        IRTLASSERT(ptnParent != NULL);
        
        _Node* ptn = ptnParent->m_pChild;
        const TCHAR tch = (fIgnoreCase
                           ? (TCHAR) _totlower(ptszToken[i])
                           : ptszToken[i]);
        const _TOKEN* ptok2 = (i == cLen - 1)  ?  ptok       :  NULL;
        LPCTSTR ptsz2 =       (i == cLen - 1)  ?  ptszToken  :  NULL;

        while (ptn != NULL  &&  ptn->m_tch < tch)
            ptn = ptn->m_pSibling;
            
        if (ptn == NULL  ||  ptn->m_tch > tch)
        {
            ptnParent = new _Node(ptnParent, ptok2, tch, ptsz2);
        }
        else
        {
            IRTLASSERT(ptn->m_tch == tch);
            
            ptn->SetData(ptok2, ptsz2);
            ptnParent = ptn;
        }

        IRTLASSERT(ptnParent->CheckNodeToken());
    }

    m_tchMinChild = m_tnRoot.m_pChild->m_tch;
    m_tchMaxChild = m_tnRoot.m_tchMaxChild;
#ifdef _DEBUG
    m_ctchMaxTokenLen = max(m_ctchMaxTokenLen, cLen);
#endif

    IRTLASSERT(TCHAR_MIN < m_tchMinChild  &&  m_tchMinChild <= m_tchMaxChild);

#ifndef _UNICODE
    // Keep a map of the initial letter of each token, to speed up searches
    if (fIgnoreCase)
    {
        _SetCharPresent(tolower(ptszToken[0]), true);
        _SetCharPresent(toupper(ptszToken[0]), true);
    }
    else
        _SetCharPresent(ptszToken[0], true);
#endif // !UNICODE

#ifdef _DEBUG
    int nTemp;
    const _TOKEN* ptok2 = Search(ptszToken, &nTemp);

    IRTLASSERT(ptok2 == ptok  &&  nTemp == cLen);
#endif // _DEBUG

    return true;
}



// CTrie::Search
//      Search trie for `ptszSearch', returning count of characters
//      matched in `pctchMatched' (if non-NULL), matching at most `nMaxLen'
//      characters, if nMaxLen != 0, or _tcslen(ptszSearch) otherwise.

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
const _TOKEN*
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Search(
    LPCTSTR   ptszSearch,
    int*      pctchMatched /* = NULL */,
    const int nMaxLen /* = 0 */) const
{
    // Set count of matched characters
    if (pctchMatched != NULL)
        *pctchMatched = 0;

#ifndef _UNICODE
    if (! _CharPresent(ptszSearch[0]))
        return NULL;

    TCHAR tch;
#else    // UNICODE
    TCHAR tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[0]) : ptszSearch[0];

    if (tch < m_tchMinChild  ||  m_tchMaxChild < tch)
        return NULL;
#endif // UNICODE

    // For some uses (e.g., ptszSearch is not '\0'-terminated), nMaxLen is
    // specified.  If it's not specified, use the length of the string.
    const int cLen = (nMaxLen != 0)  ?  nMaxLen  :  _tcslen(ptszSearch);
    IRTLASSERT(0 < cLen);

    bool fOvershot = true;
    const _Node* ptnParent = &m_tnRoot;
    const _Node* ptn = NULL;
    int i;

    // Find the longest approximate match.  For example, if we have "foo"
    // and "foobar" in the trie and we're asked to match "fool", we'll work
    // our way down to "foob", then backtrack up to "foo".

    for (i = 0;  i < cLen;  ++i)
    {
        IRTLASSERT(ptnParent != NULL);

        ptn = ptnParent->m_pChild;
        IRTLASSERT(ptn != NULL  &&  ptn->m_pParent == ptnParent);

        tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[i]) : ptszSearch[i];
        IRTLASSERT(tch >= TCHAR_MIN);

        if (ptnParent->m_tchMaxChild < tch)
        {
            IRTLASSERT(i > 0);
            break;
        }
        
        while (ptn != NULL  &&  ptn->m_tch < tch)
            ptn = ptn->m_pSibling;

        // failed to match?
        if (ptn == NULL  ||  ptn->m_tch > tch)
        {
            IRTLASSERT(ptn == NULL  || ptn->m_tch <= ptnParent->m_tchMaxChild);
            
            if (i == 0)
                return NULL;
            break;
        }
        else
        {
            IRTLASSERT(ptn->m_tch == tch);
            IRTLASSERT(ptn->m_pParent->m_tchMaxChild >= tch);

            if (ptn->m_pChild == NULL)
            {
                IRTLASSERT(ptn->m_ptok != NULL);
                fOvershot = false;
                break;
            }

            ptnParent = ptn;
        }
    }

    if (fOvershot)
    {
        --i;  ptn = ptnParent;  // back up one character
    }
    else
        IRTLASSERT(ptn->m_pChild == NULL);

    IRTLASSERT(0 <= i  &&  i < cLen);
    IRTLASSERT(ptn != NULL  &&  ptn != &m_tnRoot);
    
    // we've found an approximate match; backtrack until we find an exact match
    do
    {
        IRTLASSERT(ptn != NULL);
        IRTLASSERT(ptn->m_tch == (fIgnoreCase
                                  ? (TCHAR) _totlower(ptszSearch[i])
                                  : ptszSearch[i]));
        IRTLASSERT(ptn->CheckNodeToken());
        
        const _TOKEN* const ptok = ptn->m_ptok;

        if (ptok != NULL)
        {
            IRTLASSERT(i == (int) _tcslen(ptn->m_ptszToken) - 1);

            if (pctchMatched != NULL)
                *pctchMatched = i+1;

            return ptok;
        }

        ptn = ptn->m_pParent;
    } while (--i >= 0);

    return NULL;
}



// CTrie::Flush
//      flush all nodes leaving an empty trie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Flush()
{
    if (m_tnRoot.m_pChild != NULL)
        _DeleteTrie(m_tnRoot.m_pChild);

    m_tnRoot.m_pChild = NULL;  // or ~CTrieNode will ASSERT
    m_tnRoot.m_tchMaxChild = TCHAR_MIN;

    m_tchMinChild = m_tchMaxChild = TCHAR_MIN;
#ifdef _DEBUG
    m_ctchMaxTokenLen = 0;
#endif
#ifndef _UNICODE
    memset(m_afCharPresent, 0, sizeof(m_afCharPresent));
#endif
}



// CTrie::_DeleteTrie
//      recursively delete a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_DeleteTrie(
    _Node* ptn)
{
    if (ptn == NULL)
    {
        IRTLASSERT(false);
        return;
    }
    
    do
    {
        if (ptn->m_pChild != NULL)
        {
            _DeleteTrie(ptn->m_pChild);
            ptn->m_pChild = NULL;   // or ~CTrieNode will ASSERT
        }

        _Node* ptnSibling = ptn->m_pSibling;
        delete ptn;
        ptn = ptnSibling;   // tail recursion
    } while (ptn != NULL);
}



//-----------------------------------------------------------------------------
// CTrie diagnostics

#ifdef _DEBUG

// CTrie::AssertValid

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::AssertValid() const
{
    TCHAR* ptszName = static_cast<TCHAR*>
                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1)));
    *ptszName = _T('\0');

    ASSERT_VALID(&m_tnRoot);
    IRTLASSERT(m_tnRoot.m_tchMaxChild == m_tchMaxChild);

    if (m_tnRoot.m_pChild != NULL)
    {
        IRTLASSERT(m_tchMinChild == m_tnRoot.m_pChild->m_tch);
        IRTLASSERT(m_ctchMaxTokenLen > 0);
        _AssertWalk(m_tnRoot.m_pChild, ptszName, 0);
    }
    else
    {
        IRTLASSERT(m_tchMinChild == TCHAR_MIN
                   &&  m_tchMinChild == m_tchMaxChild);
        IRTLASSERT(m_ctchMaxTokenLen == 0);
    }
}



// CTrie::_AssertWalk
//      recursively validate a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_AssertWalk(
    _Node* ptn,
    LPTSTR ptszName,
    int    iLevel) const
{
    IRTLASSERT(iLevel < m_ctchMaxTokenLen);
    
    do
    {
        ASSERT_VALID(ptn);
        
        ptszName[iLevel] = ptn->m_tch;
        ptszName[iLevel+1] = _T('\0');

        if (ptn->m_ptok != NULL)
        {
            IRTLASSERT(ptn->m_ptszToken != NULL);
            if (fIgnoreCase)
                IRTLASSERT(_tcsicmp(ptszName, ptn->m_ptszToken) == 0);
            else
                IRTLASSERT(_tcscmp(ptszName, ptn->m_ptszToken) == 0);
            ASSERT_VALID(ptn->m_ptok);
        }
        
        if (ptn->m_pChild != NULL)
            _AssertWalk(ptn->m_pChild, ptszName, iLevel+1);

        ptn = ptn->m_pSibling;   // tail recursion
    } while (ptn != NULL);
}



// CTrie::Dump

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Dump() const
{
    int cNodes = 0, cTokens = 0;
    TCHAR* ptszName = static_cast<TCHAR*>
                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1)));
    *ptszName = _T('\0');

    TRACE0("Dumping trie...\n");

    if (m_tnRoot.m_pChild != NULL)
        _DumpWalk(m_tnRoot.m_pChild, ptszName, 0, cNodes, cTokens);

    TRACE2("%d nodes, %d tokens\n", cNodes, cTokens);
}



// CTrie::_DumpWalk
//      recursively dump a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_DumpWalk(
    _Node* ptn,
    LPTSTR ptszName,
    int    iLevel,
    int&   rcNodes,
    int&   rcTokens) const
{
    IRTLASSERT(iLevel < m_ctchMaxTokenLen);

    do
    {
        ASSERT_VALID(ptn);
        
        ++rcNodes;
        ptszName[iLevel] = ptn->m_tch;
        ptszName[iLevel+1] = _T('\0');

        if (ptn->m_ptok != NULL)
        {
            ++rcTokens;
            IRTLASSERT(ptn->m_ptszToken != NULL);
            TRACE2("\t%s (%s): ", ptszName, ptn->m_ptszToken);
            DUMP(ptn->m_ptok);
            TRACE0("\n");
        }
        
        if (ptn->m_pChild != NULL)
            _DumpWalk(ptn->m_pChild, ptszName, iLevel+1, rcNodes, rcTokens);

        ptn = ptn->m_pSibling;   // tail recursion
    } while (ptn != NULL);
}

#endif // _DEBUG

#endif // __TRIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\_ntverp.h ===
/****************************************************************************
 *                                                                          *
 *      ntverp.H        -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD lines must contain the product          */
/* comments (Win9x or NT) and end with the build#<CR><LF>       */
/*                                                              */
/* the VER_PRODUCTBETA_STR lines must contain the product       */
/* comments (Win9x or NT) and end with "some string"<CR><LF>    */
/*--------------------------------------------------------------*/

#define VER_PRODUCTBUILD_QFE        1

#if defined(NASHVILLE)
#define VER_PRODUCTBUILD            /* Win9x */  1089
#define VER_PRODUCTBETA_STR         /* Win9x */  ""
#define VER_PRODUCTVERSION_STR      "4.70"
#define VER_PRODUCTVERSION          4,70,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0446)
#define VER_PRODUCTVERSION_DW       (0x04460000 | VER_PRODUCTBUILD)

#else
#define VER_PRODUCTBUILD            /* NT */     0984
#define VER_PRODUCTBETA_STR         /* NT */     ""
#define VER_PRODUCTVERSION_STR      "5.00.0984"
#define VER_PRODUCTVERSION          5,00,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0500)
#define VER_PRODUCTVERSION_DW       (0x05000000 | VER_PRODUCTBUILD)

#endif

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) Windows NT(TM) Operating System"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\inc\urlutil.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    urlutil.hxx

    This module contains various URL utility functions

    FILE HISTORY:
        Johnl       04-Apr-1995     Created

*/

#ifndef _URLUTIL_H_
#define _URLUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  This indicates the URL is an enumerated type that should use
//  InternetFindFirstFile/<Protocol>FindNextFile
//
//  URL_FLAGS_DIR_OR_FILE indicates we can't tell whether the URL is a
//  directory or a file, so assume it's a directory and if that fails, retry
//  as a file (handles ftp case where there isn't a trailing '/')
//

#define URL_FLAGS_DIRECTORY_OP          0x00000001
#define URL_FLAGS_SEARCH_OP             0x00000002
#define URL_FLAGS_GOPHER_PLUS           0x00000004
#define URL_FLAGS_DIR_OR_FILE           0x00000008

typedef struct _URL_DESCRIPTOR
{
    DWORD          dwFlags;
    DWORD          dwServiceType;
    CHAR *         pszProtocol;
    CHAR *         pszServer;
    INTERNET_PORT  sPort;
    CHAR *         pszPath;
    CHAR *         pszUserName;
    CHAR *         pszPassword;
    CHAR *         pszSearchTerms;      // Gopher search items
    CHAR *         pszExtra;            // Gopher+ data
    DWORD          GopherType;

} URL_DESCRIPTOR, *LPURL_DESCRIPTOR;

BOOL
CrackURLInPlace(
    IN OUT CHAR *           pszURL,
    OUT    URL_DESCRIPTOR * pUrlDesc
    );

VOID
Unescape(
    CHAR *        pch
    );

#ifdef __cplusplus
}
#endif

#endif // _URLUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\last\makefile.inc ===
STAXEXPORT=$(_NTTREE)\staxpt\iis

$(O)\asptlb.h: ..\svcs\cmp\aspidl\$(O)\_asptlb.h
    copy $** $@

$(O)\httpext.h: ..\inc\$(O)\iisext.h
    copy $** $@

$(O)\httpfilt.h: ..\inc\$(O)\iisfilt.h
    copy $** $@

copyfiles: $(O)\asptlb.h $(O)\httpext.h $(O)\httpfilt.h 
    perl -S xcopy2binplace.pl /vyirfda ..\inc\*.* $(STAXEXPORT)\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1997-2002    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__


//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// LKRhash.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# if defined(IRTLDBG_KERNEL_MODE) || defined(LIB_IMPLEMENTATION)
#  define IRTL_DLLEXP
#  define IRTL_EXPIMP
# elif defined(DLL_IMPLEMENTATION)
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !IRTLDBG_KERNEL_MODE && !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !IRTLDBG_KERNEL_MODE && !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP


#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\klocks.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       kLocks.h

   Abstract:
       A collection of kernel-mode locks for multithreaded access to
       data structures that provide the same abstractions as <locks.h>

   Author:
       George V. Reilly      (GeorgeRe)     24-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/


#ifndef __KLOCKS_H__
#define __KLOCKS_H__

#define LOCKS_KERNEL_MODE

#ifdef __LOCKS_H__
# error Do not #include <locks.h> before <klocks.h>
#endif

#include <locks.h>



//--------------------------------------------------------------------
// CKSpinLock is a mutex lock based on KSPIN_LOCK

class IRTL_DLLEXP CKSpinLock :
    public CLockBase<LOCK_KSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SPIN, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // BUGBUG: this data must live in non-paged memory
    mutable  KSPIN_LOCK KSpinLock;
    volatile KIRQL      m_OldIrql;

    LOCK_INSTRUMENTATION_DECL();

public:

#ifndef LOCK_INSTRUMENTATION

    CKSpinLock()
    {
        KeInitializeSpinLock(&KSpinLock);
        m_OldIrql = PASSIVE_LEVEL;
    }

#else // LOCK_INSTRUMENTATION

    CKSpinLock(
        const TCHAR* ptszName)
    {
        KeInitializeSpinLock(&KSpinLock);
        m_OldIrql = PASSIVE_LEVEL;
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CKSpinLock() {}
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.
    // Blocks (if needed) until acquired.
    void WriteLock()
    {
        KIRQL OldIrql;
        KeAcquireSpinLock(&KSpinLock, &OldIrql);

        // Now that we've acquired the spinlock, copy the stack variable
        // into the member variable. The member variable is only written
        // or read by the owner of the spinlock.
        m_OldIrql = OldIrql;
    }

    // Acquire a (possibly shared) lock for reading.
    // Blocks (if needed) until acquired.
    void ReadLock()
    {
        WriteLock();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    bool TryWriteLock()
    {
        return false;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    bool TryReadLock()
    {
        return TryWriteLock();
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    void WriteUnlock()
    {
        KeReleaseSpinLock(&KSpinLock, m_OldIrql);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        // A KSPIN_LOCK doesn't keep track of its owning thread/processor.
        // It's either 0 (unlocked) or 1 (locked). We could keep track of
        // the owner in an additional member variable, but currently we don't.
        return false;
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return false;
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CKSpinLock");}
}; // CKSpinLock




//--------------------------------------------------------------------
// CFastMutex is a mutex lock based on FAST_MUTEX

class IRTL_DLLEXP CFastMutex :
    public CLockBase<LOCK_FASTMUTEX, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    mutable FAST_MUTEX FastMutex;

    LOCK_INSTRUMENTATION_DECL();

public:

#ifndef LOCK_INSTRUMENTATION

    CFastMutex()
    {
        ExInitializeFastMutex(&FastMutex);
    }

#else // LOCK_INSTRUMENTATION

    CFastMutex(
        const TCHAR* ptszName)
    {
        ExInitializeFastMutex(&FastMutex);
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CFastMutex() {}
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.
    // Blocks (if needed) until acquired.
    void WriteLock()
    {
        ExAcquireFastMutex(&FastMutex);
    }

    // Acquire a (possibly shared) lock for reading.
    // Blocks (if needed) until acquired.
    void ReadLock()
    {
        WriteLock();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    bool TryWriteLock()
    {
        return ExTryToAcquireFastMutex(&FastMutex) != FALSE;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    bool TryReadLock()
    {
        return TryWriteLock();
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    void WriteUnlock()
    {
        ExReleaseFastMutex(&FastMutex);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return false; // no way of determining this w/o auxiliary info
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CFastMutex");}
}; // CFastMutex




//--------------------------------------------------------------------
// CEResource is a multi-reader, single-writer lock based on ERESOURCE

class IRTL_DLLEXP CEResource :
    public CLockBase<LOCK_ERESOURCE, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    mutable ERESOURCE Resource;

public:
    CEResource()
    {
        ExInitializeResourceLite(&Resource);
    }

#ifdef LOCK_INSTRUMENTATION
    CEResource(
        const TCHAR* ptszName)
    {
        ExInitializeResourceLite(&Resource);
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

    ~CEResource()
    {
        ExDeleteResourceLite(&Resource);
    }

    inline void
    WriteLock()
    {
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(&Resource, TRUE);
    }

    inline void
    ReadLock()
    {
        KeEnterCriticalRegion();
        ExAcquireResourceSharedLite(&Resource, TRUE);
    }

    bool ReadOrWriteLock();

    inline bool
    TryWriteLock()
    {
        KeEnterCriticalRegion();
        BOOLEAN fLocked = ExAcquireResourceExclusiveLite(&Resource, FALSE);
        if (! fLocked)
            KeLeaveCriticalRegion();
        return fLocked != FALSE;
    }

    inline bool
    TryReadLock()
    {
        KeEnterCriticalRegion();
        BOOLEAN fLocked = ExAcquireResourceSharedLite(&Resource, FALSE);
        if (! fLocked)
            KeLeaveCriticalRegion();
        return fLocked != FALSE;
    }

    inline void
    WriteUnlock()
    {
        ExReleaseResourceLite(&Resource);
        KeLeaveCriticalRegion();
    }

    inline void
    ReadUnlock()
    {
        WriteUnlock();
    }

    void ReadOrWriteUnlock(bool fIsReadLocked);

    // Does current thread hold a write lock?
    bool
    IsWriteLocked() const
    {
        return ExIsResourceAcquiredExclusiveLite(&Resource) != FALSE;
    }

    bool
    IsReadLocked() const
    {
        return ExIsResourceAcquiredSharedLite(&Resource) > 0;
    }

    bool
    IsWriteUnlocked() const
    { return !IsWriteLocked(); }

    bool
    IsReadUnlocked() const
    { return !IsReadLocked(); }

    void
    ConvertSharedToExclusive()
    {
        ReadUnlock();
        WriteLock();
    }

    // There is no such window when converting from a writelock to a readlock
    void
    ConvertExclusiveToShared()
    {
#if 0
        ExConvertExclusiveToShared(&Resource);
#else
        WriteUnlock();
        ReadLock();
#endif
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool
    SetSpinCount(WORD wSpins)
    {return false;}

    WORD
    GetSpinCount() const
    {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*
    ClassName()
    {return _TEXT("CEResource");}

}; // CEResource



#if 1

//--------------------------------------------------------------------
// CRtlMrswLock is a multi-reader, single-writer lock from the TCP team
//
// The following structure and routines implement a multiple reader,
// single writer lock.  The lock may be used from PASSIVE_LEVEL to
// DISPATCH_LEVEL.
//
// While the lock is held by readers or writer, the IRQL is
// raised to DISPATCH_LEVEL.  As a result, the memory for the
// CRtlMrswLock structure must reside in non-paged pool.  The
// lock is "fair" in the sense that waiters are granted the lock
// in the order requested.  This is achieved via the use of a
// queued spinlock internally.
//
// The lock can be recursively acquired by readers, but not by writers.
//
// There is no support for upgrading (downgrading) a read (write) lock to
// a write (read) lock.

class IRTL_DLLEXP CRtlMrswLock :
    public CLockBase<LOCK_RTL_MRSW_LOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SPIN, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    mutable KSPIN_LOCK  ExclusiveLock;
    volatile LONG       ReaderCount;

public:
    CRtlMrswLock()
    {
        KeInitializeSpinLock(&ExclusiveLock);
        ReaderCount = 0;
    }

#ifdef LOCK_INSTRUMENTATION
    CRtlMrswLock(
        const TCHAR* ptszName)
    {
        KeInitializeSpinLock(&ExclusiveLock);
        ReaderCount = 0;
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

    ~CRtlMrswLock()
    {
        IRTLASSERT(ReaderCount == 0);
        // KeUninitializeSpinLock(&ExclusiveLock);
    }

    inline void
    WriteLockAtDpcLevel(
        OUT PKLOCK_QUEUE_HANDLE LockHandle)
    {
        //
        // Wait for the writer (if there is one) to release.
        //
        KeAcquireInStackQueuedSpinLockAtDpcLevel(&ExclusiveLock, LockHandle);
        
        //
        // Now wait for all readers to release.
        //
        while (ReaderCount != 0)
        {}
    }
    
    inline void
    ReadLockAtDpcLevel()
    {
        KLOCK_QUEUE_HANDLE LockHandle;
        
        //
        // Wait for the writer (if there is one) to release.
        //
        KeAcquireInStackQueuedSpinLockAtDpcLevel(&ExclusiveLock, &LockHandle);
        
        //
        // Now that we have the exclusive lock, we know there are no writers.
        // Bump the reader count to cause any new writer to wait.
        // We use an interlock here becasue the decrement path is not done
        // under the exclusive lock.
        //
        InterlockedIncrement(const_cast<LONG*>(&ReaderCount));
 
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    }

    inline void
    WriteLock(
        OUT PKLOCK_QUEUE_HANDLE LockHandle)
    {
        //
        // Wait for the writer (if there is one) to release.
        //
        KeAcquireInStackQueuedSpinLock(&ExclusiveLock, LockHandle);
        
        //
        // Now wait for all readers to release.
        //
        while (ReaderCount != 0)
        {}
    }

    inline void
    ReadLock(
        OUT PKIRQL OldIrql)
    {
        *OldIrql = KeRaiseIrqlToDpcLevel();
        ReadLockAtDpcLevel();
    }

    inline bool
    TryWriteLock()
    {
        return false;
    }

    inline bool
    TryReadLock()
    {
        // TODO 
        return false;
    }

    inline void
    WriteUnlockFromDpcLevel(
        IN PKLOCK_QUEUE_HANDLE LockHandle)
    {
        KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle);
    }

    inline void
    ReadUnlockFromDpcLevel()
    {
        //
        // Decrement the reader count.  This will cause any waiting writer
        // to wake up and acquire the lock if the reader count becomes zero.
        //
        InterlockedDecrement(const_cast<LONG*>(&ReaderCount));
    }

    inline void
    WriteUnlock(
        IN PKLOCK_QUEUE_HANDLE LockHandle)
    {
        KeReleaseInStackQueuedSpinLock(LockHandle);
    }

    inline void
    ReadUnlock(
        IN KIRQL OldIrql)
    {
        ReadUnlockFromDpcLevel();
        KeLowerIrql(OldIrql);
    }

    void ReadOrWriteUnlock(bool fIsReadLocked);

    // Does current thread hold a write lock?
    bool
    IsWriteLocked() const
    {
        return false;
    }

    bool
    IsReadLocked() const
    {
        return false;
    }

    bool
    IsWriteUnlocked() const
    {
        return false;
    }

    bool
    IsReadUnlocked() const
    {
        return false;
    }

    void
    ConvertSharedToExclusive()
    {
        // ReadUnlock();
        // WriteLock();
    }

    void
    ConvertExclusiveToShared()
    {
        // WriteUnlock();
        // ReadLock();
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool
    SetSpinCount(WORD)
    {return false;}

    WORD
    GetSpinCount() const
    {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*
    ClassName()
    {return _TEXT("CRtlMrswLock");}

}; // CRtlMrswLock

#endif

#endif  // __KLOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\irtldbg.h ===
/*++

   Copyright    (c)    1997-2002    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define IRTLDBG_RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# if defined(NDEBUG)
#  undef IRTLDEBUG
# else
#  if DBG || defined(_DEBUG)
#   define IRTLDEBUG
#  endif
# endif

# ifdef IRTLDEBUG

#  if defined(IRTLDBG_KERNEL_MODE)

#   define IRTLASSERT(f) ASSERT(f)

#  elif !defined(USE_DEBUG_CRTS)

    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>

    /* workaround for /W4 warnings about 'constant expressions' */
#   define IRTLASSERT(f)                                    \
    ((void) ((f) || (PuDbgAssertFailed(DBG_CONTEXT, #f), 0) ))

#  elif defined(_DEBUG)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)

    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>

    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)

#  else

#   include <assert.h>
#   define IRTLASSERT(f) assert(f)

#  endif /* different definitions of IRTLASSERT */

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)              (f)
#  endif
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define IRTLTRACE4(psz, p1, p2, p3, p4) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4)
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4, p5)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !IRTLDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)          ((void)0)
#  endif
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE1(psz, p1)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE2(psz, p1, p2) 1 ? (void)0 : IrtlTrace
#  define IRTLTRACE3(psz, p1, p2, p3)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE4(psz, p1, p2, p3, p4)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) 1 ? (void)0 : IrtlTrace
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !IRTLDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#else
# define IRTLASSERT(f) _ASSERTE(f)

#endif /* !_AFX */


/* Writes trace messages to debug stream */
#ifdef __cplusplus
extern "C" {
#endif /* !__cplusplus */

IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...);

IRTL_DLLEXP
DWORD
IrtlSetDebugOutput(
    DWORD dwFlags);

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}; // extern "C"
#endif /* __cplusplus */


#ifdef IRTLDEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !IRTLDEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !IRTLDEBUG */


#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\lkrhash.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, PALarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash
       10/2000 - Port to kernel mode

--*/


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

#ifndef __LKR_HASH_H__
// external definitions
# include <LKR-hash.h>
#endif //  !__LKR_HASH_H__

#ifndef __IRTLDBG_H__
# include <IrtlDbg.h>
#endif // !__IRTLDBG_H__

#ifndef LKR_NO_GLOBAL_LIST
# ifndef __LSTENTRY_H__
#  include <LstEntry.h>
# endif // !__LSTENTRY_H__
#else  // LKR_NO_GLOBAL_LIST
# ifndef __LOCKS_H__
#  include <Locks.h>
# endif // !__LOCKS_H__
#endif // LKR_NO_GLOBAL_LIST

#ifndef __HASHFN_H__
# include <HashFn.h>
#endif // !__HASHFN_H__


// Disable old-style deprecated iterators, by default
#ifndef LKR_DEPRECATED_ITERATORS
# define LKR_NO_DEPRECATED_ITERATORS
#endif // !LKR_DEPRECATED_ITERATORS

#ifndef LKR_NO_DEPRECATED_ITERATORS
# undef  LKR_DEPRECATED_ITERATORS
# define LKR_DEPRECATED_ITERATORS 1
#endif // !LKR_NO_DEPRECATED_ITERATORS

#undef  LKR_COUNTDOWN

// Is bucket locking enabled? If not, then the table lock must be held
// for longer, but that may be cheaper
#define LKR_USE_BUCKET_LOCKS

#define LKR_ALLOW_NULL_RECORDS

// #define __LKRHASH_NO_NAMESPACE__
// #define __HASHFN_NO_NAMESPACE__

// #define LKR_TABLE_LOCK  CReaderWriterLock3 
// #define LKR_BUCKET_LOCK CSmallSpinLock


#ifndef LKR_TABLE_LOCK
# if defined(LKR_EXPOSED_TABLE_LOCK) || defined(LKR_DEPRECATED_ITERATORS)
   // need recursive writelocks
#  define LKR_TABLE_LOCK  CReaderWriterLock4 
# else
   // use non-recursive writelocks
#  define LKR_TABLE_LOCK  CReaderWriterLock2 
# endif
#endif // !LKR_TABLE_LOCK

#ifndef LKR_BUCKET_LOCK
# ifndef LKR_USE_BUCKET_LOCKS
#  define LKR_BUCKET_LOCK CFakeLock
# elif defined(LKR_DEPRECATED_ITERATORS)
#  define LKR_BUCKET_LOCK CReaderWriterLock3 
# else // !LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CSmallSpinLock
# endif // !LKR_DEPRECATED_ITERATORS
#endif // !LKR_BUCKET_LOCK

#ifdef IRTLDEBUG
# define LKR_ALLOC_STATS
# define LKR_OPS_STATS
#endif // IRTLDEBUG



//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups). It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious. See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite. Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table. The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets). An insertion (deletion) may cause an expansion
// (contraction) of the table. This causes relocation of a small number
// of records (at most one bucket worth). All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table. The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes. Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock. Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash subtables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a directory (growable array) of
// segments, each holding m_nSegSize CBuckets. Each CBucket in turn consists
// of a chain of CNodeClumps. Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items. Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks. However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache. We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations. It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash subtable (i.e., it's non-invasive).



#ifdef LKR_STL_ITERATORS

// needed for std::forward_iterator_tag, etc
# include <iterator>

// The iterators have very verbose tracing. Don't want it on all the time
// in debug builds.
# if defined(IRTLDEBUG)  &&  (LKR_STL_ITERATORS >= 2)
#  define LKR_ITER_TRACE  IrtlTrace
# else // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2
#  define LKR_ITER_TRACE  1 ? (void)0 : IrtlTrace
# endif // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// Default values for the hashtable constructors
enum {
#ifdef _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#else
    LK_DFLT_MAXLOAD=     7, // Default upperbound on average chain length.
#endif
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};


/*--------------------------------------------------------------------
 * Undocumented additional creation flag parameters to LKR_CreateTable
 */

enum {
    LK_CREATE_NON_PAGED_ALLOCS = 0x1000, // Use paged or NP pool in kernel
};



//--------------------------------------------------------------------
// Custom memory allocators (optional)
//--------------------------------------------------------------------


#if !defined(LKR_NO_ALLOCATORS) && !defined(LKRHASH_KERNEL_MODE)
// # define LKRHASH_ACACHE 1
// # define LKRHASH_ROCKALL_FAST 1
#endif // !LKR_NO_ALLOCATORS && !LKRHASH_KERNEL_MODE


#if defined(LKRHASH_ACACHE)

# include <acache.hxx>

class ACache : public ALLOC_CACHE_HANDLER
{
private:
    SIZE_T m_cb;

public:
    ACache(IN LPCSTR pszName, IN const ALLOC_CACHE_CONFIGURATION* pacConfig)
        : ALLOC_CACHE_HANDLER(pszName, pacConfig),
          m_cb(m_acConfig.cbSize)
    {}

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*  ClassName()  {return _TEXT("ACache");}
}; // class ACache

  typedef ACache CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(_C, N, Tag)                       \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(_C) };  \
    _C::sm_palloc = new ACache("LKRhash:" #_C, &acc);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
private:
    SIZE_T m_cb;

public:
    FastHeap(SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*  ClassName()  {return _TEXT("FastHeap");}
}; // class FastHeap

  typedef FastHeap CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(_C, N, Tag) \
    _C::sm_palloc = new FastHeap(sizeof(_C))

#endif // LKRHASH_ROCKALL_FAST



#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class _C
# define LKRHASH_ALLOCATOR_DEFINITIONS(_C)                      \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
    public:                                                     \
        friend class CLKRLinearHashTable;                       \
                                                                \
        static void* operator new(size_t s)                     \
        {                                                       \
            UNREFERENCED_PARAMETER(s);                          \
            IRTLASSERT(s == sizeof(_C));                        \
            IRTLASSERT(sm_palloc != NULL);                      \
            return sm_palloc->Alloc();                          \
        }                                                       \
        static void  operator delete(void* pv)                  \
        {                                                       \
            IRTLASSERT(pv != NULL);                             \
            IRTLASSERT(sm_palloc != NULL);                      \
            sm_palloc->Free(pv);                                \
        }


// used in LKR_Initialize()
# define LKRHASH_ALLOCATOR_INIT(_C, N, Tag, f)                  \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(_C::sm_palloc == NULL);                  \
            LKRHASH_ALLOCATOR_NEW(_C, N, Tag);                  \
            f = (_C::sm_palloc != NULL);                        \
        }                                                       \
    }


// used in LKR_Terminate()
# define LKRHASH_ALLOCATOR_UNINIT(_C)                           \
    {                                                           \
        if (_C::sm_palloc != NULL)                              \
        {                                                       \
            delete _C::sm_palloc;                               \
            _C::sm_palloc = NULL;                               \
        }                                                       \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(_C)
# define LKRHASH_ALLOCATOR_INIT(_C, N, Tag, f)
# define LKRHASH_ALLOCATOR_UNINIT(_C)

class CLKRhashAllocator
{
public:
    static const TCHAR*  ClassName()  {return _TEXT("global new");}
};

#endif // !LKRHASH_ALLOCATOR_NEW


#define LKRHASH_CLASS_INIT_DECLS(_C)                    \
private:                                                \
    /* class-wide initialization and termination */     \
    static int  _Initialize(DWORD dwFlags);             \
    static void _Terminate();                           \
                                                        \
    friend int  ::LKR_Initialize(DWORD dwInitFlags);    \
    friend void ::LKR_Terminate()



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, bool  _fDRC, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;

class CNodeClump;
typedef CNodeClump* PNodeClump;

class CBucket;
typedef CBucket* PBucket;

class CSegment;
typedef CSegment* PSegment;

class IRTL_DLLEXP CLKRHashTableStats;



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats();
}; // class CAveragedLockStats

#endif // LOCK_INSTRUMENTATION


#ifndef LKRHASH_KERNEL_MODE

class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats();

    static const LONG*
    BucketSizes();

    static LONG
    BucketSize(
        LONG nBucketIndex);

    static LONG
    BucketIndex(
        LONG nBucketLength);
}; // class CLKRHashTableStats

#endif // !LKRHASH_KERNEL_MODE



//--------------------------------------------------------------------
// Keep some statistics about allocations/frees and about various operations

#ifdef LKR_ALLOC_STATS

# define DECLARE_ALLOC_STAT(Type)               \
    mutable LONG  m_c##Type##Allocs;            \
    mutable LONG  m_c##Type##Frees;             \
    static LONG  sm_c##Type##Allocs;            \
    static LONG  sm_c##Type##Frees

# define DECLARE_CLASS_ALLOC_STAT_STORAGE(Class, Type)  \
    LONG LKRHASH_NS::Class::sm_c##Type##Allocs;         \
    LONG LKRHASH_NS::Class::sm_c##Type##Frees

# define INIT_ALLOC_STAT(Type)                  \
    m_c##Type##Allocs = m_c##Type##Frees = 0

# define INIT_CLASS_ALLOC_STAT(Class, Type)     \
    LKRHASH_NS::Class::sm_c##Type##Allocs = 0;  \
    LKRHASH_NS::Class::sm_c##Type##Frees = 0

# define INCREMENT_ALLOC_STAT(Type)             \
    InterlockedIncrement(&m_c##Type##Allocs);   \
    InterlockedIncrement(&sm_c##Type##Allocs)

# define INCREMENT_FREE_STAT(Type)              \
    InterlockedIncrement(&m_c##Type##Frees);    \
    InterlockedIncrement(&sm_c##Type##Frees)

# define VALIDATE_DUMP_ALLOC_STAT(Type)                         \
    IRTLASSERT(m_c##Type##Allocs == m_c##Type##Frees);          \
    IRTLTRACE(_TEXT(#Type) _TEXT(": Allocs=%ld, Frees=%ld\n"),  \
              m_c##Type##Allocs, m_c##Type##Frees)

# define VALIDATE_DUMP_CLASS_ALLOC_STAT(Class, Type)            \
    IRTLASSERT(LKRHASH_NS::Class::sm_c##Type##Allocs            \
               == LKRHASH_NS::Class::sm_c##Type##Frees);        \
    IRTLTRACE(_TEXT("Global ") _TEXT(#Type)                     \
              _TEXT(": Allocs=%ld, Frees=%ld\n"),               \
              LKRHASH_NS::Class::sm_c##Type##Allocs,            \
              LKRHASH_NS::Class::sm_c##Type##Frees)

#else  // !LKR_ALLOC_STATS
# define DECLARE_ALLOC_STAT(Type)
# define DECLARE_CLASS_ALLOC_STAT_STORAGE(Class, Type)
# define INIT_ALLOC_STAT(Type)                          ((void) 0)
# define INIT_CLASS_ALLOC_STAT(Class, Type)             ((void) 0)
# define INCREMENT_ALLOC_STAT(Type)                     ((void) 0)
# define INCREMENT_FREE_STAT(Type)                      ((void) 0)
# define VALIDATE_DUMP_ALLOC_STAT(Type)                 ((void) 0)
# define VALIDATE_DUMP_CLASS_ALLOC_STAT(Class, Type)    ((void) 0)
#endif // !LKR_ALLOC_STATS



// Statistics on different kinds of operations

#ifdef LKR_OPS_STATS

# define DECLARE_OP_STAT(Type)              \
    mutable LONG  m_c##Type##Ops;           \
    static LONG  sm_c##Type##Ops

# define DECLARE_CLASS_OP_STAT_STORAGE(Class, Type) \
    LONG LKRHASH_NS::Class::sm_c##Type##Ops

# define INIT_OP_STAT(Type)                 \
    m_c##Type##Ops = 0

# define INIT_CLASS_OP_STAT(Class, Type)    \
    LKRHASH_NS::Class::sm_c##Type##Ops = 0

# define INCREMENT_OP_STAT(Type)            \
    InterlockedIncrement(&m_c##Type##Ops);  \
    InterlockedIncrement(&sm_c##Type##Ops)

# define DUMP_OP_STAT(Type)                                         \
    IRTLTRACE(_TEXT(#Type) _TEXT(": Ops=%ld\n"), m_c##Type##Ops)

# define DUMP_CLASS_OP_STAT(Class, Type)                            \
    IRTLTRACE(_TEXT("Global ") _TEXT(#Type) _TEXT(": Ops=%ld\n"),   \
              LKRHASH_NS::Class::sm_c##Type##Ops)

#else  // !LKR_OPS_STATS
# define DECLARE_OP_STAT(Type)
# define DECLARE_CLASS_OP_STAT_STORAGE(Class, Type)
# define INIT_OP_STAT(Type)                 ((void) 0)
# define INIT_CLASS_OP_STAT(Class,Type)     ((void) 0)
# define INCREMENT_OP_STAT(Type)            ((void) 0)
# define DUMP_OP_STAT(Type)                 ((void) 0)
# define DUMP_CLASS_OP_STAT(Class,Type)     ((void) 0)
#endif // !LKR_OPS_STATS



//--------------------------------------------------------------------
// Global table lock code. This is only used to measure how much of a
// slowdown having a global lock on the CLKRHashTable causes. It is
// *never* used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



// Class for nodes on a bucket chain. Instead of a node containing
// one (signature, record-pointer, next-tuple-pointer) tuple, it
// contains _N_ such tuples. (N-1 next-tuple-pointers are omitted.)
// This improves locality of reference greatly; i.e., it's L1
// cache-friendly. It also reduces memory fragmentation and memory
// allocator overhead. It does complicate the chain traversal code
// slightly, admittedly.
//
// This theory is beautiful. In practice, however, CNodeClumps
// are *not* perfectly aligned on 32-byte boundaries by the memory
// allocators. Experimental results indicate that we get a 2-3%
// speed improvement by using 32-byte-aligned blocks, but this must
// be considered against the average of 16 bytes wasted per block.

class CNodeClump
{
public:
    // Record slots per chunk - set so a chunk matches (one or two)
    // cache lines. 3 ==> 32 bytes, 7 ==> 64 bytes, on 32-bit system.
    // Note: the default max load factor is 7, which implies that
    // there will seldom be more than one node clump in a chain.
    enum {
#if defined(LOCK_INSTRUMENTATION)
        BUCKET_BYTE_SIZE = 96,
#else
        BUCKET_BYTE_SIZE = 64,
#endif
        // overhead = m_Lock + m_pncNext
        BUCKET_OVERHEAD  = sizeof(LKR_BUCKET_LOCK) + sizeof(PNodeClump),
        // node size = dwKeySignature + pvRecord
        NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
        NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE,
#ifdef _WIN64
        NODE_CLUMP_BITS  = 2,
#else
        NODE_CLUMP_BITS  = 3,
#endif
        _NODES_PER_CLUMP  = 15, // <<---
        _NODE_CLUMP_BITS  = 4,
    };

    typedef int NodeIndex;  // for iterating through a CNodeClump

    enum {
        // See if countdown loops are faster than countup loops for
        // traversing a CNodeClump. In practice, countup loops are faster.
        // These constants allow us to write direction-agnostic loops,
        // such as
        //    for (NodeIndex x = NODE_BEGIN;  x != NODE_END;  x += NODE_STEP)
#ifndef LKR_COUNTDOWN
        // for (NodeIndex x = 0;  x < NODES_PER_CLUMP;  ++x) ...
        NODE_BEGIN = 0,
        NODE_END   = NODES_PER_CLUMP,
        NODE_STEP  = +1,
#else // LKR_COUNTDOWN
        // for (NodeIndex x = NODES_PER_CLUMP;  --x >= 0;  ) ...
        NODE_BEGIN = NODES_PER_CLUMP - 1,
        NODE_END   = -1,
        NODE_STEP  = -1,
#endif // LKR_COUNTDOWN
    };

    // If m_dwKeySigs[iNode] == HASH_INVALID_SIGNATURE then the node is
    // empty, as are all nodes in the range [iNode+NODE_STEP, NODE_END).
    enum {
#ifndef __HASHFN_NO_NAMESPACE__
        HASH_INVALID_SIGNATURE = HashFn::HASH_INVALID_SIGNATURE,
#else // !__HASHFN_NO_NAMESPACE__
        HASH_INVALID_SIGNATURE = ::HASH_INVALID_SIGNATURE,
#endif // !__HASHFN_NO_NAMESPACE__
    };


    DWORD       m_dwKeySigs[NODES_PER_CLUMP];// hash values computed from keys
    PNodeClump  m_pncNext;                   // next node clump on the chain
    const void* m_pvNode[NODES_PER_CLUMP];   // pointers to records


    CNodeClump()
    {
        STATIC_ASSERT((1 << (NODE_CLUMP_BITS - 1)) < NODES_PER_CLUMP);
        STATIC_ASSERT(NODES_PER_CLUMP <= (1 << NODE_CLUMP_BITS));
        STATIC_ASSERT(NODES_PER_CLUMP * NODE_SIZE + BUCKET_OVERHEAD
                            <= BUCKET_BYTE_SIZE);
        Clear();
    }

    void
    Clear()
    { 
        m_pncNext = NULL;  // no dangling pointers
        IRTLASSERT(IsLastClump());

        for (NodeIndex iNode = NODES_PER_CLUMP;  --iNode >= 0; )
        {
            m_dwKeySigs[iNode] = HASH_INVALID_SIGNATURE;
            m_pvNode[iNode]    = NULL;
            IRTLASSERT(IsEmptyAndInvalid(iNode));
        }
    }

    DWORD
    Signature(
        NodeIndex iNode) const
    {
        IRTLASSERT(0 <= iNode  &&  iNode < NODES_PER_CLUMP);
        return m_dwKeySigs[iNode];
    }

    const void*
    Node(
        NodeIndex iNode) const
    {
        IRTLASSERT(0 <= iNode  &&  iNode < NODES_PER_CLUMP);
        return m_pvNode[iNode];
    }

    PNodeClump const
    NextClump() const
    {
        return m_pncNext;
    }

    bool
    InvalidSignature(
        NodeIndex iNode) const
    {
        IRTLASSERT(0 <= iNode  &&  iNode < NODES_PER_CLUMP);
        return (m_dwKeySigs[iNode] == HASH_INVALID_SIGNATURE);
    }

    bool
    IsEmptyNode(
        NodeIndex iNode) const
    {
        IRTLASSERT(0 <= iNode  &&  iNode < NODES_PER_CLUMP);
#ifndef LKR_ALLOW_NULL_RECORDS
        return (m_pvNode[iNode] == NULL);
#else
        return InvalidSignature(iNode);
#endif
    }

    bool
    IsEmptyAndInvalid(
        NodeIndex iNode) const
    {
        return
#ifndef LKR_ALLOW_NULL_RECORDS
            IsEmptyNode(iNode) &&
#endif
            InvalidSignature(iNode);
    }

    bool
    IsEmptySlot(
        NodeIndex iNode) const
    {
        return InvalidSignature(iNode);
    }

    bool
    IsLastClump() const
    {
        return (m_pncNext == NULL);
    }

#ifdef IRTLDEBUG
    bool
    NoMoreValidSlots(
        NodeIndex iNode) const
    {
        IRTLASSERT(0 <= iNode  &&  iNode < NODES_PER_CLUMP);
        bool f = IsLastClump();  // last nodeclump in chain
        for (  ;  iNode != NODE_END;  iNode += NODE_STEP)
            f = f  &&  IsEmptyAndInvalid(iNode);
        return f;
    }

    bool
    NoValidSlots() const
    {
        return NoMoreValidSlots(NODE_BEGIN);
    }

    // Don't want overhead of calls to dtor in retail build, since it
    // doesn't do anything useful
    ~CNodeClump()
    {
        IRTLASSERT(IsLastClump());  // no dangling pointers
        for (NodeIndex iNode = NODES_PER_CLUMP;  --iNode >= 0;  )
            IRTLASSERT(InvalidSignature(iNode)  &&  IsEmptyNode(iNode));
    }
#endif // IRTLDEBUG

private:
    // We rely on the compiler to generate an efficient copy constructor
    // and operator= that make shallow (bitwise) copies of CNodeClumps.

    LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);

    LKRHASH_CLASS_INIT_DECLS(CNodeClump);
}; // class CNodeClump



#ifdef LKR_STL_ITERATORS

class IRTL_DLLEXP CLKRLinearHashTable_Iterator;
class IRTL_DLLEXP CLKRHashTable_Iterator;


class IRTL_DLLEXP CLKRLinearHashTable_Iterator
{
    friend class CLKRLinearHashTable;
    friend class CLKRHashTable;
    friend class CLKRHashTable_Iterator;

protected:
    typedef short NodeIndex;

    CLKRLinearHashTable* m_plht;        // which linear hash subtable?
    PNodeClump           m_pnc;         // a CNodeClump in bucket
    DWORD                m_dwBucketAddr;// bucket index
    NodeIndex            m_iNode;       // offset within m_pnc

    enum {
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
    };

    CLKRLinearHashTable_Iterator(
        CLKRLinearHashTable* plht,
        PNodeClump           pnc,
        DWORD                dwBucketAddr,
        NodeIndex            iNode)
        : m_plht(plht),
          m_pnc(pnc),
          m_dwBucketAddr(dwBucketAddr),
          m_iNode(iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::prot ctor, this=%p, plht=%p, ")
                       _TEXT("pnc=%p, ba=%d, in=%d\n"),
                       this, plht, pnc, dwBucketAddr, iNode);
    }

    inline void _AddRef(
        LK_ADDREF_REASON lkar) const;

    bool _Increment(
        bool fDecrementOldValue=true);

    NodeIndex _NodesPerClump() const    { return NODES_PER_CLUMP; }
    NodeIndex _NodeBegin() const        { return NODE_BEGIN; }
    NodeIndex _NodeEnd() const          { return NODE_END; }
    NodeIndex _NodeStep() const         { return NODE_STEP; }

public:
    CLKRLinearHashTable_Iterator()
        : m_plht(NULL),
          m_pnc(NULL),
          m_dwBucketAddr(0),
          m_iNode(0)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::default ctor, this=%p\n"), this);
    }

    CLKRLinearHashTable_Iterator(
        const CLKRLinearHashTable_Iterator& rhs)
        : m_plht(rhs.m_plht),
          m_pnc(rhs.m_pnc),
          m_dwBucketAddr(rhs.m_dwBucketAddr),
          m_iNode(rhs.m_iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
        _AddRef(LKAR_ITER_COPY_CTOR);
    }

    CLKRLinearHashTable_Iterator& operator=(
        const CLKRLinearHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);
        rhs._AddRef(LKAR_ITER_ASSIGN_ACQUIRE);
        this->_AddRef(LKAR_ITER_ASSIGN_RELEASE);

        m_plht =         rhs.m_plht;
        m_pnc =          rhs.m_pnc;
        m_dwBucketAddr = rhs.m_dwBucketAddr;
        m_iNode =        rhs.m_iNode;

        return *this;
    }

    ~CLKRLinearHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::dtor, this=%p, plht=%p\n"),
                       this, m_plht);
        _AddRef(LKAR_ITER_DTOR);
    }

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
        bool fValid = (m_plht != NULL  &&  m_pnc != NULL
                       &&  0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP);
        if (fValid)
            fValid = (m_pnc->m_dwKeySigs[m_iNode] != HASH_INVALID_SIGNATURE);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_pnc->m_pvNode[m_iNode];
    }

    inline const DWORD_PTR Key() const;

    bool operator==(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_pnc == rhs.m_pnc)    // most unique field
                    &&  (m_iNode == rhs.m_iNode));
        IRTLASSERT(!fEQ || ((m_plht == rhs.m_plht)
                            &&  (m_dwBucketAddr == rhs.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_pnc != rhs.m_pnc)
                    ||  (m_iNode != rhs.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRLinearHashTable_Iterator



class IRTL_DLLEXP CLKRHashTable_Iterator
{
    friend class CLKRHashTable;

protected:
    typedef short SubTableIndex;

    // order important to minimize size
    CLKRHashTable*                  m_pht;      // which hash table?
    CLKRLinearHashTable_Iterator    m_subiter;  // iterator into subtable
    SubTableIndex                   m_ist;      // index of subtable

    CLKRHashTable_Iterator(
        CLKRHashTable* pht,
        SubTableIndex  ist)
        : m_pht(pht),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::prot ctor, this=%p, pht=%p, ist=%d\n"),
                       this, pht, ist);
    }

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRHashTable_Iterator()
        : m_pht(NULL),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(0)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::default ctor, this=%p\n"), this);
    }

#ifdef IRTLDEBUG
    // Compiler does a perfectly adequate job of synthesizing these methods.
    CLKRHashTable_Iterator(
        const CLKRHashTable_Iterator& rhs)
        : m_pht(rhs.m_pht),
          m_subiter(rhs.m_subiter),
          m_ist(rhs.m_ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
    }

    CLKRHashTable_Iterator& operator=(
        const CLKRHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);

        m_ist     = rhs.m_ist;
        m_subiter = rhs.m_subiter;
        m_pht     = rhs.m_pht;

        return *this;
    }

    ~CLKRHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::dtor, this=%p, pht=%p\n"), this, m_pht);
    }
#endif // IRTLDEBUG

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;
    }

    bool IsValid() const
    {
        bool fValid = (m_pht != NULL  &&  m_ist >= 0);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_plht != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_pnc != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= m_subiter.m_iNode);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_iNode < CNodeClump::NODES_PER_CLUMP);
        IRTLASSERT(fValid);

        if (fValid)
        {
            fValid = (m_subiter.m_pnc->m_dwKeySigs[m_subiter.m_iNode]
                            != CNodeClump::HASH_INVALID_SIGNATURE);
        }
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Record();
    }

    const DWORD_PTR Key() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Key();
    }

    bool operator==(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_subiter.m_pnc
                            == rhs.m_subiter.m_pnc)     // most unique field
                    &&  (m_subiter.m_iNode == rhs.m_subiter.m_iNode));
        IRTLASSERT(!fEQ
                   || ((m_ist == rhs.m_ist)
                       &&  (m_pht == rhs.m_pht)
                       &&  (m_subiter.m_plht == rhs.m_subiter.m_plht)
                       &&  (m_subiter.m_dwBucketAddr
                                == rhs.m_subiter.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_subiter.m_pnc != rhs.m_subiter.m_pnc)
                    ||  (m_subiter.m_iNode != rhs.m_subiter.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRHashTable_Iterator

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash (sub)table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    typedef LKR_TABLE_LOCK  TableLock;
    typedef LKR_BUCKET_LOCK BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRLinearHashTable_Iterator;
    typedef CLKRLinearHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

private:
    friend class CNodeClump;
    friend class CLKRHashTable;

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION


public:

    // aliases for convenience
    enum {
        MIN_DIRSIZE_BITS       =  2,    // min size for directory of segments
        MIN_DIRSIZE            = 1u << MIN_DIRSIZE_BITS,
        MAX_DIRSIZE_BITS       = 20,    // max size for directory of segments
        MAX_DIRSIZE            = 1u << MAX_DIRSIZE_BITS,
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
        NAME_SIZE              = 24,    // CHARs, includes trailing '\0'
        MAX_LKR_SUBTABLES      = MAXIMUM_PROCESSORS, // 64 on Win64, 32 on W32
        INVALID_PARENT_INDEX   = 128,
    };

    typedef CNodeClump::NodeIndex NodeIndex;


private:

    //
    // Miscellaneous helper functions
    //

    LKRHASH_CLASS_INIT_DECLS(CLKRLinearHashTable);

    // Convert a hash signature to a bucket address
    inline DWORD        _BucketAddress(DWORD dwSignature) const;

    // See the Linear Hashing paper
    inline static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask);

    inline DWORD        _H0(DWORD dwSignature) const;

    // See the Linear Hashing paper. Preserves one bit more than _H0.
    inline static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask);

    inline DWORD        _H1(DWORD dwSignature) const;

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    inline PSegment&    _Segment(DWORD dwBucketAddr) const;

    // Offset within the segment of the bucketaddress
    inline DWORD        _SegIndex(DWORD dwBucketAddr) const;

    // Convert a bucketaddress to a PBucket
    inline PBucket      _BucketFromAddress(DWORD dwBucketAddr) const;

    // Number of nodes in a CNodeClump
    inline NodeIndex    _NodesPerClump() const;

    // Index of first node in a CNodeClump
    inline NodeIndex    _NodeBegin() const;

    // Index of last node in a CNodeClump
    inline NodeIndex    _NodeEnd() const;

    // Advance from _NodeBegin() to _NodeEnd() by this increment
    inline NodeIndex    _NodeStep() const;

    // Use bucket locks or not?
    inline bool         _UseBucketLocking() const;

    // Move the expansion index forward by one.
    inline void         _IncrementExpansionIndex();

    // Move the expansion index back by one.
    inline void         _DecrementExpansionIndex();

    // Extract the key from a record
    inline const DWORD_PTR _ExtractKey(const void* pvRecord) const;

    // Hash the key
    inline DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const;

    // Compare two keys for equality
    inline int          _CompareKeys(const DWORD_PTR pnKey1,
                                     const DWORD_PTR pnKey2) const;

    // AddRef or Release a record.
    inline LONG         _AddRefRecord(const void* pvRecord,
                                      LK_ADDREF_REASON lkar) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called subtable->WriteLock().
    inline bool         _ReadOrWriteLock() const;

    inline void         _ReadOrWriteUnlock(bool fReadLocked) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    PSegment* const
    _AllocateSegmentDirectory(
        size_t n);

    bool
    _FreeSegmentDirectory();

    PNodeClump const
    _AllocateNodeClump() const;

    bool
    _FreeNodeClump(
        PNodeClump pnc) const;

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("LH%05x"), 0xFFFFF & l);
        return s_tszName;
    }

    // Statistics for the subtable lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:
    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check

    // Put the table lock in the first cache line, far away from the other
    // volatile fields.
    mutable TableLock  m_Lock;      // Lock on entire linear hash subtable
    const bool    m_fUseLocks;      // Must use locks to protect data
    bool          m_fSealed;        // no further updates allowed

    mutable LK_RETCODE m_lkrcState; // Internal state of subtable
    CHAR          m_szName[NAME_SIZE];// an identifier for debugging

    // type-specific function pointers
    LKR_PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    LKR_PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    LKR_PFnCompareKeys  m_pfnCompareKeys;   // Compare two keys
    LKR_PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    BYTE          m_MaxLoad;        // max load factor (average chain length)
    BYTE          m_nLevel;         // number of subtable doublings performed
    BYTE          m_lkts;           // "size" of subtable: small/medium/large
    BYTE          m_nSegBits;      // C{Small,Medium,Large}Segment::SEGBITS

    WORD          m_nSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    WORD          m_nSegMask;      // C{Small,Medium,Large}Segment::SEGMASK

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation

    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    PSegment*     m_paDirSegs;      // directory of subtable segments
    PSegment      m_aDirSegs[MIN_DIRSIZE];  // inlined directory, adequate
                                    // for many subtables

    // These three fields are fairly volatile, but tend to be adjusted
    // at the same time. Keep them well away from the TableLock.
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    DWORD         m_cRecords;       // number of records in the subtable
    DWORD         m_cActiveBuckets; // number of buckets in use (subtable size)

    const BYTE    m_nTableLockType; // for debugging: LOCK_READERWRITERLOCK4
    const BYTE    m_nBucketLockType;// for debugging: e.g., LOCK_SPINLOCK
    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    const BYTE    m_iParentIndex;   // index within parent table
    const bool    m_fMultiKeys;     // Allow multiple identical keys?
    const bool    m_fNonPagedAllocs;// Use paged or NP pool in kernel
    BYTE          m_Dummy1;

    // Reserve some space for future debugging needs
    DWORD_PTR     m_pvReserved1;
    DWORD_PTR     m_pvReserved2;
    DWORD_PTR     m_pvReserved3;
    DWORD_PTR     m_pvReserved4;

#ifndef LKR_NO_GLOBAL_LIST
    CListEntry    m_leGlobalList;

    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
#endif // !LKR_NO_GLOBAL_LIST


    DECLARE_ALLOC_STAT(SegDir);
    DECLARE_ALLOC_STAT(Segment);
    DECLARE_ALLOC_STAT(NodeClump);

    DECLARE_OP_STAT(InsertRecord);
    DECLARE_OP_STAT(FindKey);
    DECLARE_OP_STAT(FindRecord);
    DECLARE_OP_STAT(DeleteKey);
    DECLARE_OP_STAT(DeleteRecord);
    DECLARE_OP_STAT(FindKeyMultiRec);
    DECLARE_OP_STAT(DeleteKeyMultiRec);
    DECLARE_OP_STAT(Expand);
    DECLARE_OP_STAT(Contract);
    DECLARE_OP_STAT(LevelExpansion);
    DECLARE_OP_STAT(LevelContraction);
    DECLARE_OP_STAT(ApplyIf);
    DECLARE_OP_STAT(DeleteIf);


    // Non-trivial implementation functions
    void         _InsertThisIntoGlobalList();
    void         _RemoveThisFromGlobalList();


    LK_RETCODE   _InsertRecord(
                        const void* pvRecord,
                        const DWORD_PTR pnKey,
                        const DWORD dwSignature,
                        bool fOverwrite
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                        );
    LK_RETCODE   _DeleteKey(
                        const DWORD_PTR pnKey,
                        const DWORD dwSignature,
                        const void** ppvRecord,
                        bool fDeleteAllSame);
    LK_RETCODE   _DeleteRecord(
                        const void* pvRecord,
                        const DWORD dwSignature);
    void         _DeleteNode(
                        PBucket const pbkt,
                        PNodeClump& rpnc,
                        PNodeClump& rpncPrev,
                        NodeIndex& riNode,
                        LK_ADDREF_REASON lkar);
    LK_RETCODE   _FindKey(
                        const DWORD_PTR pnKey,
                        const DWORD dwSignature,
                        const void** ppvRecord
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                          ) const;
    LK_RETCODE   _FindRecord(
                        const void* pvRecord,
                        const DWORD dwSignature) const;
    LK_RETCODE   _FindKeyMultipleRecords(
                        const DWORD_PTR pnKey,
                        const DWORD dwSignature,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr) const;
    LK_RETCODE   _DeleteKeyMultipleRecords(
                        const DWORD_PTR pnKey,
                        const DWORD dwSignature,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr);

#ifdef LKR_APPLY_IF
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _ApplyIf(
                        LKR_PFnRecordPred   pfnPredicate,
                        LKR_PFnRecordAction pfnAction,
                        void* pvState,
                        LK_LOCKTYPE lkl,
                        LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(
                        LKR_PFnRecordPred pfnPredicate,
                        void* pvState,
                        LK_PREDICATE& rlkp);
#endif // LKR_APPLY_IF

    // returns count of errors in compacted state => 0 is good
    int          _IsBucketChainCompact(PBucket const pbkt) const;
    int          _IsBucketChainMultiKeySorted(PBucket const pbkt) const;

    // helper functions
    void         _Clear(bool fShrinkDirectory);
    LK_RETCODE   _SetSegVars(LK_TABLESIZE lkts, DWORD cInitialBuckets);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitBucketChain(
                        PNodeClump  pncOldTarget,
                        PNodeClump  pncNewTarget,
                        const DWORD dwBktAddrMask,
                        const DWORD dwNewBkt,
                        PNodeClump  pncFreeList);
    LK_RETCODE   _AppendBucketChain(
                        PBucket const pbktNewTarget,
                        CNodeClump&   rncOldFirst,
                        PNodeClump    pncFreeList);
    LK_RETCODE   _MergeSortBucketChains(
                        PBucket const pbktNewTarget,
                        CNodeClump&   rncOldFirst,
                        PNodeClump    pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.
    CLKRLinearHashTable(const CLKRLinearHashTable&);
    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&);

private:
    // This ctor is used by CLKRHashTable, the parent table
    CLKRLinearHashTable(
        LPCSTR              pszClassName,   // Identifies subtable for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned            maxload,        // Upperbound on avg chain length
        DWORD               initsize,       // Initial size of hash subtable
        CLKRHashTable*      phtParent,      // Owning table.
        int                 iParentIndex,   // index within parent table
        bool                fMultiKeys,     // Allow multiple identical keys?
        bool                fUseLocks,      // Must use locks
        bool                fNonPagedAllocs // use paged or NP pool in kernel
        );

    // Does all the common work of the constructors
    LK_RETCODE
    _Initialize(
        LKR_PFnExtractKey   pfnExtractKey,
        LKR_PFnCalcKeyHash  pfnCalcKeyHash,
        LKR_PFnCompareKeys  pfnCompareKeys,
        LKR_PFnAddRefRecord pfnAddRefRecord,
        LPCSTR              pszClassName,
        unsigned            maxload,
        DWORD               initsize);

public:
    CLKRLinearHashTable(
        LPCSTR              pszClassName,   // Identifies subtable for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash subtable.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS, // for signature compatiblity
                                                  // with CLKRHashTable
        bool                fMultiKeys=false,// Allow multiple identical keys?
        bool                fUseLocks=true   // Must use locks
#ifdef LKRHASH_KERNEL_MODE
      , bool                fNonPagedAllocs=true  // use paged or NP pool
#endif
        );

    ~CLKRLinearHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRLinearHashTable");}

    unsigned           NumSubTables() const  {return 1;}

    bool               MultiKeys() const
    {
        return m_fMultiKeys;
    }

    bool               UsingLocks() const
    {
        return m_fUseLocks;
    }

#ifdef LKRHASH_KERNEL_MODE
    bool               NonPagedAllocs() const
    {
        return m_fNonPagedAllocs;
    }
#endif

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash subtable.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(
                        const void* pvRecord,
                        bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

#ifndef LKR_ALLOW_NULL_RECORDS
        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        const DWORD_PTR pnKey = _ExtractKey(pvRecord);

        return _InsertRecord(pvRecord, pnKey, _CalcKeyHash(pnKey), fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(
                        const DWORD_PTR pnKey,
                        const void** ppvRecord=NULL,
                        bool fDeleteAllSame=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord != NULL)
            *ppvRecord = NULL;

        return _DeleteKey(pnKey, _CalcKeyHash(pnKey),
                          ppvRecord, fDeleteAllSame);
    }

    // Delete a record from the subtable, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(
                        const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

#ifndef LKR_ALLOW_NULL_RECORDS
        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash subtable not in usable state
    // Note: the record is AddRef'd. You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(
                        const DWORD_PTR pnKey,
                        const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the subtable
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the subtable
    //           LK_UNUSABLE, if hash subtable not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(
                        const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

#ifndef LKR_ALLOW_NULL_RECORDS
        if (pvRecord == NULL)
            return LK_BAD_RECORD;
#endif

        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    LK_RETCODE     FindKeyMultipleRecords(
                        const DWORD_PTR pnKey,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr=NULL) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pcRecords == NULL)
            return LK_BAD_PARAMETERS;

        return _FindKeyMultipleRecords(pnKey, _CalcKeyHash(pnKey),
                                       pcRecords, pplmr);
    }

    LK_RETCODE     DeleteKeyMultipleRecords(
                        const DWORD_PTR pnKey,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr=NULL)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pcRecords == NULL)
            return LK_BAD_PARAMETERS;

        return _DeleteKeyMultipleRecords(pnKey, _CalcKeyHash(pnKey),
                                         pcRecords, pplmr);
    }

    static LK_RETCODE FreeMultipleRecords(LKR_MULTIPLE_RECORDS* plmr);

#ifdef LKR_APPLY_IF
    // Walk the hash subtable, applying pfnAction to all records.
    // Locks the whole subtable for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(
                        LKR_PFnRecordAction pfnAction,
                        void*           pvState=NULL,
                        LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash subtable, applying pfnAction to any records that match
    // pfnPredicate. Locks the whole subtable for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(
                        LKR_PFnRecordPred   pfnPredicate,
                        LKR_PFnRecordAction pfnAction,
                        void*               pvState=NULL,
                        LK_LOCKTYPE         lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the subtable for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey. The iterator will end up pointing to garbage.
    DWORD          DeleteIf(
                        LKR_PFnRecordPred pfnPredicate,
                        void*             pvState=NULL);
#endif // LKR_APPLY_IF


    // Check subtable for consistency. Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the subtable
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the subtable
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the subtable
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_nSegSize); }

    // Get hash subtable statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash subtable usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    // Is the hash subtable consistent and correct?
    bool           IsValid() const
    {
        STATIC_ASSERT(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 2) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnCompareKeys != NULL
                  &&  m_pfnAddRefRecord != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the subtable lock
    void        SetTableLockSpinCount(WORD wSpins);

    // Get the spin count on the subtable lock
    WORD        GetTableLockSpinCount() const;

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


#ifdef LKR_EXPOSED_TABLE_LOCK
public:
#else // !LKR_EXPOSED_TABLE_LOCK
protected:
#endif // !LKR_EXPOSED_TABLE_LOCK

    //
    // Lock manipulators
    //

    // Lock the subtable (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the subtable (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the subtable for writing
    void        WriteUnlock()
    { m_Lock.WriteUnlock(); }

    // Unlock the subtable for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the subtable already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the subtable already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the subtable unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the subtable unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive()
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);
#endif // LKRHASH_KERNEL_MODE


#ifdef LKR_DEPRECATED_ITERATORS
    // These iterators are deprecated. Use the STL-style iterators instead.

public:

    // Iterators can be used to walk the subtable. To ensure a consistent
    // view of the data, the iterator locks the whole subtable. This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the subtable. Use with care.
    //
    // You should not use an iterator to walk the subtable, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree. Or use the STL-style iterators.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of
    // the iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called
    //     //   ht.AddRefRecord(pRec, LKAR_EXPLICIT_ACQUIRE) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If the record has no reference-counting semantics, then you can
    // ignore the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash subtable?
        DWORD               m_dwBucketAddr; // bucket index
        PNodeClump          m_pnc;          // a CNodeClump in bucket
        NodeIndex           m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // TODO: implement these properly; they could be useful.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to. Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to. The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    }; // class CIterator


    // Const iterators for readonly access. You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    }; // class CConstIterator


private:
    // The public APIs lock the subtable. The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash subtable
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the subtable.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };

#endif // LKR_DEPRECATED_ITERATORS


#ifdef LKR_STL_ITERATORS

private:
    bool _Erase(Iterator& riter, DWORD dwSignature);
    bool _Find(DWORD_PTR pnKey, DWORD dwSignature,
               Iterator& riterResult);

    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH:_IsValidIterator(%p)\n"), &riter);
        bool fValid = ((riter.m_plht == this)
                       &&  (riter.m_dwBucketAddr < m_cActiveBuckets)
                       &&  riter.IsValid());
        IRTLASSERT(fValid);
        return fValid;
    }

public:
    // Return iterator pointing to first item in subtable
    Iterator
    Begin();

    // Return a one-past-the-end iterator. Always empty.
    Iterator
    End() const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::End\n"));
        return Iterator();
    }

    // Insert a record
    // Returns `true' if successful; iterResult points to that record
    // Returns `false' otherwise; iterResult == End()
    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    // Erase the record pointed to by the iterator; adjust the iterator
    // to point to the next record. Returns `true' if successful.
    bool
    Erase(
        /* in,out */ Iterator& riter);

    // Erase the records in the range [riterFirst, riterLast).
    // Returns `true' if successful. riterFirst points to riterLast on return.
    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    // Find the (first) record that has its key == pnKey.
    // If successful, returns `true' and iterator points to (first) record.
    // If fails, returns `false' and iterator == End()
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    // Find the range of records that have their keys == pnKey.
    // If successful, returns `true', iterFirst points to first record,
    //     and iterLast points to one-beyond-the last such record.
    // If fails, returns `false' and both iterators == End().
    // Primarily useful when m_fMultiKey == true
    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRLinearHashTable



#ifdef LKR_STL_ITERATORS

// These functions have to be defined after CLKRLinearHashTable

inline void
CLKRLinearHashTable_Iterator::_AddRef(
    LK_ADDREF_REASON lkar) const
{
    // TODO: should iterator call _AddRefRecord at all
    if (m_plht != NULL  &&  m_iNode != NODE_BEGIN - NODE_STEP)
    {
        IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
                   &&  (unsigned) m_iNode < NODES_PER_CLUMP
                   &&  m_pnc != NULL
                   &&  (lkar < 0 ||  lkar > 0)
                   );
        const void* pvRecord = m_pnc->m_pvNode[m_iNode];
#ifndef LKR_ALLOW_NULL_RECORDS
        IRTLASSERT(pvRecord != NULL);
#endif
        LKR_ITER_TRACE(_TEXT("  LKLH::AddRef, this=%p, Rec=%p\n"),
                       this, pvRecord);
        LONG cRefs = m_plht->_AddRefRecord(pvRecord, lkar);
        UNREFERENCED_PARAMETER(cRefs);
        IRTLASSERT(cRefs > 0);
    }
} // CLKRLinearHashTable_Iterator::_AddRef


inline const DWORD_PTR
CLKRLinearHashTable_Iterator::Key() const
{
    IRTLASSERT(IsValid());
    return m_plht->_ExtractKey(m_pnc->m_pvNode[m_iNode]);
} // CLKRLinearHashTable_Iterator::Key

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the outer table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly. The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRHashTable_Iterator;
    typedef CLKRHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

    friend class CLKRLinearHashTable;
    friend int   ::LKR_Initialize(DWORD dwInitFlags);
    friend void  ::LKR_Terminate();

    // aliases for convenience
    enum {
        NAME_SIZE =              SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP =        SubTable::NODES_PER_CLUMP,
        MAX_LKR_SUBTABLES =      SubTable::MAX_LKR_SUBTABLES,
        INVALID_PARENT_INDEX =   SubTable::INVALID_PARENT_INDEX,
    };

private:
    // Hash table parameters
    DWORD              m_dwSignature;   // debugging: id & corruption check
    CHAR               m_szName[NAME_SIZE]; // an identifier for debugging
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
    LKR_PFnExtractKey  m_pfnExtractKey;
    LKR_PFnCalcKeyHash m_pfnCalcKeyHash;
    DWORD              m_cSubTables;    // number of subtables
    int                m_nSubTableMask;
    SubTable*          m_palhtDir[MAX_LKR_SUBTABLES];  // array of subtables

#ifndef LKR_NO_GLOBAL_LIST
    CListEntry         m_leGlobalList;

    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
#endif // !LKR_NO_GLOBAL_LIST

    DECLARE_ALLOC_STAT(SubTable);

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    LKRHASH_CLASS_INIT_DECLS(CLKRHashTable);

private:
    inline void             _InsertThisIntoGlobalList();
    inline void             _RemoveThisFromGlobalList();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&);
    CLKRHashTable& operator=(const CLKRHashTable&);

    // Extract the key from the record
    inline const DWORD_PTR  _ExtractKey(const void* pvRecord) const;

    // Hash the key
    inline DWORD            _CalcKeyHash(const DWORD_PTR pnKey) const;

    // Use the key's hash signature to multiplex into a subtable
    inline SubTable* const  _SubTable(DWORD dwSignature) const;

    // Find the index of pst within the subtable array
    inline int              _SubTableIndex(SubTable* pst) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    SubTable* const
    _AllocateSubTable(
        LPCSTR              pszClassName,   // Identifies table for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned            maxload,        // Upperbound on avg chain length
        DWORD               initsize,       // Initial size of hash table.
        CLKRHashTable*      phtParent,      // Owning table.
        int                 iParentIndex,   // index within parent table
        bool                fMultiKeys,     // Allow multiple identical keys?
        bool                fUseLocks,      // Must use locks
        bool                fNonPagedAllocs // use paged or NP pool in kernel
    ) const;

    bool
    _FreeSubTable(
        SubTable* plht) const;


public:
    CLKRHashTable(
        LPCSTR              pszClassName,   // Identifies table for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned  maxload=LK_DFLT_MAXLOAD,  // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,// Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS, // #subordinate hash tables.
        bool                fMultiKeys=false,// Allow multiple identical keys?
        bool                fUseLocks=true  // Must use locks
#ifdef LKRHASH_KERNEL_MODE
      , bool                fNonPagedAllocs=true  // use paged or NP pool
#endif
        );

    ~CLKRHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRHashTable");}

    unsigned           NumSubTables() const  {return m_cSubTables;}

    bool               MultiKeys() const;

#ifdef LKRHASH_KERNEL_MODE
    bool               NonPagedAllocs() const;
#endif

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(
                        const void* pvRecord,
                        bool fOverwrite=false);
    LK_RETCODE     DeleteKey(
                        const DWORD_PTR pnKey,
                        const void** ppvRecord=NULL,
                        bool fDeleteAllSame=false);
    LK_RETCODE     DeleteRecord(
                        const void* pvRecord);
    LK_RETCODE     FindKey(
                        const DWORD_PTR pnKey,
                        const void** ppvRecord) const;
    LK_RETCODE     FindRecord(
                        const void* pvRecord) const;
    LK_RETCODE     FindKeyMultipleRecords(
                        const DWORD_PTR pnKey,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr=NULL) const;
    LK_RETCODE     DeleteKeyMultipleRecords(
                        const DWORD_PTR pnKey,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr=NULL);
    static LK_RETCODE FreeMultipleRecords(
                        LKR_MULTIPLE_RECORDS* plmr);

#ifdef LKR_APPLY_IF
    DWORD          Apply(
                        LKR_PFnRecordAction pfnAction,
                        void*           pvState=NULL,
                        LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(
                        LKR_PFnRecordPred   pfnPredicate,
                        LKR_PFnRecordAction pfnAction,
                        void*           pvState=NULL,
                        LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(
                        LKR_PFnRecordPred pfnPredicate,
                        void*         pvState=NULL);
#endif // LKR_APPLY_IF

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount() const;
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }


#ifdef LKR_EXPOSED_TABLE_LOCK
public:
#else // !LKR_EXPOSED_TABLE_LOCK
protected:
#endif // !LKR_EXPOSED_TABLE_LOCK

    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock();
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive();
    void        ConvertExclusiveToShared() const;


#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);
#endif // LKRHASH_KERNEL_MODE


#ifdef LKR_DEPRECATED_ITERATORS

public:

    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug. Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    };

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

private:
    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT:_IsValidIterator(%p)\n"), &riter);
        bool fValid = (riter.m_pht == this);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= riter.m_ist
                              &&  riter.m_ist < (int) m_cSubTables);
        IRTLASSERT(fValid);
        IRTLASSERT(_SubTableIndex(riter.m_subiter.m_plht) == riter.m_ist);
        fValid = fValid  &&  riter.IsValid();
        IRTLASSERT(fValid);
        return fValid;
    }


public:
    Iterator
    Begin();

    Iterator
    End() const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::End\n"));
        return Iterator();
    }

    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    bool
    Erase(
        /* in,out */ Iterator& riter);

    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRHashTable



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions (ExtractKey, CalcKeyHash, CompareKeys, AddRefRecord). It's
//   needed so that the method wrappers can downcast to the typesafe
//   implementations that you provide.
// * _Record is the type of the record. C{Linear}HashTable will store
//   >pointers< to _Record; i.e., stores _Records by reference, not by value.
// * _Key is the type of the key. _Key is used directly---it is not
//   assumed to be a pointer type. _Key can be an integer or a pointer.
//   C{Linear}HashTable assumes that the key is stored in the associated
//   record. See the comments at the declaration of LKR_PFnExtractKey
//   for more details.
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// Some associative containers allow you to store key-value (aka
// name-value) pairs. LKRhash doesn't allow you to do this directly, but
// it's straightforward to build a simple wrapper class (or to use
// std::pair<key,value>).
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
// If you expect to be using the table a lot on multiprocessor machines,
// you should use the default of CLKRHashTable, as it will scale better.
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//
// The _Derived class should look something like this:
//   class CDerived : public CTypedHashTable<CDerived, RecordType, KeyType>
//   {
//   public:
//      CDerived()
//          : CTypedHashTable<CDerived, RecordType, KeyType>("DerivedTable")
//      { /* other ctor actions, if needed */ }
//      static KeyType ExtractKey(const RecordType* pTest);
//      static DWORD   CalcKeyHash(const KeyType Key);
//      static int     CompareKeys(const KeyType Key1, const KeyType Key2);
//      static LONG    AddRefRecord(RecordType* pRecord,LK_ADDREF_REASON lkar);
//      // You probably want to declare the copy ctor and operator=
//      // as private, so that the compiler won't synthesize them.
//      // You don't need to provide a dtor, unless you have custom
//      // member data to clean up.
//
//      // Optional: other functions
//   };
// 
//--------------------------------------------------------------------

template < class _Derived, class _Record, class _Key,
           bool  _fDoRefCounting=false,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    enum { REF_COUNTED = _fDoRefCounting };
    typedef _BaseHashTable  BaseHashTable;

    typedef CTypedHashTable<_Derived, _Record, _Key,
                            _fDoRefCounting, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;

#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS


private:
    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);

        // I would prefer to use reinterpret_cast here and in _CalcKeyHash
        // and _CompareKeys, but the stupid Win64 compiler thinks it knows
        // better than I do.
        const _Key      key   = _Derived::ExtractKey(pRec);

//      const void*     pvKey = reinterpret_cast<const void*>(key);
//      const DWORD_PTR pnKey = reinterpret_cast<const DWORD_PTR>(pvKey);
        const DWORD_PTR pnKey = (DWORD_PTR) key;

        return pnKey;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey1)
    {
        const void*     pvKey1  = reinterpret_cast<const void*>(pnKey1);
        const DWORD_PTR pnKey1a = reinterpret_cast<const DWORD_PTR>(pvKey1);
//      const _Key      key1    = reinterpret_cast<const _Key>(pnKey1a);
        const _Key      key1    = (const _Key) pnKey1a;

        return _Derived::CalcKeyHash(key1);
    }

    static int WINAPI
    _CompareKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        const void*     pvKey1  = reinterpret_cast<const void*>(pnKey1);
        const DWORD_PTR pnKey1a = reinterpret_cast<const DWORD_PTR>(pvKey1);
//      const _Key      key1    = reinterpret_cast<const _Key>(pnKey1a);
        const _Key      key1    = (const _Key) pnKey1a;

        const void*     pvKey2  = reinterpret_cast<const void*>(pnKey2);
        const DWORD_PTR pnKey2a = reinterpret_cast<const DWORD_PTR>(pvKey2);
//      const _Key      key2    = reinterpret_cast<const _Key>(pnKey2a);
        const _Key      key2    = (const _Key) pnKey2a;

        return _Derived::CompareKeys(key1, key2);
    }

    static LONG WINAPI
    _AddRefRecord(void* pvRecord, LK_ADDREF_REASON lkar)
    {
        _Record* pRec = static_cast<_Record*>(pvRecord);
        return _Derived::AddRefRecord(pRec, lkar);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.
public:
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*. You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table. Also, you need to
    // exercise care that you don't modify the key of the record.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);

protected:
    class CState
    {
    protected:
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _fDoRefCounting, _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

    public:
        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec   = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec   = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF


protected:
    ~CTypedHashTable()
    {
        IRTLTRACE1("~CTypedHashTable(%p)\n", this);
    }

    CTypedHashTable(const HashTable&);
    HashTable& operator=(const HashTable&);

private:
    template <bool> class CRefCount;

    // Dummy, no-op specialization
    template <> class CRefCount<false>
    {
    public:
        LONG Increment()    { return 1; }
        LONG Decrement()    { return 0; }
    };

    // Real, threadsafe specialization
    template <> class CRefCount<true>
    {
    public:
        CRefCount<true>() : m_cRefs(1) {} 
        ~CRefCount<true>()  { IRTLASSERT(0 == m_cRefs); }
        LONG Increment()    { return ::InterlockedIncrement(&m_cRefs); }
        LONG Decrement()    { return ::InterlockedDecrement(&m_cRefs); }
    private:
        LONG m_cRefs;
    };


    mutable CRefCount<_fDoRefCounting>  m_rc;

    LONG
    _AddRef() const
    {
        return m_rc.Increment();
    }

    LONG
    _Release() const
    {
        const LONG cRefs = m_rc.Decrement();

        if (0 == cRefs)
        {
            _Derived* pThis = static_cast<_Derived*>(
                                        const_cast<HashTable*>(this));
            delete pThis;
        }

        return cRefs;
    }

    template <bool> class CAutoRefCountImpl;

    typedef CAutoRefCountImpl<_fDoRefCounting>  CAutoRefCount;
    friend  typename CAutoRefCountImpl<_fDoRefCounting>;
    // friend  typename CAutoRefCount;

    // no-op specialization
    template <> class CAutoRefCountImpl<false>
    {
    public:
        CAutoRefCountImpl<false>(const HashTable* const) {}
    };

    // threadsafe specialization
    template <> class CAutoRefCountImpl<true>
    {
    private:
        const HashTable* const m_pCont;

        // At /W4, compiler complains that it can't generate operator=
        CAutoRefCountImpl<true>& operator=(const CAutoRefCountImpl<true>&);

    public:
        CAutoRefCountImpl<true>(
            const HashTable* const pCont)
            : m_pCont(pCont)
        {
            m_pCont->_AddRef();
        }

        ~CAutoRefCountImpl<true>()
        {
            m_pCont->_Release();
        }
    };

    // Now at the top of an operation, we place a statement like this:
    //      CAutoRefCount arc(this);
    //
    // If we're using CAutoRefCountImpl<false>, the compiler optimizes it away.
    //
    // If we're using CAutoRefCountImpl<true>, we increment m_rc at this
    // point. At the end of the function, the destructor calls _Release(),
    // which will `delete this' if the last reference was released.


public:
    CTypedHashTable(
        LPCSTR   pszClassName,                // Identifies table for debugging
        unsigned maxload=LK_DFLT_MAXLOAD,     // Upperbound on avg chain len
        DWORD    initsize=LK_DFLT_INITSIZE,   // Initial size of table: S/M/L
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool     fMultiKeys=false,            // Allow multiple identical keys?
        bool     fUseLocks=true               // Must use locks
#ifdef LKRHASH_KERNEL_MODE
      , bool     fNonPagedAllocs=true         // use paged or NP pool in kernel
#endif
        )
        : _BaseHashTable(pszClassName, _ExtractKey, _CalcKeyHash, _CompareKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys, fUseLocks
#ifdef LKRHASH_KERNEL_MODE
                         , fNonPagedAllocs
#endif
                         )
    {
        // Ensure that _Key is no bigger than a pointer. Because we
        // support both numeric and pointer keys, the various casts
        // in the member functions unfortunately silently truncate if
        // _Key is an unacceptable numeric type, such as __int64 on x86.
        STATIC_ASSERT(sizeof(_Key) <= sizeof(DWORD_PTR));
    }

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    {
        CAutoRefCount arc(this);

        return _BaseHashTable::InsertRecord(pRec, fOverwrite);
    }

    LK_RETCODE   DeleteKey(const _Key key, _Record** ppRec=NULL,
                           bool fDeleteAllSame=false)
    {
        CAutoRefCount arc(this);

//      const void*   pvKey  = reinterpret_cast<const void*>(key);
//      DWORD_PTR     pnKey  = reinterpret_cast<DWORD_PTR>(pvKey);
        DWORD_PTR     pnKey  = (DWORD_PTR) key;
        const void**  ppvRec = (const void**) ppRec;

        return _BaseHashTable::DeleteKey(pnKey, ppvRec, fDeleteAllSame);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    {
        CAutoRefCount arc(this);

        return _BaseHashTable::DeleteRecord(pRec);
    }

    // Note: returns a _Record**, not a const Record**. Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;

        *ppRec = NULL;

        CAutoRefCount arc(this);
        const void* pvRec = NULL;

//      const void* pvKey = reinterpret_cast<const void*>(key);
//      DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        DWORD_PTR pnKey = (DWORD_PTR) key;

        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);

        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));

        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    {
        CAutoRefCount arc(this);

        return _BaseHashTable::FindRecord(pRec);
    }

    void         Destroy()
    {
        _Release();
    }

    LK_RETCODE   FindKeyMultipleRecords(
                        const _Key key,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr=NULL
                        ) const
    {
        CAutoRefCount arc(this);
//      const void*   pvKey = reinterpret_cast<const void*>(key);
//      DWORD_PTR     pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        DWORD_PTR     pnKey = (DWORD_PTR) key;

        return _BaseHashTable::FindKeyMultipleRecords(pnKey, pcRecords, pplmr);
    }

    LK_RETCODE   DeleteKeyMultipleRecords(
                        const _Key key,
                        size_t* pcRecords,
                        LKR_MULTIPLE_RECORDS** pplmr=NULL)
    {
        CAutoRefCount arc(this);
//      const void*   pvKey = reinterpret_cast<const void*>(key);
//      DWORD_PTR     pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        DWORD_PTR     pnKey = (DWORD_PTR) key;

        return _BaseHashTable::DeleteKeyMultipleRecords(pnKey, pcRecords,
                                                        pplmr);
    }

    static LK_RETCODE FreeMultipleRecords(LKR_MULTIPLE_RECORDS* plmr)
    {
        return _BaseHashTable::FreeMultipleRecords(LKR_MULTIPLE_RECORDS* plmr)
    }

    // Other C{Linear}HashTable methods can be exposed without change

    // CODEWORK: refcount iterators


#ifdef LKR_APPLY_IF

public:

    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CAutoRefCount arc(this);
        CState        state(NULL, pfnAction, pvState);

        return _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CAutoRefCount arc(this);
        CState        state(pfnPredicate, pfnAction, pvState);

        return _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CAutoRefCount arc(this);
        CState        state(pfnPredicate, NULL, pvState);

        return _BaseHashTable::DeleteIf(_Pred, &state);
    }
#endif // LKR_APPLY_IF



#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

    // TODO: const_iterator

public:

    class iterator
    {
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _fDoRefCounting, _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

    protected:
        typename _BaseHashTable::Iterator            m_iter;

        iterator(
            const typename _BaseHashTable::Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        pointer   operator->() const
        {
            return (reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record())));
        }

        reference operator*() const
        {
            return * (operator->());
        }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return iterator(_BaseHashTable::Begin());
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end() const
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return iterator(_BaseHashTable::End());
    }

    template <class _InputIterator>
    CTypedHashTable(
        _InputIterator f,                     // first element in range
        _InputIterator l,                     // one-beyond-last element
        LPCSTR   pszClassName,                // Identifies table for debugging
        unsigned maxload=LK_DFLT_MAXLOAD,     // Upperbound on avg chain len
        DWORD    initsize=LK_DFLT_INITSIZE,   // Initial size of table: S/M/L
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool     fMultiKeys=false,            // Allow multiple identical keys?
        bool     fUseLocks=true               // Must use locks
#ifdef LKRHASH_KERNEL_MODE
      , bool     fNonPagedAllocs=true         // use paged or NP pool in kernel
#endif
        )
        : _BaseHashTable(pszClassName, _ExtractKey, _CalcKeyHash, _CompareKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys, fUseLocks
#ifdef LKRHASH_KERNEL_MODE
                          , fNonPagedAllocs
#endif
                         )
    {
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return _BaseHashTable::Insert(pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return _BaseHashTable::Erase(riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return _BaseHashTable::Erase(riterFirst.m_iter, riterLast.m_iter);
    }

    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::Find(pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::EqualRange(pnKey, riterFirst.m_iter,
                                          riterLast.m_iter);
    }

    // The iterator functions for an STL hash_(|multi)_(set|map)
    //
    // Value type of a Pair-Associative Container is
    //     pair<const key_type, mapped_type>
    //
    // pair<iterator,bool> insert(const value_type& x);
    //
    // void erase(iterator pos);
    // void erase(iterator f, iterator l);
    //
    // iterator find(const key_type& k) [const];
    // const_iterator find(const key_type& k) const;
    //
    // pair<iterator,iterator> equal_range(const key_type& k) [const];
    // pair<const_iterator,const_iterator> equal_range(const key_type& k) const


#endif // LKR_STL_ITERATORS
}; // class CTypedHashTable


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\lkr-hash.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-hash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and
       multiprocessor-friendly hash table
       Public API

   Authors:
       Paul (Per-Ake) Larson, PALarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

--*/


#ifndef __LKR_HASH_H__
#define __LKR_HASH_H__


/* Enable STL-style iterators */
#ifndef LKR_NO_STL_ITERATORS
# define LKR_STL_ITERATORS 1
#endif /* !LKR_NO_STL_ITERATORS */

/* Enable call-back, table visitor routines */
#ifndef LKR_NO_APPLY_IF
# define LKR_APPLY_IF
#endif /* !LKR_NO_APPLY_IF */

/* Expose the table's ReadLock and WriteLock routines */
#ifndef LKR_NO_EXPOSED_TABLE_LOCK
# define LKR_EXPOSED_TABLE_LOCK
#endif /* !LKR_NO_EXPOSED_TABLE_LOCK */


#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif /* !__IRTLMISC_H__ */



#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


typedef struct LkrHashTable* PLkrHashTable;


/*--------------------------------------------------------------------
 * Possible return codes from LKR_functions and TypedLkrHashTable
 */
enum LK_RETCODE {
    /* severe errors < 0 */
    LK_UNUSABLE = -99,  /* Table corrupted: all bets are off */
    LK_ALLOC_FAIL,      /* Ran out of memory */
    LK_BAD_ITERATOR,    /* Invalid iterator; e.g., points to another table */
    LK_BAD_RECORD,      /* Invalid record; e.g., NULL for LKR_InsertRecord */
    LK_BAD_PARAMETERS,  /* Invalid parameters; e.g., NULL fnptrs to ctor */
    LK_NOT_INITIALIZED, /* LKR_Initialize was not called */
    LK_BAD_TABLE,       /* Called with invalid PLkrHashTable */
    LK_SEALED,          /* Modifying operation called on sealed table */

    LK_SUCCESS = 0,     /* Everything's okay */
    LK_KEY_EXISTS,      /* Key already present for
                            LKR_InsertRecord(no-overwrite) */
    LK_NO_SUCH_KEY,     /* Key not found in table */
    LK_NO_MORE_ELEMENTS,/* (Oldstyle, deprecated) Iterator exhausted */
};

#define LKR_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


/*--------------------------------------------------------------------
 * Size parameter to LKR_CreateTable
 */

enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE =  1,    /* < 200 elements */
    LK_MEDIUM_TABLESIZE = 2,    /* 200...10,000 elements */
    LK_LARGE_TABLESIZE =  3,    /* 10,000+ elements */
};


/*--------------------------------------------------------------------
 * Creation flag parameter to LKR_CreateTable
 */

enum {
    LK_CREATE_MULTIKEYS = 0x0001,   /* Allow multiple identical keys? */
    LK_CREATE_USE_LOCKS = 0x0002,   /* Use locks to protect data? */
    LK_CREATE_DEFAULT   = LK_CREATE_USE_LOCKS
};


/*--------------------------------------------------------------------
 * Initialization flag parameters to LKR_Initialize
 */

enum {
    LK_INIT_DEFAULT    =      0, /* 0 is an acceptable default */
    LK_INIT_DEBUG_SPEW = 0x1000, /* Enable debug output: debug version only */
};



/*--------------------------------------------------------------------
 * Reference Counting and Lifetime Management
 *
 * Increment the reference count of a record before returning it from
 * LKR_FindKey. It's necessary to do it in LKR_FindKey itself while the
 * bucket is still locked, rather than one of the wrappers, to avoid race
 * conditions. Similarly, the reference count is incremented in
 * LKR_InsertRecord and decremented in LKR_DeleteKey. Note: if an old
 * record is overwritten in LKR_InsertRecord, its reference count is
 * decremented. Similarly, for the other functions.
 *
 * It's up to you to decrement the reference count when you're finished
 * with it after retrieving it via LKR_FindKey (e.g., you could call
 * pht->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE)) and to determine the
 * semantics of what this means. The hashtable itself has no notion of
 * reference counts; this is merely to help with the lifetime management
 * of the record objects.
 */

/* These reason codes help in debugging refcount leaks */
enum LK_ADDREF_REASON {

/* negative reasons => decrement refcount => release ownership */
    LKAR_DESTRUCTOR          = -30, /* user calls ht.AddRefRecord in rec's */
                                        /* dtor to release final ref */
    LKAR_EXPLICIT_RELEASE    = -29, /* user calls ht.AddRefRecord to */
                                        /* explicitly release a record */
    LKAR_DELETE_KEY          = -28, /* DeleteKey() */
    LKAR_DELETE_RECORD       = -27, /* DeleteRecord() */
    LKAR_INSERT_RELEASE      = -26, /* InsertRecord overwrites prev record */
    LKAR_CLEAR               = -25, /* Clear() */
    LKAR_LKR_DTOR            = -24, /* internal hash table destructor */
    LKAR_APPLY_DELETE        = -23, /* Apply[If] LKP_(PERFORM|_DELETE) */
    LKAR_DELETEIF_DELETE     = -22, /* DeleteIf  LKP_(PERFORM|_DELETE) */
    LKAR_DELETE_MULTI_FREE   = -21, /* DeleteKeyMultipleRecords, freed */
    LKAR_ITER_RELEASE        = -20, /* ++iter releases previous record */
    LKAR_ITER_ASSIGN_RELEASE = -19, /* iter.operator= releases prev rec */
    LKAR_ITER_DTOR           = -18, /* ~iter */
    LKAR_ITER_ERASE          = -17, /* Erase(iter): iter releases record */
    LKAR_ITER_ERASE_TABLE    = -16, /* Erase(iter); table releases record */
    LKAR_ITER_CLOSE          = -15, /* CloseIterator (obsolete) */
    LKAR_FIND_MULTI_FREE     = -14, /* FindKeyMultipleRecords, freed */

    LKAR_MIN_NEGATIVE = LKAR_EXPLICIT_RELEASE,
    LKAR_MAX_NEGATIVE = LKAR_ITER_CLOSE,

    LKAR_MIN_DELETE_FROM_TABLE = LKAR_DELETE_KEY,
    LKAR_MAX_DELETE_FROM_TABLE = LKAR_DELETE_MULTI_FREE,

/* positive reasons => increment refcount => add an owner */
    LKAR_INSERT_RECORD       = +11, /* InsertRecord() */
    LKAR_FIND_KEY            = +12, /* FindKey() */
    LKAR_ITER_ACQUIRE        = +13, /* ++iter acquires next record */
    LKAR_ITER_COPY_CTOR      = +14, /* iter copy constructor acquires rec */
    LKAR_ITER_ASSIGN_ACQUIRE = +15, /* iter.operator= acquires new rec */
    LKAR_ITER_INSERT         = +16, /* Insert(iter) */
    LKAR_ITER_FIND           = +17, /* Find(iter) */
    LKAR_CONSTRUCTOR         = +18, /* user calls ht.AddRefRecord to */
                                        /* construct initial ref for a rec */
    LKAR_EXPLICIT_ACQUIRE    = +19, /* user calls ht.AddRefRecord to */
                                        /* explicitly acquire a ref to a rec */

    LKAR_MIN_POSITIVE = LKAR_INSERT_RECORD,
    LKAR_MAX_POSITIVE = LKAR_CONSTRUCTOR,
};


/* Convert an LK_ADDREF_REASON to a string representation.
 * Useful for debugging.
 */
IRTL_DLLEXP
const char*
LKR_AddRefReasonAsString(
    LK_ADDREF_REASON lkar);



/*--------------------------------------------------------------------
 * A collection of records, with identical keys, as returned by
 * LKR_FindKeyMultipleRecords and LKR_DeleteKeyMultipleRecords (qv).
 * It must be destroyed by LKR_FreeMultipleRecords.
 */

typedef struct _LKR_MULTIPLE_RECORDS
{
    PVOID            m_Table;           /* reserved */
    PVOID            m_SubTable;        /* reserved */
    LK_ADDREF_REASON m_lkarRelease;     /* reserved */
    size_t           m_cRecords;        /* num records in array m_apvRecords */
    PVOID            m_apvRecords[1];   /* variable size,
                                           bounded by m_cRecords */
} LKR_MULTIPLE_RECORDS;


/*--------------------------------------------------------------------
 * Parameter to Apply and ApplyIf, and iterator constructors.
 */

enum LK_LOCKTYPE {
    LKL_NOLOCK = 1,         /* Don't lock the table */
    LKL_READLOCK = 2,       /* Lock the table for reading (for constness) */
    LKL_WRITELOCK = 3,      /* Lock the table for writing */
};




/*--------------------------------------------------------------------
 * Callback functions needed by table:
 *     ExtractKey, CalcKeyHash, CompareKeys, AddRefRecord
 * Internally, records are handled as `const void*' and
 * keys are handled as `const DWORD_PTR'. The latter allows for
 * keys to be numbers as well as pointers (polymorphism).
 */


/* Use types defined in recent versions of the Platform SDK in <basetsd.h>.
 */
#ifndef _W64
typedef DWORD DWORD_PTR;    /* integral type big enough to hold a pointer */
                                /* or a 32-bit integer*/
#endif


/* Given a record, return its key. Assumes that the key is embedded in
 * the record, or at least somehow derivable from the record. For
 * completely unrelated keys & values, a wrapper class should use
 * something like STL's pair<key,value> template to aggregate them
 * into a record.
 */
typedef
const DWORD_PTR
(WINAPI *LKR_PFnExtractKey)  (
    const void* pvRecord);


/* Given a key, return its hash signature. The hashing functions in
 * hashfn.h (or something that builds upon them) are suggested.
 */
typedef
DWORD
(WINAPI *LKR_PFnCalcKeyHash) (
    const DWORD_PTR pnKey);


/* Compare two keys; e.g., _stricmp, memcmp
 * Return value: <0 => key1 < key2,  ==0 => key1 == key2,  >0 => key1 > key2
 *
 * If this is not a multikeys hashtable, it's sufficient to return
 * zero if the keys are identical and a non-zero value otherwise.
 * For a multikeys table (multiple, identical keys), the keys needed to be
 * sorted, so the return value's sign must be correct.
 *
 * Note: CompareKeys is called only when the two keys have identical
 * hash signatures.
 */
typedef
int
(WINAPI *LKR_PFnCompareKeys) (
    const DWORD_PTR pnKey1,
    const DWORD_PTR pnKey2);


/* Adjust the reference count of a record. See the earlier discussion of
 * reference counting and lifetime management. Returns the new reference
 * count, which should always be non-negative. Do not rely on this value,
 * except for debugging purposes, with one exception: If the new reference
 * count is zero, the record is no longer in the hashtable.
 */
typedef
LONG
(WINAPI *LKR_PFnAddRefRecord)(
    void*            pvRecord,
    LK_ADDREF_REASON lkar);



#ifdef LKR_APPLY_IF

/*--------------------------------------------------------------------
 * Apply, ApplyIf, and DeleteIf provide one way to visit (enumerate) all
 * records in a table.
 */

/*--------------------------------------------------------------------
 * Return codes from PFnRecordPred.
 */

enum LK_PREDICATE {
    LKP_ABORT = 1,           /* Stop walking the table immediately */
    LKP_NO_ACTION = 2,       /* No action, just keep walking */
    LKP_PERFORM = 3,         /* Perform action and continue walking */
    LKP_PERFORM_STOP = 4,    /* Perform action, then stop */
    LKP_DELETE = 5,          /* Delete record and keep walking */
    LKP_DELETE_STOP = 6,     /* Delete record, then stop */
};


/*--------------------------------------------------------------------
 * Return codes from PFnRecordAction.
 */

enum LK_ACTION {
    LKA_ABORT = 1,          /* Stop walking the table immediately */
    LKA_FAILED = 2,         /* Action failed; continue walking the table */
    LKA_SUCCEEDED = 3,      /* Action succeeded; continue walking the table */
};


/* LKR_ApplyIf() and LKR_DeleteIf(): Does the record match the predicate?
 */
typedef
LK_PREDICATE
(WINAPI *LKR_PFnRecordPred) (
    const void* pvRecord,
    void* pvState);

/* LKR_Apply() et al: Perform action on record.
 */
typedef
LK_ACTION
(WINAPI *LKR_PFnRecordAction)(
    const void* pvRecord,
    void* pvState);

#endif /* LKR_APPLY_IF */



/* Initialize the global variables needed by other LKR routines.
 */
IRTL_DLLEXP
int
LKR_Initialize(
    DWORD dwInitFlags);

/* Clean up the global variables needed by other LKR routines.
 */
IRTL_DLLEXP
void
LKR_Terminate();

/* Create a new LkrHashTable
 * Returns pointer to new table if successful. NULL, otherwise.
 * The table must be destroyed with LKR_DeleteTable.
 */
IRTL_DLLEXP
PLkrHashTable
LKR_CreateTable(
    LPCSTR              pszClassName,   /* Identify the table for debugging */
    LKR_PFnExtractKey   pfnExtractKey,  /* Extract key from record */
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, /* Calculate hash signature of key */
    LKR_PFnCompareKeys  pfnCompareKeys, /* Compare two keys */
    LKR_PFnAddRefRecord pfnAddRefRecord,/* AddRef in LKR_FindKey, etc */
    LK_TABLESIZE        nTableSize,     /* Small/Med/Large number of elements*/
    DWORD               fCreateFlags    /* Mixture of LK_CREATE_* flags. */
    );

/* Destroy an LkrHashTable created by LKR_CreateTable.
 */
IRTL_DLLEXP
void
LKR_DeleteTable(
    PLkrHashTable plkr);

/* Insert a new record into hash table.
 * Returns LKR_SUCCESS if all OK, LKR_KEY_EXISTS if same key already
 * exists (unless fOverwrite), LKR_ALLOC_FAIL if out of space,
 * or LKR_BAD_RECORD for a bad record.
 * If fOverwrite is set and a record with this key is already present,
 * it will be overwritten. If there are multiple records with this key,
 * only the first will be overwritten.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_InsertRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord,
    BOOL            fOverwrite);

/* Delete record with the given key from the table. Does not actually delete
 * record from memory, just calls AddRefRecord(LKAR_DELETE_KEY);
 * Returns LKR_SUCCESS if all OK, or LKR_NO_SUCH_KEY if not found
 * If ppvRecord is non-NULL, the record is returned in ppvRecord after
 * removing it from the table, but AddRefRecord(LKAR_DELETE_KEY) is not called.
 * If fDeleteAllSame is set, all records that match pnKey will be deleted
 * from the table; otherwise, only the first matching record is deleted.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_DeleteKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    const void**    ppvRecord,
    BOOL            fDeleteAllSame);

/* Delete a record from the table, if present.
 * Returns LKR_SUCCESS if all OK, or LKR_NO_SUCH_KEY if not found
 */
IRTL_DLLEXP
LK_RETCODE
LKR_DeleteRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord);

/* Find record with given key.
 * Returns:  LKR_SUCCESS, if record found (record is returned in *ppvRecord)
 *           LKR_NO_SUCH_KEY, if no record with given key value was found
 *           LKR_BAD_RECORD, if ppvRecord is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 * Note: the record is AddRef'd. You must decrement the reference
 * count when you are finished with the record (if you're implementing
 * refcounting semantics).
 */
IRTL_DLLEXP
LK_RETCODE
LKR_FindKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    const void**    ppvRecord);

/* Sees if the record is contained in the table
 * Returns:  LKR_SUCCESS, if record found
 *           LKR_NO_SUCH_KEY, if record is not in the table
 *           LKR_BAD_RECORD, if pvRecord is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 * Note: the record is *not* AddRef'd. By definition, the caller
 * already has a reference to it.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_FindRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord);

/* Find all records with given key. If table was not created with
 * LK_CREATE_MULTIKEYS, there will be at most one such record.
 *
 * Returns:  LKR_SUCCESS, if record(s) found (number of record is returned
 *              in *pcRecords)
 *           LKR_NO_SUCH_KEY, if no record with given key value was found
 *           LKR_BAD_PARAMETERS, if pcRecords is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 *
 * If pplmr is not NULL, a (*pcRecords)-element array of records is returned
 * in *pplmr. These records are AddRef(LKAR_FIND_KEY)'d. The pplmr struct
 * must be destroyed with LKR_FreeMultipleRecords, which will take
 * care of releasing the references with AddRef(LKAR_FIND_MULTI_FREE).
 *
 * If pplmr is NULL, *pcRecords contains the number of matching records. 
 * These records are not AddRef'd.
 *
 * pcRecords must not be NULL.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_FindKeyMultipleRecords(
    PLkrHashTable           plkr,
    const DWORD_PTR         pnKey,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr);

/* Delete all record(s) with the given key from the table. If table was not
 * created with LK_CREATE_MULTIKEYS, there will be at most one such record.
 * Does not actually delete record(s) from memory, just removes them
 * from the table.
 *
 * Returns:  LKR_SUCCESS, if record(s) found (number of record is returned
 *              in *pcRecords)
 *           LKR_NO_SUCH_KEY, if no record with given key value was found
 *           LKR_BAD_PARAMETERS, if pcRecords is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 *
 * If pplmr is not NULL, a (*pcRecords)-element array of records is returned
 * in *pplmr. These records are not AddRef'd, but they have been removed from.
 * the table. The pplmr struct must be destroyed with LKR_FreeMultipleRecords,
 * which will take care of releasing the final reference on each record
 * with AddRef(LKAR_DELETE_MULTI_FREE).
 *
 * If pplmr is NULL, *pcRecords contains the number of matching records. 
 * These records were AddRef(LKAR_DELETE_KEY)'d when they were removed
 * from the table.
 *
 * pcRecords must not be NULL.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_DeleteKeyMultipleRecords(
    PLkrHashTable           plkr,
    const DWORD_PTR         pnKey,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr);

/* Destroys an array created by LKR_FindKeyMultipleRecords or
 * LKR_DeleteKeyMultipleRecords. Releases a reference on each record,
 * using either LKAR_FIND_MULTI_FREE or LKAR_DELETE_MULTI_FREE.
 * Returns:  LKR_SUCCESS
 *           LKR_BAD_PARAMETERS, if ppvRecords is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 */
IRTL_DLLEXP
LK_RETCODE
LKR_FreeMultipleRecords(
    LKR_MULTIPLE_RECORDS* plmr);


#ifdef LKR_APPLY_IF

/* Walk the hash table, applying pfnAction to all records.
 * Locks one subtable after another with either a (possibly
 * shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction ever returns LKA_ABORT.
 * Returns the number of successful applications.
 */
IRTL_DLLEXP
DWORD
LKR_Apply(
    PLkrHashTable       plkr,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl);

/* Walk the hash table, applying pfnAction to any records that match
 * pfnPredicate. Locks one subtable after another with either
 * a (possibly shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction ever returns LKA_ABORT.
 * Returns the number of successful applications.
 */
IRTL_DLLEXP
DWORD
LKR_ApplyIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl);

/* Delete any records that match pfnPredicate.
 * Locks one subtable after another with a writelock.
 * Returns the number of deletions.
 *
 * Do *not* walk the hash table by hand with an iterator and call
 * LKR_DeleteKey. The iterator will end up pointing to garbage.
 */
IRTL_DLLEXP
DWORD
LKR_DeleteIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState);

#endif /* LKR_APPLY_IF */


/* Check table for consistency. Returns 0 if okay, or the number of
 * errors otherwise.
 */
IRTL_DLLEXP
int
LKR_CheckTable(
    PLkrHashTable plkr);

/* Remove all data from the table
 */
IRTL_DLLEXP
void
LKR_Clear(
    PLkrHashTable plkr);

/* Number of elements in the table
 */
IRTL_DLLEXP
DWORD
LKR_Size(
    PLkrHashTable plkr);

/* Maximum possible number of elements in the table
 */
IRTL_DLLEXP
DWORD
LKR_MaxSize(
    PLkrHashTable plkr);

/* Is the hash table usable?
 */
IRTL_DLLEXP
BOOL
LKR_IsUsable(
    PLkrHashTable plkr);
    
/* Is the hash table consistent and correct?
 */
IRTL_DLLEXP
BOOL
LKR_IsValid(
    PLkrHashTable plkr);

#ifdef LKR_EXPOSED_TABLE_LOCK

/* Lock the table (exclusively) for writing
 */
IRTL_DLLEXP
void
LKR_WriteLock(
    PLkrHashTable plkr);

/* Lock the table (possibly shared) for reading
 */
IRTL_DLLEXP
void
LKR_ReadLock(
    PLkrHashTable plkr);

/* Unlock the table for writing
 */
IRTL_DLLEXP
void
LKR_WriteUnlock(
    PLkrHashTable plkr);

/* Unlock the table for reading
 */
IRTL_DLLEXP
void
LKR_ReadUnlock(
    PLkrHashTable plkr);

/* Is the table already locked for writing?
 */
IRTL_DLLEXP
BOOL
LKR_IsWriteLocked(
    PLkrHashTable plkr);

/* Is the table already locked for reading?
 */
IRTL_DLLEXP
BOOL
LKR_IsReadLocked(
    PLkrHashTable plkr);

/* Is the table unlocked for writing?
 */
IRTL_DLLEXP
BOOL
LKR_IsWriteUnlocked(
    PLkrHashTable plkr);

/* Is the table unlocked for reading?
 */
IRTL_DLLEXP
BOOL
LKR_IsReadUnlocked(
    PLkrHashTable plkr);

/* Convert the read lock to a write lock. Note: another thread may acquire
 * exclusive access to the table before this routine returns.
 */
IRTL_DLLEXP
void
LKR_ConvertSharedToExclusive(
    PLkrHashTable plkr);

/* Convert the write lock to a read lock
 */
IRTL_DLLEXP
void
LKR_ConvertExclusiveToShared(
    PLkrHashTable plkr);

#endif /* LKR_EXPOSED_TABLE_LOCK */


#ifdef __cplusplus
} // extern "C"



// Only provide iterators in the C++ interface. It's too hard to
// provide the correct ownership semantics in a typesafe way in C,
// and C users can always use the LKR_ApplyIf family of callback
// enumerators if they really need to walk the hashtable.


#ifdef LKR_STL_ITERATORS

#pragma message("STL iterators")

// needed for std::forward_iterator_tag, etc
#include <iterator>

#include <irtldbg.h>

#define LKR_ITER_TRACE IRTLTRACE


class IRTL_DLLEXP LKR_Iterator
{
private:
    friend IRTL_DLLEXP LKR_Iterator LKR_Begin(PLkrHashTable plkr);
    friend IRTL_DLLEXP LKR_Iterator LKR_End(PLkrHashTable plkr);

    // private ctor
    LKR_Iterator(bool);

public:
    // default ctor
    LKR_Iterator();
    // copy ctor
    LKR_Iterator(const LKR_Iterator& rhs);
    // assignment operator
    LKR_Iterator& operator=(const LKR_Iterator& rhs);
    // dtor
    ~LKR_Iterator();

    // Increment the iterator to point to the next record, or to LKR_End()
    bool Increment();
    // Is the iterator valid?
    bool IsValid() const;

    // Returns the record that the iterator points to.
    // Must point to a valid record.
    const void* Record() const;
    // Returns the key of the record that the iterator points to.
    // Must point to a valid record.
    const DWORD_PTR Key() const;

    // Compare two iterators for equality
    bool operator==(const LKR_Iterator& rhs) const;
    // Compare two iterators for inequality
    bool operator!=(const LKR_Iterator& rhs) const;

    // pointer to implementation object
    void* pImpl;
}; // class LKR_Iterator


/* Return iterator pointing to first item in table
 */
IRTL_DLLEXP
LKR_Iterator
LKR_Begin(
    PLkrHashTable plkr);

/* Return a one-past-the-end iterator. Always empty.
 */
IRTL_DLLEXP
LKR_Iterator
LKR_End(
    PLkrHashTable plkr);

/* Insert a record
 * Returns `true' if successful; iterResult points to that record
 * Returns `false' otherwise; iterResult == End()
 */
IRTL_DLLEXP
bool
LKR_Insert(
              PLkrHashTable plkr,
    /* in */  const void*   pvRecord,
    /* out */ LKR_Iterator& riterResult,
    /* in */  bool          fOverwrite=false);

/* Erase the record pointed to by the iterator; adjust the iterator
 * to point to the next record. Returns `true' if successful.
 */
IRTL_DLLEXP
bool
LKR_Erase(
                 PLkrHashTable plkr,
    /* in,out */ LKR_Iterator& riter);

/* Erase the records in the range [riterFirst, riterLast).
 * Returns `true' if successful.
 */
IRTL_DLLEXP
bool
LKR_Erase(
           PLkrHashTable plkr,
    /*in*/ LKR_Iterator& riterFirst,
    /*in*/ LKR_Iterator& riterLast);
    
/* Find the (first) record that has its key == pnKey.
 * If successful, returns `true' and iterator points to (first) record.
 * If fails, returns `false' and iterator == End()
 */
IRTL_DLLEXP
bool
LKR_Find(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterResult);

/* Find the range of records that have their keys == pnKey.
 * If successful, returns `true', iterFirst points to first record,
 *     and iterLast points to one-beyond-the last such record.
 * If fails, returns `false' and both iterators == End().
 * Primarily useful when fMultiKeys == TRUE
 */
IRTL_DLLEXP
bool
LKR_EqualRange(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterFirst,     // inclusive
    /* out */ LKR_Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// A typesafe wrapper for PLkrHashTable
//
// * _Derived must derive from TypedLkrHashTable and provide certain member
//   functions. It's needed for various downcasting operations.
// * _Record is the type of the record. PLkrHashTable will store
//   pointers to _Record, as const void*.
// * _Key is the type of the key. _Key is used directly; i.e., it is
//   not assumed to be a pointer type. PLkrHashTable assumes that
//   the key is stored in the associated record. See the comments
//   at the declaration of LKR_PFnExtractKey for more details.
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//
// The _Derived class should look something like this:
//  class CDerived : public TypedLkrHashTable<CDerived, RecordType, KeyType>
//  {
//  public:
//      CDerived()
//          : TypedLkrHashTable<CDerived, RecordType, KeyType>("CDerived")
//      {/*other ctor actions*/}
//      static KeyType ExtractKey(const RecordType* pTest);
//      static DWORD   CalcKeyHash(const KeyType Key);
//      static int     CompareKeys(const KeyType Key1, const KeyType Key2);
//      static LONG    AddRefRecord(RecordType* pRecord,LK_ADDREF_REASON lkar);
//      // optional: other functions
//  };
// 
//--------------------------------------------------------------------

template <class _Derived, class _Record, class _Key>
class TypedLkrHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;

    typedef TypedLkrHashTable<_Derived, _Record, _Key> HashTable;

#ifdef LKR_APPLY_IF
    // LKR_ApplyIf() and LKR_DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*. You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

protected:
    PLkrHashTable m_plkr;

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        const _Key   key = static_cast<const _Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here and in _CalcKeyHash
        // and _CompareKeys, but the stupid Win64 compiler thinks it knows
        // better than I do.
        return (const DWORD_PTR) key;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        const _Key key = (const _Key) (DWORD_PTR) pnKey;
        return _Derived::CalcKeyHash(key);
    }

    static int WINAPI
    _CompareKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        const _Key key1 = (const _Key) (DWORD_PTR) pnKey1;
        const _Key key2 = (const _Key) (DWORD_PTR) pnKey2;
        return _Derived::CompareKeys(key1, key2);
    }

    static LONG WINAPI
    _AddRefRecord(void* pvRecord, LK_ADDREF_REASON lkar)
    {
        _Record* pRec = static_cast<_Record*>(pvRecord);
        return _Derived::AddRefRecord(pRec, lkar);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    TypedLkrHashTable(
        LPCSTR        pszName,          // An identifier for debugging
        LK_TABLESIZE  nTableSize,       // Small/Med/Large number of elements
        bool          fMultiKeys=false  // Allow multiple identical keys?
        )
        : m_plkr(NULL)
    {
        m_plkr = LKR_CreateTable(pszName, _ExtractKey, _CalcKeyHash,
                                 _CompareKeys, _AddRefRecord,
                                 nTableSize, fMultiKeys);
    }

    ~TypedLkrHashTable()
    {
        LKR_DeleteTable(m_plkr);
    }

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return LKR_InsertRecord(m_plkr, pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key, _Record** ppRec=NULL,
                           bool fDeleteAllSame=false)
    {
        const void*  pvKey  = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR    pnKey  = reinterpret_cast<DWORD_PTR>(pvKey);
        const void** ppvRec = (const void**) ppRec;
        return LKR_DeleteKey(m_plkr, pnKey, ppvRec, fDeleteAllSame);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return LKR_DeleteRecord(m_plkr, pRec);}

    // Note: returns a _Record**, not a const Record**. Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = LKR_FindKey(m_plkr, pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return LKR_FindRecord(m_plkr, pRec);}

    LK_RETCODE   FindKeyMultipleRecords(const _Key key,
                                        size_t* pcRecords,
                                        LKR_MULTIPLE_RECORDS** pplmr=NULL
                                        ) const
    {
        const void*   pvKey       = reinterpret_cast<const void*>(key);
        DWORD_PTR     pnKey       = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_FindKeyMultipleRecords(m_plkr, pnKey, pcRecords, pplmr);
    }
    
    LK_RETCODE   DeleteKeyMultipleRecords(const _Key key,
                                          size_t* pcRecords,
                                          LKR_MULTIPLE_RECORDS** pplmr=NULL)
    {
        const void*   pvKey       = reinterpret_cast<const void*>(key);
        DWORD_PTR     pnKey       = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_DeleteKeyMultipleRecords(m_plkr, pnKey, pcRecords, pplmr);
    }
    
    static LK_RETCODE FreeMultipleRecords(LKR_MULTIPLE_RECORDS* plmr)
    {
        return LKR_FreeMultipleRecords(plmr);
    }

#ifdef LKR_APPLY_IF
    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   LKR_Apply(m_plkr, _Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   LKR_ApplyIf(m_plkr, _Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   LKR_DeleteIf(m_plkr, _Pred, &state);
    }
#endif // LKR_APPLY_IF

    int          CheckTable() const
    { return LKR_CheckTable(m_plkr); }

    void          Clear()
    { return LKR_Clear(m_plkr); }

    DWORD         Size() const
    { return LKR_Size(m_plkr); }

    DWORD         MaxSize() const
    { return LKR_MaxSize(m_plkr); }

    BOOL          IsUsable() const
    { return LKR_IsUsable(m_plkr); }

    BOOL          IsValid() const
    { return LKR_IsValid(m_plkr); }

#ifdef LKR_EXPOSED_TABLE_LOCK
    void          WriteLock()
    { LKR_WriteLock(m_plkr); }

    void          ReadLock() const
    { LKR_ReadLock(m_plkr); }

    void          WriteUnlock()
    { LKR_WriteUnlock(m_plkr); }

    void          ReadUnlock() const
    { LKR_ReadUnlock(m_plkr); }

    BOOL          IsWriteLocked() const
    { return LKR_IsWriteLocked(m_plkr); }

    BOOL          IsReadLocked() const
    { return LKR_IsReadLocked(m_plkr); }

    BOOL          IsWriteUnlocked() const
    { return LKR_IsWriteUnlocked(m_plkr); }

    BOOL          IsReadUnlocked() const
    { return LKR_IsReadUnlocked(m_plkr); }

    void          ConvertSharedToExclusive() const
    { LKR_ConvertSharedToExclusive(m_plkr); }

    void          ConvertExclusiveToShared() const
    { LKR_ConvertExclusiveToShared(m_plkr); }
#endif // LKR_EXPOSED_TABLE_LOCK


#ifdef LKR_STL_ITERATORS
    friend class LKR_Iterator;

    // TODO: const_iterator

public:
    class iterator
    {
        friend class TypedLkrHashTable<_Derived, _Record, _Key>;

    protected:
        LKR_Iterator            m_iter;

        iterator(
            const LKR_Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        pointer   operator->() const
        {
            return (reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record())));
        }

        reference operator*() const
        {
            return * (operator->());
        }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return LKR_Begin(m_plkr);
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end() const
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return LKR_End(m_plkr);
    }

    template <class _InputIterator>
    TypedLkrHashTable(
        LPCSTR pszName,             // An identifier for debugging
        _InputIterator f,           // first element in range
        _InputIterator l,           // one-beyond-last element
        LK_TABLESIZE  nTableSize,   // Small/Med/Large number of elements
        bool   fMultiKeys=false     // Allow multiple identical keys?
        )
    {
        m_plkr = LKR_CreateTable(pszName, _ExtractKey, _CalcKeyHash,
                                 _CompareKeys, _AddRefRecord,
                                 nTableSize, fMultiKeys);
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return LKR_Insert(m_plkr, pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return LKR_Erase(m_plkr, riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return LKR_Erase(m_plkr, riterFirst.m_iter, riterLast.m_iter);
    }
    
    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_Find(m_plkr, pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_EqualRange(m_plkr, pnKey, riterFirst.m_iter,
                              riterLast.m_iter);
    }

#undef LKR_ITER_TRACE

#endif // LKR_STL_ITERATORS

}; // class TypedLkrHashTable

#endif /* __cplusplus */

#endif /* __LKR_HASH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\klkrhash.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       kLKRhash.h

   Abstract:
       Kernel-mode version of LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     24-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/


#ifndef __KLKRHASH_H__
#define __KLKRHASH_H__

#ifdef __LKRHASH_H__
# error Do not #include <LKRhash.h> before <kLKRhash.h>
#endif

#define LKRHASH_KERNEL_MODE

// BUGBUG: temporarily disable global list of LKRhash tables, to avoid
// dealing with issues of constructing/destructing global objects
#define LKR_NO_GLOBAL_LIST


// Fake up some Windows types for kernel mode
#define WINAPI          NTAPI   /* __stdcall */
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned long   DWORD;
typedef unsigned int    UINT;
typedef unsigned short  WORD;
typedef unsigned char   BYTE;
typedef BYTE*           PBYTE;
typedef BYTE*           LPBYTE;
typedef int             BOOL;
typedef const TCHAR*    LPCTSTR;



#ifdef __IRTLDBG_H__
# error Do not #include <IrtlDbg.h> before <kLKRhash.h>
#else // !__IRTLDBG_H__
# define IRTLDBG_KERNEL_MODE
# include <IrtlDbg.h>
#endif // !__IRTLDBG_H__



#define KLKRHASH_TAG  ((ULONG) 'hRKL')


#ifndef LKRHASH_KERNEL_NO_NEW
// Override operator new and operator delete

extern ULONG __Pool_Tag__;

// Prototype for function that sets the pool tag

inline
void
SetPoolTag(
    ULONG tag)
{
	__Pool_Tag__ = tag;
}

inline
void*
__cdecl
operator new(
    size_t nSize)
{
	return ((nSize > 0)
            ? ExAllocatePoolWithTag(NonPagedPool, nSize, __Pool_Tag__)
            : NULL);
}

inline
void*
__cdecl
operator new(
    size_t    nSize,
    POOL_TYPE iType)
{ 
	return ((nSize > 0)
            ? ExAllocatePoolWithTag(iType, nSize, __Pool_Tag__)
            : NULL);
}

inline
void*
__cdecl
operator new(
    size_t    nSize,
    POOL_TYPE iType,
    ULONG     tag)
{ 
	return ((nSize > 0)
            ? ExAllocatePoolWithTag(iType, nSize, tag)
            : NULL);
}

inline
void
__cdecl
operator delete(
    void* p)
{ 
	if (p != NULL)
        ExFreePool(p);
}

inline
void
__cdecl
operator delete[](
    void* p)
{ 
	if (p != NULL)
        ExFreePool(p);
}

#endif // !LKRHASH_KERNEL_NO_NEW



// Pool Allocators 

template <POOL_TYPE _pt>
class CPoolAllocator
{
private:
    SIZE_T      m_cb;
    const ULONG m_ulTag;

#ifdef IRTLDEBUG
    ULONG       m_cAllocs;
    ULONG       m_cFrees;
#endif // IRTLDEBUG

public:
    CPoolAllocator(
        SIZE_T cb,
        ULONG  ulTag)
        : m_cb(cb),
          m_ulTag(ulTag)
#ifdef IRTLDEBUG
        , m_cAllocs(0)
        , m_cFrees(0)
#endif // IRTLDEBUG
    {}

    ~CPoolAllocator()
    {
        IRTLASSERT(m_cAllocs == m_cFrees);
    }
    
    LPVOID Alloc()
    {
        LPVOID pvMem = ExAllocatePoolWithTag(_pt, m_cb, m_ulTag);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cAllocs);
#endif // IRTLDEBUG
        return pvMem;
    }

    BOOL   Free(LPVOID pvMem)
    {
        IRTLASSERT(pvMem != NULL);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cFrees);
#endif // IRTLDEBUG
        // return ExFreePoolWithTag(pvMem, m_ulTag);
        ExFreePool(pvMem);
        return TRUE;
    }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }
}; // class CPoolAllocator<_pt>


class CNonPagedHeap : public CPoolAllocator<NonPagedPool>
{
public:
    static const TCHAR*  ClassName()  {return _TEXT("CNonPagedHeap");}
}; // class CNonPagedHeap


class CPagedHeap : public CPoolAllocator<PagedPool>
{
public:
    static const TCHAR*  ClassName()  {return _TEXT("CPagedHeap");}
}; // class CPagedHeap



// Lookaside Lists

class CNonPagedLookasideList
{
private:
    PNPAGED_LOOKASIDE_LIST m_pnpla;
    const SIZE_T           m_cb;
    const ULONG            m_ulTag;

    enum {
        PNPAGED_LOOKASIDE_LIST_TAG = 'aLPn',
    };

#ifdef IRTLDEBUG
    ULONG                 m_cAllocs;
    ULONG                 m_cFrees;
    
    static PVOID
    AllocateFunction(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag
        )
    {
        IRTLASSERT( PoolType == NonPagedPool );
        // TODO: better bookkeeping
        return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    }

    static VOID
    FreeFunction(
        IN PVOID Buffer
        )
    {
        // TODO: better bookkeeping
        ExFreePool(Buffer);
    }
#endif // IRTLDEBUG

public:
    CNonPagedLookasideList(
        SIZE_T cb,
        ULONG  ulTag)
        : m_cb(cb),
          m_ulTag(ulTag)
#ifdef IRTLDEBUG
        , m_cAllocs(0)
        , m_cFrees(0)
#endif // IRTLDEBUG
    {
    
        m_pnpla = static_cast<PNPAGED_LOOKASIDE_LIST>(
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(NPAGED_LOOKASIDE_LIST),
                        PNPAGED_LOOKASIDE_LIST_TAG));

        if (m_pnpla != NULL)
        {
            ExInitializeNPagedLookasideList(
                m_pnpla,            // Lookaside
#ifdef IRTLDEBUG
                AllocateFunction,   // Allocate
                FreeFunction,       // Free
#else  // !IRTLDEBUG
                NULL,               // default Allocate
                NULL,               // default Free
#endif // !IRTLDEBUG
                0,                  // Flags
                m_cb,               // Size
                m_ulTag,            // Tag
                0                   // Depth
                );
        }
    }
    
    ~CNonPagedLookasideList()
    {
        IRTLASSERT(m_cAllocs == m_cFrees);

        if (m_pnpla != NULL)
        {
            ExDeleteNPagedLookasideList(m_pnpla);
            ExFreePool(m_pnpla);
        }
    }
    
    LPVOID Alloc()
    {
        LPVOID pvMem = ExAllocateFromNPagedLookasideList(m_pnpla);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cAllocs);
#endif // IRTLDEBUG
        return pvMem;
    }

    BOOL   Free(LPVOID pvMem)
    {
        IRTLASSERT(pvMem != NULL);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cFrees);
#endif // IRTLDEBUG
        ExFreeToNPagedLookasideList(m_pnpla, pvMem);
        return TRUE;
    }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*  ClassName()  {return _TEXT("CNonPagedLookasideList");}
}; // class CNonPagedLookasideList



class CPagedLookasideList
{
private:
    PPAGED_LOOKASIDE_LIST m_ppla;
    const SIZE_T          m_cb;
    const ULONG           m_ulTag;

    enum {
        PPAGED_LOOKASIDE_LIST_TAG = 'aLPp',
    };

#ifdef IRTLDEBUG
    ULONG                 m_cAllocs;
    ULONG                 m_cFrees;
    
    static PVOID
    AllocateFunction(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag
        )
    {
        IRTLASSERT( PoolType == PagedPool );
        // TODO: better bookkeeping
        return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    }

    static VOID
    FreeFunction(
        IN PVOID Buffer
        )
    {
        // TODO: better bookkeeping
        ExFreePool(Buffer);
    }
#endif // IRTLDEBUG

public:
    CPagedLookasideList(
        SIZE_T cb,
        ULONG  ulTag)
        : m_cb(cb),
          m_ulTag(ulTag)
#ifdef IRTLDEBUG
        , m_cAllocs(0)
        , m_cFrees(0)
#endif // IRTLDEBUG
    {
        m_ppla = static_cast<PPAGED_LOOKASIDE_LIST>(
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(PAGED_LOOKASIDE_LIST),
                        PPAGED_LOOKASIDE_LIST_TAG));

        if (m_ppla != NULL)
        {
            ExInitializePagedLookasideList(
                m_ppla,             // Lookaside
#ifdef IRTLDEBUG
                AllocateFunction,   // Allocate
                FreeFunction,       // Free
#else  // !IRTLDEBUG
                NULL,               // Allocate
                NULL,               // Free
#endif // !IRTLDEBUG
                0,                  // Flags
                m_cb,               // Size
                m_ulTag,            // Tag
                0                   // Depth
                );
        }
    }
    
    ~CPagedLookasideList()
    {
        IRTLASSERT(m_cAllocs == m_cFrees);

        if (m_ppla != NULL)
        {
            ExDeletePagedLookasideList(m_ppla);
            ExFreePool(m_ppla);
        }
    }
    
    LPVOID Alloc()
    {
        LPVOID pvMem = ExAllocateFromPagedLookasideList(m_ppla);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cAllocs);
#endif // IRTLDEBUG
        return pvMem;
    }

    BOOL   Free(LPVOID pvMem)
    {
        IRTLASSERT(pvMem != NULL);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cFrees);
#endif // IRTLDEBUG
        ExFreeToPagedLookasideList(m_ppla, pvMem);
        return TRUE;
    }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*   ClassName()  {return _TEXT("CPagedLookasideList");}
}; // class CPagedLookasideList



#if 0

# define LKRHASH_NONPAGEDHEAP
  typedef CNonPagedHeap CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CNonPagedHeap(sizeof(C), Tag)

#elif 0

# define LKRHASH_PAGEDHEAP
  typedef CPagedHeap CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CPagedHeap(sizeof(C), Tag)

#elif 1 // <----

# define LKRHASH_NONPAGEDLOOKASIDE
  typedef CNonPagedLookasideList CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CNonPagedLookasideList(sizeof(C), Tag)

#elif 0

# define LKRHASH_PAGEDLOOKASIDE
  typedef CPagedLookasideList CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CPagedLookasideList(sizeof(C), Tag)

#endif



// TODO: lookaside lists

#include <kLocks.h>

// #define LKR_TABLE_LOCK  CEResource
// #define LKR_BUCKET_LOCK CSpinLock
#define LKR_TABLE_LOCK  CReaderWriterLock3 
#define LKR_BUCKET_LOCK CSmallSpinLock
#define LSTENTRY_LOCK   LKR_BUCKET_LOCK
    
#include <LKRhash.h>

#endif // __KLKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\hashfn.h ===
/*++

   Copyright    (c)    1997-2002    Microsoft Corporation

   Module  Name :
       HashFn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__

#include <math.h>
#include <limits.h>

#ifndef __HASHFN_NO_NAMESPACE__
namespace HashFn {
#endif // !__HASHFN_NO_NAMESPACE__

#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// The __forceinline keyword is new to VC6
# define HASHFN_FORCEINLINE __forceinline
#else
# define HASHFN_FORCEINLINE inline
#endif

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

HASHFN_FORCEINLINE
DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


enum {
    // No number in 0..2^31-1 maps to this number after it has been
    // scrambled by HashFn::HashRandomizeBits
    HASH_INVALID_SIGNATURE = 31678523,

    // Given M = A % B, A and B unsigned 32-bit integers greater than zero,
    // there are no values of A or B which yield M = 2^32-1.  Why?  Because
    // M must be less than B. (For numbers scrambled by HashScramble)
    // HASH_INVALID_SIGNATURE = ULONG_MAX
};

// Faster scrambling function suggested by Eric Jacobsen

HASHFN_FORCEINLINE
DWORD
HashRandomizeBits(DWORD dw)
{
	const DWORD dwLo = ((dw * 1103515245 + 12345) >> 16);
	const DWORD dwHi = ((dw * 69069 + 1) & 0xffff0000);
	const DWORD dw2  = dwHi | dwLo;

    IRTLASSERT(dw2 != HASH_INVALID_SIGNATURE);

    return dw2;
}



#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY

HASHFN_FORCEINLINE
DWORD
HASH_MULTIPLY(
    DWORD dw)
{
    // 127 = 2^7 - 1 is prime
    return (dw << 7) - dw;
}

#else // !HASH_SHIFT_MULTIPLY

HASHFN_FORCEINLINE
DWORD
HASH_MULTIPLY(
    DWORD dw)
{
    // Small prime number used as a multiplier in the supplied hash functions
    const DWORD HASH_MULTIPLIER = 101;
    return dw * HASH_MULTIPLIER;
}

#endif // !HASH_SHIFT_MULTIPLY


// Fast, simple hash function that tends to give a good distribution.
// Apply HashRandomizeBits to the result if you're using this for something
// other than LKRhash.

HASHFN_FORCEINLINE
DWORD
HashString(
    const char*  psz,
    DWORD dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// --------------------------------------------------------
// Compute a hash value from an input string of any type, i.e.
// the input is just treated as a sequence of bytes.
// Based on a hash function originally proposed by J. Zobel.
// Author: Paul Larson, 1999, palarson@microsoft.com
// -------------------------------------------------------- 
HASHFN_FORCEINLINE
DWORD
HashString2( 
    const char* pszInputKey,        // ptr to input - any type is OK
    DWORD       dwHash = 314159269) // Initial seed for hash function
{
	// Initialize dwHash to a reasonably large constant so very
	// short keys won't get mapped to small values. Virtually any
	// large odd constant will do. 
    const unsigned char* upsz = (const unsigned char*) pszInputKey;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash ^= (dwHash << 11) + (dwHash << 5) + (dwHash >> 2) + *upsz;

    return (dwHash & 0x7FFFFFFF);
}



// Unicode version of above

HASHFN_FORCEINLINE
DWORD
HashString(
    const wchar_t* pwsz,
    DWORD   dwHash = 0)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashRandomizeBits to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

HASHFN_FORCEINLINE
DWORD
HashStringNoCase(
    const char*  psz,
    DWORD dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
    {
        dwHash = HASH_MULTIPLY(dwHash)  +  toupper(*upsz);
    }

    return dwHash;
}


// Unicode version of above

HASHFN_FORCEINLINE
DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD dwHash = 0)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
    {
#ifdef LKRHASH_KERNEL_MODE
        dwHash = HASH_MULTIPLY(dwHash)  +  RtlUpcaseUnicodeChar(*pwsz);
#else
        dwHash = HASH_MULTIPLY(dwHash)  +  towupper(*pwsz);
#endif
    }

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashRandomizeBits if using with something other than LKRhash.

HASHFN_FORCEINLINE
DWORD
HashBlob(
    const void*  pv,
    size_t       cb,
    DWORD dwHash = 0)
{
    const BYTE* pb = static_cast<const BYTE*>(pv);

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



// --------------------------------------------------------
// Compute a hash value from an input string of any type, i.e.
// the input is just treated as a sequence of bytes.
// Based on a hash function originally proposed by J. Zobel.
// Author: Paul Larson, 1999, palarson@microsoft.com
// -------------------------------------------------------- 
HASHFN_FORCEINLINE
DWORD
HashBlob2( 
    const void* pvInputKey,         // ptr to input - any type is OK
    size_t      cbKeyLen,           // length of input key in bytes
    DWORD       dwHash = 314159269) // Initial seed for hash function
{
	// Initialize dwHash to a reasonably large constant so very
	// short keys won't get mapped to small values. Virtually any
	// large odd constant will do. 

    const BYTE* pb         = static_cast<const BYTE*>(pvInputKey);
    const BYTE* pbSentinel = pb + cbKeyLen;

    for ( ;  pb < pbSentinel;  ++pb)
        dwHash ^= (dwHash << 11) + (dwHash << 5) + (dwHash >> 2) + *pb;

    return (dwHash & 0x7FFFFFFF);
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashRandomizeBits to result if using with something other than
// LKRhash.
//

HASHFN_FORCEINLINE
DWORD Hash(const char* psz)
{ return HashString(psz); }

HASHFN_FORCEINLINE
DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

HASHFN_FORCEINLINE
DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

HASHFN_FORCEINLINE
DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

HASHFN_FORCEINLINE
DWORD
Hash(
    const GUID* pguid,
    DWORD dwHash = 0)
{
    dwHash += * reinterpret_cast<const DWORD*>(pguid);
    return dwHash;
}

// Identity hash functions: scalar values map to themselves
HASHFN_FORCEINLINE
DWORD Hash(char c)
{ return c; }

HASHFN_FORCEINLINE
DWORD Hash(unsigned char uc)
{ return uc; }

HASHFN_FORCEINLINE
DWORD Hash(signed char sc)
{ return sc; }

HASHFN_FORCEINLINE
DWORD Hash(short sh)
{ return sh; }

HASHFN_FORCEINLINE
DWORD Hash(unsigned short ush)
{ return ush; }

HASHFN_FORCEINLINE
DWORD Hash(int i)
{ return i; }

HASHFN_FORCEINLINE
DWORD Hash(unsigned int u)
{ return u; }

HASHFN_FORCEINLINE
DWORD Hash(long l)
{ return l; }

HASHFN_FORCEINLINE
DWORD Hash(unsigned long ul)
{ return ul; }

HASHFN_FORCEINLINE
DWORD Hash(double dbl)
{
    if (dbl == 0.0)
        return 0;
    int nExponent;
    double dblMantissa = frexp(dbl, &nExponent);
    // 0.5 <= |mantissa| < 1.0
    return (DWORD) ((2.0 * fabs(dblMantissa)  -  1.0)  *  ULONG_MAX);
}

HASHFN_FORCEINLINE
DWORD Hash(float f)
{ return Hash((double) f); }

HASHFN_FORCEINLINE
DWORD Hash(unsigned __int64 ull)
{
    union {
        unsigned __int64 _ull;
        DWORD            dw[2];
    } u = {ull};
    return HASH_MULTIPLY(u.dw[0])  +  u.dw[1];
}

HASHFN_FORCEINLINE
DWORD Hash(__int64 ll)
{ return Hash((unsigned __int64) ll); }

#ifndef __HASHFN_NO_NAMESPACE__
}
#endif // !__HASHFN_NO_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\kernel\klkrhash.cpp ===
/*++

   Copyright    (c) 2000-2002    Microsoft Corporation

   Module  Name :
       kLKRhash.cpp

   Abstract:
       LKRhash.sys: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <kLKRhash.h>
#include "../src/LKRhash.cpp"
#include "../src/LKR-apply.cpp"
#include "../src/LKR-c-api.cpp"
#include "../src/LKR-old-iter.cpp"
#include "../src/LKR-stats.cpp"
#include "../src/LKR-stl-iter.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\locks.h ===
/*++

   Copyright    (c)    1997-2002    Microsoft Corporation

   Module  Name :
       Locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------


#ifndef LOCKS_KERNEL_MODE
# define LOCKS_ENTER_CRIT_REGION()   ((void) 0)
# define LOCKS_LEAVE_CRIT_REGION()   ((void) 0)
#else
# define LOCKS_ENTER_CRIT_REGION()   KeEnterCriticalRegion()
# define LOCKS_LEAVE_CRIT_REGION()   KeLeaveCriticalRegion()
#endif


#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// The __forceinline keyword is new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif


enum LOCK_LOCKTYPE {
    LOCK_FAKELOCK = 1,
    LOCK_SMALLSPINLOCK,
    LOCK_SPINLOCK,
    LOCK_CRITSEC,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
    LOCK_READERWRITERLOCK4,
    LOCK_KSPINLOCK,
    LOCK_FASTMUTEX,
    LOCK_ERESOURCE,
    LOCK_RTL_MRSW_LOCK,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;




//--------------------------------------------------------------------
// Spin count values.

enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


#ifndef LOCKS_KERNEL_MODE

// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \

#endif // !LOCKS_KERNEL_MODE



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
    LOCK_WAIT_SPIN,         // Spins until lock acquired. Never sleeps.
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}

    enum {
        LOCK_WRITELOCK_RECURSIVE = (LOCK_RECURSIVE == recursiontype),
    };
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    TCHAR    m_tszName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_tszName[0] = _TEXT('\0');
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    TCHAR           m_tszName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const TCHAR* Name() const       {return m_tszName;}                     \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(ptszName)        \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (ptszName == NULL)                           \
        m_tszName[0] = _TEXT('\0');                 \
    else                                            \
        _tcsncpy(m_tszName, ptszName, sizeof(m_tszName)/sizeof(TCHAR))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class IRTL_DLLEXP CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class IRTL_DLLEXP CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD)         {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

    enum {
        SL_UNOWNED = 0,
#ifdef LOCK_SMALL_SPIN_NO_THREAD_ID
        SL_LOCKED  = 1,
#endif // LOCK_SMALL_SPIN_NO_THREAD_ID
    };

    LOCK_INSTRUMENTATION_DECL();

    static LONG _CurrentThreadId();

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    // Attempt to acquire the lock
    bool _TryLock();

    // Release the lock
    void _Unlock();

public:

#ifndef LOCK_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(SL_UNOWNED)
    {}

#else // LOCK_INSTRUMENTATION

    CSmallSpinLock(
        const TCHAR* ptszName)
        : m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.
    // Blocks (if needed) until acquired.
    LOCK_FORCEINLINE void
    WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        if (! _TryLock())
            _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.
    // Blocks (if needed) until acquired.
    LOCK_FORCEINLINE void
    ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        if (! _TryLock())
            _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    LOCK_FORCEINLINE bool
    TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    LOCK_FORCEINLINE bool
    TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    LOCK_FORCEINLINE void
    WriteUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    LOCK_FORCEINLINE void
    ReadUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == SL_UNOWNED);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        UNREFERENCED_PARAMETER(wSpins);
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 24 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 24,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 8,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
        SL_UNOWNED      = 0,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 24 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit
    // into 24 bits would mean that more than 16 million threads were
    // currently active (actually 4 million as lowest two bits are always
    // zero on W2K).  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static DWORD _GetCurrentThreadId()
    {
#ifdef LOCKS_KERNEL_MODE
        return (DWORD) HandleToULong(::PsGetCurrentThreadId());
#else // !LOCKS_KERNEL_MODE
        return ::GetCurrentThreadId();
#endif // !LOCKS_KERNEL_MODE
    }

    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = _GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != SL_UNOWNED
                   && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    bool _TryLock();

    // Acquire the lock, recursively if need be
    void _Lock();

    // Release the lock
    void _Unlock();

    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        const LONG lTid = m_lTid;

        if (lTid == SL_UNOWNED)
            return false;
        
        bool fLocked = ((lTid ^ _GetCurrentThreadId()) << SL_OWNER_BITS) == 0;

        IRTLASSERT(!fLocked
                   || ((lTid & SL_OWNER_MASK) > 0
                       && (lTid & SL_THREAD_MASK) == _CurrentThreadId()));

        return fLocked;
    }

    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(SL_UNOWNED)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const TCHAR* ptszName)
        : m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    LOCK_FORCEINLINE void
    WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (! _TryLock())
            _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    LOCK_FORCEINLINE void
    ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (! _TryLock())
            _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    LOCK_FORCEINLINE bool
    ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    LOCK_FORCEINLINE bool
    TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    LOCK_FORCEINLINE bool
    TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    LOCK_FORCEINLINE void
    WriteUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    LOCK_FORCEINLINE void
    ReadUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    LOCK_FORCEINLINE void
    ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    bool SetSpinCount(WORD)             {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




#ifndef LOCKS_KERNEL_MODE

//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }

#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION

    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CCritSec");}
}; // CCritSec

#endif // !LOCKS_KERNEL_MODE



//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    bool _CmpExch(LONG lNew, LONG lCurrent);
    bool _TryWriteLock();
    bool _TryReadLock();

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const TCHAR* ptszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // IRTLDEBUG

    void WriteLock();
    void ReadLock();

    bool TryWriteLock();
    bool TryReadLock();
    
    void WriteUnlock();
    void ReadUnlock();

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive();
    void ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock");}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    bool _CmpExch(LONG lNew, LONG lCurrent);
    bool _TryWriteLock(LONG nIncr);
    bool _TryReadLock();

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // IRTLDEBUG

    LOCK_FORCEINLINE void
    WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    LOCK_FORCEINLINE void
    ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    LOCK_FORCEINLINE bool
    TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            return false;
        }
    }

    LOCK_FORCEINLINE bool
    TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            return false;
        }
    }

    void WriteUnlock();
    void ReadUnlock();

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {
        LONG lRW = m_lRW;
        return (((lRW & SL_STATE_MASK) != SL_EXCLUSIVE)
                &&  (lRW & SL_READER_MASK) >= SL_READER_INCR);
    }

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive();
    void ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock2");}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. ==0 => free;  >0 => readers;  ==0xFFFF => 1 writer
    //  HiWord is count of waiters + writers, N.
    //      If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise => N waiters, 0 writers.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
    // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_BITS =           16,
        SL_STATE_SHIFT =           0,
        SL_STATE_MASK =   ((1 << SL_STATE_BITS) - 1) << SL_STATE_SHIFT,

        SL_WAITING_BITS =         16,
        SL_WAITING_SHIFT = SL_STATE_BITS,
        SL_WAITING_MASK = ((1 << SL_WAITING_BITS) - 1) << SL_WAITING_SHIFT,
                            // waiting writers

        SL_READER_INCR =  1 << SL_STATE_SHIFT,
        SL_READER_MASK =  ((1 << (SL_STATE_BITS - 1)) - 1) << SL_STATE_SHIFT,
        SL_EXCLUSIVE =    SL_STATE_MASK,   // one writer
        SL_WRITER_INCR =  1 << SL_WAITING_SHIFT,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + SL_READER_INCR),
        SL_WRITERS_MASK = ~SL_READER_MASK, // == waiter | writer

    // m_lTid
        SL_UNOWNED      = 0,
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 24,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 8,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1)  << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    bool _CmpExchRW(LONG lNew, LONG lCurrent);
    LONG _SetTid(LONG lNewTid);
    bool _TryWriteLock(LONG nWriterIncr);
    bool _TryReadLock();
    bool _TryReadLockRecursive();

    static LONG _GetCurrentThreadId();
    static LONG _CurrentThreadId();
    

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(SL_UNOWNED)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE),
          m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    LOCK_FORCEINLINE void
    WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        if (! _TryWriteLock(SL_WRITER_INCR))
            _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    } 

    LOCK_FORCEINLINE void
    ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        if (! _TryReadLock())
            _ReadLockSpin(SPIN_READ);

        IRTLASSERT(IsReadLocked());
    } 

    // ReadOrWriteLock: If already locked, recursively acquires another lock
    // of the same kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    bool ReadOrWriteLock();

    LOCK_FORCEINLINE bool
    TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            IRTLASSERT(IsWriteLocked());
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            IRTLASSERT(!IsWriteLocked());
            return false;
        }
    }

    LOCK_FORCEINLINE bool
    TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            IRTLASSERT(IsReadLocked());
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            // Can't IRTLASSERT(!IsReadLocked()) because other threads
            // may have acquired a read lock by now
            return false;
        }
    }

    void WriteUnlock();
    void ReadUnlock();
    void ReadOrWriteUnlock(bool fIsReadLocked);

    // Does current thread hold a write lock?
    LOCK_FORCEINLINE bool
    IsWriteLocked() const
    {
        const LONG lTid = m_lTid;

        if (lTid == SL_UNOWNED)
            return false;
        
        bool fLocked = ((lTid ^ _GetCurrentThreadId()) << SL_OWNER_BITS) == 0;

        IRTLASSERT(!fLocked
                   || ((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE
                       && (lTid & SL_THREAD_MASK) == _CurrentThreadId()
                       && (lTid & SL_OWNER_MASK) > 0));
        return fLocked;
    }

    LOCK_FORCEINLINE bool
    IsReadLocked() const
    {
        LONG lRW = m_lRW;
        return (((lRW & SL_STATE_MASK) != SL_EXCLUSIVE)
                &&  (lRW & SL_READER_MASK) >= SL_READER_INCR);

    }

    bool
    IsWriteUnlocked() const
    { return !IsWriteLocked(); }

    bool
    IsReadUnlocked() const
    { return !IsReadLocked(); }

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void
    ConvertSharedToExclusive();

    // There is no such window when converting from a writelock to a readlock
    void
    ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool
    SetSpinCount(WORD)
    {return false;}

    WORD
    GetSpinCount() const
    {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*
    ClassName()
    {return _TEXT("CReaderWriterLock3");}

}; // CReaderWriterLock3




//--------------------------------------------------------------------
// CReaderWriterLock4 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock4 :
    public CLockBase<LOCK_READERWRITERLOCK4, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. ==0 => free;
    //                   > 0 => # readers;
    //                   < 0 => 1 writer + recursion count
    //  HiWord is count of waiters + writers, N.
    //      If LoWord < 0 => N-1 waiters, 1 writer;
    //      otherwise     => N waiters, 0 writers.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id

    enum {
    // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_BITS =           16,
        SL_STATE_SHIFT =           0,
        SL_STATE_MASK =   ((1 << SL_STATE_BITS) - 1) << SL_STATE_SHIFT,

        SL_WAITING_BITS =         16,
        SL_WAITING_SHIFT = SL_STATE_BITS,
        SL_WAITING_MASK = ((1 << SL_WAITING_BITS) - 1) << SL_WAITING_SHIFT,
                            // waiting writers

        SL_READER_INCR =  1 << SL_STATE_SHIFT,
        SL_WRITER_INCR =  - SL_READER_INCR,
        SL_READER_MASK =  ((1 << (SL_STATE_BITS - 1)) - 1) << SL_STATE_SHIFT,
        SL_EXCLUSIVE   =    SL_STATE_MASK,   // one writer, recursion == 1
        SL_WRITER_MIN  = SL_READER_MASK + SL_READER_INCR,

        SL_WAIT_WRITER_INCR =  1 << SL_WAITING_SHIFT,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WAIT_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + SL_READER_INCR),
        SL_WRITERS_MASK = ~SL_READER_MASK, // == waiter | writer

    // m_lTid
        SL_UNOWNED      = 0,
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 32,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    bool _CmpExchRW(LONG lNew, LONG lCurrent);
    LONG _SetTid(LONG lNewTid);
    bool _TryWriteLock();
    bool _TryWriteLock2();
    bool _TryReadLock();
    bool _TryReadLockRecursive();

    static LONG _GetCurrentThreadId();
    static LONG _CurrentThreadId();
    

public:
    CReaderWriterLock4()
        : m_lRW(SL_FREE),
          m_lTid(SL_UNOWNED)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock4(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE),
          m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock4()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    LOCK_FORCEINLINE void
    WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        if (! _TryWriteLock())
            _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    } 

    LOCK_FORCEINLINE void
    ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        if (! _TryReadLock())
            _ReadLockSpin(SPIN_READ);

        IRTLASSERT(IsReadLocked());
    } 

    // ReadOrWriteLock: If already locked, recursively acquires another lock
    // of the same kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    bool ReadOrWriteLock();

    LOCK_FORCEINLINE bool
    TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            IRTLASSERT(IsWriteLocked());
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            IRTLASSERT(!IsWriteLocked());
            return false;
        }
    }

    LOCK_FORCEINLINE bool
    TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            IRTLASSERT(IsReadLocked());
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            // Can't IRTLASSERT(!IsReadLocked()) because other threads
            // may have acquired a read lock by now
            return false;
        }
    }

    void WriteUnlock();
    void ReadUnlock();
    void ReadOrWriteUnlock(bool fIsReadLocked);

    // Does current thread hold a write lock?
    LOCK_FORCEINLINE bool
    IsWriteLocked() const
    {
        const LONG lTid = m_lTid;

        if (lTid == SL_UNOWNED)
            return false;
        
        bool fLocked = (lTid == _GetCurrentThreadId());

        IRTLASSERT(!fLocked
                   ||  ((SL_WRITER_MIN <= (m_lRW & SL_STATE_MASK))
                        &&  ((m_lRW & SL_STATE_MASK) <= SL_EXCLUSIVE)));
        return fLocked;
    }

    LOCK_FORCEINLINE bool
    IsReadLocked() const
    {
        LONG lRW = m_lRW;
        return ((SL_READER_INCR <= (lRW & SL_STATE_MASK))
                &&  ((lRW & SL_STATE_MASK) <= SL_READER_MASK));

    }

    bool
    IsWriteUnlocked() const
    { return !IsWriteLocked(); }

    bool
    IsReadUnlocked() const
    { return !IsReadLocked(); }

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void
    ConvertSharedToExclusive();

    // There is no such window when converting from a writelock to a readlock
    void
    ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool
    SetSpinCount(WORD)
    {return false;}

    WORD
    GetSpinCount() const
    {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*
    ClassName()
    {return _TEXT("CReaderWriterLock4");}

}; // CReaderWriterLock4

#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\kernel\kirtldbg.cpp ===
/*++

   Copyright    (c) 2000-2002    Microsoft Corporation

   Module  Name :
       kLocks.cpp

   Abstract:
       A collection of kernel-mode locks for multithreaded access
       to data structures

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include <kLKRhash.h>
#include "../src/IrtlDbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\inc\lstentry.h ===
/*++

   Copyright    (c)    1997-2002    Microsoft Corporation

   Module  Name :
       LstEntry.h

   Abstract:
       Declares CListEntry and other intrusive singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <Locks.h>
#endif // !__LOCKS_H__

#ifndef LSTENTRY_LOCK
 #ifdef LOCKS_KERNEL_MODE
  #define LSTENTRY_LOCK CKSpinLock
 #else // !LOCKS_KERNEL_MODE
  #define LSTENTRY_LOCK CSpinLock
  #endif // !LOCKS_KERNEL_MODE
#endif // !LSTENTRY_LOCK

// TODO:
// * Add STL-style iterators: begin(), end(), operator++(), etc
// * Templatize the lists, so that you can avoid the CONTAINING_RECORD goo

//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    LSTENTRY_LOCK m_lock;
    CSingleList   m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    LSTENTRY_LOCK m_lock;
    CDoubleList   m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\kernel\main.cpp ===
/*++

   Copyright    (c) 2000-2002    Microsoft Corporation

   Module  Name :
       main.cpp

   Abstract:
       Driver entrypoints for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"

ULONG __Pool_Tag__ = 'RKLk';	// default memory tag

extern "C"
VOID
LkrUnload(
    IN PDRIVER_OBJECT DriverObject);

extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    // TODO: other driver initialization

    DriverObject->DriverUnload = &LkrUnload;

    if (!LKR_Initialize(LK_INIT_DEFAULT))
        return STATUS_UNSUCCESSFUL;

    return STATUS_SUCCESS;
}


VOID
LkrUnload(
    IN PDRIVER_OBJECT DriverObject)
{
    LKR_Terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\kernel\klocks.cpp ===
/*++

   Copyright    (c) 2000-2002    Microsoft Corporation

   Module  Name :
       kLocks.cpp

   Abstract:
       A collection of kernel-mode locks for multithreaded access
       to data structures

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include <kLKRhash.h>
#include "../src/Locks.cpp"

//------------------------------------------------------------------------
// CKSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CKSpinLock);
LOCK_STATISTICS_DATA(CKSpinLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CKSpinLock);


//------------------------------------------------------------------------
// CFastMutex static member variables

LOCK_DEFAULT_SPIN_DATA(CFastMutex);
LOCK_STATISTICS_DATA(CFastMutex);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFastMutex);


//------------------------------------------------------------------------
// CEResource static member variables

LOCK_DEFAULT_SPIN_DATA(CEResource);
LOCK_STATISTICS_DATA(CEResource);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CEResource);


//------------------------------------------------------------------------
// Function: CEResource::ReadOrWriteLock
// Synopsis: If already locked, recursively acquires another lock of the
// same kind (read or write). Otherwise, just acquires a read lock.
//------------------------------------------------------------------------

bool
CEResource::ReadOrWriteLock()
{
    if (IsWriteLocked())
    {
        WriteLock();
        return false;   // => not read locked
    }
    else
    {
        ReadLock();
            
        return true;   // => is read locked
    }
} 



//------------------------------------------------------------------------
// Function: CEResource::ReadOrWriteUnlock
// Synopsis: release a lock acquired with ReadOrWriteLock
//------------------------------------------------------------------------

void
CEResource::ReadOrWriteUnlock(
    bool fIsReadLocked)
{
    if (fIsReadLocked)
        ReadUnlock();
    else
        WriteUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\dbglkrh.cxx ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    dbglkrh.cxx

Abstract:

    LKRhash support

Author:

    George V. Reilly (GeorgeRe)  22-Feb-1999

Revision History:

--*/

#include "precomp.hxx"

#include "lkrcust.h"

#define LKR_CUST_DECLARE_TABLE
#include "lkrcust.h"

#include <i-lkrhash.h>

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets = 0;
LONG CLKRLinearHashTable::sm_cTables           = 0;
#endif // LOCK_INSTRUMENTATION

#define CMDNAME "lkrhash"

// There are several different DLLs in the IISRTL family. This is to
// allow us to set the name of the DLL on the fly.
// TODO: add a command to set this name dynamically.

#ifndef LKRHASH_NAME
# define LKRHASH_NAME "LKRhash"
#endif // LKRHASH_NAME

CHAR g_szLKRhashDllName[MAX_PATH] = LKRHASH_NAME;

// sprintf-formatted string, e.g., "&%s!CLKRHashTable__sm_llGlobalList"
// Has to return LPSTR, not LPCSTR, because GetExpression is not const-correct
LPSTR
LKRhashDllVar(
    LPCSTR pszFormat)
{
    // we can get away with a static CHAR[] because debugger extensions
    // are single-threaded
    static CHAR szSymbol[MAX_SYMBOL_LEN];

    sprintf(szSymbol, pszFormat, g_szLKRhashDllName);
    return szSymbol;
}

#ifndef __LKRHASH_NO_NAMESPACE__
 #define STR_LKRHASH_NS "LKRhash__"
#else
 #define STR_LKRHASH_NS ""
#endif // !__LKRHASH_NO_NAMESPACE__



/************************************************************
 * Dump LKRhash tables
 ************************************************************/
const char*
LKRC2String(
    LK_RETCODE lkrc)
{
    const char* psz = NULL;

    switch (lkrc)
    {
    case LK_UNUSABLE:
        psz = "LK_UNUSABLE";
        break;
    case LK_ALLOC_FAIL:
        psz = "LK_ALLOC_FAIL";
        break;
    case LK_BAD_ITERATOR:
        psz = "LK_BAD_ITERATOR";
        break;
    case LK_BAD_RECORD:
        psz = "LK_BAD_RECORD";
        break;
    case LK_BAD_PARAMETERS:
        psz = "LK_BAD_PARAMETERS";
        break;
    case LK_NOT_INITIALIZED:
        psz = "LK_NOT_INITIALIZED";
        break;
    case LK_BAD_TABLE:
        psz = "LK_BAD_TABLE";
        break;
    case LK_SUCCESS:
        psz = "LK_SUCCESS";
        break;
    case LK_KEY_EXISTS:
        psz = "LK_KEY_EXISTS";
        break;
    case LK_NO_SUCH_KEY:
        psz = "LK_NO_SUCH_KEY";
        break;
    case LK_NO_MORE_ELEMENTS:
        psz = "LK_NO_MORE_ELEMENTS";
        break;
    default:
        psz = "Unknown LK_RETCODE";
        break;
    }

    return psz;
}


enum {
    NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
    BUCKET_BYTE_SIZE = CNodeClump::BUCKET_BYTE_SIZE,
    HASH_INVALID_SIGNATURE =
        LKRHASH_NS::CLKRLinearHashTable::HASH_INVALID_SIGNATURE,
    LKLH_SIGNATURE =      LKRHASH_NS::CLKRLinearHashTable::SIGNATURE,
    LKLH_SIGNATURE_FREE = LKRHASH_NS::CLKRLinearHashTable::SIGNATURE_FREE,
    LKHT_SIGNATURE =      LKRHASH_NS::CLKRHashTable::SIGNATURE,
    LKHT_SIGNATURE_FREE = LKRHASH_NS::CLKRHashTable::SIGNATURE_FREE,
};


BOOL
EnumerateBucketChain(
    LKR_CUST_EXTN*    plce,
    IN LOCK_LOCKTYPE  ltBucketLockType,
    IN INT            iBkt,
    IN PBucket        pbkt,
    IN INT            nVerbose)
{
    PSTR        cmdName = CMDNAME;
    BYTE        abBkt[BUCKET_BYTE_SIZE];
    DEFINE_CPP_VAR(CNodeClump, nc);
    PNodeClump  pnc = GET_CPP_VAR_PTR(CNodeClump, nc);
    PNodeClump  pncCurr;
    DWORD       cNodes = 0, cnc = 0;
    BOOL        fLockPrinted = FALSE;

    ReadMemory(pbkt, abBkt, sizeof(abBkt), NULL);

    // Just in case lkrdbg.dll and lkrhash.dll were built with different
    // definitions for BucketLock, we make no assumptions about the size
    // of BucketLock
    for (pncCurr = (PNodeClump) ((PBYTE) pbkt + LockSize(ltBucketLockType));
         pncCurr != NULL;
         pncCurr = pnc->m_pncNext)
    {
        DWORD i, c;

        ReadMemory(pncCurr, pnc, sizeof(nc), NULL);

        for (i = c = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                c++;
        }

        if (c == NODES_PER_CLUMP)
        {
            if (nVerbose >= 3)
                dprintf("  0-%d: -- empty\n", NODES_PER_CLUMP);
        }
        else
        {
#ifdef LKR_USE_BUCKET_LOCKS
            if (cnc++ == 0)
                PrintLock(ltBucketLockType, &pbkt->m_Lock, nVerbose);
#endif

            dprintf("Bucket %4d, %d:\n", iBkt, cnc);
            for (i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                {
                    if (nVerbose >= 3)
                        dprintf("  %d: --\n", i);
                    else
                        break;
                }
                else if (plce != NULL)
                {
                    if (!(*plce->m_pfn_Record_Dump)(pnc->m_pvNode[i],
                                                    pnc->m_dwKeySigs[i],
                                                    nVerbose))
                        return FALSE;
                }
            }
        }

        if (CheckControlC())
        {
            dprintf("\n^C\n");
            return FALSE;
        }

        const DWORD MAX_NODES = 20;
        if (++cNodes > MAX_NODES)
        {
            dprintf(DBGEXT ".%s: Bucket chain contains more than %d nodes! "
                    "Corrupted?\n", cmdName, MAX_NODES);
            return TRUE;
        }
    }

    return TRUE;
}



BOOL
EnumerateLKRLinearHashTable(
    LKR_CUST_EXTN*       plce,
    IN CLinearHashTable* plht,
    IN INT               nVerbose)
{
    PSTR cmdName = CMDNAME;
    DEFINE_CPP_VAR(CLinearHashTable, lht);
    CLinearHashTable* plht2 = GET_CPP_VAR_PTR(CLinearHashTable, lht);
    INT i;
    BOOL fRet = FALSE;
    LOCK_LOCKTYPE ltTableLockType  = LOCK_SPINLOCK;
    LOCK_LOCKTYPE ltBucketLockType = LOCK_SPINLOCK;
    PSegment* paDirSegs = NULL;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(plht, plht2, sizeof(lht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)plht);

        goto cleanup;
    }

    dprintf(
        "\n" DBGEXT ".%s: @ %p:\n"
        "    CLKRLinearHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    State = %d (%s)\n",
        cmdName,
        plht,
        plht2->m_dwSignature,
        DECODE_SIGNATURE(plht2->m_dwSignature),
        plht2->m_dwSignature == LKLH_SIGNATURE
            ? "OK" : (plht2->m_dwSignature == LKLH_SIGNATURE_FREE
                      ? "FREED" : "INVALID"),
        plht2->m_szName,
        plht2->m_lkrcState, LKRC2String(plht2->m_lkrcState));

    if (nVerbose == 0)
        goto done;

    ltTableLockType  = (LOCK_LOCKTYPE) plht2->m_nTableLockType;
    ltBucketLockType = (LOCK_LOCKTYPE) plht2->m_nBucketLockType;
    dprintf(
        "    TableLock = %s, BucketLock = %s, Parent CLKRHashTable = %p\n",
        LockName(ltTableLockType),
        LockName(ltBucketLockType),
        plht2->m_phtParent);

    dprintf(
        "    Size = %d, SegBits = %d, SegSize = %d, SegMask = %x\n",
        plht2->m_lkts, plht2->m_nSegBits,
        plht2->m_nSegSize, plht2->m_nSegMask);
    dprintf(
        "    MaxLoad = %3.1f, paDirSegs = %p, cDirSegs = %d\n",
        plht2->m_MaxLoad, plht2->m_paDirSegs, plht2->m_cDirSegs);
    dprintf(
        "    cRecords = %d, cActiveBuckets = %d, BucketSpins = %hd\n",
        plht2->m_cRecords, plht2->m_cActiveBuckets, plht2->m_wBucketLockSpins);
    dprintf(
        "    nLevel = %d, dwBktAddrMask0 = %x, iExpansionIdx = %d\n",
        plht2->m_nLevel, plht2->m_dwBktAddrMask0, plht2->m_iExpansionIdx);

    PrintLock(ltTableLockType, &plht->m_Lock, nVerbose);

    if (plce != NULL  &&  !(*plce->m_pfn_LKLH_Dump)(plht, nVerbose))
        goto done;
    
    if (nVerbose == 1)
        goto done;
    
    paDirSegs = (PSegment*) calloc(plht2->m_cDirSegs, sizeof(PSegment));

    if (paDirSegs == NULL)
    {
        dprintf("Couldn't allocate %d bytes for directory segment\n",
                plht2->m_cDirSegs * sizeof(PSegment));
        return fRet;
    }
    
    if (!ReadMemory(plht2->m_paDirSegs, paDirSegs,
                    sizeof(PSegment) * plht2->m_cDirSegs, NULL))
        goto cleanup;

    for (i = 0;  i < (INT) (plht2->m_cDirSegs * plht2->m_nSegSize);  i++)
    {
        const DWORD iSeg = i >> plht2->m_nSegBits;
        CLargeSegment* pseg = static_cast<CLargeSegment*>(paDirSegs[iSeg]);

        if ((i & plht2->m_nSegMask) == 0)
            dprintf("Segment %d: %p\n", iSeg, pseg);

        if (pseg == NULL)
            continue;

        if (nVerbose >= 2)
        {
            PBucket pbkt = pseg->m_bktSlots + (i & plht2->m_nSegMask);
            
            if (!EnumerateBucketChain(plce, ltBucketLockType,
                                      i, pbkt, nVerbose))
                goto cleanup;
        }

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;

  cleanup:
    memset(plht2, 0, sizeof(lht));
    free(paDirSegs);
    return fRet;
}



BOOL
EnumerateLKRhashTable(
    LKR_CUST_EXTN*    plce,
    IN CHashTable*    pht,
    IN INT            nVerbose)
{
    DEFINE_CPP_VAR(CHashTable, ht);
    CHashTable* pht2 = GET_CPP_VAR_PTR(CHashTable, ht);
    PSTR cmdName = CMDNAME;
    CLinearHashTable** palhtDir = NULL;
    UINT i;
    BOOL fRet = FALSE;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(pht, pht2, sizeof(ht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)pht);

        goto cleanup;
    }

    dprintf(
        DBGEXT ".%s: @ %p:\n"
        "    CLKRHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    %d subtables, State = %d (%s)\n",
        cmdName,
        pht,
        pht2->m_dwSignature,
        DECODE_SIGNATURE(pht2->m_dwSignature),
        pht2->m_dwSignature == LKHT_SIGNATURE
            ? "OK"
            : pht2->m_dwSignature == LKHT_SIGNATURE_FREE
              ? "FREED"
              : "INVALID",
        pht2->m_szName,
        pht2->m_cSubTables,
        pht2->m_lkrcState, LKRC2String(pht2->m_lkrcState)
        );

    if (plce != NULL  &&  !(*plce->m_pfn_LKHT_Dump)(pht, nVerbose))
        goto done;
    
    if (nVerbose == 0)
        goto done;

    palhtDir = (CLinearHashTable**) calloc(pht2->m_cSubTables,
                                           sizeof(CLinearHashTable*));
    if (!palhtDir)
        goto cleanup;
    
    if (!ReadMemory(pht2->m_palhtDir, palhtDir,
                    pht2->m_cSubTables * sizeof(CLinearHashTable*), NULL))
        goto cleanup;

    for (i = 0;  i < pht2->m_cSubTables;  ++i)
    {
        dprintf("\n%d : ", i);
        if (!EnumerateLKRLinearHashTable(plce, palhtDir[i], nVerbose))
            break;

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;
    
  cleanup:
    free(palhtDir);

    return fRet;
}



VOID
PrintLKRLinearHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CLinearHashTable*) psdDebugger)->m_dwSignature;

    if (dwSig != LKLH_SIGNATURE)
    {
        dprintf( "CLKRLinearHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee, dwSig, DECODE_SIGNATURE(dwSig),
                 LKLH_SIGNATURE, DECODE_SIGNATURE(LKLH_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) psdDebuggee,
                                    chVerbosity);
}



VOID
PrintLKRHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CHashTable*) psdDebugger)->m_dwSignature;
    if (dwSig != LKHT_SIGNATURE)
    {
        dprintf( "CLKRHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee,
                 dwSig, DECODE_SIGNATURE(dwSig),
                 LKHT_SIGNATURE, DECODE_SIGNATURE(LKHT_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRhashTable(plce, (CHashTable*) psdDebuggee,
                              chVerbosity);
}



VOID
DumpLKRsList(
    IN INT              nVerbose)
{
#ifndef LKR_NO_GLOBAL_LIST
    CLockedDoubleList* plstHashTables = (CLockedDoubleList*) GetExpression(
                        LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                      "CLKRHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("%s!" STR_LKRHASH_NS
                              "CLKRHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CHashTable),
                    FIELD_OFFSET( CHashTable, m_leGlobalList));


    plstHashTables = (CLockedDoubleList*) GetExpression(
                      LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                    "CLKRLinearHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("!" STR_LKRHASH_NS
                              "CLKRLinearHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRLinearHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRLinearHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CLinearHashTable),
                    FIELD_OFFSET( CLinearHashTable, m_leGlobalList));
#endif // !LKR_NO_GLOBAL_LIST
    return;
} // DumpLKRsList()





DECLARE_API( lkrhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKRhash table.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    ULONG_PTR lkrAddress = 0;
    INT nVerbose = 0;
    PSTR cmdName = CMDNAME;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *lpArgumentString == 'l' ) {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
        }

        if ( *lpArgumentString == 'v' )
        {
            lpArgumentString++;
            nVerbose = 99;
        }

        if ( *lpArgumentString == 'g' )
        {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
            DumpLKRsList(nVerbose);
            return;
        }

    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    lkrAddress = (ULONG_PTR) GetExpression( lpArgumentString );

    if (lkrAddress == 0) {

        dprintf(
            DBGEXT ".%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    DWORD dwSig;
    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, (VOID*) lkrAddress, dwSig);

    if (plce == NULL)
        goto cleanup;
    
    if (dwSig == LKHT_SIGNATURE || dwSig == LKHT_SIGNATURE_FREE)
    { 
        EnumerateLKRhashTable(plce,
                              (CHashTable*) lkrAddress,
                              nVerbose);
    }
    else if (dwSig == LKLH_SIGNATURE || dwSig == LKLH_SIGNATURE_FREE)
    { 
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) lkrAddress,
                                    nVerbose);
    }
    else
    {
        dprintf(DBGEXT ".%s: %p does not contain a valid LKRhash table\n",
                cmdName, (PVOID)lkrAddress);
    }
    
cleanup:
    return;
} // DECLARE_API( lkrhash )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\dbglocks.cxx ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    dbglocks.cxx

Abstract:

    Locks support

Author:

    George V. Reilly (GeorgeRe)  01-Mar-1999

Revision History:

--*/

#include "precomp.hxx"

#ifdef LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME ("lkrdbg")
LONG CSmallSpinLock::sm_cTotalLocks     = 0;
LONG CSpinLock::sm_cTotalLocks          = 0;
LONG CReaderWriterLock::sm_cTotalLocks  = 0;
LONG CReaderWriterLock2::sm_cTotalLocks = 0;
LONG CReaderWriterLock3::sm_cTotalLocks = 0;
LONG CReaderWriterLock4::sm_cTotalLocks = 0;
#else // !LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME 
#endif // !LOCK_INSTRUMENTATION

const char*
LockName(
    LOCK_LOCKTYPE lt)
{
    const char* pszName = NULL;
    static char szName[40];

    switch (lt)
    {
    case LOCK_FAKELOCK:
        pszName = "CFakeLock";
        break;
    case LOCK_SMALLSPINLOCK:
        pszName = "CSmallSpinLock";
        break;
    case LOCK_SPINLOCK:
        pszName = "CSpinLock";
        break;
    case LOCK_CRITSEC:
        pszName = "CCritSec";
        break;
    case LOCK_READERWRITERLOCK:
        pszName = "CReaderWriterLock";
        break;
    case LOCK_READERWRITERLOCK2:
        pszName = "CReaderWriterLock2";
        break;
    case LOCK_READERWRITERLOCK3:
        pszName = "CReaderWriterLock3";
        break;
    case LOCK_READERWRITERLOCK4:
        pszName = "CReaderWriterLock4";
        break;
#ifdef LOCKS_KERNEL_MODE
    case LOCK_KSPINLOCK:
        pszName = "CKSpinLock";
        break;
    case LOCK_FASTMUTEX:
        pszName = "CFastMutex";
        break;
    case LOCK_ERESOURCE:
        pszName = "CEResource";
        break;
    case LOCK_RTL_MRSW_LOCK:
        pszName = "CRtlMrswLock";
        break;
#endif // LOCKS_KERNEL_MODE
    default:
        sprintf(szName, "UnknownLockType %d", lt);
        pszName = szName;
        break;
    }

    return pszName;
};

int
LockSize(
    LOCK_LOCKTYPE lt)
{
    int cb = 0;

    switch (lt)
    {
    case LOCK_FAKELOCK:
        cb = sizeof(CFakeLock);
        break;
    case LOCK_SMALLSPINLOCK:
        cb = sizeof(CSmallSpinLock);
        break;
    case LOCK_SPINLOCK:
        cb = sizeof(CSpinLock);
        break;
    case LOCK_CRITSEC:
        cb = sizeof(CCritSec);
        break;
    case LOCK_READERWRITERLOCK:
        cb = sizeof(CReaderWriterLock);
        break;
    case LOCK_READERWRITERLOCK2:
        cb = sizeof(CReaderWriterLock2);
        break;
    case LOCK_READERWRITERLOCK3:
        cb = sizeof(CReaderWriterLock3);
        break;
    case LOCK_READERWRITERLOCK4:
        cb = sizeof(CReaderWriterLock4);
        break;
#ifdef LOCKS_KERNEL_MODE
    case LOCK_KSPINLOCK:
        cb = sizeof(CKSpinLock);
        break;
    case LOCK_FASTMUTEX:
        cb = sizeof(CFastMutex);
        break;
    case LOCK_ERESOURCE:
        cb = sizeof(CEResource);
        break;
    case LOCK_RTL_MRSW_LOCK:
        cb = sizeof(CRtlMrswLock);
        break;
#endif // LOCKS_KERNEL_MODE
    default:
        cb = 0;
        break;
    }

    return cb;
};



BOOL
Print_FakeLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_SmallSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSmallSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSmallSpinLock (%p): Thread = %x\n",
            pvLock, sl.m_lTid);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_SpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock (%p): Thread = %d, Count = %d\n",
            pvLock,
            (sl.m_lTid & CSpinLock::SL_THREAD_MASK)
                >> CSpinLock::SL_THREAD_SHIFT,
            (sl.m_lTid & CSpinLock::SL_OWNER_MASK)
                >> CSpinLock::SL_OWNER_SHIFT);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_CritSec(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_ReaderWriterLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock (%p): State = %x, Waiters = %d\n",
            pvLock, sl.m_nState, sl.m_cWaiting);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock2 (%p): State = %x, Waiters = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock2::SL_STATE_MASK)
                >> CReaderWriterLock2::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock2::SL_WAITING_MASK)
                >> CReaderWriterLock2::SL_WAITING_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock3(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock3 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    int nReaders = ((sl.m_lRW & CReaderWriterLock3::SL_STATE_MASK)
                        >> CReaderWriterLock3::SL_STATE_SHIFT);

    dprintf("CReaderWriterLock3 (%p): State = %x, Readers = %d, Waiters = %d, "
            "Thrd = %x, Cnt = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock3::SL_STATE_MASK)
                >> CReaderWriterLock3::SL_STATE_SHIFT,
            nReaders == CReaderWriterLock3::SL_EXCLUSIVE ? 0 : nReaders,
            (sl.m_lRW & CReaderWriterLock3::SL_WAITING_MASK)
                >> CReaderWriterLock3::SL_WAITING_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_THREAD_MASK)
                >> CReaderWriterLock3::SL_THREAD_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_OWNER_MASK)
                >> CReaderWriterLock3::SL_OWNER_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock4(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock4 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    int nRW = (short) ((sl.m_lRW & CReaderWriterLock4::SL_STATE_MASK)
                        >> CReaderWriterLock4::SL_STATE_SHIFT);
    int nWriterRecursion = ((sl.m_lRW & CReaderWriterLock4::SL_STATE_MASK)
                            >> CReaderWriterLock4::SL_STATE_SHIFT);

    dprintf("CReaderWriterLock4 (%p): RW=%08x, Tid=%x - State = %x, "
            "Readers = %d, Waiters = %d, Thrd = %x, Cnt = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock4::SL_STATE_MASK)
                >> CReaderWriterLock4::SL_STATE_SHIFT,
            nRW < 0 ? 0 : nRW,
            (sl.m_lRW & CReaderWriterLock4::SL_WAITING_MASK)
                >> CReaderWriterLock4::SL_WAITING_SHIFT,
            (sl.m_lTid & CReaderWriterLock4::SL_THREAD_MASK)
                >> CReaderWriterLock4::SL_THREAD_SHIFT,
            nRW < 0 ? -nRW : 0
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



#ifdef LOCKS_KERNEL_MODE

BOOL
Print_KSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CKSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CKSpinLock (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_FastMutex(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CFastMutex sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CFastMutex (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_EResource(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CEResource sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CEResource (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_RtlMrswLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CRtlMrswLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CRtlMrswLock (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}

#endif // LOCKS_KERNEL_MODE



BOOL
PrintLock(
    LOCK_LOCKTYPE lt,
    IN PVOID      pvLock,
    IN INT        nVerbose)
{
    BOOL f = FALSE;
    switch (lt)
    {
    case LOCK_FAKELOCK:
        f = Print_FakeLock(pvLock, nVerbose);
        break;
    case LOCK_SMALLSPINLOCK:
        f = Print_SmallSpinLock(pvLock, nVerbose);
        break;
    case LOCK_SPINLOCK:
        f = Print_SpinLock(pvLock, nVerbose);
        break;
    case LOCK_CRITSEC:
        f = Print_CritSec(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK:
        f = Print_ReaderWriterLock(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK2:
        f = Print_ReaderWriterLock2(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK3:
        f = Print_ReaderWriterLock3(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK4:
        f = Print_ReaderWriterLock4(pvLock, nVerbose);
        break;
#ifdef LOCKS_KERNEL_MODE
    case LOCK_KSPINLOCK:
        f = Print_KSpinLock(pvLock, nVerbose);
        break;
    case LOCK_FASTMUTEX:
        f = Print_FastMutex(pvLock, nVerbose);
        break;
    case LOCK_ERESOURCE:
        f = Print_EResource(pvLock, nVerbose);
        break;
    case LOCK_RTL_MRSW_LOCK:
        f = Print_RtlMrswLock(pvLock, nVerbose);
        break;
#endif // LOCKS_KERNEL_MODE
    default:
        f = FALSE;
        break;
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\help.cxx ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    help.cxx

Abstract:

    This module contains the help text for all commands supported by this
    NTSD debugger extension.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"

//
// The following structure defines the text displayed in response
// to the "!help" command. This text may also be displayed if invalid
// arguments are passed to a command.
//

typedef struct _HELP_MAP {

    //
    // This is the name of the command.
    //

    PSTR Command;

    //
    // This is a "one-liner" displayed when the user executes "!help".
    //

    PSTR OneLiner;

    //
    // This is the full help text displayed when the user executes
    // "!help <cmd>".
    //

    PSTR FullHelp;

} HELP_MAP, *PHELP_MAP;

HELP_MAP HelpMaps[] =
    {
        {
            "help",
            "Dump this list or help for specific command",
            "help [<cmd>] - Dump help for command\n"
            "  If no <cmd> is given, a list of all available commands is displayed\n"
        },

        {
            "lkrhash",
            "Dump LKRhash table structures",
            "!lkrhash [options] <addr>    - Dump LKRhash table at <addr>\n"
             "     -l[0-2] == verbosity level\n"
             "     -v      == very verbose\n"
             "     -g[0-2] == dump global list of LKRhashes at verbosity level\n"
        },

    };

#define NUM_HELP_MAPS ( sizeof(HelpMaps) / sizeof(HelpMaps[0]) )


PSTR
FindHelpForCommand(
    IN PSTR CommandName
    )
{

    PHELP_MAP helpMap;
    ULONG i;

    for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
        if( _stricmp( helpMap->Command, CommandName ) == 0 ) {
            return helpMap->FullHelp;
        }
    }

    return NULL;

}   // FindHelpForCommand

VOID
PrintUsage(
    IN PSTR CommandName
    )
{

    PSTR cmdHelp;
    PHELP_MAP helpMap;
    ULONG i;
    ULONG maxLength;
    ULONG length;

    dprintf( "IIS debugging extension for IIS Version 5.0\n" );

    if( CommandName == NULL ) {

        //
        // We'll display the one-liners for each command. Start by
        // scanning the commands to find the longest length. This makes the
        // output much prettier without having to manually tweak the
        // columns.
        //

        maxLength = 0;

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            length = (ULONG)strlen( helpMap->Command );
            if( length > maxLength ) {
                maxLength = length;
            }
        }

        //
        // Now actually display the one-liners.
        //

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            dprintf(
                "!%-*s - %s\n",
                maxLength,
                helpMap->Command,
                helpMap->OneLiner
                );
        }

    } else {

        //
        // Find a specific command and display the full help.
        //

        cmdHelp = FindHelpForCommand( CommandName );

        if( cmdHelp == NULL ) {
            dprintf( "unrecognized command %s\n", CommandName );
        } else {
            dprintf( "%s", cmdHelp );
        }

    }

} // PrintUsage()


DECLARE_API( help )
{

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( !strcmp( lpArgumentString, "?" ) ) {
        lpArgumentString = "help";
    }

    if( *lpArgumentString == '\0' ) {
        lpArgumentString = NULL;
    }

    PrintUsage( lpArgumentString );

} // DECLARE_API( help )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\lkrcust.h ===
#ifndef LKR_CUST_DECLARE_TABLE

#include "lkrhash.h"

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
 using namespace LKRhash;
 typedef LKRhash::CLKRLinearHashTable CLinearHashTable;
 typedef LKRhash::CLKRHashTable       CHashTable;
#else
 #define LKRHASH_NS
 typedef CLKRLinearHashTable CLinearHashTable;
 typedef CLKRHashTable       CHashTable;
#endif // !__LKRHASH_NO_NAMESPACE__


typedef
BOOL
(CALLBACK * PFN_LKHT_DUMP)(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose);

typedef
BOOL
(CALLBACK * PFN_LKLH_DUMP)(
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose);

typedef
BOOL
(CALLBACK * PFN_RECORD_DUMP)(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose);

struct LKR_CUST_EXTN {
    LPCSTR          m_pszTableName;
    PFN_LKHT_DUMP   m_pfn_LKHT_Dump;
    PFN_LKLH_DUMP   m_pfn_LKLH_Dump;
    PFN_RECORD_DUMP m_pfn_Record_Dump;
};

LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig);

BOOL
EnumerateBucketChain(
    LKR_CUST_EXTN*    plce,
    IN LOCK_LOCKTYPE  ltBucketLockType,
    IN INT            iBkt,
    IN CBucket*       pbkt,
    IN INT            nVerbose);

BOOL
EnumerateLKRLinearHashTable(
    LKR_CUST_EXTN*       plce,
    IN CLinearHashTable* plht,
    IN INT               nVerbose);

BOOL
EnumerateLKRhashTable(
    LKR_CUST_EXTN*    plce,
    IN CHashTable*    pht,
    IN INT            nVerbose);



# define BEGIN_LKR_EXTN_TABLE()

# define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKHT_Dump(                          \
    IN CLKRHashTable*   pht,            \
    IN INT              nVerbose);      \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKLH_Dump(                          \
    IN CLKRLinearHashTable* plht,       \
    IN INT                  nVerbose);  \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_Record_Dump(                        \
    IN const void* pvRecord,            \
    IN DWORD       dwSignature,         \
    IN INT         nVerbose);           \

# define END_LKR_EXTN_TABLE()


#else // LKR_CUST_DECLARE_TABLE


#undef BEGIN_LKR_EXTN_TABLE
#undef LKR_EXTN_DECLARE
#undef END_LKR_EXTN_TABLE


 #define BEGIN_LKR_EXTN_TABLE() \
    LKR_CUST_EXTN g_alce[] = {

 #define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
        { #_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump }, 

 #define END_LKR_EXTN_TABLE()   \
        { 0, 0, 0, 0},          \
        };


#endif // LKR_CUST_DECLARE_TABLE



BEGIN_LKR_EXTN_TABLE()
  LKR_EXTN_DECLARE(?,
                   Dummy_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   Dummy_Record_Dump)
  LKR_EXTN_DECLARE(wordhash,
                   CWordHash_LKHT_Dump,
                   CWordHash_LKLH_Dump,
                   CWordHash_RecordDump)
  LKR_EXTN_DECLARE(string,
                   CStringTest_TableDump,
                   Dummy_LKLH_Dump,
                   CTest_RecordDump)
  LKR_EXTN_DECLARE(NumberSet,
                   CNumberSet_TableDump,
                   Dummy_LKLH_Dump,
                   int_RecordDump)
  LKR_EXTN_DECLARE(number,
                   CNumberTest_TableDump,
                   Dummy_LKLH_Dump,
                   CTest_RecordDump)
  LKR_EXTN_DECLARE(VWtest,
                   CWchar_TableDump,
                   Dummy_LKLH_Dump,
                   Vwrecord_RecordDump)
END_LKR_EXTN_TABLE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\lkrcust.cpp ===
#include "precomp.hxx"
#include "lkrcust.h"

enum {
    NAME_SIZE           = LKRHASH_NS::CLKRHashTable::NAME_SIZE,
};

LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig)
{
    extern LKR_CUST_EXTN g_alce[];

    struct LKRheader {
        DWORD m_dwSignature;
        CHAR  m_szName[NAME_SIZE];
    };

    LKRheader lkrh;
    rdwSig = 0;
    
    if (!ReadMemory(lkrAddress, &lkrh, sizeof(lkrh), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID) lkrAddress);

        return NULL;
    }

    rdwSig = lkrh.m_dwSignature;

    lkrh.m_szName[NAME_SIZE-1] = '\0';
    
    for (LKR_CUST_EXTN* plce = g_alce + 1;
         plce->m_pszTableName != NULL;
         ++plce)
    {
        if (strcmp(plce->m_pszTableName, lkrh.m_szName) == 0)
            return plce;
    }

    return &g_alce[0];  // Dummy methods
}



BOOL
WINAPI
Dummy_LKHT_Dump(
    IN LKRHASH_NS::CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_LKLH_Dump(
    IN LKRHASH_NS::CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_Record_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    dprintf("%p (%08x)\n", pvRecord, dwSignature);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\minfan.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\minfan\minfan.h"

BOOL
WINAPI
CWchar_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Vwrecord_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide VwrecordBase ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(VwrecordBase, vwbr);
    VwrecordBase* pvwbr = GET_CPP_VAR_PTR(VwrecordBase, vwbr); 

    // Copy the VwrecordBase from the debuggee's memory
    ReadMemory(pvRecord, pvwbr, sizeof(vwbr), NULL);

    // Read the associated string from the debuggee's memory
    const int MAX_STR=4096;
    char sz[MAX_STR];
    ReadMemory(pvwbr->Key, sz, MAX_STR, NULL);
    sz[MAX_STR-1] = '\0';

    dprintf("%p (%08x): Key=\"%s\", m_num=%d, Refs=%d\n",
            pvRecord, dwSignature, sz, pvwbr->m_num, pvwbr->cRef);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\numset.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\numset\numset.h"

BOOL
WINAPI
CNumberSet_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
int_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    int test;

    // Copy the CTest from the debuggee's memory
    ReadMemory(pvRecord, &test, sizeof(test), NULL);

    dprintf("%p (%08x): n=%d\n",
            pvRecord, dwSignature, test);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\main.cxx ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Misc utilities

Author:

    Murali R. Krishnan    ( MuraliK )     24-Aug-1997

Revision History:

--*/

#include "precomp.hxx"


NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;


# define minSize(a, b)  (((a) < (b)) ? (a) : (b))

/************************************************************
 *    Utility Functions
************************************************************/

VOID
dstring( CHAR * pszName, PVOID pvString, DWORD cbLen)
/*++
  Description:
    This function reads the data from the debuggee process at
    address [pvString] for specified length [cbLen] and echoes
    the string back on the debugger window.

  Arguments:
    pszName - pointer to string containing the name of the string read
    pvString - pointer to VOID specifying the location of the string
               in the debugee process
    cbLen   - count of bytes to be read at [pvString]

  Returns:
     None
--*/
{
    CHAR rgchString[10240];
    DWORD cLength = minSize( cbLen, sizeof(rgchString) -1);

    //
    // Read the data block from the debuggee process into local buffer
    //
    moveBlock( rgchString, pvString, cLength);

    rgchString[cLength] = '\0'; // terminate the string buffer
    dprintf( "%s = %s\n", pszName, rgchString);

    return;
} // dstring()



VOID
Print2Dwords( CHAR * pszN1, DWORD d1,
              CHAR * pszN2, DWORD d2
              )
{
    dprintf("    %25s =%8d  %25s =%8d\n",
             pszN1, d1,
             pszN2, d2
             );
    return;
} // Print2Dwords()



BOOL
EnumLinkedList(
    IN LIST_ENTRY  *       pListHead,
    IN PFN_LIST_ENUMERATOR pfnListEnumerator,
    IN CHAR                chVerbosity,
    IN DWORD               cbSizeOfStructure,
    IN DWORD               cbListEntryOffset
    )
/*++
  Description:
    This function iterates over the NT's standard LIST_ENTRY structure
    (doubly linked circular list with header) and makes callbacks for
    objects found on the list.

  Arguments:
    pListHead  - pointer to List head in the debugee process
    pfnListEnumerator - pointer to callback function for the object on the list
    chVerbosity - character indicating the verbosity level desired
    cbSizeOfStructure - count of bytes of object's size
    cbListEntryOffset - count of bytes of offset of the List entry structure
                           inside the containing object

  Returns:
     TRUE on successful enumeration
     FALSE on failure
--*/
{
# define MAX_STRUCTURE_SIZE        (10240)
    CHAR           rgch[MAX_STRUCTURE_SIZE];
    PVOID          pvDebuggee = NULL;
    PVOID          pvDebugger = (PVOID ) rgch;

    LIST_ENTRY     leListHead;
    LIST_ENTRY *   pListEntry;

    DWORD          cItems = 0;

    if ( NULL == pListHead) {
        dprintf( "Invalid List given \n");
        return (FALSE);
    }

    if ( MAX_STRUCTURE_SIZE < cbSizeOfStructure) {
        dprintf( "Given size for structure %d exceeds default max %d bytes\n",
                 cbSizeOfStructure, MAX_STRUCTURE_SIZE);
        return (FALSE);
    }

    // make a local copy of the list head for navigation purposes
    MoveWithRet( leListHead, pListHead, FALSE);

    for ( pListEntry  = leListHead.Flink;
          pListEntry != pListHead;
          )
    {
        if ( CheckControlC() )
        {
            return (FALSE);
        }

        pvDebuggee = (PVOID ) ((PCHAR ) pListEntry - cbListEntryOffset);

        // make a local copy of the debuggee structure
        MoveBlockWithRet( rgch, pvDebuggee, cbSizeOfStructure, FALSE);

        cItems++;

        if( pfnListEnumerator ) {
            (*pfnListEnumerator)( pvDebuggee, pvDebugger, chVerbosity, cItems);
            dprintf( "\n");
        }

        MoveWithRet( pListEntry, &pListEntry->Flink, FALSE );
    } // for all linked list entries

    dprintf( "%d entries traversed\n", cItems );

    return (TRUE);
} // EnumLinkedList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\wordhash.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\hashtest\wordhash.h"

BOOL
WINAPI
CWordHash_LKHT_Dump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    dprintf("CWordHash\n");
    return TRUE;
}



BOOL
WINAPI
CWordHash_LKLH_Dump(
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    dprintf("CWordHash\n");
    return TRUE;
}



BOOL
WINAPI
CWordHash_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide CWord ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(CWord, word);
    CWord* pWord = GET_CPP_VAR_PTR(CWord, word); 

    // Copy the CWord from the debuggee's memory
    ReadMemory(pvRecord, pWord, sizeof(CWord), NULL);

    // Read the associated string from the debuggee's memory
    char sz[4096];
    ReadMemory(pWord->m_str.m_psz, sz, min(4096, pWord->m_str.m_cch+1), NULL);
    sz[4096-1] = '\0';

    dprintf("%p (%08x): str=(\"%s\", %d)"
            ", NF=%d, fIns=%d, fIter=%d, Refs=%d"
            "\n",
            pvRecord, dwSignature, sz, pWord->m_str.m_cch,
            pWord->m_cNotFound, (int) pWord->m_fInserted,
            (int) pWord->m_fIterated, pWord->m_cRefs
            );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\lkrdbg\str-num.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\str-num\str-num.h"

BOOL
WINAPI
CStringTest_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
CNumberTest_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
CTest_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide CTest ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(CTest, test);
    CTest* pTest = GET_CPP_VAR_PTR(CTest, test); 

    // Copy the CTest from the debuggee's memory
    ReadMemory(pvRecord, pTest, sizeof(test), NULL);

    dprintf("%p (%08x): m_n=%d, m_sz=\"%s\", m_fWhatever=%d, m_cRefs=%d\n",
            pvRecord, dwSignature, pTest->m_n, pTest->m_sz,
            (int) pTest->m_fWhatever, pTest->m_cRefs);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\hashtest\inifile.h ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       HashTest.h

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __INIFILE_H__
#define __INIFILE_H__

#ifndef _MAX_PATH
# define _MAX_PATH 260
#endif

class CIniFileSettings
{
public:
    TCHAR   m_tszIniFile[_MAX_PATH]; // the .ini file
    TCHAR   m_tszDataFile[_MAX_PATH]; // where string data table lives
    int     m_nMaxKeys;         // maximum number of keys
    unsigned m_nHighLoad;       // maximum load of table (avg. bucket length)
    DWORD   m_nInitSize;        // initsize (1 => "small", 2 => "medium",
                                //   3 => "large", other => exact)
    int     m_nSubTables;       // num subtables (0 => heuristic)
    int     m_nLookupFreq;      // lookup frequency
    int     m_nMinThreads;      // min threads
    int     m_nMaxThreads;      // max threads
    int     m_nRounds;          // num rounds
    int     m_nSeed;            // random seed
    bool    m_fCaseInsensitive; // case-insensitive
    bool    m_fMemCmp;          // memcmp or strcmp
    int     m_nLastChars;       // num last chars (0 => all chars)
    WORD    m_wTableSpin;       // table lock spin count (0 => no spinning on
                                //   MP machines)
    WORD    m_wBucketSpin;      // bucket lock spin count (0 => no MP spinning)
    double  m_dblSpinAdjFctr;   // spin adjustment factor
    bool    m_fTestIterators;   // run test_iterators?
    int     m_nInsertIfNotFound;// test WriteLock, if(!FindKey) InsertRec, WUL?
                                // if IINF > 0, do this with probability 1/IINF
    int     m_nFindKeyCopy;     // search for a COPY of the key?
                                // if FKC > 0, do this probability 1/FKC
    bool    m_fNonPagedAllocs;  // Kernel mode: paged or non-paged allocs
    bool    m_fDebugSpew;       // Enable global debug spew?
    bool    m_fRefTrace;        // Enable debug spew for WordHash::AddRef?
    bool    m_fMultiKeys;       // Allow multiple identical keys
    bool    m_fUseLocks;        // Must use locks to protect the data

    int
    ParseIniFile(
        LPCSTR pszIniFile);
    
    void
    ReadIniFile(
        LPCTSTR ptszIniFile);
    
    void
    Dump(
        LPCTSTR ptszProlog,
        LPCTSTR ptszEpilog) const;
};

extern "C"
const TCHAR*
CommaNumber(
    int n,
    TCHAR* ptszBuff);

int
LKR_TestHashTable(
    CIniFileSettings& ifs);

extern "C"
int
NumProcessors();

#endif // __INIFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\hashtest\hashtest.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       HashTest.cpp

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"



DECLARE_DEBUG_PRINTS_OBJECT();


#define HASHTEST_STATIC_DATA
#include "WordHash.h"
#include "IniFile.h"


void test_iterators(unsigned highload, int initsize, int nsubtbls,
                    int nInsertIfNotFound);

#ifdef LKR_STL_ITERATORS
#pragma message("test STL iterators")
void test_stl_iterators(unsigned highload, int initsize, int nsubtbls);
#endif // LKR_STL_ITERATORS

#ifndef LKRHASH_KERNEL_MODE
void print_table_statistics(const CLKRHashTableStats& stats);

# ifdef LOCK_INSTRUMENTATION
void print_lock_statistics(const CLKRHashTableStats &stats);
# endif
#endif // !LKRHASH_KERNEL_MODE

int  expand_key_set(int maxkeys, int numkeys, bool fVerbose) ;
#ifdef LKRHASH_KERNEL_MODE
void
#else
unsigned __stdcall
#endif
exercise_table(void *pinput);


// how many CPUs on this machine?
int
NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
#ifdef LKRHASH_KERNEL_MODE
        s_nCPUs = KeNumberProcessors;
#else  // !LKRHASH_KERNEL_MODE
        SYSTEM_INFO si;
        
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
#endif // !LKRHASH_KERNEL_MODE
    }
    return s_nCPUs;
}



// globals
int        g_nokeys=0 ;
CWord      g_wordtable[MAXKEYS];


bool
CheckRefCounts(
    LONG nRef,
    int iFirst =  0,
    int iLast  = -1)
{
    if (iLast == -1)
        iLast = g_nokeys;
    
    IRTLTRACE3("\nCheckRefCounts(%d, [%d,%d))\n", nRef, iFirst, iLast);
    bool f = true;

    for (int i = iFirst;  i != iLast;  ++i)
    {
        f = f && (g_wordtable[i].m_cRefs == nRef);
        if (g_wordtable[i].m_cRefs != nRef)
            IRTLTRACE4("\nCRC: %d, %hs, expected %d, got %d\n",
                      i, g_wordtable[i].m_str.m_psz, nRef,
                      g_wordtable[i].m_cRefs);
        IRTLASSERT(g_wordtable[i].m_cRefs == nRef);
    }

    return f;
}


bool CWordHash::sm_fCaseInsensitive = true;
bool CWordHash::sm_fMemCmp    = false;
int  CWordHash::sm_nLastChars = 16;
bool CWordHash::sm_fRefTrace  = false;
bool CWordHash::sm_fMultiKeys = false;
bool CWordHash::sm_fUseLocks  = true;
bool CWordHash::sm_fNonPagedAllocs = true;


struct thread_data
{
    CWordHash* ptbl ;

    int      threadno ;
    int      first_key ;
    int      last_key ;
    int      rounds ;
    int      lookup_freq ;
    unsigned highload ;

    int      cinserts ;
    int      cdeletes ;
    int      clookups ;
    int      cfailures ;
    int      m_nInsertIfNotFound;
    int      m_nFindKeyCopy;
    int      m_nSeed;            // random seed

    double   duration ;
    HANDLE   hevFinished;
    HANDLE   hThread;
} ;



const TCHAR*
CommaNumber(
    int n,
    TCHAR* ptszBuff)
{
    TCHAR* ptsz = ptszBuff;
    TCHAR  tchComma = '\0';

    int aThousands[4];
    int iThousands = 0;
    unsigned int u = n;

    if (n < 0)
    {
        *ptsz++ = '-';
        u = -n;
    }

    do {
        aThousands[iThousands++] = u % 1000;
        u /= 1000;
    } while (u != 0);

    while (--iThousands >= 0)
    {
        u = aThousands[iThousands];

        if (tchComma)
            *ptsz++ = tchComma;

        unsigned d = u % 10;
        u /= 10;
        unsigned t = u % 10;
        u /= 10;
        unsigned h = u;

        if (h > 0  ||  tchComma)
            *ptsz++ = (TCHAR) (h + '0');
        if (t > 0  ||  h > 0  ||  tchComma)
            *ptsz++ = (TCHAR) (t + '0');
        *ptsz++ = (TCHAR) (d + '0');

        tchComma = ',';
    }

    *ptsz = '\0';
        
    return ptszBuff;
}


#ifndef LKRHASH_KERNEL_MODE

typedef union {
    FILETIME ft;
    __int64  l64;
} FILETIME_UINT64;

# define FILETIME_1_SECOND     10000000
# define FILETIME_1_MILLISECOND   10000

HANDLE
HashTestCreateEvent()
{
    return CreateEvent(NULL,     // no security attributes
                       FALSE,    // auto reset
                       FALSE,    // not signalled
                       NULL);    // no name
}

void
HashTestResumeThread(
    HANDLE hThread)
{
    ResumeThread(hThread);
}

HANDLE
HashTestCreateThread(
    unsigned (__stdcall * pfnThreadProc) (void *),
    void* pvContext,
    bool  fSuspended)
{
    unsigned dummy;
    return (HANDLE) _beginthreadex(NULL, 0, pfnThreadProc, pvContext,
                                   fSuspended ? CREATE_SUSPENDED : 0,
                                   &dummy); 
}

DWORD
HashTestWaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles)
{
    return WaitForMultipleObjects(nCount, lpHandles, TRUE, INFINITE);
}

#else // LKRHASH_KERNEL_MODE

# define GetTickCount()         NtGetTickCount()
# define GetCurrentThread()     NtCurrentThread()

void
SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    )
{
    NtSetInformationThread(
                hThread,
                ThreadIdealProcessor,
                &dwIdealProcessor,
                sizeof(dwIdealProcessor)
                );
}

// non-threadsafe implementation of rand and srand, stolen from CRT
unsigned long _holdrand = 1234567890;

void __cdecl
srand(
    unsigned int seed)
{
    _holdrand = (unsigned long) seed;
}


int __cdecl
rand()
{
    return ((_holdrand = _holdrand * 214013L + 2531011L) >> 16) & 0x7fff;
}

HANDLE
HashTestCreateEvent()
{
    HANDLE hEvent = NULL;

    NTSTATUS status = NtCreateEvent(
        &hEvent,
        EVENT_ALL_ACCESS,
        NULL,
        SynchronizationEvent,
        FALSE);
    
    return hEvent;
}

void
HashTestResumeThread(
    HANDLE hThread)
{
    NtResumeThread(hThread, NULL);
}

HANDLE
HashTestCreateThread(
    void (* pfnThreadProc) (void *),
    void* pvContext,
    bool  fSuspended)
{
    NTSTATUS status;
    HANDLE threadHandle;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Create the thread.
    //
    
    InitializeObjectAttributes(
        &objectAttributes,             // ObjectAttributes
        NULL,                          // ObjectName
        OBJ_KERNEL_HANDLE,             // Attributes
        NULL,                          // RootDirectory
        NULL                           // SecurityDescriptor
        );
    
    status = PsCreateSystemThread(
        &threadHandle,                 // ThreadHandle
        THREAD_ALL_ACCESS,             // DesiredAccess
        &objectAttributes,             // ObjectAttributes
        NULL,                          // ProcessHandle
        NULL,                          // ClientId
        pfnThreadProc,                 // StartRoutine
        pvContext                      // StartContext
        );

    if (!fSuspended)
        HashTestResumeThread(threadHandle);

    return threadHandle;
}

BOOL
CloseHandle(
    HANDLE h)
{
    return NT_SUCCESS(NtClose(h));
}

DWORD
HashTestWaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles)
{
    HANDLE ahHandles[MAX_THREADS+1];

    for (int i = 0;  i < nCount;  ++i)
        ahHandles[i] = lpHandles[i];
    
    return NtWaitForMultipleObjects((CHAR) nCount, ahHandles,
                                    WaitAll, FALSE, NULL);
}

BOOL
SetEvent(
    HANDLE hEvent)
{
    return NT_SUCCESS(NtSetEvent(hEvent, NULL));
}

#endif // LKRHASH_KERNEL_MODE



#ifdef _M_IX86
// Use RDTSC to read timestamp
void
GetCycleCount(
	LARGE_INTEGER *pliTimeStamp)
{
	ULONG Lo;
	LONG Hi;
	
	_asm {
		_emit 0x0f
		_emit 0x31
		mov Lo, eax
		mov Hi, edx
	} /* _asm */
	pliTimeStamp->LowPart = Lo;
	pliTimeStamp->HighPart = Hi;
}
#endif // _M_IX86


int
LKR_TestHashTable(
    CIniFileSettings& ifs)
{
    CWordHash    *pTbl ;
    int          num_threads ;
    thread_data  de_area[MAX_THREADS] ;
    HANDLE       ahEvents[MAX_THREADS];
    TCHAR        tsz[1024] ;
    FILE        *fp ;
    int          keys_per_thread ;
    int          i ;
    int          sum_ins, sum_dels, sum_lookups ;
    int          failures = 0, total_failures = 0;
    bool         fVerbose = false;
    double       dblSumDuration3 = 0;
    DWORD        dwRunTime = GetTickCount();
    int          nBaseOps = 0;

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("hashtest");
#endif

    SetThreadIdealProcessor(GetCurrentThread(), 0);

    _tprintf(_TEXT("\nTest driver for LKRhash\n")
#ifdef LKRHASH_KERNEL_MODE
           _TEXT(" (Kernel)")
#endif
#ifdef IRTLDEBUG
           _TEXT(" (Debug)")
#endif
#ifdef LKR_PUBLIC_API
           _TEXT(" (Public API)")
#else
           _TEXT(" (Internal API)")
#endif
#ifdef LKR_COUNTDOWN
           _TEXT(" (CountDown)")
#else
           _TEXT(" (CountUp)")
#endif
#ifdef LKR_INDEX_HIBITS
           _TEXT(" (Index hibits)\n")
#else
           _TEXT(" (No Index hibits)\n")
#endif
#ifdef LKR_CONTRACT
           _TEXT(" (Contraction)")
#else
           _TEXT(" (No Contraction)")
#endif
#ifdef LKR_HYSTERESIS
           _TEXT(" (Hysteresis)")
#else
           _TEXT(" (No Hysteresis)")
#endif
#ifdef LKR_CONTRACT_BY_DIVISION
           _TEXT(" (Contract: B > R/L)\n")
#else
           _TEXT(" (Contract: R < L*B)\n")
#endif
#ifdef LKR_EXPAND_BY_DIVISION
           _TEXT(" (Expand: B < R/L)")
#else
           _TEXT(" (Expand: R > L*B)")
#endif
#ifdef LKR_EXPAND_CALC_FREELIST
           _TEXT(" (Expand: Calc)")
#else
           _TEXT(" (Expand: No Calc)")
#endif
#ifdef LKR_ALLOC_STATS
           _TEXT(" (Alloc stats)")
#else
           _TEXT(" (No Alloc stats)")
#endif
#ifdef LKR_OPS_STATS
           _TEXT(" (Ops stats)\n")
#else
           _TEXT(" (No Ops stats)\n")
#endif
#ifdef LKR_ALLOW_NULL_RECORDS
           _TEXT(" (NULL records)")
#endif
#ifdef LKR_DEPRECATED_ITERATORS
           _TEXT(" (Deprecated Iterators)")
#endif
#ifdef LKR_STL_ITERATORS
           _TEXT(" (STL-style Iterators")
# if LKR_STL_ITERATORS >= 2
           _TEXT(", verbose)")
# else
           _TEXT(")")
# endif
#else // !LKR_STL_ITERATORS
           _TEXT(" (No STL-style Iterators)")
#endif // !LKR_STL_ITERATORS
#ifdef LKR_APPLY_IF
           _TEXT(" (ApplyIf)\n")
#else
           _TEXT(" (No ApplyIf)\n")
#endif
#ifdef LKR_USE_BUCKET_LOCKS
           _TEXT(" (Use Bucket Locks)")
#else
           _TEXT(" (No Bucket Locks)")
#endif
#ifdef LKR_EXPOSED_TABLE_LOCK
           _TEXT(" (Exposed Table Lock)")
#endif
#ifdef LOCKS_SWITCH_TO_THREAD
           _TEXT(" (SwitchToThread)\n")
#else
           _TEXT(" (Sleep)\n")
#endif
#ifdef LOCK_NO_INTERLOCKED_TID
           _TEXT(" (non-interlocked Tid)")
#else // !LOCK_NO_INTERLOCKED_TID
           _TEXT(" (interlocked Tid)")
#endif // !LOCK_NO_INTERLOCKED_TID
#ifdef LOCK_ASM
           _TEXT(" (Locks: ASM)")
#else // !LOCK_ASM
           _TEXT(" (Locks: no ASM)")
#endif // !LOCK_ASM
           _TEXT("\n\n")
           ) ;

#if defined(LKRHASH_ACACHE)
    const TCHAR tszAllocator[] = _TEXT("ACache");
#elif defined(LKRHASH_ROCKALL_FAST)
    const TCHAR tszAllocator[] = _TEXT("Rockall FAST_HEAP");
#elif defined(LKRHASH_PAGEDHEAP)
    const TCHAR tszAllocator[] = _TEXT("CPagedHeap");
#elif defined(LKRHASH_NONPAGEDHEAP)
    const TCHAR tszAllocator[] = _TEXT("CNonPagedHeap");
#elif defined(LKRHASH_NONPAGEDLOOKASIDE)
    const TCHAR tszAllocator[] = _TEXT("CNonPagedLookasideList");
#elif defined(LKRHASH_PAGEDLOOKASIDE)
    const TCHAR tszAllocator[] = _TEXT("CPagedLookasideList");
#else
    const TCHAR tszAllocator[] =
        _TEXT("Default allocator (global operator new)");
#endif

    _tprintf(_TEXT("%s version.\n"), tszAllocator);

    IrtlSetDebugOutput(ifs.m_fDebugSpew ? 1 : 0);

#ifdef SAMPLE_LKRHASH_TESTCLASS
    Test(fVerbose);
    if (fVerbose)
        _tprintf(_TEXT("Test succeeded\n"));
#else
    UNREFERENCED_PARAMETER(fVerbose);
#endif // SAMPLE_LKRHASH_TESTCLASS

    fp = _tfopen(ifs.m_tszDataFile, _TEXT("r") ) ;
    if (fp == NULL)
    {
        _tprintf(_TEXT("Can't open file `%s'.\n"), ifs.m_tszDataFile) ;
        return 1;
    }

    char sz[1024];

    _tprintf(_TEXT("Reading `%s' "), ifs.m_tszDataFile);
    for (g_nokeys = 0;  g_nokeys < ifs.m_nMaxKeys;  )
    {
        if (fgets(sz, sizeof(sz)/sizeof(sz[0]), fp) == NULL)
            break;
        int cch = strlen(sz);
        // TODO: check for duplicates
        if (cch > 0  &&  sz[cch-1] == '\n')
            sz[--cch] = '\0';
        if (cch >= MAX_STRSIZE)
            sz[MAX_STRSIZE-1] = '\0';
        if (cch > 0)
        {
            g_wordtable[g_nokeys].m_iIndex = g_nokeys;
            g_wordtable[g_nokeys++].m_str.Set(sz, cch);
        }
        if (g_nokeys % 10000 == 0)
            putchar('.');
    }

    fclose(fp) ;

    _tprintf(_TEXT("\nLoaded %s keys from `%s', \n\t"),
             CommaNumber(g_nokeys, tsz), ifs.m_tszDataFile);
    g_nokeys = expand_key_set(ifs.m_nMaxKeys, g_nokeys, true) ;
    _tprintf(_TEXT(" expanded to %s keys.\n\n"),
             CommaNumber(g_nokeys, tsz));

    int cchTotal = 0, cchMin = INT_MAX, cchMax = 0;
    for (i = 0;  i < g_nokeys;  ++i)
    {
        cchTotal += g_wordtable[i].m_str.m_cch;
        cchMin    = min(cchMin, g_wordtable[i].m_str.m_cch);
        cchMax    = max(cchMax, g_wordtable[i].m_str.m_cch);
    }

    srand(ifs.m_nSeed) ;

    _stprintf(tsz, _TEXT("%d"), ifs.m_nInitSize);
    if (ifs.m_nInitSize == LK_SMALL_TABLESIZE)
        _tcscpy(tsz, _TEXT("small"));
    else if (ifs.m_nInitSize == LK_MEDIUM_TABLESIZE)
        _tcscpy(tsz, _TEXT("medium"));
    else if (ifs.m_nInitSize == LK_LARGE_TABLESIZE)
        _tcscpy(tsz, _TEXT("large"));

    DWORD initsize2 = ifs.m_nInitSize;
    DWORD nsubtbls2 = ifs.m_nSubTables;
    LK_TABLESIZE lkts = CWordHash::NumSubTables(ifs.m_nInitSize, nsubtbls2);
    
    _tprintf(_TEXT("Max load=%d, initsize=%s, ")
             _TEXT("%d subtables (%d tables, size=%d, lkts=%d).\n"),
             ifs.m_nHighLoad, tsz,
             ifs.m_nSubTables, nsubtbls2, initsize2, lkts);
    _tprintf(_TEXT("Lookup freq = %d, %d-%d threads, ")
             _TEXT("%d round%s.\n"),
             ifs.m_nLookupFreq, ifs.m_nMinThreads, ifs.m_nMaxThreads,
             ifs.m_nRounds, (ifs.m_nRounds==1 ? "" : "s"));
    _tprintf(_TEXT("%s keys from `%s'.\n"),
             CommaNumber(g_nokeys, tsz), ifs.m_tszDataFile);
    _tprintf(_TEXT("Key length: avg = %d, min = %d, max = %d.\n"),
             cchTotal / g_nokeys, cchMin, cchMax);
    _tprintf(_TEXT("Base Table = %s. Hash method = %s.\n"),
             CWordHash::ClassName(), CWordHash::HashMethod());
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
# ifdef LKRHASH_GLOBAL_LOCK
    _tprintf(_TEXT("GlobalLock = %s, ")
             _TEXT("%d bytes, ")
             _TEXT("Spin Count = %hd, ")
             _TEXT("Adj Factor = %.2f.\n"),
             CWordHash::GlobalLock::ClassName(),
             sizeof(CWordHash::GlobalLock),
             ifs.m_wTableSpin,
             CWordHash::GlobalLock::GetDefaultSpinAdjustmentFactor());
# endif
    _tprintf(_TEXT("TableLock = %s, ")
             _TEXT("%d bytes, ")
             _TEXT("Spin Count = %hd, ")
             _TEXT("Adj Factor = %.2f.\n"),
             CWordHash::TableLock::ClassName(),
             sizeof(CWordHash::TableLock),
             ifs.m_wTableSpin,
             CWordHash::TableLock::GetDefaultSpinAdjustmentFactor());
    
    _tprintf(_TEXT("BucketLock = %s, ")
             _TEXT("%d bytes, ")
             _TEXT("Spin Count = %hd, ")
             _TEXT("Adj Factor = %.2f.\n"),
             CWordHash::BucketLock::ClassName(),
             sizeof(CWordHash::BucketLock),
             ifs.m_wBucketSpin,
             CWordHash::BucketLock::GetDefaultSpinAdjustmentFactor());
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
    
#ifdef LOCK_PER_LOCK_SPINCOUNTS
    _tprintf(_TEXT("Per"));
#else
    _tprintf(_TEXT("No per"));
#endif
    _tprintf(_TEXT("-lock spincounts.  #CPUs = %d.  Random seed = %d.  ")
             _TEXT("Nodes/Clump = %d.\n"),
             NumProcessors(), ifs.m_nSeed,
             CWordHash::NODES_PER_CLUMP
             );

    _tprintf(_TEXT("InsertIfNotFound = %d, FindKeyCopy = %d, ")
             _TEXT("MultiKeys=%d, UseLocks=%d\n"),
             ifs.m_nInsertIfNotFound, ifs.m_nFindKeyCopy,
             ifs.m_fMultiKeys, ifs.m_fUseLocks);
    _tprintf(_TEXT("NonPagedAllocs=%d, RefTrace=%d, ")
             _TEXT("DebugSpew=%d, Allocator=%s.\n"),
             ifs.m_fNonPagedAllocs, ifs.m_fRefTrace,
             ifs.m_fDebugSpew, CLKRhashAllocator::ClassName());

#ifndef LKRHASH_KERNEL_MODE
	time_t tmNow;
	time(&tmNow);

    _tprintf(_TEXT("\nRun: %s\n\n"), _tctime(&tmNow));
#endif // !LKRHASH_KERNEL_MODE

    if (ifs.m_fTestIterators)
    {
        test_iterators(ifs.m_nHighLoad, ifs.m_nInitSize,
                       ifs.m_nSubTables, ifs.m_nInsertIfNotFound);
#ifdef LKR_STL_ITERATORS
        test_stl_iterators(ifs.m_nHighLoad, ifs.m_nInitSize,
                           ifs.m_nSubTables);
#endif // LKR_STL_ITERATORS
    }

#ifndef LKRHASH_KERNEL_MODE
# ifdef _INC_MMSYSTEM
    // set multimedia timer's period to be 1 millisecond (or the closest
    // approximation that the hardware can manage). This is usually more
    // accurate than GetTickCount. I have had very dubious results from
    // QueryPerformanceCounter on multiprocessor machines, including
    // negative(!) durations (timer skew between processors?)
    timeBeginPeriod(1);
# endif // _INC_MMSYSTEM
#endif // !LKRHASH_KERNEL_MODE

    _tprintf(_TEXT("Starting threads...\n\n"));

    int nTotalOps = 0;
    int step = (ifs.m_nMinThreads <= ifs.m_nMaxThreads) ? +1 : -1;

    dwRunTime = GetTickCount() - dwRunTime;

    for (num_threads =  ifs.m_nMinThreads;
         num_threads != ifs.m_nMaxThreads + step;
         num_threads += step )
    {
        IRTLTRACE1("\nStarting %8d\n", num_threads);

        pTbl = new CWordHash(ifs.m_nHighLoad, ifs.m_nInitSize,
                             ifs.m_nSubTables) ;
        pTbl->SetTableLockSpinCount(ifs.m_wTableSpin);
        pTbl->SetBucketLockSpinCount(ifs.m_wBucketSpin);

        keys_per_thread = g_nokeys/num_threads ;
        for (i = 0; i < num_threads; i++)
        {
            de_area[i].ptbl        = pTbl ;
            de_area[i].threadno    = i+1 ;
            de_area[i].first_key   = i*keys_per_thread ;
            de_area[i].last_key    = ((i == num_threads - 1)
                                      ? g_nokeys
                                      : (i+1)*keys_per_thread) ;
            de_area[i].rounds      = ifs.m_nRounds ;
            de_area[i].highload    = ifs.m_nHighLoad ;
            de_area[i].lookup_freq = ifs.m_nLookupFreq ;
            de_area[i].m_nInsertIfNotFound = ifs.m_nInsertIfNotFound;
            de_area[i].m_nFindKeyCopy = ifs.m_nFindKeyCopy;
            de_area[i].m_nSeed     = ifs.m_nSeed;
            de_area[i].hevFinished = HashTestCreateEvent();
            IRTLASSERT(de_area[i].hevFinished != NULL);
            ahEvents[i] = de_area[i].hevFinished;

            de_area[i].hThread = HashTestCreateThread(exercise_table,
                                                      &de_area[i], true);
        }

#ifndef LKRHASH_KERNEL_MODE
# ifdef _INC_MMSYSTEM
        DWORD dwMMT1 = timeGetTime();
# endif // _INC_MMSYSTEM
#endif // !LKRHASH_KERNEL_MODE
        
        for (i = 0; i < num_threads; i++)
        {
            HashTestResumeThread(de_area[i].hThread);
            CloseHandle(de_area[i].hThread);
        }

        DWORD dw = HashTestWaitForMultipleObjects(num_threads, ahEvents);
        UNREFERENCED_PARAMETER(dw);

#ifndef LKRHASH_KERNEL_MODE
# ifdef _INC_MMSYSTEM
        DWORD dwMMT2 = timeGetTime();
# endif // _INC_MMSYSTEM
#endif // !LKRHASH_KERNEL_MODE

        for (i = 0; i < num_threads; i++)
            CloseHandle(ahEvents[i]);

#ifndef LKRHASH_KERNEL_MODE
# ifdef _INC_MMSYSTEM
        double duration3 = double(dwMMT2 - dwMMT1) / 1000.0;
        dblSumDuration3 += duration3;

        dwRunTime += dwMMT2 - dwMMT1;
# else
        dblSumDuration3 = 1.0;
# endif // _INC_MMSYSTEM
#endif // !LKRHASH_KERNEL_MODE

        sum_ins = sum_dels = sum_lookups = 0 ;

        for (i = 0; i < num_threads; i++)
        {
            sum_ins     += de_area[i].cinserts ;
            sum_dels    += de_area[i].cdeletes ;
            sum_lookups += de_area[i].clookups ;
            failures    += de_area[i].cfailures ;
        }
        int nOps = sum_ins + sum_dels + sum_lookups;

        total_failures += failures;
        nTotalOps += nOps;  // TODO: weight?

#ifdef LKRHASH_KERNEL_MODE
#else // !LKRHASH_KERNEL_MODE
# ifdef _INC_MMSYSTEM
        int nOpsRate3 = (int)(nOps / duration3);

        if (num_threads == ifs.m_nMinThreads)
            nBaseOps = nOpsRate3;

        TCHAR tszSumIns[16], tszSumDels[16], tszSumLookups[16];
        TCHAR tszNOps3[16];
# else
        UNREFERENCED_PARAMETER(nBaseOps);
# endif // _INC_MMSYSTEM

#ifndef LOCK_INSTRUMENTATION
        if (num_threads == ifs.m_nMinThreads)
#endif // LOCK_INSTRUMENTATION
        {
            _tprintf(_TEXT("%5s %10s %9s %6s")
                     _TEXT("%8s %8s %8s\n"),
                     _TEXT("Thrds"), _TEXT("Ops/sec"),
                     _TEXT("Duration"), _TEXT("Ratio"),
                     _TEXT("Inserts"), _TEXT("Deletes"), _TEXT("Lookups"));
        }

# ifdef _INC_MMSYSTEM
        TCHAR tszSummary[200];

        _stprintf(tszSummary, _TEXT("%5d %10s %9.3f %6.3f")
                  _TEXT("%7sK %7sK %7sK\n"),
                  num_threads,
                  CommaNumber(nOpsRate3, tszNOps3),
                  duration3,
                  double(nOpsRate3) / double(nBaseOps),
                  CommaNumber((sum_ins + 500) / 1000,     tszSumIns),
                  CommaNumber((sum_dels + 500) / 1000,    tszSumDels),
                  CommaNumber((sum_lookups + 500) / 1000, tszSumLookups)
                  );
        _tprintf("%s", tszSummary);
        IRTLTRACE1("%s", tszSummary);
# endif // _INC_MMSYSTEM

        if (failures != 0)
            _tprintf(_TEXT("%d failed operations!\n"), failures);
#endif // !LKRHASH_KERNEL_MODE

#ifdef LOCK_INSTRUMENTATION
        print_lock_statistics(pTbl->GetStatistics());
 #ifdef LKRHASH_GLOBAL_LOCK
        CWordHash::GlobalLock::ResetGlobalStatistics();
 #endif
        CWordHash::BucketLock::ResetGlobalStatistics();
        CWordHash::TableLock::ResetGlobalStatistics();
        _tprintf(_TEXT("\n"));
#endif

        pTbl->Destroy();
    }

    TCHAR tszNTotalOps3[16];
    _tprintf(_TEXT("\nAverage Ops = %s. RunTime = %d:%02d.%03d.\n"),
             CommaNumber(int(nTotalOps / dblSumDuration3), tszNTotalOps3),
             dwRunTime / 60000, (dwRunTime / 1000) % 60, dwRunTime % 1000);

    if (total_failures != 0)
        _tprintf(_TEXT("%d total failed operations!\n"), total_failures);

#ifndef LKRHASH_KERNEL_MODE
# ifdef _INC_MMSYSTEM
    timeEndPeriod(1);
# endif // _INC_MMSYSTEM
#endif // !LKRHASH_KERNEL_MODE

    return 0;
} // LKR_TestHashTable



void test_iterators(
    unsigned highload,
    int      initsize,
    int      nsubtbls,
    int      nInsertIfNotFound)
{
    _tprintf(_TEXT("Testing iterators...\n"));

    int i;
    CWordHash *pTbl = new CWordHash(highload, initsize, nsubtbls) ;
    LK_RETCODE lkrc;

    IRTLASSERT(0 == pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    IRTLTRACE0("Table is empty.  Building...\n");

    int cInsertIfNotFounds = 0;
    
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        lkrc = pTbl->InsertRecord(&g_wordtable[i], false);
        if (lkrc != LK_SUCCESS)
            IRTLTRACE3("i = %d, word = `%hs', lkrc = %d\n",
                       i, g_wordtable[i].m_str.m_psz, lkrc);
        IRTLASSERT(lkrc == LK_SUCCESS);

#ifdef LKR_EXPOSED_TABLE_LOCK
        if (nInsertIfNotFound > 0  &&   rand() % nInsertIfNotFound == 0)
        {
            pTbl->WriteLock();

            int    x        = rand() % g_nokeys;
            CStr*  pstrKey1 = &g_wordtable[x].m_str;
            CWord* pRec1    = NULL;

            lkrc = pTbl->FindKey(pstrKey1, &pRec1);

            if (pRec1 != NULL)
            {
                IRTLASSERT(lkrc == LK_SUCCESS);
                IRTLASSERT(pRec1 == &g_wordtable[x]);
                IRTLASSERT(x <= i);
                --g_wordtable[x].m_cRefs;
            }
            else
            {
                ++cInsertIfNotFounds;
                IRTLASSERT(x > i);
                IRTLASSERT(lkrc == LK_NO_SUCH_KEY);

                lkrc = pTbl->InsertRecord(&g_wordtable[x], false);
                IRTLASSERT(lkrc == LK_SUCCESS);
                InterlockedIncrement(&g_wordtable[x].m_cInsertIfNotFounds);

                lkrc = pTbl->DeleteKey(&g_wordtable[x].m_str);
                IRTLASSERT(lkrc == LK_SUCCESS);
            }
            
            pTbl->WriteUnlock();
        }
#endif // LKR_EXPOSED_TABLE_LOCK
    }

    IRTLTRACE1("cInsertIfNotFounds = %d\n", cInsertIfNotFounds);
    
#ifdef LKR_EXPOSED_TABLE_LOCK
    pTbl->ReadLock();

    IRTLTRACE2("Checking that table has %d records (size = %d)\n",
              g_nokeys, pTbl->Size());
    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    pTbl->ReadUnlock();
#endif // LKR_EXPOSED_TABLE_LOCK

    IRTLTRACE0("Clearing the table\n");
    pTbl->Clear();
    IRTLASSERT(0 == pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    IRTLTRACE0("Seeing what crud is left in the table\n");
    size_t cRec = 0;

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        CStr*  pstrKey  = &g_wordtable[i].m_str;
        CWord* pRec     = NULL;

        lkrc = pTbl->FindKey(pstrKey, &pRec);

        if (pRec != NULL)
        {
            IRTLASSERT(pRec == &g_wordtable[i]);
            --pRec->m_cRefs;
            IRTLTRACE1("%hs\n", g_wordtable[i].m_str.m_psz);
            ++cRec;
        }
    }
    IRTLTRACE1("Found %d records that shouldn't have been there\n", cRec);

    pTbl->Clear();
    pTbl->Destroy();

    pTbl = new CWordHash(highload, initsize, nsubtbls) ;

    IRTLTRACE0("Rebuilding the table\n");
    for (i = 0 ; i < g_nokeys ; i++ )
        IRTLVERIFY(pTbl->InsertRecord(&g_wordtable[i]) == LK_SUCCESS);

    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

#ifdef LKR_DEPRECATED_ITERATORS
    IRTLTRACE0("Checking iterators\n");
    cRec = 0;
    CWordHash::CIterator iter(LKL_READLOCK);
    
    for (lkrc = pTbl->InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         lkrc = pTbl->IncrementIterator(&iter))
    {
        ++cRec;
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();
        
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
        IRTLASSERT(!pRec->m_fIterated);
        pRec->m_fIterated = true;

        if (CWordHash::TableLock::Recursion() != LOCK_NON_RECURSIVE
            &&  CWordHash::BucketLock::Recursion() != LOCK_NON_RECURSIVE)
        {
            // Check that the lock can be safely acquired recursively
            // (the table is already locked by the iterator).
            int x = rand() % g_nokeys;
            CStr*  pstrKey2 = &g_wordtable[x].m_str;
            CWord* pRec2    = NULL;
            LK_RETCODE lkrc2= pTbl->FindKey(pstrKey2, &pRec2);
            IRTLASSERT(lkrc2 == LK_SUCCESS  &&  pRec2 == &g_wordtable[x]);
            if (pRec2 != NULL)
                --pRec2->m_cRefs;
        }
    }
    
    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);
    IRTLASSERT((int) cRec == g_nokeys);

    lkrc = pTbl->CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLASSERT(g_wordtable[i].m_fIterated);
        g_wordtable[i].m_fIterated = false;
    }


    do {
        cRec = rand() % (g_nokeys - 1);
    } while (cRec == 0);
    IRTLTRACE1("Checking abandoning of const iterators after %d iterations\n",
              cRec);

    const CWordHash *pTblConst = pTbl;
    CWordHash::CConstIterator iterConst;

    for (lkrc = pTblConst->InitializeIterator(&iterConst);
         lkrc == LK_SUCCESS;
         lkrc = pTblConst->IncrementIterator(&iterConst))
    {
        if (--cRec == 0)
            break;
        const CStr*  pszKey = iterConst.Key();
        const CWord* pRec   = iterConst.Record();
        
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
    }
    
    IRTLASSERT(lkrc != LK_NO_MORE_ELEMENTS);

    lkrc = pTblConst->CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);
#endif // LKR_DEPRECATED_ITERATORS

    
#ifndef LKRHASH_KERNEL_MODE
    IRTLTRACE0("Gathering statistics\n");
    CLKRHashTableStats stats = pTbl->GetStatistics();
    print_table_statistics(stats);
#endif // !LKRHASH_KERNEL_MODE

#ifdef LOCK_INSTRUMENTATION
    print_lock_statistics(stats);
    CWordHash::BucketLock::ResetGlobalStatistics();
    CWordHash::TableLock::ResetGlobalStatistics();
#endif
    _tprintf(_TEXT("\n"));

    IRTLTRACE0("Cleaning up by hand\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLVERIFY(pTbl->DeleteKey(&g_wordtable[i].m_str) == LK_SUCCESS);
    }
    
    IRTLASSERT(0 == pTbl->Size());

    pTbl->Destroy();
}


#ifdef LKR_STL_ITERATORS

void test_stl_iterators2(
    CWordHash *pTbl);


void test_stl_iterators(
    unsigned highload,
    int      initsize,
    int      nsubtbls)
{
    _tprintf(_TEXT("\nTesting STL iterators...\n"));

    _tprintf(_TEXT("subtable iter = %d, iter = %d\n"),
           sizeof(CLKRLinearHashTable::Iterator),
           sizeof(CLKRHashTable::Iterator));

    int i;
    bool f;
    CWordHash *pTbl;
    CWordHash::iterator iter;
    const int iFirst = 5; //     g_nokeys / 5;
    const int iLast  = 10; // 4 * g_nokeys / 5;

    // pTbl = new CWordHash(highload, initsize, nsubtbls) ;

    IRTLTRACE1("\n\nAbout to create table with %d records\n\n",
               iLast - iFirst);
    pTbl = new CWordHash(&g_wordtable[iFirst], &g_wordtable[iLast],
                        highload, initsize, nsubtbls) ;

    for (iter = pTbl->begin();  iter != pTbl->end();  ++iter)
    {
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();
        CWord&      rRec    = *iter;
        bool        fIterated = rRec.m_fIterated;
        LONG        cRefs   = iter->m_cRefs;

        UNREFERENCED_PARAMETER(pstrKey);
        UNREFERENCED_PARAMETER(pRec);
        UNREFERENCED_PARAMETER(fIterated);
        UNREFERENCED_PARAMETER(cRefs);

        IRTLASSERT(&g_wordtable[iFirst] <= pRec
                   &&  pRec < &g_wordtable[iLast]);
        IRTLASSERT(pRec - g_wordtable == pRec->m_iIndex);
        IRTLASSERT(rRec.m_iIndex == pRec->m_iIndex);
        IRTLTRACE3("\nRecord: %p, %d, %hs\n",
                   pRec, rRec.m_iIndex, pstrKey->m_psz);
    }

    IRTLTRACE1("\n\nAbout to search %d records\n\n", pTbl->Size());
    for (i = iFirst;  i != iLast;  ++i)
    {
        f = pTbl->Find(&g_wordtable[i].m_str, iter);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE2("\n\tFound: %d, %hs\n", i, iter.Key()->m_psz);
    }
        
    f = pTbl->Find(&g_wordtable[iLast].m_str, iter);
    IRTLASSERT(!f);
    IRTLASSERT(iter == pTbl->end());

    i = pTbl->Size();
    IRTLTRACE1("\n\nAbout to erase %d records\n\n", i);

    for (iter = pTbl->begin();  iter != pTbl->end();  --i)
    {
        IRTLTRACE1("\n\terase %d\n", i);
        IRTLVERIFY(pTbl->Erase(iter));
    }

    IRTLASSERT(i == 0);
    IRTLASSERT(pTbl->Size() == 0);
    CheckRefCounts(0);

    IRTLTRACE1("\n\nAbout to insert %d records\n\n", iLast - iFirst);
    for (i = iFirst;  i != iLast;  ++i)
    {
        f = pTbl->Insert(&g_wordtable[i], iter);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE2("\n\tInserted: %d, %hs\n", i, iter.Key()->m_psz);
    }

    // Reset iter so that it isn't pointing to anything, raising its refcount
    iter = pTbl->end();
    CheckRefCounts(1, iFirst, iLast);

    IRTLTRACE1("\n\nAbout to Erase2 %d records\n\n", iLast - iFirst);
    CWordHash::iterator iterBegin = pTbl->begin(), iterEnd = pTbl->end();
    f = pTbl->Erase(iterBegin, iterEnd);
    IRTLASSERT(f  &&  pTbl->Size() == 0);

    CheckRefCounts(0);

    IRTLTRACE1("\n\nAbout to insert %d records, again\n\n", iLast - iFirst);
    for (i = iFirst;  i != iLast;  ++i)
    {
        f = pTbl->Insert(&g_wordtable[i], iter);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE2("\n\tInserted: %d, %hs\n", i, iter.Key()->m_psz);
    }

    // Reset iter so that it isn't pointing to anything, raising its refcount
    iter = pTbl->end();
    CheckRefCounts(1, iFirst, iLast);

    IRTLTRACE1("\nAbout to equalrange and erase2 %d records, backwards\n\n",
               iLast - iFirst);
    for (i = iLast;  --i >= iFirst;  )
    {
        CWordHash::iterator iterLast;

        f = pTbl->EqualRange(&g_wordtable[i].m_str, iter, iterLast);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE3("\n\tEqualRange: %d, \"%hs\", %d\n",
                   i, iter.Key()->m_psz, iter.Record()->m_cRefs);

        f = pTbl->Erase(iter, iterLast);
        IRTLASSERT(f);
        IRTLTRACE1("\n\tErase2d: %d\n", i);
    }

    IRTLASSERT(pTbl->Size() == 0);
    CheckRefCounts(0);

    pTbl->Destroy();

#if 1
    pTbl = new CWordHash(highload, initsize, nsubtbls) ;
#else
    pTbl = new CWordHash(1, // LK_DFLT_MAXLOAD * 6,
                         100000, // LK_SMALL_TABLESIZE,
                         17); // # subtables
#endif

    CheckRefCounts(0);
    
    IRTLTRACE0("Building the table\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        g_wordtable[i].m_fIterated = false;
        IRTLVERIFY(pTbl->InsertRecord(&g_wordtable[i]) == LK_SUCCESS);
    }

    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    test_stl_iterators2(pTbl);

    IRTLTRACE0("Cleaning up by hand\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLVERIFY(pTbl->DeleteKey(&g_wordtable[i].m_str) == LK_SUCCESS);
    }
    
    IRTLASSERT(0 == pTbl->Size());

    pTbl->Destroy();
}



void test_stl_iterators2(
    CWordHash *pTbl)
{
    IRTLTRACE0("Checking STL iterators\n");
    size_t cRec = 0;
    int i;
    
    for (CWordHash::iterator iter = pTbl->begin();
        iter != pTbl->end();
         ++iter)
    {
        ++cRec;
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();

        UNREFERENCED_PARAMETER(pstrKey);
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
        IRTLASSERT(!pRec->m_fIterated);
        pRec->m_fIterated = true;
        // IRTLTRACE3("%d: %p, %hs\n", cRec, pRec, pstrKey->m_psz);
    }
    
    IRTLASSERT((int) cRec == g_nokeys);

    IRTLTRACE1("Checking that all %d records were touched\n", g_nokeys);
    CheckRefCounts(1);

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLASSERT(g_wordtable[i].m_fIterated);
        g_wordtable[i].m_fIterated = false;
    }
}

#endif // LKR_STL_ITERATORS



#ifndef LKRHASH_KERNEL_MODE

void print_table_statistics(const CLKRHashTableStats& stats)
{
    _tprintf(_TEXT("#Records=%d, #BucketChains=%d, ")
           _TEXT("DirSize=%d, LongestChain=%3d,\n"),
           stats.RecordCount, stats.TableSize,
           stats.DirectorySize, stats.LongestChain);
           
    _tprintf(_TEXT("#Empty Buckets=%d, Split Factor=%.2f, ")
           _TEXT("AvgSrchLen=%.2f, Expected SL=%.2f,\n"),
           stats.EmptySlots, stats.SplitFactor,
           stats.AvgSearchLength, stats.ExpSearchLength);

    _tprintf(_TEXT("Avg Unsuccessful SrchLen=%.2f, ExpUSL=%.2f.\n"),
           stats.AvgUSearchLength, stats.ExpUSearchLength);

    _tprintf(_TEXT("\nBucket Chain Lengths ")
           _TEXT("(node clump size = %d, bucket size = %d bytes):\n"),
           stats.NodeClumpSize, stats.CBucketSize);
    for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
    {
        if (stats.m_aBucketLenHistogram[j] == 0)
        {
            _tprintf(_TEXT("\n"));
            break;
        }
        _tprintf(_TEXT(" %10d: %6d"),
               stats.BucketSize(j), stats.m_aBucketLenHistogram[j]);
        if (j % 4 == 3)
            _tprintf(_TEXT("\n"));
    }

    _tprintf(_TEXT("\n"));
}


#ifdef LOCK_INSTRUMENTATION

void print_lock_statistics(const CLKRHashTableStats& stats)
{
    _tprintf(_TEXT("Global Locks Statistics:")
           _TEXT("\n   total locks created = %ld, ")
           _TEXT("total contentions = %ld, ")
           _TEXT("#sleeps = %ld,")
           _TEXT("\n   total spins = %I64d, ")
           _TEXT("av spins/contention = %.1f, ")
           _TEXT("\n   #readlocks = %d, ")
           _TEXT("#writelocks=%d\n"),
           stats.m_gls.m_cTotalLocks,
           stats.m_gls.m_cContendedLocks,
           stats.m_gls.m_nSleeps,
           stats.m_gls.m_cTotalSpins,
           stats.m_gls.m_nAverageSpins,
           stats.m_gls.m_nReadLocks,
           stats.m_gls.m_nWriteLocks
           );

    _tprintf(_TEXT("Averaged SubTable Locks Statistics:")
           _TEXT("\n   Total locks = %d, ")
           _TEXT("#contentions = %.1f, ")
           _TEXT("sleeps = %.1f; ")
           _TEXT("\n   total spins = %.1f, ")
           _TEXT("avg spins = %.1f, ")
           _TEXT("\n   #readlocks = %.1f, ")
           _TEXT("#writelocks=%.1f\n"),
           stats.m_alsTable.m_nItems,
           stats.m_alsTable.m_nContentions,
           stats.m_alsTable.m_nSleeps,
           stats.m_alsTable.m_nContentionSpins,
           stats.m_alsTable.m_nAverageSpins,
           stats.m_alsTable.m_nReadLocks,
           stats.m_alsTable.m_nWriteLocks);

    _tprintf(_TEXT("Averaged Bucket Locks Statistics:")
           _TEXT("\n   Total locks = %d, ")
           _TEXT("#contentions = %.1f, ")
           _TEXT("sleeps = %.1f; ")
           _TEXT("\n   total spins = %.1f, ")
           _TEXT("avg spins = %.1f, ")
           _TEXT("\n   #readlocks = %.1f, ")
           _TEXT("#writelocks=%.1f\n"),
           stats.m_alsBucketsAvg.m_nItems,
           stats.m_alsBucketsAvg.m_nContentions,
           stats.m_alsBucketsAvg.m_nSleeps,
           stats.m_alsBucketsAvg.m_nContentionSpins,
           stats.m_alsBucketsAvg.m_nAverageSpins,
           stats.m_alsBucketsAvg.m_nReadLocks,
           stats.m_alsBucketsAvg.m_nWriteLocks);

    _tprintf(_TEXT("\n"));
}

#endif // LOCK_INSTRUMENTATION

#endif // !LKRHASH_KERNEL_MODE
    
int expand_key_set(int maxkeys, int numkeys, bool fVerbose)
{
    int totkeys = numkeys ;
    if (totkeys > maxkeys)
        return maxkeys;

    char* pszTemp = new char [20 + CStr::sm_cchMax];

    for (int k = 0; ; k++)
    {
        for(int i = 0; i < numkeys; i++)
        {
            if (totkeys == maxkeys)
            {
                delete [] pszTemp;
                return(totkeys) ;
            }

            sprintf(pszTemp, "%d%hs", k, g_wordtable[i].m_str.m_psz);
            g_wordtable[totkeys++].m_str.Set(pszTemp, strlen(pszTemp));
        }

        if (fVerbose)
            putchar('.');
    }
    // notreached
}



#ifdef LKRHASH_KERNEL_MODE
void
#else
unsigned __stdcall
#endif
exercise_table(
    void* pinput)
{
    CWordHash*    pTbl;
    thread_data*  pdea = (thread_data*) pinput ;
    int           cfailed_ins=0 ;
    int           cfailed_dels=0 ;
    int           cFoundSuccesses=0, cFoundFails=0 ;
    int           x, i ;
    LK_RETCODE    lkrc;

    SetThreadIdealProcessor(GetCurrentThread(),
                            pdea->threadno % NumProcessors());

#ifndef LKRHASH_KERNEL_MODE
    LARGE_INTEGER liFreq = {0,0}, liT1 = {0,0}, liT2 = {0,0};
    IRTLVERIFY(QueryPerformanceFrequency(&liFreq));
    IRTLVERIFY(QueryPerformanceCounter(&liT1));
#endif // !LKRHASH_KERNEL_MODE

    pdea->cinserts = 0 ;
    pdea->cdeletes = 0 ;
    pdea->clookups = 0 ;
    pTbl = pdea->ptbl ;
    srand(pdea->m_nSeed);

    for (int rnd = 0; rnd < pdea->rounds; rnd++)
    {
        IRTLASSERT(pTbl->CheckTable() == 0);

        // Insert all the keys, randomly searching after each insertion
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
#ifdef IRTLDEBUG
            CStr*  pstrKey1 = &g_wordtable[i].m_str;
            CWord* pRec1    = NULL;
            lkrc = pTbl->FindKey(pstrKey1, &pRec1);
            IRTLASSERT(lkrc == LK_NO_SUCH_KEY  &&  pRec1 == NULL);
#endif // IRTLDEBUG

            if (pTbl->InsertRecord(&g_wordtable[i] ) != LK_SUCCESS )
            {
                cfailed_ins++ ;
            }
            else
            {
#ifdef IRTLDEBUG
                pstrKey1 = &g_wordtable[i].m_str;
                lkrc = pTbl->FindKey(pstrKey1, &pRec1);
                IRTLASSERT(lkrc == LK_SUCCESS  &&  pRec1 == &g_wordtable[i]);
                pTbl->AddRefRecord(pRec1, LKAR_EXPLICIT_RELEASE);
#endif // IRTLDEBUG

                g_wordtable[i].m_fInserted = true;
            }

            pdea->cinserts++ ;

            for (int lu = 0; lu < pdea->lookup_freq; lu++)
            {
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent = (x <= i); // should it be found?
                CWord* pRec   = NULL;

                if (pdea->m_nFindKeyCopy > 0
                    &&  rand() % pdea->m_nFindKeyCopy == 0)
                {
                    char szTemp[MAX_STRSIZE];
                    strcpy(szTemp, g_wordtable[x].m_str.m_psz);
                    CStr strTemp(szTemp, g_wordtable[x].m_str.m_cch, false);
                    lkrc = pTbl->FindKey(&strTemp, &pRec);
                }
                else
                    lkrc = pTbl->FindKey(&g_wordtable[x].m_str, &pRec);

                if (fPresent)
                {
                    if (lkrc != LK_SUCCESS  ||  pRec != &g_wordtable[x] )
                    {
                        ++g_wordtable[x].m_cNotFound;
                        IRTLTRACE(_TEXT("%d: Not found (%hs): x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz, x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec != NULL ? pRec->m_str.m_psz : "<null>",
                              pRec != NULL ? (pRec - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
#ifdef IRTLDEBUG
                        pTbl->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE);
#else
                        --g_wordtable[x].m_cRefs;
#endif
                        cFoundSuccesses++ ;
                    }
                }
                else // not fPresent
                {
                    IRTLASSERT(lkrc != LK_SUCCESS  &&  pRec == NULL);
                    if (lkrc == LK_SUCCESS  ||  pRec != NULL)
                    {
                        IRTLTRACE(_TEXT("%d: found when not present (%hs): ")
                              _TEXT("x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz,
                              x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec != NULL ? pRec->m_str.m_psz : "<null>",
                              pRec != NULL ? (pRec - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        // wasn't found, but it wasn't present, so this is good
                        cFoundSuccesses++ ;
                    }
                }
            }

            pdea->clookups += pdea->lookup_freq ;
            
#ifdef LKR_EXPOSED_TABLE_LOCK
            if (pdea->m_nInsertIfNotFound > 0
                &&  rand() % pdea->m_nInsertIfNotFound == 0)
            {
                bool fWrite = (rand() & 1) != 0;

                if (fWrite)
                    pTbl->WriteLock();
                else
                    pTbl->ReadLock();
                
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                CStr*  pstrKey2 = &g_wordtable[x].m_str;
                CWord* pRec2    = NULL;
                
                lkrc = pTbl->FindKey(pstrKey2, &pRec2);
                
                if (pRec2 != NULL)
                {
                    IRTLASSERT(lkrc == LK_SUCCESS);
                    IRTLASSERT(pRec2 == &g_wordtable[x]);
                    IRTLASSERT(x <= i);
#ifdef IRTLDEBUG
                    pTbl->AddRefRecord(pRec2, LKAR_EXPLICIT_RELEASE);
#else
                    --g_wordtable[x].m_cRefs;
#endif
                }
                else if (fWrite)
                {
                    IRTLASSERT(x > i);
                    IRTLASSERT(lkrc == LK_NO_SUCH_KEY);

                    lkrc = pTbl->InsertRecord(&g_wordtable[x], false);
                    IRTLASSERT(lkrc == LK_SUCCESS);
                    InterlockedIncrement(&g_wordtable[x].m_cInsertIfNotFounds);
                    
                    lkrc = pTbl->DeleteKey(&g_wordtable[x].m_str);
                    IRTLASSERT(lkrc == LK_SUCCESS);
                }
            
                if (fWrite)
                    pTbl->WriteUnlock();
                else
                    pTbl->ReadUnlock();
            }
#endif // LKR_EXPOSED_TABLE_LOCK
        }

        IRTLASSERT(cfailed_ins == 0) ;
        IRTLASSERT(cFoundFails == 0) ;
        IRTLASSERT(cFoundSuccesses == ((2 * rnd + 1) * pdea->lookup_freq
                              * (pdea->last_key - pdea->first_key)));

        IRTLTRACE(_TEXT("Thrd %u, rnd %d: %d inserts done, not found %d, ")
                  _TEXT("f=%d, l=%d\n"), 
                  pdea->threadno, rnd, pdea->cinserts, cFoundFails,
                  pdea->first_key, pdea->last_key) ;
        IRTLASSERT(pTbl->CheckTable() == 0);

        // Delete all the keys, randomly searching before each deletion
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
            for (int lu = 0; lu < pdea->lookup_freq; lu++)
            {
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent = (x >= i); // should it be found?
                CWord* pRec3  = NULL;

                if (pdea->m_nFindKeyCopy > 0
                    &&  rand() % pdea->m_nFindKeyCopy == 0)
                {
                    char szTemp[MAX_STRSIZE];
                    strcpy(szTemp, g_wordtable[x].m_str.m_psz);
                    CStr strTemp(szTemp, g_wordtable[x].m_str.m_cch, false);
                    lkrc = pTbl->FindKey(&strTemp, &pRec3);
                }
                else
                    lkrc = pTbl->FindKey(&g_wordtable[x].m_str, &pRec3);

                if (fPresent)
                {
                    if (lkrc != LK_SUCCESS  ||  pRec3 != &g_wordtable[x] )
                    {
                        ++g_wordtable[x].m_cNotFound;
                        IRTLTRACE(_TEXT("%d: Not found (%hs): x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz, x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec3 != NULL ? pRec3->m_str.m_psz : "<null>",
                              pRec3 != NULL ? (pRec3 - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
#ifdef IRTLDEBUG
                        pTbl->AddRefRecord(pRec3, LKAR_EXPLICIT_RELEASE);
#else
                        --g_wordtable[x].m_cRefs;
#endif
                        cFoundSuccesses++ ;
                    }
                }
                else // !fPresent
                {
                    IRTLASSERT(lkrc != LK_SUCCESS  &&  pRec3 == NULL);
                    if (lkrc == LK_SUCCESS  ||  pRec3 != NULL)
                    {
                        IRTLTRACE(_TEXT("%d: found when not present (%hs): ")
                              _TEXT("x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz,
                              x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec3 != NULL ? pRec3->m_str.m_psz : "<null>",
                              pRec3 != NULL ? (pRec3 - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        // wasn't found, but it wasn't present, so this is good
                        cFoundSuccesses++ ;
                    }
                }
            }
            pdea->clookups += pdea->lookup_freq ;

#ifdef IRTLDEBUG
            CStr*  pstrKey4 = &g_wordtable[i].m_str;
            CWord* pRec4    = NULL;
            lkrc = pTbl->FindKey(pstrKey4, &pRec4);
            IRTLASSERT(lkrc == LK_SUCCESS  &&  pRec4 == &g_wordtable[i]);
            pTbl->AddRefRecord(pRec4, LKAR_EXPLICIT_RELEASE);
#endif // IRTLDEBUG

            if (pTbl->DeleteKey(&g_wordtable[i].m_str) != LK_SUCCESS )
            {
                cfailed_dels++ ;
            }
            else
            {
#ifdef IRTLDEBUG
                pstrKey4 = &g_wordtable[i].m_str;
                lkrc = pTbl->FindKey(pstrKey4, &pRec4);
                IRTLASSERT(lkrc == LK_NO_SUCH_KEY  &&  pRec4 == NULL);
#endif // IRTLDEBUG

                g_wordtable[i].m_fInserted = false;
            }
            pdea->cdeletes++ ;
        }

#ifdef IRTLDEBUG
        int cBadKeys = 0;
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
            if (g_wordtable[i].m_cNotFound > 0)
            {
                ++cBadKeys;
                IRTLTRACE(_TEXT("%-20hs: #not found = %d, hash = %d, %08x\n"),
                          g_wordtable[i].m_str.m_psz,
                          g_wordtable[i].m_cNotFound,
                          CWordHash::CalcKeyHash(CWordHash::ExtractKey(
                                                 &g_wordtable[i])),
                          CWordHash::CalcKeyHash(CWordHash::ExtractKey(
                                                 &g_wordtable[i])));
            }
        }
        if (cBadKeys > 0)
            IRTLTRACE1("%d bad keys\n", cBadKeys);
        IRTLASSERT(cBadKeys == 0);
#endif // IRTLDEBUG

        IRTLASSERT(cfailed_dels == 0 ) ;
        IRTLASSERT(cFoundFails == 0 ) ;
        IRTLASSERT(cFoundSuccesses == ((2 * rnd + 2) * pdea->lookup_freq
                              * (pdea->last_key - pdea->first_key)));
        IRTLTRACE(_TEXT("Thrd %u, rnd %d: %d deletes done, not found %d, ")
                  _TEXT("f=%d, l=%d\n"), 
                  pdea->threadno, rnd, pdea->cdeletes, cFoundFails,
                  pdea->first_key, pdea->last_key) ;
    } // (for rnd)

#ifndef LKRHASH_KERNEL_MODE
    IRTLVERIFY(QueryPerformanceCounter(&liT2));
    pdea->duration = (liT2.QuadPart-liT1.QuadPart) / (double) liFreq.QuadPart;
#endif // !LKRHASH_KERNEL_MODE

    IRTLASSERT(pTbl->CheckTable() == 0);

    IRTLTRACE3("Thread %u terminating: %d found, %d not found\n",
              pdea->threadno, cFoundSuccesses, cFoundFails) ;

    if (cFoundSuccesses != (2 * pdea->rounds * pdea->lookup_freq
                   * (pdea->last_key - pdea->first_key))
        ||  cFoundFails != 0  ||  cfailed_ins != 0  ||  cfailed_dels != 0)
    {
        _tprintf(_TEXT("Thread %u: found = %d, not found = %d, ")
               _TEXT("\nfailed inserts = %d, failed deletes = %d\n"),
               pdea->threadno, cFoundSuccesses, cFoundFails,
               cfailed_ins, cfailed_dels);
    }

    pdea->cfailures = cfailed_ins + cfailed_dels + cFoundFails;

    if (pdea->hevFinished != NULL)
        SetEvent(pdea->hevFinished);

#ifndef LKRHASH_KERNEL_MODE
    return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\hashtest\inifile.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       IniFile.cpp

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"
#include "WordHash.h"
#include "IniFile.h"


enum INI_TYPE {
    INI_WORD = 1,
    INI_DWORD,
    INI_DOUBLE,
    INI_STRING,
    INI_BOOL,
};

typedef struct _ParseOptions {
    int         m_nFieldOffset;
    const char* m_pszName;
    unsigned    m_cchName;
    INI_TYPE    m_type;
    DWORD_PTR   m_default;
} ParseOptions;

#define INI_ENTRY(_member, _name, _type, _default)  \
    {                                               \
        FIELD_OFFSET(CIniFileSettings, _member),    \
        _name,                                      \
        sizeof(_name)-1,                            \
        _type,                                      \
        (DWORD_PTR) _default,                       \
    }                                               \

static const ParseOptions g_po[] = {
    INI_ENTRY(m_tszDataFile,  "DataFile",       INI_STRING, _TEXT("??")),
    INI_ENTRY(m_nMaxKeys,     "MaxKeys",        INI_DWORD,  MAXKEYS),
    INI_ENTRY(m_nHighLoad,    "MaxLoadFactor",  INI_DWORD,  LK_DFLT_MAXLOAD),
    INI_ENTRY(m_nInitSize,    "InitSize",       INI_DWORD,  LK_DFLT_INITSIZE),
    INI_ENTRY(m_nSubTables,   "NumSubTables",   INI_DWORD,LK_DFLT_NUM_SUBTBLS),
    INI_ENTRY(m_nLookupFreq,  "LookupFrequency",INI_DWORD,  5),
    INI_ENTRY(m_nMinThreads,  "MinThreads",     INI_DWORD,  1),
    INI_ENTRY(m_nMaxThreads,  "MaxThreads",     INI_DWORD,  4),
    INI_ENTRY(m_nRounds,      "NumRounds",      INI_DWORD,  1),
    INI_ENTRY(m_nSeed,        "RandomSeed",     INI_DWORD,  1234),
    INI_ENTRY(m_fCaseInsensitive,"CaseInsensitive",INI_BOOL, FALSE),
    INI_ENTRY(m_fMemCmp,      "MemCmp",         INI_BOOL,   FALSE),
    INI_ENTRY(m_nLastChars,   "NumLastChars",   INI_DWORD,  0),
    INI_ENTRY(m_wTableSpin,   "TableLockSpinCount",INI_WORD, LOCK_DEFAULT_SPINS),
    INI_ENTRY(m_wBucketSpin,  "BucketLockSpinCount",INI_WORD,LOCK_DEFAULT_SPINS),
    INI_ENTRY(m_dblSpinAdjFctr,"SpinAdjustmentFactor",INI_DOUBLE, 1),
    INI_ENTRY(m_fTestIterators,"TestIterators", INI_BOOL,   FALSE),
    INI_ENTRY(m_nInsertIfNotFound, "InsertIfNotFound",INI_DWORD, 0),
    INI_ENTRY(m_nFindKeyCopy, "FindKeyCopy",    INI_DWORD,  0),
    INI_ENTRY(m_fNonPagedAllocs,"NonPagedAllocs", INI_BOOL, TRUE),
    INI_ENTRY(m_fDebugSpew,    "DebugSpew",     INI_BOOL,   FALSE),
    INI_ENTRY(m_fRefTrace,     "RefTrace",      INI_BOOL,   FALSE),
    INI_ENTRY(m_fMultiKeys,    "MultiKeys",     INI_BOOL,   FALSE),
    INI_ENTRY(m_fUseLocks,     "UseLocks",      INI_BOOL,   TRUE),
    {-1}  // last entry
};


void
CIniFileSettings::Dump(
    LPCTSTR ptszProlog,
    LPCTSTR ptszEpilog) const
{
    TCHAR tsz[50];

    _tprintf(_TEXT("%s\n"), ptszProlog);
    _tprintf(_TEXT("IniFile=\"%s\"\n"),
             m_tszIniFile);
    _tprintf(_TEXT("DataFile=\"%s\". %s keys.\n"),
             m_tszDataFile, CommaNumber(m_nMaxKeys, tsz));
    _tprintf(_TEXT("Max load = %u, initsize = %d, %d subtables.\n"),
             m_nHighLoad, m_nInitSize, m_nSubTables);
    _tprintf(_TEXT("Lookup freq = %d, %d-%d threads, %d round%s.\n"),
             m_nLookupFreq, m_nMinThreads, m_nMaxThreads,
             m_nRounds, (m_nRounds==1 ? "" : "s"));
    _tprintf(_TEXT("Seed=%d, CaseInsensitive=%d, MemCmp=%d, LastChars=%d\n"),
             m_nSeed, m_fCaseInsensitive, m_fMemCmp, m_nLastChars);
    _tprintf(_TEXT("Spin Count: Table = %hd, Bucket = %hd, AdjFactor=%.1f\n"),
             m_wTableSpin, m_wBucketSpin, m_dblSpinAdjFctr);
    _tprintf(_TEXT("TestIterators=%d, InsertIfNotFound=%d, FindKeyCopy=%d\n"),
             m_fTestIterators, m_nInsertIfNotFound, m_nFindKeyCopy);
    _tprintf(_TEXT("NonPagedAllocs=%d, DebugSpew=%d, RefTrace=%d, ")
             _TEXT("MultiKeys=%d, UseLocks=%d\n"),
             m_fNonPagedAllocs, m_fDebugSpew, m_fRefTrace,
             m_fMultiKeys, m_fUseLocks);
    _tprintf(_TEXT("%s\n"), ptszEpilog);
}

#if defined(IRTLDEBUG)
# define DUMP_INIFILE(pifs, Pro, Epi)   pifs->Dump(Pro, Epi)
#else
# define DUMP_INIFILE(pifs, Pro, Epi)   ((void) 0)
#endif


DWORD
ReadFileIntoBuffer(
	LPCTSTR ptszFile,
    PBYTE   pbBuffer,
    DWORD   cbBuffer)
{
#ifndef LKRHASH_KERNEL_MODE
    HANDLE hFile =
        CreateFile(
            ptszFile,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return 0;

    DWORD cbRead = 0, cbFileSizeLow, cbFileSizeHigh;

    cbFileSizeLow = GetFileSize(hFile, &cbFileSizeHigh);

    bool fBadFile =
        (cbFileSizeHigh != 0
         ||  cbFileSizeLow > cbBuffer
         ||  !ReadFile(hFile, pbBuffer, cbFileSizeLow, &cbRead, NULL));

    CloseHandle(hFile);

    return fBadFile  ?  0  :  cbRead;
#else
    return 0;
#endif // !LKRHASH_KERNEL_MODE
}


// Do a case-insensitive match of first `cchStr' chars of ptszBuffer
// against ptszStr. Strings assumed to be alphanumeric
bool
StrMatch(
    LPCSTR   pszBuffer,
    LPCSTR   pszStr,
    unsigned cchStr)
{
    LPCSTR   psz1 = pszBuffer;
    LPCSTR   psz2 = pszStr;
    unsigned i, j;
    bool     fMatch = true;

    for (i = 0;  i < cchStr;  ++i)
    {
        IRTLASSERT(isalnum(*psz1) && isalnum(*psz2));

        if (((*psz1++ ^ *psz2++) & 0xDF) != 0)
        {
            fMatch = false;
            break;
        }
    }

    IRTLTRACE0("\tStrMatch: \"");
    for (j = 0;  j < i + !fMatch;  ++j)
        IRTLTRACE1("%hc", pszBuffer[j]);
    IRTLTRACE0(fMatch ? "\" == \"" : "\" != \"");
    for (j = 0;  j < i + !fMatch;  ++j)
        IRTLTRACE1("%hc", pszStr[j]);
    IRTLTRACE0("\"\n");


    return fMatch;
}


bool
GetNum(
    char*& rpch,
    int&   rn)
{
    int fNegative = ('-' == *rpch);
    rn = 0;

    if (fNegative)
        ++rpch;
    else if (!('0' <= *rpch  &&  *rpch <= '9'))
        return false;

    while ('0' <= *rpch  &&  *rpch <= '9')
        rn = rn * 10 + (*rpch++ - '0');

    if (fNegative)
        rn = -rn;

    return true;
}



bool
GetDouble(
    char*&  rpch,
    double& rdbl)
{
    rdbl = 0;

    IRTLTRACE1("GetDouble(\"%s\")\n", rpch);

    int n;
    bool fValidInt = GetNum(rpch, n);

    if (fValidInt)
    {
        rdbl = n;

        if ('.' == *rpch)
        {
            char* pchFrac = ++rpch;
            fValidInt = GetNum(rpch, n);

            if (fValidInt)
            {
                double scale = 1.;
                int nDigits = rpch - pchFrac;
                while (--nDigits >= 0)
                    scale *= 10.;
                rdbl = (scale * rdbl + n) / scale;
            }
        }
    }

    return fValidInt;
}



bool
GetString(
    char*&   rpch,
    char*    pszOutput,
    unsigned cchOutput)
{
    // TODO: handle quoted strings and trailing blanks

    bool fGotChars = false;
    
    while ('\0' != *rpch  &&  '\r' != *rpch  &&  '\n' != *rpch )
    {
        fGotChars = true;

        if (cchOutput-- > 0)
            *pszOutput++ = *rpch++;
        else
            ++rpch;
    }

    if (cchOutput > 0)
        *pszOutput = '\0';

    return fGotChars;
}
    


// TODO: break the dependency upon g_po.

int
CIniFileSettings::ParseIniFile(
	LPCSTR             pszIniFile)
{
    strncpy(m_tszIniFile, pszIniFile, _MAX_PATH);

    int i, iMaxIndex = -1;
    int cMembers = 0;

    for (i = 0;  ; ++i)
    {
        if (g_po[i].m_nFieldOffset < 0)
        {
            iMaxIndex = i;
            break;
        }

        PBYTE pbMember = g_po[i].m_nFieldOffset + ((BYTE*) this);

        // Initialize the members of `this' with their default values
        switch (g_po[i].m_type)
        {
        case INI_WORD:
            * (WORD*) pbMember = (WORD) g_po[i].m_default;
            break;
        case INI_DWORD:
            * (DWORD*) pbMember = (DWORD) g_po[i].m_default;
            break;
        case INI_DOUBLE:
            * (double*) pbMember = (float) g_po[i].m_default;
            break;
        case INI_STRING:
            strcpy((char*) pbMember, (const char*) g_po[i].m_default);
            break;
        case INI_BOOL:
            * (bool*) pbMember = (bool) (g_po[i].m_default != 0);
            break;
        default:
            IRTLASSERT(! "invalid INI_TYPE");
        }
    }

    DUMP_INIFILE(this, "Before", "");

    BYTE  abBuffer[2049];
    DWORD cbRead = ReadFileIntoBuffer(m_tszIniFile, abBuffer,
                                      sizeof(abBuffer)-1);

    if (cbRead == 0)
    {
        _tprintf(_TEXT("Can't open IniFile `%s'.\n"), m_tszIniFile) ;
        return 0;
    }

    abBuffer[cbRead] = '\0';

    bool  fInSection = false, fSkipLine = false;
    const char szSectionName[] = "HashTest";
    unsigned   cchSectionName = strlen(szSectionName);
    char* pch = (char*) abBuffer;
    char* pszEOB = (char*) (abBuffer + cbRead);

    // parse the in-memory buffer
    while ('\0' != *pch)
    {
        while (' ' == *pch  ||  '\r' == *pch
               ||  '\n' == *pch  ||  '\t' == *pch)
            ++pch;

        if ('\0' == *pch)
            break;

        IRTLTRACE(_TEXT("Line starts with '%hc%hc%hc%hc'\n"),
                  pch[0], pch[1], pch[2], pch[3]);

        // Is this a section name?
        if ('[' == *pch)
        {
            fInSection = false;
            ++pch;
            while (' ' == *pch  ||  '\t' == *pch)
                ++pch;
            if (pch + cchSectionName < pszEOB
                &&  StrMatch(pch, szSectionName, cchSectionName))
            {
                pch += cchSectionName;
                while (' ' == *pch  ||  '\t' == *pch)
                    ++pch;
                if (']' == *pch)
                {
                    ++pch;
                    fInSection = true;
                }
            }
            else
                fSkipLine = true;

            continue;
        }

        // skip comments and entire lines if we're not in the right section
        if (fSkipLine  ||  ';' == *pch  ||  !fInSection)
        {
            // skip to end of line
            while ('\0' != *pch  &&  '\r' != *pch  &&  '\n' != *pch)
            {
                IRTLTRACE1("%hc", *pch);
                ++pch;
            }

            IRTLTRACE0("\n");
            fSkipLine = false;
            continue;
        }

        fSkipLine = true;

        // try to match name=value
        for (i = 0;  i < iMaxIndex;  ++i)
        {
            IRTLASSERT(isalnum(*pch));
            if (pch + g_po[i].m_cchName >= pszEOB
                || !StrMatch(pch, g_po[i].m_pszName, g_po[i].m_cchName))
                continue;

            pch += g_po[i].m_cchName;
            while (' ' == *pch  ||  '\t' == *pch)
                ++pch;
            if ('=' != *pch)
            {
                IRTLTRACE1("'=' not seen after <%hs>\n", g_po[i].m_pszName);
                break;
            }
            ++pch;
            while (' ' == *pch  ||  '\t' == *pch)
                ++pch;

            PBYTE  pbMember = g_po[i].m_nFieldOffset + ((BYTE*) this);
            int    n;
            char   sz[_MAX_PATH];
            double dbl;

            IRTLTRACE1("<%hs>=", g_po[i].m_pszName);

            switch (g_po[i].m_type)
            {
            case INI_WORD:
                if (GetNum(pch, n))
                {
                    IRTLTRACE1("%hu\n", (WORD) n);
                    * (WORD*) pbMember = (WORD) n;
                }
                else
                    IRTLTRACE("bad word\n");
                break;
            case INI_DWORD:
                if (GetNum(pch, n))
                {
                    IRTLTRACE1("%u\n", (DWORD) n);
                    * (DWORD*) pbMember = (DWORD) n;
                }
                else
                    IRTLTRACE("bad dword\n");
                break;
            case INI_DOUBLE:
                if (GetDouble(pch, dbl))
                {
                    IRTLTRACE1("%.1f\n", dbl);
                    * (double*) pbMember = dbl;
                }
                else
                    IRTLTRACE("bad double\n");
                break;
            case INI_STRING:
                if (GetString(pch, sz, sizeof(sz)/sizeof(sz[0])))
                {
                    IRTLTRACE1("%hs\n", sz);
                    strcpy((char*) pbMember, sz);
                }
                else
                    IRTLTRACE("bad string\n");
                break;
            case INI_BOOL:
                if (GetNum(pch, n))
                {
                    IRTLTRACE1("%d\n", n);
                    * (bool*) pbMember = (n != 0);
                }
                else
                    IRTLTRACE("bad bool\n");
                break;
            default:
                IRTLASSERT(! "invalid INI_TYPE");
            }

            ++cMembers;
            fSkipLine = false;
            break;
        }
    }

    DUMP_INIFILE(this, "Parsed", "---");

    return cMembers;
}


void
CIniFileSettings::ReadIniFile(
	LPCTSTR ptszIniFile)
{
    // IrtlSetDebugOutput(1);

    ParseIniFile(ptszIniFile);

    m_nMaxKeys = min(max(1, m_nMaxKeys),  MAXKEYS);
    m_nHighLoad = max(1, m_nHighLoad);
    m_nMinThreads = max(1, m_nMinThreads);
    m_nMaxThreads = min(MAX_THREADS,  max(1, m_nMaxThreads));

    // If we're not using a real lock, then we're not threadsafe
    if (CWordHash::TableLock::LockType() == LOCK_FAKELOCK
        ||  CWordHash::BucketLock::LockType() == LOCK_FAKELOCK)
        m_nMinThreads = m_nMaxThreads = 1;

    m_nRounds = max(1, m_nRounds);
    CWordHash::sm_fCaseInsensitive = m_fCaseInsensitive;
    CWordHash::sm_fMemCmp = m_fMemCmp;
    CWordHash::sm_nLastChars = m_nLastChars;
    CWordHash::sm_fNonPagedAllocs = m_fNonPagedAllocs;
    CWordHash::sm_fRefTrace = m_fRefTrace;
    CWordHash::sm_fMultiKeys = m_fMultiKeys;
    CWordHash::sm_fUseLocks = m_fUseLocks;

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
# ifdef LKRHASH_GLOBAL_LOCK
    CWordHash::GlobalLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
# endif
    CWordHash::TableLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
    CWordHash::BucketLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    if (CWordHash::TableLock::Recursion() != LOCK_RECURSIVE)
    {
        IRTLTRACE1("TableLock %s is not recursive. No InsertIfNotFound\n",
                   CWordHash::TableLock::ClassName());
        m_nInsertIfNotFound = 0;
    }

    if (!CWordHash::sm_fUseLocks)
    {
        IRTLTRACE0("Not using locks. One thread only.\n");
        m_nMinThreads = m_nMaxThreads = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\hashtest\main.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       HashTest.cpp

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"
#include "WordHash.h"
#include "IniFile.h"

int __cdecl
_tmain(
    int argc,
    TCHAR **argv)
{
    TCHAR            tszIniFile[MAX_PATH];
    CIniFileSettings ifs;

    if (argc == 2)
    {
        GetFullPathName(argv[1], MAX_PATH, tszIniFile, NULL);
        ifs.ReadIniFile(tszIniFile);

        FILE* fp = _tfopen(ifs.m_tszDataFile, _TEXT("r"));

        if (fp == NULL)
        {
            TCHAR tszDrive[_MAX_DRIVE], tszDir[_MAX_DIR];
            
            _tsplitpath(tszIniFile, tszDrive, tszDir, NULL, NULL);
            
            _stprintf(tszIniFile, "%s%s%s", tszDrive, tszDir,
                      ifs.m_tszDataFile);
            _tcscpy(ifs.m_tszDataFile, tszIniFile);

            fp = _tfopen(ifs.m_tszDataFile, _TEXT("r"));
        }

        if (fp != NULL)
            fclose(fp);
        else
            _ftprintf(stderr, _TEXT("%s: Can't open datafile `%s'.\n"),
                      argv[0], ifs.m_tszDataFile) ;
    }
    else
    {
        _ftprintf(stderr, _TEXT("Usage: %s ini-file\n"), argv[0]);
        exit(1);
    }

    LKR_TestHashTable(ifs);

    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\hashtest\kernel\kmain.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       HashTest.cpp

   Abstract:
       Kernel-mode test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\minfan\minfan.h ===
#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
using namespace LKRhash;
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
using namespace HashFn;
#endif // __HASHFN_NO_NAMESPACE__

class VwrecordBase
{
public:
    VwrecordBase(const char* pszKey, int i)
    {
        Key = new char[strlen(pszKey) + 1];
        strcpy(Key, pszKey);
        m_num  = i;
        cRef = 0;
    }

    virtual ~VwrecordBase()
    {
        // printf("~VwrecordBase: %s\n", Key);
        delete [] Key;
    }

    char* getKey() const { return Key; }

    LONG  AddRefRecord(LK_ADDREF_REASON lkar) const
    {
        LONG l;
        if (lkar > 0)
            l = InterlockedIncrement(&cRef);
        else if ((l = InterlockedDecrement(&cRef)) == 0)
            delete this;
        return l;
    }

private:
    char* Key;
    int m_num;
    mutable long cRef;
};


// a hashtable of read-only VwrecordBases, using strings as the key.
class CWcharHashTable
    : public CTypedHashTable<CWcharHashTable, const VwrecordBase, const char*>
{
public:
    CWcharHashTable()
        : CTypedHashTable<CWcharHashTable, const VwrecordBase, const char*>("VWtest")
    {}

    static char*
    ExtractKey(const VwrecordBase* pRecord)        
    {
        return pRecord->getKey();
    }
    
    static DWORD
    CalcKeyHash(const char* pszKey)
    {
        return HashString(pszKey);
    }

    static int
    CompareKeys(const char* pszKey1, const char* pszKey2)
    {
        return strcmp(pszKey1, pszKey2);
    }

    static LONG
    AddRefRecord(const VwrecordBase* pRecord, LK_ADDREF_REASON lkar)
    {
        return pRecord->AddRefRecord(lkar);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\hashtest\wordhash.h ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       WordHash.h

   Abstract:
       LKRhash test harness: hash table of words

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __WORDHASH_H__
#define __WORDHASH_H__

#define MAXKEYS      1000000
#define MAX_THREADS  MAXIMUM_WAIT_OBJECTS
#define MAX_STRSIZE  300

#ifdef LKR_PUBLIC_API

 typedef PLkrHashTable WordBaseTable;
 #include <lkrhash.h>

#endif //  LKR_PUBLIC_API


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
 using namespace LKRhash;
#else
 #define LKRHASH_NS
#endif // !__LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 using namespace HashFn;
#endif // !__HASHFN_NO_NAMESPACE__


#ifndef LKR_PUBLIC_API
 typedef LKRHASH_NS::CLKRHashTable WordBaseTable;
 // typedef LKRHASH_NS::CLKRLinearHashTable WordBaseTable;
#endif



// A string wrapper class that keeps track of the length of the string data.
// A more useful string class would refcount the data and have copy-on-write
// semantics (or use MFC's CString or STL's string classes).

class CStr
{
public:
    const char* m_psz;
    short       m_cch;
    bool        m_fDynamic;
    
    static int  sm_cchMax;

    CStr()
        :  m_psz(NULL),
           m_cch(0),
           m_fDynamic(false)
    { 
    }
    
    CStr(
        const char* psz,
        int cch,
        bool fDynamic)
        :  m_psz(NULL),
           m_cch(static_cast<short>(cch)),
           m_fDynamic(fDynamic)
    { 
        if (fDynamic)
            Set(psz, cch);
        else
            m_psz = psz;
            
    }
    
    void Set(
        const char* psz,
        int cch)
    { 
        delete [] const_cast<char*>(m_psz);
        m_psz = new char[cch+1];
        if (m_psz != NULL)
        {
            strcpy(const_cast<char*>(m_psz), psz);
            m_cch = static_cast<short>(cch);
            m_fDynamic = true;
            sm_cchMax = max(m_cch, sm_cchMax);
        }
        else
        {
            m_cch = 0;
            m_fDynamic = false;
        }
    }

    ~CStr()
    {
        if (m_fDynamic)
            delete [] const_cast<char*>(m_psz);
    }
};

#ifdef HASHTEST_STATIC_DATA
// length of longest string seen
int CStr::sm_cchMax = 0;
#endif


// a word from the data file, which contains one 'word' per line (may
// include spaces).

class CWord
{
public:
    int    m_cNotFound;
    CStr   m_str;
    bool   m_fInserted;
    bool   m_fIterated;
    LONG   m_cRefs;
    LONG   m_cInsertIfNotFounds;
    int    m_iIndex;
    
    CWord()
        : m_cNotFound(0),
          m_fInserted(false),
          m_fIterated(false),
          m_cRefs(0),
          m_cInsertIfNotFounds(0),
          m_iIndex(-1)
    { 
    }
    
    ~CWord()
    {
        IRTLASSERT(m_cRefs == 0);
#ifdef IRTLDEBUG
        if (m_cRefs != 0)
            IRTLTRACE(_TEXT("\"%hs\": %d, %d\n"), m_str.m_psz, m_cRefs,
                      m_cInsertIfNotFounds);
#endif
    }
};


// globals
extern int        g_nokeys ;
extern CWord      g_wordtable[MAXKEYS];

const char*
LK_AddRefReasonCode2String(
    LK_ADDREF_REASON lkar);

#define DO_REF_COUNT false

// A hash table of CWords, indexed by CStr*s.
class CWordHash
#ifndef LKR_PUBLIC_API
    : public CTypedHashTable<CWordHash, CWord, const CStr*, DO_REF_COUNT, WordBaseTable>
#else
    : public TypedLkrHashTable<CWordHash, CWord, const CStr*, DO_REF_COUNT>
#endif
{
public:
    static bool sm_fCaseInsensitive;
    static bool sm_fMemCmp;
    static int  sm_nLastChars;
    static bool sm_fNonPagedAllocs;
    static bool sm_fRefTrace;
    static bool sm_fMultiKeys;
    static bool sm_fUseLocks;
    
#ifndef LKR_PUBLIC_API
    friend class CTypedHashTable<CWordHash, CWord, const CStr*,
                                 DO_REF_COUNT, WordBaseTable>;
#else
    friend class TypedLkrHashTable<CWordHash, CWord, const CStr*>;
#endif

    static const CStr*
    ExtractKey(const CWord* pKey)
    {
        return &pKey->m_str;
    }

    static DWORD
    CalcKeyHash(const CStr* pstrKey)
    {
        const char* psz = pstrKey->m_psz;

        // use only the last few chars instead of whole string?
        if (sm_nLastChars > 0  &&  pstrKey->m_cch >= sm_nLastChars)
            psz = pstrKey->m_psz + pstrKey->m_cch - sm_nLastChars;

        IRTLASSERT(pstrKey->m_psz <= psz
                   &&  psz < pstrKey->m_psz + pstrKey->m_cch);

        if (sm_fCaseInsensitive)
            return HashStringNoCase(psz, pstrKey->m_cch);
        else
            return HashString(psz, pstrKey->m_cch);
    }

    static int
    CompareKeys(const CStr* pstrKey1, const CStr* pstrKey2)
    {
        int nCmp;

        if (sm_fCaseInsensitive)
        {
#if 1
            // if (sm_fMultiKeys)
            {
                // Hack that works for ASCII data
                nCmp = (pstrKey1->m_psz[0] & 0xDF)
                        - (pstrKey2->m_psz[0] & 0xDF);

                if (nCmp != 0)
                    return nCmp;
            }
#endif
            // nCmp = pstrKey1->m_cch - pstrKey2->m_cch;

            // if (nCmp != 0)
                // return nCmp;
            if (sm_fMemCmp)
                return _memicmp(pstrKey1->m_psz, pstrKey2->m_psz,
                                pstrKey1->m_cch);
            else
                return _stricmp(pstrKey1->m_psz, pstrKey2->m_psz);
        }
        else
        {
#if 1
            // if (sm_fMultiKeys)
            {
                nCmp = pstrKey1->m_psz[0] - pstrKey2->m_psz[0];

                if (nCmp != 0)
                    return nCmp;
            }
#endif
            // nCmp = pstrKey1->m_cch - pstrKey2->m_cch;

            // if (nCmp != 0)
                // return nCmp;
            if (sm_fMemCmp)
                return memcmp(pstrKey1->m_psz, pstrKey2->m_psz,
                              pstrKey1->m_cch);
            else
                return strcmp(pstrKey1->m_psz, pstrKey2->m_psz);
        }
    }

    static LONG
    AddRefRecord(CWord* pRec, LK_ADDREF_REASON lkar)
    {
        int  nIncr = (lkar < 0) ? -1 : +1;
        LONG cRefs = nIncr + InterlockedExchangeAdd(&pRec->m_cRefs, nIncr);
        if (sm_fRefTrace)
            IRTLTRACE(_TEXT("\tAddRef key(%d, %p: \"%hs\"), %hs (%s), = %d\n"),
                      pRec - g_wordtable, pRec, pRec->m_str.m_psz,
                      (lkar > 0) ? "+1" : "-1",
                      LKR_AddRefReasonAsString(lkar), cRefs);
        IRTLASSERT(cRefs >= 0);
        return cRefs;
    }

    CWordHash(
        unsigned        maxload,    // Bound on avg chain length
        size_t          initsize,   // Initial size of hash table.
        size_t          num_subtbls // #subordinate hash tables.
        )
#ifndef LKR_PUBLIC_API
        : CTypedHashTable<CWordHash, CWord, const CStr*,
                          DO_REF_COUNT, WordBaseTable>
                ("wordhash", maxload, initsize, num_subtbls,
                 sm_fMultiKeys, sm_fUseLocks
# ifdef LKRHASH_KERNEL_MODE
                 , sm_fNonPagedAllocs // use paged or NP pool
# endif
                 )
#else // LKR_PUBLIC_API
        : TypedLkrHashTable<CWordHash, CWord, const CStr*>
                ("wordhash", (LK_TABLESIZE) initsize,
                 sm_fMultiKeys, sm_fUseLocks)
#endif // LKR_PUBLIC_API
    {}

    template <class _InputIterator>
    CWordHash(
        _InputIterator  f,
        _InputIterator  l,
        unsigned        maxload,    // Bound on avg chain length
        size_t          initsize,   // Initial size of hash table.
        size_t          num_subtbls // #subordinate hash tables.
        )
#ifndef LKR_PUBLIC_API
        : CTypedHashTable<CWordHash, CWord, const CStr*,
                          DO_REF_COUNT, WordBaseTable>
                (f, l, "wordhash", maxload, initsize, num_subtbls)
#else
        : TypedLkrHashTable<CWordHash, CWord, const CStr*>
                (f, l, "wordhash", (LK_TABLESIZE) initsize)
#endif
    {}

    static const TCHAR*
    HashMethod()
    {
        TCHAR tszLast[20];
        static TCHAR s_tsz[80];

        if (sm_nLastChars > 0)
            _stprintf(tszLast, _TEXT("last %d"), sm_nLastChars);
        else
            _tcscpy(tszLast, _TEXT("all"));

        _stprintf(s_tsz, _TEXT("case-%ssensitive, %scmp, %s chars"),
                  sm_fCaseInsensitive ? _TEXT("in") : _TEXT(""),
                  sm_fMemCmp ? _TEXT("mem") : _TEXT("str"),
                  tszLast);

        return s_tsz;
    }

#ifdef LKR_PUBLIC_API
    typedef CLKRHashTable             BaseHashTable;
    typedef BaseHashTable::TableLock  TableLock;
    typedef BaseHashTable::BucketLock BucketLock;

    enum {
        NODES_PER_CLUMP = BaseHashTable::NODES_PER_CLUMP,
    };

    static const TCHAR* ClassName()
    {return _TEXT("PLkrHashTable");}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls)
    { return BaseHashTable::NumSubTables(rinitsize, rnum_subtbls); }

    int                NumSubTables() const
    { return reinterpret_cast<BaseHashTable*>(m_plkr)->NumSubTables(); }

    void        SetTableLockSpinCount(WORD wSpins)
    { reinterpret_cast<BaseHashTable*>(m_plkr)->SetTableLockSpinCount(wSpins);}

    void        SetBucketLockSpinCount(WORD wSpins)
    { reinterpret_cast<BaseHashTable*>(m_plkr)->SetBucketLockSpinCount(wSpins);}

    CLKRHashTableStats GetStatistics() const
    { return reinterpret_cast<BaseHashTable*>(m_plkr)->GetStatistics();}

#endif // LKR_PUBLIC_API

protected:
    ~CWordHash() {}

private:
    CWordHash(const CWordHash&);
    CWordHash& operator=(const CWordHash&);
};

#endif // __WORDHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\numset\numset.h ===
//--------------------------------------------------------------------
// An example of how to create a wrapper for CLKRHashTable
//--------------------------------------------------------------------

#include <lkrhash.h>


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
// using namespace LKRhash;
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS HashFn
// using namespace HashFn;
#else  // __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS
#endif // __HASHFN_NO_NAMESPACE__


class CNumberTestHashTable
    : public LKRHASH_NS::CTypedHashTable<CNumberTestHashTable, int, int>
{
public:
    CNumberTestHashTable()
        : LKRHASH_NS::CTypedHashTable<CNumberTestHashTable, int, int>(
            "NumberSet") {}
    static int   ExtractKey(const int* pn)       {return (int) (DWORD_PTR) pn;}
    static DWORD CalcKeyHash(int nKey)           {return nKey;}
    static int   CompareKeys(int nKey1, int nKey2) {return nKey1 - nKey2;}
    static LONG  AddRefRecord(const int* pn, LK_ADDREF_REASON lkar) {return 1;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\numset\numset.cpp ===
/* Test driver for class HashTable             */
/* Author: Paul Larson, palarson@microsoft.com */
/* Much hacked upon by George V. Reilly, georgere@microsoft.com */

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#include "numset.h"


LK_RETCODE
InsertRecord(
    CNumberTestHashTable* pntht,
    int n)
{
    return pntht->InsertRecord((const int*) (DWORD_PTR) n);
}


LK_RETCODE
FindKey(
    CNumberTestHashTable* pntht,
    int nKey,
    int** pptOut)
{
    return pntht->FindKey(nKey, pptOut);
}


LK_RETCODE
DeleteKey(
    CNumberTestHashTable* pntht,
    int nKey)
{
    return pntht->DeleteKey(nKey);
}


void Test(
    CNumberTestHashTable* pntht,
    int n)
{
    int* pt2 = NULL;
    LK_RETCODE lkrc;

    lkrc = InsertRecord(pntht, n);
    IRTLASSERT(LK_SUCCESS == lkrc);

    lkrc = FindKey(pntht, n, &pt2);
    IRTLASSERT(LK_SUCCESS == lkrc);

    printf("FK = %d\n", (int) (DWORD_PTR) pt2);

    lkrc = DeleteKey(pntht, n);
    IRTLASSERT(LK_SUCCESS == lkrc);
}


int __cdecl
main(
    int argc,
    char **argv)
{
    CNumberTestHashTable ntht;
    int n = 1965;

    Test(&ntht, n);
    Test(&ntht, 0);

    return(0) ;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\minfan\minfan.cpp ===
// Repro case for LKRhash Clear bug

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#include "MinFan.h"

void
test(
    int N)
{
    printf("\nTest driver for LKRhash for wchar, %d\n", N);

    // A case-senstive string-to-int map
    CWcharHashTable map;
    int index;
    LK_RETCODE lkrc;
#ifdef LKR_DEPRECATED_ITERATORS
    CWcharHashTable::CIterator iter;
#endif // LKR_DEPRECATED_ITERATORS

#if 1
    // Some objects for the hash tables
    printf("\tFirst Insertion Loop\n");
    for ( index = 0; index < N; index++)
    {
        char buf[30];
        sprintf(buf, "page%04d.htm", index);
        VwrecordBase* psoRecord = new VwrecordBase(buf, index);
        // printf("Insert1: pso is %s\n", psoRecord->getKey());
        map.InsertRecord(psoRecord);
    }   
#endif
    
#ifdef LKR_DEPRECATED_ITERATORS
    printf("\tFirst Iteration Loop\n");
    for (lkrc = map.InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         lkrc = map.IncrementIterator(&iter))
    {
        const VwrecordBase* psoRecord = iter.Record();
        // printf("Iterate1: pso is %s\n", psoRecord->getKey());
    }
    lkrc = map.CloseIterator(&iter);
#endif // LKR_DEPRECATED_ITERATORS
    
    printf("\tAfter insertions, size of map is %d\n", map.Size());  
    
    map.Clear();
    printf("\tAfter Clear(), size of map is %d\n", map.Size());

    printf("\tSecond Insertion Loop\n");
    for ( index = 0; index < N; index++)
    {
        char buf[30];
        sprintf(buf, "page%4d", index);
        VwrecordBase* psoRecord = new VwrecordBase(buf, index);
        // printf("Insert2: pso is %s\n", psoRecord->getKey());
        map.InsertRecord(psoRecord);

        const VwrecordBase* psoRecord2;
        lkrc = map.FindKey(buf, &psoRecord2);
        // printf("FindKey(%s) returned %d, %p\n", buf, lkrc, psoRecord2);
        map.AddRefRecord(psoRecord2, LKAR_EXPLICIT_RELEASE);
    }   
    
#ifdef LKR_DEPRECATED_ITERATORS
    printf("\tSecond Iteration Loop\n");
    for (index = 0, lkrc = map.InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         ++index, lkrc = map.IncrementIterator(&iter))
    {
        const VwrecordBase* psoRecord = iter.Record();
        // printf("Iterate2: %d, pso is %s\n", index, psoRecord->getKey());
    }
    lkrc = map.CloseIterator(&iter);
#endif // LKR_DEPRECATED_ITERATORS

    printf("\tClearing again\n");
    map.Clear();

    printf("\tFinishing %d\n", N);
}



int __cdecl
main(
    int argc,
    char **argv)
{
#if 0
    for (int i = 0; i < 200000; ++i)
        test(i);
#endif

    int N = 5092;
    if (argc > 1)
        N = atoi(argv[1]);
    test(N);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\str-num\str-num.cpp ===
/* Test driver for class HashTable             */
/* Author: Paul Larson, palarson@microsoft.com */
/* Much hacked upon by George V. Reilly, georgere@microsoft.com */

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#include "str-num.h"


#ifdef LKR_APPLY_IF

// A class to exercise ApplyIf()

class CApplyIfTest
{
public:
    static LK_PREDICATE WINAPI
    Predicate(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cPreds;
        IRTLTRACE("CApplyIfTest::Predicate(%p (%s, %d), %p)\n",
                  pTest, pTest->m_sz, pTest->m_n, pThis);
        return ((pTest->m_n % 10 == 7)
                ?  LKP_PERFORM
                :  LKP_NO_ACTION);
    }

    static LK_ACTION WINAPI
    Action(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cActions;
        LK_ACTION lka = ((pTest->m_n > 30)
                                     ?  LKA_SUCCEEDED
                                     :  LKA_FAILED);

        IRTLTRACE("CApplyIfTest::Action(%p (%s, %d), %p) %s\n",
                  pTest, pTest->m_sz, pTest->m_n, pThis,
              lka == LKA_SUCCEEDED ? "succeeded" : "failed");

        if (lka == LKA_SUCCEEDED)
            ++pThis->m_cSuccesses;
        else if (lka == LKA_FAILED)
            ++pThis->m_cFailures;

        return lka;
    }

    int m_cPreds;
    int m_cActions;
    int m_cSuccesses;
    int m_cFailures;

    CApplyIfTest()
        : m_cPreds(0), m_cActions(0), m_cSuccesses(0), m_cFailures(0)
    {}
};


// The Predicate and Action functions can be static member functions,
// but don't have to be

LK_PREDICATE WINAPI
DeleteIfGt10(
    const CTest* pTest,
    void* pvState)
{
    IRTLTRACE("DeleteIfGt10(%p, %s, %p) = %d\n",
              pTest, pTest->m_sz, pvState, pTest->m_n);
    return ((pTest->m_n > 10)
            ?  LKP_PERFORM
            :   LKP_NO_ACTION);
}

#endif // LKR_APPLY_IF


void Test(
    bool fVerbose)
{
    // Some objects for the hash tables
    CTest tl(5,  "Larson",   true);
    CTest tk(17, "Krishnan", false);
    CTest tr(37, "Reilly",   true);

    // A string-keyed hash table
    CStringTestHashTable stht;

    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr));

    IRTLTRACE("Check the overwrite feature of InsertRecord\n");
    IRTLVERIFY(LK_KEY_EXISTS == stht.InsertRecord(&tr, false));
    IRTLASSERT(tr.m_cRefs == 1);

    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr, true));
    IRTLASSERT(tr.m_cRefs == 1);    // 1+1-1 == 1

    IRTLTRACE("Check that the keys are really present in the table and that "
              "the refcounting works\n");
    const CTest* pTest = NULL;

    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tl.m_sz, &pTest)  &&  pTest == &tl);
    IRTLASSERT(tl.m_cRefs == 2);

    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tk.m_sz, &pTest)  &&  pTest == &tk);
    IRTLASSERT(tk.m_cRefs == 2);

    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tr.m_sz, &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 2);

    IRTLVERIFY(LK_SUCCESS == stht.FindRecord(&tr));
    IRTLASSERT(tr.m_cRefs == 2);    // FindRecord does not addref

    IRTLTRACE("Look for a key under an alternate spelling "
              "(case-insensitive)\n");
    IRTLVERIFY(LK_SUCCESS == stht.FindKey("rEiLlY", &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 3);

    IRTLTRACE("Release the references added by FindKey\n");
    stht.AddRefRecord(&tl, LKAR_EXPLICIT_RELEASE);
    tk.m_cRefs--;
    tr.m_cRefs = 1;

#ifdef NUM64
    IRTLTRACE("Quick test of the __int64 keys\n");
    CNum64TestHashTable ntht64;

    IRTLVERIFY(LK_SUCCESS == ntht64.InsertRecord(&tr));
    IRTLVERIFY(LK_SUCCESS == ntht64.FindKey(tr.m_n64, &pTest));
    ntht64.AddRefRecord(pTest, LKAR_EXPLICIT_RELEASE); // release ref
    IRTLVERIFY(LK_SUCCESS == ntht64.DeleteKey(tr.m_n64));
#endif // NUM64

    IRTLTRACE("Now build the numeric hash table\n");
    CNumberTestHashTable ntht;

    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tr));

#ifdef LKR_APPLY_IF
    IRTLTRACE("Test ApplyIf()\n");
    CApplyIfTest ait;

    IRTLVERIFY(1 == ntht.ApplyIf(ait.Predicate, ait.Action, &ait));
    IRTLASSERT(3 == ait.m_cPreds  &&  2 == ait.m_cActions
               &&  1 == ait.m_cSuccesses  &&  1 == ait.m_cFailures);

    IRTLTRACE("Test DeleteIf()\n");
    IRTLASSERT(3 == ntht.Size());
    ntht.DeleteIf(DeleteIfGt10, NULL);
    IRTLASSERT(1 == ntht.Size());

    IRTLTRACE("Check that the keys that were supposed to be deleted "
              "really are gone\n");
    IRTLASSERT(tl.m_n <= 10);
    IRTLVERIFY(LK_SUCCESS == ntht.FindKey(tl.m_n, &pTest)  &&  pTest == &tl);
    ntht.AddRefRecord(pTest, LKAR_EXPLICIT_RELEASE); // release ref

    IRTLASSERT(tk.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tk.m_n, &pTest)
               &&  pTest == NULL);

    IRTLASSERT(tr.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tr.m_n, &pTest)
               &&  pTest == NULL);

    IRTLVERIFY(LK_SUCCESS == ntht.DeleteKey(tl.m_n));
    IRTLASSERT(0 == ntht.Size());
#endif // LKR_APPLY_IF

#ifdef LKR_DEPRECATED_ITERATORS
    IRTLTRACE("Check Iterators\n");
    DWORD  cRec = 0;
    CStringTestHashTable::CIterator iter;
    LK_RETCODE lkrc = stht.InitializeIterator(&iter);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        CStringTestHashTable::Key     pszKey = iter.Key();
        CStringTestHashTable::Record* pRec   = iter.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = stht.IncrementIterator(&iter);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = stht.CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == stht.Size());

    IRTLTRACE("Check const iterators\n");
    const CStringTestHashTable& sthtConst = stht;
    CStringTestHashTable::CConstIterator iterConst;
    cRec = 0;

    lkrc = sthtConst.InitializeIterator(&iterConst);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        const CStringTestHashTable::Key     pszKey = iterConst.Key();
        const CStringTestHashTable::Record* pRec   = iterConst.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Const Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = sthtConst.IncrementIterator(&iterConst);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = sthtConst.CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == sthtConst.Size());
#endif // LKR_DEPRECATED_ITERATORS

#if 0
    IRTLTRACE("Check Clear\n");
    stht.Clear();
    IRTLASSERT(0 == stht.Size());
#else
    IRTLTRACE("Check DeleteKey\n");
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tl.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tk.m_sz));
    IRTLTRACE("Exercise DeleteKey(pRecord)\n");
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey("rEiLlY", &pTest)
               &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 1);
    tr.m_cRefs = 0;

#endif

    IRTLTRACE("Test done\n");
    // ~CTest will check for m_cRefs==0
}


int __cdecl
main(
    int argc,
    char **argv)
{
    IrtlSetDebugOutput(1);

    Test(true);

    return(0) ;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\samples\str-num\str-num.h ===
//--------------------------------------------------------------------
// An example of how to create a wrapper for CLKRHashTable
//--------------------------------------------------------------------

#include <lkrhash.h>


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
// using namespace LKRhash;
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS HashFn
// using namespace HashFn;
#else  // __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS
#endif // __HASHFN_NO_NAMESPACE__


// some random class

class CTest
{
public:
    enum {BUFFSIZE=20};

    int   m_n;                  // This will also be a key
    __int64   m_n64;          // This will be a third key
    char  m_sz[BUFFSIZE];       // This will be the primary key
    bool  m_fWhatever;
    mutable LONG  m_cRefs;      // Reference count for lifetime management.
                                // Must be mutable to use 'const CTest*' in
                                // hashtables

    CTest(int n, const char* psz, bool f)
        : m_n(n), m_n64(((__int64) n << 32) | n), m_fWhatever(f), m_cRefs(0)
    {
        strncpy(m_sz, psz, BUFFSIZE-1);
        m_sz[BUFFSIZE-1] = '\0';
    }

    ~CTest()
    {
        IRTLASSERT(m_cRefs == 0);
    }
};



// A typed hash table of CTests, keyed on the string field.  Case-insensitive.

class CStringTestHashTable
    : public LKRHASH_NS::CTypedHashTable<CStringTestHashTable,
                                         const CTest, const char*>
{
public:
    CStringTestHashTable()
        : LKRHASH_NS::CTypedHashTable<CStringTestHashTable, const CTest,
                          const char*>("string",
                                       LK_DFLT_MAXLOAD,
                                       LK_SMALL_TABLESIZE,
                                       LK_DFLT_NUM_SUBTBLS)
    {}
    
    static const char*
    ExtractKey(const CTest* pTest)
    {
        return pTest->m_sz;
    }

    static DWORD
    CalcKeyHash(const char* pszKey)
    {
        return HASHFN_NS::HashStringNoCase(pszKey);
    }

    static int
    CompareKeys(const char* pszKey1, const char* pszKey2)
    {
        return _stricmp(pszKey1, pszKey2);
    }

    static LONG
    AddRefRecord(const CTest* pTest, LK_ADDREF_REASON lkar)
    {
        LONG l;
        
        if (lkar > 0)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            l = InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (lkar < 0)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            //      if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);

        IRTLTRACE("AddRef(%p, %s) %d, cRefs == %d\n",
                  pTest, pTest->m_sz, lkar, l);

        return l;
    }
};


// Another typed hash table of CTests.  This one is keyed on the numeric field.

class CNumberTestHashTable
    : public LKRHASH_NS::CTypedHashTable<CNumberTestHashTable,
                                         const CTest, int>
{
public:
    CNumberTestHashTable()
        : LKRHASH_NS::CTypedHashTable<CNumberTestHashTable, const CTest, int>(
            "number") {}
    static int   ExtractKey(const CTest* pTest)        {return pTest->m_n;}
    static DWORD CalcKeyHash(int nKey)          {return HASHFN_NS::Hash(nKey);}
    static int   CompareKeys(int nKey1, int nKey2)     {return nKey1 - nKey2;}
    static LONG  AddRefRecord(const CTest* pTest, LK_ADDREF_REASON lkar)
    {
        int nIncr = (lkar > 0) ? +1 : -1;
        LONG l = InterlockedExchangeAdd(&pTest->m_cRefs, nIncr);
        IRTLTRACE("AddRef(%p, %d) %d (%d), cRefs == %d\n",
                  pTest, pTest->m_n, nIncr, (int) lkar, l);
        return l;
    }
};


// Third typed hash table of CTests.  This one is keyed on the __int64 field.

#undef NUM64

#ifdef NUM64

class CNum64TestHashTable
    : public LKRHASH_NS::CTypedHashTable<CNum64TestHashTable,
                                         const CTest, __int64>
{
public:
    CNum64TestHashTable()
        : LKRHASH_NS::CTypedHashTable<CNum64TestHashTable, const CTest, __int64>(
            "num64") {}
    static __int64   ExtractKey(const CTest* pTest)        {return pTest->m_n64;}
    static DWORD CalcKeyHash(__int64 nKey)          {return HASHFN_NS::Hash(nKey);}
    static int   CompareKeys(__int64 nKey1, __int64 nKey2)     {return nKey1 - nKey2;}
    static LONG  AddRefRecord(const CTest* pTest, LK_ADDREF_REASON lkar)
    {
        int nIncr = (lkar > 0) ? +1 : -1;
        LONG l = InterlockedExchangeAdd(&pTest->m_cRefs, nIncr);
        IRTLTRACE("AddRef(%p, %d) %d (%d), cRefs == %d\n",
                  pTest, pTest->m_n, nIncr, (int) lkar, l);
        return l;
    }
};

#endif // NUM64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\i-debug.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       i-debug.h

   Abstract:
       Internal debugging declarations for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode
       NT - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __I_DEBUG_H__
#define __I_DEBUG_H__

extern "C" {

extern bool g_fDebugOutputEnabled;

}; // extern "C"

#endif // __I_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\i-locks.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       i-Locks.h

   Abstract:
       Internal declarations for Locks

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode
       NT - Kernel Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __I_LOCKS_H__
#define __I_LOCKS_H__

#define LOCKS_SWITCH_TO_THREAD
#define LOCK_NO_INTERLOCKED_TID

#ifdef _M_IX86
// # define LOCK_NAKED  __declspec(naked)
# define LOCK_NAKED
# define LOCK_FASTCALL __fastcall
# define LOCK_ASM

# ifdef LOCK_ASM
#  define LOCK_ATOMIC_INLINE
# else
#  define LOCK_ATOMIC_INLINE LOCK_FORCEINLINE
# endif
// # define LOCK_FASTCALL
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)

#else // !_M_IX86

# undef  LOCK_ASM
# define LOCK_NAKED
# define LOCK_FASTCALL
# define LOCK_ATOMIC_INLINE LOCK_FORCEINLINE
#endif // _M_IX86

extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

}; // extern "C"


class CSimpleLock
{
    volatile LONG m_l;

public:
    CSimpleLock()
        : m_l(0)
    {}

    ~CSimpleLock()
    {
        IRTLASSERT(0 == m_l);
    }
    
    void Enter();
    void Leave();
};

#endif // __I_LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\i-lkrhash.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       i-LKRhash.h

   Abstract:
       Internal declarations for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#ifndef __I_LKRHASH_H__
#define __I_LKRHASH_H__

// Should the table be allowed to contract after deletions?
#undef LKR_CONTRACT

// Use hysteresis to reduce expansion/contraction rate in volatile tables?
#define LKR_HYSTERESIS

// Use division instead of multiplication when calculating how many
// times _InsertRecord() should call _Expand()
#undef LKR_EXPAND_BY_DIVISION

// Use division instead of multiplication when calculating how many
// times _DeleteKey()/_DeleteRecord should call _Contract()
#undef LKR_CONTRACT_BY_DIVISION

// Calculate the hi-order bits of the subtable index?
#undef LKR_INDEX_HIBITS

// Precalculate exactly if we need to prime the freelist in _Expand,
// or just use a slightly pessimistic heuristic?
#undef LKR_EXPAND_CALC_FREELIST

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


// Class for bucket chains of the hash table. Note that the first
// nodeclump is actually included in the bucket and not dynamically
// allocated, which increases space requirements slightly but does
// improve performance.
class CBucket
{
public:
    typedef LKR_BUCKET_LOCK BucketLock;

private:
#ifdef LKR_USE_BUCKET_LOCKS
    mutable BucketLock m_Lock;       // lock protecting this bucket
#endif

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cBuckets;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cBuckets;
        // Possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("B%06x"), 0xFFFFFF & l);
        return s_tszName;
    }
#endif // LOCK_INSTRUMENTATION

public:
    CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

    DWORD
    FirstSignature() const
    {
        return m_ncFirst.Signature(CNodeClump::NODE_BEGIN);
    }

    const void*
    FirstNode() const
    {
        return m_ncFirst.Node(CNodeClump::NODE_BEGIN);
    }
    
    bool
    IsLastClump() const
    {
        return m_ncFirst.IsLastClump();
    }

    bool
    IsEmptyFirstSlot() const
    {
        return m_ncFirst.InvalidSignature(CNodeClump::NODE_BEGIN);
    }

    PNodeClump const
    FirstClump()
    {
        return &m_ncFirst;
    }

    PNodeClump const
    NextClump() const
    {
        return m_ncFirst.NextClump();
    }

#ifdef IRTLDEBUG
    bool
    NoValidSlots() const
    {
        return m_ncFirst.NoValidSlots();
    }
#endif // IRTLDEBUG


#if defined(LOCK_INSTRUMENTATION) || defined(IRTLDEBUG)
    CBucket()
#if defined(LOCK_INSTRUMENTATION) && defined(LKR_USE_BUCKET_LOCKS)
        : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION && LKR_USE_BUCKET_LOCKS
    {
#ifdef IRTLDEBUG
        LOCK_LOCKTYPE lt = BucketLock::LockType();
        if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
            IRTLASSERT(sizeof(*this) <= CNodeClump::BUCKET_BYTE_SIZE);
#endif IRTLDEBUG
    }
#endif // LOCK_INSTRUMENTATION || IRTLDEBUG

#ifdef LKR_USE_BUCKET_LOCKS
    void  WriteLock()               { m_Lock.WriteLock(); }
    void  ReadLock() const          { m_Lock.ReadLock(); }
    void  WriteUnlock()             { m_Lock.WriteUnlock(); }
    void  ReadUnlock() const        { m_Lock.ReadUnlock(); }
    bool  IsWriteLocked() const     { return m_Lock.IsWriteLocked(); }
    bool  IsReadLocked() const      { return m_Lock.IsReadLocked(); }
    bool  IsWriteUnlocked() const   { return m_Lock.IsWriteUnlocked(); }
    bool  IsReadUnlocked() const    { return m_Lock.IsReadUnlocked(); }

# ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
    WORD  GetSpinCount() const      { return m_Lock.GetSpinCount(); }
# endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

# ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const {return m_Lock.Statistics();}
# endif // LOCK_INSTRUMENTATION

#else  // !LKR_USE_BUCKET_LOCKS

    void  WriteLock()               { IRTLASSERT(! "Bucket::WriteLock()"  ); }
    void  ReadLock() const          { IRTLASSERT(! "Bucket::ReadLock()"   ); }
    void  WriteUnlock()             { IRTLASSERT(! "Bucket::WriteUnlock()"); }
    void  ReadUnlock() const        { IRTLASSERT(! "Bucket::ReadUnlock()" ); }
    bool  IsWriteLocked() const     { return true; }
    bool  IsReadLocked() const      { return true; }
    bool  IsWriteUnlocked() const   { return true; }
    bool  IsReadUnlocked() const    { return true; }

# ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    void  SetSpinCount(WORD)        {}
    WORD  GetSpinCount() const      { return LOCK_DEFAULT_SPINS; }
# endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

# ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const { CLockStatistics ls; return ls; }
# endif // LOCK_INSTRUMENTATION

#endif // !LKR_USE_BUCKET_LOCKS

    LKRHASH_CLASS_INIT_DECLS(CBucket);
}; // class CBucket



// The hash table space is divided into fixed-size segments (arrays of
// CBuckets) and physically grows/shrinks one segment at a time. This is
// a low-cost way of having a growable array of buckets.
//
// We provide small, medium, and large segments to better tune the
// overall memory requirements of the hash table according to the
// expected usage of an instance.
//
// We do not use virtual functions: partially because it's faster not
// to, and partially so that the custom allocators can do a better job,
// as the segment size is exactly 2 ^ (_NBits + 6) bytes long (assuming
// BUCKET_BYTE_SIZE==64).

class CSegment
{
public:
    CBucket m_bktSlots[1];

    // See note at m_bktSlots2 in CSizedSegment below
    CBucket& Slot(DWORD i)
    { return m_bktSlots[i]; }
}; // class CSegment



template <int _NBits, int _InitSizeMultiplier, LK_TABLESIZE _lkts>
class CSizedSegment : public CSegment
{
public:
    // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
    enum {
        SEGBITS  =       _NBits,// number of bits extracted from a hash
                                // address for offset within a segment
        SEGSIZE  = (1<<SEGBITS),// segment size
        SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
        INITSIZE = _InitSizeMultiplier * SEGSIZE, // #segments to allocate
                                // initially
    };

    // Hack: assumes laid out immediately after CSegment::m_bktSlots,
    // with no padding. The STATIC_ASSERTs in _AllocateSegment and in
    // CompileTimeAssertions should cause a compile-time error if
    // this assumption ever proves false.
    CBucket m_bktSlots2[SEGSIZE - 1];

public:
    DWORD           Bits() const        { return SEGBITS; }
    DWORD           Size() const        { return SEGSIZE; }
    DWORD           Mask() const        { return SEGMASK; }
    DWORD           InitSize() const    { return INITSIZE;}
    LK_TABLESIZE    SegmentType() const { return _lkts; }

    static void CompileTimeAssertions()
    {
        STATIC_ASSERT(offsetof(CSizedSegment, m_bktSlots) + sizeof(CBucket)
                        == offsetof(CSizedSegment, m_bktSlots2));
        STATIC_ASSERT(sizeof(CSizedSegment) == SEGSIZE * sizeof(CBucket));
    };

#ifdef IRTLDEBUG
    CSizedSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CSizedSegment);

}; // class CSizedSegment<>


class CSmallSegment  : public CSizedSegment<3, 1, LK_SMALL_TABLESIZE>
{
    LKRHASH_CLASS_INIT_DECLS(CSmallSegment);
};

class CMediumSegment : public CSizedSegment<6, 1, LK_MEDIUM_TABLESIZE>
{
    LKRHASH_CLASS_INIT_DECLS(CMediumSegment);
};

class CLargeSegment  : public CSizedSegment<9, 2, LK_LARGE_TABLESIZE>
{
    LKRHASH_CLASS_INIT_DECLS(CLargeSegment);
};


// Used as a dummy parameter to _DeleteNode
#define LKAR_ZERO  ((LK_ADDREF_REASON) 0)

#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__

extern "C" int g_fLKRhashInitialized;

#include "LKR-inline.h"

#endif //__I_LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\dllmain.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       dllmain.cpp

   Abstract:
       DLL entrypoints for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#include <precomp.hxx>

#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <irtldbg.h>
#include <lkrhash.h>


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point. Not included in static libraries, which must
// initialize LKRhash explicitly.

#ifndef LIB_IMPLEMENTATION

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{
    BOOL  fReturn = TRUE;  // ok
    
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        IRTL_DEBUG_INIT();
        IRTLTRACE0("LKRhash::DllMain::DLL_PROCESS_ATTACH\n");
        fReturn = LKR_Initialize(LK_INIT_DEFAULT);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        IRTLTRACE0("LKRhash::DllMain::DLL_PROCESS_DETACH\n");
        LKR_Terminate();
        IRTL_DEBUG_TERM();
    }

    return fReturn;
}

#endif // !LIB_IMPLEMENTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-c-api.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-c-api.cpp

   Abstract:
       Implements the C API for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
using namespace LKRhash;
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS HashFn
using namespace HashFn;
#else  // __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS
#endif // __HASHFN_NO_NAMESPACE__


typedef CLKRHashTable          BaseHashTable;


// don't want to expose the inner workings of LKRhash through the
// public iterators, so we use this as the actual implementation

class BaseIter
{
public:
    BaseHashTable::Iterator m_iter;
    LONG                    m_cRefs;

    BaseIter()
        : m_iter(),
          m_cRefs(1)
    {}

    BaseIter(
        BaseHashTable::Iterator& iter)
        : m_iter(iter),
          m_cRefs(1)
    {}

    LONG
    AddRef()
    {
        const LONG l = InterlockedIncrement(&m_cRefs);
        LKR_ITER_TRACE(_TEXT(" BI::AddRef: this=%p, iter=%p, cRefs=%d\n"),
                       this, &m_iter, m_cRefs);
        return l;
    }

    LONG
    Release()
    {
        const LONG l = InterlockedDecrement(&m_cRefs);
        LKR_ITER_TRACE(_TEXT(" BI::Release: this=%p, iter=%p, cRefs=%d\n"),
                       this, &m_iter, m_cRefs);
        if (l == 0)
            delete this;
        return l;
    }

    ~BaseIter()
    {
        IRTLASSERT(m_cRefs == 0);
    }

private:
    BaseIter(const BaseIter& rhs);
    BaseIter& operator=(const BaseIter& rhs);
};



/* Create a new LkrHashTable
 */
PLkrHashTable
LKR_CreateTable(
    LPCSTR              pszName,        /* An identifier for debugging */
    LKR_PFnExtractKey   pfnExtractKey,  /* Extract key from record */
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, /* Calculate hash signature of key */
    LKR_PFnCompareKeys  pfnCompareKeys, /* Compare two keys */
    LKR_PFnAddRefRecord pfnAddRefRecord,/* AddRef in LKR_FindKey, etc */
    LK_TABLESIZE        nTableSize,     /* Small/Med/Large number of elements*/
    DWORD               fCreateFlags    /* Mixture of LK_CREATE_* flags. */
    )
{
    bool fMultiKeys = (fCreateFlags & LK_CREATE_MULTIKEYS) != 0;
    bool fUseLocks  = (fCreateFlags & LK_CREATE_USE_LOCKS) != 0;

    BaseHashTable* pht
        = new BaseHashTable(
                    pszName,
                    pfnExtractKey,
                    pfnCalcKeyHash,
                    pfnCompareKeys,
                    pfnAddRefRecord,
                    LK_DFLT_MAXLOAD,
                    nTableSize,
                    LK_DFLT_NUM_SUBTBLS,
                    fMultiKeys,
                    fUseLocks);

    if (pht != NULL  &&  !pht->IsValid())
    {
        delete pht;
        pht = NULL;
    }

    return (PLkrHashTable) pht;
}



/* Destroy an LkrHashTable created by LKR_CreateTable.
 */
void
LKR_DeleteTable(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;

    delete pht;
}



/* Insert a new record into hash table.
 */
LK_RETCODE
LKR_InsertRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord,
    BOOL            fOverwrite)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->InsertRecord(pvRecord, !!fOverwrite);
}



/* Delete record with the given key from the table.
 */
LK_RETCODE
LKR_DeleteKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    const void**    ppvRecord,
    BOOL            fDeleteAllSame)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->DeleteKey(pnKey, ppvRecord, !!fDeleteAllSame);
}



/* Delete a record from the table, if present.
 */
LK_RETCODE
LKR_DeleteRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->DeleteRecord(pvRecord);
}



/* Find record with given key.
 */
LK_RETCODE
LKR_FindKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    const void**    ppvRecord)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->FindKey(pnKey, ppvRecord);
}



/* Sees if the record is contained in the table
 */
LK_RETCODE
LKR_FindRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->FindRecord(pvRecord);
}



/* Find all records with given key.
 */
LK_RETCODE
LKR_FindKeyMultipleRecords(
    PLkrHashTable           plkr,
    const DWORD_PTR         pnKey,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->FindKeyMultipleRecords(pnKey, pcRecords, pplmr);
}



/* Delete all record(s) with the given key from the table.
 */
LK_RETCODE
LKR_DeleteKeyMultipleRecords(
    PLkrHashTable           plkr,
    const DWORD_PTR         pnKey,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->DeleteKeyMultipleRecords(pnKey, pcRecords, pplmr);
}



/* Destroys an LKR_MULTIPLE_RECORDS created by LKR_FindKeyMultipleRecords
 * or LKR_DeleteKeyMultipleRecords.
 */
LK_RETCODE
LKR_FreeMultipleRecords(
    LKR_MULTIPLE_RECORDS* plmr)
{
    return BaseHashTable::FreeMultipleRecords(plmr);
}



#ifdef LKR_APPLY_IF

/* Walk the hash table, applying pfnAction to all records.
 * Locks the whole table for the duration with either a (possibly
 * shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction returns LKA_ABORT.
 * Returns the number of successful applications.
 */
DWORD
LKR_Apply(
    PLkrHashTable       plkr,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return static_cast<DWORD>(LK_BAD_TABLE);
    
    return pht->Apply(pfnAction, pvState, lkl);
}



/* Walk the hash table, applying pfnAction to any records that match
 * pfnPredicate. Locks the whole table for the duration with either
 * a (possibly shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction returns LKA_ABORT.
 * Returns the number of successful applications.
 */
DWORD
LKR_ApplyIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return static_cast<DWORD>(LK_BAD_TABLE);
    
    return pht->ApplyIf(pfnPredicate, pfnAction, pvState, lkl);
}



/* Delete any records that match pfnPredicate.
 * Locks the table for the duration with a writelock.
 * Returns the number of deletions.
 *
 * Do *not* walk the hash table by hand with an iterator and call
 * LKR_DeleteKey. The iterator will end up pointing to garbage.
 */
DWORD
LKR_DeleteIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return static_cast<DWORD>(LK_BAD_TABLE);
    
    return pht->DeleteIf(pfnPredicate, pvState);
}

#endif /* LKR_APPLY_IF */



/* Check table for consistency. Returns 0 if okay, or the number of
 * errors otherwise.
 */
int
LKR_CheckTable(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->CheckTable();
}



/* Remove all data from the table
 */
void
LKR_Clear(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->Clear();
}



/* Number of elements in the table
 */
DWORD
LKR_Size(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return 0;
    
    return pht->Size();
}



/* Maximum possible number of elements in the table
 */
DWORD
LKR_MaxSize(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return 0;
    
    return pht->MaxSize();
}



/* Is the hash table usable?
 */
BOOL
LKR_IsUsable(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL)
        return FALSE;
    
    return pht->IsUsable();
}


    
/* Is the hash table consistent and correct?
 */
BOOL
LKR_IsValid(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL)
        return FALSE;
    
    return pht->IsValid();
}



#ifdef LKR_EXPOSED_TABLE_LOCK

/* Lock the table (exclusively) for writing
 */
void
LKR_WriteLock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->WriteLock();
}



/* Lock the table (possibly shared) for reading
 */
void
LKR_ReadLock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->ReadLock();
}



/* Unlock the table for writing
 */
void
LKR_WriteUnlock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->WriteUnlock();
}



/* Unlock the table for reading
 */
void
LKR_ReadUnlock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->ReadUnlock();
}



/* Is the table already locked for writing?
 */
BOOL
LKR_IsWriteLocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsWriteLocked();
}



/* Is the table already locked for reading?
 */
BOOL
LKR_IsReadLocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsReadLocked();
}



/* Is the table unlocked for writing?
 */
BOOL
LKR_IsWriteUnlocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsWriteUnlocked();
}



/* Is the table unlocked for reading?
 */
BOOL
LKR_IsReadUnlocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsReadUnlocked();
}



/* Convert the read lock to a write lock. Note: another thread may acquire
 * exclusive access to the table before this routine returns.
 */
void
LKR_ConvertSharedToExclusive(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;

    pht->ConvertSharedToExclusive();
}



/* Convert the write lock to a read lock
 */
void
LKR_ConvertExclusiveToShared(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;

    pht->ConvertExclusiveToShared();
}

#endif // LKR_EXPOSED_TABLE_LOCK



#ifdef LKR_STL_ITERATORS


/* LKR_Iterator default ctor
 */
LKR_Iterator::LKR_Iterator()
    : pImpl(NULL)
{
    BaseIter* piter = new BaseIter;
    LKR_ITER_TRACE(_TEXT(" L_I::default ctor: this=%p, pImpl=%p, %d\n"),
                   this, piter, piter->m_cRefs);
    pImpl = piter;
}



/* LKR_Iterator private ctor
 */
LKR_Iterator::LKR_Iterator(
    bool)
    : pImpl(NULL)
{
    LKR_ITER_TRACE(_TEXT(" L_I::private ctor: this=%p\n"), this);
}



/* LKR_Iterator copy ctor
 */
LKR_Iterator::LKR_Iterator(
    const LKR_Iterator& rhs)
    : pImpl(NULL)
{
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    IRTLASSERT(piterRhs != NULL  &&  piterRhs->m_cRefs > 0);

    LKR_ITER_TRACE(_TEXT(" L_I::copy ctor: this=%p, ")
                   _TEXT(" rhs=%p, rhs.pImpl=%p,%d\n"),
                   this, &rhs, piterRhs, piterRhs->m_cRefs);

    pImpl = rhs.pImpl;
    piterRhs->AddRef();
}



/* LKR_Iterator assignment operator
 */
LKR_Iterator&
LKR_Iterator::operator=(
    const LKR_Iterator& rhs)
{
    BaseIter* piter    = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    IRTLASSERT(piter != NULL     &&  piter->m_cRefs > 0);
    IRTLASSERT(piterRhs != NULL  &&  piterRhs->m_cRefs > 0);

    LKR_ITER_TRACE(_TEXT(" L_I::op=: this=%p, pImpl=%p,%d,")
                   _TEXT(" rhs=%p, rhs.pImpl=%p,%d\n"),
                   this, piter, (piter ? piter->m_cRefs : -99),
                   &rhs, piterRhs, piterRhs->m_cRefs);

    piterRhs->AddRef();
    piter->Release();

    pImpl = rhs.pImpl;

    return *this;
}



/* LKR_Iterator dtor
 */
LKR_Iterator::~LKR_Iterator()
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::dtor: this=%p, pImpl=%p,%d\n"),
                   this, piter, (piter ? piter->m_cRefs : -99));

    IRTLASSERT(piter != NULL     &&  piter->m_cRefs > 0);
    piter->Release();
}



/* Increment the LKR_Iterator, so that it points to the next record in
 * the LkrHashTable, or to LKR_End();
 */
bool
LKR_Iterator::Increment()
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Increment: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.Increment();
}



/* Is the LKR_Iterator valid?
 */
bool
LKR_Iterator::IsValid() const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::IsValid: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.IsValid();
}



/* Return the record that an LKR_Iterator points to.
 * Must point to a valid record.
 */
const void*
LKR_Iterator::Record() const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Record: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.Record();
}



/* Return the key of the record that an LKR_Iterator points to.
 * Must point to a valid record.
 */
const DWORD_PTR
LKR_Iterator::Key() const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Key: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.Key();
}



/* Compare two LKR_Iterators for equality
 */
bool
LKR_Iterator::operator==(
    const LKR_Iterator& rhs) const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::op==, this=%p, pImpl=%p, rhs=%p, r.p=%p\n"),
                   this, pImpl, &rhs, rhs.pImpl);

    return piter->m_iter == piterRhs->m_iter;
}



/* Compare two LKR_Iterators for inequality
 */
bool
LKR_Iterator::operator!=(
    const LKR_Iterator& rhs) const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::op!=, this=%p, pImpl=%p, rhs=%p, r.p=%p\n"),
                   this, pImpl, &rhs, rhs.pImpl);

    return piter->m_iter != piterRhs->m_iter;
}



/* Return iterator pointing to first item in table
 */
LKR_Iterator
LKR_Begin(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    LKR_Iterator   iter(true);

    BaseHashTable::Iterator iterBegin = pht->Begin();
    iter.pImpl = new BaseIter(iterBegin);
    
    LKR_ITER_TRACE(_TEXT(" L_I::Begin: plkr=%p, iter=%p, pImpl=%p\n"),
                   plkr, &iter, iter.pImpl);

    return iter;
}



/* Return a one-past-the-end iterator. Always empty.
 */
LKR_Iterator
LKR_End(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    LKR_Iterator   iter(true);

    BaseHashTable::Iterator iterEnd = pht->End();
    iter.pImpl = new BaseIter(iterEnd);

    LKR_ITER_TRACE(_TEXT(" L_I::End: plkr=%p, iter=%p, pImpl=%p\n"),
                   plkr, &iter, iter.pImpl);

    return iter;
}



/* Insert a record
 * Returns `true' if successful; iterResult points to that record
 * Returns `false' otherwise; iterResult == End()
 */
bool
LKR_Insert(
              PLkrHashTable plkr,
    /* in */  const void*   pvRecord,
    /* out */ LKR_Iterator& riterResult,
    /* in */  bool          fOverwrite)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piter = reinterpret_cast<BaseIter*>(riterResult.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Insert: plkr=%p, iter=%p, pImpl=%p, Rec=%p\n"),
                   plkr, &riterResult, piter, pvRecord);

    return pht->Insert(pvRecord, piter->m_iter, fOverwrite);
}



/* Erase the record pointed to by the iterator; adjust the iterator
 * to point to the next record. Returns `true' if successful.
 */
bool
LKR_Erase(
                 PLkrHashTable plkr,
    /* in,out */ LKR_Iterator& riter)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piter = reinterpret_cast<BaseIter*>(riter.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Erase: plkr=%p, iter=%p, pImpl=%p\n"),
                   plkr, &riter, piter);

    return pht->Erase(piter->m_iter);
}



/* Erase the records in the range [riterFirst, riterLast).
 * Returns `true' if successful. riterFirst points to riterLast on return.
 */
bool
LKR_Erase(
           PLkrHashTable plkr,
    /*in*/ LKR_Iterator& riterFirst,
    /*in*/ LKR_Iterator& riterLast)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piterFirst= reinterpret_cast<BaseIter*>(riterFirst.pImpl);
    BaseIter* piterLast = reinterpret_cast<BaseIter*>(riterLast.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Erase2: plkr=%p,")
                   _TEXT(" iterFirst=%p, pImplFirst=%p,")
                   _TEXT(" iterLast=%p, pImplLast=%p\n"),
                   plkr, &riterFirst, piterFirst, &riterLast, piterLast);

    return pht->Erase(piterFirst->m_iter, piterLast->m_iter);
}


    
/* Find the (first) record that has its key == pnKey.
 * If successful, returns `true' and iterator points to (first) record.
 * If fails, returns `false' and iterator == End()
 */
bool
LKR_Find(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterResult)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piter = reinterpret_cast<BaseIter*>(riterResult.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Find: plkr=%p, iter=%p, pImpl=%p, Key=%p\n"),
                   plkr, &riterResult, piter, (void*) pnKey);

    return pht->Find(pnKey, piter->m_iter);
}



/* Find the range of records that have their keys == pnKey.
 * If successful, returns `true', iterFirst points to first record,
 *     and iterLast points to one-beyond-the last such record.
 * If fails, returns `false' and both iterators == End().
 * Primarily useful when fMultiKeys == TRUE
 */
bool
LKR_EqualRange(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterFirst,     // inclusive
    /* out */ LKR_Iterator& riterLast)      // exclusive
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piterFirst= reinterpret_cast<BaseIter*>(riterFirst.pImpl);
    BaseIter* piterLast = reinterpret_cast<BaseIter*>(riterLast.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::EqualRange: plkr=%p, Key=%p,")
                   _TEXT(" iterFirst=%p, pImplFirst=%p,")
                   _TEXT(" iterLast=%p, pImplLast=%p\n"),
                   plkr, (void*) pnKey, &riterFirst, piterFirst,
                   &riterLast, piterLast);

    return pht->EqualRange(pnKey, piterFirst->m_iter, piterLast->m_iter);
}

#endif // LKR_STL_ITERATORS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\irtldbg.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       IrtlDbg.cpp

   Abstract:
       Debug support for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/

// Implementation of debug support functions

#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <IrtlDbg.h>

#include "i-Debug.h"

bool g_fDebugOutputEnabled = true;

IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    if (g_fDebugOutputEnabled)
    {
        TCHAR tszBuff[2048];
        va_list args;
        
        va_start(args, ptszFormat);
        _vsntprintf(tszBuff, sizeof(tszBuff) / sizeof(TCHAR), ptszFormat, args);
        // _vsntprintf doesn't always NUL-terminate the buffer
        tszBuff[RTL_NUMBER_OF(tszBuff)-1] = TEXT('\0');
        va_end(args);
        
#ifdef IRTLDBG_KERNEL_MODE
        DbgPrint("%s", tszBuff);
#else // !IRTLDBG_KERNEL_MODE
        OutputDebugString(tszBuff);
#endif // !IRTLDBG_KERNEL_MODE
    }
} // IrtlTrace


IRTL_DLLEXP
DWORD
IrtlSetDebugOutput(
    DWORD dwFlags)
{
    DWORD dwResult = !!g_fDebugOutputEnabled;
    g_fDebugOutputEnabled = (dwFlags != 0);
    return dwResult;
}


#ifdef IRTLDBG_KERNEL_MODE
# undef IRTLDEBUG
// Can't compile the rest of this code in kernel mode
#endif


#ifdef IRTLDEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_DEBUG)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  define REALLY_USE_DEBUG_CRTS
# endif


# ifdef REALLY_USE_DEBUG_CRTS
#  ifdef IRTLDBG_RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate LKRhash,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    int   nResult = FALSE;

    *pnReturn = 0;  // nothing for _CrtDbgReport to do
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(malloc(strlen(pszErrorText) + strlen(szInfo) + 1));

    if (NULL == pszMessageText)
        return FALSE;

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        nResult = TRUE;  // tell _CrtDbgReport to run
    }

    free(pszMessageText);
    
    return nResult;
} // AspAssertHandler

#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // REALLY_USE_DEBUG_CRTS



void
IrtlDebugInit()
{
# ifdef REALLY_USE_DEBUG_CRTS
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // IRTLDBG_RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // REALLY_USE_DEBUG_CRTS
} // IrtlDebugInit



void
IrtlDebugTerm()
{
# ifdef REALLY_USE_DEBUG_CRTS
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // REALLY_USE_DEBUG_CRTS
} // IrtlDebugTerm



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}

#endif //IRTLDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-apply.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-apply.cpp

   Abstract:
       Apply, ApplyIf, and DeleteIf

   Author:
       George V. Reilly      (GeorgeRe)     1998

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#ifdef LKR_APPLY_IF

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    if (lkl == LKL_WRITELOCK)
        this->WriteLock();
    else
        this->ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    LK_PREDICATE lkp = LKP_PERFORM;
    DWORD dw = _ApplyIf(_PredTrue, pfnAction, pvState, lkl, lkp);

    if (lkl == LKL_WRITELOCK)
        this->WriteUnlock();
    else
        this->ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteLock();
        else
            m_palhtDir[i]->ReadLock();

        // Must call IsValid inside a lock to ensure that none of the state
        // variables change while it's being evaluated
        IRTLASSERT(m_palhtDir[i]->IsValid());

        if (m_palhtDir[i]->IsValid())
        {
            dw += m_palhtDir[i]->_ApplyIf(CLKRLinearHashTable::_PredTrue,
                                          pfnAction, pvState, lkl, lkp);
        }

        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteUnlock();
        else
            m_palhtDir[i]->ReadUnlock();

        if (lkp == LKP_ABORT
            ||  lkp == LKP_PERFORM_STOP
            ||  lkp == LKP_DELETE_STOP)
        {
            break;
        }
    }

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        this->WriteLock();
    else
        this->ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        this->WriteUnlock();
    else
        this->ReadUnlock();

    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteLock();
        else
            m_palhtDir[i]->ReadLock();
        
        // Must call IsValid inside a lock to ensure that none of the state
        // variables change while it's being evaluated
        IRTLASSERT(m_palhtDir[i]->IsValid());
        
        if (m_palhtDir[i]->IsValid())
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
        }
        
        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteUnlock();
        else
            m_palhtDir[i]->ReadUnlock();
        
        if (lkp == LKP_ABORT
            ||  lkp == LKP_PERFORM_STOP
            ||  lkp == LKP_DELETE_STOP)
        {
            break;
        }
    }

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    this->WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);

    this->WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i]->WriteLock();
        
        // Must call IsValid inside a lock to ensure that none of the state
        // variables change while it's being evaluated
        IRTLASSERT(m_palhtDir[i]->IsValid());
        
        if (m_palhtDir[i]->IsValid())
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
        
        m_palhtDir[i]->WriteUnlock();
        
        if (lkp == LKP_ABORT
            ||  lkp == LKP_PERFORM_STOP
            ||  lkp == LKP_DELETE_STOP)
        {
            break;
        }
    }

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl,
    LK_PREDICATE&       rlkp)
{
    INCREMENT_OP_STAT(ApplyIf);

    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        PBucket const pbkt = _BucketFromAddress(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (_UseBucketLocking())
        {
            if (lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
        }

        for (PNodeClump pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
                        pncCurr != NULL;
                        pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            FOR_EACH_NODE_DECL(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->NoMoreValidSlots(i));
                    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (_UseBucketLocking())
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                        }
                        
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            if (_UseBucketLocking())
                                pbkt->ReadUnlock();

                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            _DeleteNode(pbkt, pncCurr, pncPrev, i,
                                        LKAR_APPLY_DELETE);

                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (_UseBucketLocking())
                                {
                                    if (lkl == LKL_WRITELOCK)
                                        pbkt->WriteUnlock();
                                    else
                                        pbkt->ReadUnlock();
                                }
                                
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(! "Unknown LK_ACTION in ApplyIf");
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (_UseBucketLocking())
                            {
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                            }
                            
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in ApplyIf");
                        break;
                    }
                }
            }
        }

      unlock:
        if (_UseBucketLocking())
        {
            if (lkl == LKL_WRITELOCK)
                pbkt->WriteUnlock();
            else
                pbkt->ReadUnlock();
        }
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState,
    LK_PREDICATE&       rlkp)
{
    INCREMENT_OP_STAT(DeleteIf);

    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        PBucket const pbkt = _BucketFromAddress(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (_UseBucketLocking())
            pbkt->WriteLock();

        for (PNodeClump pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
                        pncCurr != NULL;
                        pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            FOR_EACH_NODE_DECL(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->NoMoreValidSlots(i));
                    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (_UseBucketLocking())
                            pbkt->WriteUnlock();

                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        _DeleteNode(pbkt, pncCurr, pncPrev, i,
                                    LKAR_DELETEIF_DELETE);

                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (_UseBucketLocking())
                                pbkt->WriteUnlock();

                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in DeleteIf");
                        break;
                    }
                }
            }
        }

      unlock:
        if (_UseBucketLocking())
            pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf

#endif // LKR_APPLY_IF


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-alloc.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-alloc.cpp

   Abstract:
       Allocation wrappers for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#include <stdlib.h>


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

PSegment* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    IRTLASSERT(0 == (n & (n - 1)));
    IRTLASSERT(MIN_DIRSIZE <= n  &&  n <= MAX_DIRSIZE);

    PSegment* const paDirSegs =
        (n == MIN_DIRSIZE)  ?  &m_aDirSegs[0]  :  new PSegment [n];

    if (NULL != paDirSegs)
    {
        INCREMENT_ALLOC_STAT(SegDir);

        for (size_t i = 0;  i < n;  ++i)
            paDirSegs[i] = NULL;
    }

    return paDirSegs;
} // CLKRLinearHashTable::_AllocateSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory()
{
#ifdef IRTLDEBUG
    if (m_paDirSegs != NULL)
    {
        for (size_t i = 0;  i < m_cDirSegs;  ++i)
            IRTLASSERT(m_paDirSegs[i] == NULL);
    }
#endif // IRTLDEBUG

    IRTLASSERT(MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE);
    IRTLASSERT(0 == (m_cDirSegs & (m_cDirSegs - 1)));
    IRTLASSERT(m_paDirSegs != NULL);

    IRTLASSERT((m_cDirSegs == MIN_DIRSIZE)
               ?  m_paDirSegs == &m_aDirSegs[0]
               :  m_paDirSegs != &m_aDirSegs[0]);

    if (m_paDirSegs != NULL)
        INCREMENT_FREE_STAT(SegDir);

    if (m_cDirSegs != MIN_DIRSIZE)
        delete [] m_paDirSegs;

    m_paDirSegs = NULL;
    m_cDirSegs  = 0;

    return true;
} // CLKRLinearHashTable::_FreeSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

PNodeClump const
CLKRLinearHashTable::_AllocateNodeClump() const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    PNodeClump const pnc = new CNodeClump;

    if (NULL != pnc)
        INCREMENT_ALLOC_STAT(NodeClump);

    return pnc;
} // CLKRLinearHashTable::_AllocateNodeClump



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeNodeClump
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    PNodeClump const pnc) const
{
    if (NULL != pnc)
        INCREMENT_FREE_STAT(NodeClump);

    delete pnc;

    return true;
} // CLKRLinearHashTable::_FreeNodeClump



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

PSegment const
CLKRLinearHashTable::_AllocateSegment() const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    STATIC_ASSERT(offsetof(CSmallSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CSmallSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CMediumSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CMediumSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CLargeSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CLargeSegment, m_bktSlots2));

    PSegment pseg = NULL;

    switch (m_lkts)
    {

    case LK_SMALL_TABLESIZE:
    {
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CSmallSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW

        pseg = new CSmallSegment;
    }
    break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
    {
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CMediumSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW

        pseg = new CMediumSegment;
    }
    break;
        
    case LK_LARGE_TABLESIZE:
    {
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLargeSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW

        pseg = new CLargeSegment;
    }
    break;

    } // switch

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_nSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    if (NULL != pseg)
        INCREMENT_ALLOC_STAT(Segment);

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    PSegment const pseg) const
{
    if (NULL != pseg)
        INCREMENT_FREE_STAT(Segment);

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        delete static_cast<CSmallSegment*>(pseg);
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        delete static_cast<CMediumSegment*>(pseg);
        break;
        
    case LK_LARGE_TABLESIZE:
        delete static_cast<CLargeSegment*>(pseg);
        break;
    }

    return true;
} // CLKRLinearHashTable::_FreeSegment



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR              pszClassName,   // Identifies subtable for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Upperbound on average chain length
    DWORD               initsize,       // Initial size of hash subtable.
    CLKRHashTable*      phtParent,      // Owning table.
    int                 iParentIndex,   // index within parent table
    bool                fMultiKeys,     // Allow multiple identical keys?
    bool                fUseLocks,      // Must use locks
    bool                fNonPagedAllocs // use paged or NP pool in kernel
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    CLKRHashTable::SubTable* const plht =
            new SubTable(pszClassName, pfnExtractKey, pfnCalcKeyHash,
                         pfnCompareKeys,  pfnAddRefRecord,
                         maxload, initsize, phtParent, iParentIndex,
                         fMultiKeys, fUseLocks, fNonPagedAllocs);

    if (NULL != plht)
        INCREMENT_ALLOC_STAT(SubTable);

    return plht;
} // CLKRHashTable::_AllocateSubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht) const
{
    if (NULL != plht)
        INCREMENT_FREE_STAT(SubTable);

    delete plht;

    return true;
} // CLKRHashTable::_FreeSubTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::FreeMultipleRecords
// Synopsis:
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::FreeMultipleRecords(
    LKR_MULTIPLE_RECORDS* plmr)
{
    UNREFERENCED_PARAMETER(plmr);   // for /W4

    IRTLASSERT(! "FreeMultipleRecords not implemented yet");

    return LK_BAD_TABLE;
} // CLKRLinearHashTable::FreeMultipleRecords



//------------------------------------------------------------------------
// Function: CLKRHashTable::FreeMultipleRecords
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FreeMultipleRecords(
    LKR_MULTIPLE_RECORDS* plmr)
{
    return CLKRLinearHashTable::FreeMultipleRecords(plmr);
} // CLKRHashTable::FreeMultipleRecords




#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-init.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-init.cpp

   Abstract:
       Initialization code for LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     May 2000

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:
       May 2000

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"
#include "i-Locks.h"
#include "i-Debug.h"


#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* LKRHASH_NS::CLASS::sm_palloc = NULL

#ifdef LKRHASH_KERNEL_MODE
DECLARE_ALLOCATOR(CLKRLinearHashTable);
DECLARE_ALLOCATOR(CLKRHashTable);
#endif

DECLARE_ALLOCATOR(CNodeClump);
DECLARE_ALLOCATOR(CSmallSegment);
DECLARE_ALLOCATOR(CMediumSegment);
DECLARE_ALLOCATOR(CLargeSegment);

#endif // LKRHASH_ALLOCATOR_NEW

// Declare allocation and operations statistics variables

DECLARE_CLASS_ALLOC_STAT_STORAGE(CLKRLinearHashTable, SegDir);
DECLARE_CLASS_ALLOC_STAT_STORAGE(CLKRLinearHashTable, Segment);
DECLARE_CLASS_ALLOC_STAT_STORAGE(CLKRLinearHashTable, NodeClump);
DECLARE_CLASS_ALLOC_STAT_STORAGE(CLKRHashTable,       SubTable);

DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, InsertRecord);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, FindKey);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, FindRecord);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, DeleteKey);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, DeleteRecord);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, FindKeyMultiRec);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, DeleteKeyMultiRec);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, Expand);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, Contract);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, LevelExpansion);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, LevelContraction);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, ApplyIf);
DECLARE_CLASS_OP_STAT_STORAGE(CLKRLinearHashTable, DeleteIf);


int g_fLKRhashInitialized = FALSE;
static LONG g_nLkrInitCount = 0;
CSimpleLock g_lckLkrInit;



// -------------------------------------------------------------------------
// Initialize per-class allocators and other global initialization
// -------------------------------------------------------------------------

int
LKR_Initialize(
    DWORD dwInitFlags)
{
    int f = TRUE;

    g_lckLkrInit.Enter();

    LONG nCount = g_nLkrInitCount;

    IRTLTRACE(_TEXT("LKR_Initialize")
#ifdef LKRHASH_KERNEL_MODE
              _TEXT(" (kernel)")
#endif
              _TEXT("%ld: Flags=0x%08x, Allocator=%s,\n")
              _TEXT("\tTableLock=%s, BucketLock=%s.\n"),
              nCount, dwInitFlags, CLKRhashAllocator::ClassName(),
              LKRHASH_NS::CLKRHashTable::TableLock::ClassName(),
              LKRHASH_NS::CLKRHashTable::BucketLock::ClassName()
              );

    // Keep track of how many times LKR_Initialize() has been called,
    // but only allow the first caller to have any effect
    
    if (++g_nLkrInitCount == 1)
    {
        g_fDebugOutputEnabled = (dwInitFlags & LK_INIT_DEBUG_SPEW) != 0;

        f = Locks_Initialize();

        if (f)  f = LKRHASH_NS::CLKRLinearHashTable::_Initialize(dwInitFlags);
        if (f)  f = LKRHASH_NS::CLKRHashTable::_Initialize(dwInitFlags);
        if (f)  f = LKRHASH_NS::CNodeClump::_Initialize(dwInitFlags);
        if (f)  f = LKRHASH_NS::CBucket::_Initialize(dwInitFlags);
        if (f)  f = LKRHASH_NS::CSmallSegment::_Initialize(dwInitFlags);
        if (f)  f = LKRHASH_NS::CMediumSegment::_Initialize(dwInitFlags);
        if (f)  f = LKRHASH_NS::CLargeSegment::_Initialize(dwInitFlags);
        
        g_fLKRhashInitialized = f;
    }

    g_lckLkrInit.Leave();

    return f;
} // LKR_Initialize



// -------------------------------------------------------------------------
// Destroy per-class allocators and other global cleanup
// -------------------------------------------------------------------------

void
LKR_Terminate()
{
    g_lckLkrInit.Enter();

    LONG nCount = g_nLkrInitCount;

    UNREFERENCED_PARAMETER(nCount);

    // Last call to LKR_Terminate?
    
    if (--g_nLkrInitCount == 0)
    {
        LKRHASH_NS::CLargeSegment::_Terminate();
        LKRHASH_NS::CMediumSegment::_Terminate();
        LKRHASH_NS::CSmallSegment::_Terminate();
        LKRHASH_NS::CBucket::_Terminate();
        LKRHASH_NS::CNodeClump::_Terminate();
        LKRHASH_NS::CLKRHashTable::_Terminate();
        LKRHASH_NS::CLKRLinearHashTable::_Terminate();

        Locks_Cleanup();

        g_fLKRhashInitialized = false;
    }

    g_lckLkrInit.Leave();

    IRTLTRACE1("LKR_Terminate done, %ld\n", nCount);
} // LKR_Terminate



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CBucket::sm_cBuckets            = 0;

LONG CLKRLinearHashTable::sm_cTables = 0;
#endif // LOCK_INSTRUMENTATION


#ifndef LKR_NO_GLOBAL_LIST
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NO_GLOBAL_LIST


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CLKRLinearHashTable::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_INIT(CLKRLinearHashTable, 20, 'hlKL', f);
#endif

    INIT_CLASS_ALLOC_STAT(CLKRLinearHashTable, SegDir);
    INIT_CLASS_ALLOC_STAT(CLKRLinearHashTable, Segment);
    INIT_CLASS_ALLOC_STAT(CLKRLinearHashTable, NodeClump);

    INIT_CLASS_OP_STAT(CLKRLinearHashTable, InsertRecord);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, FindKey);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, FindRecord);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, DeleteKey);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, DeleteRecord);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, FindKeyMultiRec);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, DeleteKeyMultiRec);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, Expand);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, Contract);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, ApplyIf);
    INIT_CLASS_OP_STAT(CLKRLinearHashTable, DeleteIf);

    return f;
} // CLKRLinearHashTable::_Initialize



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CLKRLinearHashTable::_Terminate()
{
    VALIDATE_DUMP_CLASS_ALLOC_STAT(CLKRLinearHashTable, SegDir);
    VALIDATE_DUMP_CLASS_ALLOC_STAT(CLKRLinearHashTable, Segment);
    VALIDATE_DUMP_CLASS_ALLOC_STAT(CLKRLinearHashTable, NodeClump);

    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, InsertRecord);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, FindKey);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, FindRecord);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, DeleteKey);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, DeleteRecord);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, FindKeyMultiRec);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, DeleteKeyMultiRec);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, Expand);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, Contract);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, LevelExpansion);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, LevelContraction);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, ApplyIf);
    DUMP_CLASS_OP_STAT(CLKRLinearHashTable, DeleteIf);

#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_UNINIT(CLKRLinearHashTable);
#endif

} // CLKRLinearHashTable::_Terminate



//------------------------------------------------------------------------
// Function: CLKRHashTable::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CLKRHashTable::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_INIT(CLKRHashTable, 4, 'thKL', f);
#endif

    INIT_CLASS_ALLOC_STAT(CLKRHashTable, SubTable);

    return f;
} // CLKRHashTable::_Initialize



//------------------------------------------------------------------------
// Function: CLKRHashTable::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CLKRHashTable::_Terminate()
{
    VALIDATE_DUMP_CLASS_ALLOC_STAT(CLKRHashTable, SubTable);

#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_UNINIT(CLKRHashTable);
#endif
} // CLKRHashTable::_Terminate



//------------------------------------------------------------------------
// Function: CNodeClump::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CNodeClump::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    LKRHASH_ALLOCATOR_INIT(CNodeClump, 200, 'cnKL', f);
    return f;
} // CNodeClump::_Initialize



//------------------------------------------------------------------------
// Function: CNodeClump::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CNodeClump::_Terminate()
{
    LKRHASH_ALLOCATOR_UNINIT(CNodeClump);
} // CLKRLinearHashTable::_Terminate



//------------------------------------------------------------------------
// Function: CBucket::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CBucket::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    return f;
} // CBucket::_Initialize



//------------------------------------------------------------------------
// Function: CBucket::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CBucket::_Terminate()
{
} // CBucket::_Terminate



//------------------------------------------------------------------------
// Function: CSmallSegment::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CSmallSegment::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    LKRHASH_ALLOCATOR_INIT(CSmallSegment, 5, 'ssKL', f);
    CSmallSegment::CompileTimeAssertions();
    return f;
} // CSmallSegment::_Initialize



//------------------------------------------------------------------------
// Function: CSmallSegment::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CSmallSegment::_Terminate()
{
    LKRHASH_ALLOCATOR_UNINIT(CSmallSegment);
} // CSmallSegment::_Terminate



//------------------------------------------------------------------------
// Function: CMediumSegment::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CMediumSegment::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    LKRHASH_ALLOCATOR_INIT(CMediumSegment, 5, 'msKL', f);
    CMediumSegment::CompileTimeAssertions();
    return f;
} // CMediumSegment::_Initialize



//------------------------------------------------------------------------
// Function: CMediumSegment::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CMediumSegment::_Terminate()
{
    LKRHASH_ALLOCATOR_UNINIT(CMediumSegment);
} // CMediumSegment::_Terminate



//------------------------------------------------------------------------
// Function: CLargeSegment::_Initialize
// Synopsis: 
//------------------------------------------------------------------------

/* static */ int
CLargeSegment::_Initialize(
    DWORD dwFlags)
{
    int f = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    CLargeSegment::CompileTimeAssertions();
    LKRHASH_ALLOCATOR_INIT(CLargeSegment, 5, 'lsKL', f);
    return f;
} // CLargeSegment::_Initialize



//------------------------------------------------------------------------
// Function: CLargeSegment::_Terminate
// Synopsis: 
//------------------------------------------------------------------------

/* static */ void
CLargeSegment::_Terminate()
{
    LKRHASH_ALLOCATOR_UNINIT(CLargeSegment);
} // CLargeSegment::_Terminate


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-del-keyrec.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-del-keyrec.cpp

   Abstract:
       DeleteKey, DeleteRecord, _DeleteNode, DeleteKeyMultipleRecords,
       _Contract, _MergeSortBucketChains, and _AppendBucketChain.

   Author:
       George V. Reilly      (GeorgeRe)     May 2000

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:
       May 2000

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           subtable (if it exists).
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash subtable not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    const DWORD     dwSignature,
    const void**    ppvRecord,
    bool            fDeleteAllSame)
{
    IRTLASSERT(IsUsable());
    IRTLASSERT(ppvRecord == NULL  ||  *ppvRecord == NULL);
    IRTLASSERT(HASH_INVALID_SIGNATURE != dwSignature);

    INCREMENT_OP_STAT(DeleteKey);

    unsigned   cFound = 0;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // Lock the subtable, find the appropriate bucket, then lock that.
    this->WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    // Locate the beginning of the correct bucket chain
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    
    PBucket const pbkt = _BucketFromAddress(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (_UseBucketLocking())
        pbkt->WriteLock();

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbkt));
    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    // Now that bucket is locked, can release subtable lock
    if (_UseBucketLocking())
        this->WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (PNodeClump pncCurr =   pbkt->FirstClump(), pncPrev = NULL;
                    pncCurr !=  NULL;
                    pncPrev =   pncCurr, pncCurr = pncCurr->NextClump())
    {
        FOR_EACH_NODE_DECL(iNode)
        {
            // Reached end of bucket chain?
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->NoMoreValidSlots(iNode));
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
            {
                if (m_fMultiKeys &&  dwSignature < pncCurr->m_dwKeySigs[iNode])
                {
                    // Signatures are sorted. We've gone past the point
                    // where this signature can possibly be.
                    
#ifdef IRTLDEBUG
                    NodeIndex j = iNode;  // start at current node
                    
                    for (PNodeClump pnc =  pncCurr;
                                    pnc != NULL;
                                    pnc =  pnc->NextClump())
                    {
                        for ( ;  j != _NodeEnd();  j += _NodeStep())
                        {
                            if (pnc->IsEmptySlot(j))
                                IRTLASSERT(pnc->NoMoreValidSlots(j));
                            else
                                IRTLASSERT(dwSignature < pnc->m_dwKeySigs[j]);
                        }
                            
                        j = _NodeBegin(); // reinitialize for remaining nodes
                    }
#endif // IRTLDEBUG

                    goto exit;
                }

                // Signature doesn't match, but it may still be present
                // in the sorted/unsorted bucket chain
                continue;   // next iNode
            }

            IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[iNode]);

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);
            const int       nCmp   = ((pnKey == pnKey2)
                                       ?  0
                                       :  _CompareKeys(pnKey,  pnKey2));

            if (nCmp == 0)
            {
                LK_ADDREF_REASON lkar;

                // Save first matching record, if caller requested
                if (ppvRecord != NULL  &&  cFound == 0)
                {
                    *ppvRecord = pncCurr->m_pvNode[iNode];
#ifndef LKR_ALLOW_NULL_RECORDS
                    IRTLASSERT(NULL != *ppvRecord);
#endif
                    // Don't want to release refcount if returning record to
                    // caller. LKAR_ZERO is a special case for _DeleteNode.
                    lkar = LKAR_ZERO;
                }
                else
                {
                    // Release reference on all other matching records
                    lkar = LKAR_DELETE_KEY;
                }
                    
                ++cFound;
                _DeleteNode(pbkt, pncCurr, pncPrev, iNode, lkar);

                lkrc = LK_SUCCESS;

                if (! fDeleteAllSame)
                    goto exit;
            }
            else if (m_fMultiKeys  &&  nCmp < 0)
            {
                // Gone past the point where this signature could found
                // be in the sorted bucket chain.
                goto exit;
            }
        }
    }

  exit:
    if (_UseBucketLocking())
        pbkt->WriteUnlock();
    else
        this->WriteUnlock();


#ifdef LKR_CONTRACT
    if (lkrc == LK_SUCCESS)
    {
# ifdef LKR_CONTRACT_BY_DIVISION
        // contract the subtable if necessary
        unsigned nContractedBuckets = m_cRecords / m_MaxLoad;

#  ifdef LKR_HYSTERESIS
        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedBuckets += nContractedBuckets >> 4;

        // Always want to have at least m_nSegSize buckets
        nContractedBuckets =  max(nContractedBuckets, m_nSegSize);
#  endif // LKR_HYSTERESIS

        while (m_cActiveBuckets > nContractedBuckets)

# else  // !LKR_CONTRACT_BY_DIVISION

        // contract the subtable if necessary
        unsigned nContractedRecords = m_cRecords; 

#  ifdef LKR_HYSTERESIS
        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedRecords += nContractedRecords >> 4;
#  endif // LKR_HYSTERESIS

        // Always want to have at least m_nSegSize buckets
        while (m_cActiveBuckets * m_MaxLoad > nContractedRecords
               && m_cActiveBuckets > m_nSegSize)

# endif // !LKR_CONTRACT_BY_DIVISION
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the subtable by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }
#endif // LKR_CONTRACT

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteKey(
    const DWORD_PTR pnKey,
    const void**    ppvRecord,     /* =NULL */
    bool            fDeleteAllSame /* =false */)
{
    if (!IsUsable())
        return m_lkrcState;

    if (ppvRecord != NULL)
        *ppvRecord = NULL;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lkrc     = pst->_DeleteKey(pnKey, hash_val,
                                          ppvRecord, fDeleteAllSame);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash subtable (if it
//           exists).  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If _DeleteKey were called for
//           a record that doesn't exist in the subtable, it could delete some
//           completely unrelated record that happened to have the same key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the subtable.
//           LK_UNUSABLE, if hash subtable not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    const DWORD dwSignature
    )
{
    IRTLASSERT(IsUsable());
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(HASH_INVALID_SIGNATURE != dwSignature);

    INCREMENT_OP_STAT(DeleteRecord);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // Lock the subtable, find the appropriate bucket, then lock that.
    this->WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    // Locate the beginning of the correct bucket chain
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    
    PBucket const pbkt = _BucketFromAddress(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (_UseBucketLocking())
        pbkt->WriteLock();

    // Now that bucket is locked, can release subtable lock
    if (_UseBucketLocking())
        this->WriteUnlock();

    IRTLASSERT(dwSignature == _CalcKeyHash(_ExtractKey(pvRecord)));

    // scan down the bucket chain, looking for the victim
    for (PNodeClump pncCurr =   pbkt->FirstClump(), pncPrev = NULL;
                    pncCurr !=  NULL;
                    pncPrev =   pncCurr, pncCurr = pncCurr->NextClump())
    {
        FOR_EACH_NODE_DECL(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->NoMoreValidSlots(iNode));
                IRTLASSERT(0 == _IsBucketChainCompact(pbkt));
                goto exit;
            }

            const void* pvCurrRecord = pncCurr->m_pvNode[iNode];

            if (pvCurrRecord == pvRecord)
            {
                IRTLASSERT(0 == _CompareKeys(_ExtractKey(pvRecord),
                                             _ExtractKey(pvCurrRecord)));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[iNode]);

                _DeleteNode(pbkt, pncCurr, pncPrev, iNode, LKAR_DELETE_RECORD);

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    if (_UseBucketLocking())
        pbkt->WriteUnlock();
    else
        this->WriteUnlock();


#ifdef LKR_CONTRACT
    if (lkrc == LK_SUCCESS)
    {
# ifdef LKR_CONTRACT_BY_DIVISION
        // contract the subtable if necessary
        unsigned nContractedBuckets = m_cRecords / m_MaxLoad;

#  ifdef LKR_HYSTERESIS
        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedBuckets += nContractedBuckets >> 4;

        // Always want to have at least m_nSegSize buckets
        nContractedBuckets =  max(nContractedBuckets, m_nSegSize);
#  endif // LKR_HYSTERESIS

        while (m_cActiveBuckets > nContractedBuckets)

# else  // !LKR_CONTRACT_BY_DIVISION

        // contract the subtable if necessary
        unsigned nContractedRecords = m_cRecords; 

#  ifdef LKR_HYSTERESIS
        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedRecords += nContractedRecords >> 4;
#  endif // LKR_HYSTERESIS

        // Always want to have at least m_nSegSize buckets
        while (m_cActiveBuckets * m_MaxLoad > nContractedRecords
               && m_cActiveBuckets > m_nSegSize)

# endif // !LKR_CONTRACT_BY_DIVISION
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the subtable by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }
#endif // LKR_CONTRACT

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteRecord(
    const void* pvRecord)
{
    if (!IsUsable())
        return m_lkrcState;
    
#ifndef LKR_ALLOW_NULL_RECORDS
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
#endif
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lkrc     = pst->_DeleteRecord(pvRecord, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKeyMultipleRecords
// Synopsis: 
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKeyMultipleRecords(
    const DWORD_PTR         pnKey,
    const DWORD             dwSignature,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr)
{
    INCREMENT_OP_STAT(DeleteKeyMultiRec);

    UNREFERENCED_PARAMETER(pnKey);          // for /W4
    UNREFERENCED_PARAMETER(dwSignature);    // for /W4
    UNREFERENCED_PARAMETER(pcRecords);      // for /W4
    UNREFERENCED_PARAMETER(pplmr);          // for /W4

    IRTLASSERT(! "DeleteKeyMultipleRecords not implemented yet");

    return LK_BAD_TABLE;
} // CLKRLinearHashTable::_DeleteKeyMultipleRecords



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteKeyMultipleRecords
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteKeyMultipleRecords(
    const DWORD_PTR         pnKey,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pcRecords == NULL)
        return LK_BAD_PARAMETERS;

    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_DeleteKeyMultipleRecords(pnKey, hash_val,
                                                          pcRecords, pplmr);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::DeleteKeyMultipleRecords




//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//
// TODO: Is the rpncPrev parameter really necessary?
//       Is the backing up of (rpnc, riNode) really necessary?
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_DeleteNode(
    PBucket const    pbkt,      // bucket chain containing node
    PNodeClump&      rpnc,      // actual node
    PNodeClump&      rpncPrev,  // predecessor of actual node, or NULL
    NodeIndex&       riNode,    // index within node
    LK_ADDREF_REASON lkar)      // Where called from
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->NextClump() == rpnc);
    IRTLASSERT(rpncPrev != NULL
                ?  rpnc != pbkt->FirstClump()  :  rpnc == pbkt->FirstClump());
    IRTLASSERT(0 <= riNode  &&  riNode < _NodesPerClump());
    IRTLASSERT(! rpnc->IsEmptyAndInvalid(riNode));
    IRTLASSERT(lkar <= 0);

#ifdef IRTLDEBUG
    // Check that the node clump really does belong to the bucket
    PNodeClump pnc1 = pbkt->FirstClump();

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->NextClump();

    IRTLASSERT(pnc1 == rpnc);
#endif // IRTLDEBUG

    // Release the reference to the record
    if (lkar != LKAR_ZERO)
        _AddRefRecord(rpnc->m_pvNode[riNode], lkar);

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbkt));
    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    PNodeClump pncEnd   = rpnc;
    NodeIndex  iNodeEnd = riNode;

    // Find the last nodeclump in the chain
    while (! pncEnd->IsLastClump())
    {
         pncEnd   = pncEnd->NextClump();
         iNodeEnd = _NodeBegin();
    }

    IRTLASSERT(0 <= iNodeEnd  &&  iNodeEnd < _NodesPerClump());
    IRTLASSERT(! pncEnd->IsEmptyAndInvalid(iNodeEnd));

    // Find the first empty slot in the nodeclump
    while (iNodeEnd != _NodeEnd()  &&  !pncEnd->IsEmptySlot(iNodeEnd))
    {
        iNodeEnd += _NodeStep();
    }

    // Back up to last non-empty slot
    iNodeEnd -= _NodeStep();
    IRTLASSERT(0 <= iNodeEnd  &&  iNodeEnd < _NodesPerClump()
               &&  ! pncEnd->IsEmptyAndInvalid(iNodeEnd));
    IRTLASSERT(iNodeEnd + _NodeStep() == _NodeEnd()
               ||  pncEnd->NoMoreValidSlots(iNodeEnd + _NodeStep()));

    if (m_fMultiKeys)
    {
        // Keep bucket chain sorted
        NodeIndex i = riNode; // start with this node

        // Shift all nodes back by one to close the gap
        for (PNodeClump pncCurr =  rpnc;
                        pncCurr != NULL;
                        pncCurr =  pncCurr->NextClump())
        {
            const NodeIndex iLast = ((pncCurr == pncEnd)
                                     ?  iNodeEnd  :  _NodeEnd());

            for ( ;  i != iLast;  i += _NodeStep())
            {
                NodeIndex  iNext   = i + _NodeStep();
                PNodeClump pncNext = pncCurr;

                if (iNext == _NodeEnd())
                {
                    iNext = _NodeBegin();
                    pncNext = pncCurr->NextClump();
                }

                IRTLASSERT(0 <= iNext  &&  iNext < _NodesPerClump());
                IRTLASSERT(pncNext != NULL
                           &&  ! pncNext->IsEmptyAndInvalid(iNext));

                pncCurr->m_dwKeySigs[i] = pncNext->m_dwKeySigs[iNext];
                pncCurr->m_pvNode[i]    = pncNext->m_pvNode[iNext];
            }

            i = _NodeBegin(); // reinitialize for remaining nodeclumps
        }
    }
    else
    {
        // Move the last node's data back to the current node
        rpnc->m_pvNode[riNode]    = pncEnd->m_pvNode[iNodeEnd];
        rpnc->m_dwKeySigs[riNode] = pncEnd->m_dwKeySigs[iNodeEnd];
    }
        
    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pncEnd, iNodeEnd).
    pncEnd->m_pvNode[iNodeEnd]    = NULL;
    pncEnd->m_dwKeySigs[iNodeEnd] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbkt));
    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != _NodeBegin())
    {
        riNode -= _NodeStep();
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == pbkt->FirstClump())
        {
            riNode = _NodeBegin() - _NodeStep();
            IRTLASSERT(rpncPrev == NULL);
        }
        else
        {
            IRTLASSERT(rpncPrev != NULL);
            riNode = _NodeEnd();
            rpnc = rpncPrev;

            if (rpnc == pbkt->FirstClump())
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev =  pbkt->FirstClump();
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev =  rpncPrev->NextClump())
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNodeEnd == _NodeBegin()  &&  pncEnd != pbkt->FirstClump())
    {
        // Find preceding nodeclump
        PNodeClump pnc3 = pbkt->FirstClump();

        while (pnc3->NextClump() != pncEnd)
        {
            pnc3 = pnc3->NextClump();
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef IRTLDEBUG
//      pncEnd->m_pncNext = NULL; // or dtor will ASSERT
#endif // IRTLDEBUG

        _FreeNodeClump(pncEnd);
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->NextClump() == rpnc);
    IRTLASSERT(rpncPrev != NULL
                ?  rpnc != pbkt->FirstClump()  :  rpnc == pbkt->FirstClump());

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the subtable by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    INCREMENT_OP_STAT(Contract);

    this->WriteLock();

    IRTLASSERT(m_cActiveBuckets >= m_nSegSize);

    // Always keep at least m_nSegSize buckets in the table;
    // i.e., one segment's worth.
    if (m_cActiveBuckets <= m_nSegSize)
    {
        this->WriteUnlock();
        return LK_ALLOC_FAIL;
    }

    _DecrementExpansionIndex();

    // The last bucket is the one that will be emptied
    IRTLASSERT(m_cActiveBuckets > 0);

    PBucket const pbktOld = _BucketFromAddress(m_cActiveBuckets - 1);

    if (_UseBucketLocking())
        pbktOld->WriteLock();

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbktOld));
    IRTLASSERT(0 == _IsBucketChainCompact(pbktOld));

    // Decrement after calculating pbktOld, or _BucketFromAddress()
    // will assert.
    --m_cActiveBuckets;
    IRTLASSERT(m_cActiveBuckets == ((1 << m_nLevel) | m_iExpansionIdx));

    // Where the nodes from pbktOld will end up
    PBucket const pbktNew = _BucketFromAddress(m_iExpansionIdx);

    if (_UseBucketLocking())
        pbktNew->WriteLock();

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbktNew));
    IRTLASSERT(0 == _IsBucketChainCompact(pbktNew));


    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _AppendBucketChain, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    PNodeClump pnc;
    unsigned   cOldNodes = 0, cNewNodes = 0, cEmptyNodes = 0;
    NodeIndex  i;

    // First, count the number of items in the old bucket chain
    for (pnc = pbktOld->FirstClump();
         !pnc->IsLastClump();
         pnc = pnc->NextClump())
    {
        cOldNodes += _NodesPerClump();

#ifdef IRTLDEBUG
        FOR_EACH_NODE(i)
        {
            IRTLASSERT(! pnc->IsEmptyAndInvalid(i));
        }
#endif // IRTLDEBUG
    }

    IRTLASSERT(pnc != NULL  &&  pnc->IsLastClump()
               &&  (pnc == pbktOld->FirstClump()  ||  !pnc->NoValidSlots()));
    
    FOR_EACH_NODE(i)
    {
        if (! pnc->IsEmptySlot(i))
        {
            IRTLASSERT(! pnc->IsEmptyAndInvalid(i));
            ++cOldNodes;
        }
        else
        {
            IRTLASSERT(pnc->NoMoreValidSlots(i));
            break;
        }
    }


    // Then, subtract off the number of empty slots in the final
    // nodeclump of the new bucket chain. (The preceding nodeclumps
    // are all full, by definition.)

    for (pnc = pbktNew->FirstClump();
         !pnc->IsLastClump();
         pnc = pnc->NextClump())
    {
        cNewNodes += _NodesPerClump();

#ifdef IRTLDEBUG
        FOR_EACH_NODE(i)
        {
            IRTLASSERT(!pnc->IsEmptyAndInvalid(i));
        }
#endif // IRTLDEBUG
    }

    IRTLASSERT(pnc != NULL  &&  pnc->IsLastClump()
               &&  (pnc == pbktNew->FirstClump()  ||  !pnc->NoValidSlots()));

    FOR_EACH_NODE(i)
    {
        if (pnc->IsEmptySlot(i))
        {
            // if (pnc != pbktNew->FirstClump())
            {
                cEmptyNodes = ((_NodeStep() > 0)
                               ?  _NodesPerClump() - i  :  i + 1);

#ifdef IRTLDEBUG
                IRTLASSERT(pnc->NoMoreValidSlots(i));
                unsigned c = 0;
                
                for (NodeIndex j = i;  j != _NodeEnd();  j += _NodeStep())
                {
                    IRTLASSERT(pnc->IsEmptySlot(j));
                    ++c;
                }

                IRTLASSERT(c == cEmptyNodes);
#endif // IRTLDEBUG
            }

            break;
        }
        else
        {
            IRTLASSERT(! pnc->IsEmptyAndInvalid(i));
            ++cNewNodes;
        }
    }

    // If the new bucket is empty, can just append the contents of
    // the old bucket to it. Otherwise, can only append if not multikeys.
    bool fAppendNodes = (cNewNodes == 0) ? true : !m_fMultiKeys;

    //
    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    //

    PNodeClump pncFreeList     = NULL;  // list of nodes available for reuse
    LK_RETCODE lkrc            = LK_SUCCESS;
    unsigned   nFreeListLength = 0;

    if (cOldNodes > 0)
    {
        if (fAppendNodes)
        {
            const int cNetNodes = cOldNodes - cEmptyNodes;

            if (cNetNodes > 0)
            {
                nFreeListLength = 1;

                if (cNetNodes > _NodesPerClump())
                {
                    // In the worst case, we need a 2-element freelist for
                    // _AppendBucketChain. Two CNodeClumps always suffice since
                    // the freelist will be augmented by the CNodeClumps from
                    // the old bucket chain as they are processed.
                    nFreeListLength = 2;
                }
            }
        }
        else
        {
            // Have to merge-sort old and new bucket chains
            IRTLASSERT(m_fMultiKeys);

            const unsigned cTotalNodes = cOldNodes + cNewNodes;

            if (cTotalNodes > 1u * _NodesPerClump())
            {
                nFreeListLength = 1;

                if (cTotalNodes > 2u * _NodesPerClump())
                {
                    nFreeListLength = 2;

                    if (cTotalNodes > 3u * _NodesPerClump())
                    {
                        nFreeListLength = 3;
                    }
                }
            }
        }
    }

    IRTLASSERT(nFreeListLength <= 3);

    for (unsigned iFree = 0;  iFree < nFreeListLength;  ++iFree)
    {
        pnc = _AllocateNodeClump();

        if (NULL == pnc)
        {
            lkrc = LK_ALLOC_FAIL;
            break;
        }

        pnc->m_pncNext = pncFreeList;
        pncFreeList = pnc;
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        _IncrementExpansionIndex();

        ++m_cActiveBuckets;

        while (pncFreeList != NULL)
        {
            pnc = pncFreeList;
            pncFreeList = pncFreeList->NextClump();
#ifdef IRTLDEBUG
            pnc->Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
            _FreeNodeClump(pnc);
        }
        
        // Unlock the buckets and the subtable
        if (_UseBucketLocking())
        {
            pbktNew->WriteUnlock();
            pbktOld->WriteUnlock();
        }

        this->WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktOld
    CNodeClump ncOldFirst(pbktOld->m_ncFirst);

    // destroy pbktOld
    pbktOld->m_ncFirst.Clear();

    if (_UseBucketLocking())
        pbktOld->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef IRTLDEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);

        for (DWORD iBkt = 0;  iBkt < m_nSegSize;  ++iBkt)
        {
            PBucket const pbkt = &_Segment(m_cActiveBuckets)->Slot(iBkt);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->NoValidSlots());
        }
#endif // IRTLDEBUG

        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs << (m_nSegBits - 1))
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        IRTLASSERT((cDirSegsNew & (cDirSegsNew-1)) == 0);  // == (1 << N)

        PSegment* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            // copy segments from old directory
            for (DWORD j = 0;  j < cDirSegsNew;  ++j)
                paDirSegsNew[j] = m_paDirSegs[j];

            // clear and free old directory
            for (j = 0;  j < m_cDirSegs;  ++j)
                m_paDirSegs[j] = NULL;
            _FreeSegmentDirectory();

            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the subtable lock before doing the reorg
    if (_UseBucketLocking())
        this->WriteUnlock();

    if (cOldNodes > 0)
    {
        if (fAppendNodes)
            lkrc = _AppendBucketChain(pbktNew, ncOldFirst, pncFreeList);
        else
            lkrc = _MergeSortBucketChains(pbktNew, ncOldFirst, pncFreeList);
    }
    else
    {
        IRTLASSERT(ncOldFirst.NoValidSlots());
        IRTLASSERT(NULL == pncFreeList);
    }

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbktNew));
    IRTLASSERT(0 == _IsBucketChainCompact(pbktNew));

    if (_UseBucketLocking())
        pbktNew->WriteUnlock();
    else
        this->WriteUnlock();

#ifdef IRTLDEBUG
    ncOldFirst.Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeSortBucketChains
// Synopsis: Merge two sorted record sets when m_fMultiKeys is enabled.
// Merge the contents of rncOldFirst into pbktTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeSortBucketChains(
    PBucket const pbktTarget,
    CNodeClump&   rncOldFirst,
    PNodeClump    pncFreeList
    )
{
    IRTLASSERT(m_fMultiKeys);
    IRTLASSERT(pbktTarget != NULL);
    IRTLASSERT(pbktTarget->IsWriteLocked());

    PNodeClump pncOldList = &rncOldFirst;
    PNodeClump pncTmp;

    // Copy the chain of records from pbktTarget
    CNodeClump ncNewFirst(pbktTarget->m_ncFirst);
    PNodeClump pncNewList = &ncNewFirst;

    // Zap pbktTarget
    PNodeClump pncTarget = pbktTarget->FirstClump();
    pncTarget->Clear();

    IRTLASSERT(pncOldList != NULL  &&  pncNewList != NULL);

#ifdef IRTLDEBUG
    unsigned cFreeListExhaustions = (pncFreeList == NULL);

const int MAX_NODES = 500;
int iA, aTarget[MAX_NODES];
for (iA = 0;  iA < MAX_NODES; ++iA)
    aTarget[iA] = 0;
iA = 0;

    // Calculate how many nodes there are in the old and new bucket chains,
    // so that we can double-check that the target gets the correct number
    // of nodes.
    unsigned cOldNodes = 0, cNewNodes = 0, cFromOld = 0, cFromNew = 0;
    NodeIndex iTmp;

    for (pncTmp = pncOldList;  pncTmp != NULL;  pncTmp = pncTmp->NextClump())
    {
        FOR_EACH_NODE(iTmp)
        {
            if (! pncTmp->IsEmptyAndInvalid(iTmp))
                ++cOldNodes;
            else
                IRTLASSERT(pncTmp->NoMoreValidSlots(iTmp));
        }
    }

    for (pncTmp = pncNewList;  pncTmp != NULL;  pncTmp = pncTmp->NextClump())
    {
        FOR_EACH_NODE(iTmp)
        {
            if (! pncTmp->IsEmptyAndInvalid(iTmp))
                ++cNewNodes;
            else
                IRTLASSERT(pncTmp->NoMoreValidSlots(iTmp));
        }
    }
#endif // IRTLDEBUG
    
    NodeIndex iOldSlot = _NodeBegin();
    NodeIndex iNewSlot = _NodeBegin();
    NodeIndex iTarget  = _NodeBegin();

    if (pncOldList->IsEmptySlot(iOldSlot))
    {
        // Check that all the remaining nodes are empty
        IRTLASSERT(pncOldList->NoMoreValidSlots(iOldSlot));
        pncOldList = NULL;
    }

    if (pncNewList->IsEmptySlot(iNewSlot))
    {
        IRTLASSERT(pncNewList->NoMoreValidSlots(iNewSlot));
        pncNewList = NULL;
    }

    bool fNodesLeft = (pncOldList != NULL  ||  pncNewList != NULL);
    IRTLASSERT(fNodesLeft);
    
    while (fNodesLeft)
    {
        for (iTarget =  _NodeBegin();
             iTarget != _NodeEnd()  &&  fNodesLeft;
             iTarget += _NodeStep())
        {
            bool fFromOld; // draw from old list or new list?
            
#ifdef IRTLDEBUG
++iA;
#endif
            IRTLASSERT(pncTarget->NoMoreValidSlots(iTarget));
            
            IRTLASSERT(0 <= iOldSlot  &&  iOldSlot < _NodesPerClump());
            IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < _NodesPerClump());

            if (pncOldList == NULL)
            {
                IRTLASSERT(pncNewList != NULL);
                IRTLASSERT(!pncNewList->IsEmptySlot(iNewSlot));
                fFromOld = false;
            }
            else
            {
                IRTLASSERT(! pncOldList->IsEmptySlot(iOldSlot));

                if (pncNewList == NULL)
                {
                    fFromOld = true;
                }
                else
                {
                    IRTLASSERT(! pncNewList->IsEmptySlot(iNewSlot));

                    const DWORD dwOldSig = pncOldList->m_dwKeySigs[iOldSlot];
                    const DWORD dwNewSig = pncNewList->m_dwKeySigs[iNewSlot];

                    IRTLASSERT(HASH_INVALID_SIGNATURE != dwOldSig);
                    IRTLASSERT(HASH_INVALID_SIGNATURE != dwNewSig);

                    if (dwOldSig < dwNewSig)
                    {
                        fFromOld = true;
                    }
                    else if (dwOldSig > dwNewSig)
                    {
                        fFromOld = false;
                    }
                    else
                    {
                        IRTLASSERT(dwOldSig == dwNewSig);

                        // Find the relative ordering of the multikeys
                        const DWORD_PTR pnOldKey
                            = _ExtractKey(pncOldList->m_pvNode[iOldSlot]);
                        const DWORD_PTR pnNewKey
                            = _ExtractKey(pncNewList->m_pvNode[iNewSlot]);

                        const int nCmp = _CompareKeys(pnOldKey, pnNewKey);

                        fFromOld = (nCmp <= 0);
                    }
                }
            } // pncOldList != NULL

            if (fFromOld)
            {
                IRTLASSERT(0 <= iOldSlot  &&  iOldSlot < _NodesPerClump()
                           &&  pncOldList != NULL
                           &&  ! pncOldList->IsEmptyAndInvalid(iOldSlot));

#ifdef IRTLDEBUG
                IRTLASSERT(cFromOld < cOldNodes);
                ++cFromOld;
#endif // IRTLDEBUG

#ifdef IRTLDEBUG
aTarget[iA - 1] = -iA;
#endif // IRTLDEBUG

                pncTarget->m_dwKeySigs[iTarget]
                    = pncOldList->m_dwKeySigs[iOldSlot];
                pncTarget->m_pvNode[iTarget]
                    = pncOldList->m_pvNode[iOldSlot];

                iOldSlot += _NodeStep();

                if (iOldSlot == _NodeEnd())
                {
                    iOldSlot   = _NodeBegin();
                    pncTmp     = pncOldList;
                    pncOldList = pncOldList->NextClump();

                    // Prepend pncTmp to the free list. Don't put the first
                    // node of pncOldList onto the free list, as it's a
                    // stack variable from the caller
                    if (pncTmp != &rncOldFirst)
                    {
                        pncTmp->m_pncNext = pncFreeList;
                        pncFreeList = pncTmp;
                    }

                    fNodesLeft = (pncOldList != NULL  ||  pncNewList != NULL);
                }
                else if (pncOldList->IsEmptySlot(iOldSlot))
                {
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(pncOldList->NoMoreValidSlots(iOldSlot));

                    if (pncOldList != &rncOldFirst)
                    {
                        pncOldList->m_pncNext = pncFreeList;
                        pncFreeList = pncOldList;
                    }

                    pncOldList = NULL;
                    fNodesLeft = (pncNewList != NULL);
                }

                IRTLASSERT(pncOldList == NULL
                           ||  ! pncOldList->IsEmptyAndInvalid(iOldSlot));
            }

            else // !fFromOld
            {
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < _NodesPerClump()
                           &&  pncNewList != NULL
                           &&  ! pncNewList->IsEmptyAndInvalid(iNewSlot));

#ifdef IRTLDEBUG
                IRTLASSERT(cFromNew < cNewNodes);
                ++cFromNew;
#endif // IRTLDEBUG

#ifdef IRTLDEBUG
aTarget[iA - 1] = +iA;
#endif // IRTLDEBUG

                pncTarget->m_dwKeySigs[iTarget]
                    = pncNewList->m_dwKeySigs[iNewSlot];
                pncTarget->m_pvNode[iTarget]
                    = pncNewList->m_pvNode[iNewSlot];

                iNewSlot += _NodeStep();

                if (iNewSlot == _NodeEnd())
                {
                    iNewSlot   = _NodeBegin();
                    pncTmp     = pncNewList;
                    pncNewList = pncNewList->NextClump();

                    // Prepend pncTmp to the free list. Don't put the first
                    // node of pncNewList onto the free list, as it's a
                    // stack variable.
                    if (pncTmp != &ncNewFirst)
                    {
                        pncTmp->m_pncNext = pncFreeList;
                        pncFreeList = pncTmp;
                    }

                    fNodesLeft = (pncOldList != NULL  ||  pncNewList != NULL);
                }
                else if (pncNewList->IsEmptySlot(iNewSlot))
                {
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(pncNewList->NoMoreValidSlots(iNewSlot));

                    if (pncNewList != &ncNewFirst)
                    {
                        pncNewList->m_pncNext = pncFreeList;
                        pncFreeList = pncNewList;
                    }

                    pncNewList = NULL;
                    fNodesLeft = (pncOldList != NULL);
                }

                IRTLASSERT(pncNewList == NULL
                           ||  ! pncNewList->IsEmptyAndInvalid(iNewSlot));
            } // !fFromOld

        } // for (iTarget ...

        if (fNodesLeft)
        {
            IRTLASSERT(pncFreeList != NULL);

            // Move into the next nodeclump in pncFreeList
            pncTarget->m_pncNext = pncFreeList;
            pncFreeList = pncFreeList->NextClump();
#ifdef IRTLDEBUG
            cFreeListExhaustions += (pncFreeList == NULL);
#endif // IRTLDEBUG

            iTarget   = _NodeBegin();
            pncTarget = pncTarget->NextClump();
            pncTarget->Clear();
        }
    } // while (fNodesLeft)

    IRTLASSERT(pncTarget == NULL
               ||  iTarget == _NodeEnd()
               ||  (iTarget != _NodeBegin()
                    && pncTarget->NoMoreValidSlots(iTarget)));
    IRTLASSERT(cFromOld == cOldNodes);
    IRTLASSERT(cFromNew == cNewNodes);
    IRTLASSERT(0 == _IsBucketChainCompact(pbktTarget));

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->NextClump();

        IRTLASSERT(pncTmp != &rncOldFirst);
        IRTLASSERT(pncTmp != &ncNewFirst);
#ifdef IRTLDEBUG
        pncTmp->Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
//  IRTLASSERT(cFreeListExhaustions > 0);
    ncNewFirst.Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeSortBucketChains



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AppendBucketChain
// Synopsis: Append the contents of pncOldList onto pbktTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_AppendBucketChain(
    PBucket const pbktTarget,
    CNodeClump&   rncOldFirst,
    PNodeClump    pncFreeList
    )
{
    IRTLASSERT(pbktTarget != NULL);
    IRTLASSERT(pbktTarget->IsWriteLocked());

    PNodeClump pncTmp;
    PNodeClump pncOldList = &rncOldFirst;
    PNodeClump pncTarget  = pbktTarget->FirstClump();
    NodeIndex  iOldSlot, iTarget;
#ifdef IRTLDEBUG
    unsigned   cFreeListExhaustions = (pncFreeList == NULL);
#endif // IRTLDEBUG

    IRTLASSERT(pncTarget->NoValidSlots()  ||  !m_fMultiKeys);

    // Find the first nodeclump in the new target bucket with an empty slot.
    // By definition, that's the last nodeclump.
    while (! pncTarget->IsLastClump())
    {
#ifdef IRTLDEBUG
        FOR_EACH_NODE(iTarget)
        {
            IRTLASSERT(! pncTarget->IsEmptyAndInvalid(iTarget));
        }
#endif // IRTLDEBUG
        pncTarget = pncTarget->NextClump();
    }

    IRTLASSERT(pncTarget != NULL  &&  pncTarget->IsLastClump());

    // Find the first empty slot in pncTarget; if none, iTarget == _NodeEnd()
    FOR_EACH_NODE(iTarget)
    {
        if (pncTarget->IsEmptySlot(iTarget))
        {
            break;
        }
    }
    
    IRTLASSERT(iTarget == _NodeEnd()  ||  pncTarget->IsEmptySlot(iTarget));

    // Append each node in pncOldList to pncTarget
    while (pncOldList != NULL)
    {
        FOR_EACH_NODE(iOldSlot)
        {
            if (pncOldList->IsEmptySlot(iOldSlot))
            {
                // Check that all the remaining nodes are empty
                IRTLASSERT(pncOldList->NoMoreValidSlots(iOldSlot));

                break; // out of FOR_EACH_NODE(iOldSlot)...
            }

            // Any empty slots left in pncTarget?
            if (iTarget == _NodeEnd())
            {
                IRTLASSERT(pncTarget->IsLastClump());
                
                // Oops, pncTarget is full. Get a new nodeclump off the
                // free list, which is big enough to handle all needs.
                IRTLASSERT(pncFreeList != NULL);

                pncTmp = pncFreeList;
                pncFreeList = pncFreeList->NextClump();
#ifdef IRTLDEBUG
                cFreeListExhaustions += (pncFreeList == NULL);
#endif // IRTLDEBUG

                pncTarget->m_pncNext = pncTmp;
                pncTarget = pncTmp;
                pncTarget->Clear();
                iTarget = _NodeBegin();
            }
            
            // We have an empty slot in pncTarget
            IRTLASSERT(pncTarget->NoMoreValidSlots(iTarget));
            
            // Let's copy the node from pncOldList
            pncTarget->m_dwKeySigs[iTarget]= pncOldList->m_dwKeySigs[iOldSlot];
            pncTarget->m_pvNode[iTarget] = pncOldList->m_pvNode[iOldSlot];

            iTarget += _NodeStep();

            IRTLASSERT(iTarget == _NodeEnd()
                       ||  pncTarget->IsEmptySlot(iTarget));
        } // FOR_EACH_NODE(iOldSlot)

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->NextClump();

        // Prepend pncTmp to the free list. Don't put the first node of
        // pncOldList on the free list, as it's a stack variable in the caller
        if (pncTmp != &rncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    } // while (pncOldList != NULL ...

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->NextClump();

        IRTLASSERT(pncTmp != &rncOldFirst);
#ifdef IRTLDEBUG
        pncTmp->Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
//  IRTLASSERT(cFreeListExhaustions > 0);
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_AppendBucketChain


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-inline.h ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-inline.h

   Abstract:
       Inlined implementation of important small functions

   Author:
       George V. Reilly      (GeorgeRe)     November 2000

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:
       March 2000

--*/

#ifndef __LKR_INLINE_H__
#define __LKR_INLINE_H__


// See if countdown loops are faster than countup loops for
// traversing a CNodeClump
#ifdef LKR_COUNTDOWN

# define  FOR_EACH_NODE(x)      \
    for (x = NODES_PER_CLUMP;  --x >= 0;  )
# define  FOR_EACH_NODE_DECL(x) \
    for (NodeIndex x = NODES_PER_CLUMP;  --x >= 0;  )

#else // !LKR_COUNTDOWN

# define  FOR_EACH_NODE(x)      \
    for (x = 0;  x < NODES_PER_CLUMP;  ++x)
# define  FOR_EACH_NODE_DECL(x) \
    for (NodeIndex x = 0;  x < NODES_PER_CLUMP;  ++x)

#endif // !LKR_COUNTDOWN


#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// The __forceinline keyword is new to VC6
# define LKR_FORCEINLINE __forceinline
#else
# define LKR_FORCEINLINE inline
#endif


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_H0
// Synopsis: See the Linear Hashing paper
//------------------------------------------------------------------------

LKR_FORCEINLINE
DWORD
CLKRLinearHashTable::_H0(
    DWORD dwSignature,
    DWORD dwBktAddrMask)
{
    return dwSignature & dwBktAddrMask;
} // CLKRLinearHashTable::_H0


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_H0
// Synopsis: 
//------------------------------------------------------------------------

LKR_FORCEINLINE
/* static */
DWORD
CLKRLinearHashTable::_H0(
    DWORD dwSignature) const
{
    return _H0(dwSignature, m_dwBktAddrMask0);
} // CLKRLinearHashTable::_H0


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_H1
// Synopsis: See the Linear Hashing paper. Preserves one bit more than _H0.
//------------------------------------------------------------------------

LKR_FORCEINLINE
/* static */
DWORD
CLKRLinearHashTable::_H1(
    DWORD dwSignature,
    DWORD dwBktAddrMask)
{
    return dwSignature & ((dwBktAddrMask << 1) | 1);
} // CLKRLinearHashTable::_H1


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_H1
// Synopsis: 
//------------------------------------------------------------------------

LKR_FORCEINLINE
DWORD
CLKRLinearHashTable::_H1(
    DWORD dwSignature) const
{
    return _H0(dwSignature, m_dwBktAddrMask1);
} // CLKRLinearHashTable::_H1


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_BucketAddress
// Synopsis: Convert a hash signature to a bucket address
//------------------------------------------------------------------------

LKR_FORCEINLINE
DWORD
CLKRLinearHashTable::_BucketAddress(
    DWORD dwSignature) const
{
    // Check address calculation invariants
    IRTLASSERT(m_dwBktAddrMask0 > 0);
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask0 == ((1U << m_nLevel) - 1));
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT(2 < m_nSegBits  &&  m_nSegBits < 20
               &&  m_nSegSize == (1U << m_nSegBits)
               &&  m_nSegMask == (m_nSegSize - 1));

    DWORD dwBktAddr = _H0(dwSignature);

    // Has this bucket been split already? If so, mask with one more bit
    // and see if this signature maps to the low or the high bucket.
    if (dwBktAddr < m_iExpansionIdx)
        dwBktAddr = _H1(dwSignature);

    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    IRTLASSERT(dwBktAddr < (m_cDirSegs << m_nSegBits));

    return dwBktAddr;
} // CLKRLinearHashTable::_BucketAddress


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_UseBucketLocking
// Synopsis: Use bucket locks or not?
//      The compiler is smart enough to optimize this away, as well
//      as any code protected by `if (_UseBucketLocking())' when
//      it evaluates to `false'.
//------------------------------------------------------------------------

LKR_FORCEINLINE
bool
CLKRLinearHashTable::_UseBucketLocking() const
{
#ifdef LKR_USE_BUCKET_LOCKS
    return true;
#else // !LKR_USE_BUCKET_LOCKS
    return false;
#endif
} // CLKRLinearHashTable::_UseBucketLocking



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Segment
// Synopsis: In which segment within the directory does the bucketaddress lie?
//      Result may be null, so it's up to the caller to validate.
//      (Return type must be lvalue so that it can be assigned to.)
//------------------------------------------------------------------------

LKR_FORCEINLINE
PSegment&
CLKRLinearHashTable::_Segment(
    DWORD dwBucketAddr) const
{
    const DWORD iSeg = (dwBucketAddr >> m_nSegBits);

    IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);

    return m_paDirSegs[iSeg];
} // CLKRLinearHashTable::_Segment


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SegIndex
// Synopsis: Offset within the segment of the bucketaddress
//------------------------------------------------------------------------

LKR_FORCEINLINE
DWORD
CLKRLinearHashTable::_SegIndex(
    DWORD dwBucketAddr) const
{
    const DWORD dwSegIndex = (dwBucketAddr & m_nSegMask);

    IRTLASSERT(dwSegIndex < m_nSegSize);

    return dwSegIndex;
} // CLKRLinearHashTable::_SegIndex


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_BucketFromAddress
// Synopsis: Convert a bucketaddress to a PBucket
//------------------------------------------------------------------------

LKR_FORCEINLINE
PBucket
CLKRLinearHashTable::_BucketFromAddress(
    DWORD dwBucketAddr) const
{
    IRTLASSERT(dwBucketAddr < m_cActiveBuckets);

    PSegment const pseg = _Segment(dwBucketAddr);
    IRTLASSERT(pseg != NULL);

    const DWORD dwSegIndex = _SegIndex(dwBucketAddr);

    return &(pseg->Slot(dwSegIndex));
} // CLKRLinearHashTable::_BucketFromAddress


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_NodesPerClump
// Synopsis: Number of nodes in a CNodeClump
//           Primarily to simplify conversion to a non-constant
//------------------------------------------------------------------------

LKR_FORCEINLINE
CLKRLinearHashTable::NodeIndex
CLKRLinearHashTable::_NodesPerClump() const
{
    return NODES_PER_CLUMP;
} // CLKRLinearHashTable::_NodesPerClump



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_NodeBegin
// Synopsis: Index of first node in a CNodeClump
//------------------------------------------------------------------------

LKR_FORCEINLINE
CLKRLinearHashTable::NodeIndex
CLKRLinearHashTable::_NodeBegin() const
{
    return NODE_BEGIN;
} // CLKRLinearHashTable::_NodeBegin



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_NodeEnd
// Synopsis: Index of last node in a CNodeClump
//------------------------------------------------------------------------

LKR_FORCEINLINE
CLKRLinearHashTable::NodeIndex
CLKRLinearHashTable::_NodeEnd() const
{
    return NODE_END;
} // CLKRLinearHashTable::_NodeEnd



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_NodeStep
// Synopsis: Advance from _NodeBegin() to _NodeEnd() by this increment
//------------------------------------------------------------------------

LKR_FORCEINLINE
CLKRLinearHashTable::NodeIndex
CLKRLinearHashTable::_NodeStep() const
{
    return NODE_STEP;
} // CLKRLinearHashTable::_NodeStep



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IncrementExpansionIndex
// Synopsis: Move the expansion index forward by one.
//      Adjust the level and masks, if necessary.
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRLinearHashTable::_IncrementExpansionIndex()
{
    IRTLASSERT(this->IsWriteLocked());

    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT((m_dwBktAddrMask0 + 1) == (1U << m_nLevel));

    if (m_iExpansionIdx < m_dwBktAddrMask0)
    {
        ++m_iExpansionIdx;
    }
    else
    {
        IRTLASSERT(m_iExpansionIdx == m_dwBktAddrMask0);
        IRTLASSERT(m_iExpansionIdx == ((1U << m_nLevel) - 1) );

        ++m_nLevel;
        IRTLASSERT(m_nLevel > m_nSegBits);

        INCREMENT_OP_STAT(LevelExpansion);

        m_iExpansionIdx = 0;

        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
        m_dwBktAddrMask1 = (m_dwBktAddrMask1 << 1) | 1;
    }

    IRTLASSERT(m_nLevel >= m_nSegBits);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);

    // m_dwBktAddrMask0 = 00011..111
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);
    IRTLASSERT( m_dwBktAddrMask0 == ((1U << m_nLevel) - 1) );

    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT( m_dwBktAddrMask1 == ((1U << (1 + m_nLevel)) - 1) );
} // CLKRLinearHashTable::_IncrementExpansionIndex



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DecrementExpansionIndex
// Synopsis: Move the expansion index back by one.
//      Adjust the level and masks, if necessary.
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRLinearHashTable::_DecrementExpansionIndex()
{
    IRTLASSERT(this->IsWriteLocked());

    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT((m_dwBktAddrMask0 + 1) == (1U << m_nLevel));

    if (m_iExpansionIdx != 0)
    {
        --m_iExpansionIdx;
    }
    else
    {
        IRTLASSERT(m_nLevel > m_nSegBits);

        --m_nLevel;

        INCREMENT_OP_STAT(LevelContraction);

        m_iExpansionIdx  = (1U << m_nLevel) - 1;
        m_dwBktAddrMask0 = m_iExpansionIdx;
        m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    }

    IRTLASSERT(m_nLevel >= m_nSegBits);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);

    // m_dwBktAddrMask0 = 00011..111
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);
    IRTLASSERT( m_dwBktAddrMask0 == ((1U << m_nLevel) - 1) );

    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT( m_dwBktAddrMask1 == ((1U << (1 + m_nLevel)) - 1) );
} // CLKRLinearHashTable::_DecrementExpansionIndex



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ExtractKey
// Synopsis: Extract the key from a record
//------------------------------------------------------------------------

LKR_FORCEINLINE
const DWORD_PTR
CLKRLinearHashTable::_ExtractKey(
    const void* pvRecord) const
{
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(m_pfnExtractKey != NULL);

    return (*m_pfnExtractKey)(pvRecord);
} // CLKRLinearHashTable::_ExtractKey


//------------------------------------------------------------------------
// Function: CLKRHashTable::_ExtractKey
// Synopsis: Extract the key from a record
//------------------------------------------------------------------------

LKR_FORCEINLINE
const DWORD_PTR
CLKRHashTable::_ExtractKey(
    const void* pvRecord) const
{
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(m_pfnExtractKey != NULL);

    return (*m_pfnExtractKey)(pvRecord);
} // CLKRHashTable::_ExtractKey


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CalcKeyHash
// Synopsis: Hash the key
//------------------------------------------------------------------------

LKR_FORCEINLINE
DWORD
CLKRLinearHashTable::_CalcKeyHash(
    const DWORD_PTR pnKey) const
{
    // Note pnKey==0 is acceptable, as the real key type could be an int
    IRTLASSERT(m_pfnCalcKeyHash != NULL);

    DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);

    // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
    dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
    dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__

    IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);

    return dwHash;
} // CLKRLinearHashTable::_CalcKeyHash


//------------------------------------------------------------------------
// Function: CLKRHashTable::_CalcKeyHash
// Synopsis: Hash the key
//------------------------------------------------------------------------

LKR_FORCEINLINE
DWORD
CLKRHashTable::_CalcKeyHash(
    const DWORD_PTR pnKey) const
{
    // Note pnKey==0 is acceptable, as the real key type could be an int
    IRTLASSERT(m_pfnCalcKeyHash != NULL);

    DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);

    // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
    dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
    dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__

    IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);

    return dwHash;
} // CLKRHashTable::_CalcKeyHash


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CompareKeys
// Synopsis: Compare two keys for equality. Only called if
//      their hash signatures match.
//------------------------------------------------------------------------

LKR_FORCEINLINE
int
CLKRLinearHashTable::_CompareKeys(
    const DWORD_PTR pnKey1,
    const DWORD_PTR pnKey2) const
{
    IRTLASSERT(m_pfnCompareKeys != NULL);

    return (*m_pfnCompareKeys)(pnKey1, pnKey2);
} // CLKRLinearHashTable::_CompareKeys


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AddRefRecord
// Synopsis: AddRef or Release a record.
//------------------------------------------------------------------------

LKR_FORCEINLINE
LONG
CLKRLinearHashTable::_AddRefRecord(
    const void*      pvRecord,
    LK_ADDREF_REASON lkar) const
{
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(lkar != 0);
    IRTLASSERT(m_pfnAddRefRecord != NULL);

    LONG cRefs = (*m_pfnAddRefRecord)(const_cast<void*>(pvRecord), lkar);
    IRTLASSERT(cRefs >= 0);

    return cRefs;
} // CLKRLinearHashTable::_AddRefRecord


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ReadOrWriteLock
// Synopsis: Used by _FindKey so that the thread won't deadlock if the user
// has already explicitly called subtable->WriteLock().
//------------------------------------------------------------------------

LKR_FORCEINLINE
bool
CLKRLinearHashTable::_ReadOrWriteLock() const
{
#ifdef LKR_EXPOSED_TABLE_LOCK
    STATIC_ASSERT(TableLock::LOCK_WRITELOCK_RECURSIVE);
    return m_Lock.ReadOrWriteLock();
#else // !LKR_EXPOSED_TABLE_LOCK
    m_Lock.ReadLock();
    return true;
#endif // !LKR_EXPOSED_TABLE_LOCK
} // CLKRLinearHashTable::_ReadOrWriteLock


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ReadOrWriteUnlock
// Synopsis: converse of _ReadOrWriteLock().
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRLinearHashTable::_ReadOrWriteUnlock(
    bool fReadLocked) const
{
#ifdef LKR_EXPOSED_TABLE_LOCK
    STATIC_ASSERT(TableLock::LOCK_WRITELOCK_RECURSIVE);
    m_Lock.ReadOrWriteUnlock(fReadLocked);
#else // !LKR_EXPOSED_TABLE_LOCK
    m_Lock.ReadUnlock();
#endif // !LKR_EXPOSED_TABLE_LOCK
} // CLKRLinearHashTable::_ReadOrWriteUnlock


//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTable
// Synopsis: Map a hash signature to a subtable
//------------------------------------------------------------------------

LKR_FORCEINLINE
CLKRHashTable::SubTable* const
CLKRHashTable::_SubTable(
    DWORD dwSignature) const
{
    IRTLASSERT(m_lkrcState == LK_SUCCESS
               &&  m_palhtDir != NULL  &&  m_cSubTables > 0);

    // Don't scramble the hash signature if there's only one subtable
    if (0 == m_nSubTableMask)
    {
        IRTLASSERT(1 == m_cSubTables);
        return m_palhtDir[0];
    }
    else
        IRTLASSERT(1 < m_cSubTables);

    const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
    DWORD       index = dwSignature;

    // scramble the index, using a different set of constants than
    // HashRandomizeBits. This helps ensure that elements are sprayed
    // equally across subtables
    index = ((index * PRIME + 12345) >> 16)
#ifdef LKR_INDEX_HIBITS
                | ((index * 69069 + 1) & 0xffff0000)
#endif // LKR_INDEX_HIBITS
        ;

    // If mask is non-negative, we can use faster bitwise-and
    if (m_nSubTableMask >= 0)
        index &= m_nSubTableMask;
    else
        index %= m_cSubTables;

    return m_palhtDir[index];
} // CLKRHashTable::_SubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTableIndex
// Synopsis: Given a subtable, find its index within the parent table
//------------------------------------------------------------------------

LKR_FORCEINLINE
int
CLKRHashTable::_SubTableIndex(
    CLKRHashTable::SubTable* pst) const
{
    STATIC_ASSERT(MAX_LKR_SUBTABLES < INVALID_PARENT_INDEX);

#ifdef IRTLDEBUG
    int index = -1;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        if (pst == m_palhtDir[i])
        {
            index = i;
            break;
        }
    }

    IRTLASSERT(index >= 0);

    IRTLASSERT(index == pst->m_iParentIndex);
#endif // IRTLDEBUG

    IRTLASSERT(pst->m_iParentIndex < m_cSubTables
               &&  m_cSubTables < INVALID_PARENT_INDEX);

    return pst->m_iParentIndex;
} // CLKRHashTable::_SubTableIndex


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertThisIntoGlobalList
// Synopsis: 
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRLinearHashTable::_InsertThisIntoGlobalList()
{
#ifndef LKR_NO_GLOBAL_LIST
    // Only add standalone CLKRLinearHashTables to global list.
    // CLKRHashTables have their own global list.
    if (m_phtParent == NULL)
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
} // CLKRLinearHashTable::_InsertThisIntoGlobalList



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_RemoveThisFromGlobalList
// Synopsis: 
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRLinearHashTable::_RemoveThisFromGlobalList()
{
#ifndef LKR_NO_GLOBAL_LIST
    if (m_phtParent == NULL)
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
} // CLKRLinearHashTable::_RemoveThisFromGlobalList


//------------------------------------------------------------------------
// Function: CLKRHashTable::_InsertThisIntoGlobalList
// Synopsis: 
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRHashTable::_InsertThisIntoGlobalList()
{
#ifndef LKR_NO_GLOBAL_LIST
    IRTLTRACE1("CLKRHashTable::_InsertThisIntoGlobalList(%p)\n", this);
    sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
} // CLKRHashTable::_InsertThisIntoGlobalList


//------------------------------------------------------------------------
// Function: CLKRHashTable::_RemoveThisFromGlobalList
// Synopsis: 
//------------------------------------------------------------------------

LKR_FORCEINLINE
void
CLKRHashTable::_RemoveThisFromGlobalList()
{
#ifndef LKR_NO_GLOBAL_LIST
    IRTLTRACE1("CLKRHashTable::_RemoveThisFromGlobalList(%p)\n", this);
    sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
} // CLKRHashTable::_RemoveThisFromGlobalList


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__

#endif  // __LKR_INLINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-find-keyrec.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-find-keyrec.cpp

   Abstract:
       FindKey, FindRecord, and FindKeyMultipleRecords

   Author:
       George V. Reilly      (GeorgeRe)

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash subtable not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    const DWORD     dwSignature,// hash signature
    const void**    ppvRecord   // resultant record
#ifdef LKR_STL_ITERATORS
  , Iterator*       piterResult // = NULL. Points to record upon return
#endif // LKR_STL_ITERATORS
    ) const
{
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);
    IRTLASSERT(HASH_INVALID_SIGNATURE != dwSignature);

    INCREMENT_OP_STAT(FindKey);

    *ppvRecord = NULL;

    LK_RETCODE lkrc  = LK_NO_SUCH_KEY;
    NodeIndex  iNode = _NodeEnd();

    // If the subtable has already been locked for writing, we must recursively
    // writelock; otherwise, we readlock it. If we unconditionally readlocked
    // the subtable, the thread would deadlock if it had already writelocked
    // the subtable.
    bool fReadLocked = this->_ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    // Locate the beginning of the correct bucket chain
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    
    PBucket const pbkt = _BucketFromAddress(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (_UseBucketLocking())
        pbkt->ReadLock();

    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    // Now that bucket is locked, can release subtable lock
    if (_UseBucketLocking())
        this->_ReadOrWriteUnlock(fReadLocked);

    // walk down the bucket chain
    for (PNodeClump pncCurr =   pbkt->FirstClump();
                    pncCurr !=  NULL;
                    pncCurr =   pncCurr->NextClump())
    {
        FOR_EACH_NODE(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->NoMoreValidSlots(iNode));
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
            {
                if (m_fMultiKeys &&  dwSignature < pncCurr->m_dwKeySigs[iNode])
                {
                    // Signatures are sorted. We've gone past the point
                    // where this signature can be.
                    
#ifdef IRTLDEBUG
                    NodeIndex j = iNode;  // start at current node
                    
                    for (PNodeClump pnc =  pncCurr;
                                    pnc != NULL;
                                    pnc =  pnc->NextClump())
                    {
                        for ( ;  j != _NodeEnd();  j += _NodeStep())
                        {
                            if (pnc->IsEmptySlot(j))
                                IRTLASSERT(pnc->NoMoreValidSlots(j));
                            else
                                IRTLASSERT(dwSignature < pnc->m_dwKeySigs[j]);
                        }
                        
                        j = _NodeBegin(); // reinitialize for remaining nodes
                    }
#endif // IRTLDEBUG

                    goto exit;
                }

                // Signature doesn't match, but it may still be present
                // in the sorted/unsorted bucket chain
                continue;   // next iNode
            }

            IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[iNode]);

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);
            const int       nCmp   = ((pnKey == pnKey2)
                                      ?  0
                                      :  _CompareKeys(pnKey,  pnKey2));

            if (nCmp == 0)
            {
                *ppvRecord = pncCurr->m_pvNode[iNode];
                lkrc = LK_SUCCESS;

                // Bump the reference count before handing the record
                // back to the user. The user must decrement the
                // reference count when finished with this record.
                
                LK_ADDREF_REASON lkar;
                
#ifdef LKR_STL_ITERATORS
                if (piterResult != NULL)
                    lkar = LKAR_ITER_FIND;
                else
#endif // LKR_STL_ITERATORS
                    lkar = LKAR_FIND_KEY;

                _AddRefRecord(*ppvRecord, lkar);
                goto exit;
            }
            else if (m_fMultiKeys  &&  nCmp < 0)
            {
                // Gone past the point where this signature could found
                // be in the sorted bucket chain.
                goto exit;
            }
        }
    }

  exit:
    if (_UseBucketLocking())
        pbkt->ReadUnlock();
    else
        this->_ReadOrWriteUnlock(fReadLocked);

#ifdef LKR_STL_ITERATORS
    if (piterResult != NULL)
    {
        if (lkrc == LK_SUCCESS)
        {
            piterResult->m_plht =       const_cast<CLKRLinearHashTable*>(this);
            piterResult->m_pnc =          pncCurr;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode
                = static_cast<CLKRLinearHashTable_Iterator::NodeIndex>(iNode);
        }
        else
        {
            IRTLASSERT((*piterResult) == End());
        }
    }
#endif // LKR_STL_ITERATORS

    return lkrc;
} // CLKRLinearHashTable::_FindKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindKey(
    const DWORD_PTR pnKey,
    const void**    ppvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op

    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);

    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the subtable
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the subtable
//           LK_UNUSABLE, if hash subtable not in usable state
// Note:     The record is *not* AddRef'd. By definition, the caller
//           already has a reference to it.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the subtable
    const DWORD dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsUsable());
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(HASH_INVALID_SIGNATURE != dwSignature);

    INCREMENT_OP_STAT(FindRecord);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // If the subtable has already been locked for writing, we must recursively
    // writelock; otherwise, we readlock it. If we unconditionally readlocked
    // the subtable, the thread would deadlock if it had already writelocked
    // the subtable.
    bool fReadLocked = this->_ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    // Locate the beginning of the correct bucket chain
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    
    PBucket const pbkt = _BucketFromAddress(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (_UseBucketLocking())
        pbkt->ReadLock();

    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    // Now that bucket is locked, can release subtable lock
    if (_UseBucketLocking())
        this->_ReadOrWriteUnlock(fReadLocked);

    IRTLASSERT(dwSignature == _CalcKeyHash(_ExtractKey(pvRecord)));

    // walk down the bucket chain
    for (PNodeClump pncCurr =   pbkt->FirstClump();
                    pncCurr !=  NULL;
                    pncCurr =   pncCurr->NextClump())
    {
        FOR_EACH_NODE_DECL(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->NoMoreValidSlots(iNode));
                goto exit;
            }

            const void* pvCurrRecord = pncCurr->m_pvNode[iNode];

            if (pvCurrRecord == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[iNode]);
                IRTLASSERT(0 == _CompareKeys(_ExtractKey(pvRecord),
                                             _ExtractKey(pvCurrRecord)));
                lkrc = LK_SUCCESS;

                // Do NOT AddRef the record: caller already has a reference

                goto exit;
            }
        }
    }

  exit:
    if (_UseBucketLocking())
        pbkt->ReadUnlock();
    else
        this->_ReadOrWriteUnlock(fReadLocked);
        
    return lkrc;
} // CLKRLinearHashTable::_FindRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindRecord(
    const void* pvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
#ifndef LKR_ALLOW_NULL_RECORDS
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
#endif
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op

    DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);

    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKeyMultipleRecords
// Synopsis:
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKeyMultipleRecords(
    const DWORD_PTR         pnKey,
    const DWORD             dwSignature,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr) const
{
    INCREMENT_OP_STAT(FindKeyMultiRec);

    UNREFERENCED_PARAMETER(pnKey);          // for /W4
    UNREFERENCED_PARAMETER(dwSignature);    // for /W4
    UNREFERENCED_PARAMETER(pcRecords);      // for /W4
    UNREFERENCED_PARAMETER(pplmr);          // for /W4

    IRTLASSERT(! "FindKeyMultipleRecords not implemented yet");
    return LK_BAD_TABLE;
} // CLKRLinearHashTable::_FindKeyMultipleRecords



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindKeyMultipleRecords
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindKeyMultipleRecords(
    const DWORD_PTR         pnKey,
    size_t*                 pcRecords,
    LKR_MULTIPLE_RECORDS**  pplmr) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pcRecords == NULL)
        return LK_BAD_PARAMETERS;

    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op

    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKeyMultipleRecords(pnKey, hash_val,
                                                        pcRecords, pplmr);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindKeyMultipleRecords



#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-misc.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-misc.cpp

   Abstract:
       Locks and other misc routines

   Author:
       George V. Reilly      (GeorgeRe)

   Project:
       LKRhash

   Revision History:

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock()
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        // Recursive write locking or a race condition with
        // another thread taking the write lock means that
        // m_palhtDir[i]->IsWriteUnlocked() could return false.
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        // Multiple readers and/or recursive locking mean that
        // m_palhtDir[i]->IsReadUnlocked() could return false.
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
} // CLKRHashTable::IsWriteLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
} // CLKRHashTable::IsReadLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
// Note: Recursive write locking or a race condition with
// another thread taking the write lock means that
// m_palhtDir[i]->IsWriteUnlocked() could return false.
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsWriteUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
// Note: Multiple readers and/or recursive locking mean that
// m_palhtDir[i]->IsReadUnlocked() could return false.
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsReadUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertSharedToExclusive
// Synopsis: Convert the read lock to a write lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertSharedToExclusive()
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i]->ConvertSharedToExclusive();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::ConvertSharedToExclusive



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertExclusiveToShared
// Synopsis: Convert the write lock to a read lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertExclusiveToShared() const
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i]->ConvertExclusiveToShared();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ConvertExclusiveToShared



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  ++i)
        f = f && m_palhtDir[i]->IsValid();

    if (!f)
        m_lkrcState = LK_UNUSABLE;

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    m_Lock.SetSpinCount(wSpins);
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetTableLockSpinCount() const
{
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    return m_Lock.GetSpinCount();
#else
    return 0;
#endif
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  ++i)
    {
        PSegment pseg = m_paDirSegs[i];

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_nSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount() const
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  (WORD) LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  (WORD) LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::MultiKeys
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::MultiKeys() const
{
    return ((m_cSubTables == 0)
            ?  false
            :  m_palhtDir[0]->MultiKeys());
} // CLKRHashTable::MultiKeys



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD&,
    DWORD&)
{
    return LK_MEDIUM_TABLESIZE;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        static int s_nCPUs = -1;
    
        if (s_nCPUs == -1)
        {
#ifdef LKRHASH_KERNEL_MODE
            s_nCPUs = KeNumberProcessors;
#else  // !LKRHASH_KERNEL_MODE
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            s_nCPUs = si.dwNumberOfProcessors;
#endif // !LKRHASH_KERNEL_MODE
        }

        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = max(1,  min(s_nCPUs, 4));
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * s_nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * s_nCPUs;
            break;
        }
    }

    rnum_subtbls = min(MAX_LKR_SUBTABLES,  max(1, rnum_subtbls));

    return lkts;
} // CLKRHashTable::NumSubTables


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__



const char*
LKR_AddRefReasonAsString(
    LK_ADDREF_REASON lkar)
{
    switch (lkar)
    {
// negative reasons => decrement refcount => release ownership
    case LKAR_DESTRUCTOR:
        return "User_Destructor";
    case LKAR_EXPLICIT_RELEASE:
        return "Explicit_Release";
    case LKAR_DELETE_KEY:
        return "Delete_Key";
    case LKAR_DELETE_RECORD:
        return "Delete_Record";
    case LKAR_INSERT_RELEASE:
        return "Insert_Release";
    case LKAR_CLEAR:
        return "Clear";
    case LKAR_LKR_DTOR:
        return "~LKR_Table_Dtor";
    case LKAR_APPLY_DELETE:
        return "Apply_Delete";
    case LKAR_DELETEIF_DELETE:
        return "DeleteIf_Delete";
    case LKAR_DELETE_MULTI_FREE:
        return "DeleteKeyMultipleRecords_freed";
    case LKAR_ITER_RELEASE:
        return "++Iter_Release";
    case LKAR_ITER_ASSIGN_RELEASE:
        return "Iter_Operator=_Release";
    case LKAR_ITER_DTOR:
        return "~Iter_Dtor";
    case LKAR_ITER_ERASE:
        return "Iter_Erase";
    case LKAR_ITER_ERASE_TABLE:
        return "Iter_Erase_Table";
    case LKAR_ITER_CLOSE:
        return "Iter_Close";
    case LKAR_FIND_MULTI_FREE:
        return "FindKeyMultipleRecords_freed";

// positive reasons => increment refcount => add an owner
    case LKAR_INSERT_RECORD:
        return "Insert_Record";
    case LKAR_FIND_KEY:
        return "Find_Key";
    case LKAR_ITER_ACQUIRE:
        return "Iter_Acquire";
    case LKAR_ITER_COPY_CTOR:
        return "Iter_Copy_Ctor";
    case LKAR_ITER_ASSIGN_ACQUIRE:
        return "Iter_Operator=_Assign";
    case LKAR_ITER_INSERT:
        return "Insert(Iter)";
    case LKAR_ITER_FIND:
        return "Find(Iter)";
    case LKAR_CONSTRUCTOR:
        return "User_Constructor";
    case LKAR_EXPLICIT_ACQUIRE:
        return "Explicit_Acquire";

    default:
        IRTLASSERT(! "Invalid LK_ADDREF_REASON");
        return "Invalid LK_ADDREF_REASON";
    }
} // LKR_AddRefReasonAsString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-stats.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-stats.cpp

   Abstract:
       Implements statistics gathering for LKRhash

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <LKRhash.h>

#include "i-LKRhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#include "LKR-inline.h"

#ifndef LKRHASH_KERNEL_MODE

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the subtable
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                                / static_cast<double>(1ui64 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = _NodesPerClump();
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  ++i)
        {
            int acc = 0;

            for (PNodeClump pncCurr = &_BucketFromAddress(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                FOR_EACH_NODE_DECL(j)
                {
                    if (! pncCurr->IsEmptySlot(j))
                    {
                        ++acc;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _BucketFromAddress(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           += 1;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                ++empty;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx)
                         / static_cast<double>(1ui64 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                {
                    low_sl  = static_cast<double>(low_count)
                             / (2.0 * m_iExpansionIdx);
                }
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                {
                    high_sl = static_cast<double>(high_count)
                             / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                }
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics

#endif // !LKRHASH_KERNEL_MODE



#ifdef LOCK_INSTRUMENTATION

CAveragedLockStats::CAveragedLockStats()
    : m_nItems(1)
{}

#endif // LOCK_INSTRUMENTATION


#ifndef LKRHASH_KERNEL_MODE

CLKRHashTableStats::CLKRHashTableStats()
    : RecordCount(0),
      TableSize(0),
      DirectorySize(0),
      LongestChain(0),
      EmptySlots(0),
      SplitFactor(0.0),
      AvgSearchLength(0.0),
      ExpSearchLength(0.0),
      AvgUSearchLength(0.0),
      ExpUSearchLength(0.0),
      NodeClumpSize(1),
      CBucketSize(0)
{
    for (int i = MAX_BUCKETS;  --i >= 0;  )
        m_aBucketLenHistogram[i] = 0;
}

const LONG*
CLKRHashTableStats::BucketSizes()
{
    static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
        1,    2,    3,    4,    5,    6,    7,      8,        9,
        10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
        20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
        70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
    };
    
    return s_aBucketSizes;
}

LONG
CLKRHashTableStats::BucketSize(
    LONG nBucketIndex)
{
    IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
    return BucketSizes()[nBucketIndex];
}

LONG
CLKRHashTableStats::BucketIndex(
    LONG nBucketLength)
{
    const LONG* palBucketSizes = BucketSizes();
    LONG i = 0;
    while (palBucketSizes[i] < nBucketLength)
        ++i;
    if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
        --i;
    IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
    return i;
}

#endif // !LKRHASH_KERNEL_MODE


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-ins-rec.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-ins-rec.cpp

   Abstract:
       InsertRecord, _Expand, and _SplitBucketChain

   Author:
       George V. Reilly      (GeorgeRe)

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash subtable. If this causes the
//           average chain length to exceed the upper bound, the subtable is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the subtable, unless
//               fOverwrite==true or m_fMultiKeys==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash subtable not in usable state
//           LK_BAD_RECORD, if record is bad.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to subtable
    const DWORD_PTR pnKey,  // Key corresponding to pvRecord
    const DWORD dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult // = NULL. Points to record upon return
#endif // LKR_STL_ITERATORS
    )
{
    IRTLASSERT(IsUsable());
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);

    INCREMENT_OP_STAT(InsertRecord);

    // Lock the subtable, find the appropriate bucket, then lock that.
    // Table must be locked to prevent race conditions while
    // locating the bucket, as bucket address calculation is a
    // function of several variables, which get updated whenever
    // subtable expands or contracts.
    this->WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    // Locate the beginning of the correct bucket chain
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    
    PBucket const pbkt = _BucketFromAddress(dwBktAddr);
    IRTLASSERT(pbkt != NULL);

    if (_UseBucketLocking())
        pbkt->WriteLock();

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbkt));
    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    // Now that bucket is locked, can release subtable lock
    if (_UseBucketLocking())
        this->WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE  lkrc = LK_SUCCESS;
    PNodeClump  pncInsert = NULL, pncEnd = NULL;
    bool        fUpdateSlot = false;
    NodeIndex   iNode, iInsert = _NodeBegin() - _NodeStep(), iEnd = _NodeEnd();


    // Walk down the entire bucket chain, looking for matching hash
    // signatures and keys

    PNodeClump pncPrev = NULL, pncCurr = pbkt->FirstClump();

    do
    {
        // do-while loop rather than a for loop to convince PREfast that
        // pncPrev can't be NULL in the new node allocation code below

        IRTLASSERT(NULL != pncCurr);

        FOR_EACH_NODE(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode)
                ||  (m_fMultiKeys
                     &&  dwSignature < pncCurr->m_dwKeySigs[iNode]))
            {
#ifdef IRTLDEBUG
                // Have we reached an empty slot at the end of the chain?
                if (pncCurr->IsEmptySlot(iNode))
                {
                    IRTLASSERT(pncCurr->NoMoreValidSlots(iNode));
                }
                else
                {
                    // The signatures in MultiKeys tables are kept in
                    // sorted order. We've found the insertion point.
                    IRTLASSERT(m_fMultiKeys);
                    IRTLASSERT(pncCurr->m_dwKeySigs[iNode] > dwSignature);
                    
                    // Check that the preceding node (if present)
                    // had a signature less than dwSignature.
                    if (iNode != _NodeBegin()  ||  pncPrev != NULL)
                    {
                        if (iNode == _NodeBegin())
                        {
                            IRTLASSERT(pncPrev->m_dwKeySigs[_NodeEnd()
                                                                - _NodeStep()]
                                            <= dwSignature);
                        }
                        else
                        {
                            IRTLASSERT(pncCurr->m_dwKeySigs[iNode
                                                                - _NodeStep()]
                                            <= dwSignature);
                        }
                    }
                }
#endif // IRTLDEBUG
                
                // The new record will be inserted at (pncInsert, iInsert)
                pncInsert = pncCurr;
                iInsert   = iNode;
                goto insert;
            }
            
            IRTLASSERT(HASH_INVALID_SIGNATURE != pncCurr->m_dwKeySigs[iNode]);
            
            // If signatures don't match, keep walking
            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
                continue;
            
            if (pvRecord == pncCurr->m_pvNode[iNode])
            {
                // We're overwriting an existing record with itself. Whatever.
                // Don't adjust any reference counts.
                goto exit;
            }

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);
            const int       nCmp   = _CompareKeys(pnKey, pnKey2);

            // Are the two keys identical?
            if (nCmp == 0)
            {
                // If we allow overwrites, this is the slot to do it to.
                // Otherwise, if this is a multikeys table, we'll insert the
                // new record here and shuffle the remainder out one slot
                fUpdateSlot = fOverwrite;
                    
                if (m_fMultiKeys  ||  fOverwrite)
                {
                    pncInsert = pncCurr;
                    iInsert   = iNode;
                    goto insert;
                }
                else
                {
                    // overwrites and multiple keys forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }
            else if (m_fMultiKeys  &&  nCmp < 0)
            {
                // Have found the insertion point within the set of
                // adjacent identical signatures
                pncInsert = pncCurr;
                iInsert   = iNode;
                goto insert;
            }
        }

        pncPrev = pncCurr;
        pncCurr = pncCurr->NextClump();

    } while (pncCurr != NULL);


  insert:
    // We've found a spot to insert the new record (maybe)

    bool fAllocNode = false;
        
    // Did we fall off the end of the bucket chain?
    if (pncInsert == NULL)
    {
        IRTLASSERT(iInsert == _NodeBegin() - _NodeStep());
        IRTLASSERT(pncPrev != NULL  &&  pncCurr == NULL);

        if (m_fMultiKeys)
        {
            IRTLASSERT(pncPrev->m_dwKeySigs[_NodeEnd() - _NodeStep()]
                            <= dwSignature);
            IRTLASSERT(pncPrev->m_dwKeySigs[_NodeEnd() - _NodeStep()]
                            != HASH_INVALID_SIGNATURE);
        }
        
        fAllocNode = true;
    }
    else
    {
        // Found an insertion point
        IRTLASSERT(0 <= iInsert  &&  iInsert < _NodesPerClump());
        IRTLASSERT(pncCurr != NULL  &&  pncInsert == pncCurr);

        if (m_fMultiKeys  &&  !fUpdateSlot)
        {
            fAllocNode = true;
            
            // See if there's any space in the last clump
            
            for (pncPrev = pncInsert;
                 ! pncPrev->IsLastClump();
                 pncPrev = pncPrev->NextClump())
            {}
            
            FOR_EACH_NODE(iNode)
            {
                if (pncPrev->IsEmptySlot(iNode))
                {
                    fAllocNode = false;
                    pncEnd = pncPrev;
                    iEnd   = iNode;
                    break;
                }
            }
        }
    }

    // No free slots. Allocate a new node and attach it to the end of the chain
    if (fAllocNode)
    {
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncCurr->NoValidSlots());
        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());

        pncPrev->m_pncNext = pncCurr;

        if (pncInsert == NULL)
        {
            pncInsert = pncCurr;
            iInsert   = _NodeBegin();
        }

        if (m_fMultiKeys)
        {
            pncEnd = pncCurr;
            iEnd   = _NodeBegin();
        }
    }

    IRTLASSERT(pncInsert != NULL);
    IRTLASSERT(0 <= iInsert  &&  iInsert < _NodesPerClump());

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, LKAR_INSERT_RECORD);

    if (fUpdateSlot)
    {
        // We're overwriting an existing record that has the
        // same key as the new record.
        IRTLASSERT(pvRecord != pncInsert->m_pvNode[iInsert]);
        IRTLASSERT(dwSignature == pncInsert->m_dwKeySigs[iInsert]);
        IRTLASSERT(! pncInsert->IsEmptyAndInvalid(iInsert));

            // Release the subtable's reference on the old record.
        _AddRefRecord(pncInsert->m_pvNode[iInsert], LKAR_INSERT_RELEASE);
    }
    else
    {
        // We're not overwriting an existing record, we're adding a new record.
        IRTLASSERT(m_fMultiKeys  ||  pncInsert->IsEmptyAndInvalid(iInsert));

        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));

        // Need to move every node in range [Insert, End) up by one
        if (m_fMultiKeys)
        {
            IRTLASSERT(pncEnd != NULL && 0 <= iEnd && iEnd < _NodesPerClump());
            IRTLASSERT(pncEnd->NoMoreValidSlots(iEnd));

            // Prev = Node[iInsert];
            // for (i = iInsert+1;  i <= iEnd;  ++i) {
            //    Temp = Node[i];  Node[i] = Prev;  Prev = Temp;
            // }

            DWORD dwSigPrev    = pncInsert->m_dwKeySigs[iInsert];
            const void* pvPrev = pncInsert->m_pvNode[iInsert];

            iNode = iInsert + _NodeStep();    // first destination node

            for (pncCurr =  pncInsert;
                 pncCurr != NULL;
                 pncCurr =  pncCurr->NextClump())
            {
                const NodeIndex iLast = ((pncCurr == pncEnd)
                                         ?  iEnd + _NodeStep()  :  _NodeEnd());

                for ( ;  iNode != iLast;  iNode += _NodeStep())
                {
                    IRTLASSERT(0 <= iNode  &&  iNode < _NodesPerClump());
                    IRTLASSERT(dwSigPrev != HASH_INVALID_SIGNATURE);

                    const DWORD dwSigTemp = pncCurr->m_dwKeySigs[iNode];
                    pncCurr->m_dwKeySigs[iNode] = dwSigPrev;
                    dwSigPrev = dwSigTemp;

                    const void* pvTemp = pncCurr->m_pvNode[iNode];
                    pncCurr->m_pvNode[iNode] = pvPrev;
                    pvPrev    = pvTemp;
                }

                iNode = _NodeBegin(); // reinitialize for remaining nodeclumps
            }

            // The old value of (pncEnd, iEnd) was empty
            IRTLASSERT(pvPrev == NULL &&  dwSigPrev == HASH_INVALID_SIGNATURE);
        } // if (m_fMultiKeys)

        pncInsert->m_dwKeySigs[iInsert] = dwSignature;
    }

    pncInsert->m_pvNode[iInsert] = pvRecord;
    IRTLASSERT(dwSignature == pncInsert->m_dwKeySigs[iInsert]);


  exit:
    // We've inserted the record (if appropriate). Now finish up.

    IRTLASSERT(0 == _IsBucketChainMultiKeySorted(pbkt));
    IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

    if (_UseBucketLocking())
        pbkt->WriteUnlock();
    else
        this->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
#ifdef LKR_STL_ITERATORS
        // Don't call _Expand() if we're putting the result into an
        // iterator, as _Expand() tends to invalidate any other
        // iterators that might be in use.
        if (piterResult != NULL)
        {
            piterResult->m_plht =         this;
            piterResult->m_pnc =          pncInsert;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode
               = static_cast<CLKRLinearHashTable_Iterator::NodeIndex>(iInsert);

            // Add an extra reference on the record, as the one added by
            // _InsertRecord will be lost when the iterator's destructor
            // fires or its assignment operator is used
            piterResult->_AddRef(LKAR_ITER_INSERT);
        }
        else
#endif // LKR_STL_ITERATORS
        {
            // If the average load factor has grown too high, we grow the
            // subtable one bucket at a time.
#ifdef LKR_EXPAND_BY_DIVISION
            unsigned nExpandedBuckets = m_cRecords / m_MaxLoad;

            while (m_cActiveBuckets < nExpandedBuckets)
#else
            while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
#endif
            {
                // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
                // just means that there isn't enough spare memory to expand
                // the subtable by one bucket. This is likely to cause problems
                // elsewhere soon, but this hashtable has not been corrupted.
                // If the call to _AllocateNodeClump above failed, then we do
                // have a real error that must be propagated back to the caller
                // because we were unable to insert the element at all.
                if (_Expand() != LK_SUCCESS)
                    break;  // expansion failed
            }
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::InsertRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InsertRecord(
    const void* pvRecord,
    bool fOverwrite /*=false*/)
{
    if (!IsUsable())
        return m_lkrcState;
    
#ifndef LKR_ALLOW_NULL_RECORDS
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
#endif
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    DWORD     hash_val    = _CalcKeyHash(pnKey);
    SubTable* const pst   = _SubTable(hash_val);
    LK_RETCODE lkrc       = pst->_InsertRecord(pvRecord, pnKey, hash_val,
                                               fOverwrite);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::InsertRecord



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the subtable by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    INCREMENT_OP_STAT(Expand);

    this->WriteLock();

    if (m_cActiveBuckets >= (DWORD) ((MAX_DIRSIZE << m_nSegBits) - 1))
    {
        this->WriteUnlock();
        return LK_ALLOC_FAIL;  // subtable is not allowed to grow any larger
    }

    // double segment directory size, if necessary
    if (m_cActiveBuckets >= (m_cDirSegs << m_nSegBits))
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);

        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        IRTLASSERT((cDirSegsNew & (cDirSegsNew-1)) == 0);  // == (1 << N)

        PSegment* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  ++j)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j]  = NULL;
            }

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            this->WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    const DWORD dwOldBkt = m_iExpansionIdx;
    const DWORD dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    // save to avoid race conditions
    const DWORD dwBktAddrMask = m_dwBktAddrMask1;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    IRTLASSERT((dwNewBkt & dwBktAddrMask) == dwNewBkt);

    IRTLASSERT(_Segment(dwOldBkt) != NULL);

    PSegment psegNew = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();

        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            this->WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }

        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    PBucket const pbktOld = _BucketFromAddress(dwOldBkt);
    PBucket const pbktNew = _BucketFromAddress(dwNewBkt);

    // get locks on the two buckets involved
    if (_UseBucketLocking())
    {
        pbktOld->WriteLock();
        pbktNew->WriteLock();
    }

    IRTLASSERT(0 == _IsBucketChainCompact(pbktOld));

    IRTLASSERT(pbktNew->NoValidSlots());


    // CODEWORK: short-circuit if cOldNodes == 0 => nothing to copy

    // Now work out if we need to allocate any extra CNodeClumps. We do
    // this up front, before calling _SplitBucketChain, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    LK_RETCODE lkrc           = LK_SUCCESS;
    PNodeClump pncFreeList    = NULL;
    bool       fPrimeFreeList;

#ifdef LKR_EXPAND_CALC_FREELIST
unsigned cOrigClumps = 0, cOldClumps = 0, cNewClumps = 0;
unsigned cOldNodes = 0, cNewNodes = 0;

NodeIndex iOld = _NodeEnd() - _NodeStep(), iNew = _NodeEnd() - _NodeStep();
NodeIndex iOld2 = 0, iNew2 = 0;
#endif // LKR_EXPAND_CALC_FREELIST

const unsigned MAX_NODES = 500;
int iA, aOld[MAX_NODES], aNew[MAX_NODES];

for (iA = 0; iA < MAX_NODES; ++iA)
    aOld[iA] = aNew[iA] = 0;

    if (pbktOld->IsLastClump())
    {
        // If the original bucket has only one CNodeClump (embedded in the
        // CBucket), there's zero chance that we'll need extra CNodeClumps
        // in either of the two new bucket chains.

        fPrimeFreeList = false;
    }
#if 0
    else if (! pbktOld->NextClump()->IsLastClump())
    {
        // If there are more than two CNodeClumps in the original bucket
        // chain, then we'll definitely need to prime the freelist,
        // because at least one of the two new bucket chains is going to
        // have at least two node clumps.

        fPrimeFreeList = true;
cNewNodes = 0xffff;

        for (PNodeClump pnc =  &pbktOld->FirstClump();
                        pnc !=  NULL;
                        pnc =   pnc->NextClump())
        {
            FOR_EACH_NODE_DECL(iNode)
            {
                const DWORD dwBkt = pnc->m_dwKeySigs[iNode];

                if (HASH_INVALID_SIGNATURE == dwBkt)
                    break;
                ++cOldNodes;
            }
        }

        if (cOldNodes == 5)
            DebugBreak();
    }
#endif
    else
    {
#ifdef LKR_EXPAND_CALC_FREELIST
        // There are two node clumps in the original bucket chain. We'll only
        // need to prime the freelist if at least one of the two new
        // bucket chains requires two node clumps. If they're fairly
        // evenly distributed, neither bucket chain will require more than
        // the first node clump that's embedded in the CBucket.

        const DWORD dwMaskHiBit = (dwBktAddrMask ^ (dwBktAddrMask >> 1));
iA = 0;

        IRTLASSERT((dwMaskHiBit & (dwMaskHiBit-1)) == 0);

fPrimeFreeList = false;
int   nFreeListLength = 0;
        for (PNodeClump pnc =   pbktOld->FirstClump();
                        pnc !=  NULL;
                        pnc =   pnc->NextClump())
        {
            ++cOrigClumps;
            
            FOR_EACH_NODE_DECL(iNode)
            {
                const DWORD dwBkt = pnc->m_dwKeySigs[iNode];

                if (HASH_INVALID_SIGNATURE == dwBkt)
                    goto dont_prime;
                
                if (dwBkt & dwMaskHiBit)
                {
                    IRTLASSERT((dwBkt & dwBktAddrMask) == dwNewBkt);

                    ++cNewNodes;

                    if ((iNew += _NodeStep())  ==  _NodeEnd())
                    {
                        ++cNewClumps;
                        iNew = _NodeBegin();

                        if (cNewClumps > 1)
                        {
                            if (--nFreeListLength < 0)
                                fPrimeFreeList = true;
                        }
                    }

                    aNew[iNew2++] = ++iA;
# if 0
                    if (cNewNodes > _NodesPerClump()
                        && cOldNodes + cNewNodes < 2 * _NodesPerClump())
                    {
                        fPrimeFreeList = true;
                        // goto prime;
                    }
# endif // 0
                }
                else
                {
                    IRTLASSERT((dwBkt & dwBktAddrMask) == dwOldBkt);

                    ++cOldNodes;

                    if ((iOld += _NodeStep())  ==  _NodeEnd())
                    {
                        ++cOldClumps;
                        iOld = _NodeBegin();

                        if (cOldClumps > 1)
                        {
                            if (--nFreeListLength < 0)
                                fPrimeFreeList = true;
                        }
                    }

                    aOld[iOld2++] = ++iA;
# if 0
                    if (cOldNodes > _NodesPerClump()
                        && cOldNodes + cNewNodes < 2 * _NodesPerClump())
                    {
                        fPrimeFreeList = true;
                        // goto prime;
                    }
# endif // 0
                }

# if 0
                const int Diff = cNewNodes - cOldNodes;

                if ((cOldNodes > _NodesPerClump())
                    && (cNewNodes > _NodesPerClump())
                    || (Diff > _NodesPerClump()  ||  Diff < -_NodesPerClump()))
                {
                    fPrimeFreeList = true;
                    goto prime;
                }
# endif  // 0
            } // iNode

            if (pnc != pbktOld->FirstClump())
                ++nFreeListLength;
        }

      dont_prime:
        // fPrimeFreeList = (cOldClumps + cNewClumps - 1  >  cOrigClumps);
        ;

        // Don't need to prime the freelist
// fPrimeFreeList = false;

//      IRTLASSERT(cOldNodes <= _NodesPerClump()
//                 &&  cNewNodes <= _NodesPerClump()
//                 &&  cOldNodes + cNewNodes > _NodesPerClump());

#else  // !LKR_EXPAND_CALC_FREELIST

        fPrimeFreeList = true;
#endif // !LKR_EXPAND_CALC_FREELIST
    }

    // Prime the freelist, if need be. We need at most one node clump
    // in the freelist, because we'll be able to reuse CNodeClumps from
    // the original bucket chain to meet all other needs.
// prime:
    if (fPrimeFreeList)
    {
        pncFreeList = _AllocateNodeClump();

        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }
    
    // Adjust expansion pointer, and level and mask, if need be.
    if (lkrc == LK_SUCCESS)
    {
        _IncrementExpansionIndex();
    }


    // Release the subtable lock before doing the actual relocation
    if (_UseBucketLocking())
        this->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // Is the original bucket chain empty?
        if (pbktOld->IsEmptyFirstSlot())
        {
            IRTLASSERT(pncFreeList == NULL);
            IRTLASSERT(pbktOld->NoValidSlots());
        }
        else
        {
            lkrc = _SplitBucketChain(
                            pbktOld->FirstClump(),
                            pbktNew->FirstClump(),
                            dwBktAddrMask,
                            dwNewBkt,
                            pncFreeList
                            );
        }
    }

    IRTLASSERT(0 == _IsBucketChainCompact(pbktOld));
    IRTLASSERT(0 == _IsBucketChainCompact(pbktNew));

    if (_UseBucketLocking())
    {
        pbktNew->WriteUnlock();
        pbktOld->WriteUnlock();
    }
    else
        this->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitBucketChain
// Synopsis: Split records between the old and new buckets chains.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitBucketChain(
    PNodeClump  pncOldTarget,
    PNodeClump  pncNewTarget,
    const DWORD dwBktAddrMask,
    const DWORD dwNewBkt,
    PNodeClump  pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst(*pncOldTarget);    // save head of old target chain
    PNodeClump  pncOldList = &ncFirst;
    PNodeClump  pncTmp;
    NodeIndex   iOldSlot = _NodeBegin();
    NodeIndex   iNewSlot = _NodeBegin();
#ifdef IRTLDEBUG
    unsigned    cFreeListExhaustions = (pncFreeList == NULL);
    const DWORD dwMaskHiBit = (dwBktAddrMask ^ (dwBktAddrMask >> 1));
#endif // IRTLDEBUG

NodeIndex iB = 0;

    IRTLASSERT(! pncOldTarget->NoValidSlots());

    // clear old target bucket now that it's saved in ncFirst
    pncOldTarget->Clear();
    IRTLASSERT(pncOldTarget->NoValidSlots());

    // The new target should be empty on entry
    IRTLASSERT(pncNewTarget->NoValidSlots());

    // Scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        FOR_EACH_NODE_DECL(iOldList)
        {
++iB;
            // Node already empty?
            if (pncOldList->IsEmptySlot(iOldList))
            {
                // Check that all the remaining nodes are empty
                IRTLASSERT(pncOldList->NoMoreValidSlots(iOldList));

                break; // out of FOR_EACH_NODE(iOldList)...
            }

            IRTLASSERT(! pncOldList->IsEmptyAndInvalid(iOldList));

            // calculate bucket address of this node
            DWORD dwBkt = pncOldList->m_dwKeySigs[iOldList] & dwBktAddrMask;

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // msb should be set
                IRTLASSERT((dwBkt & dwMaskHiBit) == dwMaskHiBit);

                // node in new bucket chain full?
                if (iNewSlot == _NodeEnd())
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->NextClump();
#ifdef IRTLDEBUG
                    cFreeListExhaustions += (pncFreeList == NULL);
#endif // IRTLDEBUG

                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    pncNewTarget->Clear();
                    iNewSlot = _NodeBegin();
                }

                IRTLASSERT(pncNewTarget->NoMoreValidSlots(iNewSlot));

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[iOldList];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[iOldList];

                iNewSlot += _NodeStep();
            }

            // no, record stays in its current bucket chain
            else
            {
                // msb should be clear
                IRTLASSERT((dwBkt & dwMaskHiBit) == 0);

                // node in old bucket chain full?
                if (iOldSlot == _NodeEnd())
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->NextClump();
#ifdef IRTLDEBUG
                    cFreeListExhaustions += (pncFreeList == NULL);
#endif // IRTLDEBUG

                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    pncOldTarget->Clear();
                    iOldSlot = _NodeBegin();
                }

                IRTLASSERT(pncOldTarget->NoMoreValidSlots(iOldSlot));

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[iOldList];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[iOldList];

                iOldSlot += _NodeStep();
            }
        } // FOR_EACH_NODE(iOldList) ...


        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->NextClump();

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    } // while (pncOldList != NULL ...

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->NextClump();

        IRTLASSERT(pncTmp != &ncFirst);
#ifdef IRTLDEBUG
        pncTmp->Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
    IRTLASSERT(cFreeListExhaustions > 0);
    ncFirst.Clear(); // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitBucketChain


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-old-iter.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-old-iter.cpp

   Abstract:
       Implements the old, deprecated iterators for LKRhash.
       Use the STL-style iterators instead. These will go away soon.

   Author:
       George V. Reilly      (GeorgeRe)     1998

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash subtable.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  this->IsWriteLocked()
               :  this->IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    PBucket pbkt = _BucketFromAddress(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);

    if (_UseBucketLocking())
    {
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();
    }

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = _NodeBegin() - _NodeStep();

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        this->WriteLock();
    else
        this->ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash subtable
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  this->IsWriteLocked()
               :  this->IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < _NodesPerClump())
               || (_NodeBegin() - _NodeStep() == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode != _NodeBegin() - _NodeStep())
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, LKAR_ITER_RELEASE);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((piter->m_iNode += _NodeStep())  !=  _NodeEnd())
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];

                if (piter->m_pnc->m_dwKeySigs[piter->m_iNode]
                        != HASH_INVALID_SIGNATURE)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, LKAR_ITER_ACQUIRE);
                    return LK_SUCCESS;
                }
                else
                {
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(piter->m_pnc->NoMoreValidSlots(piter->m_iNode));
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = _NodeBegin() - _NodeStep();
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        PBucket pbkt = _BucketFromAddress(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);

        if (_UseBucketLocking())
        {
            IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                       ?  pbkt->IsWriteLocked()
                       :  pbkt->IsReadLocked());
        
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteUnlock();
            else
                pbkt->ReadUnlock();
        }

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _BucketFromAddress(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);

            if (_UseBucketLocking())
            {
                if (piter->m_lkl == LKL_WRITELOCK)
                    pbkt->WriteLock();
                else
                    pbkt->ReadLock();
            }
            
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = _NodeBegin() - _NodeStep();
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  this->IsWriteLocked()
               :  this->IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < _NodesPerClump())
               || (_NodeBegin() - _NodeStep() == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the subtable?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        PBucket pbkt = _BucketFromAddress(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);

        if (_UseBucketLocking())
        {
            IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                       ?  pbkt->IsWriteLocked()
                       :  pbkt->IsReadLocked());
        }
        
        if (0 <= piter->m_iNode  &&  piter->m_iNode < _NodesPerClump())
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, LKAR_ITER_CLOSE);
        }

        if (_UseBucketLocking())
        {
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteUnlock();
            else
                pbkt->ReadUnlock();
        }
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        this->WriteUnlock();
    else
        this->ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator

#endif // LKR_DEPRECATED_ITERATORS


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-stl-iter.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-stl-iter.cpp

   Abstract:
       Implements STL-style iterators for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     March 2000

   Project:
       LKRhash

   Revision History:
       March 2000

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifdef LKR_STL_ITERATORS


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash subtable.
//------------------------------------------------------------------------

CLKRLinearHashTable::Iterator
CLKRLinearHashTable::Begin()
{
    Iterator iter(this,
                  &_BucketFromAddress(0)->m_ncFirst,
                  0,
                  static_cast<CLKRLinearHashTable_Iterator::NodeIndex>(
                      _NodeBegin() - _NodeStep())
                  );

    LKR_ITER_TRACE(_TEXT("  LKLH:Begin(it=%p, plht=%p)\n"), &iter, this);
    
    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_iNode != _NodeBegin() - _NodeStep());
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRLinearHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable_Iterator::Increment()
// Synopsis: move iterator to next valid record in subtable
//------------------------------------------------------------------------

bool
CLKRLinearHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_plht != NULL);
    IRTLASSERT(m_dwBucketAddr < m_plht->m_cActiveBuckets);
    IRTLASSERT(m_pnc != NULL);
    IRTLASSERT((0 <= m_iNode  &&  m_iNode < _NodesPerClump())
               || (_NodeBegin() - _NodeStep() == m_iNode));

    // Release the reference acquired in the previous call to _Increment
    if (fDecrementOldValue)
    {
        _AddRef(LKAR_ITER_RELEASE);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((m_iNode += NODE_STEP) !=  _NodeEnd())
            {
                const DWORD dwSignature = m_pnc->m_dwKeySigs[m_iNode];

                if (dwSignature != HASH_INVALID_SIGNATURE)
                {
                    IRTLASSERT(! m_pnc->IsEmptyAndInvalid(m_iNode));

                    // Add a new reference
                    _AddRef(LKAR_ITER_ACQUIRE);

                    LKR_ITER_TRACE(_TEXT("  LKLH:++(this=%p, plht=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_plht, m_pnc,
                                   m_dwBucketAddr, m_iNode,
                                   m_pnc->m_pvNode[m_iNode]);

                    return true;
                }
                else
                {
#if 0 //// #ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(m_pnc->NoMoreValidSlots(m_iNode));
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            m_iNode = _NodeBegin() - _NodeStep();
            m_pnc = m_pnc->m_pncNext;

        } while (m_pnc != NULL);

        // Try the next bucket, if there is one
        if (++m_dwBucketAddr < m_plht->m_cActiveBuckets)
        {
            PBucket pbkt = m_plht->_BucketFromAddress(m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            m_pnc = &pbkt->m_ncFirst;
        }

    } while (m_dwBucketAddr < m_plht->m_cActiveBuckets);

    // We have fallen off the end of the hashtable. Set iterator equal
    // to end(), the empty iterator.
    LKR_ITER_TRACE(_TEXT("  LKLH:End(this=%p, plht=%p)\n"), this, m_plht);

    m_plht = NULL;
    m_pnc = NULL;
    m_dwBucketAddr = 0;
    m_iNode = 0;

    //// IRTLASSERT(this->operator==(Iterator())); // == end()

    return false;
} // CLKRLinearHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Insert
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite /* = false */)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
#ifndef LKR_ALLOW_NULL_RECORDS
    if (pvRecord == NULL)
        return false;
#endif
    
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
        
    bool fSuccess = (_InsertRecord(pvRecord, pnKey, _CalcKeyHash(pnKey),
                                  fOverwrite, &riterResult)
                     == LK_SUCCESS);

    IRTLASSERT(riterResult.m_iNode != _NodeBegin() - _NodeStep());
    IRTLASSERT(fSuccess
               ?  _IsValidIterator(riterResult)
               :  riterResult == End());

    return fSuccess;
} // CLKRLinearHashTable::Insert()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_Erase(
    Iterator& riter,
    DWORD     dwSignature)
{
    PNodeClump pncCurr, pncPrev;
    PBucket const pbkt
        = riter.m_plht->_BucketFromAddress(riter.m_dwBucketAddr);

    LKR_ITER_TRACE(_TEXT("  LKLH:_Erase:pre(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);

    if (_UseBucketLocking())
        pbkt->WriteLock();

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        if (pncCurr == riter.m_pnc)
            break;
    }
    IRTLASSERT(pncCurr != NULL);

    // Release the iterator's reference on the record
    const void* pvRecord = riter.m_pnc->m_pvNode[riter.m_iNode];
#ifndef LKR_ALLOW_NULL_RECORDS
    IRTLASSERT(pvRecord != NULL);
#endif
    IRTLASSERT(HASH_INVALID_SIGNATURE != riter.m_pnc->m_dwKeySigs[riter.m_iNode]);
    _AddRefRecord(pvRecord, LKAR_ITER_ERASE);

    // _DeleteNode will leave iterator members pointing to the
    // preceding record
    NodeIndex iNode = riter.m_iNode;

    _DeleteNode(pbkt, riter.m_pnc, pncPrev, iNode, LKAR_ITER_ERASE_TABLE);

    if (iNode == _NodeEnd())
    {
        LKR_ITER_TRACE(_TEXT("\t_Erase(Bkt=%p, pnc=%p, Prev=%p, iNode=%d)\n"),
                       pbkt, riter.m_pnc, pncPrev, iNode);
    }
                  
    riter.m_iNode = static_cast<CLKRLinearHashTable_Iterator::NodeIndex>(
                        (iNode == _NodeEnd())
                             ?  _NodeEnd() - _NodeStep()
                             :  iNode);

    if (_UseBucketLocking())
        pbkt->WriteUnlock();

    // Don't contract the subtable. Likely to invalidate the iterator,
    // if iterator is being used in a loop

    return true;
} // CLKRLinearHashTable::_Erase()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:pre(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    bool fSuccess = _Erase(riter, dwSignature);
    bool fIncrement = false;
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL,
                   (fSuccess ? "true" : "false"));
    
    // _Erase left riter pointing to the preceding record.
    // Move to next record.
    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_iNode != _NodeBegin() - _NodeStep());
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter == End());
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post++(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n  LKLH:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT("  LKLH:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    bool        fFound   = (_FindKey(pnKey, hash_val, &pvRecord, &riterResult)
                            == LK_SUCCESS);

    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());
    IRTLASSERT(riterResult.m_iNode != _NodeBegin() - _NodeStep());

    return fFound;
} // CLKRLinearHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT("  LKLH:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_iNode != _NodeBegin() - _NodeStep());
    IRTLASSERT(fFound ?  _IsValidIterator(riterFirst) :  riterFirst == End());

    IRTLASSERT(riterLast.m_iNode  != _NodeBegin() - _NodeStep());
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRLinearHashTable::EqualRange



//------------------------------------------------------------------------
// Function: CLKRHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRHashTable::Iterator
CLKRHashTable::Begin()
{
    Iterator iter(this, -1);

    LKR_ITER_TRACE(_TEXT(" LKHT:Begin(it=%p, pht=%p)\n"), &iter, this);

    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_ist != -1);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRHashTable_Iterator::_Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_pht != NULL);
    IRTLASSERT(-1 <= m_ist
               &&  m_ist < static_cast<int>(m_pht->m_cSubTables));

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (m_subiter.m_plht == NULL)
        {
            while (++m_ist < static_cast<int>(m_pht->m_cSubTables))
            {
                LKR_ITER_TRACE(_TEXT(" LKHT:++IST=%d\n"), m_ist);
                m_subiter = m_pht->m_palhtDir[m_ist]->Begin();

                if (m_subiter.m_plht != NULL)
                {
                    LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                                   _TEXT("LHT=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_pht, m_ist,
                                   m_subiter.m_plht, m_subiter.m_pnc,
                                   m_subiter.m_dwBucketAddr, m_subiter.m_iNode,
                                   m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]
                                  );
                    return true;
                }
            }
            
            // There are no more subtables left.
            LKR_ITER_TRACE(_TEXT(" LKHT:End(this=%p, pht=%p)\n"), this, m_pht);

            m_pht = NULL;
            m_ist = 0;

            //// IRTLASSERT(this->operator==(Iterator())); // == end()
            
            return false;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        m_subiter._Increment(fDecrementOldValue);

        if (m_subiter.m_plht != NULL)
        {
            LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                           _TEXT("LHT=%p, NC=%p, BA=%u, IN=%d, Rec=%p)\n"),
                           this, m_pht, m_ist,
                           m_subiter.m_plht, m_subiter.m_pnc,
                           m_subiter.m_dwBucketAddr, m_subiter.m_iNode, 
                           m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]);
            return true;
        }
    }
} // CLKRHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRHashTable::Insert
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
#ifndef LKR_ALLOW_NULL_RECORDS
    if (pvRecord == NULL)
        return false;
#endif
    
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);

    bool f = (pst->_InsertRecord(pvRecord, pnKey, hash_val, fOverwrite,
                                 &riterResult.m_subiter)
              == LK_SUCCESS);

    if (f)
    {
        riterResult.m_pht = this;
        riterResult.m_ist
            = static_cast<CLKRHashTable_Iterator::SubTableIndex>(
                        _SubTableIndex(pst));
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(f  ?  _IsValidIterator(riterResult)  :  riterResult == End());

    return f;
} // CLKRHashTable::Insert



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD     dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    SubTable* const pst   = _SubTable(dwSignature);

    IRTLASSERT(pst == riter.m_subiter.m_plht);

    if (pst != riter.m_subiter.m_plht)
        return false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:pre(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    // _Erase left riter pointing to the preceding record. Move to
    // next record.
    bool fSuccess = pst->_Erase(riter.m_subiter, dwSignature);
    bool fIncrement = false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   ((riter.m_subiter.m_pnc && riter.m_subiter.m_iNode >= 0)
                        ? riter.Record() : NULL),
                   (fSuccess ? "true" : "false"));

    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_ist != -1);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter  == End());

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post++(iter=%p, pht=%p, ist=%d, ")
                   _TEXT("plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n LKHT:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    bool        fFound   = (pst->_FindKey(pnKey, hash_val, &pvRecord,
                                          &riterResult.m_subiter)
                            == LK_SUCCESS);
    if (fFound)
    {
        riterResult.m_pht = this;
        riterResult.m_ist
            = static_cast<CLKRHashTable_Iterator::SubTableIndex>(
                        _SubTableIndex(pst));
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());

    return fFound;
} // CLKRHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_ist != -1);
    IRTLASSERT(fFound ? _IsValidIterator(riterFirst) : riterFirst == End());

    IRTLASSERT(riterLast.m_ist != -1);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRHashTable::EqualRange


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // LKR_STL_ITERATORS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkr-validate.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKR-validate.cpp

   Abstract:
       _IsBucketChainMultiKeySorted, _IsBucketChainCompact, CheckTable

   Author:
       George V. Reilly      (GeorgeRe)

   Project:
       LKRhash

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


#define CheckAndAdd(var, cond)  \
    { IRTLASSERT(cond);  var += !(cond); }

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsBucketChainMultiKeySorted
// Synopsis: validates that a node is correctly sorted for multikeys
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsBucketChainMultiKeySorted(
    PBucket const pbkt) const
{
    // If it's not a MultiKeys hashtable, we don't bother sorting
    if (! m_fMultiKeys)
        return 0;

    DWORD       dwSigPrev = pbkt->FirstSignature();
    DWORD_PTR   pnKeyPrev = (dwSigPrev == HASH_INVALID_SIGNATURE
                             ?  0
                             :  _ExtractKey(pbkt->FirstNode()));
    NodeIndex   iNode     = _NodeBegin() + _NodeStep(); // second node
    int         cErrors   = 0;

    for (PNodeClump pncCurr =  &pbkt->m_ncFirst;
                    pncCurr !=  NULL;
                    pncCurr =   pncCurr->m_pncNext)
    {
        for (  ;  iNode != _NodeEnd();  iNode += _NodeStep())
        {
            // if m_dwKeySigs[iNode] == HASH_INVALID_SIGNATURE, then
            // all subsequent nodes should also be invalid

            if (pncCurr->InvalidSignature(iNode))
            {
                // Must be last nodeclump in the bucket chain
                CheckAndAdd(cErrors, pncCurr->IsLastClump());

                for (NodeIndex j = iNode;  j != _NodeEnd();  j += _NodeStep())
                {
                    CheckAndAdd(cErrors, pncCurr->IsEmptyAndInvalid(j));
                }

                dwSigPrev = HASH_INVALID_SIGNATURE;
                pnKeyPrev = 0;

                // It's possible for preceding keys to have a
                // signature > HASH_INVALID_SIGNATURE
                continue;
            }
            
            const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[iNode]);
            const DWORD     dwSig = pncCurr->m_dwKeySigs[iNode];

            // valid signatures must be in ascending order
            CheckAndAdd(cErrors, dwSigPrev <= dwSig);
            
            if (dwSigPrev == dwSig)
            {
                // Are the keys in sorted order?
                const int nCmp = _CompareKeys(pnKeyPrev, pnKey);

                CheckAndAdd(cErrors, nCmp <= 0);
            }

            pnKeyPrev = pnKey;
            dwSigPrev = dwSig;
        }

        iNode = _NodeBegin(); // reinitialize for inner loop
    }
    
    return cErrors;
} // CLKRLinearHashTable::_IsBucketChainMultiKeySorted



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsBucketChainCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsBucketChainCompact(
    PBucket const pbkt) const
{
    int  cErrors = 0;
    bool fEmpty  = pbkt->IsEmptyFirstSlot();

    if (fEmpty)
    {
        CheckAndAdd(cErrors, pbkt->m_ncFirst.IsLastClump());
    }

    cErrors += _IsBucketChainMultiKeySorted(pbkt);

    for (PNodeClump pncCurr =  &pbkt->m_ncFirst;
                    pncCurr !=  NULL;
                    pncCurr =   pncCurr->m_pncNext)
    {
        FOR_EACH_NODE_DECL(iNode)
        {
            if (fEmpty)
            {
                CheckAndAdd(cErrors, pncCurr->IsEmptyAndInvalid(iNode));
            }
            else if (pncCurr->InvalidSignature(iNode))
            {
                // first empty node
                fEmpty = true;
                CheckAndAdd(cErrors, pncCurr->IsLastClump());
                CheckAndAdd(cErrors, pncCurr->IsEmptyAndInvalid(iNode));
            }
            else // still in non-empty portion
            {
                CheckAndAdd(cErrors, !pncCurr->IsEmptyAndInvalid(iNode));
            }
        }
    }

    return cErrors;
} // CLKRLinearHashTable::_IsBucketChainCompact



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash subtable is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE; // negative

    bool fReadLocked = this->_ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        this->_ReadOrWriteUnlock(fReadLocked);
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       cErrors = 0;
    DWORD     iBkt;

    // Check every bucket
    for (iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        PBucket const pbkt = _BucketFromAddress(iBkt);

        CheckAndAdd(cErrors, pbkt != NULL);

        if (_UseBucketLocking())
            pbkt->ReadLock();

        IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

        // Walk the bucket chain
        for (PNodeClump pncCurr =  &pbkt->m_ncFirst,  pncPrev = NULL;
                        pncCurr !=  NULL;
                        pncPrev =   pncCurr,  pncCurr = pncCurr->m_pncNext)
        {
            FOR_EACH_NODE_DECL(iNode)
            {
                if (pncCurr->IsEmptySlot(iNode))
                {
                    CheckAndAdd(cErrors, pncCurr->IsLastClump());

                    for (NodeIndex j = iNode;
                                   j != _NodeEnd();
                                   j += _NodeStep())
                    {
                        CheckAndAdd(cErrors, pncCurr->IsEmptyAndInvalid(j));
                    }

                    break;
                }
                else
                {
                    ++cRecords;

#ifndef LKR_ALLOW_NULL_RECORDS
                    CheckAndAdd(cErrors, NULL != pncCurr->m_pvNode[iNode]);
#endif

                    const DWORD_PTR pnKey
                        = _ExtractKey(pncCurr->m_pvNode[iNode]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);

                    CheckAndAdd(cErrors,
                                dwSignature != HASH_INVALID_SIGNATURE);
                    CheckAndAdd(cErrors,
                                dwSignature == pncCurr->m_dwKeySigs[iNode]);

                    DWORD address = _BucketAddress(dwSignature);

                    CheckAndAdd(cErrors, address == iBkt);

                    if (address != iBkt
                        || dwSignature != pncCurr->m_dwKeySigs[iNode])
                    {
                        ++cMisplaced;
                    }
                }
            }

            if (pncPrev != NULL)
            {
                CheckAndAdd(cErrors, pncPrev->m_pncNext == pncCurr);
            }
        }

        if (_UseBucketLocking())
            pbkt->ReadUnlock();
    }

    CheckAndAdd(cErrors, cRecords == m_cRecords);

    if (cMisplaced > 0)
        cErrors += cMisplaced;

    CheckAndAdd(cErrors, cMisplaced == 0);

    // CODEWORK: check that all buckets from m_cActiveBuckets on in
    // the last segment are empty

    this->_ReadOrWriteUnlock(fReadLocked);

    return cErrors;

} // CLKRLinearHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int cErrors = 0, cUnusables = 0;

    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        int retcode = m_palhtDir[i]->CheckTable();

        if (retcode < 0)
        {
            IRTLASSERT(retcode == LK_UNUSABLE);
            ++cUnusables;
        }
        else
            cErrors += retcode;
    }

    return cUnusables > 0  ?  LK_UNUSABLE  :  cErrors;

} // CLKRHashTable::CheckTable


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\acwebsvc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )


// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

//# define    DEBUG_TRACE                0x10000000
//# define    DEBUG_DUMPS                0x20000000



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\acwebsvc\acwebsvc.cxx ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   acwebsvc.cxx

 Abstract:

   This dll is the IIS app compat shim.  Its purpose is
   to create appropriate metabase entries in the
   WebSvcExtRestrictionList and ApplicationDependencies
   properties.

 Author:
   Wade A. Hilmo (WadeH)              30-Apr-2002

 Project:
   AcWebSvc.dll
   
--*/

#include "precomp.hxx"
#include <stdio.h>

typedef VOID        (WINAPI *_pfn_ExitProcess)(UINT uExitCode);

#define WRITE_BUFFER_SIZE   1024

//
//  Global Data
//

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

STRU            g_strAppName;
STRU            g_strBasePath;
STRU            g_strPathType;
STRU            g_strWebSvcExtensions;
STRU            g_strGroupID;
STRU            g_strGroupDesc;
STRU            g_strEnableExtGroups;
STRU            g_strIndicatorFile;
STRU            g_strCookedBasePath;
STRU            g_strHonorDisabled;

LIST_ENTRY      g_Head;

IMSAdminBase *  g_pMetabase = NULL;
BOOL            g_fCoInitialized = FALSE;

//
// The DBG build of shimlib.lib introduces some 
// problems at both build time and run time.  For
// now, we'll just defeat DBG code.  This project
// has no dependencies on the DBG stuff anyway.
//

#ifdef DBG
#undef DBG
#define DBG_DISABLED
#endif

#include "ShimHook.h"

HRESULT
GetStringDataFromAppCompatDB(
    const PDB   pdb,
    const TAGID TagId,
    LPCWSTR     szName,
    STRU *      pstrValue
    );

using namespace ShimLib;

IMPLEMENT_SHIM_STANDALONE(AcWebSvc)
#include "ShimHookMacro.h"

#ifdef DBG_DISABLED
#undef DBG_DISABLED
#define DBG
#endif

DECLARE_SHIM(AcWebSvc)

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExitProcess)
APIHOOK_ENUM_END

//
// Function implementations
//

VOID
APIHOOK(ExitProcess)(
    UINT uExitCode
    )
{
    HRESULT hr;

    WriteDebug( L"EnableIIS shim notified of ExitProcess.\r\n" );

    hr = InitMetabase();

    if ( SUCCEEDED( hr ) )
    {
        DoWork( COMMAND_LINE );

        UninitMetabase();
    }

    ORIGINAL_API(ExitProcess)(uExitCode);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
/*++

Routine Description:

    AppCompat calls into this function at several points.

    For this shim, we are only interested in DLL_PROCESS_DETACH,
    which gets called when the shimmed process terminates.
    
    *** Note that DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH may
    look like DllMain entries.  They are not.  Please refer to
    the AppCompat documentation and other resources before making
    assumptions about the loader lock or any other process state.

Arguments:

    fdwReason - The reason this function was called.
  
Return Value:

    TRUE on success

--*/
{
    HRESULT hr;
    DWORD   dwThreadId;

    //
    // Note that there are further cases besides attach and detach.
    //
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            break;
    
        case SHIM_STATIC_DLLS_INITIALIZED:

            break;

        case SHIM_PROCESS_DYING:

            break;

        default:
            break;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, ExitProcess)

HOOK_END

IMPLEMENT_SHIM_END

BOOL
DoWork(
    LPCSTR  szCommandLine
    )
{
    HRESULT hr;

    hr = ReadDataFromAppCompatDB( szCommandLine );

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    hr = BuildCookedBasePath( &g_strCookedBasePath );

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    hr = BuildListOfExtensions();

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    if ( IsApplicationInstalled() )
    {
        hr = InstallApplication();
    }
    else
    {
        hr = UninstallApplication();
    }

Finished:

    if ( FAILED( hr ) )
    {
        WriteDebug( L"EnableIIS encountered errors performing lockdown "
                    L"for application '%s'.\r\n",
                    *g_strAppName.QueryStr() != L'\0' ? g_strAppName.QueryStr() : L"unknown" );

        SetLastError( WIN32_FROM_HRESULT( hr ) );
    }
    else
    {
        WriteDebug( L"EnableIIS shim completed successfully completed "
                    L"lockdown registration for application '%s'.\r\n",
                    g_strAppName.QueryStr() );
    }

    return SUCCEEDED( hr );
}

HRESULT
ReadDataFromAppCompatDB(
    LPCSTR  szCommandLine
    )
{
    STRU    strDatabasePath;
    LPSTR   pGuid;
    LPSTR   pTagId;
    LPSTR   pCursor;
    GUID    guid;
    PDB     pdb;
    TAGID   TagId;
    BOOL    fResult;
    DWORD   dwError;
    RPC_STATUS  status;
    HRESULT hr = S_OK;

    //
    // Parse the command line
    //
    // Note that we are heavily dependent on the exact
    // syntax that app compat uses to call into us.  This
    // code is based on their sample code, and it is
    // supposed to be the correct way to parse it...
    //

    pCursor = strstr( szCommandLine, "-d{" );

    if ( pCursor == NULL )
    {
        WriteDebug( L"Error parsing command line.  Option '-d' not found.\r\n" );

        return E_FAIL;
    }

    pGuid = pCursor + 3;

    pCursor = strchr( pGuid, '}' );

    if ( pCursor == NULL )
    {
        WriteDebug( L"Error parsing command line.  Option '-d' malformed.\r\n" );

        return E_FAIL;
    }

    *pCursor = NULL;

    pCursor++;

    pTagId = strstr( pCursor, "-t" );

    if ( pTagId == NULL )
    {
        WriteDebug( L"Error parsing command line.  Option '-t' not found.\r\n" );

        return E_FAIL;
    }

    pTagId += 2;

    //
    // Get the GUID for the app compat database
    //

    status = UuidFromStringA( (unsigned char *)pGuid, &guid );

    if ( status != RPC_S_OK )
    {
        dwError = status;

        WriteDebug( L"Error %d occurred getting GUID from command line.\r\n",
                    dwError );

        return HRESULT_FROM_WIN32( dwError );
    }

    hr = strDatabasePath.Resize( MAX_PATH );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    fResult = SdbResolveDatabase( NULL,
                                  &guid,
                                  NULL,
                                  strDatabasePath.QueryStr(),
                                  MAX_PATH );

    if ( !fResult )
    {
        dwError = GetLastError();

        WriteDebug( L"Error %d occurred resolving AppCompat database.\r\n",
                    dwError );

        return HRESULT_FROM_WIN32( dwError );
    }

    //
    // Open the database
    //

    pdb = SdbOpenDatabase( strDatabasePath.QueryStr(), DOS_PATH );

    if ( pdb == NULL )
    {
        dwError = GetLastError();

        WriteDebug( L"Error %d occurred opending AppCompat database.\r\n",
                    dwError );

        return HRESULT_FROM_WIN32( dwError );
    }

    TagId = (TAGID)strtoul( pTagId, NULL, 0 );

    if ( TagId == TAGID_NULL )
    {
        WriteDebug( L"The shimref is invalid.\r\n" );

        return E_FAIL;
    }

    //
    // Read the data we need from the app compat database
    //
    // AppName is required.  There are scenarios where any
    // of the others might be absent.
    //

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"AppName",
                                       &g_strAppName );

    if ( FAILED( hr ) )
    {
        WriteDebug( L"Error 0x%08x occurred getting 'AppName' from "
                    L"AppCompat database.\r\n",
                    hr );

        return hr;
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"BasePath",
                                       &g_strBasePath );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strBasePath.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"PathType",
                                       &g_strPathType );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strPathType.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"WebSvcExtensions",
                                       &g_strWebSvcExtensions );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strWebSvcExtensions.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"GroupID",
                                       &g_strGroupID );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strGroupID.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"GroupDesc",
                                       &g_strGroupDesc );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strGroupDesc.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"EnableExtGroups",
                                       &g_strEnableExtGroups );
    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strEnableExtGroups.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"SetupIndicatorFile",
                                       &g_strIndicatorFile );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strIndicatorFile.Copy( L"" ) ) )
        {
            return hr;
        }
    }

    hr = GetStringDataFromAppCompatDB( pdb,
                                       TagId,
                                       L"HonorDisabledExtensionsAndDependencies",
                                       &g_strHonorDisabled );

    if ( FAILED( hr ) )
    {
        if ( FAILED( hr = g_strHonorDisabled.Copy( L"TRUE" ) ) )
        {
            return hr;
        }
    }

    return hr;
}

HRESULT
GetStringDataFromAppCompatDB(
    const PDB   pdb,
    const TAGID TagId,
    LPCWSTR     szName,
    STRU *      pstrValue
    )
{
    DWORD   dwError;
    DWORD   dwDataType;
    DWORD   cbData = 0;
    HRESULT hr = S_OK;

    //
    // Call the database with a NULL buffer to get the
    // necessary size.
    //

    dwError = SdbQueryDataExTagID( pdb,
                              TagId,
                              szName,
                              &dwDataType,
                              NULL,
                              &cbData,
                              NULL );

    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
    {
        //
        // Don't write for ERROR_NOT_FOUND
        //
        
        if ( dwError != ERROR_NOT_FOUND )
        {
            WriteDebug( L"Error %d occurred getting '%s' from "
                        L"AppCompat database.\r\n",
                        dwError,
                        szName );
        }

        return HRESULT_FROM_WIN32( dwError );
    }

    //
    // Resize the buffer and call it for real.
    //

    hr = pstrValue->Resize( cbData );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    dwError = SdbQueryDataExTagID( pdb,
                              TagId,
                              szName,
                              &dwDataType,
                              pstrValue->QueryStr(),
                              &cbData,
                              NULL );

    if ( dwError != ERROR_SUCCESS )
    {
        return HRESULT_FROM_WIN32( dwError );
    }

    return hr;
}

HRESULT
BuildListOfExtensions(
    VOID
    )
{
    LPWSTR              pExtension;
    LPWSTR              pNext;
    EXTENSION_IMAGE *   pRecord;
    HRESULT             hr;

    InitializeListHead( &g_Head );

    pExtension = g_strWebSvcExtensions.QueryStr();

    //
    // If there are no extensions in the list,
    // we should just return now.
    //

    if ( *pExtension == L'\0' )
    {
        return S_OK;
    }

    //
    // Parse the list of extensions
    //

    while ( pExtension )
    {
        pNext = wcschr( pExtension, ',' );

        if ( pNext )
        {
            *pNext = L'\0';
            pNext++;
        }

        pRecord = new EXTENSION_IMAGE;

        if ( pRecord == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        hr = pRecord->strPath.Copy( g_strCookedBasePath.QueryStr() );

        if ( FAILED( hr ) )
        {
            delete pRecord;
            return hr;
        }

        hr = pRecord->strPath.Append( pExtension );

        if ( FAILED( hr ) )
        {
            delete pRecord;
            return hr;
        }

        InsertTailList( &g_Head, &pRecord->le );

        pExtension = pNext;
    }

    return hr;
}

HRESULT
BuildCookedBasePath(
    STRU *  pstrCookedBasePath
    )
{
    STRU    strBasePathFromReg;
    LPWSTR  pCursor;
    LPWSTR  pKeyName;
    LPWSTR  pValueName;
    HKEY    hRootKey;
    HKEY    hKey;
    DWORD   dwError;
    DWORD   cbData;
    DWORD   dwType;
    HRESULT hr;

    //
    // If the base path is a reg key, then get it now
    //

    if ( wcscmp( g_strPathType.QueryStr(), L"1" ) == 0 )
    {
        //
        // Get the root key
        //

        if ( _wcsnicmp( g_strBasePath.QueryStr(), L"HKEY_LOCAL_MACHINE", 18 ) == 0 )
        {
            hRootKey = HKEY_LOCAL_MACHINE;
            pKeyName = g_strBasePath.QueryStr() + 19;
        }
        else if ( _wcsnicmp( g_strBasePath.QueryStr(), L"HKEY_CURRENT_USER", 17 ) == 0 )
        {
            hRootKey = HKEY_CURRENT_USER;
            pKeyName = g_strBasePath.QueryStr() + 18;
        }
        else if ( _wcsnicmp( g_strBasePath.QueryStr(), L"HKEY_CLASSES_ROOT", 17 ) == 0 )
        {
            hRootKey = HKEY_CLASSES_ROOT;
            pKeyName = g_strBasePath.QueryStr() + 18;
        }
        else if ( _wcsnicmp( g_strBasePath.QueryStr(), L"HKEY_USERS", 10 ) == 0 )
        {
            hRootKey = HKEY_USERS;
            pKeyName = g_strBasePath.QueryStr() + 11;
        }
        else if ( _wcsnicmp( g_strBasePath.QueryStr(), L"HKEY_CURRENT_CONFIG", 19 ) == 0 )
        {
            hRootKey = HKEY_CURRENT_CONFIG;
            pKeyName = g_strBasePath.QueryStr() + 20;
        }
        else
        {
            WriteDebug( L"Registry key '%s' unknown.\r\n",
                        g_strBasePath.QueryStr() );

            return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        }

        //
        // Split off the value name from the key name
        //

        pValueName = wcsrchr( pKeyName, '\\' );

        if ( pValueName == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        }

        *pValueName = L'\0';

        pValueName++;

        //
        // Ok, now get it from the registry
        //

        dwError = RegOpenKeyW( hRootKey,
                               pKeyName,
                               &hKey);

        if ( dwError != ERROR_SUCCESS )
        {
            return HRESULT_FROM_WIN32( dwError );
        }

        //
        // Get the data from the registry
        //

        cbData = strBasePathFromReg.QueryCB();

        dwError = RegQueryValueExW( hKey,
                                    pValueName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)strBasePathFromReg.QueryStr(),
                                    &cbData );

        if ( dwError == ERROR_MORE_DATA )
        {
            //
            // Resize the buffer and try again
            //

            hr = strBasePathFromReg.Resize( cbData );

            if ( FAILED( hr ) )
            {
                RegCloseKey( hKey );
                return hr;
            }

            dwError = RegQueryValueExW( hKey,
                                        pValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)strBasePathFromReg.QueryStr(),
                                        &cbData );
        }

        RegCloseKey( hKey );

        //
        // If we still don't have it, or if the key type
        // is wrong, then fail.
        //

        if ( dwError != ERROR_SUCCESS ||
             dwType != REG_SZ )
        {
            WriteDebug( L"Value '%s' not found in key '%s'.\r\n",
                        pValueName,
                        pKeyName );

            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        }

        //
        // Now set the base path from the registry into
        // the global
        //

        hr = g_strBasePath.Copy( strBasePathFromReg.QueryStr() );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Ok, at this point, we can expand the global base path
    // into the return variable.
    //
    // Note that in testing, I found that calling ExpandEnvironmentStrings
    // twice, with the first call getting the size would cause AV's
    // with pageheap on the second call.  So to work around the issue,
    // I'm just resizing the buffer to 16K, which should accommodate
    // any reasonable path.
    //

    hr = pstrCookedBasePath->Resize( 16384 );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    cbData = ExpandEnvironmentStrings( g_strBasePath.QueryStr(),
                                       pstrCookedBasePath->QueryStr(),
                                       16384 );

    return S_OK;
}

BOOL
IsApplicationInstalled(
    VOID
    )
{
    STRU                strCookedIndicatorFile;
    LIST_ENTRY *        ple;
    EXTENSION_IMAGE *   pImage;
    HRESULT             hr;
    BOOL                fUseIndicator = FALSE;
    BOOL                fResult = FALSE;

    //
    // If we have a setup indicator file, use it's presence to
    // determine in installation has occured.
    //

    if ( *g_strIndicatorFile.QueryStr() != L'\0' )
    {
        fUseIndicator = TRUE;

        hr = strCookedIndicatorFile.Copy( g_strCookedBasePath.QueryStr() );

        if ( FAILED( hr ) )
        {
            //
            // On error, assume not installed
            //

            return FALSE;
        }

        hr = strCookedIndicatorFile.Append( g_strIndicatorFile.QueryStr() );

        if ( FAILED( hr ) )
        {
            return FALSE;
        }

        fResult = DoesFileExist( strCookedIndicatorFile.QueryStr() );
    }

    //
    // No indicator file.  Check for the existence of any ISAPI extensions
    // associated with the hooked application.
    //

    ple = g_Head.Flink;

    while ( ple != &g_Head )
    {
        pImage = CONTAINING_RECORD( ple,
                                    EXTENSION_IMAGE,
                                    le );

        if ( DoesFileExist( pImage->strPath.QueryStr() ) )
        {
            pImage->fExists = TRUE;

            if ( !fUseIndicator )
            {
                fResult = TRUE;
            }
        }
        else
        {
            pImage->fExists = FALSE;
        }

        ple = ple->Flink;
    }

    return fResult;
}

HRESULT
InstallApplication(
    VOID
    )
{
    HRESULT         hr;

    WriteDebug( L"EnableIIS shim doing install for application '%s'.\r\n",
                 g_strAppName.QueryStr() );

    //
    // Enable the application's extensions.  Note that the
    // AddExtensionsToMetabase function will only add extensions
    // that are not already present in the metabase.
    //

    hr = AddExtensionsToMetabase();

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Check to see if we already have an ApplicationDependencies
    // entry for this application.  If we do, we should assume that
    // installation has already been done and we should take no
    // further action.
    //

    if ( IsApplicationAlreadyInstalled() )
    {
        WriteDebug( L"Application '%s' already registered "
                    L"in metabase ApplicationDependencies key. "
                    L"No changes will be made.",
                    g_strAppName.QueryStr() );

        hr = S_OK;

        goto Finished;
    }


    //
    // Set the application's dependencies in the
    // metabase
    //

    hr = AddDependenciesToMetabase();

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

Finished:

    if ( FAILED( hr ) )
    {
        //
        // If we failed, then we should try to undo
        // our work so that we don't leave the application
        // in a bogus state.
        //

        WriteDebug( L"EnableIIS shim will undo work done so far.\r\n" );

        UninstallApplication();
    }
    else
    {
        WriteDebug( L"EnableIIS shim successfully registered lockdown "
                    L"information for application '%s'.\r\n",
                    g_strAppName.QueryStr() );
    }

    return hr;
}

HRESULT
UninstallApplication(
    VOID
    )
{
    HRESULT hr;

    WriteDebug( L"EnableIIS shim performing uninstall of application '%s'.\r\n",
                g_strAppName.QueryStr() );

    //
    // Remove the application's extensions from the
    // metabase.
    //

    hr = RemoveExtensionsFromMetabase();

    if ( FAILED( hr ) )
    {
        //
        // Report the failure, but let the function
        // continue to run.  No action needs to be taken.
        //
    }

    //
    // Remove the application dependencies from the metabase
    //

    hr = RemoveDependenciesFromMetabase();

    if ( FAILED( hr ) )
    {
        //
        // Report the failure, but let the function
        // continue to run.  No action needs to be taken.
        //
    }

    WriteDebug( L"EnableIIS uninstall of application '%s' completed.\r\n",
                g_strAppName.QueryStr() );

    return hr;
}

HRESULT
InitMetabase(
    VOID
    )
{
    HRESULT hr = S_OK;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( SUCCEEDED( hr ) )
    {
        g_fCoInitialized = TRUE;
    }

    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           (LPVOID *)&(g_pMetabase) );

    if ( FAILED( hr ) )
    {
        WriteDebug( L"Error 0x%0x8 occurred initializing metabase.\r\n" );

        UninitMetabase();
    }

    return hr;
}

HRESULT
UninitMetabase(
    VOID
    )
{
    if ( g_pMetabase != NULL )
    {
        g_pMetabase->Release();
        g_pMetabase = NULL;
    }

    if ( g_fCoInitialized )
    {
        CoUninitialize();
        g_fCoInitialized = FALSE;
    }

    return S_OK;
}

BOOL
IsApplicationAlreadyInstalled(
    VOID
    )
{
    LPWSTR      pCursor;
    LPWSTR      pAppList = NULL;
    DWORD       cbAppList;
    HRESULT     hr;
    BOOL        fResult;

    DBG_ASSERT( g_pMetabase );

    CSecConLib  SecHelper( g_pMetabase );

    //
    // We should return TRUE on any errors.  This
    // will tell the caller that no shim work needs
    // to be done on install.
    //

    fResult = TRUE;

    //
    // Get app list from the metabase
    //

    hr = SecHelper.ListApplications( L"/LM/w3svc",
                                     &pAppList,
                                     &cbAppList );

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    pCursor = pAppList;

    //
    // Loop through the list from the metabase and
    // set fResult to FALSE if not present
    //

    fResult = FALSE;

    while ( *pCursor != L'\0' )
    {
        if ( _wcsicmp( pCursor, g_strAppName.QueryStr() ) == 0 )
        {
            fResult = TRUE;

            goto Finished;
        }

        pCursor += wcslen( pCursor ) + 1;
    }

Finished:

    if ( pAppList != NULL )
    {
        delete [] pAppList;
        pAppList = NULL;
    }

    return fResult;
}

HRESULT
AddExtensionsToMetabase(
    VOID
    )
{
    LIST_ENTRY *        ple;
    EXTENSION_IMAGE *   pImage;
    HRESULT             hr;

    DBG_ASSERT( g_pMetabase );

    CSecConLib  SecHelper( g_pMetabase );

    WriteDebug( L"Adding extensions for '%s' to the metabase "
                L"WebSvcExtRestrictionList entry.\r\n",
                g_strAppName.QueryStr() );

    ple = g_Head.Flink;

    while ( ple != &g_Head )
    {
        pImage = CONTAINING_RECORD( ple,
                                    EXTENSION_IMAGE,
                                    le );

        //
        // Only add extensions that actually exist on the drive and
        // don't already exist in the restrictionlist.
        //

        if ( pImage->fExists )
        {
            if ( IsExtensionInMetabase( pImage->strPath.QueryStr() ) )
            {
                //
                // Already in metabase.  Skip it.
                //

                WriteDebug( L"  Skipping '%s' because it's already listed.\r\n",
                            pImage->strPath.QueryStr() );
            }
            else
            {
                //
                // Need to add it to metabase.
                //

                WriteDebug( L"  Adding '%s'.\r\n",
                             pImage->strPath.QueryStr() );

                hr = SecHelper.AddExtensionFile( pImage->strPath.QueryStr(),
                                                 TRUE, // Image should be enabled
                                                 g_strGroupID.QueryStr(),
                                                 FALSE, // Not UI deletable
                                                 g_strGroupDesc.QueryStr(),
                                                 L"/LM/w3svc" );

                if ( FAILED( hr ) )
                {
                    //
                    // A failure here shouldn't be fatal,
                    // but we'll dump some debugger output for it
                    //

                    WriteDebug( L"    Error 0x%08x occurred adding '%s' to "
                                L"WebSvcExtRestrictionList.\r\n",
                                hr,
                                pImage->strPath.QueryStr() );
                }
            }
        }
        else
        {
            //
            // Hmm.  The file must not exist any more.
            //

            if ( IsExtensionInMetabase( pImage->strPath.QueryStr() ) )
            {
                //
                // Need to remove it, since it's apparently been uninstalled.
                //

                WriteDebug( L"  Removing '%s' because it's not on the disk.\r\n",
                            pImage->strPath.QueryStr() );

                hr = SecHelper.DeleteExtensionFileRecord( pImage->strPath.QueryStr(),
                                                          L"/LM/w3svc" );

                //
                // Don't consider 0x800cc801 (MD_ERROR_DATA_NOT_FOUND)
                // an error.
                //

                if ( hr == 0x800cc801 )
                {
                    hr = S_OK;
                }

                if ( FAILED( hr ) )
                {
                    //
                    // A failure here shouldn't be fatal,
                    // but we'll dump some debugger output for it
                    //

                    WriteDebug( L"    Error 0x%08x occurred removing '%s' from "
                                L"WebSvcExtRestrictionList.\r\n",
                                hr,
                                pImage->strPath.QueryStr() );
                }
            }
            else
            {
                WriteDebug( L"  Skipping '%s' because it is not on the disk.\r\n",
                            pImage->strPath.QueryStr() );
            }
        }

        ple = ple->Flink;
    }

    WriteDebug( L"Finished adding extensions for '%s'.\r\n",
                g_strAppName.QueryStr() );

    return S_OK;
}

HRESULT
AddDependenciesToMetabase(
    VOID
    )
{
    HRESULT hr;
    LPWSTR  pGroupID;
    LPWSTR  pCursor;
    LPWSTR  pNext;

    DBG_ASSERT( g_pMetabase );

    CSecConLib  SecHelper( g_pMetabase );

    WriteDebug( L"Adding dependencies for application '%s' to "
                L"metabase ApplicationDependencies list.\r\n",
                g_strAppName.QueryStr() );

    //
    // If the application depends on its own group,
    // add it now.
    //

    pGroupID = g_strGroupID.QueryStr();

    if ( *pGroupID != L'\0' )
    {
        WriteDebug( L"  Adding '%s'...\r\n",
                    pGroupID );

        hr = SecHelper.AddDependency( g_strAppName.QueryStr(),
                                      pGroupID,
                                      L"/LM/w3svc" );

        if ( FAILED( hr ) )
        {
            WriteDebug( L"    Error 0x%08x occurred adding '%s' "
                        L"as a dependency of '%s'.\r\n",
                        hr,
                        pGroupID,
                        g_strAppName.QueryStr() );
            return hr;
        }
    }

    //
    // If the application has outside dependencies,
    // add them now
    //

    pGroupID = g_strEnableExtGroups.QueryStr();

    while ( pGroupID )
    {
        pCursor = wcschr( pGroupID, L',' );

        if ( pCursor )
        {
            *pCursor = '\0';

            pNext = pCursor + 1;
        }
        else
        {
            pNext = NULL;
        }

        WriteDebug( L"  Adding '%s'...\r\n",
                    pGroupID );

        hr = SecHelper.AddDependency( g_strAppName.QueryStr(),
                                      pGroupID,
                                      L"/LM/w3svc" );

        if ( FAILED( hr ) )
        {
            WriteDebug( L"    Error 0x%08x occurred adding '%s' "
                        L"as a dependency of '%s'.\r\n",
                        hr,
                        pGroupID,
                        g_strAppName.QueryStr() );

            return hr;
        }

        pGroupID = pNext;
    }

    WriteDebug( L"Finished adding application dependencies for '%s'.\r\n",
                g_strAppName.QueryStr() );

    //
    // If we're going to throw caution to the wind and enable
    // every extension and dependency of this application
    // (regardless of whether the administrator disabled it for
    // a good reason), do so now.
    //

    if ( _wcsicmp( g_strHonorDisabled.QueryStr(), L"false" ) == 0)
    {
        WriteDebug( L"Enabling all dependencies of '%s'.  Please "
                    L"review the IIS lockdown status.\r\n",
                    g_strAppName.QueryStr() );

        hr = SecHelper.EnableApplication( g_strAppName.QueryStr(),
                                          L"/LM/w3svc" );

        if ( FAILED( hr ) )
        {
            //
            // This error is not fatal, but should be reported.
            //

            WriteDebug( L"  Error %d occurred enabling dependencies of '%s'.\r\n",
                        hr,
                        g_strAppName.QueryStr() );
        }
    }

    return S_OK;
}

HRESULT
RemoveExtensionsFromMetabase(
    VOID
    )
{
    LIST_ENTRY *        ple;
    EXTENSION_IMAGE *   pImage;
    HRESULT             hr;

    DBG_ASSERT( g_pMetabase );

    CSecConLib  SecHelper( g_pMetabase );

    WriteDebug( L"Removing extensions for '%s' from the metabase "
                L"WebSvcExtRestrictionList entry.\r\n",
                g_strAppName.QueryStr() );

    ple = g_Head.Flink;

    while ( ple != &g_Head )
    {
        pImage = CONTAINING_RECORD( ple,
                                    EXTENSION_IMAGE,
                                    le );

        if ( IsExtensionInMetabase( pImage->strPath.QueryStr() ) )
        {
            WriteDebug( L"  Removing '%s'...\r\n",
                        pImage->strPath.QueryStr() );

            hr = SecHelper.DeleteExtensionFileRecord( pImage->strPath.QueryStr(),
                                                      L"/LM/w3svc" );

            //
            // Don't consider 0x800cc801 (MD_ERROR_DATA_NOT_FOUND)
            // an error.
            //

            if ( hr == 0x800cc801 )
            {
                hr = S_OK;
            }

            if ( FAILED( hr ) )
            {
                //
                // A failure here shouldn't be fatal,
                // but we'll dump some debugger output for it
                //

                WriteDebug( L"    Error 0x%08x occurred removing '%s' from "
                            L"WebSvcExtRestrictionList.\r\n",
                            hr,
                            pImage->strPath.QueryStr() );

            }
        }
        else
        {
            WriteDebug( L"  Skipping '%s' because it was not listed.\r\n",
                        pImage->strPath.QueryStr() );
        }

        ple = ple->Flink;
    }

    WriteDebug( L"Finished removing extensions for '%s' from the metabase.\r\n",
                g_strAppName.QueryStr() );

    return S_OK;
}

HRESULT
RemoveDependenciesFromMetabase(
    VOID
    )
{
    HRESULT hr;

    DBG_ASSERT( g_pMetabase );

    CSecConLib  SecHelper( g_pMetabase );

    WriteDebug( L"Removing dependencies for '%s' from the metabase "
                L"ApplicationDependencies entry.\r\n",
                g_strAppName.QueryStr() );

    hr = SecHelper.RemoveApplication( g_strAppName.QueryStr(),
                                      L"/LM/w3svc" );

    //
    // Don't consider 0x800cc801 (MD_ERROR_DATA_NOT_FOUND)
    // to be an error
    //

    if ( hr == 0x800cc801 )
    {
        hr = S_OK;
    }

    if ( FAILED( hr ) )
    {
        WriteDebug( L"  Error 0x%08x occurred removing '%s' from "
                    L"ApplicationDependencies.\r\n",
                    hr,
                    g_strAppName.QueryStr() );
    }

    WriteDebug( L"Finished removing application dependencies for '%s'.\r\n",
                g_strAppName.QueryStr() );

    return hr;
}

BOOL
IsExtensionInMetabase(
    LPWSTR  szImagePath
    )
{
    HRESULT hr;
    DWORD   cbData;
    LPWSTR  pExtensionList = NULL;
    LPWSTR  pCursor;
    BOOL    fRet = FALSE;

    DBG_ASSERT( g_pMetabase );

    CSecConLib  SecHelper( g_pMetabase );

    hr = SecHelper.ListExtensionFiles( L"/LM/w3svc",
                                             &pExtensionList,
                                             &cbData );

    if ( FAILED( hr ) )
    {
        WriteDebug( L"Error 0x%08x occurred reading WebSvcExtRestrictionList "
                    L"from metabase.\r\n",
                    hr );
        //
        // If we fail to get the list, assume that
        // the extension is on it.
        //

        fRet = TRUE;

        goto Finished;
    }

    //
    // Walk the list
    //

    pCursor = pExtensionList;

    while ( pCursor && *pCursor != L'\0' )
    {
        if ( _wcsicmp( pCursor, szImagePath ) == NULL )
        {
            fRet = TRUE;
            goto Finished;
        }

        pCursor += wcslen( pCursor ) + 1;
    }

Finished:

    if ( pExtensionList )
    {
        delete [] pExtensionList;
        pExtensionList = NULL;
    }

    return fRet;
}

BOOL
DoesFileExist(
    LPWSTR szImagePath
    )
{
    return ( GetFileAttributesW( szImagePath ) != 0xffffffff );
}

VOID
WriteDebug(
    LPWSTR   szFormat,
    ...
    )
{
    WCHAR   szBuffer[WRITE_BUFFER_SIZE];
    LPWSTR  pCursor;
    DWORD   cbToWrite;
    INT     nWritten;
    va_list args;

    if ( WRITE_BUFFER_SIZE < 3 )
    {
        //
        // This is just too small to deal with...
        //

        return;
    }

    //
    // Inject the module name tag into the buffer
    //

    nWritten = _snwprintf( szBuffer,
                           WRITE_BUFFER_SIZE,
                           L"[AcWebSvc.dll] " );

    if ( nWritten == -1 )
    {
        return;
    }

    pCursor = szBuffer + nWritten;
    cbToWrite = WRITE_BUFFER_SIZE - nWritten;

    va_start( args, szFormat );

    nWritten = _vsnwprintf( pCursor,
                            cbToWrite,
                            szFormat,
                            args );

    va_end( args );

    if ( nWritten == -1 )
    {
        szBuffer[WRITE_BUFFER_SIZE-3] = '\r';
        szBuffer[WRITE_BUFFER_SIZE-2] = '\n';
    }

    szBuffer[WRITE_BUFFER_SIZE-1] = '\0';

    OutputDebugString( szBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\lkrhash.cpp ===
/*++

   Copyright    (c) 1997-2002    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       LKRhash: a fast, scalable, cache- and MP-friendly hash table
       Constructors, destructors, _Clear(), and _SetSegVars.

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Project:
       LKRhash

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash
       10/2000    - Refactor, port to kernel mode

--*/

#include "precomp.hxx"


#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <lkrhash.h>

#include "i-LKRhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR              pszClassName,   // Identifies subtable for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Upperbound on average chain length
    DWORD               initsize,       // Initial size of hash subtable.
    DWORD             /*num_subtbls*/,  // for compatiblity with CLKRHashTable
    bool                fMultiKeys,     // Allow multiple identical keys?
    bool                fUseLocks       // Must use locks
#ifdef LKRHASH_KERNEL_MODE
  , bool                fNonPagedAllocs // use paged or NP pool
#endif
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(static_cast<BYTE>(TableLock::LockType())),
      m_nBucketLockType(static_cast<BYTE>(BucketLock::LockType())),
      m_phtParent(NULL),    // directly created, no owning table
      m_iParentIndex(INVALID_PARENT_INDEX),
      m_fMultiKeys(fMultiKeys),
      m_fUseLocks(fUseLocks),
#ifdef LKRHASH_KERNEL_MODE
      m_fNonPagedAllocs(fNonPagedAllocs)
#else
      m_fNonPagedAllocs(false)
#endif
{
#ifndef LOCK_INSTRUMENTATION
//  STATIC_ASSERT(1 <= LK_DFLT_MAXLOAD  && LK_DFLT_MAXLOAD <= NODES_PER_CLUMP);
#endif // !LOCK_INSTRUMENTATION

    STATIC_ASSERT(0 < NODES_PER_CLUMP  &&  NODES_PER_CLUMP < 255);
    STATIC_ASSERT(0 <= NODE_BEGIN  &&  NODE_BEGIN < NODES_PER_CLUMP);
    STATIC_ASSERT(!(0 <= NODE_END  &&  NODE_END < NODES_PER_CLUMP));
    STATIC_ASSERT(NODE_STEP == +1  ||  NODE_STEP == -1);
    STATIC_ASSERT(NODE_END - NODE_BEGIN == NODE_STEP * NODES_PER_CLUMP);

    LK_RETCODE lkrc = _Initialize(pfnExtractKey, pfnCalcKeyHash,
                                  pfnCompareKeys, pfnAddRefRecord,
                                  pszClassName, maxload, initsize);

    if (LK_SUCCESS != lkrc)
        IRTLASSERT(! "_Initialize failed");

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR              pszClassName,   // Identifies subtable for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Upperbound on average chain length
    DWORD               initsize,       // Initial size of hash subtable.
    CLKRHashTable*      phtParent,      // Owning table.
    int                 iParentIndex,   // index within parent table
    bool                fMultiKeys,     // Allow multiple identical keys?
    bool                fUseLocks,      // Must use locks
    bool                fNonPagedAllocs // use paged or NP pool
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(static_cast<BYTE>(TableLock::LockType())),
      m_nBucketLockType(static_cast<BYTE>(BucketLock::LockType())),
      m_phtParent(phtParent),
      m_iParentIndex((BYTE) iParentIndex),
      m_fMultiKeys(fMultiKeys),
      m_fUseLocks(fUseLocks),
      m_fNonPagedAllocs(fNonPagedAllocs)
{
    IRTLASSERT(m_phtParent != NULL);

    LK_RETCODE lkrc = _Initialize(pfnExtractKey, pfnCalcKeyHash,
                                  pfnCompareKeys, pfnAddRefRecord,
                                  pszClassName, maxload, initsize);

    if (LK_SUCCESS != lkrc)
        IRTLASSERT(! "_Initialize failed");

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    LKR_PFnExtractKey   pfnExtractKey,
    LKR_PFnCalcKeyHash  pfnCalcKeyHash,
    LKR_PFnCompareKeys  pfnCompareKeys,
    LKR_PFnAddRefRecord pfnAddRefRecord,
    LPCSTR              pszClassName,
    unsigned            maxload,
    DWORD               initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask0 =  0;
    m_dwBktAddrMask1 =  0;
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_nSegBits =        0;
    m_nSegSize =        0;
    m_nSegMask =        0;
    m_lkrcState =       LK_UNUSABLE;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnCompareKeys =  pfnCompareKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;
    m_fSealed =         false;
    m_pvReserved1     = 0;
    m_pvReserved2     = 0;
    m_pvReserved3     = 0;
    m_pvReserved4     = 0;

    INIT_ALLOC_STAT(SegDir);
    INIT_ALLOC_STAT(Segment);
    INIT_ALLOC_STAT(NodeClump);

    INIT_OP_STAT(InsertRecord);
    INIT_OP_STAT(FindKey);
    INIT_OP_STAT(FindRecord);
    INIT_OP_STAT(DeleteKey);
    INIT_OP_STAT(DeleteRecord);
    INIT_OP_STAT(FindKeyMultiRec);
    INIT_OP_STAT(DeleteKeyMultiRec);
    INIT_OP_STAT(Expand);
    INIT_OP_STAT(Contract);
    INIT_OP_STAT(LevelExpansion);
    INIT_OP_STAT(LevelContraction);
    INIT_OP_STAT(ApplyIf);
    INIT_OP_STAT(DeleteIf);

    strncpy(m_szName, pszClassName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnCompareKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(g_fLKRhashInitialized);

    if (!g_fLKRhashInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnCompareKeys == NULL
            || m_pfnAddRefRecord == NULL)
    {
        return (m_lkrcState = LK_BAD_PARAMETERS);
    }

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = static_cast<BYTE>( min( max(1, maxload),
                                        min(255, 60 * NODES_PER_CLUMP)
                                        )
                                 );

    // Choose the size of the segments according to the desired "size" of
    // the subtable, small, medium, or large.
    LK_TABLESIZE lkts;

    if (initsize == LK_SMALL_TABLESIZE)
    {
        lkts = LK_SMALL_TABLESIZE;
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        lkts = LK_MEDIUM_TABLESIZE;
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        lkts = LK_LARGE_TABLESIZE;
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE  <= initsize <=  MAX_DIRSIZE * Large::INITSIZE
        initsize = min( max(initsize, CSmallSegment::INITSIZE),
                        (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE );

        // Guess a subtable size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            lkts = LK_SMALL_TABLESIZE;
        else if (initsize >= CLargeSegment::INITSIZE)
            lkts = LK_LARGE_TABLESIZE;
        else
            lkts = LK_MEDIUM_TABLESIZE;
    }

    return _SetSegVars(lkts, initsize);
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR              pszClassName,   // Identifies table for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnCompareKeys  pfnCompareKeys, // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Bound on the average chain length
    DWORD               initsize,       // Initial size of hash table.
    DWORD               num_subtbls,    // Number of subordinate hash tables.
    bool                fMultiKeys,     // Allow multiple identical keys?
    bool                fUseLocks       // Must use locks
#ifdef LKRHASH_KERNEL_MODE
  , bool                fNonPagedAllocs // use paged or NP pool
#endif
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    STATIC_ASSERT(MAX_LKR_SUBTABLES < INVALID_PARENT_INDEX);

    strncpy(m_szName, pszClassName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    _InsertThisIntoGlobalList();

    INIT_ALLOC_STAT(SubTable);

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnCompareKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnCompareKeys == NULL
            || pfnAddRefRecord == NULL)
    {
        return;
    }

    if (!g_fLKRhashInitialized)
    {
        m_lkrcState = LK_NOT_INITIALIZED;
        return;
    }

#ifndef LKRHASH_KERNEL_MODE
    bool         fNonPagedAllocs = false;
#endif
    LK_TABLESIZE lkts            = NumSubTables(initsize, num_subtbls);

#ifdef IRTLDEBUG
    int cBuckets = initsize;

    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = CLargeSegment::INITSIZE;

    IRTLTRACE(TEXT("CLKRHashTable, %p, %s: ")
              TEXT("%s, %d subtables, initsize = %d, ")
              TEXT("total #buckets = %d\n"),
              this, m_szName,
              ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
               (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
              num_subtbls, initsize, cBuckets * num_subtbls);
#else  // !IRTLDEBUG
    UNREFERENCED_PARAMETER(lkts);
#endif // !IRTLDEBUG

    m_lkrcState = LK_ALLOC_FAIL;

    m_cSubTables = num_subtbls;
    IRTLASSERT(1 <= m_cSubTables  &&  m_cSubTables <= MAX_LKR_SUBTABLES);

    DWORD i;
    
    for (i = 0;  i < m_cSubTables;  ++i)
        m_palhtDir[i] = NULL;

    for (i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i] = _AllocateSubTable(m_szName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnCompareKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this, i, fMultiKeys,
                                          fUseLocks, fNonPagedAllocs);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            m_cSubTables = 0;

            IRTLASSERT(! LKR_SUCCEEDED(m_lkrcState));
            return;
        }
    }

    m_nSubTableMask = m_cSubTables - 1;

    // Is m_cSubTables a power of 2? This calculation works even for
    // m_cSubTables == 1 ( == 2^0).
    if ((m_nSubTableMask & m_cSubTables) != 0)
        m_nSubTableMask = -1; // No, see CLKRHashTable::_SubTable()

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the subtable
    WriteLock();
    _Clear(false);

    _RemoveThisFromGlobalList();

    VALIDATE_DUMP_ALLOC_STAT(SegDir);
    VALIDATE_DUMP_ALLOC_STAT(Segment);
    VALIDATE_DUMP_ALLOC_STAT(NodeClump);

    DUMP_OP_STAT(InsertRecord);
    DUMP_OP_STAT(FindKey);
    DUMP_OP_STAT(FindRecord);
    DUMP_OP_STAT(DeleteKey);
    DUMP_OP_STAT(DeleteRecord);
    DUMP_OP_STAT(FindKeyMultiRec);
    DUMP_OP_STAT(DeleteKeyMultiRec);
    DUMP_OP_STAT(Expand);
    DUMP_OP_STAT(Contract);
    DUMP_OP_STAT(LevelExpansion);
    DUMP_OP_STAT(LevelContraction);
    DUMP_OP_STAT(ApplyIf);
    DUMP_OP_STAT(DeleteIf);

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState   = LK_UNUSABLE; // so IsUsable will fail

    WriteUnlock();
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // Must delete the subtables in forward order (unlike
    // delete[], which starts at the end and moves backwards) to
    // prevent possibility of deadlock by acquiring the subtable
    // locks in a different order from the rest of the code.
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
        _FreeSubTable(m_palhtDir[i]);

    _RemoveThisFromGlobalList();

    VALIDATE_DUMP_ALLOC_STAT(SubTable);

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState   = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the subtable
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(this->IsWriteLocked());

    // If we're Clear()ing the table AND the table has no records, we
    // can return immediately. The dtor, however, must clean up completely.
    if (fShrinkDirectory  &&  0 == m_cRecords)
        return;

#ifdef IRTLDEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // IRTLDEBUG

    const LK_ADDREF_REASON lkar = (fShrinkDirectory
                                   ?  LKAR_CLEAR
                                   :  LKAR_LKR_DTOR);

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        PBucket const pbkt = _BucketFromAddress(iBkt);

        IRTLASSERT(pbkt != NULL);

        if (_UseBucketLocking())
            pbkt->WriteLock();

        IRTLASSERT(0 == _IsBucketChainCompact(pbkt));

        PNodeClump pncCurr = &pbkt->m_ncFirst;

        while (pncCurr != NULL)
        {
            FOR_EACH_NODE_DECL(iNode)
            {
                if (pncCurr->IsEmptySlot(iNode))
                {
                    IRTLASSERT(pncCurr->NoMoreValidSlots(iNode));
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[iNode], lkar);
#ifdef IRTLDEBUG
                    pncCurr->m_pvNode[iNode]    = NULL;
                    pncCurr->m_dwKeySigs[iNode] = HASH_INVALID_SIGNATURE;
                    ++cDeleted;
#endif // IRTLDEBUG
                    --m_cRecords;
                }
            }

            PNodeClump const pncPrev = pncCurr;

            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
        } // while (pncCurr ...

        if (_UseBucketLocking())
            pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all segments
    for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_nSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    _FreeSegmentDirectory();

    m_cActiveBuckets = 0;
    m_iExpansionIdx  = 0;
    m_nLevel         = 0;
    m_dwBktAddrMask0 = 0;
    m_dwBktAddrMask1 = 0;

    // set directory of segments to minimum size
    if (fShrinkDirectory)
    {
        DWORD cInitialBuckets = 0;

        if (LK_SMALL_TABLESIZE == m_lkts)
            cInitialBuckets = CSmallSegment::INITSIZE;
        else if (LK_MEDIUM_TABLESIZE == m_lkts)
            cInitialBuckets = CMediumSegment::INITSIZE;
        else if (LK_LARGE_TABLESIZE == m_lkts)
            cInitialBuckets = CLargeSegment::INITSIZE;
        else
            IRTLASSERT(! "Unknown LK_TABLESIZE");

        _SetSegVars((LK_TABLESIZE) m_lkts, cInitialBuckets);
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
    {
        m_palhtDir[i]->WriteLock();
        m_palhtDir[i]->_Clear(true);
        m_palhtDir[i]->WriteUnlock();
    }
} // CLKRHashTable::Clear



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts,
    DWORD        cInitialBuckets)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
      {
        m_lkts     = LK_SMALL_TABLESIZE;
        m_nSegBits = CSmallSegment::SEGBITS;
        m_nSegSize = CSmallSegment::SEGSIZE;
        m_nSegMask = CSmallSegment::SEGMASK;

        STATIC_ASSERT(1 < CSmallSegment::SEGBITS
                      &&  CSmallSegment::SEGBITS < 16);
        STATIC_ASSERT(CSmallSegment::SEGSIZE == (1U<<CSmallSegment::SEGBITS));
        STATIC_ASSERT(CSmallSegment::SEGMASK == (CSmallSegment::SEGSIZE-1));
        break;
      }
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
      {
        m_lkts     = LK_MEDIUM_TABLESIZE;
        m_nSegBits = CMediumSegment::SEGBITS;
        m_nSegSize = CMediumSegment::SEGSIZE;
        m_nSegMask = CMediumSegment::SEGMASK;

        STATIC_ASSERT(1 < CMediumSegment::SEGBITS
                      &&  CMediumSegment::SEGBITS < 16);
        STATIC_ASSERT(CSmallSegment::SEGBITS < CMediumSegment::SEGBITS
                      &&  CMediumSegment::SEGBITS < CLargeSegment::SEGBITS);
        STATIC_ASSERT(CMediumSegment::SEGSIZE ==(1U<<CMediumSegment::SEGBITS));
        STATIC_ASSERT(CMediumSegment::SEGMASK == (CMediumSegment::SEGSIZE-1));
        break;
      }
        
    case LK_LARGE_TABLESIZE:
      {
        m_lkts     = LK_LARGE_TABLESIZE;
        m_nSegBits = CLargeSegment::SEGBITS;
        m_nSegSize = CLargeSegment::SEGSIZE;
        m_nSegMask = CLargeSegment::SEGMASK;

        STATIC_ASSERT(1 < CLargeSegment::SEGBITS
                      &&  CLargeSegment::SEGBITS < 16);
        STATIC_ASSERT(CLargeSegment::SEGSIZE == (1U<<CLargeSegment::SEGBITS));
        STATIC_ASSERT(CLargeSegment::SEGMASK == (CLargeSegment::SEGSIZE-1));
        break;
      }
    }

    m_dwBktAddrMask0 = m_nSegMask;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    m_nLevel         = m_nSegBits;
    m_cActiveBuckets = max(m_nSegSize, cInitialBuckets);

    IRTLASSERT(m_cActiveBuckets > 0);

    IRTLASSERT(m_nLevel == m_nSegBits);
    IRTLASSERT(m_dwBktAddrMask0 == ((1U << m_nLevel) - 1));
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));

    IRTLASSERT(m_nSegBits > 0);
    IRTLASSERT(m_nSegSize == (1U << m_nSegBits));
    IRTLASSERT(m_nSegMask == (m_nSegSize - 1));
    IRTLASSERT(m_dwBktAddrMask0 == m_nSegMask);

    // Adjust m_dwBktAddrMask0 (== m_nSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_nSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
    }

    IRTLASSERT(m_dwBktAddrMask0 == ((1U << m_nLevel) - 1));
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;

    // create and clear directory of segments
    DWORD cDirSegs = MIN_DIRSIZE;
    while (cDirSegs < (m_cActiveBuckets >> m_nSegBits))
        cDirSegs <<= 1;

    cDirSegs = min(cDirSegs, MAX_DIRSIZE);
    IRTLASSERT((cDirSegs << m_nSegBits) >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(cDirSegs);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = cDirSegs;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_nSegSize - 1) >> m_nSegBits;
        IRTLASSERT(dwMaxSegs <= m_cDirSegs);

#if 0
        IRTLTRACE(TEXT("LKR_SetSegVars: m_lkts = %d, m_cActiveBuckets = %lu, ")
                  TEXT("m_nSegSize = %lu, bits = %lu\n")
                  TEXT("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
                  TEXT("segment total size = %lu bytes\n"),
                  m_lkts, m_cActiveBuckets,
                  m_nSegSize, m_nSegBits,
                  m_cDirSegs, dwMaxSegs,
                  m_nSegSize * sizeof(CBucket));
#endif

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  ++i)
        {
            PSegment pSeg = _AllocateSegment();

            if (pSeg != NULL)
            {
                m_paDirSegs[i] = pSeg;
            }
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;

                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j]);
                    m_paDirSegs[j] = NULL;
                }

                _FreeSegmentDirectory();
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs = NULL;
        m_cDirSegs  = m_cActiveBuckets = m_iExpansionIdx = 0;

        // Propagate error back up to parent (if it exists). This ensures
        // that all of the parent's public methods will start failing.
        if (NULL != m_phtParent)
            m_phtParent->m_lkrcState = m_lkrcState;
    }

    return m_lkrcState;
} // CLKRLinearHashTable::_SetSegVars



#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\lkrhash\src\locks.cpp ===
/*++

   Copyright    (c)    1997-2002    Microsoft Corporation

   Module  Name :
       Locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/


#include "precomp.hxx"

#ifndef LIB_IMPLEMENTATION
# define DLL_IMPLEMENTATION
# define IMPLEMENTATION_EXPORT
#endif // !LIB_IMPLEMENTATION

#include <Locks.h>
#include "i-Locks.h"


// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a i386 (unlikely
// in 2002), you'll need to use something else.


// Lock_AtomicIncrement is equivalent to
//      LONG lNew = +1 + *plAddend;
//      *plAddend = lNew;
// except it's one atomic operation
LOCK_NAKED
LOCK_ATOMIC_INLINE
void
LOCK_FASTCALL
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifndef LOCK_ASM
    ::InterlockedIncrement(plAddend);
#elif defined(_M_IX86)
    UNREFERENCED_PARAMETER(plAddend);       // for /W4
    IRTLASSERT(plAddend != NULL);
    // ecx = plAddend
    __asm
    {
;            mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
;            inc        eax                 // correct result (ignored)
    }
#endif // _M_IX86
}


// Lock_AtomicDecrement is equivalent to
//      LONG lNew = -1 + *plAddend;
//      *plAddend = lNew;
// except it's one atomic operation
LOCK_NAKED
LOCK_ATOMIC_INLINE
void
LOCK_FASTCALL
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifndef LOCK_ASM
    ::InterlockedDecrement(plAddend);
#elif defined(_M_IX86)
    UNREFERENCED_PARAMETER(plAddend);
    IRTLASSERT(plAddend != NULL);
    // ecx = plAddend
    __asm
    {
;            mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
;            dec        eax                 // correct result (ignored)
    }
#endif // _M_IX86
}


// Lock_AtomicExchange is equivalent to
//      LONG lOld = *plAddr;
//      *plAddr = lNew;
//      return lOld;
// except it's one atomic operation
LOCK_NAKED
LOCK_ATOMIC_INLINE
LONG
LOCK_FASTCALL
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifndef LOCK_ASM
    return ::InterlockedExchange(plAddr, lNew);
#elif defined(_M_IX86)
    UNREFERENCED_PARAMETER(plAddr);
    UNREFERENCED_PARAMETER(lNew);
    IRTLASSERT(plAddr != NULL);
    // ecx = plAddr, edx = lNew
    __asm
    {
;            mov        ecx,    plAddr
;            mov        edx,    lNew
;            mov        eax,    [ecx]
;   LAEloop:
;       lock cmpxchg    [ecx],  edx
;            jnz        LAEloop

;       lock xchg       [ecx],  edx
;            mov        eax,    edx

    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#endif // _M_IX86
}


// Lock_AtomicCompareAndSwap is equivalent to
//      if (*plAddr == lCurrent)
//          *plAddr = lNew;
//          return true;
//      else
//          return false;
// except it's one atomic operation
LOCK_NAKED
LOCK_ATOMIC_INLINE
bool
LOCK_FASTCALL
Lock_AtomicCompareAndSwap(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifndef LOCK_ASM
# if defined(UNDER_CE)
    return ::InterlockedTestExchange(plAddr, lCurrent, lNew) == lCurrent;
# else
    return ::InterlockedCompareExchange(plAddr, lNew, lCurrent) == lCurrent;
# endif
#elif defined(_M_IX86)
    UNREFERENCED_PARAMETER(plAddr);
    UNREFERENCED_PARAMETER(lNew);
    UNREFERENCED_PARAMETER(lCurrent);
    IRTLASSERT(plAddr != NULL);
    // ecx = plAddr, edx = lNew
    __asm
    {
;            mov        ecx,    plAddr
;            mov        edx,    lNew
;            mov        eax,    lCurrent

             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
             sete       al          // eax==1 => successfully swapped; else =0
    }
#endif // _M_IX86
}


LOCK_FORCEINLINE
DWORD
Lock_GetCurrentThreadId()
{
#ifdef LOCKS_KERNEL_MODE
    return (DWORD) HandleToULong(::PsGetCurrentThreadId());
#elif 1 // !defined(LOCK_ASM)
    return ::GetCurrentThreadId();
#elif defined(_M_IX86)
    const unsigned int PcTeb = 0x18;
    const unsigned int IDTeb = 0x24;
    
    __asm
    {
        mov		eax,fs:[PcTeb]				// Load TEB base address.
        mov		eax,dword ptr[eax+IDTeb]	// Load thread ID.
    }
#endif // _M_IX86
}


#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette (Pentium 4) processors for Hyper-Threading.
# define Lock_Pause()    __asm { rep nop }
#else  // !_M_IX86
# define Lock_Pause()    ((void) 0)
#endif // !_M_IX86


//------------------------------------------------------------------------
// Not all Win32 platforms support all the functions we want. Set up dummy
// thunks and use GetProcAddress to find their addresses at runtime.

#ifndef LOCKS_KERNEL_MODE

typedef
BOOL
(WINAPI * PFN_SWITCH_TO_THREAD)(
    VOID
    );

static BOOL WINAPI
FakeSwitchToThread(
    VOID)
{
    return FALSE;
}

PFN_SWITCH_TO_THREAD  g_pfnSwitchToThread = NULL;


typedef
BOOL
(WINAPI * PFN_TRY_ENTER_CRITICAL_SECTION)(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

static BOOL WINAPI
FakeTryEnterCriticalSection(
    LPCRITICAL_SECTION /*lpCriticalSection*/)
{
    return FALSE;
}

PFN_TRY_ENTER_CRITICAL_SECTION g_pfnTryEnterCritSec = NULL;


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;

#else  // LOCKS_KERNEL_MODE

// ZwYieldExecution is the actual kernel-mode implementation of SwitchToThread.
extern "C"
NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );

#endif // LOCKS_KERNEL_MODE


void
CSimpleLock::Enter()
{
    while (Lock_AtomicExchange(const_cast<LONG*>(&m_l), 1) != 0)
    {
#ifdef LOCKS_KERNEL_MODE
        ZwYieldExecution();
#else // !LOCKS_KERNEL_MODE
        Sleep(0);
#endif // !LOCKS_KERNEL_MODE
    }
}

void
CSimpleLock::Leave()
{
    Lock_AtomicExchange(const_cast<LONG*>(&m_l), 0);
}


DWORD g_cProcessors = 0;
BOOL  g_fLocksInitialized = FALSE;
CSimpleLock g_lckLocksInit;



BOOL
Locks_Initialize()
{
    if (!g_fLocksInitialized)
    {
        g_lckLocksInit.Enter();
    
        if (! g_fLocksInitialized)
        {
#if defined(LOCKS_KERNEL_MODE)

            g_cProcessors = KeNumberProcessors;

#else  // !LOCKS_KERNEL_MODE

# if !defined(UNDER_CE)
            // load kernel32 and get NT-specific entry points
            HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

            if (hKernel32 != NULL)
            {
                g_pfnSwitchToThread = (PFN_SWITCH_TO_THREAD)
                    GetProcAddress(hKernel32, "SwitchToThread");
                
                g_pfnTryEnterCritSec = (PFN_TRY_ENTER_CRITICAL_SECTION)
                    GetProcAddress(hKernel32, "TryEnterCriticalSection");
                
                g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(hKernel32, "SetCriticalSectionSpinCount");
            }
# endif // !UNDER_CE
            
            if (g_pfnSwitchToThread == NULL)
                g_pfnSwitchToThread = FakeSwitchToThread;
            
            if (g_pfnTryEnterCritSec == NULL)
                g_pfnTryEnterCritSec = FakeTryEnterCriticalSection;
            
            if (g_pfnSetCSSpinCount == NULL)
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;

            SYSTEM_INFO si;

            GetSystemInfo(&si);
            g_cProcessors = si.dwNumberOfProcessors;
            
#endif // !LOCKS_KERNEL_MODE

            IRTLASSERT(g_cProcessors > 0);

            Lock_AtomicExchange((LONG*) &g_fLocksInitialized, TRUE);
        }
        
        g_lckLocksInit.Leave();
    }

    return TRUE;
}


BOOL
Locks_Cleanup()
{
    return TRUE;
}



#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION

 #define LOCK_DEFAULT_SPIN_DATA(CLASS)                      \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5

 #define DefaultSpinCount()     sm_wDefaultSpinCount
 #define AdjustBySpinFactor(x)  (int) ((x) * sm_dblDfltSpinAdjFctr)

#else  // !LOCK_DEFAULT_SPIN_IMPLEMENTATION

 #define LOCK_DEFAULT_SPIN_DATA(CLASS)
 #define DefaultSpinCount()     LOCK_DEFAULT_SPINS
 #define AdjustBySpinFactor(x)  ((x) >> 1)

#endif  // !LOCK_DEFAULT_SPIN_IMPLEMENTATION


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    _tcscpy(ls.m_tszName, m_tszName);                           \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters. We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()

#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

LONG
RandomBackoffFactor(
    LONG cBaseSpins)
{
    static const int s_aFactors[] = {
        // 64ths of cBaseSpin
        +2, -3, -5, +6, +3, +1, -4, -1, -2, +8, -7,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
#ifdef LOCKS_KERNEL_MODE
    DWORD nRand = (DWORD) HandleToULong(::PsGetCurrentThreadId());
#else // !LOCKS_KERNEL_MODE
    DWORD nRand = ::GetCurrentThreadId();
#endif // !LOCKS_KERNEL_MODE

    return cBaseSpins  +  (s_aFactors[nRand % nFactors] * (cBaseSpins >> 6));
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: If possible, yields the thread with SwitchToThread.
//           If that doesn't work, calls Sleep.
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
    // TODO: check global and per-class flags to see if we should
    // sleep at all.
    
#ifdef LOCKS_KERNEL_MODE
    // If we're running at DISPATCH_LEVEL or higher, the scheduler won't
    // run, so other threads won't run on this processor, and the only
    // appropriate action is to keep on spinning
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
        return;

    // Use KeDelayExecutionThread?

    ZwYieldExecution();

    // BTW, Sleep is implemented in terms of NtDelayExecution

#else // !LOCKS_KERNEL_MODE

# ifdef LOCKS_SWITCH_TO_THREAD
    if (!g_pfnSwitchToThread())
# endif
        Sleep(dwSleepMSec);
#endif // !LOCKS_KERNEL_MODE
}
    



//------------------------------------------------------------------------
// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



//------------------------------------------------------------------------
// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);
LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);


LOCK_FORCEINLINE
LONG
CSmallSpinLock::_CurrentThreadId()
{
#ifdef LOCK_SMALL_SPIN_NO_THREAD_ID
    DWORD dwTid = SL_LOCKED;
#else  // !LOCK_SMALL_SPIN_NO_THREAD_ID
#ifdef LOCKS_KERNEL_MODE
    DWORD dwTid = (DWORD) HandleToULong(::PsGetCurrentThreadId());
#else // !LOCKS_KERNEL_MODE
    DWORD dwTid = ::GetCurrentThreadId();
#endif // !LOCKS_KERNEL_MODE
#endif // !LOCK_SMALL_SPIN_NO_THREAD_ID
    return (LONG) (dwTid);
}

//------------------------------------------------------------------------
// Function: CSmallSpinLock::_TryLock
// Synopsis: Attempt to acquire the lock
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CSmallSpinLock::_TryLock()
{
    if (m_lTid == SL_UNOWNED)
    {
        const LONG lTid = _CurrentThreadId();
        
        return (Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lTid),
                                          lTid, SL_UNOWNED));
    }
    else
        return false;
}



//------------------------------------------------------------------------
// Function: CSmallSpinLock::_Unlock
// Synopsis: Release the lock
//------------------------------------------------------------------------

LOCK_FORCEINLINE
void
CSmallSpinLock::_Unlock()
{
    Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), SL_UNOWNED);
}



//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = DefaultSpinCount();
    LONG  cBaseSpins2 = RandomBackoffFactor(cBaseSpins);

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        IRTLASSERT(! "CSmallSpinLock: Illegally attempted to acquire "
                     "lock recursively => deadlock!");
#ifdef LOCKS_KERNEL_MODE
            DbgBreakPoint();
#else  // !LOCKS_KERNEL_MODE
            DebugBreak();
#endif // !LOCKS_KERNEL_MODE
    }

    while (! Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lTid),
                                       _CurrentThreadId(), SL_UNOWNED))
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif
                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = AdjustBySpinFactor(cBaseSpins2);

                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion. Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run. If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock. NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable. If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU. We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~1,000,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...

                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Pause();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif
            SwitchOrSleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

    LOCK_INSTRUMENTATION_EPILOG();
} // CSmallSpinLock::_LockSpin()



//------------------------------------------------------------------------
// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_TryLock
// Synopsis: Attempt to acquire the lock without blocking
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CSpinLock::_TryLock()
{
    if (m_lTid == SL_UNOWNED)
    {
        LONG lTid = _CurrentThreadId() | SL_OWNER_INCR;
        
        return (Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lTid),
                                          lTid, SL_UNOWNED));
    }
    else
        return false;
}


//------------------------------------------------------------------------
// Function: CSpinLock::_Lock
// Synopsis: Acquire the lock, recursively if need be
//------------------------------------------------------------------------

void
CSpinLock::_Lock()
{
    // Do we own the lock already?  Just bump the count.
    if (_IsLocked())
    {
        // owner count isn't maxed out?
        IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);
        
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                            m_lTid + SL_OWNER_INCR);
    }
    
    // Some other thread owns the lock. We'll have to spin :-(.
    else
        _LockSpin();
    
    IRTLASSERT((m_lTid & SL_OWNER_MASK) > 0
               &&  (m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
}


//------------------------------------------------------------------------
// Function: CSpinLock::_Unlock
// Synopsis: Release the lock.
//------------------------------------------------------------------------

void
CSpinLock::_Unlock()
{
    IRTLASSERT((m_lTid & SL_OWNER_MASK) > 0
               &&  (m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
    
    LONG lTid = m_lTid - SL_OWNER_INCR; 
    
    // Last owner?  Release completely, if so
    if ((lTid & SL_OWNER_MASK) == 0)
        lTid = SL_UNOWNED;
    
    Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lTid);
}


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = RandomBackoffFactor(DefaultSpinCount());
    const LONG lTid = _CurrentThreadId() | SL_OWNER_INCR;

    while (! fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  DefaultSpinCount() != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = AdjustBySpinFactor(cBaseSpins);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Pause();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lTid),
                                      lTid, SL_UNOWNED))
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT(_IsLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifndef LOCKS_KERNEL_MODE

//------------------------------------------------------------------------
// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);


bool
CCritSec::TryWriteLock()
{
    IRTLASSERT(g_pfnTryEnterCritSec != NULL);
    return g_pfnTryEnterCritSec(&m_cs) ? true : false;
}


//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    IRTLASSERT(g_pfnSetCSSpinCount != NULL);
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}

#endif // !LOCKS_KERNEL_MODE



//------------------------------------------------------------------------
// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


//------------------------------------------------------------------------
// Function: CReaderWriterLock::_CmpExch
// Synopsis: _CmpExch is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock::_CmpExch(
    LONG lNew,
    LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_nState),
                                     lNew, lCurrent);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::_TryWriteLock
// Synopsis: Try to acquire the lock exclusively.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock::_TryWriteLock()
{
    return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::_TryReadLock
// Synopsis: Try to acquire the lock shared.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock::_TryReadLock()
{
    LONG nCurrState = m_nState;
    
    // Give writers priority
    return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
            &&  _CmpExch(nCurrState + 1, nCurrState));
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::WriteLock
// Synopsis: acquire the lock exclusively
//------------------------------------------------------------------------

void
CReaderWriterLock::WriteLock()
{
    LOCKS_ENTER_CRIT_REGION();
    LOCK_WRITELOCK_INSTRUMENTATION();
    
    // Add ourselves to the queue of waiting writers
    Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
    
    if (! _TryWriteLock())
        _WriteLockSpin();
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::ReadLock
// Synopsis: acquire the lock shared
//------------------------------------------------------------------------

void
CReaderWriterLock::ReadLock()
{
    LOCKS_ENTER_CRIT_REGION();
    LOCK_READLOCK_INSTRUMENTATION();
    
    if (! _TryReadLock())
        _ReadLockSpin();
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::TryWriteLock
// Synopsis: Try to acquire the lock exclusively.
//------------------------------------------------------------------------

bool
CReaderWriterLock::TryWriteLock()
{
    LOCKS_ENTER_CRIT_REGION();

    // Add ourselves to the queue of waiting writers
    Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
    
    if (_TryWriteLock())
    {
        LOCK_WRITELOCK_INSTRUMENTATION();
        return true;
    }
    
    Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    LOCKS_LEAVE_CRIT_REGION();

    return false;    
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::_TryReadLock
// Synopsis: Try to acquire the lock shared.
//------------------------------------------------------------------------

bool
CReaderWriterLock::TryReadLock()
{
    LOCKS_ENTER_CRIT_REGION();

    if (_TryReadLock())
    {
        LOCK_READLOCK_INSTRUMENTATION();
        return true;
    }
    
    LOCKS_LEAVE_CRIT_REGION();

    return false;
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::WriteUnlock
// Synopsis: release the exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock::WriteUnlock()
{
    Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
    Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    LOCKS_LEAVE_CRIT_REGION();
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::ReadUnlock
// Synopsis: release the shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock::ReadUnlock()
{
    Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    LOCKS_LEAVE_CRIT_REGION();
}




//------------------------------------------------------------------------
// Function: CReaderWriterLock::ConvertSharedToExclusive()
// Synopsis: Convert a reader lock to a writer lock
//------------------------------------------------------------------------

void
CReaderWriterLock::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());
    Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
    
    // single reader?
    if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
        return;
    
    // No, so release the reader lock and spin
    ReadUnlock();

    LOCKS_ENTER_CRIT_REGION();
    _WriteLockSpin();
    
    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::ConvertExclusiveToShared()
// Synopsis: Convert a writer lock to a reader lock
//------------------------------------------------------------------------

void
CReaderWriterLock::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());
    Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
    Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        // Must unconditionally call _CmpExch once at the beginning of
        // the outer loop to establish a memory barrier. Both TryWriteLock
        // and TryReadLock test the value of m_nState before attempting a
        // call to _CmpExch. Without a memory barrier, those tests might
        // never use the true current value of m_nState on some processors.
        _CmpExch(0, 0);

        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Pause();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



//------------------------------------------------------------------------
// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_CmpExch
// Synopsis: _CmpExch is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock2::_CmpExch(
    LONG lNew,
    LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lRW),
                                     lNew, lCurrent);
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_WriteLockSpin
// Synopsis: Try to acquire an exclusive lock
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock2::_TryWriteLock(
    LONG nIncr)
{
    LONG lRW = m_lRW;
    // Grab exclusive access to the lock if it's free.  Works even
    // if there are other writers queued up.
    return ((lRW & SL_STATE_MASK) == SL_FREE
            &&  _CmpExch((lRW + nIncr) | SL_EXCLUSIVE, lRW));
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_TryReadLock
// Synopsis: Try to acquire a shared lock
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock2::_TryReadLock()
{
    LONG lRW = m_lRW;
    
    // Give writers priority
    return ((lRW & SL_WRITERS_MASK) == 0
            &&  _CmpExch(lRW + SL_READER_INCR, lRW));
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_WriteLockSpin
// Synopsis: release an exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::WriteUnlock()
{
    IRTLASSERT(IsWriteLocked());

    for (volatile LONG lRW = m_lRW;
         // decrement waiter count, clear loword to SL_FREE
         !_CmpExch((lRW - SL_WRITER_INCR) & ~SL_STATE_MASK, lRW);
         lRW = m_lRW)
    {
        IRTLASSERT(IsWriteLocked());
        Lock_Pause();
    }

    LOCKS_LEAVE_CRIT_REGION();
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::ReadUnlock
// Synopsis: release a shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::ReadUnlock()
{
    IRTLASSERT(IsReadLocked());

    for (volatile LONG lRW = m_lRW;
         !_CmpExch(lRW - SL_READER_INCR, lRW);
         lRW = m_lRW)
    {
        IRTLASSERT(IsReadLocked());
        Lock_Pause();
    }

    LOCKS_LEAVE_CRIT_REGION();
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::ConvertSharedToExclusive
// Synopsis: Convert a reader lock to a writer lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());

    // single reader?
    if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
    {
        // no, multiple readers
        ReadUnlock();

        LOCKS_ENTER_CRIT_REGION();
        _WriteLockSpin();
    }

    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::ConvertExclusiveToShared
// Synopsis: Convert a writer lock to a reader lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());

    for (volatile LONG lRW = m_lRW;
         ! _CmpExch(((lRW - SL_WRITER_INCR) & SL_WAITING_MASK)
                        | SL_READER_INCR,
                    lRW);
         lRW = m_lRW)
    {
        IRTLASSERT(IsWriteLocked());
        Lock_Pause();
    }

    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_WriteLockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (volatile LONG lRW = m_lRW;
         ! _CmpExch(lRW + SL_WRITER_INCR, lRW);
         lRW = m_lRW)
    {
        Lock_Pause();
    }
    
    _LockSpin(true);
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        // Must unconditionally call _CmpExch once at the beginning of
        // the outer loop to establish a memory barrier. Both TryWriteLock
        // and TryReadLock test the value of m_lRW before attempting a
        // call to _CmpExch. Without a memory barrier, those tests might
        // never use the true current value of m_lRW on some processors.
        _CmpExch(0, 0);

        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Pause();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



//------------------------------------------------------------------------
// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);



// Get the current thread ID.  Assumes that it can fit into 24 bits, which
// is fairly safe as NT recycles thread IDs and failing to fit into 24
// bits would mean that more than 16 million threads were currently active
// (actually 4 million as lowest two bits are always zero on W2K).  This
// is improbable in the extreme as NT runs out of resources if there are
// more than a few thousands threads in existence and the overhead of
// context swapping becomes unbearable.
inline
LONG
CReaderWriterLock3::_GetCurrentThreadId()
{
    return Lock_GetCurrentThreadId();
}

inline
LONG
CReaderWriterLock3::_CurrentThreadId()
{
    DWORD dwTid = Lock_GetCurrentThreadId();
    // Thread ID 0 is used by the System Idle Process (Process ID 0).
    // We use a thread-id of zero to indicate that the lock is unowned.
    // NT uses +ve thread ids, Win9x uses -ve ids
    IRTLASSERT(dwTid != SL_UNOWNED
               && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
    return (LONG) (dwTid & SL_THREAD_MASK);
}

//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_CmpExchRW
// Synopsis: _CmpExchRW is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock3::_CmpExchRW(
    LONG lNew,
    LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lRW),
                                     lNew, lCurrent);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_SetTid
// Synopsis: Atomically update m_lTid, the thread ID/count of owners.
// Returns:  Former value of m_lTid
//------------------------------------------------------------------------

LOCK_FORCEINLINE
LONG
CReaderWriterLock3::_SetTid(
    LONG lNewTid)
{
    return Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNewTid);
}
                                        


//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_TryWriteLock
// Synopsis: Try to acquire an exclusive lock
//------------------------------------------------------------------------

bool
CReaderWriterLock3::_TryWriteLock(
    LONG nWriterIncr)
{
    LONG lTid = m_lTid;

    // The common case: the writelock has no owner
    if (SL_UNOWNED == lTid)
    {
        LONG lRW = m_lRW;

        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        if (0 == (lRW << SL_WAITING_BITS))
        {
            IRTLASSERT(SL_FREE == (lRW & SL_STATE_MASK));

            if (_CmpExchRW(((lRW + nWriterIncr) | SL_EXCLUSIVE),  lRW))
            {
                lTid = _SetTid(_CurrentThreadId() | SL_OWNER_INCR);
                
                IRTLASSERT(lTid == SL_UNOWNED);

                return true;
            }
        }
    }

    // Does the current thread own the lock?
    else if (0 == ((lTid ^ _GetCurrentThreadId()) << SL_OWNER_BITS))
    {
        // m_lRW should be write-locked
        IRTLASSERT(SL_EXCLUSIVE == (m_lRW & SL_STATE_MASK));
        // If all bits are set in owner field, it's about to overflow
        IRTLASSERT(SL_OWNER_MASK != (lTid & SL_OWNER_MASK));

        _SetTid(lTid + SL_OWNER_INCR);

        IRTLASSERT(m_lTid == lTid + SL_OWNER_INCR);

        return true;
    }

    return false;
} // CReaderWriterLock3::_TryWriteLock



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_TryReadLock
// Synopsis: Try to acquire a shared lock
//------------------------------------------------------------------------

bool
CReaderWriterLock3::_TryReadLock()
{
    // Give writers priority
    LONG lRW = m_lRW;
    bool fLocked = (((lRW & SL_WRITERS_MASK) == 0)
                    &&  _CmpExchRW(lRW + SL_READER_INCR, lRW));
    IRTLASSERT(!fLocked  ||  m_lTid == SL_UNOWNED);
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_TryReadLockRecursive
// Synopsis: Try to acquire a shared lock that might already be owned
// by this thread for reading. Unlike _TryReadLock, does not give
// priority to waiting writers.
//------------------------------------------------------------------------

bool
CReaderWriterLock3::_TryReadLockRecursive()
{
    // Do *not* give writers priority. If the inner call attempts
    // to reacquire the read lock while another thread is waiting on
    // the write lock, we would deadlock if we waited for the queue
    // of writers to empty: the writer(s) can't acquire the lock
    // exclusively, as this thread holds a readlock. The inner call
    // typically releases the lock very quickly, so there is no
    // danger of writer starvation.
    LONG lRW = m_lRW;
    // First clause will always be true if this thread already has
    // a read lock
    bool fLocked = (((lRW & SL_STATE_MASK) != SL_EXCLUSIVE)
                    &&  _CmpExchRW(lRW + SL_READER_INCR, lRW));
    IRTLASSERT(!fLocked  ||  m_lTid == SL_UNOWNED);
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ReadOrWriteLock
// Synopsis: If already locked, recursively acquires another lock of the
// same kind (read or write). Otherwise, just acquires a read lock.
//------------------------------------------------------------------------

bool
CReaderWriterLock3::ReadOrWriteLock()
{
    LOCKS_ENTER_CRIT_REGION();

    if (IsWriteLocked())
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // If all bits are set in owner field, it's about to overflow
        IRTLASSERT(SL_OWNER_MASK != (m_lTid & SL_OWNER_MASK));

        _SetTid(m_lTid + SL_OWNER_INCR);

        IRTLASSERT(IsWriteLocked());

        return false;   // => not read locked
    }
    else
    {
        LOCK_READLOCK_INSTRUMENTATION();
        
        if (!_TryReadLockRecursive())
            _ReadLockSpin(SPIN_READ_RECURSIVE);

        IRTLASSERT(IsReadLocked());
            
        return true;   // => is read locked
    }
} // CReaderWriterLock3::ReadOrWriteLock



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::WriteUnlock
// Synopsis: release an exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock3::WriteUnlock()
{
    IRTLASSERT(IsWriteLocked());
    IRTLASSERT((m_lTid & SL_OWNER_MASK) != 0);

    volatile LONG lNew = m_lTid - SL_OWNER_INCR; 

    // Last owner?  Release completely, if so
    if ((lNew >> SL_THREAD_BITS) == 0)
    {
        IRTLASSERT((lNew & SL_OWNER_MASK) == 0);

        _SetTid(SL_UNOWNED);

        do 
        {
            Lock_Pause();
            lNew = m_lRW;
        } // decrement waiter count, clear loword to SL_FREE
        while (! _CmpExchRW((lNew - SL_WRITER_INCR) & ~SL_STATE_MASK,  lNew));
    }
    else
    {
        IRTLASSERT((lNew & SL_OWNER_MASK) != 0);
        _SetTid(lNew);
    }

    LOCKS_LEAVE_CRIT_REGION();
} // CReaderWriterLock3::WriteUnlock



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ReadUnlock
// Synopsis: release a shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock3::ReadUnlock()
{
    IRTLASSERT(IsReadLocked());

    for (volatile LONG lRW = m_lRW;
         ! _CmpExchRW(lRW - SL_READER_INCR, lRW);
         lRW = m_lRW)
    {
        IRTLASSERT(IsReadLocked());
        Lock_Pause();
    }

    LOCKS_LEAVE_CRIT_REGION();
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ReadOrWriteUnlock
// Synopsis: release a lock acquired with ReadOrWriteLock
//------------------------------------------------------------------------

void
CReaderWriterLock3::ReadOrWriteUnlock(
    bool fIsReadLocked)
{
    if (fIsReadLocked)
        ReadUnlock();
    else
        WriteUnlock();
} 



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ConvertSharedToExclusive
// Synopsis: Convert a reader lock to a writer lock
// Note: if there's more than one reader, then there's a window where
// another thread can acquire and release a writelock before this routine
// returns.
//------------------------------------------------------------------------

void
CReaderWriterLock3::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());

    // single reader?
    if (m_lRW == SL_ONE_READER
        &&  _CmpExchRW(SL_ONE_WRITER, SL_ONE_READER))
    {
        _SetTid(_CurrentThreadId() | SL_OWNER_INCR);
    }
    else
    {
        // no, multiple readers
        ReadUnlock();

        LOCKS_ENTER_CRIT_REGION();
        _WriteLockSpin();
    }

    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ConvertExclusiveToShared
// Synopsis: Convert a writer lock to a reader lock
// Note: There is no such window when converting from a writelock to a readlock
//------------------------------------------------------------------------

void
CReaderWriterLock3::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());

    // assume writelock is not held recursively
    IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
    _SetTid(SL_UNOWNED);

    for (volatile LONG lRW = m_lRW;
         ! _CmpExchRW(((lRW - SL_WRITER_INCR) & SL_WAITING_MASK)
                            | SL_READER_INCR,
                      lRW);
         lRW = m_lRW)
    {
        Lock_Pause();
    }

    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_WriteLockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (volatile LONG lRW = m_lRW;
         ! _CmpExchRW(lRW + SL_WRITER_INCR, lRW);
         lRW = m_lRW)
    {
        Lock_Pause();
    }
    
    _LockSpin(SPIN_WRITE);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock3::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        // Must unconditionally call _CmpExchRW once at the beginning of
        // the outer loop to establish a memory barrier. Both TryWriteLock
        // and TryReadLock test the value of m_lRW before attempting a
        // call to _CmpExchRW. Without a memory barrier, those tests might
        // never use the true current value of m_lRW on some processors.
        _CmpExchRW(0, 0);

        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock(0);
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                IRTLASSERT(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Pause();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



//------------------------------------------------------------------------
// CReaderWriterLock4 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock4);
LOCK_STATISTICS_DATA(CReaderWriterLock4);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock4);



// Get the current thread ID.  Assumes that it can fit into 24 bits, which
// is fairly safe as NT recycles thread IDs and failing to fit into 24
// bits would mean that more than 16 million threads were currently active
// (actually 4 million as lowest two bits are always zero on W2K).  This
// is improbable in the extreme as NT runs out of resources if there are
// more than a few thousands threads in existence and the overhead of
// context swapping becomes unbearable.
LOCK_FORCEINLINE
LONG
CReaderWriterLock4::_GetCurrentThreadId()
{
    return Lock_GetCurrentThreadId();
}



LOCK_FORCEINLINE
LONG
CReaderWriterLock4::_CurrentThreadId()
{
    DWORD dwTid = Lock_GetCurrentThreadId();
    // Thread ID 0 is used by the System Idle Process (Process ID 0).
    // We use a thread-id of zero to indicate that the lock is unowned.
    // NT uses +ve thread ids, Win9x uses -ve ids
    IRTLASSERT(dwTid != SL_UNOWNED
               && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
    return (LONG) (dwTid & SL_THREAD_MASK);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_CmpExchRW
// Synopsis: _CmpExchRW is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
bool
CReaderWriterLock4::_CmpExchRW(
    LONG lNew,
    LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lRW),
                                     lNew, lCurrent);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_SetTid
// Synopsis: Atomically update m_lTid, the thread ID/count of owners.
// Returns:  Former value of m_lTid
//------------------------------------------------------------------------

LOCK_FORCEINLINE
LONG
CReaderWriterLock4::_SetTid(
    LONG lNewTid)
{
#ifndef LOCK_NO_INTERLOCKED_TID
    return Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNewTid);
#else // LOCK_NO_INTERLOCKED_TID
    const LONG lPrevTid = m_lTid;
    m_lTid = lNewTid;
    return lPrevTid;
#endif // LOCK_NO_INTERLOCKED_TID
}
                                        


//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_TryWriteLock
// Synopsis: Try to acquire an exclusive lock
//------------------------------------------------------------------------

bool
CReaderWriterLock4::_TryWriteLock()
{
    LONG lTid = m_lTid;

    // The common case: the writelock has no owner
    if (SL_UNOWNED == lTid)
    {
        LONG lRW = m_lRW;

        // Grab exclusive access to the lock if it's free (state bits == 0).
        // Works even if there are other writers queued up.
        if (0 == (lRW << SL_WAITING_BITS))
        {
            IRTLASSERT(SL_FREE == (lRW & SL_STATE_MASK));

            if (_CmpExchRW(((lRW + SL_WAIT_WRITER_INCR) | SL_EXCLUSIVE),  lRW))
            {
                lTid = _SetTid(_CurrentThreadId());
                
                IRTLASSERT(lTid == SL_UNOWNED);

                return true;
            }
        }
    }

    // Does the current thread own the lock?
    else if (_GetCurrentThreadId() == lTid)
    {
        IRTLASSERT(IsWriteLocked());

        for (volatile LONG lRW = m_lRW;
             ! _CmpExchRW(lRW + SL_WRITER_INCR, lRW);
             lRW = m_lRW)
        {
            Lock_Pause();
        }

        return true;
    }

    return false;
} // CReaderWriterLock4::_TryWriteLock



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_TryWriteLock2
// Synopsis: Try to acquire an exclusive lock. Used by _LockSpin, so
// the thread has already been added to the count of waiters and the
// recursive writelock case is impossible
//------------------------------------------------------------------------

bool
CReaderWriterLock4::_TryWriteLock2()
{
    LONG lTid = m_lTid;

    IRTLASSERT(0 != (m_lRW & SL_WAITING_MASK));

    // Is the lock not owned by any writer?
    if (SL_UNOWNED == lTid)
    {
        LONG lRW = m_lRW;

        // Grab exclusive access to the lock if it's free (state bits == 0).
        // Works even if there are other writers queued up.
        if (0 == (lRW << SL_WAITING_BITS))
        {
            IRTLASSERT(SL_FREE == (lRW & SL_STATE_MASK));

            if (_CmpExchRW((lRW | SL_EXCLUSIVE),  lRW))
            {
                lTid = _SetTid(_CurrentThreadId());
                
                IRTLASSERT(lTid == SL_UNOWNED);

                return true;
            }
        }
    }

    IRTLASSERT(lTid != _GetCurrentThreadId());

    return false;
} // CReaderWriterLock4::_TryWriteLock2



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_TryReadLock
// Synopsis: Try to acquire a shared lock
//------------------------------------------------------------------------

bool
CReaderWriterLock4::_TryReadLock()
{
    // Give writers priority: yield if there are any waiters
    LONG lRW = m_lRW;
    bool fLocked = (((lRW & SL_WRITERS_MASK) == 0)
                    &&  _CmpExchRW(lRW + SL_READER_INCR, lRW));
    IRTLASSERT(!fLocked  ||  m_lTid == SL_UNOWNED);
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_TryReadLockRecursive
// Synopsis: Try to acquire a shared lock that might already be owned
// by this thread for reading. Unlike _TryReadLock, does not give
// priority to waiting writers.
//------------------------------------------------------------------------

bool
CReaderWriterLock4::_TryReadLockRecursive()
{
    // Do *not* give writers priority. If the inner call attempts
    // to reacquire the read lock while another thread is waiting on
    // the write lock, we would deadlock if we waited for the queue
    // of writers to empty: the writer(s) can't acquire the lock
    // exclusively, as this thread holds a readlock. The inner call
    // typically releases the lock very quickly, so there is no
    // danger of writer starvation.
    LONG lRW = m_lRW;
    LONG lState = lRW & SL_STATE_MASK;
    bool fNoWriter = ((lState >> (SL_STATE_BITS - 1)) == 0);

    // fNoWriter will always be true if this thread already has a read lock
    IRTLASSERT(fNoWriter == (lState == (lState & SL_READER_MASK)));
    IRTLASSERT(fNoWriter == (SL_FREE <= lState  &&  lState < SL_READER_MASK));

    bool fLocked = (fNoWriter  &&  _CmpExchRW(lRW + SL_READER_INCR, lRW));
    IRTLASSERT(!fLocked  ||  m_lTid == SL_UNOWNED);
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::ReadOrWriteLock
// Synopsis: If already locked, recursively acquires another lock of the
// same kind (read or write). Otherwise, just acquires a read lock.
//------------------------------------------------------------------------

bool
CReaderWriterLock4::ReadOrWriteLock()
{
    LOCKS_ENTER_CRIT_REGION();

    if (IsWriteLocked())
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        for (volatile LONG lRW = m_lRW;
             ! _CmpExchRW(lRW + SL_WRITER_INCR, lRW);
             lRW = m_lRW)
        {
            Lock_Pause();
        }

        IRTLASSERT(IsWriteLocked());
        
        return false;   // => not read locked
    }
    else
    {
        LOCK_READLOCK_INSTRUMENTATION();
        
        if (! _TryReadLockRecursive())
            _ReadLockSpin(SPIN_READ_RECURSIVE);

        IRTLASSERT(IsReadLocked());
            
        return true;   // => is read locked
    }
}  // CReaderWriterLock4::ReadOrWriteLock



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::WriteUnlock
// Synopsis: release an exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock4::WriteUnlock()
{
    IRTLASSERT(IsWriteLocked());

    LONG lState = m_lRW & SL_STATE_MASK;
    volatile LONG lRW;

    // Last owner?  Release completely, if so
    if (lState == SL_EXCLUSIVE)
    {
        _SetTid(SL_UNOWNED);

        do 
        {
            Lock_Pause();
            lRW = m_lRW;
        } // decrement waiter count, clear loword to SL_FREE
        while (!_CmpExchRW((lRW - SL_WAIT_WRITER_INCR) & ~SL_STATE_MASK, lRW));
    }
    else
    {
        for (lRW = m_lRW;
             ! _CmpExchRW(lRW - SL_WRITER_INCR, lRW);
             lRW = m_lRW)
        {
            Lock_Pause();
        }

    }

    LOCKS_LEAVE_CRIT_REGION();
} // CReaderWriterLock4::WriteUnlock



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::ReadUnlock
// Synopsis: release a shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock4::ReadUnlock()
{
    IRTLASSERT(IsReadLocked());

    for (volatile LONG lRW = m_lRW;
         ! _CmpExchRW(lRW - SL_READER_INCR, lRW);
         lRW = m_lRW)
    {
        IRTLASSERT(IsReadLocked());
        Lock_Pause();
    }

    LOCKS_LEAVE_CRIT_REGION();
} // CReaderWriterLock4::ReadUnlock



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::ReadOrWriteUnlock
// Synopsis: release a lock acquired with ReadOrWriteLock
//------------------------------------------------------------------------

void
CReaderWriterLock4::ReadOrWriteUnlock(
    bool fIsReadLocked)
{
    if (fIsReadLocked)
        ReadUnlock();
    else
        WriteUnlock();
} // CReaderWriterLock4::ReadOrWriteUnlock



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::ConvertSharedToExclusive
// Synopsis: Convert a reader lock to a writer lock
// Note: if there's more than one reader, then there's a window where
// another thread can acquire and release a writelock before this routine
// returns.
//------------------------------------------------------------------------

void
CReaderWriterLock4::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());

    // single reader?
    if (m_lRW == SL_ONE_READER
        &&  _CmpExchRW(SL_ONE_WRITER, SL_ONE_READER))
    {
        _SetTid(_CurrentThreadId());
    }
    else
    {
        // no, multiple readers
        ReadUnlock();

        LOCKS_ENTER_CRIT_REGION();
        _WriteLockSpin();
    }

    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::ConvertExclusiveToShared
// Synopsis: Convert a writer lock to a reader lock
// Note: There is no such window when converting from a writelock to a readlock
//------------------------------------------------------------------------

void
CReaderWriterLock4::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());

    // assume writelock is not held recursively
    IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
    _SetTid(SL_UNOWNED);

    for (volatile LONG lRW = m_lRW;
         ! _CmpExchRW(((lRW - SL_WAIT_WRITER_INCR) & SL_WAITING_MASK)
                            | SL_READER_INCR,
                      lRW);
         lRW = m_lRW)
    {
        Lock_Pause();
    }

    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_WriteLockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock4::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (volatile LONG lRW = m_lRW;
         ! _CmpExchRW(lRW + SL_WAIT_WRITER_INCR, lRW);
         lRW = m_lRW)
    {
        Lock_Pause();
    }
    
    _LockSpin(SPIN_WRITE);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock4::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock4::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        // Must unconditionally call _CmpExchRW once at the beginning of
        // the outer loop to establish a memory barrier. Both TryWriteLock
        // and TryReadLock test the value of m_lRW before attempting a
        // call to _CmpExchRW. Without a memory barrier, those tests might
        // never use the true current value of m_lRW on some processors.
        _CmpExchRW(0, 0);

        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock2();
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                IRTLASSERT(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }

            Lock_Pause();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\iiscomp\resource.h ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        resource.h

   Abstract:

        Resource IDs

   Author:

        Christopher Achille (cachille)

   Project:

        IIS Compatability Dll

   Revision History:
     
       May 2002: Created

--*/

#define IDS_COMPATABILITY_DESCRIPTION_CLUSTER          100
#define IDS_COMPATABILITY_DESCRIPTION_W3SVCDISABLE     101
#define IDS_COMPATABILITY_DESCRIPTION_FAT              102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\inetmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by START.RC
//
#define IDS_NOTSUPPORT                  1
#define IDS_CANTRUN                     2
#define IDS_LOAD1                       3
#define IDS_RUN_NTS                     4
#define IDS_RUN_NTW                     5
#define IDS_RUN_W95                     6
#define IDS_UNABLE_TO_RUN               7
#define IDS_UNABLE_TO_FIND              8
#define IDS_SETUP                       9
#define IDS_TITLE                       9
#define IDS_SETUP_LOAD                  10
#define IDS_UNKNOWN_SERVER_TYPE         11
#define IDS_UNABLE_TO_SETUP             12
#define IDS_CANNOT_RUN_UNC              13
#define IDS_INETSRV_INSTALLED_DIR       14
#define IDI_ICON1                       101
#define IDI_ICON2                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\iiscomp\disblwww.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        disblwww.cxx

   Abstract:

        Determine if IIS should be disabled on upgrade.

   Author:

        Christopher Achille (cachille)

   Project:

        IIS Compatability Dll

   Revision History:
     
       May 2002: Created

--*/

#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "disblwww.hxx"

// ShouldW3SVCBeDisabledOnUpgrade
//
// Should we disable W3SVC on Upgrade?
//
// Parameters
//   pbDisable - [out] Should the service be disabled or not
//
// Return Values:
//   TRUE - Success checking
//   FALSE - Failure checking
//
BOOL ShouldW3SVCBeDisabledOnUpgrade( LPBOOL pbDisable )
{
  BOOL bHasLockDownBeenRun;
  BOOL bIsW3SVCAlreadyDisabled;
  BOOL bIsRegistryBlockSet;
  BOOL bIsWin2kUpgrade;
  BOOL bIsIISInstalled;

  if ( !IsIISInstalled( &bIsIISInstalled ) ||
       !IsWin2kUpgrade( &bIsWin2kUpgrade ) )
  {
    // Failed to query appropriate information
    return FALSE;
  }

  if ( !bIsWin2kUpgrade || 
       !bIsIISInstalled )
  {
    // Don't disable, since we are only suppose to do this on Win2k
    // upgrades with IIS
    *pbDisable = FALSE;
    return TRUE;
  }

  if ( !HasLockdownBeenRun( &bHasLockDownBeenRun ) ||
       !IsW3SVCDisabled( &bIsW3SVCAlreadyDisabled ) ||
       !HasRegistryBlockEntryBeenSet( &bIsRegistryBlockSet ) )
  {
    // Failed to query, so lets fail
    return FALSE;
  }

  if ( bHasLockDownBeenRun ||
       bIsW3SVCAlreadyDisabled ||
       bIsRegistryBlockSet )
  {
    // One of these conditions has been met, so we don't have to disable
    *pbDisable = FALSE;
  }
  else
  {
    // Disable, since none of the conditions were met
    *pbDisable = TRUE;
  }

  return TRUE;
}

// HasLockdownBeenRun
//
// Has the lockdown tool been run?
//
// Parameters
//   pbBeenRun [out] - TRUE == It has been run
//                     FALSE == It has not been run
//
// Return
//   TRUE - Success checking
//   FALSE - Failure checking
//
BOOL 
HasLockdownBeenRun( LPBOOL pbBeenRun )
{
  HKEY  hRegKey;
  HKEY  hLockdownKey;

  // Initialize to FALSE
  *pbBeenRun = FALSE;

  if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                     LOCKDOWN_REGISTRY_LOCATION,
                     0,
                     KEY_READ,
                     &hRegKey ) != ERROR_SUCCESS )
  {
    // Failed to open key, lets fail
    return FALSE;
  }

  if ( RegOpenKeyEx( hRegKey,
                     LOCKDOWN_REGISTRY_KEY,
                     0,
                     KEY_READ,
                     &hLockdownKey ) == ERROR_SUCCESS )
  {
    // We found the key, so it must have been run
    RegCloseKey( hLockdownKey );
    *pbBeenRun = TRUE;    
  }

  RegCloseKey( hRegKey );

  return TRUE;
}

// IsW3SVCDisabled
//
// Check is W3SVC is already disabled
//
// pbDisabled
BOOL 
IsW3SVCDisabled( LPBOOL pbDisabled )
{
  DWORD dwW3SVCStartupType;
  DWORD dwIISAdminStartupType;

  if ( !QueryServiceStartType( W3SVC_SERVICENAME, &dwW3SVCStartupType ) ||
       !QueryServiceStartType( IISADMIN_SERVICENAME, &dwIISAdminStartupType ) )
  {
    // Failure quering services
    return FALSE;
  }

  *pbDisabled = ( dwW3SVCStartupType == SERVICE_DISABLED ) ||
                ( dwIISAdminStartupType == SERVICE_DISABLED );

  return TRUE;
}

// HasRegistryBlockEntryBeenSet
//
// Has Someone set a flag in the registry telling us not
// to disable ourselves
//
BOOL 
HasRegistryBlockEntryBeenSet( LPBOOL pbIsSet )
{
  HKEY  hRegKey;
  HKEY  hBlockKey;

  // Initialize to FALSE
  *pbIsSet = FALSE;

  if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                     SERVICE_DISABLE_BLOCK_LOCATION,
                     0,
                     KEY_READ,
                     &hRegKey ) != ERROR_SUCCESS )
  {
    // Failed to open key, lets fail
    return FALSE;
  }

  if ( RegOpenKeyEx( hRegKey,
                     SERVICE_DISABLE_BLOCK_KEY,
                     0,
                     KEY_READ,
                     &hBlockKey ) == ERROR_SUCCESS )
  {
    DWORD dwIndex;
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR szValueName[ MAX_PATH ];
    DWORD dwValueNameLength;
    DWORD dwValue;
    DWORD dwValueLength;
    DWORD dwType;

    // Now lets check and see if anything is set here
    for ( dwIndex = 0; 
          ( *pbIsSet == FALSE ) && 
          ( dwErr == ERROR_SUCCESS ) && 
          ( dwIndex < MAX_PATH );  // This is just incase we get caught in a loop
          dwIndex++)
    {
      dwValueNameLength = sizeof(szValueName)/sizeof(szValueName[0]);
      dwValueLength = sizeof( dwValue );

      dwErr = RegEnumValue( hBlockKey,           // Key to enum
                            dwIndex,             // First entry
                            szValueName,         // Name of Value
                            &dwValueNameLength,  // Length of Name buffer
                            NULL,                // Reserved
                            &dwType,             // Reg Type
                            (LPBYTE) &dwValue,   // Value in registry
                            &dwValueLength );    // Size of value

      if ( ( dwErr == ERROR_SUCCESS ) && 
           ( dwType == REG_DWORD ) )
      {
        *pbIsSet = TRUE;
      }

      if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
      {
        // If the buffer is too small, then skip this one
        dwErr = ERROR_SUCCESS;
      }
    }
                        
    RegCloseKey( hBlockKey );
  }

  RegCloseKey( hRegKey );

  return TRUE;
}

// IsIISInstalled
//
// Is IIS installed on this machine?
//
BOOL IsIISInstalled( LPBOOL pbIsIISInstalled )
{
  SC_HANDLE hSCM;
  SC_HANDLE hW3Service;
  BOOL      bRet = TRUE;

  *pbIsIISInstalled = FALSE;

  hSCM = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, GENERIC_READ );

  if ( hSCM == NULL )
  {
    // Failed to open SCM
    return FALSE;
  }

  hW3Service = OpenService( hSCM, W3SVC_SERVICENAME, SERVICE_QUERY_CONFIG );

  if ( hW3Service != NULL )
  {
    // W3SVC service is installed
    *pbIsIISInstalled = TRUE;

    CloseServiceHandle( hW3Service );
  }
  else
  {
    if ( ( GetLastError() != ERROR_INVALID_NAME ) &&
         ( GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST ) )
    {
      bRet = FALSE;
    }
  }

  CloseServiceHandle( hSCM );

  return bRet;
}

// IsWin2kUpgrate
//
// Make sure this is a Win2k Upgrade
//
BOOL 
IsWin2kUpgrade( LPBOOL pbIsWin2k )
{
  OSVERSIONINFO osVerInfo;

  osVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  if ( !GetVersionEx( &osVerInfo ) )
  {
    // Failed to check version
    return FALSE;
  }

  *pbIsWin2k = ( osVerInfo.dwMajorVersion == 5 ) &&
               ( osVerInfo.dwMinorVersion == 0 );

  return TRUE;
}


// QueryServiceStartType
//
// Query the start type for the particular service
//
// Parameters
//   szServiceName - [in] The name of the service to query
//   pdwStartType - [out] The Service Start Type
//                        see QUERY_SERVICE_CONFIG.dwStartType 
//
// Return:
//   TRUE - Successfully queried
//   FALSE - Could not be retrieved
//
BOOL 
QueryServiceStartType( LPTSTR szServiceName, LPDWORD pdwStartType )
{
  SC_HANDLE               hSCM;
  SC_HANDLE               hW3Service;
  LPBYTE                  pBuffer;
  BOOL                    bRet = FALSE;
  DWORD                   dwErr;
  DWORD                   dwSizeNeeded;

  hSCM = OpenSCManager( NULL, SERVICES_ACTIVE_DATABASE, GENERIC_READ );

  if ( hSCM == NULL )
  {
    // Failed to open SCM
    return FALSE;
  }

  hW3Service = OpenService( hSCM, szServiceName, SERVICE_QUERY_CONFIG );

  if ( hW3Service != NULL )
  {
    if ( !QueryServiceConfig( hW3Service, NULL, 0, &dwSizeNeeded ) &&
         ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) )
    {
      pBuffer = new ( BYTE[ dwSizeNeeded ] );

      if ( pBuffer &&
           QueryServiceConfig( hW3Service, (LPQUERY_SERVICE_CONFIG) pBuffer, 
                            dwSizeNeeded, &dwSizeNeeded ) )
      {
        *pdwStartType = ( (LPQUERY_SERVICE_CONFIG) pBuffer )->dwStartType;
        bRet = TRUE;
      }

      if ( pBuffer )
      {
        // Free buffer
        delete pBuffer;
      }
    }

    CloseServiceHandle( hW3Service );
  }

  CloseServiceHandle( hSCM );

  return bRet;
}

// NotifyIISToDisableW3SVCOnUpgrade
//
// Notify IIS that W3SVC should be disabled when we upgrade
//
// Parameters:
//   bDisable - Disable/Don't Disable web service on upgrade
BOOL 
NotifyIISToDisableW3SVCOnUpgrade( BOOL bDisable )
{
  HKEY  hKey;
  DWORD dwValue = bDisable;
  BOOL  bRet = TRUE;
  DWORD dwRet;

  // Open Node where this is going to be set
  dwRet = RegCreateKeyEx( HKEY_LOCAL_MACHINE,         // Root Key
                          REGISTR_IISSETUP_LOCATION,  // Subkey
                          0,                          // Reserved
                          _T(""),                     // Class ID
                          REG_OPTION_NON_VOLATILE,
                          KEY_WRITE,                  // Write Access
                          NULL,
                          &hKey,
                          NULL );

  if ( dwRet != ERROR_SUCCESS )
  {
    // Failed to open key
    return FALSE;
  }

  if ( RegSetValueEx( hKey,                           // Key
                      REGISTR_IISSETUP_DISABLEW3SVC,  // Value Name
                      0,                              // Reserver
                      REG_DWORD,                      // DWORD
                      (LPBYTE) &dwValue,              // Value
                      sizeof(dwValue) ) != ERROR_SUCCESS )
  {
    // Failed to set value
    bRet =FALSE;
  }

  RegCloseKey( hKey );

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\imh6\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

!IF "$(PROCESSOR_ARCHITECTURE)"!="MIPS"
!IF "$(PROCESSOR_ARCHITECTURE)"!="PPC"

CDROOT=$(_NTTREE)\inetsrv
CDDUMP=$(_NTTREE)\inetsrv\Dump

MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyfile:
	if not exist "$(CDROOT)" mkdir $(CDROOT)
	if not exist "$(CDDUMP)" mkdir $(CDDUMP)

#       create a list of the files that could change 
#       and we would want to make sure to rebuild the cabs if they changed.
        if exist makecab.lst attrib -r -a -s -h makecab.lst
	if exist makecab.lst0 (del makecab.lst0)
	if exist makecab.lst (del makecab.lst)
        dir /b /a-d > makecab.lst0
#	remove makecab.lst from the the list...
        findstr /i /v makecab.lst makecab.lst0 > makecab.lst

#       stuff we really do need
	$(MY_BINPLACE) infutil.csv
	$(MY_BINPLACE) header.ddf
	$(MY_BINPLACE) makecab.lst
	$(MY_BINPLACE) hardcode.lst

	$(MY_BINPLACE) iistop.inx
	$(MY_BINPLACE) iisend.inx
	$(MY_BINPLACE) dirmake.txt
	$(MY_BINPLACE) empty.txt

#       --------------------------------------
#       old bad way of copying files to the binaries dir
#       bad bad bad, you should not use xcopy!
#       use binplace and modify the placefil.txt file
#       --------------------------------------
#	xcopy /d /i header*.inf $(CDDUMP)

!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\iiscomp\iiscomp.cpp ===
#include <tchar.h>
# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
// For the compatibility check function and types
#include <comp.h>
#include <clusapi.h>
#include "resource.h"
#include "iiscomp.hxx"
#include "disblwww.hxx"

HANDLE g_hMyHandle = NULL;

//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
  BOOL bReturn = FALSE;

  switch(Reason)
  {
    case DLL_PROCESS_ATTACH:
      g_hMyHandle = DllHandle;
      bReturn = TRUE;
      break;

    case DLL_THREAD_ATTACH:
      bReturn = TRUE;
      break;

    case DLL_PROCESS_DETACH:
      bReturn = TRUE;
      break;

    case DLL_THREAD_DETACH:
      bReturn = TRUE;
      break;
  }

  return(bReturn);
}

// function: IISUpgradeCompatibilityCheck
//
// Checks the IIS Upgrade Comapatability.  At this time, this is only used to 
// tell if the machine is clustered for IIS.  Because this upgrade is not seemless
//
// Parameters:
//      PCOMPAIBILITYCALLBACK pfnCompatibilityCallbackIn
//          Points to the callback function used to supply compatibility
//          information to WinNT32.exe
//
//      LPVOID pvContextIn
//          Pointer to the context buffer supplied by WinNT32.exe
//
// Return Values:
//   TRUE - Everything worked fine
//   FALSE - There was a failure
//
extern "C"
BOOL
IISUpgradeCompatibilityCheck(
      PCOMPAIBILITYCALLBACK pfnCompatibilityCallbackIn
    , LPVOID pvContextIn
    )
{
  BOOL                  bRet = TRUE;
  BOOL                  bDisableW3SVC;
  BOOL                  bInstallingOnFat;
  BOOL                  bIISIsInstalled;
  COMPATIBILITY_ENTRY   ceCompatibilityEntry;

  if ( !IsIISInstalled( &bIISIsInstalled ) )
  {
    // Failed to do check, error out
    return FALSE;
  }

  if ( !bIISIsInstalled )
  {
    // IIS is not installed, so there is nothing we need to do
    return TRUE;
  }

  // Check for Clustering Compatability Issue
  if ( IsClusterResourceInstalled( IISCOMPAT_RESOURCETYPE ) )
  {
    // Since we have the comaptabilty problem, we have to call the winnt32 callback funcion
    SetCompatabilityContext( &ceCompatibilityEntry,
                             IDS_COMPATABILITY_DESCRIPTION_CLUSTER,
                             IISCOMPAT_TEXTNAME,
                             IISCOMPAT_HTMLNAME );

    bRet = pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn );
  }

  // Check for disabling the W3SVC Service
  if ( ShouldW3SVCBeDisabledOnUpgrade( &bDisableW3SVC ) )
  {
    if ( !NotifyIISToDisableW3SVCOnUpgrade( bDisableW3SVC ) )
    {
      bRet = FALSE;
    }

    if ( bDisableW3SVC )
    {
      // Since we have the comaptabilty problem, we have to call the winnt32 callback funcion
      SetCompatabilityContext( &ceCompatibilityEntry,
                              IDS_COMPATABILITY_DESCRIPTION_W3SVCDISABLE,
                              IISCOMPAT_W3SVCDISABLE_TEXTNAME,
                              IISCOMPAT_W3SVCDISABLE_HTMLNAME );

      if ( !pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn ) )
      {
        bRet = FALSE;
      }
    }
  }
  else
  {
    // Could not do check, so fail
    bRet = FALSE;
  }

  // Warning about installing on FAT
  if ( IsIISInstallingonFat( &bInstallingOnFat ) )
  {
    if ( bInstallingOnFat )
    {
      // Since we have the comaptabilty problem, we have to call the winnt32 callback funcion
      SetCompatabilityContext( &ceCompatibilityEntry,
                              IDS_COMPATABILITY_DESCRIPTION_FAT,
                              IISCOMPAT_FAT_TEXTNAME,
                              IISCOMPAT_FAT_HTMLNAME );

      if ( !pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn ) )
      {
        bRet = FALSE;
      }
    }
  }
  else
  {
    // Could not do check, so fail
    bRet = FALSE;
  }

  return bRet;
}

// IsIISInstallingonFat
//
// Parameters:
//   pbInstallingOnFat [out] - Is IIS installing on FAT?
//
// Return Values:
//   TRUE - Successfully checked
//   FALSE - Failure checking
//
BOOL 
IsIISInstallingonFat( LPBOOL pbInstallingOnFat )
{
  TCHAR szSystemDrive[ MAX_PATH ];
  DWORD dwDriveFlags;
  UINT  iReturn;

  iReturn = GetWindowsDirectory( szSystemDrive, 
                                 sizeof(szSystemDrive)/sizeof(szSystemDrive[0]) );

  if ( ( iReturn == 0 ) ||                // Call failed
       ( iReturn >= MAX_PATH ) ||         // Buffer was not large enough
       ( iReturn < 3 ) ||                 // sizeof 'x:\'
       ( szSystemDrive[1] != _T(':') ) || // Not in a format we expect
       ( szSystemDrive[2] != _T('\\') ) )
  {
    // Failure checking
    return FALSE;
  }

  // Null terminate drive
  szSystemDrive[3] = _T('\0');

  if ( !GetVolumeInformation( szSystemDrive,
                            NULL,         // Volume Name Buffer
                            0,            // Size of Buffer
                            NULL,         // Serial Number Buffer
                            NULL,         // Max Component Lenght
                            &dwDriveFlags,  // System Flags
                            NULL,         // FS Type
                            0 ) )
  {
    // Failed to do query
    return FALSE;
  }

  *pbInstallingOnFat = ( dwDriveFlags & FS_PERSISTENT_ACLS ) == 0;

  return TRUE;
}

// SetCompatabilityContext
//
// Set the Context of the Compatabilty stucrute that we must send back to
// the compat stuff
//
void 
SetCompatabilityContext( COMPATIBILITY_ENTRY *pCE, DWORD dwDescriptionID, LPTSTR szTxtFile, LPTSTR szHtmlFile )
{
  static WCHAR  szDescriptionBuffer[ 100 ];
  DWORD         dwErr;

  dwErr = LoadStringW( (HINSTANCE) g_hMyHandle, 
                       dwDescriptionID, 
                       szDescriptionBuffer, 
                       sizeof(szDescriptionBuffer)/sizeof(szDescriptionBuffer[0]) );

  if ( dwErr == 0 )
  {
    // This should not happen, since we control the length
    // of the resource
    ASSERT( ( sizeof(IISCOMPAT_DESCRIPTION)/sizeof(WCHAR) ) < 
            ( sizeof(szDescriptionBuffer)/sizeof(szDescriptionBuffer[0]) ) );
    ASSERT( dwErr != 0 /* FALSE */ );

    _tcscpy(szDescriptionBuffer, IISCOMPAT_DESCRIPTION );
  }

  pCE->Description = szDescriptionBuffer;
  pCE->HtmlName = szHtmlFile;
  pCE->TextName = szTxtFile;
  pCE->RegKeyName = NULL;
  pCE->RegValName = NULL ;
  pCE->RegValDataSize = 0;
  pCE->RegValData = NULL;
  pCE->SaveValue =  NULL;
  pCE->Flags = 0;
  pCE->InfName = NULL;
  pCE->InfSection = NULL;
}

// function: IsClusterResourceInstalled
//
// Check to see if there is a Cluster with a resource of a particular
// type that you are looking for.
//
// Parameters:
//   szResourceType - The type of resource that you are looking for
//
// Return Values:
//   TRUE - There is a cluster with that resource type
//   FALSE - There is not a cluster with that resource type, or we
//           failed during the search
//
BOOL
IsClusterResourceInstalled(LPWSTR szResourceType)
{
  HCLUSTER                        hCluster;
  HINSTANCE                       hClusApi = NULL;
  HCLUSENUM                       hClusEnum = NULL;
  BOOL                            bResourceFound = FALSE;

  if (hCluster = OpenCluster(NULL))
  {
    // Open cluster resource
    hClusEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_RESOURCE);
  }

  if (hClusEnum != NULL)
  {
    DWORD dwEnumIndex = 0;
    DWORD dwErr = ERROR_SUCCESS; 
    WCHAR szClusterName[CLUSTERNAME_MAXLENGTH];
    WCHAR szClusterResourceType[CLUSTERNAME_MAXLENGTH];
    DWORD dwType;
    DWORD dwLen;
    HRESOURCE hClusResource;
    HKEY  hResourceRoot;
    HKEY  hClusResourceKey;

    while ( ( dwErr == ERROR_SUCCESS ) && !bResourceFound )
    {
      // Get the cluster name
      dwLen = CLUSTERNAME_MAXLENGTH;
      dwErr = ClusterEnum( hClusEnum, dwEnumIndex++, &dwType, szClusterName, &dwLen );

      if ( ( dwErr == ERROR_SUCCESS ) && ( dwType == CLUSTER_ENUM_RESOURCE ) )
      {
        hClusResource = NULL;
        hClusResourceKey = NULL;
        dwLen = CLUSTERNAME_MAXLENGTH;
        // For each cluster, check out the resources
        if ( ( hClusResource = OpenClusterResource( hCluster, szClusterName ) ) &&
             ( hClusResourceKey = GetClusterResourceKey( hClusResource, KEY_READ ) ) &&
             ( ClusterRegQueryValue( hClusResourceKey, L"Type", &dwType, (LPBYTE) szClusterResourceType , &dwLen ) == ERROR_SUCCESS) && 
             ( dwType == REG_SZ ) &&
             ( !_wcsicmp( szClusterResourceType , szResourceType ) )
           ) 
        {
          // Found the Resource we were looking for
          bResourceFound = TRUE;
        }

        if ( hClusResourceKey )
        {
          ClusterRegCloseKey( hClusResourceKey );
        }
        
        if ( hClusResource )
        {
          CloseClusterResource( hClusResource );
        }
      }
    }
  }

  if ( hClusEnum )
  {
    ClusterCloseEnum( hClusEnum );
  }

  if ( hCluster )
  {
    CloseCluster( hCluster);
  }

  return bResourceFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\inetmgr\start.c ===
//----------------------------------------------
//
// 16 bit stub to run mmc.exe with parameters
//
//----------------------------------------------
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <direct.h>
#include <windows.h>

#include <shellapi.h> // 16-bit Windows header
#include "wownt16.h"  // available from Win32 SDK
#include "resource.h"

#define FILE_TO_RUN            "mmc.exe"
#define FILE_TO_RUN_FILE_PARAM "iis.msc"
#define REG_PRODUCT_KEY    "SYSTEM\\CurrentControlSet\\Control\\ProductOptions"

/* ************************ prototypes ***************************** */
int     RunTheApp(void);
int             HasTheAppStarted(void);
int             CheckIfFileExists(char *input_filespec);
void    PopUpUnableToSomething(char[], int);
void    AddPath(LPSTR szPath, LPCSTR szName );

LRESULT CALLBACK WindowFunc(HWND, UINT, WPARAM, LPARAM);
/* ************************* globals ******************************* */
HANDLE  g_hInstance;
HANDLE  g_hPrevInstance;
LPSTR   g_lpCmdLine;
int     g_nCmdShow;
char    g_szTime[100] = "";
UINT    g_WinExecReturn;
char    g_szWinExecModuleName[260];
char    g_szMsg[_MAX_PATH];
char    g_szSystemDir[_MAX_PATH];
char    g_szSystemDir32[_MAX_PATH];
/* **************************************************************** */
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND  hwnd;
    MSG   msg;
    WNDCLASS wcl;
    char  szWinName[_MAX_PATH];
    char  szBuf[_MAX_PATH];
    DWORD dwRet;

    g_hInstance = hInstance;
    g_hPrevInstance = hPrevInstance;
    g_lpCmdLine = lpCmdLine;
    g_nCmdShow = nCmdShow;

    LoadString( g_hInstance, IDS_TITLE, szWinName, _MAX_PATH );

    // note that this will come back as "system" <-- must be because this is a 16bit app
    dwRet = GetSystemDirectory( szBuf, sizeof(szBuf) - sizeof("32") );

    if ( ( dwRet == 0 ) ||
         ( dwRet > ( sizeof(szBuf) - sizeof("32") ) ) 
       )
    {
      return 0;
    }

    lstrcpy(g_szSystemDir, szBuf);
    lstrcat(g_szSystemDir, "32");

    // set to system if can't find system32 directory
    if  ( CheckIfFileExists( g_szSystemDir ) == FALSE ) 
    {
      lstrcpy(g_szSystemDir, szBuf);
    }

    // define windows class
    wcl.hInstance = hInstance;
    wcl.lpszClassName = szWinName;
    wcl.lpfnWndProc = WindowFunc;
    wcl.style = 0;
    wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wcl.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcl.lpszMenuName = NULL;
    wcl.cbClsExtra = 0;
    wcl.cbWndExtra = 0;
    wcl.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    // register the window class.
    if (!RegisterClass (&wcl)) return 0;

    //hwnd = CreateWindow(szWinName, NULL, WS_DLGFRAME, CW_USEDEFAULT, CW_USEDEFAULT, window_h, window_v, HWND_DESKTOP, NULL, hInstance , NULL);
    hwnd = CreateWindow(szWinName, NULL, WS_DISABLED | WS_CHILD, CW_USEDEFAULT, CW_USEDEFAULT, 10, 10, HWND_DESKTOP, NULL, hInstance , NULL);

    // display the window
    ShowWindow(hwnd, nCmdShow);

    // Start a timer -- interrupt once for 1 seconds
    SetTimer(hwnd, 1, 500, NULL);
    UpdateWindow(hwnd);

        // Return true only if we are able to start the setup program and run it.
    if (!RunTheApp()) {return FALSE;}

        // Check if the process has started by checking for
        // the window that should be run...
        if (HasTheAppStarted()) {PostQuitMessage(0);}

    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    KillTimer(hwnd, 1);
    return (int)(msg.wParam);
}


//***************************************************************************
//*
//* purpose: you know what
//*
//***************************************************************************
LRESULT CALLBACK WindowFunc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        switch(message)
                {
                case WM_TIMER:
                        // Check if the process has started by checking for
                        // the window that should be run...
                        if (HasTheAppStarted()) {PostQuitMessage(0);}
                        break;

            case WM_CREATE:
                        break;

                case WM_PAINT:
                        break;

                case WM_DESTROY:
                        PostQuitMessage(0);
                        break;

                default:
                    return DefWindowProc(hwnd,message,wParam, lParam);
                }

        return 0;
}


//***************************************************************************
//*
//* purpose: return TRUE if the window has started
//*
//***************************************************************************
int RunTheApp(void)
{
    char szIISInstalledPath[_MAX_PATH];
    char szCommandToRun[_MAX_PATH + _MAX_PATH + 50];
    char szTempFilePath[_MAX_PATH + sizeof( FILE_TO_RUN ) ];

    // check if our files exist...
    lstrcpy(szTempFilePath, g_szSystemDir);
    AddPath(szTempFilePath, FILE_TO_RUN);

    if (CheckIfFileExists(szTempFilePath) == FALSE) 
    {
      PopUpUnableToSomething(szTempFilePath, IDS_UNABLE_TO_FIND); 
      return FALSE;
    }

    // get iis installed directory
    LoadString( g_hInstance, IDS_INETSRV_INSTALLED_DIR, szIISInstalledPath, _MAX_PATH);

    if ( ( strlen(g_szSystemDir) + 
           strlen(szIISInstalledPath) + 
           strlen(FILE_TO_RUN_FILE_PARAM)
           ) >= sizeof(szTempFilePath) )
    {
      return FALSE;
    }

    lstrcpy(szTempFilePath, g_szSystemDir);
    AddPath(szTempFilePath, szIISInstalledPath);
    AddPath(szTempFilePath, FILE_TO_RUN_FILE_PARAM);

    if (CheckIfFileExists(szTempFilePath) == FALSE) 
    {
      PopUpUnableToSomething(szTempFilePath, IDS_UNABLE_TO_FIND); 
      return FALSE;
    }

    // Create a command line
    //%SystemRoot%\System32\mmc.exe D:\WINNT0\System32\inetsrv\iis.msc
    if ( ( strlen( g_szSystemDir )  +
           strlen( FILE_TO_RUN ) +
           strlen( " " ) +
           strlen( g_szSystemDir ) +
           strlen( szIISInstalledPath ) +
           strlen( FILE_TO_RUN_FILE_PARAM ) +
           1 ) > sizeof(szCommandToRun) )
    {
      return FALSE;
    }

    lstrcpy(szCommandToRun, g_szSystemDir);
    AddPath(szCommandToRun, FILE_TO_RUN);
    lstrcat(szCommandToRun, " ");
    lstrcat(szCommandToRun, g_szSystemDir);
    AddPath(szCommandToRun, szIISInstalledPath);
    AddPath(szCommandToRun, FILE_TO_RUN_FILE_PARAM);

    // Run the executable if the file exists
    g_WinExecReturn = WinExec(szCommandToRun, SW_SHOW);

    if (g_WinExecReturn < 32)
    {
        // we failed on running it.
        PopUpUnableToSomething(szCommandToRun, IDS_UNABLE_TO_RUN);
        return FALSE;
    }

    GetModuleFileName(NULL, g_szWinExecModuleName, sizeof(g_szWinExecModuleName));

    return TRUE;
}


//***************************************************************************
//*
//* purpose: return TRUE if the window has started
//*
//***************************************************************************
int HasTheAppStarted(void)
{
    // do a findwindow for our setup window to
    // see if our setup has started...
    // if it has then return TRUE,  if not return FALSE.
    if (g_WinExecReturn >= 32)
    {
        if (GetModuleHandle(g_szWinExecModuleName))
        {
          return TRUE;
        }
    }

    return FALSE;
}

//***************************************************************************
//*
//* purpose: TRUE if the file is opened, FALSE if the file does not exists.
//*
//***************************************************************************
int CheckIfFileExists (char * szFileName)
{
    char svTemp1[_MAX_PATH];
    char *pdest = NULL;
    char *pTemp = NULL;

    if ( strlen( szFileName ) > sizeof( svTemp1 ) )
    {
        return FALSE;
    }

    strcpy(svTemp1, szFileName);
    // cut off the trailing \ if need to
    pdest = svTemp1;

    if (*(pdest + (strlen(pdest) - 1)) == '\\')
    {
        pTemp = strrchr(svTemp1, '\\');
        if (pTemp)
	      {
            *pTemp = '\0';
        }
    }

    if ( (_access(svTemp1,0) ) != -1 )
    {
      return TRUE;
    }
    else
    {
      return FALSE;
    }
}

//***************************************************************************
//*
//* purpose: display message that we were unable to runthe exe
//*
//***************************************************************************
void PopUpUnableToSomething(char g_szFilepath[], int WhichString_ID)
{
    char szTempString[_MAX_PATH];

    LoadString( g_hInstance, WhichString_ID, g_szMsg, _MAX_PATH );

    if ( ( strlen( g_szMsg ) + strlen( g_szFilepath ) ) > sizeof( szTempString ) )
    {
      return;
    }

    sprintf(szTempString, g_szMsg, g_szFilepath);

    MessageBox(NULL, szTempString, NULL, MB_ICONSTOP);

    return;
}

//***************************************************************************
//*
//* purpose: add's filename onto path
//*
//***************************************************************************
void AddPath(LPSTR szPath, LPCSTR szName )
{
    LPSTR szTmp;
    // Find end of the string
    szTmp = szPath + lstrlen(szPath);
    // If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';
    // Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpy( szTmp, szName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\basefunc.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        basefunc.cxx

   Abstract:

        This is the abstract base class that is used as the base for all
        the other functions

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"

// function: VerifyParameters
//
// verify the parameters are correct
//
BOOL
CBaseFunction::VerifyParameters(CItemList &ciParams)
{

  // By default, do not check parameters
  return TRUE;
}

// function: LoadParams
//
// Load the parameters into the internal variable
//
BOOL 
CBaseFunction::LoadParams(CItemList &ciList, LPTSTR szParams)
{
  return ciList.LoadList(szParams);
}

// function: DoWork
//
//
// Parameters:
//   szParams - LPTSTR list of parameter seperated by '|'
//   dwFunctionId - Id of function, this is the oe that was set
//                  in AddMethods
//
// Load the parameters, then call the function to verify the 
// parameters, then call the private function to do all the work
//
BOOL 
CBaseFunction::DoWork(LPTSTR szParams)
{
  CItemList ciParams;

  if (!LoadParams(ciParams, szParams))
  {
    // We could not load the parameters
    return FALSE;
  }

  if (!VerifyParameters(ciParams))
  {
    // the parameters are not correct, return FALSE
    return FALSE;
  }

  return DoInternalWork(ciParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\acl.cxx ===
#include "stdafx.h"
#include "acl.hxx"
#include "dcomperm.h"
#include "Sddl.h"

// Constructor
//
CSecurityDescriptor::CSecurityDescriptor()
{
  m_bSDValid = FALSE;

  // Initialize DAcl to NULL
  m_pDAcl = NULL;
  m_pOwner = NULL;
  m_pGroup = NULL;

  // Initialize SA
  m_SA.nLength = sizeof( SECURITY_ATTRIBUTES );
  m_SA.lpSecurityDescriptor = &m_SD;
  m_SA.bInheritHandle = FALSE;

  // Do all the resetting logic in ResetSD
  ResetSD();
}

// Desctructor
//
CSecurityDescriptor::~CSecurityDescriptor()
{
  // Reset SD, so everything is freed
  ResetSD();
}

// InitializeSD
// 
// Intialize the SD, and either fail or succeeded.  If it
// is already initialized, then we NOP.  This is so that
// the user does not need to call initialize themselves, 
// we can do it automatically for them
//
BOOL 
CSecurityDescriptor::InitializeSD()
{
  if ( !m_bSDValid )
  {
    // At this point, nothing should have been done to the ACL, or
    // there is an error
    ASSERT( m_pDAcl == NULL );

    // Not initalize yet, so lets do it.
    m_bSDValid = InitializeSecurityDescriptor( &m_SD, SECURITY_DESCRIPTOR_REVISION ) &&
                 SetSecurityDescriptorControl( &m_SD, SE_DACL_PROTECTED, SE_DACL_PROTECTED);
  }

  return m_bSDValid;
}

// SetDAcl
//
// Set the DAcl for the SD, and set the pDAcl internal pointer
//
BOOL 
CSecurityDescriptor::SetDAcl( PACL pAcl )
{
  BOOL bRet;

  // Try to set SD with correct DACL
  if ( pAcl )
  {
    // Set Security Descriptor
    bRet = SetSecurityDescriptorDacl( &m_SD, TRUE, pAcl, FALSE );
  }
  else
  {
    // Clear it since pAcl is NULL
    bRet = SetSecurityDescriptorDacl( &m_SD, FALSE, NULL, TRUE );
  }

  if ( bRet ) 
  {
    // If it was set correctly, then lets free the old pointer,
    // and set the new pointer accordingly
    if ( m_pDAcl )
    {
      LocalFree( m_pDAcl );
    }

    m_pDAcl = pAcl;
  }

  return bRet;
}

// SetOwner
//
// Set the owner of the SD
//
BOOL 
CSecurityDescriptor::SetOwner( PSID pSid )
{
  if ( !InitializeSD() )
  {
    return FALSE;
  }

  if ( !SetSecurityDescriptorOwner( &m_SD, pSid, FALSE ) )
  {
    // Failed to Set
    return FALSE;
  }

  m_pOwner = pSid;

  return TRUE;
}

// SetGroup
//
// Set the group for the SD
//
BOOL 
CSecurityDescriptor::SetGroup( PSID pSid )
{
  if ( !InitializeSD() )
  {
    return FALSE;
  }

  if ( !SetSecurityDescriptorGroup( &m_SD, pSid, FALSE ) )
  {
    // Failed to Set
    return FALSE;
  }

  m_pGroup = pSid;

  return TRUE;
}

// ResetSD
//
// Reset the SD by removing everything inside of it.  Return it to
// its original State.
// If you want, you can call this in the begining, just to make sure the 
// initialization worked.
//
BOOL 
CSecurityDescriptor::ResetSD()
{
  if ( !InitializeSD() )
  {
    return FALSE;
  }

  // Initialize to ACL not inheritted
  m_bDAclIsInheritted = FALSE;

  if ( m_pOwner )
  {
    FreeSid( m_pOwner );
    m_pOwner = NULL;
  }

  if ( m_pGroup ) 
  {
    FreeSid( m_pGroup );
    m_pGroup = NULL;
  }

  return SetDAcl( NULL );
}

// CreateAdminDAcl
//
// This is a wrapper function, that just creates an Admin DAcl.  What
// this means is that we create an ACL that ONLY allows
// Administrators and Local System, and allow them FULL access
//
BOOL 
CSecurityDescriptor::CreateAdminDAcl( BOOL bIheritable )
{
  return AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS,
                                    CSecurityDescriptor::ACCESS_FULL,
                                    TRUE,
                                    bIheritable ) &&
         AddAccessAcebyWellKnownID( CSecurityDescriptor::USER_LOCALSYSTEM,
                                    CSecurityDescriptor::ACCESS_FULL,
                                    TRUE,
                                    bIheritable ); 
}

// GetCurrentDAcl
//
// Return a ppointer to the current DAcl
//
PACL
CSecurityDescriptor::GetCurrentDAcl()
{
  return m_pDAcl;
}

// UpdateDACLwithNewACE
//
// Update the DACL with a new ACE.  Based on the AccessMode, this can be used to:
//   1) Add Deny or Allow Ace's
//   2) Remove Ace's
//
BOOL 
CSecurityDescriptor::UpdateDACLwithNewACE( TRUSTEE_FORM TrusteeForm, LPTSTR szTrusteeName, 
                                           DWORD dwAccess, ACCESS_MODE dwAccessMode, 
                                           DWORD dwInheitance)
{
  PACL                  pNewDacl = NULL;
  EXPLICIT_ACCESS       ea;
  BOOL                  bRet = TRUE;

  if ( !InitializeSD() )
  {
    // Count not initialize SD
    return FALSE;
  }

  ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

  ea.grfAccessPermissions = dwAccess;
  ea.grfAccessMode = dwAccessMode;
  ea.grfInheritance = dwInheitance;
  ea.Trustee.TrusteeForm = TrusteeForm;
  ea.Trustee.ptstrName = szTrusteeName;

  if ( SetEntriesInAcl(1, &ea, GetCurrentDAcl(), &pNewDacl) != ERROR_SUCCESS )
  {
    // Failed to Set Acl
    return FALSE;
  }

  if ( !SetDAcl( pNewDacl ) )
  {
    // We could not set it, so lets free it, and fail
    LocalFree( pNewDacl );
    bRet = FALSE;
  }

  return bRet;
}

// QueryEffectiveRightsForTrustee
//
// Query the effective rights for a Trustee
//
// Parameters:
//   dwTrustee - The trustee to query for
//   pAccessMask - [out] The effective AccessMask
//
// Return Values:
//   TRUE - Success
//   FALSE - Failure
BOOL 
CSecurityDescriptor::QueryEffectiveRightsForTrustee( DWORD dwTrustee,
                                                     PACCESS_MASK pAccessMask )
{
  PSID      pSid;
  TRUSTEE   Trustee;
  BOOL      bRet;

  pSid = CreateWellKnowSid( dwTrustee );

  if ( !pSid )
  {
    // Failed to create sid, so fail
    return FALSE;
  }

  // Query Trustee information
  Trustee.pMultipleTrustee = NULL;
  Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  Trustee.TrusteeForm = TRUSTEE_IS_SID;
  Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
  Trustee.ptstrName = (LPTSTR) pSid;

  bRet = GetEffectiveRightsFromAcl( GetCurrentDAcl(),
                                    &Trustee,
                                    pAccessMask ) == ERROR_SUCCESS;

  FreeSid( pSid );

  return bRet;
}

// AddAccessAceByName
//
// Add either an Access Allowed or Access Denied ACE to this ACL
//
// Parameters:
//   szName - The name of the user or group to be added to the ACL
//   dwAccess - The access mask to be applied
//   bAllow - If TRUE then added Allow ACE, if FALSE, then add Deny ACE
//   bInherit - Should this be inherited by children
//
BOOL 
CSecurityDescriptor::AddAccessAcebyName( LPTSTR szName, DWORD dwAccess, BOOL bAllow /*= TRUE*/ , BOOL bInherit /*= FALSE*/ )
{
  return UpdateDACLwithNewACE( TRUSTEE_IS_NAME,       // Trustee is a name
                               szName,                // Username/Group
                               dwAccess,              // Access
                               bAllow ? SET_ACCESS: DENY_ACCESS,
                               bInherit ? ( OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ) : NO_INHERITANCE);
}

// AddAccessAcebyStringSid
//
// Add an Access ace to the SD by it's string SID
//
BOOL 
CSecurityDescriptor::AddAccessAcebyStringSid( LPTSTR szStringSid, 
                                              DWORD dwAccess, 
                                              BOOL bAllow /* = TRUE */ , 
                                              BOOL bInherit /* = FALSE */ )
{
  PSID pSid;
  BOOL bRet;

  if ( !ConvertStringSidToSid( szStringSid, &pSid ) )
  {
    // Failed to convert to String Sid
    return FALSE;
  }

  bRet = UpdateDACLwithNewACE( TRUSTEE_IS_SID,        // Trustee is a name
                               (LPTSTR) pSid,         // SID
                               dwAccess,              // Access
                               bAllow ? SET_ACCESS: DENY_ACCESS,
                               bInherit ? ( OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ) : NO_INHERITANCE);

  // Free the Sid that was returned
  LocalFree( pSid );

  return bRet;
}


// RemoveAccessAcebyName
//
// Remove all DAcl's in our current DAcl for the particular name
// specified
//
BOOL 
CSecurityDescriptor::RemoveAccessAcebyName( LPTSTR szName ,BOOL bInherit /*= FALSE*/ )
{
  BOOL  bUserExisted = TRUE;   
  DWORD dwReturn = ERROR_SUCCESS;

  if ( !m_pDAcl )
  {
    // If there is no ACL, then we don'e have to worry about 
    // removing this ACE for it.
    return TRUE;
  }
  
  while ( bUserExisted &&
          ( dwReturn == ERROR_SUCCESS ) )
  {
    dwReturn = RemovePrincipalFromACL( m_pDAcl, szName, &bUserExisted );
  }

  return ( dwReturn == ERROR_SUCCESS );
}

// AddAccessAcebyWellKnownID
//
// Add either an Access Allowed or Access Denied ACE to this ACL for a Well Know 
// User or Group
//
// Parameters:
//   dwID - The id of the User/Group to be added (taken from the const in this class)
//   dwAccess - The access mask to be applied
//   bAllow - If TRUE then added Allow ACE, if FALSE, then add Deny ACE
//   bInherit - Should this be inherited by children
//
BOOL 
CSecurityDescriptor::AddAccessAcebyWellKnownID( DWORD dwID, DWORD dwAccess, BOOL bAllow /*= TRUE*/ , BOOL bInherit /*= FALSE*/ )
{
  BOOL                  bRet = TRUE;
  PSID                  pSid;

  pSid = CreateWellKnowSid( dwID );

  if ( !pSid )
  {
    return FALSE;
  }

  bRet = UpdateDACLwithNewACE( TRUSTEE_IS_SID,        // Trustee is a name
                               (LPTSTR) pSid,         // SID
                               dwAccess,              // Access
                               bAllow ? SET_ACCESS: DENY_ACCESS,
                               bInherit ? ( OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ) : NO_INHERITANCE);

  FreeSid( pSid );

  return bRet;
}

// SetOwnerbyWellKnownID
//
// Set the Ownder of the SD by Well Know ID
//
BOOL 
CSecurityDescriptor::SetOwnerbyWellKnownID( DWORD dwID )
{
  BOOL                  bRet = TRUE;
  PSID                  pSid;

  pSid = CreateWellKnowSid( dwID );

  if ( !pSid )
  {
    return FALSE;
  }

  bRet = SetOwner( pSid );

  if ( !bRet )
  {
    // Failed, so must set ourself
    FreeSid( pSid );
  }

  return bRet;
}

// SetGroupbyWellKnownID
//
// Set the Group of the SD by Well Know ID
//
BOOL 
CSecurityDescriptor::SetGroupbyWellKnownID( DWORD dwID )
{
  BOOL                  bRet = TRUE;
  PSID                  pSid;

  pSid = CreateWellKnowSid( dwID );

  if ( !pSid )
  {
    return FALSE;
  }

  bRet = SetGroup( pSid );

  if ( !bRet )
  {
    // Failed, so must set ourself
    FreeSid( pSid );
  }

  return bRet;
}

// QuerySD
//
// Query a pointer to the Security Descriptor
//
PSECURITY_DESCRIPTOR 
CSecurityDescriptor::QuerySD()
{
  // We should not call this, before doing some work
  ASSERT( m_bSDValid );

  if ( !m_bSDValid )
  {
    // Return NULL, since the SD is not valid
    return NULL;
  }

  return &m_SD;
}

// QuerySA
//
// Query a pointer to the Security Attributes, created for this SD
//
PSECURITY_ATTRIBUTES 
CSecurityDescriptor::QuerySA()
{
  // We should not call this, before doing some work
  ASSERT( m_bSDValid );

  return &m_SA;
}

// CreateSidFromName
//
// Create a Sid for the user givem
//
/*BOOL
CSecurityDescriptor::CreateSidFromName( LPTSTR szTrustee )
{



}
*/

// CreateWellKnownSid
//
// Create a Well know sid, so that we can use it in the other functions
// to change ACL's
//
PSID 
CSecurityDescriptor::CreateWellKnowSid( DWORD dwId )
{
  SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
  SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
  PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
  DWORD dwCount = 0;
  DWORD dwRID[8];
  BOOL  bRet = TRUE;
  PSID  pSid = NULL;

  // Clear dwRID
  memset(&(dwRID[0]), 0, sizeof(dwRID));

  switch ( dwId )
  {
  case GROUP_ADMINISTRATORS:
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    dwRID[dwCount++] = SECURITY_BUILTIN_DOMAIN_RID;
    dwRID[dwCount++] = DOMAIN_ALIAS_RID_ADMINS;
    break;
  case GROUP_USERS:
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    dwRID[dwCount++] = SECURITY_BUILTIN_DOMAIN_RID;
    dwRID[dwCount++] = DOMAIN_ALIAS_RID_USERS;
    break;
  case USER_LOCALSYSTEM:
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    dwRID[dwCount++] = SECURITY_LOCAL_SYSTEM_RID;
    break;
  case USER_LOCALSERVICE:
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    dwRID[dwCount] = SECURITY_LOCAL_SERVICE_RID;
    break;
  case USER_NETWORKSERVICE:
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    dwRID[dwCount++] = SECURITY_NETWORK_SERVICE_RID;
    break;
  case USER_EVERYONE:
    pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
    dwRID[dwCount++] = SECURITY_WORLD_RID;
    break;
  default:
    bRet = FALSE;
  }

  if ( bRet )
  {
    bRet = AllocateAndInitializeSid(  pSidIdentifierAuthority, 
                                      (BYTE)dwCount, 
		                                  dwRID[0], 
		                                  dwRID[1], 
		                                  dwRID[2], 
		                                  dwRID[3], 
		                                  dwRID[4], 
		                                  dwRID[5], 
		                                  dwRID[6], 
		                                  dwRID[7], 
                                      &pSid );
  }

  if ( !bRet )
  {
    if ( pSid )
    {
      FreeSid( pSid );
    }

    return NULL;
  }

  return pSid;
}

// SetSecurityInfoOnHandle
// 
// Explicity set the SecurityInfo on the Handle Given
//
BOOL 
CSecurityDescriptor::SetSecurityInfoOnHandle( HANDLE hHandle, SE_OBJECT_TYPE ObjectType, BOOL bAllowInheritance )
{
  // At ths point our SD should be valid
  ASSERT( m_bSDValid );

  if ( m_bDAclIsInheritted )
  {
    // Even though they say not to use inheritance, we retrieved an ACL
    // which was inheritted.  So if we don't set with inheritted, the 
    // ACL will be different
    bAllowInheritance = TRUE;
  }

  return ( SetSecurityInfo( hHandle,      // The Handle
                            ObjectType,   // Object type
                            DACL_SECURITY_INFORMATION | 
                            ( bAllowInheritance ? UNPROTECTED_DACL_SECURITY_INFORMATION :
                                                  PROTECTED_DACL_SECURITY_INFORMATION ),
                            NULL,         // Owner Sid
                            NULL,         // Group Sid
                            GetCurrentDAcl(),  // DAcl
                            NULL ) ==       // SAcl
           ERROR_SUCCESS );
}

// SetSecurityInfoonFile
//
// Explicity set the Security Info on a File
//
// (If you do not want it to fail on file not existing, call SetSecurityInfoonFiles)
//
BOOL 
CSecurityDescriptor::SetSecurityInfoOnFile( LPTSTR szFile, BOOL bAllowInheritance )
{
  HANDLE  hFile;
  BOOL    bRet;

  hFile = CreateFile( szFile,
                      WRITE_DAC|READ_CONTROL,
                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                      NULL,                               // No need for security, since it won't do what we want anyways
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
                      NULL );

  if ( hFile == INVALID_HANDLE_VALUE )
  {
    // Failed to open File
    return FALSE;
  }

  bRet = SetSecurityInfoOnHandle( hFile, SE_FILE_OBJECT, bAllowInheritance );

  CloseHandle( hFile );

  return bRet;
}

// SetSecurityInfoonFiles
//
// Explicity set the Security Info on a Multiple Files
// The regular wildcard semantics to specify the files (ie. metbase*.xml)
//
// Note: Use this function, instead of SetSecurityInfoonFile if you do not
//       want it to fail if the file does not exist.  This will ignore such 
//       errors.
//
BOOL 
CSecurityDescriptor::SetSecurityInfoOnFiles( LPTSTR szFile, BOOL bAllowInheritance )
{
  BOOL            bRet = TRUE;
  HANDLE          hFiles;
  WIN32_FIND_DATA fd;
  TSTR_PATH       strFileName;
  TSTR_PATH       strPath;
  LPTSTR          szLastSlash;

  if ( !strPath.Copy( szFile ) )
  {
    return FALSE;
  }

  szLastSlash = _tcsrchr( strPath.QueryStr(), _T('\\') );

  if ( szLastSlash != NULL )
  {
    // Lets find the path (ie. c:\foo\test* -> c:\foo, c:\foo\test -> c:\foo)
    *szLastSlash = '\0';
  }

  hFiles = FindFirstFile( szFile, &fd );

  if ( hFiles == INVALID_HANDLE_VALUE )
  {
    if ( ( GetLastError() == ERROR_FILE_NOT_FOUND ) ||
         ( GetLastError() == ERROR_PATH_NOT_FOUND ) ||
         ( GetLastError() == ERROR_NO_MORE_FILES ) )
    {
      // If this is the case, then there is nothing to acl
      // so return success
      return TRUE;
    }

    // Failed to find the first instance of the file
    return FALSE;
  }

  do {
    if ( ( _tcscmp( fd.cFileName, _T(".") ) == 0 ) ||
         ( _tcscmp( fd.cFileName, _T("..") ) == 0 ) )
    {
      // Ignore the . and .. dirs
      continue;
    }

    if ( !strFileName.Copy( strPath ) ||
         !strFileName.PathAppend( fd.cFileName ) ||
         !SetSecurityInfoOnFile( strFileName.QueryStr() , bAllowInheritance ) )
    {
      // Failed to set ACL
      bRet = FALSE;
    }

  } while ( FindNextFile( hFiles, &fd ) );

  FindClose( hFiles );

  return ( bRet &&
           ( GetLastError() == ERROR_NO_MORE_FILES ) );
}

// DuplicateACL
//
// Take an ACL, and Duplicate it
//
// Note: This will NOT duplicate the inheritted items in the ACL
//
// Parameters:
//   pSourceAcl       [in] - The ACL to Duplicate
//   pNewlyCreateAcl [out] - The ACL that has been created as a duplicated
//                           NOTE: If we return TRUE, this must be free'd with LocalFree
// Return Values:
//   FALSE - Failed to duplicate
//   TRUE  - Success (don't forget to free)
BOOL 
CSecurityDescriptor::DuplicateACL( PACL pSourceAcl, PACL *pNewlyCreateAcl )
{
  BOOL                  bRet = FALSE;
  PEXPLICIT_ACCESS      pEA;
  ULONG                 lNumberofEntries;

  if ( GetExplicitEntriesFromAcl( pSourceAcl, &lNumberofEntries, &pEA ) == ERROR_SUCCESS )
  {
    if ( SetEntriesInAcl( lNumberofEntries, pEA, NULL, pNewlyCreateAcl ) == ERROR_SUCCESS )
    {
      if ( *pNewlyCreateAcl == NULL )
      {
        // All the entries were inheritted, so create an empty ACL, instead
        // or returning NULL!
        *pNewlyCreateAcl = ( PACL ) LocalAlloc( LMEM_FIXED, sizeof(ACL) );

        if ( *pNewlyCreateAcl &&
             InitializeAcl( *pNewlyCreateAcl, sizeof(ACL) , ACL_REVISION ) )
        {
          bRet = TRUE;
        }

        if ( !bRet &&
             ( *pNewlyCreateAcl != NULL ) )
        {
          // Free memory on failure
          LocalFree( *pNewlyCreateAcl );
          *pNewlyCreateAcl = NULL;
        }
      }
      else
      {
        // Acl was created
        bRet = TRUE;
      }
    }

    LocalFree( pEA );
  }

  return bRet;
}

// IsInerittedAcl
//
// Determines if the acl was inheritted by a parent?
//
// This is important, because when we duplicate an ACL, it does not
// duplicate the inheritted ACE's, so when we set it, we must say to
// inherit the ACE's from parent
//
// Parameters
//   pSourceAcl - The Acl to test.  NULL is valid here.
//
// Return Values:
//   TRUE - It is inheritting from parent
//   FALSE - It is not inheritting from parent
//
BOOL 
CSecurityDescriptor::IsInherittedAcl( PACL pSourceAcl )
{
  BOOL        bIsInheritted = FALSE;
  LPVOID      pAce;
  ACE_HEADER  *pAceHeader;
  DWORD       dwCurrentAce = 0;

  if ( !pSourceAcl )
  {
    // If a NULL Acl is specified, then it is not inheritted,
    // since it has nothing in it.
    return FALSE;
  }

  while ( !bIsInheritted &&
          GetAce( pSourceAcl, dwCurrentAce, &pAce ) )
  {
    dwCurrentAce++;
    pAceHeader = (ACE_HEADER *) pAce;

    if ( pAceHeader->AceFlags & INHERITED_ACE )
    {
      // This ACE was inheritted, so mark it as such
      bIsInheritted = TRUE;
    }
  }

  return bIsInheritted;
}

// GetSecurityInfoOnHandle
// 
// Retrieve the security Information for a particular Handle
//
BOOL 
CSecurityDescriptor::GetSecurityInfoOnHandle( HANDLE hHandle, SE_OBJECT_TYPE ObjectType )
{
  BOOL                  bRet;
  PACL                  pDAcl;
  PACL                  pNewDAcl = NULL;
  PSECURITY_DESCRIPTOR  pSD;
  
  if ( !InitializeSD() )
  {
    // Count not initialize SD
    return FALSE;
  }

  bRet = GetSecurityInfo( hHandle,      // The Handle
                          ObjectType,   // Object type
                          DACL_SECURITY_INFORMATION,  // right now only retrieve security info
                          NULL,         // Owner Sid
                          NULL,         // Group Sid
                          &pDAcl,        // DAcl
                          NULL,         // SAcl
                          &pSD ) == ERROR_SUCCESS;

  if ( bRet )
  {
    // This duplication does not copy inherited ACL's, only those
    // explicity set on this item, thus we must make sure that the
    // set does inherit acl's
    bRet = DuplicateACL( pDAcl, &pNewDAcl );

    if ( bRet &&
         !SetDAcl( pNewDAcl ) )
    {
      // Failed to set DAcl
      LocalFree( pNewDAcl);
      bRet = FALSE;
    }

    if ( bRet )
    {
      // Since during the duplication, we lost the inheritted acl's
      // we must set that bit now
      m_bDAclIsInheritted = IsInherittedAcl( pDAcl );
    }

    // Free the Sources Descriptor since we don't use it
    LocalFree(pSD);
  }

  return bRet;
}

BOOL 
CSecurityDescriptor::GetSecurityInfoOnFile( LPTSTR szFile )
{
  HANDLE  hFile;
  BOOL    bRet;

  hFile = CreateFile( szFile,
                      READ_CONTROL,
                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                      NULL,                               // No need for security, since it won't do what we want anyways
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
                      NULL );

  if ( hFile == INVALID_HANDLE_VALUE )
  {
    // Failed to open File
    return FALSE;
  }

  bRet = GetSecurityInfoOnHandle( hFile, SE_FILE_OBJECT );

  CloseHandle( hFile );

  return bRet;
}

// DuplicateSD
//
// Duplicate the security descriptor that is send in, into
// our class
//
BOOL 
CSecurityDescriptor::DuplicateSD( PSECURITY_DESCRIPTOR pSD )
{
  SECURITY_DESCRIPTOR_CONTROL sdc;
  PACL                        pOldAcl;
  PACL                        pNewAcl;
  BOOL                        bAclPresent;
  BOOL                        bAclDefaulted;
  DWORD                       dwVersion;

  if ( !InitializeSD() )
  {
    // Count not initialize SD
    return FALSE;
  }

  if ( !GetSecurityDescriptorControl( pSD, &sdc, &dwVersion ) ||
       !SetSecurityDescriptorControl( &m_SD, 
				      SE_DACL_AUTO_INHERIT_REQ |  // Mask of bits to set
				      SE_DACL_AUTO_INHERITED |
				      SE_DACL_PROTECTED |
				      SE_SACL_AUTO_INHERIT_REQ |
				      SE_SACL_AUTO_INHERITED |
				      SE_SACL_PROTECTED,
				      sdc ) )
  {
    // Failed to get current Security Descriptor Control, 
    // or to set it
    return FALSE;
  }
  
  if ( !GetSecurityDescriptorDacl( &m_SD, &bAclPresent, &pOldAcl, &bAclDefaulted ) )
  {
    // Failed to get acl from old SD
    return FALSE;
  }

  if ( bAclPresent )
  {
    // If ACL is present, we must duplicate and set for current
    if ( !DuplicateACL( pOldAcl, &pNewAcl ) )
    {
      // Failed to duplicate DACL
      return FALSE;
    }

    if ( !SetDAcl( pNewAcl ) )
    {
      // Failed to set as current, so must delete pointer
      delete pNewAcl;
      return FALSE;
    }
  }

  return TRUE;
}

// CreateSelfRelativeSD
//
// Create a SelfRelative Source Descriptor
//
// Parameters:
//   pBuff - [in/out] Pointer to a BUFFER object as input.  It is
//                    filled with the contents of the SD, so it does
//                    not have to be freed
//   pdwSize = [out] The length of the SD inside pBuff
//
BOOL 
CSecurityDescriptor::CreateSelfRelativeSD( BUFFER *pBuff, LPDWORD pdwSize )
{
  DWORD dwSize = 0;

  ASSERT( pdwSize != NULL );
  ASSERT( pBuff != NULL );

  if ( MakeSelfRelativeSD( &m_SD, NULL, &dwSize ) ||
       !pBuff->Resize( dwSize ) )
  {
    // Either MakeSelfRelative did not fail as we expected with
    // the size, or Resize failed
    return FALSE;
  }

  if ( !MakeSelfRelativeSD( &m_SD,
			    (PSECURITY_DESCRIPTOR) pBuff->QueryPtr(),
			    &dwSize ) )
  {
    // Failed to make self relative
    return FALSE;
  }

  *pdwSize = dwSize;

  return TRUE;
}

// CreateDirectoryWithSA
//
// Create a Directory with a specific ACL.  If the directory already exists,
// then change the acl, and succeed.
//
BOOL CreateDirectoryWithSA( LPTSTR szPath, CSecurityDescriptor &pSD, BOOL bAllowInheritance )
{
  BOOL bRet;

  // Check if the directory exists
  if ( IsFileExist( szPath ) )
  {
    // If it exists, then set ACL's on it
    bRet = pSD.SetSecurityInfoOnFile( szPath, bAllowInheritance );
  }
  else
  {
    // Create Directory with ACL's we specified
    bRet = CreateDirectory( szPath, pSD.QuerySA() );
  }

  return bRet;
}

// DoesFileSystemSupportACLs
// 
// Does the File System Supplied here support ACLs
//
BOOL
CSecurityDescriptor::DoesFileSystemSupportACLs( LPTSTR szPath, LPBOOL pbSupportAcls )
{
  TSTR_PATH     strDrivePath;
  DWORD         dwSystemFlags;

  ASSERT( szPath );

  if ( !strDrivePath.Copy( szPath ) ||
       !strDrivePath.PathAppend( _T("") ) ||
       ( strDrivePath.QueryLen() < 3 ) )
  {
    return FALSE;
  }

  // Null terminate drive
  *( strDrivePath.QueryStr() + 3 ) = _T('\0');

  if ( !GetVolumeInformation( strDrivePath.QueryStr(),
                              NULL,         // Volume Name Buffer
                              0,            // Size of Buffer
                              NULL,         // Serial Number Buffer
                              NULL,         // Max Component Lenght
                              &dwSystemFlags,  // System Flags
                              NULL,         // FS Type
                              0 ) )
  {
    // Failed to do query
    return FALSE;
  }

  *pbSupportAcls = ( dwSystemFlags & FS_PERSISTENT_ACLS ) != 0;

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\acshim.h ===
#pragma once

extern "C"
{
#include <shimdb.h>
}

#include "tstr.hxx"

struct sExtensionItem
{
  TSTR           strName;
  BOOL           bExists;
  sExtensionItem *pNext;
};

class CExtensionList 
{
private:
  DWORD          m_dwNumberofItems;
  sExtensionItem *m_pRoot;
  BOOL           m_bUseIndicatorFile;
  BOOL           m_bIndicatorFileExists;

  sExtensionItem *RetrieveItem( DWORD dwIndex );
public:
  CExtensionList();
  ~CExtensionList();

  BOOL  AddItem( LPTSTR szPath, BOOL bExists );
  DWORD QueryNumberofItems();
  BOOL  QueryItem( DWORD dwIndex, TSTR *pstrPath, LPBOOL pbExists);
  BOOL  DoesAnItemExist();
  BOOL  SetIndicatorFile( LPTSTR szIndicatorFile );
};

BOOL ProcessIISShims();
BOOL ProcessAppCompatDB( PDB hCompatDB );
BOOL ProcessExeTag( PDB hCompatDB, TAGID tagExe );
BOOL ProcessShimTag( PDB hCompatDB, TAGID tagShim );
BOOL GetBasePath( TSTR_PATH *pstrBasePath, PDB hCompatDB, TAGID tagShim );
BOOL GetBasePathFromRegistry( TSTR_PATH *pstrBasePath, TSTR &strFullRegPath );
BOOL RetrieveRegistryString( TSTR_PATH *pstrValue,
                             TSTR &strRegBase,
                             TSTR &strRegPath,
                             TSTR &strRegName );
BOOL BuildExtensionList( PDB hCompatDB, 
                         TAGID tagShim, 
                         LPTSTR szBasePath, 
                         CExtensionList *pExtensions );
BOOL InstallAppInMB( PDB hCompatDB, TAGID tagShim, CExtensionList &ExtensionList );
BOOL IsIISShim( PDB hCompatDB, TAGID tagCurrentTag );
BOOL GetValueFromName( TSTR *pstrValue, PDB hCompatDB, TAGID tagData, LPCTSTR szTagName );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\acshim.cpp ===
#include "StdAfx.h"
#include "ACShim.h"
#include <secconlib.h>
#include <shlwapi.h>
#include "reg.hxx"

// Undef PathAppend, or TSTR::PathAppend will not work
#undef PathAppend

// ProcessIISShims
//
// Open the app compat database and process all the IIS
// entries
//
BOOL 
ProcessIISShims()
{
  PDB       hCompatDB  = NULL;
  BOOL      bRet       = TRUE;
  TSTR_PATH strCompatDB;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Processeing AppCompat DB.\n") ) );

  if ( !strCompatDB.RetrieveWindowsDir() ||
       !strCompatDB.PathAppend( APPCOMPAT_DBNAME ) )
  {
    // Failed to create path
    return FALSE;
  }

  hCompatDB = SdbOpenDatabase( strCompatDB.QueryStr(), DOS_PATH );

  if ( hCompatDB == NULL )
  {
    // Failed to open DB
    return FALSE;
  }

  bRet = ProcessAppCompatDB( hCompatDB );

  SdbCloseDatabase( hCompatDB );

  return bRet;
}

// ProcessAppCompatDB
//
// Loop through all of the App Compat entries, and process
// the ones that are IIS's
//
BOOL
ProcessAppCompatDB( PDB hCompatDB )
{
  TAGID   tagDB;
  TAGID   tagExe;
  BOOL    bRet = TRUE;
  HRESULT hrCoInit;

  tagDB	= SdbFindFirstTag( hCompatDB, TAGID_ROOT, TAG_DATABASE );

  if ( tagDB == NULL )
  {
    // Failed to open DB
    return FALSE;
  }

  hrCoInit = CoInitialize( NULL );

  if ( FAILED( hrCoInit ) )
  {
    iisDebugOut((LOG_TYPE_WARN, _T("Failed to CoInitialize to process AppCompat tag's, hr=0x%8x.\n"), hrCoInit));
    return FALSE;
  }

  tagExe	= SdbFindFirstTag( hCompatDB, tagDB, TAG_EXE );

  while( tagExe != NULL )
  {
    if ( !ProcessExeTag( hCompatDB, tagExe ) )
    {
      // Failed to process tag
      iisDebugOut((LOG_TYPE_WARN, _T("Failed to process AppCompat EXE tag.\n")));
      bRet = FALSE;
    }

    // Get the next one
    tagExe = SdbFindNextTag( hCompatDB, tagDB, tagExe );
  }

  CoUninitialize(); 

  return bRet;
}

// ProcessExeTag
//
// Process All of the Exe Tags that we have
//
BOOL
ProcessExeTag( PDB hCompatDB, TAGID tagExe )
{
  TAGID tagExeInfo;
  BOOL  bRet = TRUE;

  tagExeInfo = SdbGetFirstChild( hCompatDB, tagExe );

  while ( tagExeInfo != NULL )
  {
    if ( IsIISShim( hCompatDB, tagExeInfo ) )
    {
      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Processing IIS Exe AppCompat Info tag.\n")));

      if ( !ProcessShimTag( hCompatDB, tagExeInfo ) )
      {
        iisDebugOut((LOG_TYPE_WARN, _T("Failed to process AppCompat EXE Info tag.\n")));
        bRet = FALSE;
      }
    }

    // Get next tag
    tagExeInfo = SdbGetNextChild( hCompatDB, tagExe, tagExeInfo );
  }

  return bRet;
}

// ProcessShimTag
//
// Process the Shim Tag
//
BOOL 
ProcessShimTag( PDB hCompatDB, TAGID tagShim )
{
  TSTR_PATH      strBasePath;
  CExtensionList ExtenstionList;

  if ( !GetBasePath( &strBasePath, hCompatDB, tagShim ) )
  {
    // This entry does not have a base path, so ignore
    return TRUE;
  }

  if ( !PathIsDirectory( strBasePath.QueryStr() ) )
  {
    // The directory does not exist, so it must not be installed
    return TRUE;
  }

  if ( !BuildExtensionList( hCompatDB, tagShim, strBasePath.QueryStr(), &ExtenstionList ) )
  {
    // Failed to construct List
    return FALSE;
  }

  if ( ExtenstionList.DoesAnItemExist() )
  {
    if ( !InstallAppInMB( hCompatDB, tagShim, ExtenstionList ) )
    {
      return FALSE;
    }
  }

  return TRUE;
}

// GetBasePath
//
// Get the Base Path for the Shim Tag we are talking about.
// This is either going to be a physical path or a registry entry with
// the path
//
BOOL 
GetBasePath( TSTR_PATH *pstrBasePath, PDB hCompatDB, TAGID tagShim )
{
  TSTR strDBPath;
  TSTR strType;

  ASSERT( hCompatDB != NULL );
  ASSERT( tagShim != NULL );

  if ( !GetValueFromName( &strDBPath, hCompatDB, tagShim, APPCOMPAT_TAG_BASEPATH ) ||
       !GetValueFromName( &strType, hCompatDB, tagShim, APPCOMPAT_TAG_PATHTYPE ) )
  {
    // Failed to get Base Path
    return FALSE;
  }

  if ( strType.IsEqual( APPCOMPAT_TYPE_PHYSICALPATH ) )
  {
    // This is a phsycial path, so expand environment variables and return
    if ( !pstrBasePath->Copy( strDBPath ) ||
         !pstrBasePath->ExpandEnvironmentVariables() )
    {
      // Failed
      return FALSE;
    }

    return TRUE;
  }

  // It is a registry key instead, so lets retrieve it
  return GetBasePathFromRegistry( pstrBasePath, strDBPath );
}

// GetBasePathFromRegistry
//
// Retrieve the Base Path for an entry, by reading the registry key
// that contains it
//
// Parameters
//   pstrBasePath - [out] The path from the registry
//   strFullRegPath - [in] The registry path to check
//
BOOL 
GetBasePathFromRegistry( TSTR_PATH *pstrBasePath, TSTR &strFullRegPath )
{
  TSTR   strRegBase;
  TSTR   strRegPath;
  TSTR   strRegName;
  LPTSTR szFirstSlash;
  LPTSTR szLastSlash;

  szFirstSlash = _tcschr( strFullRegPath.QueryStr(), _T('\\') );
  szLastSlash  = _tcsrchr( strFullRegPath.QueryStr(), _T('\\') );

  if ( ( szFirstSlash == NULL ) ||
       ( szLastSlash == NULL ) ||
       ( szLastSlash == szFirstSlash ) )
  {
    // If there are not atleast 2 '\'s then it is not a correct registry path
    return FALSE;
  }

  // Temporarily Null terminate strings
  *szFirstSlash = _T('\0');
  *szLastSlash = _T('\0');

  if ( !strRegBase.Copy( strFullRegPath.QueryStr() ) ||
       !strRegPath.Copy( szFirstSlash + 1 ) ||
       !strRegName.Copy( szLastSlash + 1 ) )
  {
    // Failed to copy path's
    *szFirstSlash = _T('\\');
    *szLastSlash = _T('\\');
    return FALSE;
  }

  // Insert back the slashes
  *szFirstSlash = _T('\\');
  *szLastSlash = _T('\\');

  return RetrieveRegistryString( pstrBasePath, strRegBase, strRegPath, strRegName );
}

// RetrieveRegistryString
//
// Retrieve a string from the registry
//
// Parameters:
//   pstrValue - [out] The value retrieved from the registry
//   strRegBase - [in] The base path, ie HKEY_LOCAL_MACHINE
//   strRegPath - [in] The path to the registry key
//   strRegName - [in] The name of the registry value
//
BOOL 
RetrieveRegistryString( TSTR_PATH *pstrValue,
                        TSTR &strRegBase,
                        TSTR &strRegPath,
                        TSTR &strRegName )
{
  CRegistry Reg;
  HKEY      hRoot;

  if ( strRegBase.IsEqual( APPCOMPAT_REG_HKLM, FALSE ) )
  {
    hRoot = HKEY_LOCAL_MACHINE;
  }
  else
    if ( strRegBase.IsEqual( APPCOMPAT_REG_HKCU, FALSE ) )
    {
      hRoot = HKEY_CURRENT_USER;
    }
    else
      if ( strRegBase.IsEqual( APPCOMPAT_REG_HKCR, FALSE ) )
      {
        hRoot = HKEY_CLASSES_ROOT;
      }
      else
        if ( strRegBase.IsEqual( APPCOMPAT_REG_HKU, FALSE ) )
        {
          hRoot = HKEY_USERS;
        }
        else
          if ( strRegBase.IsEqual( APPCOMPAT_REG_HKCC, FALSE ) )
          {
            hRoot = HKEY_CURRENT_CONFIG;
          }
          else
          {
            return FALSE;
          }

  if ( !Reg.OpenRegistry( hRoot, strRegPath.QueryStr(), KEY_READ ) )
  {
    // Failed to open registry
    return FALSE;
  }

  if ( !Reg.ReadValueString( strRegName.QueryStr(), pstrValue ) )
  {
    // Failed to read string from registry
    return FALSE;
  }

  return TRUE;
}

// BuildExtensionList
//
// Build the extension list from the Compat DB for this tag
//
// Parameters:
//   hCompatDB   - [in] Pointer to compat DB
//   tagShim     - [in] Tag to process
//   szBasePath  - [in] Base path for these extensions
//   pExtensions - [out] Extensions class to add them too
//   
BOOL
BuildExtensionList( PDB hCompatDB, 
                    TAGID tagShim, 
                    LPTSTR szBasePath, 
                    CExtensionList *pExtensions )
{
  TSTR_PATH strExtFullPath;
  TSTR      strExtensions;
  TSTR      strIndicatorFile;
  LPTSTR    szExtensions;
  LPTSTR    szNext;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Building extension list.\n") ) );

  if ( GetValueFromName( &strIndicatorFile,
                         hCompatDB,
                         tagShim,
                         APPCOMPAT_TAG_SETUPINDICATOR ) )
  {
    // SetupIndicator File is Set
    if ( !strExtFullPath.Copy( szBasePath ) ||
         !strExtFullPath.PathAppend( strIndicatorFile ) ||
         !pExtensions->SetIndicatorFile( strExtFullPath.QueryStr() ) )
    {
      // Failed to set indicator file
      return FALSE;
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Indicator File found, it is '%s'.\n"), strExtFullPath.QueryStr() ) );
  }

  if ( !GetValueFromName( &strExtensions,
                          hCompatDB,
                          tagShim,
                          APPCOMPAT_TAG_WEBSVCEXT ) )
  {
    // No WebSvcExtension to retrieve
    return TRUE;
  }

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Building extension list with '%s'.\n"), strExtensions.QueryStr() ) );

  // Get pointer to begining of list
  szExtensions = strExtensions.QueryStr();

  while ( szExtensions && *szExtensions )
  {
    szNext = _tcschr( szExtensions, _T(',') );

    if ( szNext )
    {
      *szNext = _T('\0');
      szNext++;
    }

    if ( !strExtFullPath.Copy( szBasePath ) ||
         !strExtFullPath.PathAppend( szExtensions ) )
    {
      // Failed to construct path
      return FALSE;
    }

    if ( !pExtensions->AddItem( strExtFullPath.QueryStr(), 
                                PathFileExists( strExtFullPath.QueryStr() ) ) )
    {
      // Failed to add item to list
      return FALSE;
    }

    szExtensions = szNext;
  }

  return TRUE;
}

// InstallAppInMB
//
// Installs the Application Extensions and dependencies into the metabase
// tagShim points to the Shim entry in the AppCompat DB where all App settings reside
//
BOOL 
InstallAppInMB( PDB hCompatDB, TAGID tagShim, CExtensionList &ExtensionList )
{
  TSTR strGroupId;
  TSTR strGroupDesc;
  TSTR strAppName;
  TSTR strExtGroups;
  TSTR strPath;
  BOOL bExists;
  CSecConLib Helper;
  DWORD i;
  BOOL bRet;
  HRESULT hr;

  // Ignore if we can not get this value, since it is not necessary
  GetValueFromName( &strExtGroups, hCompatDB, tagShim, APPCOMPAT_DB_ENABLE_EXT_GROUPS );

  if ( !GetValueFromName( &strGroupId, hCompatDB, tagShim, APPCOMPAT_DB_GROUPID ) ||
       !GetValueFromName( &strGroupDesc, hCompatDB, tagShim, APPCOMPAT_DB_GROUPDESC ) ||
       !GetValueFromName( &strAppName, hCompatDB, tagShim, APPCOMPAT_DB_APPNAME ) )
  {
    iisDebugOut( ( LOG_TYPE_PROGRAM_FLOW, 
                   _T("Could not retrieve all values for App from DB, so will not add to RestrictionList. ('%s','%s','%s','%s')\n"), 
                   strGroupId.QueryStr()   ? strGroupId.QueryStr()   : _T("<Unknown>"),
                   strGroupDesc.QueryStr() ? strGroupDesc.QueryStr() : _T("<Unknown>"),
                   strAppName.QueryStr()   ? strAppName.QueryStr()   : _T("<Unknown>"),
                   strExtGroups.QueryStr() ? strExtGroups.QueryStr() : _T("<Unknown>")) );

    // Failed to retrieve value
    return TRUE;
  }

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, 
              _T("Adding '%s' group to WebSvcRestriction List from AppCompat DB.\n"), 
              strGroupId.QueryStr() ) );

  // Add Extensions
  for ( i = 0; i < ExtensionList.QueryNumberofItems(); i++ )
  {
    if ( !ExtensionList.QueryItem( i, &strPath, &bExists ) )
    {
      // Failed to retrieve
      return FALSE;
    }

    hr = Helper.AddExtensionFile( strPath.QueryStr(),     // Path
                                  g_pTheApp->IsUpgrade() ? true : false,            // Image should be enabled
                                  strGroupId.QueryStr(),  // GroupID
                                  FALSE,                  // Not UI deletable
                                  strGroupDesc.QueryStr(),// Group description
                                  METABASEPATH_WWW_ROOT );  // MB location

    if ( FAILED( hr ) &&
         ( hr != HRESULT_FROM_WIN32(ERROR_DUP_NAME) ) )
    {
      bRet = FALSE;
      iisDebugOut((LOG_TYPE_ERROR, _T("Failed to add extension %s to group %s, hr=0x%8x\n"), strPath.QueryStr(), strGroupId.QueryStr(), hr ));
    }
  }

  // Add Dependencies
  if ( *(strGroupId.QueryStr()) != _T('\0') )
  {
    hr = Helper.AddDependency(  strAppName.QueryStr(),
                                strGroupId.QueryStr(),
                                METABASEPATH_WWW_ROOT );

    if ( FAILED( hr ) &&
         ( hr != HRESULT_FROM_WIN32(ERROR_DUP_NAME) ) )
    {
      bRet = FALSE;
      iisDebugOut((LOG_TYPE_ERROR, 
                   _T("Failed to add dependence ( App: %s on GroupID %s ), hr=0x%8x\n"),
                   strAppName.QueryStr(), 
                   strGroupId.QueryStr(), 
                   hr ));
    }
  }

  // Add all the other "external" groups it depends on
  if ( ( *strExtGroups.QueryStr() ) != _T('\0') )
  {
    LPTSTR szCurrentGroup = strExtGroups.QueryStr();
    LPTSTR szNextGroup;

    while ( szCurrentGroup && *szCurrentGroup )
    {
      szNextGroup = _tcschr( szCurrentGroup, _T(',') );

      if ( szNextGroup )
      {
        *szNextGroup = _T('\0');
        szNextGroup++;
      }

      hr = Helper.AddDependency( strAppName.QueryStr(),
                                 szCurrentGroup,
                                 METABASEPATH_WWW_ROOT );

      if ( FAILED( hr ) &&
           ( hr != HRESULT_FROM_WIN32(ERROR_DUP_NAME) ) )
      {
        bRet = FALSE;
        iisDebugOut((LOG_TYPE_ERROR, 
                     _T("Failed to add dependence ( App: %s on Group %s ), hr = %8x\n"), 
                     strAppName.QueryStr(), 
                     szCurrentGroup, 
                     hr ));
      }


      szCurrentGroup = szNextGroup;
    }
  }

  return bRet;
}

// IsIISShim
//
// Is the Tag an IIS Shim Tag
//
BOOL
IsIISShim( PDB hCompatDB, TAGID tagCurrentTag )
{
  TAG   tagType;
  TAGID tagShimName;
  TSTR  strTagName;

  tagType = SdbGetTagFromTagID( hCompatDB, tagCurrentTag );

  if ( tagType != TAG_SHIM_REF )
  {
    // We handle only <SHIM> tags
    return FALSE;
  }

  if ( !strTagName.Resize( MAX_PATH ) )
  {
    // Failed to widen buffer
    return FALSE;
  }

  tagShimName = SdbFindFirstTag( hCompatDB, tagCurrentTag, TAG_NAME );

  if ( tagShimName == NULL )
  {
    // There is not tag name, so this is not an IIS one.
    return FALSE;
  }

  if ( !SdbReadStringTag( hCompatDB, tagShimName, strTagName.QueryStr(), strTagName.QuerySize() ) )
  {
    // Failed to read string tag
    return FALSE;
  }

  return strTagName.IsEqual( APPCOMPAT_TAG_SHIM_IIS, FALSE );
}

// GetValueFromName
//
// Frab a value out of the Database with the Name we have given
//
// Parameters:
//   pstrValue - [out] The value that was in the database
//   hCompatDB - [in] Handle to DB
//   tagData - [in] The tag to retrieve it from
//   szTagName - [in] The name of the tag to retrieve
//
BOOL
GetValueFromName( TSTR *pstrValue, PDB hCompatDB, TAGID tagData, LPCTSTR szTagName )
{
  TAGID  tagChild;
  TAGID  tagValue;
  LPTSTR szValue;

  tagChild = SdbFindFirstNamedTag( hCompatDB, tagData, TAG_DATA, TAG_NAME, szTagName );

  if ( tagChild == NULL )
  {
    // Failed to find tag
    return FALSE;
  }

  tagValue = SdbFindFirstTag( hCompatDB, tagChild, TAG_DATA_STRING );

  if ( tagValue == NULL )
  {
    // Failed to retrieve tag
    return FALSE;
  }

  szValue = SdbGetStringTagPtr( hCompatDB, tagValue );

  if ( szValue == NULL )
  {
    // Not value found, so lets just set to an empty string
    szValue = _T("");
  }

  return pstrValue->Copy( szValue );
}

// Constructor
//
//
CExtensionList::CExtensionList()
{
  m_dwNumberofItems = 0;
  m_pRoot = NULL;
  m_bUseIndicatorFile = FALSE;
  m_bIndicatorFileExists = FALSE;
}

// Destructor
//
//
CExtensionList::~CExtensionList()
{
  sExtensionItem *pCurrent;
  sExtensionItem *pTemp;

  pCurrent = m_pRoot;

  while ( pCurrent ) 
  {
    pTemp = pCurrent;
    pCurrent = pCurrent->pNext;

    delete pTemp;
  }

  m_pRoot = NULL;
  m_dwNumberofItems = 0;
}

// AddItem
//
// Add an Item to the list
//
// Parameters:
//   szPath - Data for item
//   bExists - Data for Item
BOOL
CExtensionList::AddItem( LPTSTR szPath, BOOL bExists )
{
  sExtensionItem *pNewItem;
  sExtensionItem *pLastItem = NULL;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, 
              _T("Adding item '%s',0x%8x.\n"), 
              szPath, bExists ) );

  if ( QueryNumberofItems() != 0 )
  {
    pLastItem = RetrieveItem( QueryNumberofItems() - 1 );

    if ( pLastItem == NULL )
    {
      // For some read we can not get the nth item, which should exist
      ASSERT( FALSE );
      return FALSE;
    }
  }

  pNewItem = new sExtensionItem;

  if ( pNewItem == NULL )
  {
    return FALSE;
  }

  if ( !pNewItem->strName.Copy( szPath ) )
  {
    delete pNewItem;
    return FALSE;
  }

  pNewItem->bExists = bExists;
  pNewItem->pNext = NULL;
  m_dwNumberofItems++;

  if ( pLastItem )
  {
    pLastItem->pNext = pNewItem;
  }
  else
  {
    m_pRoot = pNewItem;
  }

  return TRUE;
}

// QueryItem
//
// Query the Data on a particular item
//
BOOL
CExtensionList::QueryItem( DWORD dwIndex, TSTR *pstrPath, LPBOOL pbExists)
{
  sExtensionItem *pCurrent;

  pCurrent = RetrieveItem( dwIndex );

  if ( pCurrent == NULL )
  {
    // That item does not exist
    return FALSE;
  }

  if ( !pstrPath->Copy( pCurrent->strName ) )
  {
    // Could not copy name
    return FALSE;
  }

  *pbExists = pCurrent->bExists;

  return TRUE;
}

// QueryNumberofItems
//
// Query the number of items in the list
//
DWORD
CExtensionList::QueryNumberofItems()
{
  return m_dwNumberofItems;
}

// RetrieveItem
//
// Retrieve a specific item by its index
//
sExtensionItem *
CExtensionList::RetrieveItem( DWORD dwIndex )
{
  sExtensionItem *pCurrent = m_pRoot;

  while ( ( pCurrent ) && 
          ( dwIndex != 0 ) )
  {
    pCurrent = pCurrent->pNext;
    dwIndex--;
  }

  return pCurrent;
}

// DoesAnItemExist
//
// Go through all of the items in our list,
// and determine if any of them have the bExists flag
// set
//
BOOL
CExtensionList::DoesAnItemExist()
{
  sExtensionItem *pCurrent = m_pRoot;

  if ( m_bUseIndicatorFile ) 
  {
    // If an indicator file is used, then just use this
    return m_bIndicatorFileExists;
  }

  while ( pCurrent )
  {
    if ( pCurrent->bExists )
    {
      // Found one that exists
      return TRUE;
    }

    pCurrent = pCurrent->pNext;
  }

  // None existed
  return FALSE;
}

// SetIndicatorFile
//
// If an indicator file is set, then use the fact that this is installed
// instead of checking all the other files
//
BOOL  
CExtensionList::SetIndicatorFile( LPTSTR szIndicatorFile )
{
  m_bUseIndicatorFile = TRUE;

  m_bIndicatorFileExists = PathFileExists( szIndicatorFile );

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\comncomp.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        comncomp.cxx

   Abstract:

        Class used to install the Common Components

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2002: Created

--*/

#include "stdafx.h"
#include "comncomp.hxx"
#include "reg.hxx"
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "acl.hxx"

// Define extinct properties, so we can remove them
#define MD_MAX_GLOBAL_CONNECTIONS                    (IIS_MD_GLOBAL_BASE+2)

sExtinctProperties g_ExtinctProps[] = 
  { { MD_MAX_GLOBAL_CONNECTIONS,
      ALL_METADATA }
  };

// SetInstallStateInRegistry
//
// Set the Install state in the registry.  This is so that other 
// components can know that we are in install mode.  Such as the 
// metabase, which only wants to create an new metabase.xml
// during setup
//
BOOL 
SetInstallStateInRegistry( DWORD dwState )
{
  CRegistry Reg;

  if ( !Reg.OpenRegistry( HKEY_LOCAL_MACHINE,
                          REG_INETSTP,
                          KEY_ALL_ACCESS,
                          dwState != INSTALLSTATE_DONE ) )
  {
    if ( dwState == INSTALLSTATE_DONE )
    {
      // This is fine, since we were only going to remove
      // it anyways
      return TRUE;
    }

    return FALSE;
  }

  if ( dwState == INSTALLSTATE_DONE )
  {
    // We are done, so remove registry entry
    if ( !Reg.DeleteValue( REG_INSTALLSTATE ) )
    {
      return FALSE;
    }
  }
  else
  {
    CRegValue Value;

    if ( !Value.SetDword( dwState ) ||
         !Reg.SetValue( REG_INSTALLSTATE, Value ) )
    {
      return FALSE;
    }
  }

  return TRUE;
}

// DeleteHistoryFiles
//
// Remove all the metabase History Files.
// This is because the history files were created during the setup
// process, and are only partially complete
//
BOOL 
CCommonInstallComponent::DeleteHistoryFiles()
{
  TSTR_PATH strHistoryLocation;
  BOOL      bRet = TRUE;

  if ( !strHistoryLocation.Copy( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
       !strHistoryLocation.PathAppend( PATH_HISTORYFILES ) )
  {
    // Could not construct Path
    bRet = FALSE;
  }

  if ( bRet &&
       !RecRemoveDir( strHistoryLocation.QueryStr(), FALSE ) )
  {
    bRet = FALSE;
  }

  if ( !bRet )
  {
    // This is really a very minor issue, so we will just issue a warning
    iisDebugOut((LOG_TYPE_WARN, _T("Could not delete history files after install, some of them will be incomplete") ));
  }

  return TRUE;
}

// DeleteOldBackups
//
// Remove all the backups that we had from previous versions
// This is because they are not valid on the current version, and
// can not be used
//
BOOL 
CCommonInstallComponent::DeleteOldBackups()
{
  TSTR_PATH strBackupLocation;
  BOOL      bRet = TRUE;

  if ( !strBackupLocation.Copy( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
       !strBackupLocation.PathAppend( PATH_METABASEBACKUPS ) )
  {
    // Could not construct Path
    bRet = FALSE;
  }

  if ( bRet &&
       !RecRemoveDir( strBackupLocation.QueryStr(), FALSE ) )
  {
    bRet = FALSE;
  }

  if ( !bRet )
  {
    // This is really a very minor issue, so we will just issue a warning
    iisDebugOut((LOG_TYPE_WARN, _T("Could not delete the old backup's from the previous version") ));
  }

  return TRUE;
}

// PreInstall
//
// PreInstall the Common Component
//
BOOL 
CCommonInstallComponent::PreInstall()
{
  BOOL bRet = TRUE;

  bRet = bRet && SetInstallStateInRegistry( INSTALLSTATE_CURRENTLYINSTALLING );

  return bRet;
}

// Install
//
// Install the Common Component
//
BOOL 
CCommonInstallComponent::Install()
{
  BOOL bRet = TRUE;

  if ( IsUpgrade() )
  {
    bRet = bRet && DeleteOldBackups();
    bRet = bRet && RemoveExtinctMbProperties();
  }

  return bRet;
}

// PostInstall
//
// All work that is necessary after instalation
//
BOOL 
CCommonInstallComponent::PostInstall()
{
  BOOL bRet = TRUE;

  bRet = bRet && SetInstallStateInRegistry( INSTALLSTATE_DONE );
  bRet = bRet && DeleteHistoryFiles();

  return bRet;
}

// PreUnInstall
//
// PreUnInstall the Common Component
//
BOOL 
CCommonInstallComponent::PreUnInstall()
{
  BOOL bRet = TRUE;

  bRet = bRet && SetInstallStateInRegistry( INSTALLSTATE_CURRENTLYUNINSTALLING );

  return bRet;
}

// PostUnInstall
//
// All work that is necessary after removal
//
BOOL 
CCommonInstallComponent::PostUnInstall()
{
  BOOL bRet = TRUE;

  bRet = bRet && SetInstallStateInRegistry( INSTALLSTATE_DONE );

  return bRet;
}

// GetFriendlyName
//
// Retireve the Friendly Name for the Component
//
BOOL 
CCommonInstallComponent::GetFriendlyName( TSTR *pstrFriendlyName )
{
  return pstrFriendlyName->LoadString( IDS_IIS_COMPONENTNAME );
}

// GetName
//
// Retrieve the OCM component name
//
LPTSTR 
CCommonInstallComponent::GetName()
{
  return g_ComponentList[COMPONENT_IIS_COMMON].szComponentName;
}

// RemoveExtinctMbProperties
//
// Remove Metabase properties that were used in old version, but no longer
// get used
//
BOOL 
CCommonInstallComponent::RemoveExtinctMbProperties()
{
  DWORD           i;
  CMDKey          cmdKey;
  CStringList     cslpathList;
  CString         csPath;
  POSITION        pos;

  if ( FAILED( cmdKey.OpenNode( _T("/LM") ) ) )
  {
    // Failed to open MB
    return FALSE;
  }

  for ( i = 0;
        i < ( (DWORD) ( sizeof( g_ExtinctProps ) / sizeof( sExtinctProperties ) ) );
        i++ )
  {
    if (FAILED( cmdKey.GetDataPaths( g_ExtinctProps[i].dwPropertyId, 
                                     g_ExtinctProps[i].dwUserType, 
                                     cslpathList) ))
    {
      // Ignore errors, since this is cosmetic, just continue
      // with next item
      continue;
    }

    pos = cslpathList.GetHeadPosition();

    while ( NULL != pos )
    {
      csPath = cslpathList.GetNext( pos );

      // Ignore errors, since what we are doing is cosmetic
      cmdKey.DeleteData( g_ExtinctProps[i].dwPropertyId, 
                         g_ExtinctProps[i].dwUserType,
                         csPath.GetBuffer(0) );
    }
  }

  cmdKey.Close();

  return TRUE;
}

// SetMetabaseFileAcls
//
// Set the ACL's on all the Metabase Specific Files, these are going to be
// the following:
// %windir%\system32\inetsrv\History
// %windir%\system32\inetsrv\History\*
// %windir%\system32\inetsrv\Metaback\*
// %windir%\system32\inetsrv\Metabase.xml
// %windir%\system32\inetsrv\mbschema.xml
// %windir%\system32\inetsrv\mbschema.bin.*
// %windir%\system32\inetsrv\metabase.bak
// %windir%\system32\inetsrv\metabase.xml.tmp
//
BOOL 
CCommonInstallComponent::SetMetabaseFileAcls()
{
  TSTR_PATH strHistory;
  TSTR_PATH strHistoryAll;
  TSTR_PATH strMetabackAll;
  TSTR_PATH strMetabase;
  TSTR_PATH strMBSchema;
  TSTR_PATH strMBSchemaAll;
  TSTR_PATH strMetabaseBackup;
  TSTR_PATH strMetabaseTemp;
  CSecurityDescriptor AdminSD;
  BOOL      bDriveIsAclable;

  if ( !strHistory.Copy( PATH_FULL_HISTORY_DIR )                 ||
       !strHistoryAll.Copy( PATH_FULL_HISTORY_ALLFILES )         ||
       !strMetabackAll.Copy( PATH_FULL_METABACK_ALLFILES )       ||
       !strMetabase.Copy( PATH_FULL_METABASE_FILE )              ||
       !strMBSchema.Copy( PATH_FULL_MBSCHEMA_FILE )              ||
       !strMBSchemaAll.Copy( PATH_FULL_MBSCHEMA_BINFILES )       ||
       !strMetabaseBackup.Copy( PATH_FULL_METABASE_BACKUPFILE )  ||
       !strMetabaseTemp.Copy( PATH_FULL_METABASE_TEMPFILE )      ||
       !strHistory.ExpandEnvironmentVariables()                  ||
       !strHistoryAll.ExpandEnvironmentVariables()               ||
       !strMetabackAll.ExpandEnvironmentVariables()              ||
       !strMetabase.ExpandEnvironmentVariables()                 ||
       !strMBSchema.ExpandEnvironmentVariables()                 ||
       !strMBSchemaAll.ExpandEnvironmentVariables()              ||
       !strMetabaseBackup.ExpandEnvironmentVariables()           ||
       !strMetabaseTemp.ExpandEnvironmentVariables() 
     )
  {
    // Failed to construct Path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs(         // All of these are on the same drive
                strHistory.QueryStr(),                          // so just use one to test
                &bDriveIsAclable ) )
  {
    // Failed to check if ACL is valid for this filesystem
    return FALSE;
  }

  if ( !bDriveIsAclable )
  {
    // This drive is not aclable, so skip it
    return TRUE;
  }

  if ( !AdminSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS, 
                                           CSecurityDescriptor::ACCESS_FULL, 
                                           TRUE, 
                                           TRUE ) ||
       !AdminSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::USER_LOCALSYSTEM, 
                                           CSecurityDescriptor::ACCESS_FULL, 
                                           TRUE, 
                                           TRUE ) )
  {
    // Failed to create Admin SD
    return FALSE;
  }

  if ( !AdminSD.SetSecurityInfoOnFiles( strHistory.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strHistoryAll.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strMetabackAll.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strMetabase.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strMBSchema.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strMBSchemaAll.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strMetabaseBackup.QueryStr(), FALSE ) ||
       !AdminSD.SetSecurityInfoOnFiles( strMetabaseTemp.QueryStr(), FALSE ) )
  {
    // Failed to set ACL on one of these nodes
    return FALSE;
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\common.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        common.cxx

   Abstract:

        Class that are used to do a number of commonly needed things

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       August 2001: Created

--*/

#include "stdafx.h"
#include "common.hxx"
#include "dcomperm.h"

// function: VerifyParameters
//
// Verify the parameters are correct
//
// Parameters of ciParams
//   0 params - The caller want to know if this is an upgrade, period
//   2 params - The caller wants to know if this is an upgrade in the range from param(0) to param(1) (inclusive)
//
BOOL
CIsUpgrade::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 0 ) ||
       ( ( ciParams.GetNumberOfItems() == 2 ) &&
         ( ciParams.IsNumber(0) ) &&
         ( ciParams.IsNumber(1) )
       )
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: GetMethodName
//
// Returns the name of the CIsMetabase call
//
LPTSTR
CIsUpgrade::GetMethodName()
{
  return _T("IsUpgrade");
}

// function: DoInternalWork
//
// Do the Verification of the upgrade
//
BOOL
CIsUpgrade::DoInternalWork(CItemList &ciParams)
{
  BOOL fRet = TRUE;
  DWORD dwUpgradeType = g_pTheApp->m_eUpgradeType;

  // Init return to installmode==upgrade
  fRet = g_pTheApp->m_eInstallMode == IM_UPGRADE;

  if (ciParams.GetNumberOfItems() == 0)
  {
    // We only wanted to know if it was an upgrade, so return
    return fRet;
  }

  // Check lower bound
  if (fRet)
  {
    DWORD dwMin = ciParams.GetNumber(0);

    switch ( dwUpgradeType )
    {
    case UT_10:
    case UT_10_W95:
      fRet = dwMin <= 1;
      break;
    case UT_20:
      fRet = dwMin <= 2;
      break;
    case UT_30:
    case UT_351:
      fRet = dwMin <= 3;
      break;
    case UT_40:
      fRet = dwMin <= 4;
      break;
    case UT_50:
    case UT_51:
      fRet = dwMin <= 5;
      break;
    case UT_60:
      fRet = dwMin <= 6;
      break;
    default:
      fRet = FALSE;
    }
  }

  // Check upper bound
  if (fRet)
  {
    DWORD dwMax = ciParams.GetNumber(1);

    switch ( dwUpgradeType )
    {
    case UT_10:
    case UT_10_W95:
      fRet = dwMax >= 1;
      break;
    case UT_20:
      fRet = dwMax >= 2;
      break;
    case UT_30:
    case UT_351:
      fRet = dwMax >= 3;
      break;
    case UT_40:
      fRet = dwMax >= 4;
      break;
    case UT_50:
    case UT_51:
      fRet = dwMax >= 5;
      break;
    case UT_60:
      fRet = dwMax >= 6;
      break;
    default:
      fRet = FALSE;
    } // switch
  }

  return fRet;
}

// function: AddAceToSD
//
// Add an ACE (Access Control List) to a Source Descriptor.
//
// Parameters:
//   hObject - Handle to the object
//   ObjectType - The type of object
//   pszTustee - The trustee for new ACE
//   TrusteeForm - The format of the trustee structure
//   dwAccessRights - Access Mask for the New ACE
//   AccessMode - Type of ACE
//   dwInderitance - Inheritance Flags for ACE
//   bAddToExisting - TRUE==add ace to existing ACL, FALSE==ignore existing ACL
//
// Return
//   TRUE - It was successful
//   FALSE - It failed
BOOL
CFileSys_Acl::AddAcetoSD(    HANDLE hObject,             // handle to object
                                SE_OBJECT_TYPE ObjectType,  // type of object
                                LPTSTR pszTrustee,          // trustee for new ACE
                                TRUSTEE_FORM TrusteeForm,   // format of TRUSTEE structure
                                DWORD dwAccessRights,       // access mask for new ACE
                                ACCESS_MODE AccessMode,     // type of ACE
                                DWORD dwInheritance,        // inheritance flags for new ACE
                                BOOL  bAddToExisting        // add the new ace to the old SD, if not create a new SD
                           )
{
  DWORD dwErr = ERROR_SUCCESS;
  PACL  pNewDacl = NULL;
  PACL  pOldDacl = NULL;
  EXPLICIT_ACCESS ea;
  PSECURITY_DESCRIPTOR pSD = NULL;

  if ( bAddToExisting )
  {
    // If we are adding, then lets retrieve the old SD
    dwErr = GetSecurityInfo(  hObject,
                              ObjectType,
                              DACL_SECURITY_INFORMATION,
                              NULL,
                              NULL,
                              &pOldDacl,
                              NULL,
                              &pSD);

    if ( dwErr == ERROR_SUCCESS )
    {
      // It is possible that we did not retrieve any acl's for this file,
      // so don't try to remove a user from them
      if ( pOldDacl )
      {
        RemoveUserFromAcl( pOldDacl, pszTrustee);
      }
    }
  }

  // Create new SD with the new ACE
  if ( dwErr == ERROR_SUCCESS )
  {
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = dwAccessRights;
    ea.grfAccessMode = AccessMode;
    ea.grfInheritance = dwInheritance;
    ea.Trustee.TrusteeForm = TrusteeForm;
    ea.Trustee.ptstrName = pszTrustee;

    dwErr = SetEntriesInAcl(1, &ea, pOldDacl, &pNewDacl);
  }

  if ( ( dwErr == ERROR_SUCCESS ) &&
       ( pNewDacl )
     )
  {
    dwErr = SetSecurityInfo(  hObject,
                              ObjectType,
                              DACL_SECURITY_INFORMATION |
                                ( bAddToExisting ? 
                                    UNPROTECTED_DACL_SECURITY_INFORMATION : 
                                    PROTECTED_DACL_SECURITY_INFORMATION ),
                              NULL,
                              NULL,
                              pNewDacl,
                              NULL);
  }

  if ( pSD )
  {
    LocalFree( pSD );
  }

  if ( pNewDacl )
  {
    LocalFree( pNewDacl );
  }

  return dwErr == ERROR_SUCCESS;
}

// function: RemoveUserFromAcl
//
// Remove a User from the Acl
//
// Parameters
//   pAcl - A pointer to the Acl
//   szUserName - The user to remove
BOOL 
CFileSys_Acl::RemoveUserFromAcl(PACL pAcl, LPTSTR szUserName)
{
  BOOL bUserExisted;

  do {
    bUserExisted = FALSE;
    // Keep removing until all instances of that user are gone.
  } while ( ( RemovePrincipalFromACL(pAcl,szUserName,&bUserExisted) == ERROR_SUCCESS) && bUserExisted );

  return TRUE;
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CFileSys_AddAcl::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 6 ) &&
         ciParams.IsNumber(3) &&
         ciParams.IsNumber(4) &&
         ciParams.IsNumber(5)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CFileSys_AddAcl::GetMethodName()
{
  return _T("FilSys_AddAcl");
}

// function: CreateFullFileName
//
// Create the Full FileName from the Path with wildcards, and the filename
//
// Parameters:
//   buffFullFileName [out] - The FileName including the path
//   szFullPathwithWildCard [in] - The search path (ie. c:\winnt\system32\inetsrv\*.*)
//   szFileName [in] - The filename to append to the seach path (ie. asp.dll)
//
BOOL 
CFileSys_Acl::CreateFullFileName(BUFFER &buffFullFileName, LPTSTR szFullPathwithWildCard, LPTSTR szFileName)
{
  LPTSTR szLastSlash;

  if ( !buffFullFileName.Resize( ( _tcslen(szFullPathwithWildCard) + _tcslen(szFileName) + 1 ) * sizeof(TCHAR) ) )
  {
    // Could not allocate memory needed
    return FALSE;
  }

  // Copy the full path to the buffer 
  _tcscpy( (LPTSTR) buffFullFileName.QueryPtr(), szFullPathwithWildCard);

  // Look for last part of path
  szLastSlash = _tcsrchr( (LPTSTR) buffFullFileName.QueryPtr(), L'\\' );

  if (!szLastSlash)
  {
    return FALSE;
  }

  // Copy the filename on top of the end of the path
  _tcscpy( szLastSlash + 1, szFileName);

  return TRUE;
}

// function: SetFileAcl
//
// Add the file/directory acl
//
BOOL 
CFileSys_Acl::SetFileAcl(LPTSTR szFileName, LPTSTR szUserName, SE_OBJECT_TYPE ObjectType, 
                         DWORD dwAccessMask, BOOL bAllowAccess, DWORD dwInheritable, BOOL bAddAcetoOriginal)
{
	HANDLE  hFile;
  BOOL    bRet;
  
  hFile = CreateFile(	szFileName, 
				      				WRITE_DAC|READ_CONTROL, 
						      		0,
      								NULL,
			      					OPEN_EXISTING,
						      		FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
      								NULL);

  if ( hFile == INVALID_HANDLE_VALUE )
  {
    return FALSE;
  }

  bRet = AddAcetoSD( hFile, ObjectType, szUserName, TRUSTEE_IS_NAME, dwAccessMask, 
                      bAllowAccess ? SET_ACCESS: DENY_ACCESS,  dwInheritable,
                      bAddAcetoOriginal );
//                      bAllowAccess ? GRANT_ACCESS: DENY_ACCESS,  dwInheritable);

  CloseHandle( hFile );

  return bRet;
}

// function: RemoveUserAcl
//
// Remove a User's ACL from a file
//
BOOL 
CFileSys_Acl::RemoveUserAcl(LPTSTR szFile, LPTSTR szUserName)
{
	HANDLE  hFile;
  DWORD dwErr;
  PACL  pDacl;
  PSECURITY_DESCRIPTOR pSD = NULL;
  
  hFile = CreateFile(	szFile, 
				      				WRITE_DAC|READ_CONTROL, 
						      		0,
      								NULL,
			      					OPEN_EXISTING,
						      		FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
      								NULL);

  if ( hFile == INVALID_HANDLE_VALUE )
  {
    return FALSE;
  }

  dwErr = GetSecurityInfo(  hFile,
                            SE_FILE_OBJECT,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            NULL,
                            &pDacl,
                            NULL,
                            &pSD);

  if ( ( dwErr == ERROR_SUCCESS ) &&
       ( pDacl )
     )
  {
    RemoveUserFromAcl( pDacl, szUserName);

    dwErr = SetSecurityInfo(hFile,
                            SE_FILE_OBJECT,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            NULL,
                            pDacl,
                            NULL);
  }

  CloseHandle( hFile );

  if ( pSD )
  {
    LocalFree( pSD );
  }

  return dwErr == ERROR_SUCCESS;
}

// function: DoSetAcl
//
// Set or remove an ACL on a file.
// If it is Set, then we will either add or just set based on bIgnorePreviousAcls
//
// Parameters
//   bAdd - Add the ace. FALSE==remove the ace from the acl
//   bAddAcltoOrignial - TRUE==add ace, FALSE==do not add to old ace, just replace
//
//   ciList - The list of the parameters from the inf file
//     0 - A list of files (full paths)
//     1 - The exclusion list, list of files to not be inclused (file names only)
//     2 - The user(s) to have access for 
//  the following are needed it bAdd is true...
//     3 - Access Mask
//     4 - bAllowAccess (FALSE==Denuy Access) 
//     5 - Inheritance Flags 
//
BOOL 
CFileSys_Acl::DoAcling(CItemList &ciList, BOOL bAdd, BOOL bAddAcltoOriginal)
{
  HANDLE              hFileList;
  WIN32_FIND_DATA     sFD;
  BUFFER              BuffFullFileName;
  CItemList           ciExclusionList;
  CItemList           ciUserList;

  // Load exclusion list, and userlist
  if ( (!ciExclusionList.LoadSubList(ciList.GetItem(1))) ||
       (!ciUserList.LoadSubList(ciList.GetItem(2)))
     )
  {
    return FALSE;
  }

  if ( !_tcsstr( ciList.GetItem(0), _T("*")) )
  {
    for (DWORD i = 0; i < ciUserList.GetNumberOfItems(); i++)
    {
      if ( bAdd )
      {
        // It is only a single file, so only call it once
        SetFileAcl( (LPTSTR) ciList.GetItem(0),    // FileName
                ciUserList.GetItem(i),             // UserName
                SE_FILE_OBJECT,                    // The type of object
                ciList.GetNumber(3),               // dwAccess Mask
                ciList.GetNumber(4),               // bAllow access
                ciList.GetNumber(5),               // bInhertance Flags
                bAddAcltoOriginal );
      }
      else
      {
        RemoveUserAcl(ciList.GetItem(0),ciUserList.GetItem(i));
      }
    } 
    
    return TRUE;
  }

  hFileList = FindFirstFile( ciList.GetItem(0), &sFD );

  if (hFileList == INVALID_HANDLE_VALUE)
  {
    return FALSE;
  }

  do {
    if ( ( !ciExclusionList.FindItem( sFD.cFileName, FALSE ) ) &&
         ( _tcscmp( sFD.cFileName, _T(".") ) ) &&
         ( _tcscmp( sFD.cFileName, _T("..") ) ) &&
         ( CreateFullFileName( BuffFullFileName, ciList.GetItem(0), sFD.cFileName ) )
       )
    {
      for (DWORD i = 0; i < ciUserList.GetNumberOfItems(); i++)
      {
        if ( bAdd )
        {
          SetFileAcl( (LPTSTR) BuffFullFileName.QueryPtr(),   // FileName
                      ciUserList.GetItem(i),                  // UserName
                      SE_FILE_OBJECT,                         // The type of object
                      ciList.GetNumber(3),                    // dwAccess Mask
                      ciList.GetNumber(4),                    // bAllow access
                      ciList.GetNumber(5),                    // bInhertance Flags
                      bAddAcltoOriginal );
        }
        else
        {
          RemoveUserAcl((LPTSTR) BuffFullFileName.QueryPtr(),ciUserList.GetItem(i));
        }
      }                  
    }

  } while ( FindNextFile( hFileList, &sFD ) );

  FindClose( hFileList );

  return TRUE;
}

// function: DoInternalWork
//
// Add the Acl for the files specified
//
// Parameters
//   ciList - The list of the parameters from the inf file
//     0 - A list of files (full paths)
//     1 - The exclusion list, list of files to not be inclused (file names only)
//     2 - The user(s) to have access for 
//     3 - Access Mask
//     4 - bAllowAccess (FALSE==Denuy Access)
//     5 - Inheritance Flags
BOOL
CFileSys_AddAcl::DoInternalWork(CItemList &ciList)
{
  return DoAcling( ciList, TRUE, TRUE );
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CFileSys_RemoveAcl::VerifyParameters(CItemList &ciParams)
{
  return ciParams.GetNumberOfItems() == 3;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CFileSys_RemoveAcl::GetMethodName()
{
  return _T("FilSys_RemoveAcl");
}

// function: DoInternalWork
//
// Remove an Acl for a specific user
//
// Parameters
//   ciList - The list of the parameters from the inf file
//     0 - A list of files (full paths)
//     1 - The exclusion list, list of files to not be inclused (file names only)
//     2 - The user(s) to remove access for 
BOOL
CFileSys_RemoveAcl::DoInternalWork(CItemList &ciList)
{
  return DoAcling( ciList, FALSE );
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CFileSys_SetAcl::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 6 ) &&
         ciParams.IsNumber(3) &&
         ciParams.IsNumber(4) &&
         ciParams.IsNumber(5)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CFileSys_SetAcl::GetMethodName()
{
  return _T("FilSys_SetAcl");
}

// function: DoInternalWork
//
// Set the Acl for the files specified (ignoring previous acl's)
//
// Parameters
//   ciList - The list of the parameters from the inf file
//     0 - A list of files (full paths)
//     1 - The exclusion list, list of files to not be inclused (file names only)
//     2 - The user(s) to have access for 
//     3 - Access Mask
//     4 - bAllowAccess (FALSE==Denuy Access)
//     5 - Inheritance Flags
BOOL
CFileSys_SetAcl::DoInternalWork(CItemList &ciList)
{
  return DoAcling( ciList, TRUE, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\compinst.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        compinst.cxx

   Abstract:

        Base classes that are used to define the different
        instalations

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       April 2002: Created

--*/

#include "stdafx.h"
#include "compinst.hxx"
#include "webcomp.hxx"
#include "ftpcomp.hxx"
#include "complus.hxx"
#include "wwwcmpts.hxx"
#include "comncomp.hxx"

// Constructor
//
// Initialize the Component List to NULL
CComponentList::CComponentList()
{
  DWORD i;

  for ( i = 0; i < COMPONENTS_MAXNUMBER; i++ )
  {
    // Initialize all to NULL
    m_pComponentList[i] = NULL;
  }

  m_dwNumberofComponents = 0;
}

// Destructor
//
// Cleanup all the classes we created
CComponentList::~CComponentList()
{
  DWORD i;

  for ( i = 0; i < COMPONENTS_MAXNUMBER; i++ )
  {
    if ( m_pComponentList[i] )
    {
      delete m_pComponentList[i];
      m_pComponentList[i] = NULL;
    }
  }
}

// FindComponent
//
// Find a particular component based on its name
//
CInstallComponent *
CComponentList::FindComponent(LPCTSTR szComponentName)
{
  DWORD i;

  for ( i = 0; i < GetNumberofComponents(); i++ )
  {
    if ( _tcsicmp( m_pComponentList[i]->GetName(), szComponentName ) == 0 )
    {
      return m_pComponentList[i];
    }
  }

  // Could not find
  return NULL;
}

// GetNumberofComponents
//
// Return the number of components that we have
//
DWORD
CComponentList::GetNumberofComponents()
{
  return m_dwNumberofComponents;
}

// Initialize
//
// Initialize the components that we have to install
//
BOOL 
CComponentList::Initialize()
{
  DWORD dwCurrent;
  DWORD dwComponents = 0;
  BOOL  bRet = TRUE;

  // Make sure we have not been called before, and we have no components
  ASSERT( GetNumberofComponents() == 0 );

  // Create the classes
  m_pComponentList[ dwComponents++ ] = new (CWebServiceInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CFtpServiceInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CCOMPlusInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CDTCInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CWWWASPInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CWWWIDCInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CWWWSSIInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CWWWWebDavInstallComponent);
  m_pComponentList[ dwComponents++ ] = new (CCommonInstallComponent);

  // Make sure that we have not gone past the array
  ASSERT( dwComponents < COMPONENTS_MAXNUMBER );

  // Check to make sure all classes were allocated.
  // Initialize in order of dependencies, ie. keeping scripts_vdir before web service
  for ( dwCurrent = 0; dwCurrent < dwComponents; dwCurrent++ )
  {
    if ( m_pComponentList[ dwCurrent ] == NULL )
    {
      // FAILED to allocate one of the classes
      bRet = FALSE;
      break;
    }
  }

  if ( !bRet )
  {
    // Failed, so lets cleanup
    for ( dwCurrent = 0; dwCurrent < dwComponents; dwCurrent++ )
    {
      if ( m_pComponentList[ dwCurrent ] )
      {
        delete m_pComponentList[ dwCurrent ];
        m_pComponentList[ dwCurrent ] = NULL;
      }
    }
  }
  else
  {
    m_dwNumberofComponents = dwComponents;
  }

  return bRet;
}

// PreInstall
//
// Call the PreInstall function for the appropriate component
//
BOOL 
CComponentList::PreInstall(LPCTSTR szComponentName)
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = TRUE;

  if ( pComponent && 
       !( pComponent->PreInstall() )
     )
  {
    iisDebugOut((LOG_TYPE_ERROR, _T("PreInstall of Component '%s' FAILED\n"), szComponentName ));
    bRet = FALSE;
  }

  return bRet;
}

// Install
//
// Call the Install function for the appropriate component
//
BOOL 
CComponentList::Install(LPCTSTR szComponentName)
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = TRUE;

  if ( pComponent && 
       !( pComponent->Install() )
     )
  {
    iisDebugOut((LOG_TYPE_ERROR, _T("Install of Component '%s' FAILED\n"), szComponentName ));
    bRet = FALSE;
  }

  return bRet;
}

// PostInstall
//
// Call the PostInstall function for the appropriate component
//
BOOL 
CComponentList::PostInstall(LPCTSTR szComponentName)
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = TRUE;

  if ( pComponent && 
       !( pComponent->PostInstall() )
     )
  {
    iisDebugOut((LOG_TYPE_ERROR, _T("PostInstall of Component '%s' FAILED\n"), szComponentName ));
    bRet = FALSE;
  }

  return bRet;
}

// PreUnInstall
//
// Call the PreUnInstall function for the appropriate component
//
BOOL 
CComponentList::PreUnInstall(LPCTSTR szComponentName)
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = TRUE;

  if ( pComponent && 
       !( pComponent->PreUnInstall() )
     )
  {
    iisDebugOut((LOG_TYPE_ERROR, _T("PreUnInstall of Component '%s' FAILED\n"), szComponentName ));
    bRet = FALSE;
  }

  return bRet;
}

// UnInstall
//
// Call the UnInstall function for the appropriate component
//
BOOL 
CComponentList::UnInstall(LPCTSTR szComponentName)
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = TRUE;

  if ( pComponent && 
       !( pComponent->UnInstall() )
     )
  {
    iisDebugOut((LOG_TYPE_ERROR, _T("UnInstall of Component '%s' FAILED\n"), szComponentName ));
    bRet = FALSE;
  }

  return bRet;
}

// PostUnInstall
//
// Call the PostUnInstall function for the appropriate component
//
BOOL 
CComponentList::PostUnInstall(LPCTSTR szComponentName)
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = TRUE;

  if ( pComponent && 
       !( pComponent->PostUnInstall() )
     )
  {
    iisDebugOut((LOG_TYPE_ERROR, _T("PostUnInstall of Component '%s' FAILED\n"), szComponentName ));
    bRet = FALSE;
  }

  return bRet;
}

// IsInstalled
//
// Is the component already installed or not
//
// Parameters:
//   szComponentName [in] - The name of the component to check
//   pbIsInstalled [out] - TRUE == it is installed
//                         FALSE == it is not installed
//
// Return Values
//   TRUE - We do know if it was installed
//   FALSE - We don't know if it was installed
//
BOOL 
CComponentList::IsInstalled( LPCTSTR szComponentName, LPBOOL pbIsInstalled )
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = FALSE;

  if ( pComponent )
  {
    bRet = pComponent->IsInstalled( pbIsInstalled );
  }

  return bRet;
}

// GetFriendlyName
//
// Call the GetFriendlyName function for the appropriate component
//
BOOL 
CComponentList::GetFriendlyName( LPCTSTR szComponentName, TSTR *pstrFriendlyName )
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = FALSE;

  if ( pComponent )
  {
    bRet = pComponent->GetFriendlyName( pstrFriendlyName );
  }

  return bRet;
}

// GetSmallIcon
//
// Retrieve the small icon for the OCM component
//
BOOL 
CComponentList::GetSmallIcon( LPCTSTR szComponentName,  HBITMAP *phIcon )
{
  CInstallComponent *pComponent = FindComponent( szComponentName );
  BOOL              bRet = FALSE;

  ASSERT( phIcon );

  if ( pComponent )
  {
    bRet = pComponent->GetSmallIcon( phIcon );
  }

  return bRet;
}

// Initialize
//
// Initialize the component for install.
// The default function is to do nothing
//
BOOL
CInstallComponent::Initialize()
{
  return TRUE;
}

// PreInstall
//
// PreInstall work for component.  This should theoretically be nothing, we should
// do everything in the Install Part
//
BOOL
CInstallComponent::PreInstall()
{
  return TRUE;
}

// Install
//
// This does all the meat of the install work.  Everything should be done inside of
// here.
//
BOOL 
CInstallComponent::Install()
{
  return TRUE;
}

// PostInstall
//
// This does any post install work.  In a theoretical world this would not be needed,
// but sometimes things need to be done after everything else
//
BOOL 
CInstallComponent::PostInstall()
{
  return TRUE;
}

// PreUninstall
//
// Anything that needs to be done before any uninstalation occurs.
//
BOOL 
CInstallComponent::PreUnInstall()
{
  return TRUE;
}

// Uninstall
//
// The core of the work to be done for uninstall. 
//
BOOL 
CInstallComponent::UnInstall()
{
  return TRUE;
}

// PostUnInstall
//
// Anything that needs to be done after all the other uninstall stuff is done.
//
BOOL 
CInstallComponent::PostUnInstall()
{
  return TRUE;
}

// IsInstalled
//
// Is the component already installed or not
//
// Parameters:
//   pbIsInstalled [out] - TRUE == it is installed
//                         FALSE == it is not installed
//
// Return Values
//   TRUE - We do know if it was installed
//   FALSE - We don't know if it was installed
BOOL 
CInstallComponent::IsInstalled( LPBOOL pbIsInstalled )
{
  // By default, we don't know if it is installed

  return FALSE;
}

// GetFriendlyName
//
// Get the friendly name for the application
// 
// This willr eturn false if it does not know if,
// or true if it does
BOOL 
CInstallComponent::GetFriendlyName( TSTR *pstrFriendlyName )
{
  return FALSE;
}

// GetSmallIcon
//
// Retrieve the Small Icon for this OCM component
//
// Parameters:
//   phIcon - The icon retrieved
//
// Return Values:
//   TRUE  - Retrieve Successfully
//   FALSE - No we do not know what the icon looks like,
//           or we failed to retrieve it
BOOL
CInstallComponent::GetSmallIcon( HBITMAP *phIcon )
{
  // By default, there is no icon
  return FALSE;
}

// IsUpgrade
// 
// Is this an upgrade or a fresh install
//
// Return Values:
//   TRUE - Upgrade
//   FALSE - Fresh Install
//
BOOL 
CInstallComponent::IsUpgrade()
{
  return g_pTheApp->IsUpgrade();
}

// GetUpdateVersion
//
// Is this is an upgrade, this is the version we are upgrading from
//
DWORD 
CInstallComponent::GetUpgradeVersion()
{
  return g_pTheApp->GetUpgradeVersion();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\dcomperm.cpp ===
#include "stdafx.h"

#include <conio.h>
#include "dcomperm.h"

#define _WIN32_DCOM
#include <objbase.h>

#define MY_DCOM_PERSIST_FLAG _T("PREEXIST")


int IsValidDaclInSD(PSECURITY_DESCRIPTOR pSD)
{
    int iReturn = TRUE;
    BOOL present = FALSE;
    BOOL defaultDACL = FALSE;
    PACL dacl = NULL;

    // Check if the SD is valid

    if (!IsValidSecurityDescriptor(pSD)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("IsValidDaclInSD:IsValidSecurityDescriptor FAILED")));
        iReturn = FALSE;
    }
    else
    {
        // Check if the dacl we got is valid...
        if (!GetSecurityDescriptorDacl (pSD, &present, &dacl, &defaultDACL)) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("IsValidDaclInSD:GetSecurityDescriptorDacl FAILED")));
            iReturn = FALSE;
        }
        else
        {
            if (present)
            {
                // check if our sd is valid after call
                if (!IsValidSecurityDescriptor(pSD)) 
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("IsValidDaclInSD:IsValidSecurityDescriptor FAILED")));
                    iReturn = FALSE;
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsValidDaclInSD:SD has valid dacl")));
                }
            }
        }
    }

    return iReturn;
}


DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;
    DWORD                 returnValue = ERROR_SUCCESS;

    if (0 == IsValidAcl(OldACL))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:IsValidAcl.FAILED.ACL is bad.")));
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:GetAclInformation.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
        {
            returnValue = GetLastError();
            iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:GetAce.FAILED.Return=0x%x."), returnValue));
            return returnValue;
        }

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
        {
            returnValue = GetLastError();
            iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:AddAce.FAILED.Return=0x%x."), returnValue));
            return returnValue;
        }
    }

    return returnValue;
}

//
// Ace's within in ACL must be ordered in a particular way.
// if they are not then you will get errors when you try to look at the
// security on the file/dir/object.
// 
// They should be ordered this way:
// -------------
// 1. on the top are non-inheritied ACE's
//    Access-denied ACEs that apply to the object itself 
//    Access-denied ACEs that apply to a subobject of the object, such as a property set or property 
//    Access-allowed ACEs that apply to the object itself 
//    Access-allowed ACEs that apply to a subobject of the object 
// 2. on the bottom are non-inheritied ACE's
//    Access-denied ACEs that apply to the object itself 
//    Access-denied ACEs that apply to a subobject of the object, such as a property set or property 
//    Access-allowed ACEs that apply to the object itself 
//    Access-allowed ACEs that apply to a subobject of the object 
//
// returns ERROR_SUCCESS if the acl is successfully reordered into the newAcl
// otherwise, returns an error with nothing in the newacl
//
// WARNING: the OldACL that is passed in should have been alloced with LocalAlloc(), since it
// Will be freed with LocalFree()
//
DWORD
ReOrderACL(
    PACL *ACLtoReplace
    )
{
    DWORD       returnValue = ERROR_INVALID_PARAMETER;
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID      ace = NULL;
    ACE_HEADER  *aceHeader = NULL;
    ULONG       i = 0;
    DWORD       dwLength = 0;
    PACL        NewACL = NULL;

    PACL New_ACL_AccessDenied = NULL;
    PACL New_ACL_AccessAllowed = NULL;
    PACL New_ACL_InheritedAccessDenied = NULL;
    PACL New_ACL_InheritedAccessAllowed = NULL;
    ULONG lAllowCount = 0L;
    ULONG lDenyCount = 0L;
    ULONG lInheritedAllowCount = 0L;
    ULONG lInheritedDenyCount = 0L;
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ReOrderACL:start\n")));

    if (0 == IsValidAcl(*ACLtoReplace))
    {
        returnValue = ERROR_INVALID_ACL;
        goto ReOrderACL_Exit;
    }

    if (0 == GetAclInformation (*ACLtoReplace, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation))
    {
        returnValue = GetLastError();
        goto ReOrderACL_Exit;
    }

    // There are four main types of ACE's we are concerned with:
    //  access denied, 
    //  access allowed,
    //  inherited access denied
    //  inherited access allowed.
    //
    // We will construct 4 arrays and copy elements
    // into them, then recopy to the original.
    //
    // If, along the way, we encounter a system audit type ace, just stick it in the access denied list,
    // as we are dealing in that case with a SACL, for which there is no proper ordering.
    dwLength = aclSizeInfo.AclBytesInUse;

    // Create a new ACL that we we eventually copy everything in to and hand back.
    NewACL = (PACL) LocalAlloc(LMEM_FIXED, dwLength);
    if(NewACL == NULL) {returnValue = ERROR_NOT_ENOUGH_MEMORY;goto ReOrderACL_Exit;}
    if(!InitializeAcl(NewACL, dwLength, ACL_REVISION)) {returnValue = GetLastError();goto ReOrderACL_Exit;}
    
    // Create a new ACL for Access Denied
    New_ACL_AccessDenied = (PACL) LocalAlloc(LMEM_FIXED, dwLength);
    if(New_ACL_AccessDenied == NULL) {returnValue = ERROR_NOT_ENOUGH_MEMORY;goto ReOrderACL_Exit;}
    if(!InitializeAcl(New_ACL_AccessDenied, dwLength, ACL_REVISION)) {returnValue = GetLastError();goto ReOrderACL_Exit;}

    // Create a new ACL for Access Allowed
    New_ACL_AccessAllowed = (PACL) LocalAlloc(LMEM_FIXED, dwLength);
    if(New_ACL_AccessAllowed == NULL) {returnValue = ERROR_NOT_ENOUGH_MEMORY;goto ReOrderACL_Exit;}
    if(!InitializeAcl(New_ACL_AccessAllowed, dwLength, ACL_REVISION)) {returnValue = GetLastError();goto ReOrderACL_Exit;}

    // Create a new ACL for Inherited Access Denied
    New_ACL_InheritedAccessDenied = (PACL) LocalAlloc(LMEM_FIXED, dwLength);
    if(New_ACL_InheritedAccessDenied == NULL) {returnValue = ERROR_NOT_ENOUGH_MEMORY;goto ReOrderACL_Exit;}
    if(!InitializeAcl(New_ACL_InheritedAccessDenied, dwLength, ACL_REVISION)) {returnValue = GetLastError();goto ReOrderACL_Exit;}

    // Create a new ACL for Inherited Access Allowed
    New_ACL_InheritedAccessAllowed = (PACL) LocalAlloc(LMEM_FIXED, dwLength);
    if(New_ACL_InheritedAccessAllowed == NULL) {returnValue = ERROR_NOT_ENOUGH_MEMORY;goto ReOrderACL_Exit;}
    if(!InitializeAcl(New_ACL_InheritedAccessAllowed, dwLength, ACL_REVISION)) {returnValue = GetLastError();goto ReOrderACL_Exit;}

    //
    // Copy all of the ACEs to the new ACLs
    //
    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //
        ace = NULL;
        if (!GetAce (*ACLtoReplace, i, &ace))
            {returnValue = GetLastError();goto ReOrderACL_Exit;}

        // Get the header
        aceHeader = (ACE_HEADER *) ace;

        // Check the type
        if(aceHeader->AceType == ACCESS_DENIED_ACE_TYPE || aceHeader->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE)
        {
            if(aceHeader->AceFlags & INHERITED_ACE)
            {
                // Add the ACE to the appropriate ACL
                if (!AddAce (New_ACL_InheritedAccessDenied, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                    {returnValue = GetLastError();goto ReOrderACL_Exit;}
                lInheritedDenyCount++;
            }
            else
            {
                // Add the ACE to the appropriate ACL
                if (!AddAce (New_ACL_AccessDenied, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                    {returnValue = GetLastError();goto ReOrderACL_Exit;}
                lDenyCount++;
            }
        }
        else if(aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE || aceHeader->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE)
        {
            if(aceHeader->AceFlags & INHERITED_ACE)
            {
                // Add the ACE to the appropriate ACL
                if (!AddAce (New_ACL_InheritedAccessAllowed, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                    {returnValue = GetLastError();goto ReOrderACL_Exit;}
                lInheritedAllowCount++;
            }
            else
            {
                // Add the ACE to the appropriate ACL
                if (!AddAce (New_ACL_AccessAllowed, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                    {returnValue = GetLastError();goto ReOrderACL_Exit;}
                lAllowCount++;
            }
        }
        else if(aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            // This doesn't matter
            // so lets just add this all to the New_ACL_AccessDenied list
            if (!AddAce (New_ACL_AccessDenied, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            lDenyCount++;
        }
        else
        {
            returnValue = ERROR_INVALID_PARAMETER;
            goto ReOrderACL_Exit;
        }
    }

    if(lDenyCount || lAllowCount || lInheritedDenyCount || lInheritedAllowCount)
    {
        DWORD dwTotalCount = 0;
        aceHeader = NULL;

        // First copy over the local deny aces...
        for (i = 0; i < lDenyCount; i++)
        {
            ace = NULL;
            if (!GetAce (New_ACL_AccessDenied, i, &ace))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            aceHeader = (ACE_HEADER *) ace;
            if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            dwTotalCount++;
        }

        // Then copy over the local allow aces...
        for (i = 0; i < lAllowCount; i++)
        {
            ace = NULL;
            if (!GetAce (New_ACL_AccessAllowed, i, &ace))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            aceHeader = (ACE_HEADER *) ace;
            if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            dwTotalCount++;
        }

        // Then copy over the inherited deny aces...
        for (i = 0; i < lInheritedDenyCount; i++)
        {
            ace = NULL;
            if (!GetAce (New_ACL_InheritedAccessDenied, i, &ace))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            aceHeader = (ACE_HEADER *) ace;
            if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            dwTotalCount++;
        }
        
        // Then copy over the inherited allow aces...
        for (i = 0; i < lInheritedAllowCount; i++)
        {
            ace = NULL;
            if (!GetAce (New_ACL_InheritedAccessAllowed, i, &ace))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            aceHeader = (ACE_HEADER *) ace;
            if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
                {returnValue = GetLastError();goto ReOrderACL_Exit;}
            dwTotalCount++;
        }

        // Remove the old ACL, and set it to the new acl
        if (*ACLtoReplace){LocalFree(*ACLtoReplace);*ACLtoReplace=NULL;}
        *ACLtoReplace = NewACL;
        if (*ACLtoReplace)
        {
            returnValue = ERROR_SUCCESS;
        }

        // Verify that amount of ACE's going out 
        // are the same that came in..
        if (aclSizeInfo.AceCount != dwTotalCount)
        {
            // There is something majorly wrong
            iisDebugOut((LOG_TYPE_ERROR, _T("ReOrderACL:in diff from out\n")));
        }
    }
    else
    {
        returnValue = ERROR_INVALID_ACL;
    }

ReOrderACL_Exit:
    if (New_ACL_AccessDenied){LocalFree(New_ACL_AccessDenied);New_ACL_AccessDenied=NULL;}
    if (New_ACL_AccessAllowed){LocalFree(New_ACL_AccessAllowed);New_ACL_AccessAllowed=NULL;}
    if (New_ACL_InheritedAccessDenied){LocalFree(New_ACL_InheritedAccessDenied);New_ACL_InheritedAccessDenied=NULL;}
    if (New_ACL_InheritedAccessAllowed){LocalFree(New_ACL_InheritedAccessAllowed);New_ACL_InheritedAccessAllowed=NULL;}
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ReOrderACL:FAILED with code=0x%x\n"), returnValue));
    }
    return returnValue;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  newACL = NULL;
    PACL                  oldACL = NULL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (0 == IsValidAcl(oldACL))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessDeniedACEToACL:IsValidAcl.FAILED.ACL is bad.")));
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    // cleanup old memory whose pointer we're replacing
    // okay to leak in setup... (need to comment out or else av's)
    //if (*Acl) {delete(*Acl);}
    *Acl = newACL;
    newACL = NULL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    if (newACL)
    {
		delete [] newACL;
		newACL = NULL;
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL = NULL;
    PACL                  newACL = NULL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    // check if the acl we got passed in is valid!
    if (0 == IsValidAcl(oldACL))
    {
        returnValue = ERROR_INVALID_ACL;
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL:IsValidAcl.FAILED.ACL we got passed in is bad1.")));
        goto cleanup;
    }

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetPrincipalSID.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (0 == GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("GetAclInformation.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("InitializeAcl.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    //if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    if (!AddAccessAllowedAce (newACL, ACL_REVISION, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedAce.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    // check if the acl is valid!
    /*
    if (0 == IsValidAcl(newACL))
    {
        returnValue = ERROR_INVALID_ACL;
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL:IsValidAcl.FAILED.ACL we are pasing out is bad.")));
        goto cleanup;
    }
    */

    // cleanup old memory whose pointer we're replacing
    // okay to leak in setup... (need to comment out or else av's)
    //if (*Acl) {delete(*Acl);}
    *Acl = newACL;
    newACL = NULL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    if (newACL)
    {
		delete [] newACL;
		newACL = NULL;
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal,
    BOOL *pbUserExistsToBeDeleted
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    *pbUserExistsToBeDeleted = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    // check if the acl we got passed in is valid!
    if (0 == IsValidAcl(Acl))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("RemovePrincipalFromACL:IsValidAcl.FAILED.ACL is bad.")));
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        return returnValue;
    }

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                *pbUserExistsToBeDeleted = TRUE;
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                *pbUserExistsToBeDeleted = TRUE;
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                *pbUserExistsToBeDeleted = TRUE;
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetPrincipalSID():Principal=%s\n"), Principal));

    DWORD returnValue=ERROR_SUCCESS;
    TSTR strPrincipal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    if ( !strPrincipal.Copy( Principal ) )
    {
      return ERROR_NOT_ENOUGH_MEMORY;
    }

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

    if ( strPrincipal.SubStringExists( _T("administrators"), FALSE ) ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;

    } else if ( strPrincipal.SubStringExists( _T("system"), FALSE ) ) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;

    } else if ( strPrincipal.SubStringExists( _T("networkservice"), FALSE ) ) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_NETWORK_SERVICE_RID;

    } else if ( strPrincipal.SubStringExists( _T("service"), FALSE ) ) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SERVICE_RID;

    } else if ( strPrincipal.SubStringExists( _T("interactive"), FALSE ) ) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;

    } else if ( strPrincipal.SubStringExists( _T("everyone"), FALSE ) ) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;

    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    Principal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetPrincipalSID():Ret=0x%x."), returnValue));
    return returnValue;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl = NULL;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CreateNewSD()")));

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);

        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED1.Return=0x%x."), returnValue));
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED2.Return=0x%x."), returnValue));
        return returnValue;
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED3.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED4.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED5.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED6.Return=0x%x."), returnValue));
        return returnValue;
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED7.Return=0x%x."), returnValue));
        return returnValue;
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED8.Return=0x%x."), returnValue));
        return returnValue;
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(*SD)) 
    {
        free (*SD);
        free (sid);
        returnValue = ERROR_INVALID_SECURITY_DESCR;
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.IsValidDaclInSD.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }
    
    
    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();


    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD,
    BOOL bCreateNewIfNotExist
    )
{
    DWORD               returnValue = ERROR_INVALID_PARAMETER;
    HKEY                registryKey;
    DWORD               valueType = 0;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //
    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);
    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            // okay it doesn't exist
            // shall we create a new one???
            if (TRUE == bCreateNewIfNotExist)
            {
                *SD = NULL;
                returnValue = CreateNewSD (SD);
                if (returnValue != ERROR_SUCCESS) 
                {
                    if (*SD){free(*SD);*SD=NULL;}
                    goto GetNamedValueSD_Exit;
                }

                *NewSD = TRUE;
                returnValue = ERROR_SUCCESS;

                //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key not exist.New SD created")));
                goto GetNamedValueSD_Exit;
            }
            else
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            goto GetNamedValueSD_Exit;
        }
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);
    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            // okay it doesn't exist
            // shall we create a new one???
            if (TRUE == bCreateNewIfNotExist)
            {
                *SD = NULL;
                returnValue = CreateNewSD (SD);
                if (returnValue != ERROR_SUCCESS) 
                {
                    if (*SD){free(*SD);*SD=NULL;}
                    goto GetNamedValueSD_Exit;
                }
                //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key exist, but value not found.New SD created")));
                *NewSD = TRUE;
            }
            else
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            goto GetNamedValueSD_Exit;
        }

    }
    else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            returnValue = ERROR_NOT_ENOUGH_MEMORY;
            goto GetNamedValueSD_Exit;
        }

        // get the SD from the registry
        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue != ERROR_SUCCESS)
        {
            if (*SD){free(*SD);*SD=NULL;}

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) 
            {
                if (*SD){free(*SD);*SD=NULL;}
                goto GetNamedValueSD_Exit;
            }

            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key exist,no mem.New SD created")));
            *NewSD = TRUE;
        }
        else
        {
            // otherwise, we successfully got the SD from an existing key!
            // let's test if the one we got is valid.
            // if it's not then log the error and create a new one.

            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key exist using SD from reg")));

            // check if our sd we got or created is valid
            if (!IsValidDaclInSD(*SD)) 
            {
                returnValue = ERROR_INVALID_SECURITY_DESCR;
                iisDebugOut((LOG_TYPE_ERROR, _T("Security Descriptor at [%s\\%s] is not valid.creating a new one temporarily to work around problem"),KeyName,ValueName));

                // try to just create a new one!
                if (*SD){free(*SD);*SD=NULL;}

                *SD = NULL;
                returnValue = CreateNewSD (SD);
                if (returnValue != ERROR_SUCCESS) 
                {
                    if (*SD){free(*SD);*SD=NULL;}
                    goto GetNamedValueSD_Exit;
                }
                *NewSD = TRUE;
            }
        }
    }

    RegCloseKey (registryKey);
    returnValue = ERROR_SUCCESS;

GetNamedValueSD_Exit:
    return returnValue;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit,
    BOOL AddInteractiveforDefault
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;
    BOOL                fCreateNewSDIfOneInRegNotThere = TRUE;

    //
    // Get security descriptor from registry or create a new one
    //
    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD, fCreateNewSDIfOneInRegNotThere);
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetNamedValueSD.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("GetSecurityDescriptorDacl.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }

    if (newSD)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        if (returnValue != ERROR_SUCCESS)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL(SYSTEM).FAILED.Return=0x%x."), returnValue));
        }

        if ( AddInteractiveforDefault )
        {
            returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
            if (returnValue != ERROR_SUCCESS)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL(INTERACTIVE).FAILED.Return=0x%x."), returnValue));
            }
        }
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
        if (returnValue != ERROR_SUCCESS)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL(%s).FAILED.Return=0x%x."), Principal,returnValue));
        }
    }
    else
    {
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);
    }
    if (returnValue != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("SetSecurityDescriptorDacl.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeSelfRelativeSD.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeSelfRelativeSD.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    returnValue = SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);
    if (ERROR_SUCCESS != returnValue)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetNamedValueSD.FAILED.Return=0x%x."), returnValue));
    }

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddPrincipalToNamedValueSD:%s.end\n"), Principal));
    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL * pbUserExistsToBeDeleted
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;
    BOOL                fCreateNewSDIfOneInRegNotThere = FALSE;

    *pbUserExistsToBeDeleted = FALSE;

    //
    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD, fCreateNewSDIfOneInRegNotThere);
    if (returnValue == ERROR_FILE_NOT_FOUND)
    {
        // this means that there is no SD in registry, so
        // there is nothing to remove from it, just exit with successs!
        returnValue = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    // check if the acl we got passed in is valid!
    if (present && dacl)
    {
        if (0 == IsValidAcl(dacl))
        {
            returnValue = ERROR_INVALID_ACL;
            goto Cleanup;
        }
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //
    if (newSD)
    {
        // but if this is a removal, then don't add system and interactive!
        // AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        // AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal,pbUserExistsToBeDeleted);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
  BOOL bUserExistsToBeDeleted = FALSE;
  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDAccessACL():APPID=%s,Principal=%s.  \n"), AppID, Principal));

  TSTR    strKeyName(256);
  TSTR    strFullKey;
  CString csData;
  DWORD   err = ERROR_SUCCESS;

  if ( !strKeyName.Format( AppID[0] == _T('{') ? _T("APPID\\%s") : _T("APPID\\{%s}") ,
                           AppID ) )
  {
    return ERROR_NOT_ENOUGH_MEMORY;
  }

  if ( !strFullKey.Copy( strKeyName ) ||
       !strFullKey.Append( _T(":A:") ) ||
       !strFullKey.Append( Principal )
     )
  {
    return ERROR_NOT_ENOUGH_MEMORY;
  }

  if (SetPrincipal)
  {
    err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("AccessPermission"), Principal,&bUserExistsToBeDeleted);
    if (TRUE == bUserExistsToBeDeleted)
    {
      // this means that in fact the user was already in there!
      // so we now have to add it back in!
      // we just want to make sure we know that it was already in there
      // so when we do an uninstall -- we don't delete the value if it was already in there!
      if (FALSE == bDumbCall)
      {
        // Do not set this on an upgrade!
        if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
          g_pTheApp->UnInstallList_Add(strFullKey.QueryStr(),MY_DCOM_PERSIST_FLAG);
        }
      }
    }

    err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("AccessPermission"), Principal, Permit);

		if (FAILED(err))
		{
			iisDebugOut((LOG_TYPE_ERROR, _T("AddPrincipalToNamedValueSD():Principal=%s.End.FAILED.Return=0x%x."), Principal, err));
		}
  }
  else
  {
    if (TRUE == bDumbCall)
    {
      csData = g_pTheApp->UnInstallList_QueryKey( strFullKey.QueryStr() );
      if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
      {
        // don't remove it!! it was already there before we even added it!
        err = ERROR_SUCCESS;
      }
      else
      {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("AccessPermission"), Principal,&bUserExistsToBeDeleted);
      }
      g_pTheApp->UnInstallList_DelKey(strFullKey.QueryStr());
    }
    else
    {
      err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("AccessPermission"), Principal,&bUserExistsToBeDeleted);
    }
  }

  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDAccessACL():APPID=%s,Principal=%s.  End.  Return=0x%x\n"), AppID, Principal, err));
  return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall,
    BOOL bAddInteractivebyDefault
    )
{
  BOOL bUserExistsToBeDeleted = FALSE;
  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDLaunchACL():APPID=%s,Principal=%s. Start."), AppID, Principal));

  TSTR    strKeyName(256);
  TSTR    strFullKey;
  CString csData;
  DWORD   err = ERROR_SUCCESS;

  if ( !strKeyName.Format( AppID[0] == _T('{') ? _T("APPID\\%s") : _T("APPID\\{%s}") ,
                           AppID ) )
  {
    return ERROR_NOT_ENOUGH_MEMORY;
  }

  if ( !strFullKey.Copy( strKeyName ) ||
       !strFullKey.Append( _T(":L:") ) ||
       !strFullKey.Append( Principal )
     )
  {
    return ERROR_NOT_ENOUGH_MEMORY;
  }


  if (SetPrincipal)
  {
    err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("LaunchPermission"), Principal,&bUserExistsToBeDeleted);
    if (TRUE == bUserExistsToBeDeleted)
    {
      // this means that in fact the user was already in there!
      // so we now have to add it back in!
      // we just want to make sure we know that it was already in there
      // so when we do an uninstall -- we don't delete the value if it was already in there!
      if (FALSE == bDumbCall)
      {
        // Do not set this on an upgrade!
        if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
          g_pTheApp->UnInstallList_Add(strFullKey.QueryStr(),MY_DCOM_PERSIST_FLAG);
        }
      }
    }

    err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr(), _T("LaunchPermission"), Principal, Permit, bAddInteractivebyDefault);

    if (FAILED(err))
	  {
		  iisDebugOut((LOG_TYPE_ERROR, _T("AddPrincipalToNamedValueSD():Principal=%s.End.FAILED.Return=0x%x."), Principal, err));
	  }
  }
  else
  {
    if (TRUE == bDumbCall)
    {
      err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("LaunchPermission"), Principal,&bUserExistsToBeDeleted);
    }
    else
    {
      csData = g_pTheApp->UnInstallList_QueryKey( strFullKey.QueryStr() );

      if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
      {
        // don't remove it!! it was already there before we even added it!
        err = ERROR_SUCCESS;
      }
      else
      {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, strKeyName.QueryStr() , _T("LaunchPermission"), Principal,&bUserExistsToBeDeleted);
      }
      g_pTheApp->UnInstallList_DelKey(strFullKey.QueryStr());
    }
  }

  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDLaunchACL():APPID=%s,Principal=%s.End.  Return=0x%x"), AppID, Principal, err));
  return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
  BOOL bUserExistsToBeDeleted = FALSE;
  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeDCOMAccessACL():Principal=%s. Start.\n"), Principal));

  TSTR    strKeyName(256);
  TSTR    strFullKey;
  DWORD   err;
  CString csData;

  if ( !strKeyName.Copy( _T("Software\\Microsoft\\OLE") ) )
  {
    return ERROR_NOT_ENOUGH_MEMORY;
  }

  if ( !strFullKey.Copy( _T("DCOM_DA:") ) ||
       !strFullKey.Append( Principal )
     )
  {
    return ERROR_NOT_ENOUGH_MEMORY;
  }

  if (SetPrincipal)
  {
    err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, strKeyName.QueryStr() , _T("DefaultAccessPermission"), Principal,&bUserExistsToBeDeleted);

    if (TRUE == bUserExistsToBeDeleted)
    {
      // this means that in fact the user was already in there!
      // so we now have to add it back in!
      // we just want to make sure we know that it was already in there
      // so when we do an uninstall -- we don't delete the value if it was already in there!
      if (FALSE == bDumbCall)
      {
        // Do not set this on an upgrade!
        if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
          g_pTheApp->UnInstallList_Add(strFullKey.QueryStr(),MY_DCOM_PERSIST_FLAG);
        }
      }
    }

    err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, strKeyName.QueryStr() , _T("DefaultAccessPermission"), Principal, Permit);

	  if (FAILED(err))
	  {
		  iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMAccessACL():Principal=%s.End.FAILED.Return=0x%x."), Principal, err));
	  }
  }
  else
  {
    // Should we remove this principle from there?
    // we should only do it if we actually had added them.
    // the problem is that before iis5.1 we didn't have this information
    // so when we go look in the registry to find "DCOM_DA:iusr_computername", we won't find it
    // because iis5.1 setup hasn't been run yet.

    // if "DCOM_DA:IUSR_COMPUTERNAME" exists and it is = MY_DCOM_PERSIST_FLAG
    // then do not allow the entry to be deleted!
    // that's because iis5.1 when trying to add the entry -- found that it was already there!
    if (TRUE == bDumbCall)
    {
      err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, strKeyName.QueryStr() , _T("DefaultAccessPermission"), Principal,&bUserExistsToBeDeleted);
    }
    else
    {
      csData = g_pTheApp->UnInstallList_QueryKey(strFullKey.QueryStr());
      if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
      {
        // don't remove it!! it was already there before we even added it!
        err = ERROR_SUCCESS;
      }
      else
      {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, strKeyName.QueryStr() , _T("DefaultAccessPermission"), Principal,&bUserExistsToBeDeleted);
      }
      g_pTheApp->UnInstallList_DelKey(strFullKey.QueryStr());
    }
  }

  iisDebugOut((LOG_TYPE_TRACE, _T("ChangeDCOMAccessACL():End.Return=0x%x"), err));
  return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
    BOOL bUserExistsToBeDeleted = FALSE;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeDCOMLaunchACL():Principal=%s. Start.\n"), Principal));

    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    CString csKey;
    CString csData;
    csKey = _T("DCOM_DL:");
    csKey += Principal;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal,&bUserExistsToBeDeleted);
        if (TRUE == bUserExistsToBeDeleted)
        {
            // this means that in fact the user was already in there!
            // so we now have to add it back in!
            // we just want to make sure we know that it was already in there
            // so when we do an uninstall -- we don't delete the value if it was already in there!
            if (FALSE == bDumbCall)
            {
              // Do not set this on an upgrade!
              if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
              {
                  g_pTheApp->UnInstallList_Add(csKey,MY_DCOM_PERSIST_FLAG);
              }
            }
        }

        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
		if (FAILED(err))
		{
			iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMLaunchACL():Principal=%s.End.FAILED.Return=0x%x"), Principal, err));
		}
    }
    else
    {

        // Should we remove this principle from there?
        // we should only do it if we actually had added them.
        // the problem is that before iis5.1 we didn't have this information
        // so when we go look in the registry to find "DCOM_DL:iusr_computername", we won't find it
        // because iis5.1 setup hasn't been run yet.

        // if "DCOM_DL:IUSR_COMPUTERNAME" exists and it is = MY_DCOM_PERSIST_FLAG
        // then do not allow the entry to be deleted!
        // that's because iis5.1 when trying to add the entry -- found that it was already there!
        if (TRUE == bDumbCall)
        {
            err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal,&bUserExistsToBeDeleted);
        }
        else
        {
            csData = g_pTheApp->UnInstallList_QueryKey(csKey);
            if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
            {
                // don't remove it!! it was already there before we even added it!
                err = ERROR_SUCCESS;
            }
            else
            {
                err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal,&bUserExistsToBeDeleted);
            }
            g_pTheApp->UnInstallList_DelKey(csKey);
        }
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("ChangeDCOMLaunchACL():End.\n"), err));
    return err;
}



BOOL
MakeAbsoluteCopyFromRelative(
    PSECURITY_DESCRIPTOR  psdOriginal,
    PSECURITY_DESCRIPTOR* ppsdNew
    )
{
    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
    PSECURITY_DESCRIPTOR                psdAbsoluteCopy = NULL;
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;
    PACL Dacl = NULL, Sacl = NULL;

    BOOL                                bDefaulted;
    PSID Owner = NULL, Group = NULL;

    DWORD                               dwDaclSize = 0;
    BOOL                                bDaclPresent = FALSE;
    DWORD                               dwSaclSize = 0;
    BOOL                                bSaclPresent = FALSE;

    DWORD                               dwOwnerSize = 0;
    DWORD                               dwPrimaryGroupSize = 0;

    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        return FALSE;
    }

    if( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
        DWORD err = GetLastError();
        goto cleanup;
    }

    if( sdc & SE_SELF_RELATIVE ) {
        // the original is in self-relative format, build an absolute copy

        // get the dacl
        if( !GetSecurityDescriptorDacl(
                                      psdOriginal,      // address of security descriptor
                                      &bDaclPresent,    // address of flag for presence of disc. ACL
                                      &Dacl,           // address of pointer to ACL
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            goto cleanup;
        }

        // get the sacl
        if( !GetSecurityDescriptorSacl(
                                      psdOriginal,      // address of security descriptor
                                      &bSaclPresent,    // address of flag for presence of disc. ACL
                                      &Sacl,           // address of pointer to ACL
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            goto cleanup;
        }

        // get the owner
        if( !GetSecurityDescriptorOwner(
                                       psdOriginal,    // address of security descriptor
                                       &Owner,        // address of pointer to owner security
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            goto cleanup;
        }

        // get the group
        if( !GetSecurityDescriptorGroup(
                                       psdOriginal,    // address of security descriptor
                                       &Group, // address of pointer to owner security
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            goto cleanup;
        }

        // get required buffer size
        cb = 0;
        MakeAbsoluteSD(
                      psdOriginal,              // address of self-relative SD
                      psdAbsoluteCopy,          // address of absolute SD
                      &cb,                      // address of size of absolute SD
                      NULL,                     // address of discretionary ACL
                      &dwDaclSize,              // address of size of discretionary ACL
                      NULL,                     // address of system ACL
                      &dwSaclSize,              // address of size of system ACL
                      NULL,                     // address of owner SID
                      &dwOwnerSize,             // address of size of owner SID
                      NULL,                     // address of primary-group SID
                      &dwPrimaryGroupSize       // address of size of group SID
                      );

        // alloc the memory
        psdAbsoluteCopy = (PSECURITY_DESCRIPTOR) malloc( cb );
        Dacl = (PACL) malloc( dwDaclSize );
        Sacl = (PACL) malloc( dwSaclSize );
        Owner = (PSID) malloc( dwOwnerSize );
        Group = (PSID) malloc( dwPrimaryGroupSize );

        if(NULL == psdAbsoluteCopy ||
           NULL == Dacl ||
           NULL == Sacl ||
           NULL == Owner ||
           NULL == Group
          ) {
            goto cleanup;
        }

        // make the copy
        if( !MakeAbsoluteSD(
                           psdOriginal,            // address of self-relative SD
                           psdAbsoluteCopy,        // address of absolute SD
                           &cb,                    // address of size of absolute SD
                           Dacl,                  // address of discretionary ACL
                           &dwDaclSize,            // address of size of discretionary ACL
                           Sacl,                  // address of system ACL
                           &dwSaclSize,            // address of size of system ACL
                           Owner,                 // address of owner SID
                           &dwOwnerSize,           // address of size of owner SID
                           Group,          // address of primary-group SID
                           &dwPrimaryGroupSize     // address of size of group SID
                           )
          ) {
            goto cleanup;
        }
    } else {
        // the original is in absolute format, fail
        goto cleanup;
    }

    *ppsdNew = psdAbsoluteCopy;

    // paranoia check
    if( !IsValidSecurityDescriptor( *ppsdNew ) ) {
        goto cleanup;
    }
    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        goto cleanup;
    }

    return(TRUE);

cleanup:
    if( Dacl != NULL ) {
        free((PVOID) Dacl );
        Dacl = NULL;
    }
    if( Sacl != NULL ) {
        free((PVOID) Sacl );
        Sacl = NULL;
    }
    if( Owner != NULL ) {
        free((PVOID) Owner );
        Owner = NULL;
    }
    if( Group != NULL ) {
        free((PVOID) Group );
        Group = NULL;
    }
    if( psdAbsoluteCopy != NULL ) {
        free((PVOID) psdAbsoluteCopy );
        psdAbsoluteCopy = NULL;
    }

    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\complus.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        complus.hxx

   Abstract:

        Classes that are used to activate the COM+ and 
        DTC components

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       April 2002: Created

--*/

#include "stdafx.h"
#include "complus.hxx"

// Constructor
//
CCOMPlusInstallComponent::CCOMPlusInstallComponent():
  m_hComSetupDll( NULL )
{
  
}

// Destructor
//
CCOMPlusInstallComponent::~CCOMPlusInstallComponent()
{
  if ( m_hComSetupDll == NULL )
  {
    // Free the library
    DBG_REQUIRE( m_hComSetupDll );
  }
}

// InitializeComSetupDll
//
// Initialize the Com Setup Dll
// This loads the dll, so that we can call the exported functions
// by it.
//
BOOL 
CCOMPlusInstallComponent::InitializeComSetupDll()
{
  TSTR_PATH strPath;

  if ( m_hComSetupDll != NULL )
  {
    // Since this is already opened, lets return true
    return TRUE;
  }

  if ( !strPath.RetrieveSystemDir() ||
       !strPath.PathAppend( STRING_SETUPFILES_LOCATION ) ||
       !strPath.PathAppend( STRING_COMPLUS_SETUPDLL ) )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("COMPlus setup, failed to construct path\n") ) );


    return FALSE;
  }

  m_hComSetupDll = LoadLibrary( strPath.QueryStr() );

  if ( m_hComSetupDll == NULL )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("COMPlus setup, failed to LoadLibrary on '%s'\n"),
                   STRING_COMPLUS_SETUPDLL ) );
  }

  return ( m_hComSetupDll != NULL );
}

// InstallComponent
//
// Install or Uninstall the Component
//
// Parameters:
//   bInstall - TRUE  == Install
//              FALSE == Uninstall
//
BOOL 
CCOMPlusInstallComponent::InstallComponent( BOOL bInstall )
{
  pComDtc_Set pfnInstall = NULL;
  HRESULT     hr;

  if ( !InitializeComSetupDll() )
  {
    // Failed to initialize, bail
    return FALSE;
  }

  pfnInstall = (pComDtc_Set) GetProcAddress(m_hComSetupDll, 
                                             STRING_COM_INSTALLFUNCTION );

  if ( pfnInstall == NULL )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("COMPlus Install/Uninstall call failed, could not find exported function.  GLE=0x%8x\n"),
                   GetLastError() ) );

    return FALSE;
  }

  hr = pfnInstall( bInstall ? TRUE : FALSE );

  if ( FAILED( hr ) )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("COMPlus Install/Uninstall call failed, hr=0x%8x\n"),
                   hr ) );
  }

  return ( SUCCEEDED( hr ) );
}

// Install
//
// Install the COM+ Component
//
BOOL
CCOMPlusInstallComponent::Install()
{
  return InstallComponent( TRUE );
}

// PostUnInstall
//
// UnInstall the COM+ Component
// This must be done in OC_COMPLETE, so we are doing it in PostUninstall
//
BOOL
CCOMPlusInstallComponent::PostUnInstall()
{
  return InstallComponent( FALSE );
}

// IsInstalled
//
// Return if COM+ is installed
//
BOOL
CCOMPlusInstallComponent::IsInstalled( LPBOOL pbIsInstalled )
{
  pComDtc_Get pfnIsInstalled = NULL;
  HRESULT     hr;

  ASSERT( pbIsInstalled );

  if ( !InitializeComSetupDll() )
  {
    // Failed to initialize, bail
    return FALSE;
  }

  pfnIsInstalled = (pComDtc_Get) GetProcAddress(m_hComSetupDll, 
                                    STRING_COM_ISINSTALLEDFUNCTION );

  if ( pfnIsInstalled == NULL )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("COMPlus IsInstalled call failed, could not find exported function.  GLE=0x%8x\n"),
                   GetLastError() ) );

    return FALSE;
  }

  hr = pfnIsInstalled( &g_OCMInfo, pbIsInstalled );

  if ( FAILED( hr ) )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("COMPlus Install/Uninstall call failed, hr=0x%8x\n"),
                   hr ) );
  }

  return ( SUCCEEDED( hr ) );
}

// GetFriendlyName
//
// Retrieve the FriendlyName of the COM+ Component
//
BOOL 
CCOMPlusInstallComponent::GetFriendlyName( TSTR *pstrFriendlyName )
{
  return pstrFriendlyName->LoadString( IDS_COMPLUS_COMPONETNAME );
}

// GetName
// 
// Get the name of the component in the inf
//
LPTSTR 
CCOMPlusInstallComponent::GetName()
{
  return g_ComponentList[ COMPONENT_COMPLUS ].szComponentName;
}

// GetSmallIcon
//
// Retrieve the small icon for this OCM component
//
BOOL 
CCOMPlusInstallComponent::GetSmallIcon( HBITMAP *phIcon )
{
  *phIcon = LoadBitmap( (HINSTANCE) g_MyModuleHandle, 
                        MAKEINTRESOURCE( IDB_ICON_COMPLUS ));

  return ( *phIcon != NULL );
}

// Constructor
//
CDTCInstallComponent::CDTCInstallComponent():
  m_hDtcSetupDll( NULL )
{
  
}

// Destructor
//
CDTCInstallComponent::~CDTCInstallComponent()
{
  if ( m_hDtcSetupDll == NULL )
  {
    // Free the library
    DBG_REQUIRE( m_hDtcSetupDll != NULL );
  }
}

// InitializeComSetupDll
//
// Initialize the Com Setup Dll
// This loads the dll, so that we can call the exported functions
// by it.
//
BOOL 
CDTCInstallComponent::InitializeDtcSetupDll()
{
  TSTR_PATH strPath;

  if ( m_hDtcSetupDll != NULL )
  {
    // Since this is already opened, lets return true
    return TRUE;
  }

  if ( !strPath.RetrieveSystemDir() ||
       !strPath.PathAppend( STRING_SETUPFILES_LOCATION ) ||
       !strPath.PathAppend( STRING_DTC_SETUPDLL ) )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("DTC setup, failed to construct path\n") ) );


    return FALSE;
  }

  m_hDtcSetupDll = LoadLibrary( strPath.QueryStr() );

  if ( m_hDtcSetupDll == NULL )
  {
    // Log the error
    iisDebugOut((LOG_TYPE_ERROR, 
                 _T("DTC setup, failed to LoadLibrary on '%s'\n"),
                 STRING_COMPLUS_SETUPDLL ) );
  }

  return ( m_hDtcSetupDll != NULL );
}

// InstallComponent
//
// Install or Uninstall the Component
//
// Parameters:
//   bInstall - TRUE  == Install
//              FALSE == Uninstall
//
BOOL 
CDTCInstallComponent::InstallComponent( BOOL bInstall )
{
  pComDtc_Set pfnInstall = NULL;
  HRESULT     hr;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling InstallComponent\n")));

  if ( !InitializeDtcSetupDll() )
  {
    // Failed to initialize, bail
    return FALSE;
  }

  pfnInstall = (pComDtc_Set) GetProcAddress(m_hDtcSetupDll, 
                                            STRING_DTC_INSTALLFUNCTION );

  if ( pfnInstall == NULL )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("DTC Install/Uninstall call failed, could not find exported function.  GLE=0x%8x\n"),
                   GetLastError() ) );

    return FALSE;
  }

  hr = pfnInstall( bInstall ? TRUE : FALSE );

  if ( FAILED( hr ) )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("DTC Install/Uninstall call failed, hr=0x%8x\n"),
                   hr ) );
  }

  return ( SUCCEEDED( hr ) );
}

// Install
//
// Install the COM+ Component
//
BOOL
CDTCInstallComponent::Install()
{
  return InstallComponent( TRUE );
}

// PostUnInstall
//
// UnInstall the COM+ Component
// Because this needs to be done in OC_COMPLETE, we do it in
// PostUnInstall
//
BOOL
CDTCInstallComponent::PostUnInstall()
{
  return InstallComponent( FALSE );
}

// IsInstalled
//
// Return if DTC is installed
//
BOOL
CDTCInstallComponent::IsInstalled( LPBOOL pbIsInstalled )
{
  pComDtc_Get pfnIsInstalled = NULL;
  HRESULT     hr;

  ASSERT( pbIsInstalled );

  if ( !InitializeDtcSetupDll() )
  {
    // Failed to initialize, bail
    return FALSE;
  }

  pfnIsInstalled = (pComDtc_Get) GetProcAddress(m_hDtcSetupDll, 
                                            STRING_DTC_ISINSTALLEDFUNCTION );

  if ( pfnIsInstalled == NULL )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("DTC IsInstalled call failed, could not find exported function.  GLE=0x%8x\n"),
                   GetLastError() ) );

    return FALSE;
  }

  hr = pfnIsInstalled( &g_OCMInfo, pbIsInstalled );

  if ( FAILED( hr ) )
  {
    // Log the error
    iisDebugOut( ( LOG_TYPE_ERROR, 
                   _T("DTC Install/Uninstall call failed, hr=0x%8x\n"),
                   hr ) );
  }

  return ( SUCCEEDED( hr ) );
}

// GetFriendlyName
//
// Retrieve the FriendlyName of the DTC Component
//
BOOL 
CDTCInstallComponent::GetFriendlyName( TSTR *pstrFriendlyName )
{
  return pstrFriendlyName->LoadString( IDS_DTC_COMPONETNAME );
}

// GetName
// 
// Get the name of the component in the inf
//
LPTSTR 
CDTCInstallComponent::GetName()
{
  return g_ComponentList[ COMPONENT_DTC ].szComponentName;
}

// GetSmallIcon
//
// Retrieve the small icon for this OCM component
//
BOOL 
CDTCInstallComponent::GetSmallIcon( HBITMAP *phIcon )
{
  *phIcon = LoadBitmap( (HINSTANCE) g_MyModuleHandle, 
                        MAKEINTRESOURCE( IDB_ICON_DTC ));

  return ( *phIcon != NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\const.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        const.cxx

   Abstract:

        Repository for the constants that are used throughout
        the project

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       April 2002: Created

--*/

#include "stdafx.h"
#include "resource.h"

//
// This struct, and the enum below it must mach up
//
struct sComponentList g_ComponentList[] = 
  //  Component ID                      Product Name              Sel by    Incl. in
  //                                                              Default   GrpPol Deny
  { { _T("iis"),                        0,                        TRUE,     FALSE   },
    { _T("iis_common"),                 0,                        TRUE,     TRUE    },
    { _T("iis_inetmgr"),                0,                        TRUE,     TRUE    },
    { _T("iis_pwmgr"),                  0,                        FALSE,    TRUE    },
    { _T("iis_www_parent"),             0,                        TRUE,     TRUE    },
    { _T("iis_www"),                    0,                        TRUE,     TRUE    },
    { _T("iis_www_vdir_scripts"),       0,                        FALSE,    TRUE    },
    { _T("iis_doc"),                    0,                        FALSE,    TRUE    },
    { _T("iis_ftp"),                    0,                        FALSE,    TRUE    },
    { _T("sakit_web"),                  0,                        FALSE,    TRUE    },
    { _T("appsrv"),                     0,                        FALSE,    FALSE   },
    { _T("appsrv_console"),             0,                        TRUE,     FALSE   },
    { _T("complusnetwork"),             0,                        FALSE,    FALSE   },
    { _T("dtcnetwork"),                 0,                        FALSE,    FALSE   },
    { _T("IIS_ASP"),                    IDS_PRODUCT_ASP,          FALSE,    TRUE    },
    { _T("IIS_InternetDataConnector"),  IDS_PRODUCT_HTTPODBC,     FALSE,    TRUE    },
    { _T("IIS_ServerSideIncludes"),     IDS_PRODUCT_SSINC,        FALSE,    TRUE    },
    { _T("IIS_WebDav"),                 IDS_PRODUCT_WEBDAV,       FALSE,    TRUE    },
    { NULL },
  };

//
// This struct enumerates all of the extensions that IIS installs
//
struct sOurDefaultExtensions g_OurExtensions[] = 
  { { _T("asp.dll"),
      _T("ASP"),
      g_ComponentList[ COMPONENT_IIS_WWW_ASP ].dwProductName,
      g_ComponentList[ COMPONENT_IIS_WWW_ASP ].szComponentName,
      FALSE,
      FALSE,
      { _T(".asp"),
        _T(".asa"),
        _T(".cer"),
        _T(".cdx"),
        NULL
      } 
    },
    { _T("httpodbc.dll"),
      _T("HTTPODBC"),
      g_ComponentList[ COMPONENT_IIS_WWW_HTTPODBC ].dwProductName,
      g_ComponentList[ COMPONENT_IIS_WWW_HTTPODBC ].szComponentName,
      FALSE,
      FALSE,
      { _T(".idc"),
        NULL
      }
    },
    { _T("ssinc.dll"),
      _T("SSINC"),
      g_ComponentList[ COMPONENT_IIS_WWW_SSINC ].dwProductName,
      g_ComponentList[ COMPONENT_IIS_WWW_SSINC ].szComponentName,
      FALSE,
      FALSE,
      { _T(".stm"),
        _T(".shtm"),
        _T(".shtml"),
        NULL 
      }
    },
    { _T("httpext.dll"),
      _T("WEBDAV"),
      g_ComponentList[ COMPONENT_IIS_WWW_WEBDAV ].dwProductName,
      g_ComponentList[ COMPONENT_IIS_WWW_WEBDAV ].szComponentName,
      FALSE,
      FALSE,
      { NULL
      }
    }
  };

//
// This is the structure that OCM give us
//
SETUP_INIT_COMPONENT g_OCMInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\dcomperm.h ===
DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD,
    BOOL bCreateNewIfNotExist
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit,
    BOOL AddInteractiveforDefault = TRUE
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL * pbUserExistsToBeDeleted
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD 
ReOrderACL (
    PACL *ACLtoReplace
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal,
    BOOL *pbUserExistsToBeDeleted
    );

DWORD   GetPrincipalSID (LPTSTR Principal,PSID *Sid,BOOL *pbWellKnownSID);
DWORD   ChangeAppIDAccessACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
DWORD   ChangeAppIDLaunchACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall, BOOL bAddInteractivebyDefault = TRUE );
DWORD   ChangeDCOMAccessACL (LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
DWORD   ChangeDCOMLaunchACL (LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
BOOL    MakeAbsoluteCopyFromRelative(PSECURITY_DESCRIPTOR  psdOriginal,PSECURITY_DESCRIPTOR* ppsdNew);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\const.h ===
// this is the max resource string length
#define MAX_STR_LEN 1024

#define SERVICENAME_IISADMIN            _T("IISADMIN")
#define SERVICENAME_HTTP_SSL_PROVIDER   _T("HTTPFILTER")
#define SERVICENAME_NTLMSSP             _T("NTLMSSP")

const TCHAR REG_INETSTP[]           = _T("Software\\Microsoft\\INetStp");
const TCHAR REG_IISADMIN[]          = _T("System\\CurrentControlSet\\Services\\IISADMIN");
const TCHAR REG_W3SVC[]             = _T("System\\CurrentControlSet\\Services\\W3SVC");
const TCHAR REG_HTTPSYS_PARAM[]     = _T("System\\CurrentControlSet\\Services\\HTTP\\Parameters");
const TCHAR REG_MSFTPSVC[]          = _T("System\\CurrentControlSet\\Services\\MSFTPSVC");
const TCHAR REG_GOPHERSVC[]         = _T("System\\CurrentControlSet\\Services\\GOPHERSVC");
const TCHAR REG_MIMEMAP[]           = _T("System\\CurrentControlSet\\Services\\InetInfo\\Parameters\\MimeMap");

const TCHAR REG_ASP_UNINSTALL[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ActiveServerPages");

const TCHAR REG_INETINFOPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");
const TCHAR REG_WWWPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\W3Svc\\Parameters");
const TCHAR REG_WWWVROOTS[] = _T("System\\CurrentControlSet\\Services\\W3Svc\\Parameters\\Virtual Roots");
const TCHAR REG_WWWPERFORMANCE[] = _T("System\\CurrentControlSet\\Services\\W3svc\\Performance");
const TCHAR REG_EVENTLOG_SYSTEM[] = _T("System\\CurrentControlSet\\Services\\EventLog\\System");
const TCHAR REG_EVENTLOG_APPLICATION[] = _T("System\\CurrentControlSet\\Services\\EventLog\\Application");
const TCHAR REG_FTPPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\MSFtpsvc\\Parameters");
const TCHAR REG_FTPVROOTS[] = _T("System\\CurrentControlSet\\Services\\MSFtpsvc\\Parameters\\Virtual Roots");
const TCHAR REG_HTTPSYS_DISABLESERVERHEADER[] = _T("DisableServerHeader");

const TCHAR REG_INSTALLSTATE[] = _T("CurrentInstallState");

const TCHAR REG_SNMPPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters");
const TCHAR REG_SNMPEXTAGENT[] = _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ExtensionAgents");

const TCHAR REG_GROUPPOLICY_BLOCKINSTALL_PATH[] = _T("Software\\Policies\\Microsoft\\Windows NT\\IIS");
const TCHAR REG_GROUPPOLICY_BLOCKINSTALL_NAME[] = _T("PreventIISInstall");

enum OS	{OS_NT, OS_W95, OS_OTHERS};

enum NT_OS_TYPE {OT_NT_UNKNOWN, OT_NTS, OT_PDC_OR_BDC, OT_NTW};

enum UPGRADE_TYPE {UT_NONE, UT_351, UT_10_W95, UT_10, UT_20, UT_30, UT_40, UT_50, UT_51, UT_60};

enum INSTALL_MODE {IM_FRESH,IM_UPGRADE,IM_MAINTENANCE, IM_DEGRADE};

enum ACTION_TYPE {AT_DO_NOTHING, AT_REMOVE, AT_INSTALL_FRESH, AT_INSTALL_UPGRADE, AT_INSTALL_REINSTALL};

enum STATUS_TYPE {ST_UNKNOWN, ST_INSTALLED, ST_UNINSTALLED};

const TCHAR REG_PRODUCTOPTIONS[] = _T("System\\CurrentControlSet\\Control\\ProductOptions");
const TCHAR UNATTEND_FILE_SECTION[] = _T("InternetServer");
const TCHAR REG_SETUP_UNINSTALLINFO[] = _T("UninstallInfo");
const WCHAR SECTIONNAME_STRINGS[] = L"Strings";
const WCHAR SECTION_STRINGS_CDNAME[] = L"cdname";
const TCHAR COMPONENTS_SAKIT_WEB[] = _T("sakit_web");

// App Compat Data
const TCHAR APPCOMPAT_DBNAME[]                    = _T("AppPatch\\sysmain.sdb");
const TCHAR APPCOMPAT_TAG_BASEPATH[]              = _T("BasePath");
const TCHAR APPCOMPAT_TAG_PATHTYPE[]              = _T("PathType");
const TCHAR APPCOMPAT_TYPE_PHYSICALPATH[]         = _T("0");
const TCHAR APPCOMPAT_TAG_SHIM_IIS[]              = _T("EnableIIS");
const TCHAR APPCOMPAT_TAG_WEBSVCEXT[]             = _T("WebSvcExtensions");
const TCHAR APPCOMPAT_TAG_SETUPINDICATOR[]        = _T("SetupIndicatorFile");
const TCHAR APPCOMPAT_REG_HKLM[]                  = _T("HKEY_LOCAL_MACHINE");
const TCHAR APPCOMPAT_REG_HKCU[]                  = _T("HKEY_CURRENT_USER");
const TCHAR APPCOMPAT_REG_HKCR[]                  = _T("HKEY_CLASSES_ROOT");
const TCHAR APPCOMPAT_REG_HKU[]                   = _T("HKEY_USERS");
const TCHAR APPCOMPAT_REG_HKCC[]                  = _T("HKEY_CURRENT_CONFIG");
const TCHAR APPCOMPAT_DB_GROUPID[]                = _T("GroupID");
const TCHAR APPCOMPAT_DB_GROUPDESC[]              = _T("GroupDesc");
const TCHAR APPCOMPAT_DB_APPNAME[]                = _T("AppName");
const TCHAR APPCOMPAT_DB_ENABLE_EXT_GROUPS[]      = _T("EnableExtGroups");

#define UNATTEND_INETSERVER_APPLICATIONDEPENDENCIES   _T("ApplicationDependency")
#define UNATTEND_INETSERVER_EXTENSIONRESTRICTIONLIST  _T("ExtensionFile")
#define UNATTEND_WEBAPPSERVER_SECTIONNAME             _T("AppServer")
#define UNATTEND_INETSERVER_DISABLEW3SVC              _T("DisableWebServiceOnUpgrade")

#define REGISTR_IISSETUP_DISABLEW3SVC   _T("DisableW3SVC")


// 0 = log errors only
// 1 = log errors and warnings
// 2 = log errors, warnings and program flow type statemtns
// 3 = log errors, warnings, program flow and basic trace activity
// 4 = log errors, warnings, program flow, basic trace activity and trace to win32 api calls.
const int LOG_TYPE_ERROR = 0;
const int LOG_TYPE_WARN  = 1;
const int LOG_TYPE_PROGRAM_FLOW = 2;
const int LOG_TYPE_TRACE = 3;
const int LOG_TYPE_TRACE_WIN32_API = 4;

#define USERS_LOCALSERVICE          _T("NT Authority\\Local Service")
#define USERS_NETWORKSERVICE        _T("NT Authority\\Network Service")
#define USERS_SYSTEM                _T("NT Authority\\System")

#define KEYTYPE_FILTER			              _T("IIsFilter")
#define KEYTYPE_FILTERS			              _T("IIsFilters")
#define METABASEPATH_FILTER_GLOBAL_ROOT   _T("/LM/W3SVC/Filters")
#define METABASEPATH_FILTER_PATH          _T("/Filters")
#define METABASEPATH_WWW_ROOT             _T("/LM/W3SVC")
#define METABASEPATH_WWW_INFO             ( METABASEPATH_WWW_ROOT _T("/Info") )
#define REG_FILTERDLLS                    _T("Filter DLLs")
#define REG_FILTER_DELIMITER              ','
#define METABASEPATH_FTP_ROOT             _T("/LM/MSFTPSVC")
#define METABASEPATH_SCHEMA               _T("/Schema/")

#define METABASEPATH_DEFAULTSITE          _T("/LM/W3SVC/1/Root")
#define METABASEPATH_VDIRSCRIPTS          L"Scripts"

#define PATH_WWW_CUSTOMERRORS             _T("\\Help\\iishelp\\common")
#define PATH_IISHELP                      _T("\\help\\iismmc.chm")
#define PATH_IISHELP_FAT_NTFS_WARNING     _T("/htm/sec_acc_ntfspermovr.htm")

#define PATH_PASSPORT                     _T("MicrosoftPassport")
const TCHAR PATH_HISTORYFILES[] =         _T("History");
const TCHAR PATH_METABASEBACKUPS[] =      _T("MetaBack");
const TCHAR PATH_TEMPORARY_COMPRESSION_FILES[] =  _T("IIS Temporary Compressed Files");
const TCHAR PATH_TEMPORARY_ASP_FILES[]         =  _T("inetsrv\\ASP Compiled Templates");

const TCHAR PATH_FULL_HISTORY_DIR[]          = _T("%windir%\\system32\\inetsrv\\History");
const TCHAR PATH_FULL_HISTORY_ALLFILES[]     = _T("%windir%\\system32\\inetsrv\\History\\*");
const TCHAR PATH_FULL_METABACK_ALLFILES[]    = _T("%windir%\\system32\\inetsrv\\Metaback\\*");
const TCHAR PATH_FULL_METABASE_FILE[]        = _T("%windir%\\system32\\inetsrv\\Metabase.xml");
const TCHAR PATH_FULL_METABASE_BACKUPFILE[]  = _T("%windir%\\system32\\inetsrv\\metabase.bak");
const TCHAR PATH_FULL_METABASE_TEMPFILE[]    = _T("%windir%\\system32\\inetsrv\\metabase.xml.tmp");
const TCHAR PATH_FULL_MBSCHEMA_FILE[]        = _T("%windir%\\system32\\inetsrv\\mbschema.xml");
const TCHAR PATH_FULL_MBSCHEMA_BINFILES[]    = _T("%windir%\\system32\\inetsrv\\mbschema.bin.*");

const TCHAR PATH_METABASE_FILE[] =        _T("Metabase.xml");
const TCHAR PATH_MBSCHEMA_FILE[] =        _T("MbSchema.xml");

const TCHAR METABASEPATH_UPG_IISHELP_WEB1_ROOT[]   = _T("/LM/W3SVC/1/ROOT");
const TCHAR METABASEPATH_UPG_IISHELP_WEB2_ROOT[]   = _T("/LM/W3SVC/2/ROOT");
const TCHAR METABASEPATH_UPG_IISHELP_NAME[]        = _T("IISHelp");
const TCHAR PATH_UPG_IISHELP_1[]                   = _T("Help");
const TCHAR PATH_UPG_IISHELP_2[]                   = _T("Help\\iishelp");
const TCHAR PATH_IISHELP_DEL[]                     = _T("Help\\iishelp\\iis");

const TCHAR METABASE_PHYS_RESTR_UPG_NODETYPE[]     = _T("IIsWebService");
const TCHAR METABASE_PHYS_RESTR_UPG_PROPTYPE[]     = _T("Location");
const TCHAR METABASE_PHYS_RESTR_UPG_PROPVALUE[]    = _T("/LM/W3SVC");
const TCHAR METABASE_PHYS_RESTR_ISAPI[]            = _T("IsapiRestrictionList");
const TCHAR METABASE_PHYS_RESTR_CGI[]              = _T("CgiRestrictionList");

struct sComponentList {
  LPTSTR  szComponentName;
  DWORD   dwProductName;
  BOOL    bSelectedByDefault;
  BOOL    bIncludedInGroupPolicyDeny;
};

extern struct sComponentList g_ComponentList[];

enum COMPONENT_INDEXES {
  COMPONENT_IIS                   = 0,
  COMPONENT_IIS_COMMON            = 1,
  COMPONENT_IIS_INETMGR           = 2,
  COMPONENT_IIS_PWMGR             = 3,
  COMPONENT_IIS_WWW_PARENT        = 4,
  COMPONENT_IIS_WWW               = 5,
  COMPONENT_IIS_WWW_VDIR_SCRIPTS  = 6,
  COMPONENT_IIS_DOC               = 7,
  COMPONENT_IIS_FTP               = 8,
  COMPONENT_SAKIT_WEB             = 9,
  COMPONENT_WEBAPPSRV             = 10,
  COMPONENT_WEBAPPSRV_CONSOLE     = 11,
  COMPONENT_COMPLUS               = 12,
  COMPONENT_DTC                   = 13,
  COMPONENT_IIS_WWW_ASP           = 14,
  COMPONENT_IIS_WWW_HTTPODBC      = 15,
  COMPONENT_IIS_WWW_SSINC         = 16,
  COMPONENT_IIS_WWW_WEBDAV        = 17,
  COMPONENT_ENDOFLIST             = 18    // This must be index last
};

struct sOurDefaultExtensions {
  static const DWORD MaxFileExtCount = 5;

  LPTSTR szFileName;
  LPTSTR szNotLocalizedGroupName;
  DWORD  dwProductName;
  LPTSTR szUnattendName;
  BOOL   bUIDeletable;
  BOOL   bAllowedByDefault;
  LPTSTR szExtensions[ MaxFileExtCount ];
};

extern struct sOurDefaultExtensions g_OurExtensions[]; 

enum EXTENSION_EXTENSIONS {
  EXTENSION_ASP                   = 0,
  EXTENSION_HTTPODBC              = 1,
  EXTENSION_SSINC                 = 2,
  EXTENSION_WEBDAV                = 3,
  EXTENSION_ENDOFLIST             = 4     // This must be indexed last
};

extern SETUP_INIT_COMPONENT g_OCMInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\dllmain.cpp ===
#include "stdafx.h"
#include <afxinet.h>
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "massupdt.h"
#include "log.h"
#include "other.h"
#include "mtxadmin.h"
#include "mdentry.h"
#include "kill.h"
#include "svc.h"
#include "wolfpack.h"
#include "sakit.hxx"
#include "filter.hxx"
#include "compinst.hxx"
#include "lockdown.hxx"
#include "reg.hxx"
#include <htmlhelp.h>
#pragma hdrstop

int g_GlobalTickValue = 1;
int g_GlobalGuiOverRide = 0;
int g_GlobalTotalTickGaugeCount = 0;
int g_GlobalTickTotal_iis_common = 0;
int g_GlobalTickTotal_iis_inetmgr = 0;
int g_GlobalTickTotal_iis_www = 0;
int g_GlobalTickTotal_iis_pwmgr = 0;
int g_GlobalTickTotal_iis_doc = 0;
int g_GlobalTickTotal_iis_htmla = 0;
int g_GlobalTickTotal_iis_ftp = 0;

TCHAR g_szCurrentSubComponent[25];

// OcManage globals
OCMANAGER_ROUTINES gHelperRoutines;
HANDLE g_MyModuleHandle = NULL;

const TCHAR OC_MANAGER_SETUP_KEY[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");

const TCHAR OCM_OptionalComponents_Section[] = _T("Optional Components");
const TCHAR STRING_iis[]          = _T("iis");
const TCHAR STRING_iis_htmla[] = _T("iis_htmla");
const TCHAR STRING_iis_doc[]   = _T("iis_doc");
const TCHAR STRING_iis_pwmgr[] = _T("iis_pwmgr");
const TCHAR STRING_iis_www[]   = _T("iis_www");
const TCHAR STRING_iis_inetmgr[] = _T("iis_inetmgr");
const TCHAR STRING_iis_core[]    = _T("iis_core");
const TCHAR STRING_iis_common[]  = _T("iis_common");
const TCHAR STRING_iis_www_vdir_scripts[]   = _T("iis_www_vdir_scripts");
const TCHAR STRING_iis_www_vdir_printers[]   = _T("iis_www_vdir_printers");

int g_iOC_WIZARD_CREATED_Called = FALSE;
int g_iOC_FILE_BUSY_Called = FALSE;
int g_iOC_PREINITIALIZE_Called = FALSE;
int g_iOC_INIT_COMPONENT_Called = FALSE;
int g_iOC_SET_LANGUAGE_Called = FALSE;
int g_iOC_QUERY_IMAGE_Called = FALSE;
int g_iOC_REQUEST_PAGES_Called = FALSE;
int g_iOC_QUERY_STATE_Called = FALSE;
int g_iOC_QUERY_CHANGE_SEL_STATE_Called = FALSE;
int g_iOC_QUERY_SKIP_PAGE_Called = FALSE;
int g_iOC_CALC_DISK_SPACE_Called = FALSE;
int g_iOC_QUEUE_FILE_OPS_Called = FALSE;
int g_iOC_NEED_MEDIA_Called = FALSE;
int g_iOC_NOTIFICATION_FROM_QUEUE_Called = FALSE;
int g_iOC_QUERY_STEP_COUNT_Called = FALSE;
int g_iOC_ABOUT_TO_COMMIT_QUEUE_Called = FALSE;
int g_iOC_COMPLETE_INSTALLATION_Called = FALSE;
int g_iOC_CLEANUP_Called = FALSE;
int g_iOC_DEFAULT_Called = FALSE;

int g_Please_Call_Register_iis_inetmgr = FALSE;

HSPFILEQ g_GlobalFileQueueHandle = NULL;
int g_GlobalFileQueueHandle_ReturnError = 0;

CInitApp *g_pTheApp;
CComponentList *g_pComponents = NULL;

BOOL g_bGlobalWriteUnSecuredIfFailed_All  = FALSE;

// 0 = log errors only
// 1 = log warnings
// 2 = trace
// 3 = trace win32 stuff
int g_GlobalDebugLevelFlag = 3;
int g_GlobalDebugLevelFlag_WasSetByUnattendFile = FALSE;
int g_GlobalDebugCallValidateHeap = 1;
int g_GlobalDebugCrypto = 0;
int g_GlobalFastLoad = 0;

TCHAR g_szLastSectionToGetCalled[50];

// Logging class
MyLogFile g_MyLogFile;

int CheckInfInstead(int iPrevious)
{
    INFCONTEXT Context;
    int iTempFlag = 0;
    TCHAR szPersonalFlag[20] = _T("");

    iTempFlag = iPrevious;
    if (SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, _T("SetupInfo"), _T("Personal"), &Context) )
    {
        SetupGetStringField(&Context, 1, szPersonalFlag, sizeof(szPersonalFlag)/sizeof(szPersonalFlag[0]), NULL);
        if (IsValidNumber((LPCTSTR)szPersonalFlag)) 
        {
            iTempFlag = _ttoi(szPersonalFlag);
            iTempFlag++;
        }
    }
 
    return (iTempFlag);
}


BOOL IsWhistlerPersonal(void)
{
    static int PersonalSKU = 0;

    if (0 == PersonalSKU)
    {
        OSVERSIONINFOEX osvi;

        //
        // Determine if we are installing Personal SKU
        //
        ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        GetVersionEx((OSVERSIONINFO *) &osvi);

        if (osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL))
        {
            PersonalSKU = 2;
        }
        else
        {
            PersonalSKU = 1;
        }

        PersonalSKU = CheckInfInstead(PersonalSKU);
    }

    return (PersonalSKU - 1);
}


void WINAPI ProcessInfSection(CHAR *pszSectionName)
{
    BOOL bPleaseCloseInfHandle = FALSE;
    TSTR  strFullPath;
    TCHAR wszWideString[MAX_PATH];
    int MySavedDebugLevel = 0;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("ProcessInfSection:"));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("ProcessInfSection: Start.\n")));

    if (!pszSectionName)
        {goto ProcessInfSection_Exit;}

    if (!g_pTheApp->m_hInfHandle || g_pTheApp->m_hInfHandle == INVALID_HANDLE_VALUE)
    {
        g_pTheApp->m_hInfHandle = INVALID_HANDLE_VALUE;

        if ( !strFullPath.Resize( MAX_PATH ) )
        {
            goto ProcessInfSection_Exit;
        }

        // get the c:\winnt dir
        if (0 == GetWindowsDirectory(strFullPath.QueryStr(), MAX_PATH))
            {goto ProcessInfSection_Exit;}

        // Tack on the inf\iis.inf subdir and filename
        if ( !strFullPath.Append( _T("\\inf\\iis.inf") ) )
        {
            goto ProcessInfSection_Exit;          
        }
  
	    // Check if the file exists
        if (TRUE != IsFileExist( strFullPath.QueryStr() ))
            {
            iisDebugOut((LOG_TYPE_WARN, _T("ProcessInfSection: %s does not exist!\n"),strFullPath.QueryStr()));
            goto ProcessInfSection_Exit;
            }

        // Get a handle to it.
        g_pTheApp->m_hInfHandle = SetupOpenInfFile(strFullPath.QueryStr(), NULL, INF_STYLE_WIN4, NULL);
        if (!g_pTheApp->m_hInfHandle || g_pTheApp->m_hInfHandle == INVALID_HANDLE_VALUE)
            {
            iisDebugOut((LOG_TYPE_WARN, _T("ProcessInfSection: SetupOpenInfFile failed on file: %s.\n"),strFullPath.QueryStr()));
            goto ProcessInfSection_Exit;
            }
        bPleaseCloseInfHandle = TRUE;
    }

    // get the debug level from the iis.inf
    GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);

    MySavedDebugLevel = g_GlobalDebugLevelFlag;
    // reset global debug level only most of the time
    if (LOG_TYPE_TRACE_WIN32_API < g_GlobalDebugLevelFlag)
        {g_GlobalDebugLevelFlag = LOG_TYPE_ERROR;}

    // Read .inf file and set some globals from the information in there.
    ReadGlobalsFromInf(g_pTheApp->m_hInfHandle);
    g_pTheApp->InitApplication();
    SetDIRIDforThisInf(g_pTheApp->m_hInfHandle,TRUE);

    //g_pTheApp->DumpAppVars();
    g_GlobalDebugLevelFlag = MySavedDebugLevel;

    // See if user configured anything
    ReadUserConfigurable(g_pTheApp->m_hInfHandle);
    
    // Convert the input to a wide char if ProcessSection() takes wide type.
#if defined(UNICODE) || defined(_UNICODE)
    MultiByteToWideChar( CP_ACP, 0, pszSectionName, -1, wszWideString, MAX_PATH);
#else
    _tcscpy(wszWideString, pszSectionName);
#endif
    ProcessSection(g_pTheApp->m_hInfHandle, wszWideString);

ProcessInfSection_Exit:
    if (TRUE == bPleaseCloseInfHandle)
        {if(g_pTheApp->m_hInfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(g_pTheApp->m_hInfHandle);g_pTheApp->m_hInfHandle = INVALID_HANDLE_VALUE;}}

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("ProcessInfSection: End.\n")));
    return;
}

void WINAPI IIS5Log(int iLogType, TCHAR *pszfmt)
{
    iisDebugOut((iLogType, pszfmt));
}

void WINAPI IIS5LogParmString(int iLogType, TCHAR *pszfmt, TCHAR *pszString)
{
    if ( _tcsstr(pszfmt, _T("%s")) || _tcsstr(pszfmt, _T("%S")))
    {
        iisDebugOut((iLogType, pszfmt, pszString));
    }
    else
    {
        iisDebugOut((iLogType, pszfmt));
        iisDebugOut((iLogType, pszString));
    }
}

void WINAPI IIS5LogParmDword(int iLogType, TCHAR *pszfmt, DWORD dwErrorCode)
{
    if ( _tcsstr(pszfmt, _T("%x")) || _tcsstr(pszfmt, _T("%X")) || _tcsstr(pszfmt, _T("%d")) || _tcsstr(pszfmt, _T("%D")))
    {
        iisDebugOut((iLogType, pszfmt, dwErrorCode));
    }
    else
    {
        iisDebugOut((iLogType, pszfmt));
        iisDebugOut((iLogType, _T("%d"), dwErrorCode));
    }
}

void TestAfterInitApp(void)
{
    //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("...... Start\n")));
    //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("...... End\n")));
    return;
}

extern "C" void InitializeIISRTL2();
extern "C" void TerminateIISRTL2();

//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
    BOOL bReturn = TRUE;
    UNREFERENCED_PARAMETER(Reserved);
    bReturn = TRUE;
    CString csTempPath;

    switch(Reason)
    {
        case DLL_PROCESS_ATTACH:
            InitializeIISRTL2();

            // Because Heap problems with IISRTL, we must make sure that anything that
            // uses stuff from iisrtl, must NOT live beyond the scope of 
            // InitializeIISRTL2 and TerminateIISRTL2!!!
            g_pTheApp = new (CInitApp);

            if ( !g_pTheApp )
            {
                bReturn = FALSE;
            }

            if (!g_MyModuleHandle)
            {
                srand(GetTickCount());
                g_MyModuleHandle = DllHandle;

                // open the log file.
#ifdef IIS60
                g_MyLogFile.LogFileCreate(_T("iis6.log"));
#else
                g_MyLogFile.LogFileCreate(_T("iis5.log"));
#endif
                gHelperRoutines.OcManagerContext = NULL;
            }

            break;

        case DLL_THREAD_ATTACH:
            bReturn = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Final Check:"));
            // only do the final check if we are actually run from sysocmgr.exe!
            // and the first thing that sysocmgr.exe does is call preinitialize, so let's check for that!
            if (g_iOC_PREINITIALIZE_Called)
            {
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("=======================\n")));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_PREINITIALIZE Called=%d\n"), g_iOC_PREINITIALIZE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_INIT_COMPONENT Called=%d\n"), g_iOC_INIT_COMPONENT_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_SET_LANGUAGE Called=%d\n"), g_iOC_SET_LANGUAGE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_IMAGE Called=%d\n"), g_iOC_QUERY_IMAGE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_REQUEST_PAGES Called=%d\n"), g_iOC_REQUEST_PAGES_Called));
			    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_WIZARD_CREATED Called=%d\n"), g_iOC_WIZARD_CREATED_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_STATE Called=%d\n"), g_iOC_QUERY_STATE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_CHANGE_SEL_STATE Called=%d\n"), g_iOC_QUERY_CHANGE_SEL_STATE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_SKIP_PAGE Called=%d\n"), g_iOC_QUERY_SKIP_PAGE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_CALC_DISK_SPACE Called=%d\n"), g_iOC_CALC_DISK_SPACE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUEUE_FILE_OPS Called=%d\n"), g_iOC_QUEUE_FILE_OPS_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_NEED_MEDIA Called=%d\n"), g_iOC_NEED_MEDIA_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_NOTIFICATION_FROM_QUEUE Called=%d\n"), g_iOC_NOTIFICATION_FROM_QUEUE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_STEP_COUNT Called=%d\n"), g_iOC_QUERY_STEP_COUNT_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_ABOUT_TO_COMMIT_QUEUE Called=%d\n"), g_iOC_ABOUT_TO_COMMIT_QUEUE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_FILE_BUSY Called=%d\n"), g_iOC_FILE_BUSY_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_COMPLETE_INSTALLATION Called=%d\n"), g_iOC_COMPLETE_INSTALLATION_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_CLEANUP Called=%d\n"), g_iOC_CLEANUP_Called));
                iisDebugOut((LOG_TYPE_TRACE, _T("OC_DEFAULT Called=%d\n"), g_iOC_DEFAULT_Called));
                _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Final Check:"));

			    // Check if g_iOC_COMPLETE_INSTALLATION_Called was called!!!!!
			    if (!g_iOC_COMPLETE_INSTALLATION_Called)
			    {
                    if (g_pTheApp->m_fNTGuiMode)
                    {
				        iisDebugOut((LOG_TYPE_ERROR, _T("WARNING.FAILURE: OC_COMPLETE_INSTALLATION was not called (by ocmanage.dll) for this component.  IIS was not installed or configured!!  This will be a problem for other ocm installed components as well.\n")));
                    }
			    }
            }
            // log the heap state
            LogHeapState(TRUE, __FILE__, __LINE__);

            // free some memory
            FreeTaskListMem();
            UnInit_Lib_PSAPI();

            // Close the log file
            g_MyLogFile.LogFileClose();

            ASSERT(g_pTheApp);
            delete (g_pTheApp);
            g_pTheApp = NULL;

            if ( g_pComponents )
            {
              delete g_pComponents;
              g_pComponents = NULL;
            }

            TerminateIISRTL2();

            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return(bReturn);
}


BOOL g_fFranceHackAttempted = FALSE;
LCID g_TrueThreadLocale;

DWORD WINAPI FranceFixThread(LPVOID lpParameter)
{
    g_TrueThreadLocale = GetThreadLocale ();
    return 0;
}

BOOL InitializeComponents()
{
  // Make sure we don't call this twice
  ASSERT( g_pComponents == NULL );
  
  g_pComponents = new CComponentList;

  if ( !g_pComponents )
  {
    // Failed to allocate
    return FALSE;
  }

  if ( !g_pComponents->Initialize() )
  {
    delete g_pComponents;
    g_pComponents = NULL;
    return FALSE;
  }

  return TRUE;
}

// -----------------------------------------------
// OcEntry is the main entry point (After DllMain)
// -----------------------------------------------
DWORD_PTR OcEntry(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    _tcscpy(g_szCurrentSubComponent, _T(""));
    if (SubcomponentId) {_tcscpy(g_szCurrentSubComponent, SubcomponentId);}

    if ( g_pComponents == NULL )
    {
      if ( !InitializeComponents() )
      {
        // If we can not initialize, we can not do anything
        return dwOcEntryReturn;
      }
    }

    if (!g_fFranceHackAttempted)
    {
        g_fFranceHackAttempted = TRUE;
        LCID            InitialThreadLocale;
        DWORD           thid;

       InitialThreadLocale = GetThreadLocale ();
       iisDebugOut((LOG_TYPE_TRACE, _T("Initial thread locale=%0x\n"),InitialThreadLocale));

        HANDLE hHackThread = CreateThread (NULL,0,FranceFixThread,NULL,0,&thid);
        if (hHackThread)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("Starting to wait On France fix thread\n")));

            // wait for 10 secs only
            DWORD res = WaitForSingleObject (hHackThread,10*1000);
            if (res==WAIT_TIMEOUT)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("ERROR France fix thread never finished...\n")));
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("returned from France fix with locale %0x \n"),g_TrueThreadLocale));
                CloseHandle (hHackThread);

                // do that only if locales are different and another one is France
                if (g_TrueThreadLocale !=InitialThreadLocale && g_TrueThreadLocale==0x40c)
                {
                BOOL ret = SetThreadLocale (g_TrueThreadLocale);
                iisDebugOut((LOG_TYPE_TRACE, _T("SetThreadLocale returned %d\n"),ret));

                g_TrueThreadLocale = GetThreadLocale ();
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("France fix succeed=%0x\n"),g_TrueThreadLocale));
                }

            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Failed to start France fix thread. error =%0x\n"),GetLastError()));
        }
    }


    
    switch(Function)
    {
    case OC_WIZARD_CREATED:
        g_iOC_WIZARD_CREATED_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_WIZARD_CREATED:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End. Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
        break;

    case OC_FILE_BUSY:
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_FILE_BUSY:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        // if the first time this function was
        // called then show all running services
        LogHeapState(FALSE, __FILE__, __LINE__);
        if (g_iOC_FILE_BUSY_Called != TRUE)
        {
            // display locked dlls by setup
            // This seems to thru exceptions on build nt5 build 1980.
            // comment this out since it's not crucial.
            //LogThisProcessesDLLs();
            // display running services
            LogEnumServicesStatus();
        }
        g_iOC_FILE_BUSY_Called = TRUE;
        dwOcEntryReturn = OC_FILE_BUSY_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        break;

    case OC_PREINITIALIZE:
        g_iOC_PREINITIALIZE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_PREINITIALIZE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_PREINITIALIZE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_INIT_COMPONENT:
        g_iOC_INIT_COMPONENT_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_INIT_COMPONENT:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_INIT_COMPONENT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_SET_LANGUAGE:
        g_iOC_SET_LANGUAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_SET_LANGUAGE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_SET_LANGUAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

#ifdef _WIN64
    case OC_QUERY_IMAGE_EX:
        g_iOC_QUERY_IMAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_IMAGE_EX:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_IMAGE_EX_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;
#endif

    case OC_QUERY_IMAGE:
        g_iOC_QUERY_IMAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_IMAGE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_IMAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_REQUEST_PAGES:
      ASSERT(FALSE);
        g_iOC_REQUEST_PAGES_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_REQUEST_PAGES:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        break;

    case OC_QUERY_STATE:
        g_iOC_QUERY_STATE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_STATE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        g_iOC_QUERY_CHANGE_SEL_STATE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_CHANGE_SEL_STATE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_CHANGE_SEL_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_SKIP_PAGE:
        g_iOC_QUERY_SKIP_PAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_SKIP_PAGE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_SKIP_PAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_CALC_DISK_SPACE:
        g_iOC_CALC_DISK_SPACE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_CALC_DISK_SPACE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_CALC_DISK_SPACE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        ProgressBarTextStack_Set(IDS_IIS_ALL_FILEOPS);
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUEUE_FILE_OPS:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        if (g_iOC_QUEUE_FILE_OPS_Called != TRUE)
        {
            // turn logging back on if we need to
            // get the debug level from the iis.inf
            if (g_GlobalFastLoad)
            {
                GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);
                // output stuff that we missed during init
                g_pTheApp->DumpAppVars();
            }
        }
        g_iOC_QUEUE_FILE_OPS_Called = TRUE;
        dwOcEntryReturn = OC_QUEUE_FILE_OPS_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        ProgressBarTextStack_Pop();
        break;

    case OC_NEED_MEDIA:
        g_iOC_NEED_MEDIA_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_NEED_MEDIA:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_NEED_MEDIA_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        g_iOC_NOTIFICATION_FROM_QUEUE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_NOTIFICATION_FROM_QUEUE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_NOTIFICATION_FROM_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STEP_COUNT:
        g_iOC_QUERY_STEP_COUNT_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_STEP_COUNT:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_STEP_COUNT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_ABOUT_TO_COMMIT_QUEUE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        LogHeapState(FALSE, __FILE__, __LINE__);
        if (g_iOC_ABOUT_TO_COMMIT_QUEUE_Called != TRUE)
        {
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
            {
                // display running processes
                LogCurrentProcessIDs();
                // display running services
                LogEnumServicesStatus();
                // log file versions
                LogImportantFiles();
                // display locked dlls by setup
                //LogThisProcessesDLLs();
                // check if temp dir is writeable
                LogCheckIfTempDirWriteable();
            }
        }
        g_iOC_ABOUT_TO_COMMIT_QUEUE_Called = TRUE;
        dwOcEntryReturn = OC_ABOUT_TO_COMMIT_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        break;

    case OC_COMPLETE_INSTALLATION:
        g_iOC_COMPLETE_INSTALLATION_Called = TRUE;
        //ProgressBarTextStack_Set(IDS_IIS_ALL_COMPLETE);
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_COMPLETE_INSTALLATION:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        LogHeapState(FALSE, __FILE__, __LINE__);
        // no need to do this, just slows things down
        //g_MyLogFile.m_bFlushLogToDisk = TRUE;
        if (g_iOC_COMPLETE_INSTALLATION_Called != TRUE)
        {
            // Get the debug level, incase we changed it during setup...
            GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);
        }

        dwOcEntryReturn = OC_COMPLETE_INSTALLATION_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        g_MyLogFile.m_bFlushLogToDisk = FALSE;
        //ProgressBarTextStack_Pop();
        break;

    case OC_CLEANUP:
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_CLEANUP:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        LogHeapState(FALSE, __FILE__, __LINE__);
        if (g_iOC_CLEANUP_Called != TRUE)
        {
            // turn logging back on if we need to
            // get the debug level from the iis.inf
            if (g_GlobalFastLoad)
            {
                GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);
            }
        }
        g_iOC_CLEANUP_Called = TRUE;
        dwOcEntryReturn = OC_CLEANUP_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        break;

    default:
        g_iOC_DEFAULT_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_(DEFAULT):"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = 0;
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Type=0x%x.  Return=%d\n"), ComponentId, SubcomponentId, Function, dwOcEntryReturn));
        break;
    }

    return(dwOcEntryReturn);
}


// -----------------------------------------------------
// Retrive the original state of the subcomponent
// -----------------------------------------------------
STATUS_TYPE GetSubcompInitStatus(LPCTSTR SubcomponentId)
{
    STATUS_TYPE nStatus = ST_UNINSTALLED;
    BOOL OriginalState;

#ifdef _CHICAGO_
    if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0)
        {return nStatus;}
#endif //_CHICAGO_

    // Get the original state from the Helper Routines (which get it from the registry)
    OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
    if (OriginalState == 1) {nStatus = ST_INSTALLED;}
    if (OriginalState == 0) {nStatus = ST_UNINSTALLED;}

    return nStatus;
}


void DebugOutAction(LPCTSTR SubcomponentId, ACTION_TYPE nAction)
{
    switch (nAction)
    {
    case AT_DO_NOTHING:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_DO_NOTHING.\n"), SubcomponentId));
        break;
    case AT_REMOVE:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_REMOVE.\n"), SubcomponentId));
        break;
    case AT_INSTALL_FRESH:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_INSTALL_FRESH.\n"), SubcomponentId));
        break;
    case AT_INSTALL_UPGRADE:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_INSTALL_UPGRADE.\n"), SubcomponentId));
        break;
    case AT_INSTALL_REINSTALL:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_INSTALL_REINSTALL.\n"), SubcomponentId));
        break;
    default:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= UN_DEFINED.\n"), SubcomponentId));
        break;
    }

    return;
}

// ---------------------------------------------------------
// OriginalState = 1 (means that it was previously installed and exists on the computer)
// OriginalState = 0 (means that it does not exist on the computer)
//
// CurrentState  = 1 (means please install the subcomponent)
// CurrentState  = 0 (means please remove  the subcomponent)
// ---------------------------------------------------------
ACTION_TYPE GetSubcompAction(LPCTSTR SubcomponentId, int iLogResult)
{
    ACTION_TYPE nReturn = AT_DO_NOTHING;
    BOOL CurrentState,OriginalState;

    OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
    CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

    // if already installed and we want to remove it, then remove it
    if (OriginalState == 1 && CurrentState == 0) {nReturn = AT_REMOVE;}

    // if not installed and we want to install it, then install it.
    if (OriginalState == 0 && CurrentState == 1) {nReturn = AT_INSTALL_FRESH;}

    // if already installed and we want to install it, then Gee i dunno.
    // it could be a bunch of things
    if (OriginalState == 1 && CurrentState == 1)
    {
        if (g_pTheApp->m_eInstallMode == IM_UPGRADE) {nReturn = AT_INSTALL_UPGRADE;}
        if (g_pTheApp->m_dwSetupMode == SETUPMODE_REINSTALL) {nReturn = AT_INSTALL_REINSTALL;}
        if (g_pTheApp->m_dwSetupMode == SETUPMODE_ADDREMOVE) {nReturn = AT_DO_NOTHING;}
    }

    if (iLogResult)
    {
		TCHAR szTempString[50];
		_tcscpy(szTempString, _T("UN_DEFINED"));
		switch (nReturn)
		{
		case AT_DO_NOTHING:
			_tcscpy(szTempString, _T("AT_DO_NOTHING"));
			break;
		case AT_REMOVE:
			_tcscpy(szTempString, _T("AT_REMOVE"));
			break;
		case AT_INSTALL_FRESH:
			_tcscpy(szTempString, _T("AT_INSTALL_FRESH"));
			break;
		case AT_INSTALL_UPGRADE:
			_tcscpy(szTempString, _T("AT_INSTALL_UPGRADE"));
			break;
		case AT_INSTALL_REINSTALL:
			_tcscpy(szTempString, _T("AT_INSTALL_REINSTALL"));
			break;
		default:
			_tcscpy(szTempString, _T("UN_DEFINED"));
			break;
		}

        if (_tcsicmp(SubcomponentId, _T("iis")) == 0)
        {
            // use two tabs
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t\t= %s. Original=%d, Current=%d.\n"), SubcomponentId, szTempString, OriginalState, CurrentState));
        }
        else
        {
		    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= %s. Original=%d, Current=%d.\n"), SubcomponentId, szTempString, OriginalState, CurrentState));
        }
    }

    return nReturn;
}



BOOL GetDataFromMetabase(LPCTSTR szPath, int nID, LPBYTE Buffer, int BufSize)
{
    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;

    CMDKey cmdKey;
    cmdKey.OpenNode(szPath, TRUE);
    if ( (METADATA_HANDLE)cmdKey )
    {
        bFound = cmdKey.GetData(nID, &attr, &uType, &dType, &cbLen, (PBYTE)Buffer, BufSize);
        cmdKey.Close();
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetDataFromMetabase():%s:ID=%d.Could not open node.\n"),szPath,nID));
    }
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetDataFromMetabase():%s:ID=%d.ret=%d.\n"),szPath,nID,bFound));
    return (bFound);
}

void SetIISSetupMode(DWORD dwSetupMode)
{
    if (g_pTheApp->m_fInvokedByNT)
    {
        g_pTheApp->DefineSetupModeOnNT();
    }
    else
    {
        g_pTheApp->m_dwSetupMode = dwSetupMode;
    }

    if (g_pTheApp->m_dwSetupMode & SETUPMODE_UPGRADE){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_UPGRADE\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_UPGRADEONLY){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_UPGRADEONLY\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_ADDEXTRACOMPS){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_ADDEXTRACOMPS\n")));}

    if (g_pTheApp->m_dwSetupMode & SETUPMODE_MAINTENANCE){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_ADDREMOVE){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_ADDREMOVE\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_REINSTALL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REINSTALL\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_REMOVEALL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REMOVEALL\n")));}

    if (g_pTheApp->m_dwSetupMode & SETUPMODE_FRESH){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_MINIMAL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_MINIMAL\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_TYPICAL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_TYPICAL\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_CUSTOM){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_CUSTOM\n")));}

    gHelperRoutines.SetSetupMode(gHelperRoutines.OcManagerContext, g_pTheApp->m_dwSetupMode);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("IISSetupMode"),(PVOID)&(g_pTheApp->m_dwSetupMode),sizeof(DWORD),REG_DWORD);
    return;
}


BOOL ToBeInstalled(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    BOOL fReturn = FALSE;

    if ( SubcomponentId )
    {
        BOOL CurrentState,OriginalState;
        OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
        CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);
        if (OriginalState == 0 && CurrentState == 1)
            {fReturn = TRUE;}
    }

    return fReturn;
}

void CustomFTPRoot(LPCTSTR szFTPRoot)
{
    g_pTheApp->m_csPathFTPRoot = szFTPRoot;
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32769, g_pTheApp->m_csPathFTPRoot);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathFTPRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathFTPRoot,(g_pTheApp->m_csPathFTPRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    return;
}

void CustomWWWRoot(LPCTSTR szWWWRoot)
{
    TCHAR szParentDir[_MAX_PATH], szDir[_MAX_PATH];

    g_pTheApp->m_csPathWWWRoot = szWWWRoot;
    InetGetFilePath(szWWWRoot, szParentDir);

    g_pTheApp->m_csPathInetpub = szParentDir;
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32773, szParentDir);

    AppendDir(szParentDir, _T("iissamples"), szDir);
    g_pTheApp->m_csPathIISSamples = szDir;

    AppendDir(szParentDir, _T("webpub"), szDir);
    g_pTheApp->m_csPathWebPub = szDir;

    AppendDir(szParentDir, _T("scripts"), szDir);
    g_pTheApp->m_csPathScripts = szDir;

    AppendDir(szParentDir, _T("ASPSamp"), szDir);
    g_pTheApp->m_csPathASPSamp = szDir;

    g_pTheApp->m_csPathAdvWorks = g_pTheApp->m_csPathASPSamp + _T("\\AdvWorks");

    CString csPathScripts = g_pTheApp->m_csPathIISSamples + _T("\\Scripts");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathScripts"),(PVOID)(LPCTSTR)csPathScripts,(csPathScripts.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathWWWRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathWWWRoot,(g_pTheApp->m_csPathWWWRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISSamples"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathIISSamples,(g_pTheApp->m_csPathIISSamples.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    // Set inf file dir id's
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32770, g_pTheApp->m_csPathWWWRoot);
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32771, g_pTheApp->m_csPathIISSamples);
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32772, g_pTheApp->m_csPathScripts);
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32779, g_pTheApp->m_csPathWebPub);
    return;
}


void StartInstalledServices(void)
{
    ACTION_TYPE atWWW = GetSubcompAction(STRING_iis_www, FALSE);
    ACTION_TYPE atFTP = GetSubcompAction(g_ComponentList[COMPONENT_IIS_FTP].szComponentName, FALSE);
    STATUS_TYPE stFTP = GetSubcompInitStatus(g_ComponentList[COMPONENT_IIS_FTP].szComponentName );
    STATUS_TYPE stWWW = GetSubcompInitStatus(STRING_iis_www);

    iisDebugOut_Start(_T("StartInstalledServices()"), LOG_TYPE_TRACE);

    if (atWWW == AT_INSTALL_FRESH || atWWW == AT_INSTALL_UPGRADE || atWWW == AT_INSTALL_REINSTALL || (stWWW == ST_INSTALLED && atWWW != AT_REMOVE))
    {
        InetStartService(_T("W3SVC"));
    }

#ifndef _CHICAGO_
    if (atFTP == AT_INSTALL_FRESH || atFTP == AT_INSTALL_UPGRADE || atFTP == AT_INSTALL_REINSTALL || (stFTP == ST_INSTALLED && atFTP != AT_REMOVE))
    {
        InetStartService(_T("MSFTPSVC"));
    }
#endif // _CHICAGO_

    if (g_pTheApp->m_eOS == OS_W95 || g_pTheApp->m_eNTOSType == OT_NTW)
    {
        ACTION_TYPE atPWMGR = GetSubcompAction(STRING_iis_pwmgr, FALSE);
        if (atPWMGR == AT_INSTALL_FRESH ||
            atPWMGR == AT_INSTALL_UPGRADE ||
            atPWMGR == AT_INSTALL_REINSTALL)
        {
            CString csProgram;
            csProgram = g_pTheApp->m_csSysDir + _T("\\pwstray.exe");
            if (IsFileExist(csProgram))
            {
                STARTUPINFO si;
                PROCESS_INFORMATION pi;
                ZeroMemory(&si, sizeof(STARTUPINFO));
                si.cb = sizeof( STARTUPINFO );
                CreateProcess( csProgram, NULL, NULL, NULL,FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi );
            }
        }
    }
    return;
}


void GetShortDesc(LPCTSTR SubcomponentId, LPTSTR szShortDesc)
{
    INFCONTEXT Context;
    TCHAR szSection[_MAX_PATH] = _T("Strings");
    TCHAR szKey[_MAX_PATH] = _T("SDESC_");
    TCHAR szString[_MAX_PATH] = _T("");
    int nLen=0;

    _tcscat(szKey, SubcomponentId);
    *szShortDesc = _T('\0');

    if (SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, szSection, szKey, &Context))
    {
        SetupGetStringField(&Context, 1, szString, _MAX_PATH, NULL);
        nLen = _tcslen(szString);
        if (*szString == _T('"') && *_tcsninc(szString, nLen-1) == _T('"'))
            {_tcsncpy(szShortDesc, _tcsinc(szString), nLen-2);}
        else
            {_tcscpy(szShortDesc, szString);}
    }

    return;
}

void ParseCmdLine(void)
{
  TSTR strCmdLine;

  if ( !strCmdLine.Copy( GetCommandLine() ) )
  {
    // Failed to load string
    return;
  }

  if ( strCmdLine.SubStringExists( _T("sysoc.inf"), FALSE ) )
  {
    g_pTheApp->m_fInvokedByNT = TRUE;
  }
}

// DuplicateSetupStructure
//
// Copy the setup structure, so that we can give it to the COM and DTC guys.
//
BOOL
DuplicateSetupStructure(PSETUP_INIT_COMPONENT pTarget, PSETUP_INIT_COMPONENT pSource)
{
  memcpy( pTarget, pSource, sizeof( SETUP_INIT_COMPONENT ) );

  return TRUE;
}

// -----------------------------
// handles the OC_INIT_COMPONENT call from ocmanager
//
// The OC Manager passes us some information that we want to save,
// such as an open handle to our per-component INF. As long as we have
// a per-component INF, append-open any layout file that is
// associated with it, in preparation for later inf-based file
// queuing operations.
//
// We save away certain other stuff that gets passed to us now,
// since OC Manager doesn't guarantee that the SETUP_INIT_COMPONENT
// will persist beyond processing of this one interface routine.
//
//
// Param1 = unused
// Param2 = points to SETUP_INIT_COMPONENT structure
// Return code = is Win32 error indicating outcome.
//
// -----------------------------
DWORD_PTR OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
	iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start.\n"), ComponentId, SubcomponentId));
    DWORD_PTR dwOcEntryReturn = 0;

    // Set the global OCMInfo pointer
    if ( !DuplicateSetupStructure( &g_OCMInfo, (PSETUP_INIT_COMPONENT)Param2 ) )
    {
      // Failed to duplicate
      return ERROR_CANCELLED;
    }

    // set flag if running as admin
    BOOL g_fAdministrator = RunningAsAdministrator();

    // Parse The Command line and set global Variables.
    ParseCmdLine();
   
    // first of all display iis.dll to avoid any confusion!
    DisplayVerOnCurrentModule();

    g_pTheApp->m_hInfHandle = g_OCMInfo.ComponentInfHandle;
    if (g_OCMInfo.ComponentInfHandle == INVALID_HANDLE_VALUE)
    {
        MessageBox(NULL, _T("Invalid inf handle."), _T("IIS Setup"), MB_OK | MB_SETFOREGROUND);
        iisDebugOut((LOG_TYPE_ERROR, _T("g_OCMInfo.ComponentInfHandle FAILED")));
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }
    g_pTheApp->m_fNTOperationFlags = g_OCMInfo.SetupData.OperationFlags;
    g_pTheApp->m_fNtWorkstation = g_OCMInfo.SetupData.ProductType == PRODUCT_WORKSTATION;
    if (g_OCMInfo.SetupData.OperationFlags & SETUPOP_STANDALONE)
    {
       g_pTheApp->m_fNTGuiMode = FALSE;
    }
    else
    {
       g_pTheApp->m_fNTGuiMode = TRUE;
    }
    g_pTheApp->m_csPathSource = g_OCMInfo.SetupData.SourcePath;
    gHelperRoutines = g_OCMInfo.HelperRoutines;
    g_pTheApp->m_fInvokedByNT = g_pTheApp->m_fNTGuiMode;

    // get the handle to the unattended file (the answer file)
    // if this is a migration from win95, then there will be
    // a section in here called [InternetServer] which will
    // point to the win95 migration.dat file.
    g_pTheApp->m_hUnattendFile = gHelperRoutines.GetInfHandle(INFINDEX_UNATTENDED, gHelperRoutines.OcManagerContext);
    if (_tcsicmp(g_OCMInfo.SetupData.UnattendFile,_T("")) != 0 && g_OCMInfo.SetupData.UnattendFile != NULL)
    {
        g_pTheApp->m_csUnattendFile = g_OCMInfo.SetupData.UnattendFile;
    }
    g_pTheApp->m_fUnattended = (((DWORD)g_OCMInfo.SetupData.OperationFlags) & SETUPOP_BATCH);
    if (g_pTheApp->m_fUnattended)
        {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Set UnAttendFlag:ON (File='%s')\n"), g_pTheApp->m_csUnattendFile));
        if (g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE || g_pTheApp->m_hUnattendFile == NULL)
            {iisDebugOut((LOG_TYPE_WARN, _T("WARNING: There should have been an unattended file but there is none.\n")));}
        }
    else
        {iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Set UnAttendFlag:OFF (File='%s')\n"), g_pTheApp->m_csUnattendFile));}
    
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("CmdLine=%s"), GetCommandLine()));

    // make sure that this is always set -- so that
    // you never get the iis welcome, min\typ\custom, dir selection, End pages.
    g_pTheApp->m_fInvokedByNT = TRUE;
    if (g_pTheApp->m_fInvokedByNT) {g_pTheApp->m_bAllowMessageBoxPopups = FALSE;}
    //if (g_SpecialFlagForDebug) {g_pTheApp->m_bAllowMessageBoxPopups = TRUE;}

    // get the debug level from the iis.inf
    GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);

    if (!g_pTheApp->m_fNTGuiMode)
    {
        if (g_GlobalFastLoad)
        {
            // change it so that there is no logging during the load process.
            // so that the iis.dll loads up faster.
            // g_pTheApp->m_fNTGuiMode
            g_GlobalDebugLevelFlag = LOG_TYPE_WARN;
        }
    }

    // Read .inf file
    // and set some globals from the informatin in there.
    ReadGlobalsFromInf(g_pTheApp->m_hInfHandle);
    if (g_GlobalGuiOverRide)
    {
        g_pTheApp->m_fNTGuiMode = TRUE;
        SetIISSetupMode(SETUPMODE_UPGRADEONLY);
    }
    
    // ----------------------------------
    //     handle win95 migration
    //
    // win95 migration is handled this way.
    // 1. on the win95 side a file is generated.  it is a actually a
    //    setupapi type .inf fie.
    // 2. win95 migration dll creates the file and sticks the path to where
    //    it is in the answerfile.txt file.  should look like this
    //    [InternetServer]
    //    Win95MigrateDll=d:\winnt\system32\setup\????\something.dat
    //
    // 3. so we should, open the answer file,
    //    find the [InternetServer] section
    //    have setupapi install it 
    //    
    // 4. that will put appropriate registry values into the registry.
    //
    // ----------------------------------
    HandleWin95MigrateDll();

    if (!g_fAdministrator) 
    {
        g_pTheApp->MsgBox(NULL, IDS_NOT_ADMINISTRATOR, MB_OK, TRUE);
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }
    
    // Call this stuff after setting m_fNTGuiMode and m_fNtWorkstation and m_fInvokedByNT
    // since it maybe used in InitApplication().
    if ( FALSE == g_pTheApp->InitApplication() ) 
    {
        g_pTheApp->DumpAppVars();
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED")));
        // setup should be terminated.
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }
    if ( g_pTheApp->m_eInstallMode == IM_MAINTENANCE )
        {g_pTheApp->m_fEULA = TRUE;}

    // If NT4 upgrade, enable iisadmin so we can read some data
    // from it
    if ( g_pTheApp->IsUpgrade() &&
         ( g_pTheApp->GetUpgradeVersion() <= 4 ) )
    {
      // Remove iisadmin dependency on ntlmssp, so we can use the old metabase now
      if ( !ChangeServiceDependency(SERVICENAME_IISADMIN, 
                                    FALSE, 
                                    SERVICENAME_NTLMSSP) )
      {
        // We have seen this error io pending during upgrade if the service
        // does not exist, so ignore it
        if ( ( GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST ) &&
             ( GetLastError() != ERROR_IO_PENDING ) )
        {
          iisDebugOut((LOG_TYPE_WARN, _T("Could not remove IISAdmin dependency on NTLMSSP, GLE=0x%8x\n"), GetLastError() ));
        }
      }
    }

    // check if the .inf we are looking at is the right inf for what the machine is running as
    //if (FALSE == CheckIfPlatformMatchesInf(g_pTheApp->m_hInfHandle))
    //{
    //    dwOcEntryReturn = ERROR_CANCELLED;
    //    goto OC_INIT_COMPONENT_Func_Exit;
    //}

    //  something like "this build requires nt build 1899 or something"
    CheckSpecificBuildinInf(g_pTheApp->m_hInfHandle);

    // Check for old gopher!
    if (FALSE == CheckForOldGopher(g_pTheApp->m_hInfHandle))
    {
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }

    // See if user configured anything
    // must happen after g_pTheApp->InitApplication
    // but before SetDIRIDforThisInf!
    ReadUserConfigurable(g_pTheApp->m_hInfHandle);

    //
    // Set up the DIRIDs for our .inf file
    // these are very very important and can get changed throughout the program
    // 
    SetDIRIDforThisInf(g_pTheApp->m_hInfHandle,TRUE);

    //
    // Set global ocm private data for other components to find out
    // (during installation) where our inetpub or inetsrv dir is located..
    SetOCGlobalPrivateData();

    dwOcEntryReturn = NO_ERROR;

    // Check if There are pending reboot operations...
    if (LogPendingReBootOperations() != ERROR_SUCCESS)
        {dwOcEntryReturn = ERROR_CANCELLED;}

    // if we already did some win95 stuff then don't need to do this
    // do this only in gui mode
    if (g_pTheApp->m_fNTGuiMode)
    {
        if (!g_pTheApp->m_bWin95Migration){CheckIfWeNeedToMoveMetabaseBin();}
    }

    // Get the last section to be called.
    _tcscpy(g_szLastSectionToGetCalled, _T(""));
    GetLastSectionToBeCalled();

    ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_INIT_COMPONENT"));

    Check_For_DebugServiceFlag();

    TestAfterInitApp();

OC_INIT_COMPONENT_Func_Exit:
    g_pTheApp->DumpAppVars();
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d \n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}

// function: IsComponentCheckedbyDefault
//
// Return whether this particular component is suppose to be installed by "default".
// By default here means that if you check all the components, is this one suppose to be
// automatically selected?
//
// Parameters:
//   szComponentName
//
// Return
//   TRUE - This component should install by default
//   FALSE - This component should NOT install by default
BOOL
IsComponentCheckedbyDefault( LPCTSTR szComponentName )
{
  BOOL  bInstallbyDefault = FALSE;
  DWORD dwCurrent;

  ASSERT( szComponentName );

  for ( dwCurrent = 0;
        dwCurrent < COMPONENT_ENDOFLIST;
        dwCurrent++ )
  {
    if ( _tcscmp( szComponentName, 
                  g_ComponentList[ dwCurrent ].szComponentName ) == 0 )
    {
      bInstallbyDefault = g_ComponentList[ dwCurrent ].bSelectedByDefault;
      break;
    }
  }

  return bInstallbyDefault;
}

//
//  FUNCTION: FatWndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the Fat warning Window.
//
LRESULT CALLBACK FatWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  TSTR_PATH strWinHelpLocation;

  switch (message) {

  case WM_HELP:
    if ( strWinHelpLocation.RetrieveWindowsDir() &&
         strWinHelpLocation.PathAppend( PATH_IISHELP ) &&
         strWinHelpLocation.Append( _T("::") ) &&
         strWinHelpLocation.Append( PATH_IISHELP_FAT_NTFS_WARNING ) )
    {
      HtmlHelp(GetDesktopWindow(), strWinHelpLocation.QueryStr(), HH_DISPLAY_TOPIC, NULL);
    }
		break;

	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
  }

  return 0;
}
//
// ShowFatWarning
//
// Display the Fat warning
//
// This window is used as a shim, between the OCM window
// and the MessageBox that we are going to pop up.  The reason
// we need this is to intercept the WM_HELP message.
//
BOOL ShowFatWarning( LPBOOL pbQuit, LPTSTR szCation, LPTSTR szText )
{
	WNDCLASSEX    wcex;
  HWND          hWnd = NULL;
  HWND          hOCMWnd = NULL;
  BOOL          bRet = FALSE;
  INT           iMessageReturn;
  TCHAR         szWindowClass[] = L"OCM_IIS_WARNING_FAT";
  ATOM          Atom = 0;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= FatWndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= (HINSTANCE) g_MyModuleHandle;
	wcex.hIcon			= NULL;
	wcex.hCursor		= NULL;
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= NULL; 
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= NULL;

	Atom = RegisterClassEx(&wcex);

  if ( Atom == 0 )
  {
    // Failure
    return FALSE;   
  }

  hOCMWnd = GetForegroundWindow();

  hWnd = CreateWindow( (LPTSTR) Atom,     // Class Name/Atom
                      NULL,               // Window Name
                      0,                  // Style
                      0,                  // X
                      0,                  // Y
                      0,                  // Width
                      0,                  // Height
                      hOCMWnd,            // Parent
                      NULL,               // Menu
                      NULL,               // hInstance (ignored on .net)
                      NULL);              

  if ( hWnd && hOCMWnd )
  {
    // Disable OCM Window
    EnableWindow( hOCMWnd, FALSE);

    iMessageReturn = MessageBox ( hWnd,             // Parent Handle
                                  szText,           // Text
                                  szCation,         // Caption
                                  MB_ICONWARNING |
                                  MB_OKCANCEL |
                                  MB_OK |
                                  MB_HELP);

    *pbQuit = !( iMessageReturn == IDOK );
    bRet = TRUE;

    // ReEnable OCM Window and set to Foreground
    EnableWindow( hOCMWnd, TRUE);
    SetForegroundWindow( hOCMWnd );
  }

  if ( hWnd )
  {
    // Destroy window we created, it is no longer needed
    DestroyWindow( hWnd );
  }

  if ( Atom )
  {
    // Unregister class needed
    UnregisterClass( (LPTSTR) Atom, (HINSTANCE) g_MyModuleHandle );
  }

  return bRet;
}

// CheckandShowFatWarning
//
// If we are being installed on a FAT partition, then show a warning
// telling the user that they are more secure on NTFS, and should choose
// that
//
// Parameters
//   bpQuit [out] - Should we quit (ie. user selected 'Cancel')
//
// Return Value
//   TRUE - Successfully called
//   FALSE - Failure during call
BOOL CheckandShowFatWarning( LPBOOL pbQuit )
{
  TSTR          strMessage;
  TSTR          strCaption;
  BOOL          bPreservesAcls = FALSE;

  if ( !DoesTheInstallDrivePreserveAcls( &bPreservesAcls ) )
  {
    return FALSE;
  }

  if ( bPreservesAcls )
  {
    // We can exit, since we preserve acls
    *pbQuit = FALSE;
    return TRUE;
  }

  if ( !strMessage.LoadString( IDS_ERROR_INSTALLONFAT ) ||
       !strCaption.LoadString( IDS_PRODUCT_IIS ) )
  {
    return FALSE;
  }

  return ShowFatWarning( pbQuit, 
                         strCaption.QueryStr(), 
                         strMessage.QueryStr() );
}

// ShouldWeChangeStateonFAT
//
// This function will take the state of the common component
// and determine if we should show a FAT warning.
//
// This is the biggest hack, so let me explain how it works
// The problem: When we show this error, we must show it only once, and
//              for all of the calls resulting from that click we must
//              return the appropriate return value.  For all subsequent
//              requests we must return success.  Because it is almost 
//              imposible to know the difference between requests, we have
//              all the logic below
//
// Directly clicked:
// You will be queried twice, and it is okay to return failure for only
// one of those, so that is what we do
//
// Dependency click:
// When someone else requiresyou, you can do the same as when you are 
// clicked directly
//
// Hireactical click (your parent is selected):
// When you parent is selected you must return the same value for all of
// the queried you receive.  Your first and last message will have this
// OCQ_DEPENDENT_SELECTION flag set.  So that is why we keep track of that
// and whether we are in the middle of the notification or not
//
// Return Values
//   0 - Deny the change
//   1 - Approve the change
//
DWORD
ShouldWeChangeStateonFAT(DWORD dwFlags)
{
  static BOOL bHaveAskedFatQuestion = FALSE;
  static BOOL bDontInstall = FALSE;
  static BOOL bParentCall = FALSE;

  // Have we already queried the user?
  if ( bHaveAskedFatQuestion )
  {
    // Was our parent selected?
    if ( bParentCall )
    {
      if ( dwFlags & OCQ_DEPENDENT_SELECTION )
      {
        bParentCall = FALSE;
        return bDontInstall ? 0 : 1;
      }
      else
      {
        return bDontInstall ? 0 : 1;
      }
    }

    return 1;
  }

  bHaveAskedFatQuestion = TRUE;

  if ( !CheckandShowFatWarning( &bDontInstall ) )
  {
    // Failed to do query, fail on change
    return 0;
  }
  
  if ( dwFlags & OCQ_DEPENDENT_SELECTION )
  {
    bParentCall = TRUE;
  }

  return bDontInstall ? 0 : 1;
}

// ShouldBlockInstall
//
// This checks if we should block the install based on the Group Policy to
// not allow instalation
//
// Return Values:
//   TRUE - Block instalation
//   FALSE - Do not block instalation
//
BOOL ShouldBlockInstall( BOOL bShowUI )
{
  static BOOL bBlockInstall = FALSE;
  static BOOL bCheckedRegistry = FALSE;

  if ( !bCheckedRegistry )
  {
    CRegistry Reg;
    CRegValue Value;
    DWORD     dwRegValue;

    if ( Reg.OpenRegistry( HKEY_LOCAL_MACHINE,
                           REG_GROUPPOLICY_BLOCKINSTALL_PATH,
                           KEY_READ ) )
    {
      if ( Reg.ReadValue( REG_GROUPPOLICY_BLOCKINSTALL_NAME,
                          Value ) &&
           Value.GetDword( &dwRegValue ) )
      {
        // If the reg key is one, then block install
        bBlockInstall = ( dwRegValue == 1 );
      }
    }

    if ( bBlockInstall )
    {
      TSTR strText;
      TSTR strCaption;

      if ( bShowUI &&
           strText.LoadString( IDS_ERROR_GROUPPOLICY ) &&
           strCaption.LoadString( IDS_PRODUCT_IIS ) )
      {
        // The first time this happens, spit up an error
        // Nothing really to do with an error, so ignore it
        MessageBox( NULL,
                    strText.QueryStr(),
                    strCaption.QueryStr(),
                    MB_OK | MB_ICONEXCLAMATION );
      }
    }

    bCheckedRegistry = TRUE;
  }

  return bBlockInstall;
}

// ShowFATErrorforSaKit
//
// The Server Appliance Kit does not install on FAT, so show
// a warning when it is selected
//
void ShowFATErrorforSaKit()
{
  TSTR strError;
  TSTR strTitle;

  if ( !strError.LoadString( IDS_ERROR_SAKITONFAT ) ||
       !strTitle.LoadString( IDS_PRODUCT_IIS ) )
  {
    return;
  }

  MessageBox( NULL,
              strError.QueryStr(),
              strTitle.QueryStr(),
              MB_OK | MB_ICONEXCLAMATION );
}

DWORD_PTR OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD dwOcEntryReturn = 0;
    DWORD dwCurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);
    BOOL  bOriginalyOn =   gHelperRoutines.QuerySelectionState(
                                  gHelperRoutines.OcManagerContext,
                                  SubcomponentId,
                                  OCSELSTATETYPE_ORIGINAL) == 1;
    BOOL  bDrivePreservesAcls;

    if ( SubcomponentId &&                // Componet is specified
         ( !bOriginalyOn ) &&             // It was originally off
         ( Param1 == 0x1 ) &&
         ( !g_pTheApp->m_fNTGuiMode ) &&
         ( !g_pTheApp->m_fUnattended ) &&
         DoesTheInstallDrivePreserveAcls( &bDrivePreservesAcls ) &&
         !bDrivePreservesAcls ) 
    {
      if ( _tcsicmp(SubcomponentId, 
                    g_ComponentList[COMPONENT_IIS_COMMON].szComponentName ) == 0 )
      {
        return ShouldWeChangeStateonFAT( (UINT) (ULONG_PTR) Param2 );
      }
      else 
        if ( _tcsicmp(SubcomponentId, 
                      g_ComponentList[COMPONENT_SAKIT_WEB].szComponentName ) == 0 )
      {
        ShowFATErrorforSaKit();

        return 0;
      }
    }

    if ( SubcomponentId &&                // Componet is specified
         ( !bOriginalyOn ) &&             // It was originally off
         ( Param1 == 0x1 ) &&
         ( !g_pTheApp->m_fNTGuiMode ) &&
         ( !g_pTheApp->m_fUnattended ) &&
         ( _tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_COMMON].szComponentName ) == 0 ) )
    {
      if ( ShouldBlockInstall( !g_pTheApp->m_fUnattended ) )
      {
        return 0;
      }
    }


    dwOcEntryReturn = 1;
    if (SubcomponentId)
    {
        //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   Param1=%d, Param2=%d, Original=%d, Current=%d\n"), ComponentId, SubcomponentId, Param1, Param2,OriginalState,CurrentState));
        if ( bOriginalyOn )
        {
            if ((BOOL)Param1)
            {
                dwOcEntryReturn = 1;
                if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0 || _tcsicmp(SubcomponentId, STRING_iis_www) == 0  ||  _tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0 )
                {
                    // check if tcpip is installed
                    g_pTheApp->IsTCPIPInstalled();
                    if (g_pTheApp->m_fTCPIP == FALSE)
                    {
                        g_pTheApp->MsgBox(NULL, IDS_TCPIP_NEEDED_ON_OPTION, MB_OK, TRUE);
                        dwOcEntryReturn = 0;
                    }
                }
            }
            else
            {
                // In upgrade case, we don't allow user to uncheck previously installed components
                if (g_pTheApp->m_eInstallMode == IM_UPGRADE)
                    {dwOcEntryReturn = 0;}
            }
        }
        else
        {
            if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0 || _tcsicmp(SubcomponentId, STRING_iis_www) == 0  || _tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0 )
            {
                if ((BOOL)Param1)
                {
                    //
                    // if we are turning ON then we NEED TCPIP
                    //
                    // check if tcpip is installed
                    g_pTheApp->IsTCPIPInstalled();
                    if (g_pTheApp->m_fTCPIP == FALSE)
                    {
                        g_pTheApp->MsgBox(NULL, IDS_TCPIP_NEEDED_ON_OPTION, MB_OK, TRUE);
                        dwOcEntryReturn = 0;
                    }
                }
            }
        }
    } 

    // Do not enable some of the components, if they are being selected because their parent is being selected
    // Param1 == 0x1 -> This tells us it is being turned on
    // Param2 & OCQ_DEPENDENT_SELECTION -> Tells us that it is selected from its parent
    // !(Param2 & OCQ_ACTUAL_SELECTION) -> Tells us it was not selected itself
    if ( ( (BOOL) Param1 ) &&
         ( ( (UINT) (ULONG_PTR) Param2 ) & OCQ_DEPENDENT_SELECTION ) &&
         !( ( (UINT) (ULONG_PTR) Param2 ) & OCQ_ACTUAL_SELECTION ) &&
         !IsComponentCheckedbyDefault( SubcomponentId ) 
       )
    {
      // Deny request to change state
      dwOcEntryReturn = 0;
    }

    //
    // if we are running on Whistler personal, then return denied.
    // so that no other component can turn us on! or think that they're going to turn us on.
    //
    if (IsWhistlerPersonal())
    {
       dwOcEntryReturn = 0;
    }

    if (dwOcEntryReturn == 0)
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d (denied) \n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    }
    else
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d (approved)\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    }

    return dwOcEntryReturn;
}



//
// gets called right before we show your page!
//
DWORD_PTR OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start.\n"), ComponentId, SubcomponentId));

    DWORD_PTR dwOcEntryReturn = 0;
    TCHAR szTempString[50];
    _tcscpy(szTempString, _T(""));

    switch (g_pTheApp->m_dwSetupMode)
    {
        case SETUPMODE_UPGRADEONLY:
            _tcscpy(szTempString, _T("SETUPMODE_UPGRADEONLY"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_REINSTALL:
            _tcscpy(szTempString, _T("SETUPMODE_REINSTALL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_REMOVEALL:
            _tcscpy(szTempString, _T("SETUPMODE_REMOVEALL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_MINIMAL:
            _tcscpy(szTempString, _T("SETUPMODE_MINIMAL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_TYPICAL:
            _tcscpy(szTempString, _T("SETUPMODE_TYPICAL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_ADDEXTRACOMPS:
            _tcscpy(szTempString, _T("SETUPMODE_ADDEXTRACOMPS"));
            dwOcEntryReturn = 0;
            break;
        case SETUPMODE_ADDREMOVE:
            _tcscpy(szTempString, _T("SETUPMODE_ADDREMOVE"));
            dwOcEntryReturn = 0;
            break;
        case SETUPMODE_CUSTOM:
            _tcscpy(szTempString, _T("SETUPMODE_CUSTOM"));
            dwOcEntryReturn = 0;
            break;
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  g_pTheApp->m_dwSetupMode=%x (%s), dwOcEntryReturn=%d\n"), ComponentId, SubcomponentId, g_pTheApp->m_dwSetupMode, szTempString, dwOcEntryReturn));
    return dwOcEntryReturn;
}


// ----------------------------------------
// Param1 = 0 if for removing component or non-0 if for adding component
// Param2 = HDSKSPC to operate on
//
// Return value is Win32 error code indicating outcome.
//
// In our case the private section for this component/subcomponent pair
// is a simple standard inf install section, so we can use the high-level
// disk space list api to do what we want.

// Logic is not correct here !!!
// ----------------------------------------
DWORD_PTR OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    BOOL bTempFlag = FALSE;
    TCHAR SectionName[128];

    dwOcEntryReturn = NO_ERROR;
    if (SubcomponentId)
    {
        bTempFlag = TRUE;
        if ( Param1 )
        {
            // add component
            _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));
            bTempFlag = SetupAddInstallSectionToDiskSpaceList(Param2,g_pTheApp->m_hInfHandle,NULL,SectionName,0,0);

        }
        else
        {
            // removing component

            // Comment this out per PatSt, 3/5/97, and change it to the install list
            //_stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("uninstall"));
            _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));
            bTempFlag = SetupRemoveInstallSectionFromDiskSpaceList(Param2,g_pTheApp->m_hInfHandle,NULL,SectionName,0,0);

            //
            // check if it's something we need to warn user about
            //

            // in add remove case, if the user is removing w3svc or msftpsvc
            // then check if clustering is installed.  if clustering is installed
            // then check if there are any cluster resources which have w3svc or msftpsvc as a
            // resouce, if there are any, then warn the user that they must remove these cluster resources!
#ifndef _CHICAGO_
            if (g_pTheApp->m_eInstallMode == IM_MAINTENANCE)
            {
                BOOL CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);
                BOOL OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
                if (OriginalState == 1 && CurrentState == 0)
                {
                    if (TRUE == DoesClusterServiceExist())
                    {
                        TCHAR * szClusterName = NULL;
                        WCHAR szServiceLookingFor[20];
                        CString MyReturnString;
                        CLUSTER_SVC_INFO_FILL_STRUCT MyStructOfInfo;

                        // check if they are trying to 
                        // remove the W3SVC service!
                        if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0 || 
                            _tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0)
                        {
                            if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName) == 0)
                            {
                                wcscpy(szServiceLookingFor,L"MSFTPSVC");
                                // check for msftpsvc resource
                                MyStructOfInfo.szTheClusterName = szClusterName;
                                MyStructOfInfo.pszTheServiceType = szServiceLookingFor;
                                MyStructOfInfo.csTheReturnServiceResName = &MyReturnString;
                                MyStructOfInfo.dwReturnStatus = 0;
                                if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                {
                                    g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_MSFTPSVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                }
                            }
                            else
                            {
                                wcscpy(szServiceLookingFor,L"W3SVC");
                                // check for w3svc resource
                                MyStructOfInfo.szTheClusterName = szClusterName;
                                MyStructOfInfo.pszTheServiceType = szServiceLookingFor;
                                MyStructOfInfo.csTheReturnServiceResName = &MyReturnString;
                                MyStructOfInfo.dwReturnStatus = 0;
                                if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                {
                                    g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_W3SVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                }
                                else
                                {
                                    // check for smtp resources
                                    wcscpy(szServiceLookingFor,L"SMTPSVC");
                                    if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                    {
                                        g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_W3SVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                    }
                                    else
                                    {
                                        // check for nntp resources
                                        wcscpy(szServiceLookingFor,L"NNTPSVC");
                                        if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                        {
                                            g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_W3SVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
#endif
        }

        dwOcEntryReturn = bTempFlag ? NO_ERROR : GetLastError();
    }

    // Display the new state of this component
    if (SubcomponentId)
    {
        if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName) == 0 || 
            _tcsicmp(SubcomponentId, STRING_iis_www) == 0)
        {
            GetIISCoreAction(TRUE);
        }
        else
        {
            GetSubcompAction(SubcomponentId, TRUE);
        }
    }

    if (dwOcEntryReturn == NO_ERROR)
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=NO_ERROR\n"), ComponentId, SubcomponentId));
    }
    else
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return='0x%x'\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    }

    return dwOcEntryReturn;
}

DWORD_PTR OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("[%1!s!,%2!s!] Start. Param1=0x%3!x!,Param2=0x%4!x!\n"), ComponentId, SubcomponentId, Param1, Param2));
    dwOcEntryReturn = NO_ERROR;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}

// -------------------------------
// Param1 = unused
// Param2 = HSPFILEQ to operate on
//
// Return value is Win32 error code indicating outcome.
//
// OC Manager calls this routine when it is ready for files to be copied
// to effect the changes the user requested. The component DLL must figure out
// whether it is being installed or uninstalled and take appropriate action.
// For this sample, we look in the private data section for this component/
// subcomponent pair, and get the name of an uninstall section for the
// uninstall case.
//
// Note that OC Manager calls us once for the *entire* component
// and then once per subcomponent. We ignore the first call.
// -------------------------------
DWORD_PTR OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start.\n"), ComponentId, SubcomponentId));
    DWORD_PTR dwOcEntryReturn = NO_ERROR;
    g_GlobalFileQueueHandle = Param2;
    g_GlobalFileQueueHandle_ReturnError = NO_ERROR;

    g_GlobalTotalTickGaugeCount = 0;

    if ( SubcomponentId )
    {
      if ( GetSubcompAction(SubcomponentId, FALSE) == AT_REMOVE )
      {
        // This is before we do our normal uninstall, so notify 
        // our component of PreUninstall
        g_pComponents->PreUnInstall( SubcomponentId );
      }
    }

    // -----------------------
    // handle all removes here = the file operations only
    // -----------------------
    //
    // Check to see if the user has chosen to "remove-all"
    //
    // handle all removes here.
    // we need to handle it in or special order
    // because we want to make sure that removeal happens in the right order.
    // right order means =(considering the 'needs' relationship - since ocmanage does not handle it).
    //
    if (!SubcomponentId)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
    }
    else
    {
      if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
          // make sure they can't mistakenly
          // do these remove's during guimode!
          if (!g_pTheApp->m_fNTGuiMode)
          {
            _tcscpy(g_szCurrentSubComponent, SubcomponentId);

            if ( _tcsicmp( SubcomponentId, 
                           g_ComponentList[COMPONENT_IIS_COMMON].szComponentName ) == 0 )
            {
              // If we are removing common, lets also remove core
              RemoveComponent( STRING_iis_core  ,1);
            }

            RemoveComponent( SubcomponentId ,1);
          }
        }
    }

    // ------------------------
    // handle fresh and upgrade
    // ------------------------
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    if (!SubcomponentId)
    {
        ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_QUEUE_FILE_OPS"));
        ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
        if (atCORE == AT_INSTALL_FRESH || atCORE == AT_INSTALL_UPGRADE || atCORE == AT_INSTALL_REINSTALL)
        {
            ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_QUEUE_FILE_OPS_install.iis_core"));
            dwOcEntryReturn = g_GlobalFileQueueHandle_ReturnError ? NO_ERROR : GetLastError();
        }
    }
    else
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);
        if (atComp == AT_INSTALL_FRESH ||atComp == AT_INSTALL_UPGRADE || atComp == AT_INSTALL_REINSTALL)
        {
            TSTR strTheSectionToDo;

            if ( strTheSectionToDo.Copy( _T("OC_QUEUE_FILE_OPS_install.") ) && 
                 strTheSectionToDo.Append(SubcomponentId)
               )
            {
              if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSectionToDo))
              {
                ProcessSection(g_pTheApp->m_hInfHandle, strTheSectionToDo.QueryStr() );
                dwOcEntryReturn = g_GlobalFileQueueHandle_ReturnError ? NO_ERROR : GetLastError();
              }
              else
              {
                dwOcEntryReturn = NO_ERROR;
              }
            }
            else
            {
              dwOcEntryReturn = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


DWORD_PTR OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. 0x%x,0x%x\n"), ComponentId, SubcomponentId, Param1, Param2));
    DWORD_PTR dwOcEntryReturn = 0;
    BOOL bTempFlag = FALSE;

    g_GlobalTotalTickGaugeCount = 0;

    if ( SubcomponentId )
    {
      ACTION_TYPE Action = GetSubcompAction(SubcomponentId, FALSE);

      if ( Action == AT_REMOVE )
      {
        TSTR strFriendlyName;
        TSTR strText;
        BOOL bSet = FALSE;

        if ( g_pComponents->GetFriendlyName( SubcomponentId, &strFriendlyName ) )
        {
          // Create text for UI
          if ( strText.LoadString( IDS_COMPONENT_REMOVING ) &&
               strText.Append( _T(" ") ) &&
               strText.Append( strFriendlyName ) )
          {
            ProgressBarTextStack_Push( strText.QueryStr() );
            bSet = TRUE;
          }
        }

        // This is the main place for uninstall, lets do all the work now
        g_pComponents->UnInstall( SubcomponentId );

        if ( bSet ) 
        {
          ProgressBarTextStack_Pop();
        }
      }
      else if ( ( Action == AT_INSTALL_FRESH ) ||
                ( Action == AT_INSTALL_UPGRADE ) ||
                ( Action == AT_INSTALL_REINSTALL ) )
      {
        // Since we are installing, lets do any PreInstall Work Now
        g_pComponents->PreInstall( SubcomponentId );
      }
    }

    // OCM will send this notification to each components by using the order
    // of bottom==>top of the dependency tree.
    // You should handle un-installation in this notification.
    dwOcEntryReturn = NO_ERROR;
    SetCurrentDirectory(g_pTheApp->m_csPathInetsrv);
    if (!SubcomponentId)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);

        // Re-set ID's which weren't available during oc_init
        SetDIRIDforThisInf(g_pTheApp->m_hInfHandle,FALSE);

        ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_ABOUT_TO_COMMIT_QUEUE"));
    }
    else
    {
        TCHAR szTheSectionToDo[100];
        _stprintf(szTheSectionToDo,_T("OC_ABOUT_TO_COMMIT_QUEUE.%s"),SubcomponentId);
        ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);

        ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);
        ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
    }

    // ------------------------------------
    // Stop any services that we need to...
    // ------------------------------------
    if (!SubcomponentId)
    {
        if (g_pTheApp->m_fNTGuiMode)
        {
            // In any type of case, either fresh,upgrade, reinstall, whatevers,
            // the services must be stopped at this point!!!!
            StopAllServicesRegardless(FALSE);
            // handle the metabase file appropriately,
            // in order to work correctly with NT5 GUI mode setup re-startable
            HandleMetabaseBeforeSetupStarts();
            //AfterRemoveAll_SaveMetabase();
        }
        else
        {
            // add\remove, so only stop services that will be affected
            StopAllServicesThatAreRelevant(FALSE);
        }
    }

    // -----------------------
    // handle all removes here
    // -----------------------
    //
    // Check to see if the user has chosen to "remove-all"
    //
    // handle all removes here.
    // we need to handle it in or special order
    // because we want to make sure that removeal happens in the right order.
    // right order means =(considering the 'needs' relationship - since ocmanage does not handle it).
    //
    if (!SubcomponentId)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
    }
    else
    {
        if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
            _tcscpy(g_szCurrentSubComponent, SubcomponentId );

            if ( _tcsicmp( SubcomponentId, 
                           g_ComponentList[COMPONENT_IIS_COMMON].szComponentName ) == 0 )
            {
              // If we are removing common, lets also remove core
              RemoveComponent( STRING_iis_core  ,2);
            }

            RemoveComponent( SubcomponentId , 2);
        }
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoFreeUnusedLibraries().Start.")));
    CoFreeUnusedLibraries();
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoFreeUnusedLibraries().End.")));


    // ------------------------------------
    // Make sure that all possible services are stopped before anytype of copyfiles!
    // ------------------------------------
    if (g_pTheApp->m_fNTGuiMode)
    {
        // In any type of case, either fresh,upgrade, reinstall, whatevers,
        // the services must be stopped at this point!!!!
        StopAllServicesRegardless(TRUE);
    }
    else
    {
        // add\remove, so only stop services that will be affected
        StopAllServicesThatAreRelevant(TRUE);
    }

    // -------------------------------------
    // Make sure to unload all dll's possible
    // -------------------------------------
    CoFreeUnusedLibrariesEx(0, 0);

    if ( SubcomponentId &&
         ( _tcscmp(SubcomponentId, STRING_iis_common ) == 0 ) &&
         ( GetSubcompAction(SubcomponentId, FALSE) == AT_REMOVE )
       )
    {
      // Remove w3ssl dependency on iisadmin
      if ( !ChangeServiceDependency(SERVICENAME_HTTP_SSL_PROVIDER, 
                                    FALSE, 
                                    SERVICENAME_IISADMIN) )
      {
        iisDebugOut((LOG_TYPE_ERROR, _T("ChangeServiceDependency failed during OC_QUEUE_FILE_OPS_Func\n") ));
      }
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}

// IsIncludedInGroupPolicyDeny
//
// Determine if the component is included in the group policy
// deny
//
// Return Values
//   TRUE - Should be denied if group policy is set
//   FALSE - Should not be denied if group policy is set
BOOL IsIncludedInGroupPolicyDeny( LPCTSTR szComponentName )
{
  if ( !szComponentName )
  {
    // No component specified
    return FALSE;
  }

  for ( DWORD i = 0;
        i < COMPONENT_ENDOFLIST;
        i++ )
  {
    if ( _tcsicmp( szComponentName, g_ComponentList[i].szComponentName ) == 0 )
    {
      return g_ComponentList[i].bIncludedInGroupPolicyDeny;
    }
  }

  // Not found
  return FALSE;
}

DWORD_PTR OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. 0x%x,0x%x\n"), ComponentId, SubcomponentId, Param1, Param2));
    // OCM will send this notification to each components by using the order
    // of top==>bottom of the dependency tree.
    // You should handle installation in this notification.
    DWORD_PTR       dwOcEntryReturn = 0;
    BOOL            bTempFlag = FALSE;
    TCHAR           szTheSectionToDo[100];
    ACTION_TYPE     Action = SubcomponentId ? 
                               GetSubcompAction(SubcomponentId, FALSE) : 
                               AT_DO_NOTHING;

    g_GlobalTotalTickGaugeCount = 0;

    if ( ( SubcomponentId != NULL ) &&
         ShouldBlockInstall( FALSE ) &&
         ( Action == AT_INSTALL_FRESH ) &&
         IsIncludedInGroupPolicyDeny( SubcomponentId ) )
    {
      iisDebugOut((LOG_TYPE_ERROR, _T("Internet Information Services (IIS)")
        _T(" could not be installed because your administrator has enabled")
        _T(" a \"Prevent IIS installation\" group policy.\n") ));
      return ERROR_ACCESS_DENIED;
    }

    if ( g_pTheApp->IsUpgrade() &&
         ( SubcomponentId != NULL ) &&
         ( _tcsicmp(SubcomponentId, STRING_iis_common ) == 0 )
       )
    {
      // If this is an upgrade in iis_common, the metabase maybe disabled and we may
      // want to reenable it, for the time being, until setup is complete
      g_pTheApp->m_bIISAdminWasDisabled = IsServiceDisabled( SERVICENAME_IISADMIN );

      if ( g_pTheApp->m_bIISAdminWasDisabled )
      {
        // Enable IISAdmin, so we can edit the metabase
        SetServiceStart( SERVICENAME_IISADMIN, SERVICE_AUTO_START );
      }
    }
  
    if (!SubcomponentId)
    {
        _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),ComponentId);
        ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
    }

    dwOcEntryReturn = NO_ERROR;
    SetCurrentDirectory(g_pTheApp->m_csPathInetsrv);
    if (SubcomponentId)
    {
        // Should get called in this order
        // ===============================
        // [Optional Components]
        // iis
        // iis_common
        // iis_inetmgr
        // iis_www
        // iis_doc
        // iis_htmla
        // iis_www_vdir_scripts
        // iis_ftp

        // ===============================
        //
        // iis_common should be the first call....
        //
        // ===============================
        if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0)
        {
            //
            // install the iis_common section
            //
            if (Action == AT_INSTALL_FRESH || Action == AT_INSTALL_UPGRADE || (Action == AT_INSTALL_REINSTALL))
            {
                _stprintf(g_MyLogFile.m_szLogPreLineInfo2,_T("%s:"),SubcomponentId);

                if (Action == AT_INSTALL_UPGRADE){ProgressBarTextStack_Set(IDS_IIS_ALL_UPGRADE);}
                else{ProgressBarTextStack_Set(IDS_IIS_ALL_INSTALL);}

                _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),SubcomponentId);
                ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
                _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

                ProgressBarTextStack_Pop();
            }

            //
            //  If we just processed iis_common,
            //  but now we should install iis_core
            //
            if (Action == AT_INSTALL_FRESH || Action == AT_INSTALL_UPGRADE || (Action == AT_INSTALL_REINSTALL) || Action == AT_DO_NOTHING)
            {
                ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
                if (atCORE == AT_INSTALL_FRESH || atCORE == AT_INSTALL_UPGRADE ||  (atCORE == AT_INSTALL_REINSTALL))
                {
                    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("iis_core:"));

                    if (Action != AT_DO_NOTHING)
                    {
                        if (atCORE == AT_INSTALL_UPGRADE){ProgressBarTextStack_Set(IDS_IIS_ALL_UPGRADE);}
                        else{ProgressBarTextStack_Set(IDS_IIS_ALL_INSTALL);}
                    }

                    _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),STRING_iis_core);
                    ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
                    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

                    if (Action != AT_DO_NOTHING)
                    {
                        ProgressBarTextStack_Pop();
                    }
                }
            }

        }
        else if ( _tcscmp(SubcomponentId, COMPONENTS_SAKIT_WEB ) == 0 )
          {
            SAKit Kit;

            if (Action == AT_INSTALL_FRESH || Action == AT_INSTALL_UPGRADE || (Action == AT_INSTALL_REINSTALL))
            {
              Kit.InstallKit_Web();
            }
            else if (Action == AT_REMOVE)
            {
              Kit.UninstallKit_Web();
            }
          }
          else
            {
                // ===============================
                //
                // Handle the Registration of all other components...
                //
                // ===============================
                if (Action == AT_INSTALL_FRESH || Action == AT_INSTALL_UPGRADE || (Action == AT_INSTALL_REINSTALL))
                {
                    _stprintf(g_MyLogFile.m_szLogPreLineInfo2,_T("%s:"),SubcomponentId);

                    if (Action == AT_INSTALL_UPGRADE){ProgressBarTextStack_Set(IDS_IIS_ALL_UPGRADE);}
                    else{ProgressBarTextStack_Set(IDS_IIS_ALL_INSTALL);}

                    // Call the sections registration stuff.
                    if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) 
                    {
                        // Do this at the end of setup since things that it needs may not happen yet (mmc)
                        g_Please_Call_Register_iis_inetmgr = TRUE;
                       // Register_iis_inetmgr();
                    }

                    _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),SubcomponentId);
                    ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);

                    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

                    ProgressBarTextStack_Pop();
                }
            }

        //
        // If we are removing something, then remove the directories
        //
        if (Action == AT_REMOVE)
        {
            ProgressBarTextStack_Set(IDS_IIS_ALL_REMOVE);

            _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_remove.%s"),SubcomponentId);
            ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);

            ProgressBarTextStack_Pop();
        }
    }


    AdvanceProgressBarTickGauge();

    SumUpProgressBarTickGauge(SubcomponentId);

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    
    if ( SubcomponentId )
    {
      if ( Action == AT_REMOVE )
      {
        // Call the appropriate PostUninstall, since everything has already
        // been pretty much done
        g_pComponents->PostUnInstall( SubcomponentId );
      }
      else if ( ( Action == AT_INSTALL_FRESH ) ||
                ( Action == AT_INSTALL_UPGRADE ) ||
                ( Action == AT_INSTALL_REINSTALL ) )
      {
        TSTR strFriendlyName;
        TSTR strText;
        BOOL bSet = FALSE;

        if ( g_pComponents->GetFriendlyName( SubcomponentId, &strFriendlyName ) )
        {
          // Create text for UI
          if ( strText.LoadString( IDS_COMPONENT_INSTALLING ) &&
               strText.Append( _T(" ") ) &&
               strText.Append( strFriendlyName ) )
          {
            ProgressBarTextStack_Push( strText.QueryStr() );
            bSet = TRUE;
          }
        }

        // Call the appropriate Install section for this component
        g_pComponents->Install( SubcomponentId );

        if ( bSet ) 
        {
          ProgressBarTextStack_Pop();
        }
      }
    }

    // If this is iis_www, and it is an upgrade, lets make sure that we migrate the
    // filters from the registry
    if ( SubcomponentId &&
         ( _tcscmp(SubcomponentId, STRING_iis_www ) == 0 ) &&
         ( g_pTheApp->IsUpgrade() ) &&
         ( g_pTheApp->GetUpgradeVersion() < 6 )
       )
    {
      CFilter::MigrateRegistryFilterstoMetabase();
    }

    if ( SubcomponentId &&
         ( _tcscmp(SubcomponentId, STRING_iis_www ) == 0 ) &&
         ( ( Action == AT_INSTALL_FRESH ) ||
           ( Action == AT_INSTALL_UPGRADE ) ||
           ( Action == AT_INSTALL_REINSTALL )
         )
       )
    {

      if ( !ChangeServiceDependency(SERVICENAME_HTTP_SSL_PROVIDER, 
                                    TRUE, 
                                    SERVICENAME_IISADMIN) )
      {
        iisDebugOut((LOG_TYPE_ERROR, _T("ChangeServiceDependency failed during OC_COMPLETE_INSTALLATION_Func\n") ));
      }
    }

    // check if this is the last section to get called!!!
    if (SubcomponentId)
        {
        // Yes this is the last section to get called! So, let's say sooooo....
        if (_tcsicmp(SubcomponentId, g_szLastSectionToGetCalled) == 0)
            {

            // Enforce max connections
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                //EnforceMaxConnections();
            }

            // free some memory
            FreeTaskListMem();
            UnInit_Lib_PSAPI();

            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("....All OC_COMPLETE_INSTALLATION for all 'IIS' sections have been completed.....\n")));

            // if there were errors then popup message box.
            MesssageBoxErrors_IIS();
            }
        }

    return dwOcEntryReturn;
}

DWORD_PTR OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD       dwCurrent;
    ACTION_TYPE Action;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. 0x%x,0x%x\n"), ComponentId, SubcomponentId, Param1, Param2));
    // OCM send out this notification after the "Finish" button on
    // the End Page has been clicked.
    //
    // remove the files we downloaded from the web in this session
    DWORD_PTR dwOcEntryReturn = 0;

    // display running services in case our services
    // need other services to be running!
    ShowStateOfTheseServices(g_pTheApp->m_hInfHandle);

    for ( dwCurrent = 0;
          dwCurrent < COMPONENT_ENDOFLIST;
          dwCurrent++ )
    {
      Action = GetSubcompAction( g_ComponentList[dwCurrent].szComponentName , FALSE);

      if ( ( Action == AT_INSTALL_FRESH ) ||
           ( Action == AT_INSTALL_UPGRADE ) ||
           ( Action == AT_INSTALL_REINSTALL ) )
      {
        // This is our last point on install, so lets notify of 
        // any PostInstall
        g_pComponents->PostInstall( g_ComponentList[dwCurrent].szComponentName );
      }
    }

    // Lets assert that the Enum for this list, and the list length match up
    ASSERT( g_ComponentList[dwCurrent].szComponentName == NULL );

    // Install inetmgr after gui mode setup is done because
    // it may require other things that were setup in guimode.
    if (TRUE == g_Please_Call_Register_iis_inetmgr) {Register_iis_inetmgr();}

    ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_CLEANUP"));

    // restart services that we stopped
    ServicesRestartList_RestartServices();
#ifndef _CHICAGO_
    // restart cluster resources that we had stopped
    if (!g_pTheApp->m_fNTGuiMode)
    {
        BringALLIISClusterResourcesOnline();
    }
#endif

    //--------------------------------------------------------------------
    // For Migrations we need to scan the entire metabase and look for the old
    // system directory (e.g. "C:\\Windows\\System\\") and replace
    // with the new system directory (e.g. "C:\\WINNT.1\\System32\\")
    //
    // Does the iisadmin service exist?
    // Does the metabase exist???
    if (g_pTheApp->m_eInstallMode == IM_UPGRADE)
    {
        if (g_pTheApp->m_fMoveInetsrv)
        {
            // Check if the iisadmin service exists...
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                CMDKey cmdKey;
                cmdKey.OpenNode(_T("LM"));
                if ( (METADATA_HANDLE)cmdKey ) 
                {
                    HRESULT hr;
                    cmdKey.Close();
                    CString cOldWinSysPath;
                    CString cNewWinSysPath;

                    // Change all "c:\windows\system\inetsrv" to "c:\windows\system32\inetsrv"
                    cOldWinSysPath = g_pTheApp->m_csPathOldInetsrv;
                    cOldWinSysPath += _T("\\"); // add a trailing backslash
                    cNewWinSysPath = g_pTheApp->m_csPathInetsrv;
                    cNewWinSysPath += _T("\\"); // add a trailing backslash

                    iisDebugOut((LOG_TYPE_TRACE, _T("CPhysicalPathFixer: please change %s to %s.\n"),cOldWinSysPath, cNewWinSysPath));
                    CPhysicalPathFixer cmdKeySpecial(cOldWinSysPath, cNewWinSysPath);
                    hr = cmdKeySpecial.Update(_T("LM"), TRUE);
                    if (FAILED(hr)) {iisDebugOut((LOG_TYPE_ERROR, _T("CPhysicalPathFixer failed return HR:%#lx\n"), hr));}

                    // Change all "%WinDir%\System" to "%windir%\System32"
                    cOldWinSysPath = _T("%WinDir%\\System");
                    cNewWinSysPath = _T("%WinDir%\\System32");
                    CPhysicalPathFixer cmdKeySpecial2(cOldWinSysPath, cNewWinSysPath);
                    hr = cmdKeySpecial2.Update(_T("LM"), TRUE);
                    if (FAILED(hr)) {iisDebugOut((LOG_TYPE_ERROR, _T("CPhysicalPathFixer failed return HR:%#lx\n"), hr));}
                }
            }
        }
    }

    // if iis is installed, then check if Tcp/ip is installed.
    // if it is not installed... then output some error message to the log saying 
    // a big warning that they must install tcp/ip inorder for iis to work.
    //IDS_TCPIP_ERROR
    if (CheckifServiceExist(_T("TCPIP")) == ERROR_SERVICE_DOES_NOT_EXIST)
    {
        int IISInstalled = FALSE;
        if (CheckifServiceExist(_T("W3SVC")) == 0 )
            {IISInstalled=TRUE;}
        if (CheckifServiceExist(_T("MSFTPSVC")) == 0 )
            {IISInstalled=TRUE;}
        if (IISInstalled)
        {
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T(""));
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("FAIL:"));

            CString csTemp;
            MyLoadString(IDS_TCPIP_ERROR, csTemp);
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("================================\n")));
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("%s\n"), csTemp));
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("================================\n")));
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_CLEANUP:"));
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

            //LogSevInformation           0x00000000
            //LogSevWarning               0x00000001
            //LogSevError                 0x00000002
            //LogSevFatalError            0x00000003
            //LogSevMaximum               0x00000004
            // Write it to the setupapi log file!
            SetupLogError(csTemp, LogSevWarning);
        }
    }
    else
    {
        // The tcpip service exists, but is it running???
    }

    // Write the uninstall info for this session out to the registry
    g_pTheApp->UnInstallList_RegWrite();

    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP);
    if ((HKEY) regINetStp){regINetStp.DeleteValue(_T("MetabaseUnSecuredRead"));}
    
    if ( g_pTheApp->m_bIISAdminWasDisabled )
    {
      // ReDisable the IISAdmin Service
      SetServiceStart( SERVICENAME_IISADMIN, SERVICE_DISABLED );
    }
    
    dwOcEntryReturn = 0;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}

//
// Param1 = char width flags
// Param2 = unused
//
// Return value is a flag indicating to OC Manager
// which char width we want to run in. Run in "native"
// char width.
//
DWORD_PTR OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
#ifdef UNICODE
    dwOcEntryReturn = OCFLAG_UNICODE;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s]   End.  Return=%d (OCFLAG_UNICODE)\n"), ComponentId, dwOcEntryReturn));
#else
    dwOcEntryReturn = OCFLAG_ANSI;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s]   End.  Return=%d (OCFLAG_ANSI)\n"), ComponentId, dwOcEntryReturn));
#endif
    return dwOcEntryReturn;
}

//
// Param1 = low 16 bits specify Win32 LANGID
// Param2 = unused
//
// Return code is a boolean indicating whether we think we
// support the requested language. We remember the language id
// and say we support the language. A more exact check might involve
// looking through our resources via EnumResourcesLnguages() for
// example, or checking our inf to see whether there is a matching
// or closely matching [strings] section. We don't bother with
// any of that here.
//
// Locate the component and remember the language id for later use.
//
DWORD_PTR OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    dwOcEntryReturn = TRUE;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End. Win32LANGID=0x%x,  Return=%d\n"), ComponentId, SubcomponentId, Param1, dwOcEntryReturn));

    return dwOcEntryReturn;
}

#ifdef _WIN64
DWORD_PTR OC_QUERY_IMAGE_EX_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
  BOOL bReturn = FALSE;
  HBITMAP hBitMap = NULL;
  HBITMAP * phBitMapInput = NULL;
  OC_QUERY_IMAGE_INFO * MyQueryInfo = NULL;
  MyQueryInfo = (OC_QUERY_IMAGE_INFO *) Param1;

  phBitMapInput = (HBITMAP *) Param2;

  if(MyQueryInfo->ComponentInfo == SubCompInfoSmallIcon)
  {
    if ( g_pComponents->GetSmallIcon( SubcomponentId, &hBitMap ) )
    {
      // Nothing need to be done, we have retrieved the value
    }
    else
    {
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle,MAKEINTRESOURCE(IDB_FTP));}
      if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_WWW_PARENT].szComponentName) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
      if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_scripts) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
      if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_printers) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
      if (_tcsicmp(SubcomponentId, COMPONENTS_SAKIT_WEB) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
      if (_tcsicmp(SubcomponentId, STRING_iis_htmla) == 0 || _tcsicmp(SubcomponentId, STRING_iis_doc) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_HTMLA));}
      if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WEBAPPSRV_CONSOLE));}
      if (_tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_PWS));}
      if (_tcsicmp(SubcomponentId, _T("iis")) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_TOPLEVEL_IIS));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_WEBAPPSRV_CONSOLE].szComponentName) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WEBAPPSRV_CONSOLE));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_COMPLUS].szComponentName) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_ICON_COMPLUS));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_DTC].szComponentName) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_ICON_DTC));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_WEBAPPSRV].szComponentName) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_ICON_WEB_APP_SERVER));}
    }

    if (hBitMap)
    {
      *phBitMapInput = (HBITMAP) hBitMap;
      bReturn = TRUE;
    }
  }

  if (phBitMapInput != NULL)
  {
      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=0x%x.\n"), ComponentId, SubcomponentId,phBitMapInput));
  }
  else
  {
      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=0x%x.\n"), ComponentId, SubcomponentId,phBitMapInput));
  }
  MyQueryInfo = NULL;
  return bReturn;
}
#endif


DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
  DWORD_PTR dwOcEntryReturn;
  HBITMAP   hBitMap = NULL;

  dwOcEntryReturn = (DWORD)NULL;

  if(LOWORD(Param1) == SubCompInfoSmallIcon)
  {
    if ( g_pComponents->GetSmallIcon( SubcomponentId, &hBitMap ) )
    {
      dwOcEntryReturn = (DWORD) (DWORD_PTR) hBitMap;
    }
    else
    {
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle,MAKEINTRESOURCE(IDB_FTP));}
      if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_WWW_PARENT].szComponentName) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
      if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_scripts) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
      if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_printers) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
      if (_tcsicmp(SubcomponentId, COMPONENTS_SAKIT_WEB) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
      if (_tcsicmp(SubcomponentId, STRING_iis_htmla) == 0 || _tcsicmp(SubcomponentId, STRING_iis_doc) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_HTMLA));}
      if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WEBAPPSRV_CONSOLE));}
      if (_tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_PWS));}
      if (_tcsicmp(SubcomponentId, _T("iis")) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_TOPLEVEL_IIS));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_WEBAPPSRV_CONSOLE].szComponentName) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WEBAPPSRV_CONSOLE));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_COMPLUS].szComponentName) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_ICON_COMPLUS));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_DTC].szComponentName) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_ICON_DTC));}
      if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_WEBAPPSRV].szComponentName) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_ICON_WEB_APP_SERVER));}
    }
  }

  if (dwOcEntryReturn != NULL)
  {
      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=0x%x.\n"), ComponentId, SubcomponentId,dwOcEntryReturn));
  }
  else
  {
      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=NULL.\n"), ComponentId, SubcomponentId));
  }
  return dwOcEntryReturn;
}


int GetTotalTickGaugeFromINF(IN LPCTSTR SubcomponentId, IN int GimmieForInstall)
{
    int nReturn = 0;
    INFCONTEXT Context;
    TCHAR szTempString[20];
    TCHAR szTempString2[20];
    
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("TotalTicks"), &Context) )
    {
        SetupGetStringField(&Context, 1, szTempString, 20, NULL);

        if (!SetupGetStringField(&Context, 2, szTempString2, 20, NULL))
            {_tcscpy(szTempString2,szTempString);}

        //iisDebugOut((LOG_TYPE_TRACE, _T("GetTotalTickGaugeFromINF:%s,%s\n"),szTempString,szTempString2));

        if (GimmieForInstall)
        {
            nReturn = _ttoi(szTempString);
        }
        else
        {
            nReturn = _ttoi(szTempString2);
        }
    }

    return nReturn;
}


//
// Param1 = unused
// Param2 = unused
//
// Return value is an arbitrary 'step' count or -1 if error.
//
// OC Manager calls this routine when it wants to find out how much
// work the component wants to perform for nonfile operations to
// install/uninstall a component/subcomponent.
// It is called once for the *entire* component and then once for
// each subcomponent in the component.
//
// One could get arbitrarily fancy here but we simply return 2 step
// per subcomponent. We ignore the "entire component" case.
//
DWORD_PTR OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;

    // iis
    // iis_common
    // iis_inetmgr
    // iis_www
    // iis_doc
    // iis_htmla
    // iis_ftp

    //AT_DO_NOTHING AT_REMOVE AT_INSTALL_FRESH AT_INSTALL_UPGRADE AT_INSTALL_REINSTALL

    if (SubcomponentId)
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);

        // Set the Tick Total value for iis_common (which includes iis_core)
        if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0)
        {
            // Get the operations for Core instead since this is bigger.
            ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
            if (atCORE == AT_REMOVE) 
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atCORE == AT_DO_NOTHING) 
                {dwOcEntryReturn = 0;}
        }
        else
        {
            if (atComp == AT_REMOVE)
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atComp == AT_DO_NOTHING) 
                {dwOcEntryReturn = 0;}
        }
    }
    else
    {
        //
        // "Entire component" case, which we ignore.
        //
        dwOcEntryReturn = 0;
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


//
// This is a fake notification. You'll never receive this notification from OCM.
//
DWORD_PTR OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;

    dwOcEntryReturn = 0;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));

    return dwOcEntryReturn;
}


void StopAllServicesThatAreRelevant(int iShowErrorsFlag)
{
    int iPleaseStopTheService = FALSE;
#ifndef _CHICAGO_
    ACTION_TYPE atTheComponent_core = GetIISCoreAction(FALSE);
    ACTION_TYPE atTheComponent_ftp = GetSubcompAction( g_ComponentList[COMPONENT_IIS_FTP].szComponentName, FALSE);
    ACTION_TYPE atTheComponent_www = GetSubcompAction(STRING_iis_www, FALSE);

    int BringALLIISClusterResourcesOffline_WasCalled = FALSE;

    //ACTION_TYPE atTheComponent_common = GetSubcompAction(STRING_iis_common, FALSE);
    //ACTION_TYPE atTheComponent_inetmgr = GetSubcompAction(STRING_iis_inetmgr, FALSE);
    //ACTION_TYPE atTheComponent_pwmgr = GetSubcompAction(STRING_iis_pwmgr, FALSE);
    //ACTION_TYPE atTheComponent_doc = GetSubcompAction(STRING_iis_doc, FALSE);
    //ACTION_TYPE atTheComponent_htmla = GetSubcompAction(STRING_iis_htmla, FALSE);
    
    // ----------------------
    // Handle the MSFTPSVC service...
    // ----------------------
    // Check if we are going to remove something...
    iPleaseStopTheService = FALSE;
    if (atTheComponent_ftp != AT_DO_NOTHING){iPleaseStopTheService = TRUE;}
    if (iPleaseStopTheService)
    {
        // important: you must take iis clusters off line before doing anykind of upgrade\installs...
        // but incase the user didn't do this... try to take them off line for the user
        if (FALSE == BringALLIISClusterResourcesOffline_WasCalled)
        {
	        DWORD dwResult = ERROR_SUCCESS;
	        dwResult = BringALLIISClusterResourcesOffline();
            BringALLIISClusterResourcesOffline_WasCalled = TRUE;
        }
        if (StopServiceAndDependencies(_T("MSFTPSVC"), FALSE) == FALSE)
        {
            if (iShowErrorsFlag)
            {
                MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("MSFTPSVC"), MB_OK | MB_SETFOREGROUND);
            }
        }
    }

    // ----------------------
    // Handle the W3SVC service...
    // ----------------------
    iPleaseStopTheService = FALSE;
    if (atTheComponent_www != AT_DO_NOTHING){iPleaseStopTheService = TRUE;}

    if (iPleaseStopTheService)
    {
        // important: you must take iis clusters off line before doing anykind of upgrade\installs...
        // but incase the user didn't do this... try to take them off line for the user
        if (FALSE == BringALLIISClusterResourcesOffline_WasCalled)
        {
	        DWORD dwResult = ERROR_SUCCESS;
	        dwResult = BringALLIISClusterResourcesOffline();
            BringALLIISClusterResourcesOffline_WasCalled = TRUE;
        }
        if (StopServiceAndDependencies(_T("W3SVC"), FALSE) == FALSE)
        {
            if (iShowErrorsFlag)
            {
                MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("W3SVC"), MB_OK | MB_SETFOREGROUND);
            }
        }
    }

    // ----------------------
    // Handle the IISADMIN service...
    // ----------------------
    iPleaseStopTheService = FALSE;
    if (atTheComponent_core != AT_DO_NOTHING){iPleaseStopTheService = TRUE;}

    // if they are adding msftpsvc or w3svc, then we'll have to stop this iisadmin service as well!
    // why?  because the iisadmin serivce (inetinfo.exe) can be locking some files that we want to copy in.
    // and if we can't copy them in, things could get hosed -- especially w3svc.
    // actually if you think about it all the services (msftp,w3svc,smtp, etc..) area all running in the same process (inetinfo.exe)
    // so it kinda makes sense that we have to stop this service when add\removing.

    // let's say i removed msftpsvc -- and the services are still running,
    // then i go and re-add msftpsvc -- well because we didn't reboot some of those ftp files are still
    // locked -- so well have to do the old "slip it in on reboot" trick or something
    // which still may have problems.  Bottom line here is -- we have to stop iisadmin service when adding\readding
    // msftpsvc or w3svc

    // when i tested this -- it looks like the wam*.dll's get locked by the inetinfo.exe process
    // so i have to stop the iisadmin service to unload those.
    
    // if we they are trying to remove ftp then we don't have to stop the iisadmin service.
    // but if we are trying to add, then stop the iisadmin service
    if (atTheComponent_ftp != AT_DO_NOTHING && atTheComponent_ftp != AT_REMOVE)
        {iPleaseStopTheService = TRUE;}

    // if we they are trying to remove w3svc then we don't have to stop the iisadmin service.
    // but if we are trying to add, then stop the iisadmin service
    if (atTheComponent_www != AT_DO_NOTHING && atTheComponent_www != AT_REMOVE)
        {iPleaseStopTheService = TRUE;}

    if (iPleaseStopTheService)
    {
        // important: you must take iis clusters off line before doing anykind of upgrade\installs...
        // but incase the user didn't do this... try to take them off line for the user
        if (FALSE == BringALLIISClusterResourcesOffline_WasCalled)
        {
	        DWORD dwResult = ERROR_SUCCESS;
	        dwResult = BringALLIISClusterResourcesOffline();
            BringALLIISClusterResourcesOffline_WasCalled = TRUE;
        }
        if (StopServiceAndDependencies(_T("IISADMIN"), TRUE) == FALSE)
        {
            if (iShowErrorsFlag)
            {
                MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("IISADMIN"), MB_OK | MB_SETFOREGROUND);
            }
        }
    }

#endif
    return;
}


DWORD_PTR OC_FILE_BUSY_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    //dwOcEntryReturn = TRUE;
    PFILEPATHS pTheBusyFile;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   Start.\n"), ComponentId, SubcomponentId));

    pTheBusyFile = (PFILEPATHS) Param1;
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Target=%1!s!, Source=%2!s!\n"), pTheBusyFile->Target, pTheBusyFile->Source));

    ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_FILE_BUSY"));

    // display the file version information
    LogFileVersion(pTheBusyFile->Target, TRUE);

    // handle the file busy stuff ourselves.
    // either - 1. findout who is locking this file -- which process or services and stop it.
    //          2. or try to rename the locked file and copy in the new one.
    //             will set the reboot flag if we did #2
    HandleFileBusyOurSelf(pTheBusyFile);

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


#define HandleMetabaseBeforeSetupStarts_log _T("HandleMetabaseBeforeSetupStarts")
void HandleMetabaseBeforeSetupStarts()
/*++

Routine Description:

    This function handles the metabase file in various installation scenario before iis setup really starts.
    It is developed in order to handle NT5 GUI mode setup re-startable.

    This function should be called exactly after we have stopped all running iis services,
    such that nobody is locking the metabase file.

Arguments:

    None

Return Value:

    void

--*/
{
    CString csMetabaseFile;

    csMetabaseFile = g_pTheApp->m_csPathInetsrv + _T("\\metabase.bin");

    switch (g_pTheApp->m_eInstallMode) {
    case IM_UPGRADE:
        {
            if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
                CString csBackupFile;

                csBackupFile = g_pTheApp->m_csPathInetsrv + _T("\\upg45b2.bin");

                if (IsFileExist(csBackupFile)) {
                    //
                    // restore it back to be the current metabase.bin
                    //

                    iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:restore upg45b2.bin to metabase.bin\n"),HandleMetabaseBeforeSetupStarts_log));
                    InetCopyFile(csBackupFile, csMetabaseFile);

                } else {
                    //
                    // backup the current metabase.bin to upg45b2.bin
                    //
                    if (IsFileExist(csMetabaseFile)) 
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:backup metabase.bin to upg45b2.bin\n"),HandleMetabaseBeforeSetupStarts_log));
                        InetCopyFile(csMetabaseFile, csBackupFile);
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:backup metabase.bin to upg45b2.bin.  metabase.bin not found WARNING.\n"),HandleMetabaseBeforeSetupStarts_log));
                    }
                }

                //
                // delete the backup file on reboot
                //

                iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:mark upg45b2.bin as delete-on-reboot\n"),HandleMetabaseBeforeSetupStarts_log));
                MoveFileEx( (LPCTSTR)csBackupFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );

                break;
            }

            // for all the other upgrades, fall through
            // to blow away the existing metabase.bin
        }
    case IM_FRESH:
        {
            //
            // blow away the existing metabase.bin
            //
            iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_FRESH.Delete metabase.bin for NTsetup restartable mode case.\n"),HandleMetabaseBeforeSetupStarts_log));
            InetDeleteFile(csMetabaseFile);
            break;
        }
    default:
        {
            break;
        }
    }

    return;
}

void SetRebootFlag(void)
{
	gHelperRoutines.SetReboot(gHelperRoutines.OcManagerContext, TRUE);
}


#define GetStateFromUnattendFile_log _T("GetStateFromUnattendFile")
int GetStateFromUnattendFile(LPCTSTR SubcomponentId)
/*++

Routine Description:

    This function determines the current state of SubcomponentId
    according to values specified in the unattend text file.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff/SubcompUseOcManagerDefault
    This function returns SubcompUseOcManagerDefault in case the value of SubcomponentId
    is neither specified as ON nor OFF.

--*/
{
    int nReturn = SubcompUseOcManagerDefault;
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szValue[_MAX_PATH] = _T("");

    _tcscpy(szSectionName, _T("InternetServer"));

    if (g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE || g_pTheApp->m_hUnattendFile == NULL)
        {return SubcompUseOcManagerDefault;}

    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, SubcomponentId, &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}

    if (_tcsicmp(szValue, _T("ON")) == 0)
        {nReturn = SubcompOn;}
    else if (_tcsicmp(szValue, _T("OFF")) == 0)
        {nReturn = SubcompOff;}
    else
        {nReturn = SubcompUseOcManagerDefault;}

    if (SubcompOn)
        {iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s returns SubcompOn\n"), GetStateFromUnattendFile_log, SubcomponentId));}
    if (SubcompOff)
        {iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s returns SubcompOff\n"), GetStateFromUnattendFile_log, SubcomponentId));}
    if (SubcompUseOcManagerDefault)
        {iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s returns SubcompUseOcManagerDefault\n"), GetStateFromUnattendFile_log, SubcomponentId));}

    return nReturn;
}

int GetStateFromModesLine(LPCTSTR SubcomponentId, int nModes)
/*++

Routine Description:

    This function determines the current state of SubcomponentId
    according to the Modes= line specified in the inf file.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff only

--*/
{
    int nReturn = SubcompOff;
    BOOL bFound = FALSE;
    INFCONTEXT Context;

    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("Modes"), &Context) )
    {
        int n, i, nValue;

        n = SetupGetFieldCount(&Context);
        for(i=0; i<n; i++) {
            if(SetupGetIntField(&Context,i+1,&nValue) && ((DWORD)nValue < 32)) {
                if (nValue == nModes) {
                    bFound = TRUE;
                    break;
                }
            }
        }
    }

    if (bFound)
        nReturn = SubcompOn;
    else
        nReturn = SubcompOff;

    iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s for mode %d returns %d\n"), GetStateFromUnattendFile_log, SubcomponentId, nModes, nReturn));
    
    return nReturn;
}

int GetStateFromRegistry(LPCTSTR SubcomponentId)
/*++

Routine Description:

    This function determines the original state of SubcomponentId
    according to the registry value.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff only

--*/
{
    int nReturn = SubcompOff;

    CRegKey regKey(HKEY_LOCAL_MACHINE,OC_MANAGER_SETUP_KEY,KEY_READ);
    if ((HKEY)regKey) 
    {
        DWORD dwValue = 0xffffffff;
        regKey.m_iDisplayWarnings = TRUE;
        if (regKey.QueryValue(SubcomponentId, dwValue) == ERROR_SUCCESS)
        {
            if (dwValue == 0x0)
                nReturn = SubcompOff;
            else
                nReturn = SubcompOn;
        }
    }
    
    iisDebugOut((LOG_TYPE_TRACE, _T("GetStateFromRegistry() on %s returns %d\n"), SubcomponentId, nReturn));
    
    return nReturn;
}


int IsThisSubCompNeededByOthers(LPCTSTR SubcomponentId)
{
    int iReturn = FALSE;

    // search thru our inf to see if another component needs it

    return iReturn;
}

int DoesOCManagerKeyExist(LPCTSTR SubcomponentId)
{
    int iReturn = FALSE;

    CRegKey regKey(HKEY_LOCAL_MACHINE,OC_MANAGER_SETUP_KEY,KEY_READ);
    if ((HKEY)regKey) 
    {
        DWORD dwValue = 0xffffffff;
        regKey.m_iDisplayWarnings = FALSE;
        if (regKey.QueryValue(SubcomponentId, dwValue) == ERROR_SUCCESS)
            {iReturn = TRUE;}
    }
    return iReturn;
}


int GetStateFromUpgRegLines(LPCTSTR SubcomponentId)
/*++

Routine Description:

    This function determines the original state of SubcomponentId
    according to the UpgReg= line specified in the inf file.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff only

--*/
{
    int nReturn = SubcompOff;
    INFCONTEXT Context;
    TCHAR szPath[_MAX_PATH];
    TCHAR szUpgradeInfKeyToUse[30];

    _tcscpy(szUpgradeInfKeyToUse, _T("None"));

    // Check for special NT4 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_40)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg4"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg4"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg4.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }
    // Check for special NT60 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_60)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg60"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg60"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg60.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }

    // Check for special NT5 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_51)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg51"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg51"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg51.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }

    // Check for special NT5 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_50)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg5"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg5"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg5.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }

    // Check if there is a specific one for our special upgrade type.
    _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg"));

    if (g_pTheApp->m_eUpgradeType == UT_351)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg351"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg351"));}
    }

    if (g_pTheApp->m_eUpgradeType == UT_10)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg1"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg1"));}
    }

    if (g_pTheApp->m_eUpgradeType == UT_20)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg2"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg2"));}
    }
    if (g_pTheApp->m_eUpgradeType == UT_30)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg3"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg3"));}
    }
    if (g_pTheApp->m_eUpgradeType == UT_10_W95)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg1_w95"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg1_w95"));}
    }

    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, szUpgradeInfKeyToUse, &Context) ) 
    {
        SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
        CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
        if ((HKEY)regKey)
        {
            TCHAR szCompId[_MAX_PATH];
            int iValue = 0;
            DWORD dwValue = 0xffffffff;

            // check if there is a parameter specified
            if (SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL))
            {
                if (SetupGetIntField(&Context, 3, &iValue))
                {
                    // check if the dword matches what we specified.
                    regKey.m_iDisplayWarnings = FALSE;
                    if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                    {
                        if (dwValue == (DWORD)iValue)
                            {nReturn = SubcompOn;}
                    }
                }
                else
                {
                    // just check for existence.
                    regKey.m_iDisplayWarnings = FALSE;
                    if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                    {
                        nReturn = SubcompOn;
                    }
                }
            }
            else
            {
                nReturn = SubcompOn;
            }
        }
    }
    
GetStateFromUpgRegLines_Exit:
    iisDebugOut((LOG_TYPE_TRACE, _T("GetStateFromUpgRegLines() %s:%s returns %d\n"), szUpgradeInfKeyToUse, SubcomponentId, nReturn));
    return nReturn;
}

void InCaseNoTCPIP(LPCTSTR SubcomponentId, int nNewStateValue, int *pnState)
/*++

Routine Description:

    This function overwrites current state with nNewStateValue 
    in case that TCPIP is not present.

Arguments:

    LPCTSTR SubcomponentId: e.g., iis_www, etc.
    int nNewStateValue: SubcompOn/SubcompOff/SubcompUseOcManagerDefault
    int *pnState: pointer to the state which will be overwritten if condition is met.

Return Value:

    void

--*/
{
    // check if tcpip is installed
    g_pTheApp->IsTCPIPInstalled();

    if (g_pTheApp->m_fTCPIP == FALSE) 
    {
        if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0 || 
            _tcsicmp(SubcomponentId, STRING_iis_www) == 0     || 
            _tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0 )
        {
            *pnState = nNewStateValue;
        }
    }

    return;
}

DWORD_PTR OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
/*++

Routine Description:

    This function handles OC_QUERY_STATE notification.
    
    IIS 4.0 SETUP NOTE (LinanT): 
    ============================
    This function returns SubcompOn/SubcompOff explicitly. 
    It does NOT return SubcompUseOcManagerDefault, because 
    OCM sometimes behaves strangely when SubcompUseOcManagerDefault is returned.
    The above comments were valid for iis4 but in iis5 ocmanage has been fixed so
    that SubcompUseOcManagerDefault is valid

    IIS 5.0 SETUP NOTE (AaronL):
    ============================
    Well okay.  iis5.0 shipped with Win2000, Patst and then AndrewR took over the ocmanager.
    They made a bunch of changes to ocmanager to appropriately handle the "needs" relationship stuff in the .inf files.
    Anyway, that stuffs all kool, however things had to be changed in order for this oc_query_state stuff to work.

    Here is basic description of how this works:

    OCSELSTATETYPE_ORIGINAL
    -----------------------
    During setup ocmanage will ask each of the components for they're original state (OCSELSTATETYPE_ORIGINAL).
    In this call each component can return back the state of that certain component -- such as "yes, a previous inetmgr 1.0,2.0,3.0,4.0 or 5.0 is already installed".

    If this is a fresh\maintenance installation, the component should return back SubcompUseOcManagerDefault.  Meaning, ocmanage will look in the registry for this component
    probably at HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;SubcomponentId=1 or 0.
    if the component value is 0, then ocmanage will figure your component is off.  if it's 1 then it's on.  however if it's not there, then ocmanage will use whatever
    the component has specified for for it's Modes= line in the .inf file.

    During an upgrade installation, well, since older installations of inetmgr maybe located at a different registry key than at:
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr=1 or 0.
    we have to let ocmanage know, what the original state is by manually returning on/off/default.

    Okay so what's the deal here?  Why do we even need to use default?  That's because something in ocmanage isn't working quite right and AndrewR doesn't want to destabilize
    setup by making such a drastic this late in win2000 ship cycle.  Here is the story.  If iis_inetmgr returns on during this call -- kool, everything is fine and no problems.
    however if i find that iis_inetmgr was not previously installed, then naturally i would want to return "off", but in fact this is wrong and will hose other things.  how you say?
    well because if i return "off" here, that means other components which need iis_inetmgr will not be able to turn it "on" thru needs (since the ocmanage has a screwy bug with this).
    But if i return here "SubcompUseOcManagerDefault", then the other components will be able to turn it on iff they need it.  the catch here is that -- ocmanage will use SubcompUseOcManagerDefault
    which means that it will lookup in the registry:
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr=1 or 0.
    and determine for itself if it should be on or off, however on the upgrade iis_inetmgr won't be there so it will want to default to the "Modes=" line.  however if iis is installed by default -- as 
    specified in the modes= lines -- then iis_inetmgr would be turned on wrongly!

    How to work around this problem?  Well, if the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr=1 or 0
    key was there then ocmanage wouldn't have to consult the Modes= line.  so the workaround was for AndrewR, on an upgrade case to crate the
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr key if it wasn't already there.

    OCSELSTATETYPE_CURRENT
    -----------------------
    on a fresh just returns SubcompUseOcManagerDefault.  in this case ocmanage should open the .inf file and read my Modes= line to determine if this component should be on or off.
    on a maintenance mode add\remove (there is no removeall or reinstall in win2000 add\remove ocmanage) just returns SubcompUseOcManagerDefault.  in which ocmanage will just read the registry again.
    on upgrade the code will return either on or usedefault.  we don't ever want to return off here because that would prevent other components which need us from turing us on.

--*/
{
    int nReturn = SubcompUseOcManagerDefault;
    TCHAR szTempStringInstallMode[40];
    _tcscpy(szTempStringInstallMode, _T("NONE"));
    BOOL  bIsInstalled;

    if (!SubcomponentId)
        {goto OC_QUERY_STATE_Func_Exit;}

    switch (g_pTheApp->m_eInstallMode)
    {
        case IM_FRESH:
            _tcscpy(szTempStringInstallMode, _T("IM_FRESH"));
            break;
        case IM_MAINTENANCE:
            _tcscpy(szTempStringInstallMode, _T("IM_MAINTENANCE"));
            break;
        case IM_UPGRADE:
            _tcscpy(szTempStringInstallMode, _T("IM_UPGRADE"));
            break;
    }
    
    if (Param1 == OCSELSTATETYPE_ORIGINAL)
    {
        if ( SubcomponentId )
        {
          if ( _tcscmp(SubcomponentId, COMPONENTS_SAKIT_WEB ) == 0 ) 
          {
            SAKit Kit;
          
            nReturn = Kit.IsInstalled_Web() ? SubcompOn : SubcompOff ;
          }

          // Check to see if we already know if it is installed
          if ( g_pComponents->IsInstalled( SubcomponentId, &bIsInstalled ) )
          {
            nReturn = bIsInstalled ? SubcompOn : SubcompOff;
          }

          if ( _tcscmp(SubcomponentId, STRING_iis_www_vdir_scripts ) == 0 ) 
          {
            // If they are quering about the scripts vdir, lets check the metabase to 
            // see if it is really installed, since they could of deleted it by hand.
            CMDKey    cmdKey;
            CMDValue  cmdValue;

            if ( SUCCEEDED( cmdKey.OpenNode( METABASEPATH_DEFAULTSITE, TRUE ) ) )
            {
              nReturn = cmdKey.GetData ( cmdValue, MD_KEY_TYPE, METABASEPATH_VDIRSCRIPTS ) ? SubcompOn : SubcompOff;
            }
          }
        }

        if ( nReturn == SubcompUseOcManagerDefault )
        {
          switch (g_pTheApp->m_eInstallMode)
          {
              case IM_FRESH:
                  nReturn = SubcompUseOcManagerDefault;
                  break;
              case IM_MAINTENANCE:
                  nReturn = SubcompUseOcManagerDefault;
                  break;
              case IM_UPGRADE:
                  nReturn = GetStateFromUpgRegLines(SubcomponentId);
                  if (SubcompOff == nReturn)
                  {
                      if (g_pTheApp->m_eUpgradeType != UT_NONE)
                      {
                          // Dont' return back SubCompOff because ocmanage won't be able to turn it on from they're screwy needs logic.
                          iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_ORIGINAL. %s. Return=SubcompUseOcManagerDefault (But really it was SubCompOff)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
                          nReturn = SubcompUseOcManagerDefault;
                      }
                  }
                  break;
              default:
                  break;
          }
        }
        goto OC_QUERY_STATE_Func_Exit;
    } // OCSELSTATETYPE_ORIGINAL


    if (Param1 == OCSELSTATETYPE_CURRENT)
    {
        // This should overide everything...
        if (g_pTheApp->m_bPleaseDoNotInstallByDefault == TRUE)
        {
            _tcscpy(szTempStringInstallMode, _T("IM_NO_IIS_TO_UPGRADE"));
            // change for AndrewR to make sure that during an upgrade, our component is set to default (which will be "off" by default since the modes= line will be set [if not there] at the beginning  of guimode setup)
            nReturn = SubcompUseOcManagerDefault;
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. OCSELSTATETYPE_CURRENT.m_bPleaseDoNotInstallByDefault=TRUE,so setting to SubcompUseOcManagerDefault by default.\n"), ComponentId, SubcomponentId));
            goto OC_QUERY_STATE_Func_Exit;
        }

        if (g_pTheApp->m_eInstallMode == IM_FRESH) 
        {
            nReturn = SubcompUseOcManagerDefault;
            goto OC_QUERY_STATE_Func_Exit;
        }

        if (g_pTheApp->m_eInstallMode == IM_MAINTENANCE) 
        {
            int nOriginal = (gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL)) ? SubcompOn : SubcompOff;
            switch (g_pTheApp->m_dwSetupMode)
            {
                case SETUPMODE_ADDREMOVE:
                    nReturn = SubcompUseOcManagerDefault;
                    break;
                case SETUPMODE_REINSTALL:
                    nReturn = nOriginal;
                    break;
                case SETUPMODE_REMOVEALL:
                    nReturn = SubcompOff;
                    break;
            }

            goto OC_QUERY_STATE_Func_Exit;
        }

        if (g_pTheApp->m_eInstallMode == IM_UPGRADE) 
        {
            int nOriginal = (gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL)) ? SubcompOn : SubcompOff;
            switch (g_pTheApp->m_dwSetupMode)
            {
                case SETUPMODE_UPGRADEONLY:
                    nReturn = nOriginal;
                    break;
                case SETUPMODE_ADDEXTRACOMPS:
                    nReturn = nOriginal;
                    break;
            }

            // ocmanager work around.
            // check the ocmanage setup key to see if this entry
            // exists -- in an upgrade ocmanage is assuming that it does exist
            // when in fact -- it may not (since they ocmanage key could have been introduced in this new OS version
            // if the key is in the registry then set this to subcompuseocmanagedefault, otherwise, set it to off
            //if (TRUE == DoesOCManagerKeyExist(SubcomponentId))
            {
                if (SubcompOff == nReturn)
                {
                    nReturn = SubcompUseOcManagerDefault;
                    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=SubcompUseOcManagerDefault (But really it was SubCompOff)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
                }
            }
            /*
            else
            {
                // however if the key does not exist
                // we want to set this to off (since ocmanage will take the default from the modes line -- which is probably on)
                // however if this component is needed by another component, then this component won't be able to be turned on
                // since it was set to off.

                // so before we go and set this component to be off, check to see if it has any needs dependencies (like it's needed by someone else)
                // if it's needed by someone else then we set it to be SubcompUseOcManagerDefault
                if (TRUE == IsThisSubCompNeededByOthers(SubcomponentId))
                {
                    if (SubcompOff == nReturn)
                    {
                        nReturn = SubcompUseOcManagerDefault;
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=SubcompUseOcManagerDefault (But really it was SubCompOff)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
                    }

                }
            }
            */

            //
            // if we are running on Whistler personal, then
            // return back OFF! -- so that we will remove ourselves!
            //
            if (TRUE == IsWhistlerPersonal())
            {
                nReturn = SubcompOff;
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=SubCompOff (always on personal)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
            }
        }
        goto OC_QUERY_STATE_Func_Exit;
    } // OCSELSTATETYPE_CURRENT

    if (Param1 == OCSELSTATETYPE_FINAL)
    {
        nReturn = SubcompUseOcManagerDefault;
	    if (!g_iOC_COMPLETE_INSTALLATION_Called)
	    {
            // user could have cancelled setup
            // so only do this in guimode fresh or upgrade scenario.
            if (g_pTheApp->m_fNTGuiMode)
            {
                nReturn = SubcompOff;
            }
	    }
        goto OC_QUERY_STATE_Func_Exit;
    } // OCSELSTATETYPE_FINAL

    
OC_QUERY_STATE_Func_Exit:
	TCHAR szTempStringMode[40];
    if (nReturn == SubcompOn) 
		{_tcscpy(szTempStringMode, _T("SubcompOn"));}
    if (nReturn == SubcompOff) 
		{_tcscpy(szTempStringMode, _T("SubcompOff"));}
    if (nReturn == SubcompUseOcManagerDefault)
		{_tcscpy(szTempStringMode, _T("SubcompUseOcManagerDefault"));}

    if (Param1 == OCSELSTATETYPE_ORIGINAL)
		{iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_ORIGINAL. %s. Return=%s\n"), ComponentId, SubcomponentId, szTempStringInstallMode, szTempStringMode));}
    if (Param1 == OCSELSTATETYPE_CURRENT)
		{iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=%s\n"), ComponentId, SubcomponentId, szTempStringInstallMode, szTempStringMode));}
    if (Param1 == OCSELSTATETYPE_FINAL)
		{iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_FINAL. %s. Return=%s\n"), ComponentId, SubcomponentId, szTempStringInstallMode, szTempStringMode));}

    return nReturn;
}


DWORD TryToSlipInFile(PFILEPATHS pFilePath)
{
    DWORD dwReturn = FALSE;
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("TryToSlipInFile:Replacing critical setup file %1!s!.\n"), pFilePath->Target));

    BOOL        bOK                       = FALSE;
    DWORD       dwSourceAttrib            = 0;
    DWORD       dwTargetAttrib            = 0;


    TCHAR tszTempFileName[MAX_PATH+1];
    TCHAR tszTempDir[MAX_PATH+1];

    _tcscpy(tszTempDir, pFilePath->Target);

    LPTSTR ptszTemp = _tcsrchr(tszTempDir, _T('\\'));
    if (ptszTemp)
    {
        *ptszTemp = _T('\0');
    }

    GetTempFileName(tszTempDir, _T("IIS"), 0, tszTempFileName);
    DeleteFile(tszTempFileName);

    //Save file attributes so they can be restored after we are done.
    dwSourceAttrib = GetFileAttributes(pFilePath->Source);
    dwTargetAttrib = GetFileAttributes(pFilePath->Target);

    //Now set the file attributes to normal to ensure file ops succeed.
    SetFileAttributes(pFilePath->Source, FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(pFilePath->Target, FILE_ATTRIBUTE_NORMAL);

    // Try to rename the filename.dll file!
    bOK = MoveFile(pFilePath->Target, tszTempFileName);
    if (bOK) {iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Rename %1!s! to %2!s!.  Successfull.\n"), pFilePath->Target, tszTempFileName));}
    else{iisDebugOutSafeParams((LOG_TYPE_WARN, _T("Rename %1!s! to %2!s!.  Failed.\n"), pFilePath->Target, tszTempFileName));}

    bOK = CopyFile(pFilePath->Source, pFilePath->Target, FALSE);
    if (bOK) {iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Copy %1!s! to %2!s!.  Successfull.\n"), pFilePath->Source, pFilePath->Target));}
    else{iisDebugOutSafeParams((LOG_TYPE_WARN, _T("Copy %1!s! to %2!s!.  Failed, Replace on reboot.\n"), pFilePath->Source, pFilePath->Target));}
    #ifdef _CHICAGO_
        if(!DeleteFile(tszTempFileName))
        {
            TCHAR tszWinInitFile[MAX_PATH+1];
            GetWindowsDirectory(tszWinInitFile, MAX_PATH);
            AddPath(tszWinInitFile, _T("WININIT.INI"));
            WritePrivateProfileString(_T("Rename"), _T("NUL"), tszTempFileName, tszWinInitFile);
        }
    #else
        MoveFileEx(tszTempFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    #endif

    SetFileAttributes(pFilePath->Source, dwSourceAttrib);
    SetFileAttributes(pFilePath->Target, dwTargetAttrib);
    SetRebootFlag();
    dwReturn = TRUE;

    return dwReturn;
}


DWORD HandleFileBusyOurSelf(PFILEPATHS pFilePath)
{
    // ----------------------------
    // Why would we want to handle the file busy ourself?
    //
    // When setupapi/ocmanage handles it:
    // it will keep the old filename.dll and create a new randomename.tmp for the new file.
    // 
    // The result is that our files will link with the old filename.dll when it does
    // all of it's regsvr32 stuff -- this is bad and can produce very confusing results.
    //
    //
    // What We will want to do is:
    // 1. try to rename filename.dll to something else.  and copy over filename.dll
    // 2. if we can't do it then at least log it.
    // ----------------------------
    DWORD  dwRetVal = 0;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szDrive_and_Path[_MAX_DRIVE + _MAX_PATH];
    TCHAR szFilename_only[_MAX_FNAME];
    TCHAR szFilename_ext_only[_MAX_EXT];
    TCHAR szFilename_and_ext[_MAX_FNAME + _MAX_EXT];

    BOOL        bOK                       = FALSE;
    BOOL        bFileFound                = FALSE;

    //Critical Setup files
    TCHAR * szFileList[] = {
_T("admexs.dll"),
_T("admwprox.dll"),
_T("admxprox.dll"),
_T("ADROT.dll"),
_T("adsiis.dll"),
_T("adsiis51.dll"),
_T("asp.dll"),
_T("asp51.dll"),
_T("aspperf.dll"),
_T("asptxn.dll"),
_T("authfilt.dll"),
_T("axctrnm.h2"),
_T("axperf.ini"),
_T("browscap.dll"),
_T("browscap.ini"),
_T("CertMap.ocx"),
_T("certobj.dll"),
_T("CertWiz.ocx"),
_T("Cnfgprts.ocx"),
_T("coadmin.dll"),
_T("compfilt.dll"),
_T("ContRot.dll"),
_T("convlog.exe"),
_T("counters.dll"),
_T("davcdata.exe"),
_T("exstrace.dll"),
_T("fortutil.exe"),
_T("ftpctrs.h2"),
_T("ftpctrs.ini"),
_T("ftpctrs2.dll"),
_T("ftpmib.dll"),
_T("ftpsapi2.dll"),
_T("ftpsvc2.dll"),
_T("gzip.dll"),
_T("httpext.dll"),
_T("httpmb51.dll"),
_T("httpmib.dll"),
_T("httpod51.dll"),
_T("httpodbc.dll"),
_T("iis.dll"),
_T("iis.msc"),
_T("iisadmin.dll"),
_T("IIsApp.vbs"),
_T("iisback.vbs"),
_T("iiscfg.dll"),
_T("iische51.dll"),
_T("iisclex4.dll"),
_T("IIsCnfg.vbs"),
_T("iiscrmap.dll"),
_T("iisext.dll"),
_T("iisext51.dll"),
_T("iisfecnv.dll"),
_T("IIsFtp.vbs"),
_T("IIsFtpdr.vbs"),
_T("iislog.dll"),
_T("iislog51.dll"),
_T("iismap.dll"),
_T("iismui.dll"),
_T("iisperf.pmc"),
_T("iisreset.exe"),
_T("iisrstap.dll"),
_T("iisrstas.exe"),
_T("iisRtl.dll"),
_T("IIsScHlp.wsc"),
_T("iissync.exe"),
_T("iisui.dll"),
_T("iisutil.dll"),
_T("iisvdir.vbs"),
_T("iisw3adm.dll"),
_T("iisweb.vbs"),
_T("iiswmi.dll"),
_T("iiswmi.mfl"),
_T("iiswmi.mof"),
_T("inetin51.exe"),
_T("inetinfo.exe"),
_T("inetmgr.dll"),
_T("inetmgr.exe"),
_T("inetsloc.dll"),
_T("infoadmn.dll"),
_T("infocomm.dll"),
_T("infoctrs.dll"),
_T("infoctrs.h2"),
_T("infoctrs.ini"),
_T("ipm.dll"),
_T("isapips.dll"),
_T("isatq.dll"),
_T("iscomlog.dll"),
_T("iwrps.dll"),
_T("logscrpt.dll"),
_T("logtemp.sql"),
_T("logui.ocx"),
_T("lonsint.dll"),
_T("md5filt.dll"),
_T("mdsync.dll"),
_T("metada51.dll"),
_T("metadata.dll"),
_T("NEXTLINK.dll"),
_T("nsepm.dll"),
_T("PageCnt.dll"),
_T("PermChk.dll"),
_T("pwsdata.dll"),
_T("rpcref.dll"),
_T("spud.sys"),
_T("ssinc.dll"),
_T("ssinc51.dll"),
_T("sspifilt.dll"),
_T("status.dll"),
_T("staxmem.dll"),
_T("svcext.dll"),
_T("tools.dll"),
_T("uihelper.dll"),
_T("w3cache.dll"),
_T("w3comlog.dll"),
_T("w3core.dll"),
_T("w3ctrlps.dll"),
_T("w3ctrs.dll"),
_T("w3ctrs.h2"),
_T("w3ctrs.ini"),
_T("w3ctrs51.dll"),
_T("w3ctrs51.h2"),
_T("w3ctrs51.ini"),
_T("w3dt.dll"),
_T("w3ext.dll"),
_T("w3isapi.dll"),
_T("w3svapi.dll"),
_T("w3svc.dll"),
_T("w3tp.dll"),
_T("w3wp.exe"),
_T("wam.dll"),
_T("wam51.dll"),
_T("wamps.dll"),
_T("wamps51.dll"),
_T("wamreg.dll"),
_T("wamreg51.dll"),
_T("wamregps.dll"),
_T("clusiis4.dll"),
_T("iis.msc"),
_T("iissuba.dll"),
_T("regtrace.exe"),
NULL
    };

    // make sure we didn't get some bogus pointers
    if(pFilePath->Target == NULL || pFilePath->Source == NULL) return dwRetVal;

    // Check to make sure the file exists!
    if(!IsFileExist(pFilePath->Source)) return dwRetVal;

    _tsplitpath( pFilePath->Target, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);
    _tcscpy(szFilename_and_ext, szFilename_only);
    _tcscat(szFilename_and_ext, szFilename_ext_only);
    _tcscpy(szDrive_and_Path, szDrive_only);
    _tcscat(szDrive_and_Path, szPath_only);

    //
    // if this is a removal, then forget it, if it's locked!
    //
    if((g_pTheApp->m_eInstallMode == IM_MAINTENANCE) && (g_pTheApp->m_dwSetupMode == SETUPMODE_REMOVEALL))
    {
        return dwRetVal;
    }

    CString csInetsrvPath = g_pTheApp->m_csPathInetsrv;
    // add extra '\' chracter
    csInetsrvPath += _T('\\');

    BOOL bAbleToCopyFileAfterStopingService = FALSE;

    // Check if it's anything in the inetsrv directory.
    if (_tcsicmp(csInetsrvPath, szFilename_and_ext) == 0) {bFileFound = TRUE;}

    if (_tcsicmp(csInetsrvPath, szDrive_and_Path) == 0) 
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Check %1!s! against filename=%2!s!.Match!\n"),csInetsrvPath,szDrive_and_Path));
        bFileFound = TRUE;
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Check %1!s! against filename=%2!s!.no match.\n"),csInetsrvPath,szDrive_and_Path));
    }
    
    // loop thru our list of file which
    // we care about (since this function will get called for every single
    // ocmanage component <-- not just iiS.
    if (bFileFound != TRUE)
    {
        for(int i = 0; !bFileFound && szFileList[i]; i++)
            {if(szFilename_and_ext && _tcsicmp(szFileList[i], szFilename_and_ext) == 0) bFileFound = TRUE;}
    }

    // files on nt5 in the cab are stoed as iis_filename.
    // check to see if this file starts with iis_
    // if it does then it's a file that we care about..
    if (bFileFound != TRUE)
    {
    }

    // ah, do it for everyone.
    // bFileFound = TRUE;

    // Do we really need to replace this file???
    // If the filesize is the same, then lets just save it for reboot!
    if (_tcsicmp(_T("iissuba.dll"), szFilename_and_ext) == 0)
    {
        if (bFileFound)
        {
            DWORD dwSize1 = ReturnFileSize(pFilePath->Target);
            DWORD dwSize2 = ReturnFileSize(pFilePath->Source);
            if (dwSize1 == 0xFFFFFFFF || dwSize1 == 0xFFFFFFFF)
            {
                // unable to retrieve the size of one of those files!
            }
            else
            {
                // check if dwSize1 and dwSize2 are the same.
                if (dwSize1 == dwSize2)
                {
                    // They are the same, so we don't have to replace it till reboot! yah!
                    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Files %1!s! and %2!s! are the same size, not replacing..\n"),pFilePath->Target, pFilePath->Source));
                    goto HandleFileBusyOurSelf_Exit;
                }
            }
        }
    }
  
    // if this is one of the files that we care about, then
    // let's try to see who is locking it and try to stop that service or kill the process
    // and then try to move the file over!
    bAbleToCopyFileAfterStopingService = FALSE;
    if(bFileFound)
    {
        TCHAR szReturnedServiceName[MAX_PATH];

        // display which process has it locked, so we can fix it in the future.
        CStringList strList;
        LogProcessesUsingThisModule(pFilePath->Target, strList);
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csExeName;
            int nLen = 0;

            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csExeName = strList.GetAt(pos);
                nLen += csExeName.GetLength() + 1;

                if (TRUE == InetIsThisExeAService(csExeName, szReturnedServiceName))
                {
                    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  Let's stop that service.\n"),csExeName,szReturnedServiceName, pFilePath->Target));

                    /*
                    // Check if it is the netlogon service, We no don't want to stop this service for sure!!!
                    if (_tcsicmp(szReturnedServiceName, _T("NetLogon")) == 0)
                    {
                        // no we do not want to stop this service!!!
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, pFilePath->Target));
                        bAbleToCopyFileAfterStopingService = FALSE;
                        break;
                    }

                    if (_tcsicmp(szReturnedServiceName, _T("WinLogon")) == 0)
                    {
                        // no we do not want to stop this service!!!
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, pFilePath->Target));
                        bAbleToCopyFileAfterStopingService = FALSE;
                        break;
                    }
                    */

                    // check list of services that we definetly do not want to stop!
                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, szReturnedServiceName, TRUE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, pFilePath->Target));
                    }
                    else
                    {
                        // add this service to the list of 
                        // services we need to restart after setup is done!!
                        ServicesRestartList_Add(szReturnedServiceName);

                        // net stop it
                        InetStopService(szReturnedServiceName);

                        // if the service is stopped, then it should be okay if we kill it!
                        KillProcess_Wrap(csExeName);

                        // now try to copy over the file!
                        if (CopyFile(pFilePath->Source, pFilePath->Target, FALSE))
                        {
                            bAbleToCopyFileAfterStopingService = TRUE;
                            break;
                        }
                    }

                    // otherwise go on to the next .exe file
                }
                else
                {
                    // This .exe file is not a Service....
                    // Should we kill it???????

                    // check list of services/processes that we definetly do not want to stop!
                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, csExeName, FALSE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is locking it. This process should not be killed\n"),csExeName));
                    }
                    else
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is locking it.  Let's kill that process.\n"),csExeName));
                        if (KillProcess_Wrap(csExeName) == 0)
                        {
                            // if we were able to kill the process.
                            // then let's try to copy over the file.
                            // now try to copy over the file!
                            if (CopyFile(pFilePath->Source, pFilePath->Target, FALSE))
                            {
                                bAbleToCopyFileAfterStopingService = TRUE;
                                break;
                            }
                        }
                    }
                }
                strList.GetNext(pos);
            }
        }

    }

    // if this is one of the files that we care about then, let's do the move
    if (bAbleToCopyFileAfterStopingService == TRUE)
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("HandleFileBusyOurSelf:critical setup file %1!s!, was successfully copied over after stopping services or stopping processes which were locking it.\n"), pFilePath->Target));
    }
    else
    {
        if(bFileFound)
        {
            // make sure the services we know about are stopped.
            StopAllServicesRegardless(FALSE); 

            TryToSlipInFile(pFilePath);
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("HandleFileBusyOurSelf:%1!s! busy, but not one of our files, so ignore.\n"), pFilePath->Target));
        }
    }

HandleFileBusyOurSelf_Exit:
    return dwRetVal;
}


HRESULT GetLastSectionToBeCalled(void)
{
    DWORD dwReturn = ERROR_SUCCESS;

    // Open up the .inf file and return the last section which will get called...
    // [Optional Components]
    // iis
    // iis_common
    // iis_inetmgr
    // iis_www
    // iis_doc
    // iis_htmla
    // iis_ftp  <-------
    //
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, OCM_OptionalComponents_Section, NULL, &Context);
    if (!b)
        {
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto GetLastSectionToBeCalled_Exit;
        }

    // loop through the items in the section.
    while (b) 
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto GetLastSectionToBeCalled_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto GetLastSectionToBeCalled_Exit;
            }

        // overwrite our string
        _tcscpy(g_szLastSectionToGetCalled, szLine);

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    
GetLastSectionToBeCalled_Exit:
    return dwReturn;
}


// should create a backup of the metabase on remove all....
#define AfterRemoveAll_SaveMetabase_log _T("AfterRemoveAll_SaveMetabase")
int AfterRemoveAll_SaveMetabase(void)
{
    iisDebugOut_Start(AfterRemoveAll_SaveMetabase_log);
    int iReturn = TRUE;
    int iFileExist = FALSE;
    CString csMetabaseFile;

    csMetabaseFile = g_pTheApp->m_csPathInetsrv + _T("\\metabase.xml");

    switch (g_pTheApp->m_eInstallMode) 
    {
        case IM_MAINTENANCE:
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("%s.End.Maintenance.\n"),AfterRemoveAll_SaveMetabase_log));
                if ( g_pTheApp->m_dwSetupMode == SETUPMODE_ADDREMOVE || g_pTheApp->m_dwSetupMode == SETUPMODE_REMOVEALL)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("%s.End.Maintenance.addremoveorremoveall\n"),AfterRemoveAll_SaveMetabase_log));
                    // Check if we removed iis_core!!!
                    ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
                    if (atCORE == AT_REMOVE)
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s.End.removing Core.\n"),AfterRemoveAll_SaveMetabase_log));
                        // Back up the file!
                        if (IsFileExist(csMetabaseFile))
                        {
                            CString csBackupFile;

				            SYSTEMTIME  SystemTime;
				            GetLocalTime(&SystemTime);
				            TCHAR szDatedFileName[50];

                            csBackupFile = g_pTheApp->m_csPathInetsrv + _T("\\MetaBack");
                            CreateDirectory(csBackupFile, NULL);

				            _stprintf(szDatedFileName,_T("\\MetaBack\\Metabase.%d%d%d"),SystemTime.wYear,SystemTime.wMonth, SystemTime.wDay);

                            csBackupFile = g_pTheApp->m_csPathInetsrv + szDatedFileName;

                            // Get a new filename
                            csBackupFile = ReturnUniqueFileName(csBackupFile);
                            if (!IsFileExist(csBackupFile))
                            {
                                // backup the current metabase.bin to Metabase.bin.bak#
                                iisDebugOut((LOG_TYPE_TRACE, _T("backup metabase.bin to %s\n"), csBackupFile));
                                InetCopyFile(csMetabaseFile, csBackupFile);
                            }
                        }
                    }
                }
                break;
            }

        default:
            {break;}
    }

    iisDebugOut_End(AfterRemoveAll_SaveMetabase_log);
    return iReturn;
}


int CheckIfWeNeedToMoveMetabaseBin(void)
{
    int iReturn = TRUE;
    TCHAR szTempDir1[_MAX_PATH];
    TCHAR szTempDir2[_MAX_PATH];
    BOOL bOK = FALSE;
    DWORD dwSourceAttrib = 0;

    // check if the old inetsrv dir is different from the new inetsrv directory.
    // if it's different then we need to move all the old inetsrv files to the new directory

    // no. we just need to move the metabase.bin file.
    // all those other files should get deleted in the iis.inf file.

    if (!g_pTheApp->m_fMoveInetsrv)
        {goto CheckIfWeNeedToMoveMetabaseBin_Exit;}

    _tcscpy(szTempDir1, g_pTheApp->m_csPathOldInetsrv);
    _tcscpy(szTempDir2, g_pTheApp->m_csPathInetsrv);
    AddPath(szTempDir1, _T("Metabase.bin"));
    AddPath(szTempDir2, _T("Metabase.bin"));

    // Check if the old metabase.bin even exists first...
    if (!IsFileExist(szTempDir1))
        {goto CheckIfWeNeedToMoveMetabaseBin_Exit;}

    // Check if there is a metabase.bin already in the new place
    if (IsFileExist(szTempDir2))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("CheckIfWeNeedToMoveMetabaseBin:Cannot copy %s to %s because already exists. WARNING.\n"), szTempDir1, szTempDir2));
        goto CheckIfWeNeedToMoveMetabaseBin_Exit;
    }

    //
    // Try to move over the entire dirs...
    //
    // Try to rename the system\inetsrv to system32\inetsrv
    if (TRUE == MoveFileEx( g_pTheApp->m_csPathOldInetsrv, g_pTheApp->m_csPathInetsrv, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
    {
        goto CheckIfWeNeedToMoveMetabaseBin_Exit;
    }

    // otherwise, we were not able to move the system\inetsrv dir to system32\inetsrv....
    // let's see if we can do another type of dirmove.

    //Save file attributes so they can be restored after we are done.
    dwSourceAttrib = GetFileAttributes(szTempDir1);

    //Now set the file attributes to normal to ensure file ops succeed.
    SetFileAttributes(szTempDir1, FILE_ATTRIBUTE_NORMAL);

    bOK = CopyFile(szTempDir1, szTempDir2, FALSE);
    if (bOK) {iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("CheckIfWeNeedToMoveMetabaseBin: Copy %1!s! to %2!s!.  Successfull.\n"), szTempDir1, szTempDir2));}
    else{iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CheckIfWeNeedToMoveMetabaseBin: Copy %1!s! to %2!s!.  FAILED.  Metabase.bin will not be upgraded.\n"), szTempDir1, szTempDir2));}

    if (bOK) 
    {
        // remove the old one
        DeleteFile(szTempDir1);
        // set the file attributes back to what it was.
        SetFileAttributes(szTempDir2, dwSourceAttrib);
    }
    else
    {
        // set the file attributes back to what it was.
        SetFileAttributes(szTempDir1, dwSourceAttrib);

        // set return flag to say we failed to move over old files.
        // upgrade will not do an upgrade.
        iReturn = FALSE;
    }

CheckIfWeNeedToMoveMetabaseBin_Exit:
    return iReturn;
}   


//
// function will copy all the old c:\windows\system\inetsrv files
//
// over to c:\windows\system32\inetsrv
//
// keep a list of the files which we're copied and
// then after the files are copied, delete the files in the old location.
int MigrateAllWin95Files(void)
{
    int iReturn = TRUE;
    TCHAR szTempSysDir1[_MAX_PATH];
    TCHAR szTempSysDir2[_MAX_PATH];
    TCHAR szTempSysDir3[_MAX_PATH];

    //
    // Check if the old metabase.bin even exists first...
    //
    GimmieOriginalWin95MetabaseBin(szTempSysDir1);

    GetSystemDirectory( szTempSysDir2, _MAX_PATH);
    AddPath(szTempSysDir2, _T("inetsrv\\Metabase.bin"));
    if (!IsFileExist(szTempSysDir1))
    {
        // Check if there is one in the new location...
        if (!IsFileExist(szTempSysDir2))
        {
            // set return flag to say we failed to move over old files.
            // upgrade will not do an upgrade.
            iReturn = FALSE;
            goto MigrateAllWin95Files_Exit;
        }
        else
        {
            iReturn = TRUE;
            goto MigrateAllWin95Files_Exit;
        }
    }

    //
    // Try to move over the entire dirs...
    //
    // cut of the filename and just get the path
    ReturnFilePathOnly(szTempSysDir1,szTempSysDir3);

    GetSystemDirectory( szTempSysDir2, _MAX_PATH);
    AddPath(szTempSysDir2, _T("inetsrv"));
    // Try to rename the system\inetsrv to system32\inetsrv
    RemoveDirectory( szTempSysDir2 );   // Delete the destination directory first, so the move will work.
    if (TRUE == MoveFileEx( szTempSysDir3, szTempSysDir2, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
        {goto MigrateAllWin95Files_Exit;}
    
    // otherwise, we were not able to move the system\inetsrv dir to system32\inetsrv....
    // let's see if we can do another type of dirmove.

    // looks like all the other types of copies failed...
    // let's just try to move the metabase.bin file.
    GetWindowsDirectory( szTempSysDir1, _MAX_PATH);
    AddPath(szTempSysDir1, _T("System\\inetsrv\\Metabase.bin"));

    GetSystemDirectory( szTempSysDir2, _MAX_PATH);
    AddPath(szTempSysDir2, _T("inetsrv\\Metabase.bin"));

    // then let's copy it over, if we don't already have one in system32\inetsrv
    if (IsFileExist(szTempSysDir2))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Cannot copy %s to %s because already exists. WARNING.\n"), szTempSysDir1, szTempSysDir2));
    }
    else
    {
        BOOL        bOK                       = FALSE;
        DWORD       dwSourceAttrib            = 0;

        //Save file attributes so they can be restored after we are done.
        dwSourceAttrib = GetFileAttributes(szTempSysDir1);

        //Now set the file attributes to normal to ensure file ops succeed.
        SetFileAttributes(szTempSysDir1, FILE_ATTRIBUTE_NORMAL);

        bOK = CopyFile(szTempSysDir1, szTempSysDir2, FALSE);
        if (bOK) {iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Copy %1!s! to %2!s!.  Successfull.\n"), szTempSysDir1, szTempSysDir2));}
        else{iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("Copy %1!s! to %2!s!.  FAILED.  Metabase.bin will not be upgraded.\n"), szTempSysDir1, szTempSysDir2));}

        if (bOK) 
        {
            // remove the old one
            DeleteFile(szTempSysDir1);
            // set the file attributes back to what it was.
            SetFileAttributes(szTempSysDir2, dwSourceAttrib);
        }
        else
        {
            // set the file attributes back to what it was.
            SetFileAttributes(szTempSysDir1, dwSourceAttrib);

            // set return flag to say we failed to move over old files.
            // upgrade will not do an upgrade.
            iReturn = FALSE;
        }

    }

MigrateAllWin95Files_Exit:
    return iReturn;
}


int GimmieOriginalWin95MetabaseBin(TCHAR * szReturnedFilePath)
{
    int iReturn = FALSE;
    INFCONTEXT Context;
    int iFindSection = FALSE;
    TCHAR szWin95MetabaseFile[_MAX_PATH] = _T("");

    iFindSection = SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("InternetServer"), _T("Win95MigrateDllMetabaseOrg"), &Context);
    if (iFindSection) 
    {
        SetupGetStringField(&Context, 1, szWin95MetabaseFile, _MAX_PATH, NULL);
        iisDebugOut((LOG_TYPE_TRACE, _T("[InternetServer].Win95MigrateDllMetabaseOrg=%s.\n"), szWin95MetabaseFile));
        // if there is an entry, check if the file exists...
        if (IsFileExist(szWin95MetabaseFile))
        {
            _tcscpy(szReturnedFilePath, szWin95MetabaseFile);
            iReturn = TRUE;
        }
    }

    if (FALSE == iReturn)
    {
        // we were not able to get the metabase.dll from the answer file.
        // assume that it's in %windir%\system\inetsrv\metabase.bin
        TSTR_PATH strTempSysDir1;
        // Check if the old metabase.bin even exists first...
        if ( strTempSysDir1.RetrieveWindowsDir() &&
             strTempSysDir1.PathAppend( _T("System\\inetsrv\\Metabase.bin") ) )
        {
          _tcscpy(szReturnedFilePath, strTempSysDir1.QueryStr() );
          if (IsFileExist( strTempSysDir1.QueryStr() ))
          {
              iReturn = TRUE;
          }
          else
          {
              iReturn = FALSE;
          }
        }
    }
    return iReturn;
}


int HandleWin95MigrateDll(void)
{
    int iReturn = TRUE;
    int iTempFlag = 0;
    int iFindSection = FALSE;
    TCHAR szMigrateFileName[_MAX_PATH] = _T("");
    INFCONTEXT Context;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Win95Upgrate:"));

    if (g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE || g_pTheApp->m_hUnattendFile == NULL)
    {
        goto HandleWin95MigrateDll_Exit;
    }

    if (g_pTheApp->m_csUnattendFile)
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("AnswerFile=%1!s!.\n"), g_pTheApp->m_csUnattendFile));
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("AnswerFile=(not found).exiting.\n")));
        goto HandleWin95MigrateDll_Exit;
    }

    // Look for our entry
    //iisDebugOut((LOG_TYPE_TRACE, _T("HandleWin95MigrateDll:looking for entry [InternetServer]:Win95MigrateDll.\n")));
    iFindSection = SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("InternetServer"), _T("Win95MigrateDll"), &Context);
    if (iFindSection) 
    {
        SetupGetStringField(&Context, 1, szMigrateFileName, _MAX_PATH, NULL);
        iisDebugOut((LOG_TYPE_TRACE, _T("[InternetServer].Win95MigrateDll=%s.\n"), szMigrateFileName));
        // if there is an entry
        // check if the file exists...
        if (!IsFileExist(szMigrateFileName))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("[InternetServer].Win95MigrateDll=%s. Does not exist!!!!! FAILURE.\n"), szMigrateFileName));
            iReturn = FALSE;
            goto HandleWin95MigrateDll_Exit;
        }

        // okay, the file exists.
        // lets pass it off to setupapi.
        //iisDebugOut((LOG_TYPE_TRACE, _T("%s\n"), szMigrateFileName));
        iTempFlag = InstallInfSection(INVALID_HANDLE_VALUE,szMigrateFileName,_T("DefaultInstall"));
        if (iTempFlag != TRUE)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED to install DefaultInstall Section.\n"), szMigrateFileName));
            goto HandleWin95MigrateDll_Exit;
        }

        // During the win95 side of migrate.dll
        // the metabase.bin file gets a bunch of stuff removed from it.
        // then that metabase.bin file gets renamed to another file.
        // then the original metabase.bin is put back -- just in case the user cancelled upgrading to win95 (to ensure that they're win95/98 pws still works the metabase.bin has to be kool)
        // so what we need to do here is:
        // 1.save the old metabase.bin to something in case we mess things up.
        // 2.find out what the newlyhacked metabase.bin file is called by looking for the entry in the answerfile
        // 3.rename whatever that filename is to metabase.bin
        GetTheRightWin95MetabaseFile();
        
        // set the flag to say that we did call win95 migration dll
        if (TRUE == MigrateAllWin95Files())
        {
            // only set this flag if
            // we can copy over the existing metabase.bin file!
            g_pTheApp->m_bWin95Migration = TRUE;
        }

    iReturn = iTempFlag;
    }

HandleWin95MigrateDll_Exit:
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return iReturn;
}


int GetTheRightWin95MetabaseFile(void)
{
    int iReturn = TRUE;
    int iFindSection = FALSE;
    INFCONTEXT Context;
    TCHAR szOriginalMetabaseBin[_MAX_PATH];

    // Get the full path to the original metabase.bin file
    GimmieOriginalWin95MetabaseBin(szOriginalMetabaseBin);

    iFindSection = FALSE;
    iFindSection = SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("InternetServer"), _T("Win95MigrateDllMetabaseNew"), &Context);
    if (iFindSection) 
    {
        TCHAR szWin95FixedMetabaseFile[_MAX_PATH] = _T("");
        SetupGetStringField(&Context, 1, szWin95FixedMetabaseFile, _MAX_PATH, NULL);
        iisDebugOut((LOG_TYPE_TRACE, _T("[InternetServer].Win95MigrateDllMetabaseNew=%s.\n"), szWin95FixedMetabaseFile));
        // if there is an entry, check if the file exists...
        if (IsFileExist(szWin95FixedMetabaseFile))
        {

            // delete the original metabase.bin file
            if (DeleteFile(szOriginalMetabaseBin))
            {
                // copy in the fixed one.
                if (0 == CopyFile(szWin95FixedMetabaseFile, szOriginalMetabaseBin, FALSE))
                {
                    // unable to copy it, try to move it
                    // Try to rename the system\inetsrv to system32\inetsrv
                    if (FALSE == MoveFileEx( szWin95FixedMetabaseFile, szOriginalMetabaseBin, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
                        {
                        // do nothing i guess were hosed.
                        // setup won't upgrade and will only do a clean install
                        iReturn = FALSE;
                        }
                }
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("[InternetServer].Win95MigrateDllMetabaseNew=%s. Does not exist!!!!! FAILURE.\n"), szWin95FixedMetabaseFile));
        }
    }

    return iReturn;
}


DWORD RemoveComponent(IN LPCTSTR SubcomponentId, int iThePartToDo)
{
    TSTR strTheSectionToDo;

    int iWeAreGoingToRemoveSomething = FALSE;
    DWORD dwReturn = NO_ERROR;
    ACTION_TYPE atTheComponent;

    // Make sure there are not MyMessageBox popups!
    //int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
    // g_pTheApp->m_bAllowMessageBoxPopups = FALSE;
	if (g_pTheApp->m_eInstallMode == IM_UPGRADE) goto RemoveComponent_Exit;

    // Check if we are going to remove something...
    atTheComponent = GetSubcompAction(SubcomponentId, FALSE);
    if (_tcsicmp(SubcomponentId, STRING_iis_core) == 0) 
    {
        atTheComponent = GetIISCoreAction(TRUE);;
    }
    if (atTheComponent == AT_REMOVE)
        {iWeAreGoingToRemoveSomething = TRUE;}

    if (iThePartToDo == 1)
    {
        // Check if we are supposed to do nothing.
        if (atTheComponent == AT_DO_NOTHING)
        {
            // ok, if we're supposed to do nothing
            // and the files are not supposed to be there
            // then just make sure they are not there by removing them!!!!!
            BOOL CurrentState,OriginalState;
            OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
            CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

            // if we think that the original state is uninstalled
            // and the current state is not installed, then make sure that the files do not exist by
            // removing the files!
            if (_tcsicmp(SubcomponentId, STRING_iis_core) == 0)
            {
                // Since iis_core is not real, check iis_common
                if ( gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,
                                                         STRING_iis_common,OCSELSTATETYPE_CURRENT) == 1 )
                {
                  iWeAreGoingToRemoveSomething = FALSE;
                }
                else
                {
                  iWeAreGoingToRemoveSomething = TRUE;
                }
            }
            else
            {
                if (OriginalState == 0 && CurrentState == 0)
                {
                    // but don't do it for the iis_doc files because there are too many files in that one.
                    if ((_tcsicmp(SubcomponentId, STRING_iis_common) == 0) ||
                        (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) ||
                        (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0))
                    {
                        iWeAreGoingToRemoveSomething = TRUE;
                    }
                }
            }
        }
    }

    if (iThePartToDo == 2)
    {
        // Check if we are supposed to do nothing.
        if (atTheComponent == AT_DO_NOTHING)
        {
            if (_tcsicmp(SubcomponentId, _T("iis")) == 0)
            {
                BOOL CurrentState,OriginalState;
                OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
                CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

                // if we think that the original state is uninstalled
                // and the current state is not installed, then make sure that the files do not exist by
                // removing the files!
                if (OriginalState == 0 && CurrentState == 0)
                {
                    // but don't do it for the iis_doc files because there are too many files in that one.
                    // Special: if this is removing the iis section [all of iis] then, make sure to 
                    // clean everything up.
                    iWeAreGoingToRemoveSomething = TRUE;
                }
                else
                {
                    // check if every component is off
                    if (FALSE == AtLeastOneComponentIsTurnedOn(g_pTheApp->m_hInfHandle))
                    {
                        iWeAreGoingToRemoveSomething = TRUE;
                    }
                }
            }
        }
    }

    // Do the actual removing
    if (iWeAreGoingToRemoveSomething)
    {
        if (iThePartToDo == 1)
        {
            //
            // Queue the deletion of the files
            //
            ProgressBarTextStack_Set(IDS_IIS_ALL_REMOVE);

            if ( strTheSectionToDo.Copy( _T("OC_QUEUE_FILE_OPS_remove.") ) && 
                 strTheSectionToDo.Append( SubcomponentId )
               )
            {
              if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSectionToDo ))
              {
                ProcessSection(g_pTheApp->m_hInfHandle, strTheSectionToDo.QueryStr() );
                dwReturn = g_GlobalFileQueueHandle_ReturnError ? NO_ERROR : GetLastError();
              }
              else
              {
                dwReturn = NO_ERROR;
              }
            }
            else
            {
              dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }

            ProgressBarTextStack_Pop();
        }
        else
        {
            ProgressBarTextStack_Set(IDS_IIS_ALL_REMOVE);

            _stprintf(g_MyLogFile.m_szLogPreLineInfo2,_T("Unreg %s:"),SubcomponentId);

            if ( strTheSectionToDo.Copy( _T("OC_ABOUT_TO_COMMIT_QUEUE_remove.") ) &&
                 strTheSectionToDo.Append( SubcomponentId ) )
            {
              ProcessSection(g_pTheApp->m_hInfHandle, strTheSectionToDo.QueryStr() );
            }

            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
            ProgressBarTextStack_Pop();
        }
    }
   
RemoveComponent_Exit:
    // Turn popups back on.
    //g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
    return dwReturn;
}

int AtLeastOneComponentIsTurnedOn(IN HINF hInfFileHandle)
{
    int bSomeIsOn = FALSE;
    BOOL CurrentState,OriginalState;

    CStringList strList;
    TSTR    strTheSection;

    if ( strTheSection.Copy( OCM_OptionalComponents_Section ) &&
         GetSectionNameToDo(hInfFileHandle, &strTheSection ) 
       )
    {
      if ( ERROR_SUCCESS == FillStrListWithListOfSections(hInfFileHandle, strList, strTheSection.QueryStr() ) )
      {
          // loop thru the list returned back
          if (strList.IsEmpty() == FALSE)
          {
              POSITION pos;
              CString csEntry;
              pos = strList.GetHeadPosition();
              while (pos) 
              {
                  csEntry = _T("");
                  csEntry = strList.GetAt(pos);

                  // We now have the entry, send it to the function.
                  OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,csEntry,OCSELSTATETYPE_ORIGINAL);
                  CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,csEntry,OCSELSTATETYPE_CURRENT);
                  if (CurrentState == 1) {bSomeIsOn = TRUE;}

                  // Get the next one.
                  strList.GetNext(pos);
              }
          }
      }
    }
 
    return bSomeIsOn;
}


void AdvanceProgressBarTickGauge(int iTicks)
{
    // multiply the amount of ticks by our tick multiple
    iTicks = g_GlobalTickValue * iTicks;

    for(int i = 0; i < iTicks; i++)
    {
        gHelperRoutines.TickGauge(gHelperRoutines.OcManagerContext);
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("--- TickGauge ---\n")));
    }
    g_GlobalTotalTickGaugeCount=g_GlobalTotalTickGaugeCount+iTicks;

    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_common) == 0) 
        {g_GlobalTickTotal_iis_common = g_GlobalTickTotal_iis_common + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_inetmgr) == 0) 
        {g_GlobalTickTotal_iis_inetmgr = g_GlobalTickTotal_iis_inetmgr + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_www) == 0) 
        {g_GlobalTickTotal_iis_www = g_GlobalTickTotal_iis_www + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_pwmgr) == 0) 
        {g_GlobalTickTotal_iis_pwmgr = g_GlobalTickTotal_iis_pwmgr + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_doc) == 0) 
        {g_GlobalTickTotal_iis_doc = g_GlobalTickTotal_iis_doc + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_htmla) == 0) 
        {g_GlobalTickTotal_iis_htmla = g_GlobalTickTotal_iis_htmla + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0) 
        {g_GlobalTickTotal_iis_ftp = g_GlobalTickTotal_iis_ftp + g_GlobalTotalTickGaugeCount;}
}


void SumUpProgressBarTickGauge(IN LPCTSTR SubcomponentId)
{
    int iTicksYetToDo = 0;
    int iTicksSupposedToDo = 0;

    if (SubcomponentId)
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);

        // Set the Tick Total value for iis_common (which includes iis_core)
        if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0)
        {
            // Get the operations for Core instead since this is bigger.
            ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
            if (atCORE == AT_REMOVE) 
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atCORE == AT_DO_NOTHING) 
                {iTicksSupposedToDo = 0;}
        }
        else
        {
            if (atComp == AT_REMOVE)
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atComp == AT_DO_NOTHING) 
                {iTicksSupposedToDo = 0;}
        }

        // 1. Take the amount that we're supposed to be finsihed with from the inf.
        // 2. take the amount that we are actually done with.
        // fill up the difference

        if (iTicksSupposedToDo > g_GlobalTotalTickGaugeCount)
        {
            int iTempVal = 0;
            if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_common;}
            if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_inetmgr;}
            if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_www;}
            if (_tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_pwmgr;}
            if (_tcsicmp(SubcomponentId, STRING_iis_doc) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_doc;}
            if (_tcsicmp(SubcomponentId, STRING_iis_htmla) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_htmla;}
            if (_tcsicmp(SubcomponentId, g_ComponentList[COMPONENT_IIS_FTP].szComponentName ) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_ftp;}
            
            //iTicksYetToDo = iTicksSupposedToDo - g_GlobalTotalTickGaugeCount;
            iTicksYetToDo = iTicksSupposedToDo - iTempVal;
            
            // divide by the tick multiple.

            // multiply the amount of ticks by our tick multiple
            if (iTicksYetToDo > 0)
            {
                iTicksYetToDo = iTicksYetToDo / g_GlobalTickValue;
            }

            AdvanceProgressBarTickGauge(iTicksYetToDo);
        }
    }

    return;
}

// GetIISCoreAction
//
// In the past, IISCore was the metabase, and it was a complicated section, 
// that based on the ftp and www services would determine if it was going
// to be installed.  Now we are making it and iis_common, exactly the same
//
ACTION_TYPE GetIISCoreAction(int iLogResult)
{
    return GetSubcompAction(STRING_iis_common, iLogResult);
}

void DisplayActionsForAllOurComponents(IN HINF hInfFileHandle)
{
    CStringList strList;
    ACTION_TYPE atTheComponent; 
    TSTR    strTheSection;

    if ( strTheSection.Copy( OCM_OptionalComponents_Section ) &&
         GetSectionNameToDo(hInfFileHandle, &strTheSection)
       )
    {
      if ( ERROR_SUCCESS == FillStrListWithListOfSections(hInfFileHandle, strList, strTheSection.QueryStr() ) )
      {
          // loop thru the list returned back
          if (strList.IsEmpty() == FALSE)
          {
              POSITION pos;
              CString csEntry;
              pos = strList.GetHeadPosition();
              while (pos) 
              {
                  csEntry = _T("");
                  csEntry = strList.GetAt(pos);

                  // We now have the entry, send it to the function.
                  atTheComponent = GetSubcompAction(csEntry, TRUE);

                  // Get the next one.
                  strList.GetNext(pos);
              }
          }
      }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\elem.h ===
#ifndef _ELEM_H_
#define _ELEM_H_

class CElem : public CObject
{
public:
    CElem();
    ~CElem();

    HKEY m_hKey;
    int m_index;
    CString m_ip;
    CString m_name;
    CString m_value;

    BOOL OpenReg(LPCTSTR szSubKey);
    void CloseReg();
    BOOL GetNext();
    void ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap);
    void Add(CMapStringToOb *pMap);
};

#endif // _ELEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\dllmain.h ===
#include "stdafx.h"

// Function Prototypes
DWORD_PTR OC_WIZARD_CREATED_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_FILE_BUSY_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
#ifdef _WIN64
   DWORD_PTR OC_QUERY_IMAGE_EX_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
#endif
DWORD_PTR OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);

void  GetShortDesc(LPCTSTR SubcomponentId, LPTSTR szShortDesc);
void  StartInstalledServices(void);
void  SetIISSetupMode(DWORD dwSetupMode);
void  ParseCmdLine(void);
void  HandleMetabaseBeforeSetupStarts();
DWORD HandleFileBusyOurSelf(PFILEPATHS pFilePath);
DWORD RemoveComponent(IN LPCTSTR SubcomponentId, int iThePartToDo);
int   AtLeastOneComponentIsTurnedOn(IN HINF hInfFileHandle);

void TestClusterRead(LPWSTR pszClusterName);
void TestAfterInitApp(void);
void SumUpProgressBarTickGauge(IN LPCTSTR SubcomponentId);

void WINAPI IIS5Log(int iLogType, TCHAR *pszfmt);
void WINAPI IIS5LogParmString(int iLogType, TCHAR *pszfmt, TCHAR *pszString);
void WINAPI IIS5LogParmDword(int iLogType, TCHAR *pszfmt, DWORD dwErrorCode);

int MigrateAllWin95Files(void);
int HandleWin95MigrateDll(void);
int GimmieOriginalWin95MetabaseBin(TCHAR * szReturnedFilePath);
int GetTheRightWin95MetabaseFile(void);

ACTION_TYPE GetIISCoreAction(int iLogResult);
ACTION_TYPE GetSubcompAction(LPCTSTR SubcomponentId, int iLogResult);
STATUS_TYPE GetSubcompInitStatus(LPCTSTR SubcomponentId);
void StopAllServicesThatAreRelevant(int iShowErrorsFlag);
void DisplayActionsForAllOurComponents(IN HINF hInfFileHandle);
int CheckIfWeNeedToMoveMetabaseBin(void);
BOOL ToBeInstalled(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
BOOL CheckandShowFatWarning( LPBOOL pbQuit );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\elem.cpp ===
#include "stdafx.h"

#include "elem.h"

CElem::CElem()
{
    m_hKey = NULL;
    m_index = 0;
    m_ip = _T("");
    m_name = _T("");
    m_value = _T("");
}

CElem::~CElem()
{
    if (m_hKey) 
        RegCloseKey(m_hKey);
}

BOOL CElem::OpenReg(LPCTSTR szSubKey)
{
    BOOL fReturn = FALSE;
    LONG err = ERROR_SUCCESS;
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &m_hKey);
    if (ERROR_SUCCESS  == err)
    {
        fReturn = TRUE;
    }
    else
    {
        m_hKey = NULL;
        if ( err != ERROR_FILE_NOT_FOUND ) 
            {iisDebugOut((LOG_TYPE_ERROR, _T("CElem::OpenReg(): %s.  FAILED.  code=0x%x\n"), szSubKey, err));}
    }

    return (fReturn);
}

void CElem::CloseReg()
{
    if (m_hKey) 
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}

BOOL CElem::GetNext()
{
  BOOL fReturn = FALSE;
  LONG err = ERROR_SUCCESS;
  TCHAR szBufferL[_MAX_PATH], szBufferR[_MAX_PATH];
  DWORD dwBufferL = _MAX_PATH, dwBufferR = _MAX_PATH;

  err = RegEnumValue(m_hKey, m_index, szBufferL, &dwBufferL, NULL, NULL, (LPBYTE)szBufferR, &dwBufferR);
  if (err == ERROR_SUCCESS) 
  {
    LPTSTR token;
    m_index++;
    m_value = szBufferR;

    token = _tcstok(szBufferL, _T(","));
    if (token) 
    {
      m_name = token;
      token = _tcstok(NULL, _T(","));
      if (token) {
          m_ip = token;
      } else {
          m_ip = _T("null");
      }
      fReturn = TRUE;
    }

    m_name.MakeLower();
    m_value.MakeLower();

    //
    // m_name  looks like = /scripts
    // m_value looks like = c:\inetpub\scripts,,4
    //
    // m_value could look like anything
    // c:
    // c:\stuff
    // c:\whatevers\
    // who knows what they put in there.
    // we need to make sure it look like a fully qualified path though.
    //

    // Get the first Value before the comma
    int iWhere = 0;
    iWhere = m_value.Find(_T(','));
    if (-1 != iWhere)
    {
      CString BeforeComma;
      CString AfterComma;

      // there is a ',' in the string
      BeforeComma = m_value.Left(iWhere);

      // Get the after comma vlues
      AfterComma = m_value.Right( m_value.GetLength() - iWhere);

      TCHAR thefilename[_MAX_PATH];
      TCHAR thepath[_MAX_PATH];
      TCHAR * pmypath;

      if ( BeforeComma.GetLength() >= ( sizeof(thefilename) / sizeof( TCHAR ) ) )
      {
        fReturn = FALSE;
      }
      else
      {
        _tcscpy(thefilename, BeforeComma.GetBuffer(0) );

        // make sure the left side is a valid directory name!
        if (0 != GetFullPathName(thefilename, _MAX_PATH, thepath, &pmypath))
        {
          BeforeComma = thepath;
        }

        // reconcatenate them
        m_value = BeforeComma;
        m_value += AfterComma;
      }
    }
  }
  else
  {
    if ( err != ERROR_FILE_NOT_FOUND && err != ERROR_NO_MORE_ITEMS) 
    {
      iisDebugOut((LOG_TYPE_WARN, _T("CElem::GetNext(): FAILED.  code=0x%x\n"), err));
    }
  }

  return (fReturn);
}

void CElem::ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap)
{
    if ( OpenReg(szSubKey) ) 
    {
        while (GetNext()) 
        {
            Add(pMap);
        }
        CloseReg();
    }
}

void CElem::Add(CMapStringToOb *pMap)
{
    CObject *pObj;
    CMapStringToString *pNew;

    if (pMap->Lookup(m_ip, pObj) == TRUE) {
        pNew = (CMapStringToString*)pObj;
        pNew->SetAt(m_name, m_value);
    } else {
        pNew = new CMapStringToString;

        if ( pNew )
        {
          pNew->SetAt(m_name, m_value);
          pMap->SetAt(m_ip, (CObject*)pNew);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\filter.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        filter.cxx

   Abstract:

        Class that is used to modify filters

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       January 2002: Created

--*/

#include "stdafx.h"
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdentry.h"
#include "iiscnfg.h"
#include "filter.hxx"
#include "reg.hxx"

// AddFilter
//
// Add a filter to the metabase
//
// Parameters
//   szSite - The site to add the filter to (NULL for Global)
//   szName - The name of the filter
//   szDescription - The description of the filter
//   szPath - The path to the filter
//   bCachable - Is the filter cachable?
//
// Results:
//   TRUE - Successfully added
//   FALSE - Failure to add
BOOL 
CFilter::AddFilter(LPTSTR szSite, LPTSTR szName, LPTSTR szDescription, LPTSTR szPath, BOOL bCachable )
{
  CMDKey    cmdKey;
  TSTR      strPath;
  BOOL      bRet = TRUE;

  // Open the filter, and create the node needed
  if ( !GetFilterPathfromSite( &strPath, szSite, szName ) ||
       FAILED(cmdKey.CreateNode( METADATA_MASTER_ROOT_HANDLE , strPath.QueryStr() ) )
     )
  {
    // Either we could not create the filter node, or we couldn't open it,
    // either way, we failed
    bRet = FALSE;
  }
  
  // Try and retrieve a value in this node.  If there is another filter installed here,
  // we should not overwrite it
  if ( bRet ) 
  {
    CMDValue  PreviousPath;

    if ( cmdKey.GetData( PreviousPath, MD_FILTER_IMAGE_PATH ) &&
         !PreviousPath.IsEqual( STRING_METADATA, ( _tcslen(szPath) + 1 ) * sizeof(TCHAR) , szPath )
       )
    {
      bRet = FALSE;
    }
  }

  // Now set KeyType for new node
  if ( bRet )
  {
    bRet = SUCCEEDED( cmdKey.SetData( MD_KEY_TYPE,                  // KeyType
                                      0,                            // No Attributes
                                      IIS_MD_UT_SERVER,             // Server UserType
                                      STRING_METADATA,              // String DataType
                                      ( _tcslen(KEYTYPE_FILTER) + 1 ) * sizeof(TCHAR) ,  // Size
                                      (LPBYTE) KEYTYPE_FILTER ) );  // Value (IIsFilter)
  }

  // Now set Filter Description for the new node
  if ( bRet && szDescription )
  {
    bRet = SUCCEEDED( cmdKey.SetData( MD_FILTER_DESCRIPTION,        // KeyType
                                      0,                            // No Attributes
                                      IIS_MD_UT_SERVER,             // Server UserType
                                      STRING_METADATA,              // String DataType
                                      ( _tcslen(szDescription) + 1 ) * sizeof(TCHAR),   // Size
                                      (LPBYTE) szDescription ) );   // Value
  }

  // Now set FilterPath for new node
  if ( bRet )
  {
    bRet = SUCCEEDED( cmdKey.SetData( MD_FILTER_IMAGE_PATH,         // KeyType
                                      0,                            // No Attributes
                                      IIS_MD_UT_SERVER,             // Server UserType
                                      STRING_METADATA,              // String DataType
                                      ( _tcslen(szPath) + 1 ) * sizeof(TCHAR),          // Size
                                      (LPBYTE) szPath ) );          // Value
  }

  // Now set FilterEnableCache to false, since we don't know, this is the safe default when you don't know
  if ( bRet )
  {
    DWORD dwCachable = bCachable;

    bRet = SUCCEEDED( cmdKey.SetData( MD_FILTER_ENABLE_CACHE,       // KeyType
                                      0,                            // No Attributes
                                      IIS_MD_UT_SERVER,             // Server UserType
                                      DWORD_METADATA,               // String DataType
                                      sizeof(DWORD),                // Size
                                      (LPBYTE) &dwCachable ) );        // Value
  }

  // Close Node if we got one
  cmdKey.Close();

  if ( bRet )
  {
    bRet = AddFiltertoLoadOrder( szSite, szName, TRUE );
  }

  // If we failed to create the filter entry, lets try to clean up what we did
  if ( !bRet )
  {
    if ( GetFilterPathfromSite( &strPath, szSite ) &&
         cmdKey.OpenNode( strPath.  QueryStr() ) 
       )
    {
      cmdKey.DeleteNode( szName );
    }
  }


  return bRet;
}

// AddGlobalFilter
//
// Add a Global filter to the metabase
//
// Parameters
//   szName - The name of the filter
//   szDescription - The description of the filter
//   szPath - The path to the filter
//   bCachable - Is the filter cachable?
//
// Results:
//   TRUE - Successfully added
//   FALSE - Failure to add
BOOL 
CFilter::AddGlobalFilter(LPTSTR szName, LPTSTR szDescription, LPTSTR szPath, BOOL bCachable )
{
  return AddFilter( NULL, szName, szDescription, szPath, bCachable );
}


// AddFiltertoLoadOrder
//
// Add a filter to the LoadOrder
//
// Parameters:
//   szSite - The site to be added to (NULL for Global)
//   szFilterName - The name of the fiter, this corresponds to the location where the filter
//                  is add /w3svc/filters/xxxxxx, where xxxxx is the name of the filter
//   bAddtoEnd - Add to the end of the list.  If false, then add to the begining
BOOL 
CFilter::AddFiltertoLoadOrder(LPTSTR szSite, LPTSTR szFilterName, BOOL bAddtoEnd)
{
  CMDKey    cmdKey;
  TSTR      strPath;
  CMDValue  FilterLoadOrder;
  TSTR      strFilterLoadOrder;
  BOOL      bRet = TRUE;

  if ( !GetFilterPathfromSite( &strPath, szSite ) ||
       FAILED( cmdKey.OpenNode( strPath.QueryStr() ) )
     )
  {
    // Failure to retrieve path, or open metabase
    return FALSE;
  }
  
  // Retrieve value currently in the metabase
  if ( !cmdKey.GetData( FilterLoadOrder, MD_FILTER_LOAD_ORDER ) )
  {
    // If it can not be loaded, lets set it to empty and create a new one
    bRet = strFilterLoadOrder.Copy( _T("") );
  }
  else
  {
    bRet = strFilterLoadOrder.Copy( (LPTSTR) FilterLoadOrder.GetData() );
  }

  // Append the current filter to it
  if ( bRet )
  {
    if ( *(strFilterLoadOrder.QueryStr()) == '\0' )
    {
      bRet = strFilterLoadOrder.Append( szFilterName );
    }
    else
    {
      if ( bAddtoEnd )
      {
        if ( !strFilterLoadOrder.Append( _T(",") ) ||
             !strFilterLoadOrder.Append( szFilterName )
           )
        {
          bRet = FALSE;
        }
      }
      else
      {
        TSTR strTemp;

        if ( !strTemp.Copy(strFilterLoadOrder.QueryStr() ) ||
             !strFilterLoadOrder.Copy( szFilterName ) ||
             !strFilterLoadOrder.Append( _T(",") ) ||
             !strFilterLoadOrder.Append( strTemp.QueryStr() )
           )
        {
          bRet = FALSE;
        }
      }
    } // if ( *(strFilterLoadOrder.QueryStr()) == '\0' )
  } // if bRet

  // Copy the new list into the KeyValue
  if ( bRet )
  {
    bRet = FilterLoadOrder.SetValue( MD_FILTER_LOAD_ORDER,   // Id
                                     0,                      // Attributes
                                     IIS_MD_UT_SERVER,       // UserType
                                     STRING_METADATA,        // DataType
                                     ( strFilterLoadOrder.QueryLen() + 1 ) * sizeof(TCHAR), // Size of Data
                                     strFilterLoadOrder.QueryStr() );
  }

  if ( bRet )
  {
    bRet = cmdKey.SetData( FilterLoadOrder, MD_FILTER_LOAD_ORDER );
  }

  return bRet;
}

// function: GetFilterPathfromSite
//
// Create the correct metabase for the site that we are dealing with.  If the FilterName
// is sent in, then add that too.
//
// Parameters:
//   [out]  strPath       - The path that has been constructed
//   [in]   szSite        - The site we want it for (NULL for global)
//   [in]   szFilterName  - The name of the filter to be added to the path
//
// Return Values:
//   TRUE - Successfull in creating it
//   FALSE - Failed (memory problem)
//
BOOL
CFilter::GetFilterPathfromSite(TSTR *strPath, LPTSTR szSite, LPTSTR szFilterName )
{
  BOOL bRet = TRUE;

  ASSERT( strPath != NULL );

  if ( szSite == NULL )
  {
    // Open Global filter path
    bRet = strPath->Copy( METABASEPATH_FILTER_GLOBAL_ROOT );
  }
  else
  {
    // Open site specific filter path
    if ( !strPath->Copy( METABASEPATH_WWW_ROOT ) ||
         !strPath->Append( _T("/") ) ||
         !strPath->Append(szSite) ||
         !strPath->Append( METABASEPATH_FILTER_PATH )
       )
    {
      bRet = FALSE;
    }
  }

  if ( bRet && szFilterName ) 
  {
    if ( !strPath->Append( _T("/") ) ||
         !strPath->Append(szFilterName)
       )
    {
      bRet = FALSE;
    }
  }

  return bRet;
}

// function: MigrateRegistryFilterstoMetabase
//
// Migrate the filters from the registry into the metabase.
// This will take the comma seperated list at HKLM\Services\CCS\W3SVC\Parameters\Filter Dlls,
// and put it into the global filter list at 
//   /LM/W3SVC/Filters/FilterLoadOrder - Add it to this at the end
//   /LM/W3SVC/Filters/xxx - Create this key for filter xxx
//   /LM/W3SVC/Filters/xxx/KeyType - Set this to IIsFilters
//   /LM/W3SVC/Filters/xxx/FilterPath - Set the path for the filter
//   /LM/W3SVC/Filters/xxx/FilterEnableCache - Set this to false
//
BOOL 
CFilter::MigrateRegistryFilterstoMetabase()
{
  TSTR        strFilters;
  TSTR        strFilterName;
  CRegistry   Reg;
  LPTSTR      szCurrentFilter;
  LPTSTR      szNextFilter;
  BOOL        bRet = TRUE;

  if (  !Reg.OpenRegistry( HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_ALL_ACCESS ) ||
        !Reg.ReadValueString( REG_FILTERDLLS, &strFilters )
     )
  {
    // Success, if the value is not in the registry, we do not have to worry about it
    return TRUE;
  }

  szCurrentFilter = strFilters.QueryStr();

  while ( ( szCurrentFilter != NULL) &&
          ( *szCurrentFilter != '\0' ) )
  {
    szNextFilter = _tcschr( szCurrentFilter, REG_FILTER_DELIMITER );

    if ( szNextFilter )
    {
      // If there is another filter, then lets null terminate this
      *szNextFilter = '\0';
    }

    if ( ExtractExeNamefromPath( szCurrentFilter, &strFilterName ) )
    {
      BOOL bTemp = AddGlobalFilter( strFilterName.QueryStr(),   // FilterName
                                    NULL,                       // Description
                                    szCurrentFilter,            // Path
                                    FALSE );                    // bCachable

      if ( bRet )
      {
        bRet = bTemp;
      }
    }

    // either increment it to the ',' plus 1, or NULL
    szCurrentFilter = szNextFilter ? szNextFilter + 1 : NULL;
  }

  if ( bRet )
  {
    // If we succeeded, then remove the registry entry.  If not, we will leave it
    // around, so it can be migrated manually if necessary
    Reg.DeleteValue( REG_FILTERDLLS );
  }
  else
  {
    // Log Warning
    iisDebugOut((LOG_TYPE_WARN, _T("WARNING: Not all of the filters could be migrated from %s\\%s."),
                                REG_WWWPARAMETERS, REG_FILTERDLLS ));
  }

  return bRet;
}

// function: ExtractExeNamefromPath
//
// Takes a path to an executable, and extracts the name of the executable
// without the extenstion. ie. c:\foo\test.exe -> 'test'
// 
// Parameters:
//   szPath [in] - The Path to the executable
//   strExeName [out] - The name of the exe
BOOL 
CFilter::ExtractExeNamefromPath( LPTSTR szPath, TSTR *strExeName )
{
  LPTSTR szBeginingofName;
  LPTSTR szEndofName;
  BOOL   bRet;

  // First find the begining of the name
  szBeginingofName = _tcsrchr( szPath, '\\' );

  if ( szBeginingofName == NULL )
  {
    // If there is no '\\', then the begining of the name is the begining
    // of the path
    szBeginingofName = szPath;
  }
  else
  {
    szBeginingofName++;  // Move past the '\\'
  }

  szEndofName = _tcsrchr( szBeginingofName, '.' );

  if ( szEndofName )
  {
    // Temporarirly null terminate string
    *szEndofName = '\0';
  }

  bRet = strExeName->Copy( szBeginingofName );

  if ( szEndofName )
  {
    // Replace period from before
    *szEndofName = '.';
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\ftp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "setpass.h"
#include "www.h"

int Register_iis_ftp_handle_iusr_acct(void);
int CheckForOtherIUsersAndUseItForFTP(void);
INT Register_iis_ftp(void);
INT Unregister_iis_ftp(void);

// returns true if successfully registered ftp component.
// returns false if failed.
INT Register_iis_ftp()
{
    iisDebugOut_Start(_T("Register_iis_ftp"),LOG_TYPE_TRACE);
    int iReturn = TRUE;
    int iTempFlag = TRUE;
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"), TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_ftp_before"));
    AdvanceProgressBarTickGauge();

    // Grab the IUSR_machine name account
    // so we can save it in the metabase during FTP_Upgrade_RegToMetabase();
    Register_iis_ftp_handle_iusr_acct();
    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33003, g_pTheApp->m_csFTPAnonyName);
    AdvanceProgressBarTickGauge();

    WriteToMD_Capabilities(_T("MSFTPSVC"));
    HandleSecurityTemplates(_T("MSFTPSVC"));
    // ================
    //
    // LM/MSFTPSVC/n/
    // LM/MSFTPSVC/n/ServerBindings
    // LM/MSFTPSVC/n/SecureBindings
    // LM/MSFTPSVC/n/ServerComment
    // LM/MSFTPSVC/n/ServerSize
    // LM/MSFTPSVC/n/MD_NOT_DELETABLE
    //
    // fresh = ok.
    // reinstall = ok -- Do not re-create these things if it is a reinstall...
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff
    //
    //                 if the user does not have these virtual roots which we installed during iis4 days
    //                 then we don't need to verify that they are they.  the user removed them for some
    //                 reason, and we should honor that.
    //                 a. make sure the iishelp points to the right place though.
    // ================
    ProgressBarTextStack_Set(IDS_IIS_ALL_CONFIGURE);
    AddVRootsToMD(_T("MSFTPSVC"));

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_ftp_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_ftp_after"));

    ProgressBarTextStack_Pop();
    goto Register_iis_ftp_Exit;

Register_iis_ftp_Exit:
    iisDebugOut_End(_T("Register_iis_ftp"),LOG_TYPE_TRACE);
    return iReturn;
}


INT Unregister_iis_ftp()
{
    int iReturn = TRUE;
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_ftp_before"));
    AdvanceProgressBarTickGauge();

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_ftp_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_ftp_after"));
    AdvanceProgressBarTickGauge();
    return iReturn;
}

int Register_iis_ftp_handle_iusr_acct()
{
    int err = FALSE;
    int iReturn = TRUE;
    INT iUserWasNewlyCreated = 0;

    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"),FALSE);

    // this was inited in initapp.cpp: CInitApp::SetSetupParams
    // and it could have been overridden by the time we get here
    g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;

    if (0 != g_pTheApp->dwUnattendConfig)
    {
        // if some sort of unattended www user was specified
        // then use it.  if they specified only a password,
        // then use that password for the default user.
        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME)
        {
            if (_tcsicmp(g_pTheApp->m_csFTPAnonyName_Unattend,_T("")) != 0)
            {
                g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csFTPAnonyName_Unattend;
            }
        }

        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS)
        {
            g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csFTPAnonyPassword_Unattend;
        }

        err = CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);
        if ( err != NERR_Success )
        {
            // something went wrong, set the user back to guest!!!
            g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
            g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;

            // flow down and process CheckIfThisServerHasAUserThenUseIt()
            // since things are now hosed!
        }
        else
        {
            // Check if the user was NewlyCreated.
            // if it was then add it to list that eventually gets written to
            // the registry -- so that when uninstall happens, setup knows
            // which users it added -- so that it can remove them!
            if (1 == iUserWasNewlyCreated)
            {
                // Add to the list
                g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),g_pTheApp->m_csFTPAnonyName);
            }
            WriteToMD_AnonymousUserName_FTP(FALSE);
            goto Register_iis_ftp_handle_iusr_acct_Exit;
        }
    }

    // check the metabase to see if it already has an entry in it
    if (TRUE == CheckIfThisServerHasAUserThenUseIt(DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER))
        {goto Register_iis_ftp_handle_iusr_acct_Exit;}

    // Well, i guess the there is no metabase entry for the iusr under ftp.

    // see if we can get it from somewhere else...
    if (atFTP == AT_INSTALL_FRESH)
    {
        // if this is a fresh install of ftp, then
        // let's try to use the www user
        if (TRUE == CheckIfServerAHasAUserThenUseForServerB(_T("LM/W3SVC"), DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER))
            {goto Register_iis_ftp_handle_iusr_acct_Exit;}
    }

    // if this is an upgrade or fresh or whatevers
    // see if we can get it from an older iis place
    if (TRUE == CheckForOtherIUsersAndUseItForFTP())
        {goto Register_iis_ftp_handle_iusr_acct_Exit;}

    // if there are no registry/existing user combinations
    // then we'll have to create a new iusr for ftp

    // let's use the iusr_computername deal
    g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;
    CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);

    // ================
    // LM/MSFTPSVC/AnonymousUserName
    // LM/MSFTPSVC/AnonymousPwd
    // ================
    WriteToMD_AnonymousUserName_FTP(FALSE);
    goto Register_iis_ftp_handle_iusr_acct_Exit;
    
Register_iis_ftp_handle_iusr_acct_Exit:
    return iReturn;
}


// Look in the old iis1.0,2.0,3.0 spot for the ftp user and name.
// retrieve it from the registry..
int CheckForOtherIUsersAndUseItForFTP(void)
{
    int iReturn = FALSE;
    int IfTheUserNotExistThenDoNotDoThis = TRUE;

    TSTR strAnonyName;
    CString csAnonyName;
    TSTR strAnonyPassword;

    CRegKey regFTPParam(HKEY_LOCAL_MACHINE, REG_FTPPARAMETERS, KEY_READ);
    CRegKey regWWWParam(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_READ);

    iisDebugOut_Start(_T("CheckForOtherIUsersAndUseItForFTP"));

    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"),FALSE);
    if (atFTP != AT_INSTALL_UPGRADE)
        {goto CheckForOtherIUsersAndUseItForFTP_Exit;}

    if (g_pTheApp->m_eUpgradeType != UT_351 && g_pTheApp->m_eUpgradeType != UT_10 && g_pTheApp->m_eUpgradeType != UT_20 && g_pTheApp->m_eUpgradeType != UT_30)
        {goto CheckForOtherIUsersAndUseItForFTP_Exit;}

    if ( (HKEY) regFTPParam ) 
    {
        regFTPParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regFTPParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            if ( !strAnonyName.Copy( csAnonyName.GetBuffer(0) ) ||
                 !GetAnonymousSecret( _T("FTPD_ANONYMOUS_DATA"), &strAnonyPassword ) )
            {
                goto CheckForOtherIUsersAndUseItForFTP_Exit;
            }

            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER , strAnonyName.QueryStr(), strAnonyPassword.QueryStr(), iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CheckForOtherIUsersAndUseItForFTP:using old ftp reg usr:%s.\n"), strAnonyPassword.QueryStr() ));
                iReturn = TRUE;
                goto CheckForOtherIUsersAndUseItForFTP_Exit;
            }
            else
            {
                // the user was not found, so don't use this registry data
                // just flow down to the next check
            }
        }
    }

    // retrieve from registry
    if ( (HKEY) regWWWParam ) 
    {
        regWWWParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regWWWParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            if ( !strAnonyName.Copy( csAnonyName.GetBuffer(0) ) ||
                 !GetAnonymousSecret( _T("W3_ANONYMOUS_DATA"), &strAnonyPassword ) )
            {
                iReturn = FALSE;
                goto CheckForOtherIUsersAndUseItForFTP_Exit;
            }

            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER , strAnonyName.QueryStr() , strAnonyPassword.QueryStr(), iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CheckForOtherIUsersAndUseItForFTP:using old www reg usr:%s.\n"),strAnonyName.QueryStr()));
                iReturn = TRUE;
            }
            else
            {
                // if this didn't work, then we'll have to return false
                // in other words -- we couldn't find a valid registry and existing user entry...
                iReturn = FALSE;
            }
            goto CheckForOtherIUsersAndUseItForFTP_Exit;
        }
    }

CheckForOtherIUsersAndUseItForFTP_Exit:
    iisDebugOut_End(_T("CheckForOtherIUsersAndUseItForFTP"));
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\ftpcomp.cxx ===
#include "stdafx.h"
#include "ftpcomp.hxx"
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdentry.h"
#include "svc.h"

// GetName
//
// Return the name for the Web Service Component
//
LPTSTR 
CFtpServiceInstallComponent::GetName()
{
    return _T("iis_ftp");
}


// Post install
// 
BOOL 
CFtpServiceInstallComponent::PostInstall()
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Executing PostInstall for the FTP component...\n")));
    BOOL bResult = TRUE;

    // Start the service
    // If a flag exists in the unattended file for manual service start - change the servoce startup type
    if ( g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_MANUAL_START_FTP )
    {
        SetServiceStart( _T("MSFTPSVC"), SERVICE_DEMAND_START );
    }
    else
    {
        if ( !g_pTheApp->m_fNTGuiMode )
        {
          // It's not fatal if we fail to start the service, but return result anyway
          INT nRes = InetStartService( _T("MSFTPSVC") );

          bResult = ( (nRes == ERROR_SUCCESS) || (nRes == ERROR_SERVICE_ALREADY_RUNNING) );
        }
    }

    return bResult;
}

// Install
//
// Install the FTP Component
//
BOOL 
CFtpServiceInstallComponent::Install()
{
  BOOL bRet = TRUE;

  if ( IsUpgrade() )
  {
    bRet = bRet && IfConflictDisableDefaultSite();
  }

  return bRet;
}

// IfConflictDisableDefaultSite
//
// If there is already a ftp site on the default ftp site that we just
// created, then disable the default one.
//
// Return Values:
//   TRUE - Successfull
//   FALSE - Failure checking and setting
BOOL 
CFtpServiceInstallComponent::IfConflictDisableDefaultSite()
{
  BOOL            bDisableDefault = FALSE;
  CStringList     cslpathList;
  CMDKey          cmdKey;
  POSITION        pos;
  CMDValue        cmdValue;
  CString         csPath;
  BOOL            bRet = TRUE;
  LPTSTR          szPath;
  TSTR_MSZ        mstrBindings;

  if ( FAILED( cmdKey.OpenNode( METABASEPATH_FTP_ROOT ) ) )
  {
    // Could not open the w3svc node
    return FALSE;
  }

  if (FAILED( cmdKey.GetDataPaths( MD_SERVER_BINDINGS, 
                                   MULTISZ_METADATA, 
                                   cslpathList) ))
  {
    // Could not GetDataPaths for this value
    return FALSE;
  }

  pos = cslpathList.GetHeadPosition();

  while ( NULL != pos )
  {
    csPath = cslpathList.GetNext( pos );

    szPath = csPath.GetBuffer(0);

    if ( ( wcscmp( szPath, L"/1/" ) != 0 ) &&
         ( cmdKey.GetData( cmdValue, MD_SERVER_BINDINGS, szPath ) )  &&
         ( cmdValue.GetDataType() == MULTISZ_METADATA ) &&
         ( mstrBindings.Copy( (LPTSTR) cmdValue.GetData() ) &&
         mstrBindings.IsPresent( _T(":21:") ) ) 
       ) 
    {
      if ( ( !cmdKey.GetData( cmdValue, MD_SERVER_AUTOSTART, szPath ) ) ||
           ( !cmdValue.IsEqual( DWORD_METADATA, 4, (DWORD) 0 ) )
         )
      {
        // If GetData failed, or it succedded and the value is not 0, then we
        // have found a match.
        bDisableDefault = TRUE;
        break;
      }
    }
  }

  if ( bDisableDefault )
  {
    // Now lets set default to not start, since someone else already has this port
    if ( !cmdValue.SetValue( MD_SERVER_AUTOSTART, 0, IIS_MD_UT_SERVER, 0 ) ||
         !cmdKey.SetData( cmdValue, MD_SERVER_AUTOSTART, L"/1/" ) )
    {
      bRet = FALSE;
    }
  }

  cmdKey.Close();

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\helper.h ===
#ifndef _HELPER_H_
#define _HELPER_H_

#include "wmrgexp.h"
#include "ocmanage.h"
#include "setupapi.h"

#if DBG == 1
	#include <stdio.h>
	#include <stdarg.h>
	#define DECLARE_INFOLEVEL(comp) extern unsigned long comp##InfoLevel = DEF_INFOLEVEL;
	#define DECLARE_DEBUG(comp) \
	    extern unsigned long comp##InfoLevel; \
	    _inline void \
	    comp##InlineDebugOut(unsigned long fDebugMask, TCHAR *pszfmt, ...) \
	    { \
	        if (comp##InfoLevel & fDebugMask) \
	        { \
	            TCHAR acsString[1000];\
	            va_list va; \
	            va_start(va, pszfmt);\
	            _vstprintf(acsString, pszfmt, va); \
	            va_end(va);\
	            OutputDebugString(acsString);\
	        } \
	    }\
	    _inline void \
	    comp##InlineDebugOut( TCHAR *pszfmt, ...) \
	    { \
	        if ( TRUE ) \
	        { \
	            TCHAR acsString[1000];\
	            va_list va; \
	            va_start(va, pszfmt);\
	            _vstprintf(acsString, pszfmt, va); \
	            va_end(va);\
	            OutputDebugString(acsString);\
	        } \
	    }
#else  // DBG == 0
	#define DECLARE_DEBUG(comp)
	#define DECLARE_INFOLEVEL(comp)
#endif // DBG == 0

DECLARE_DEBUG(iis);
#define iisDebugOut(x) iisDebugOut2 x
#define iisDebugOutSafeParams(x) iisDebugOutSafeParams2 x
#define iisDebugOutSafe(x) iisDebugOutSafe2 x

#define DO_IT_FOR_W3SVC_ANONYMOUSUSER    1
#define DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER 2
#define DO_IT_FOR_W3SVC_WAMUSER          4

// External globals from other .cpp files
class  MyLogFile;
extern MyLogFile g_MyLogFile;
class  CInitApp;
extern CInitApp* g_pTheApp;
extern HANDLE g_MyModuleHandle;

// structs
typedef struct _CLUSTER_SVC_INFO_FILL_STRUCT
{
    LPTSTR szTheClusterName;
    LPWSTR pszTheServiceType;
    CString * csTheReturnServiceResName;
    DWORD dwReturnStatus;
} CLUSTER_SVC_INFO_FILL_STRUCT;

typedef struct _ScriptMapNode {
    TCHAR szExt[32];
    TCHAR szProcessor[_MAX_PATH];
    DWORD dwFlags;
    TCHAR szMethods[_MAX_PATH];
    struct _ScriptMapNode *prev, *next;
} ScriptMapNode;

//
// Functions
//
void iisDebugOut2(int iLogType, TCHAR *pszfmt, ...);
void iisDebugOutSafeParams2(int iLogType, TCHAR *pszfmt, ...);
void iisDebugOutSafe2(int iLogType, TCHAR *pszfmt);
void iisDebugOut_Start(TCHAR *pszString, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_Start1(TCHAR *pszString1, TCHAR *pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_Start1(TCHAR *pszString1, CString pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_End(TCHAR *pszString, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_End1(TCHAR *pszString1, TCHAR *pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_End1(TCHAR *pszString1, CString pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void ProgressBarTextStack_Push(CString csText);
void ProgressBarTextStack_Push(LPTSTR szText);
void ProgressBarTextStack_Pop(void);
void ProgressBarTextStack_Set(int iStringID);
void ProgressBarTextStack_Set(int iStringID, const CString& csFileName);
void ProgressBarTextStack_Set(int iStringID, const CString& csString1, const CString& csString2);
void ProgressBarTextStack_Set(LPCTSTR szProgressTextString);
void ProgressBarTextStack_Inst_Set( int ServiceNameID, int iInstanceNum);
void ProgressBarTextStack_InstVRoot_Set( int ServiceNameID, int iInstanceNum, CString csVRName);
void ProgressBarTextStack_InstInProc_Set( int ServiceNameID, int iInstanceNum, CString csVRName);
void ListOfWarnings_Add(TCHAR * szEntry);
void ListOfWarnings_Display(void);
HRESULT GetLastSectionToBeCalled(void);
INT  Register_iis_common();
INT  Unregister_iis_common();
INT  Unregister_old_asp();
INT  Register_iis_core();
INT  Unregister_iis_core();
INT  Register_iis_inetmgr();
INT  Unregister_iis_inetmgr();
INT  Register_iis_pwmgr();
INT  Unregister_iis_pwmgr();
INT  Register_iis_www();
INT  Unregister_iis_www();
INT  Register_iis_doc();
INT  Register_iis_ftp();
INT  Unregister_iis_ftp();
LPWSTR MakeWideStrFromAnsi(LPSTR psz);
int  GetMultiStrSize(LPTSTR p);
BOOL IsValidNumber(LPCTSTR szValue);
int  GetRandomNum(void);
void SetRebootFlag(void);
BOOL RunProgram( LPCTSTR pszProgram, LPTSTR CmdLine, BOOL fMinimized , DWORD dwWaitTimeInSeconds, BOOL fCreateNewConsole);
void HandleSpecificErrors(DWORD iTheErrorCode, DWORD dwFormatReturn, CString csMsg, TCHAR pMsg[], CString *);
BOOL GetDataFromMetabase(LPCTSTR szPath, int nID, LPBYTE Buffer, int BufSize);
void AddOLEAUTRegKey();
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction);
void lodctr(LPCTSTR lpszIniFile);
void unlodctr(LPCTSTR lpszDriver);
INT  InstallPerformance(CString nlsRegPerf,CString nlsDll,CString nlsOpen,CString nlsClose,CString nlsCollect );
INT  AddEventLog(BOOL fSystem, CString nlsService, CString nlsMsgFile, DWORD dwType);
INT  RemoveEventLog(BOOL fSystem, CString nlsService );
INT  InstallAgent( CString nlsName, CString nlsPath );
INT  RemoveAgent( CString nlsServiceName );
void InstallMimeMap();
int  CreateInProc(LPCTSTR lpszPath, int iUseOOPPool);
void CreateInProc_Wrap(LPCTSTR lpszPath, int iUseOOPPool);
void DeleteInProc(LPCTSTR lpszKeyPath);
void SetAppFriendlyName(LPCTSTR szKeyPath);
void SetInProc(LPCTSTR szKeyPath);
void AddCustomError(IN DWORD dwCustErr, IN INT intSubCode, IN LPCTSTR szErrorString, IN LPCTSTR szKeyPath, IN BOOL fOverwriteExisting );
ScriptMapNode *AllocNewScriptMapNode(LPTSTR szExt, LPTSTR szProcessor, DWORD dwFlags, LPTSTR szMethods);
void InsertScriptMapList(ScriptMapNode *pList, ScriptMapNode *p, BOOL fReplace);
void FreeScriptMapList(ScriptMapNode *pList);
void GetScriptMapListFromRegistry(ScriptMapNode *pList);
void GetScriptMapListFromMetabase(ScriptMapNode *pList, int iUpgradeType);
void WriteScriptMapListToMetabase(ScriptMapNode *pList, LPTSTR szKeyPath, DWORD dwFlags);
DWORD CallProcedureInDll_wrap(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag, BOOL iFunctionPrototypeFlag);
DWORD CallProcedureInDll(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag, BOOL iFunctionPrototypeFlag);
void  GetDebugLevelFromInf(IN HINF hInfFileHandle);
int  IsThisStringInThisCStringList(CStringList &strList, LPCTSTR szStringToLookFor);
int  KillProcess_Wrap(LPCTSTR lpFullPathOrJustFileName);
int  ProcessSection(IN HINF hFile, IN LPCTSTR szTheSection);
void uiCenterDialog( HWND hwndDlg );
int  AfterRemoveAll_SaveMetabase(void);
int  iOleInitialize(void);
void iOleUnInitialize(int iBalanceOLE);
BOOL SetupSetDirectoryId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR Directory);
BOOL SetupSetStringId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR TheString);
void LogImportantFiles(void);
HRESULT FTestForOutstandingCoInits(void);
void DisplayStringForMetabaseID(DWORD dwMetabaseID);
void ReturnStringForMetabaseID(DWORD dwMetabaseID, LPTSTR lpReturnString);
void SetErrorFlag(char *szFileName, int iLineNumber);
DWORD FillStrListWithListOfSections(IN HINF hFile, CStringList &strList, IN LPCTSTR szSection);
void MesssageBoxErrors_IIS(void);
void MesssageBoxErrors_MTS(int iMtsThingWeWereDoing, DWORD dwErrorCode);
void ShowIfModuleUsedForGroupOfSections(IN HINF hFile, int iUnlockThem);
int ReadGlobalsFromInf(HINF InfHandle);
int CheckIfPlatformMatchesInf(HINF InfHandle);
int CheckSpecificBuildinInf(HINF InfHandle);
int CheckForOldGopher(HINF InfHandle);
void SetOCGlobalPrivateData(void);
BOOL GetJavaTLD(LPTSTR lpszDir);
void SetDIRIDforThisInf(HINF InfHandle,BOOL bOCInit);
void ShowStateOfTheseServices(IN HINF hFile);
int  GetScriptMapAllInclusionVerbs(CString &csTheVerbList);
void DumpScriptMapList();
int  GetSectionNameToDo(IN HINF hFile, TSTR *pstrSectionName);
void CustomWWWRoot(LPCTSTR szWWWRoot);
void CustomFTPRoot(LPCTSTR szFTPRoot);
void AdvanceProgressBarTickGauge(int iTicks = 1);
int  IsMetabaseCorrupt(void);
int ReadUserConfigurable(HINF InfHandle);
int ReverseExpandEnvironmentStrings(LPTSTR szOriginalDir,LPTSTR szNewlyMungedDir);
BOOL SetupFindFirstLine_Wrapped(IN HINF InfHandle,IN LPCTSTR Section,IN LPCTSTR Key,OPTIONAL INFCONTEXT *Context);
INT IsThisOnNotStopList(IN HINF hFile, CString csInputName, BOOL bServiceFlag);
HRESULT MofCompile(TCHAR * szPathMofFile);
DWORD   DoesEntryPointExist(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedure);
void    CreateDummyMetabaseBin(void);
BOOL    RunningAsAdministrator();
LPTSTR  CreatePassword(int iSize);
void    CreatePasswordOld(TCHAR *pszPassword,int iSize);
void StopAllServicesRegardless(int iShowErrorsFlag);
LPTSTR SafeCopy( LPTSTR szDestination, LPTSTR szSource, DWORD dwSize);
LPTSTR SafeCat( LPTSTR szDestination, LPTSTR szSource, DWORD dwSize);
BOOL DoesTheInstallDrivePreserveAcls( LPBOOL pbPreservesAcls );
BOOL UpdateAnonymousUsers( HINF InfHandle );

#endif // _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\initapp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "log.h"
#include <winnetwk.h>

extern int g_GlobalDebugLevelFlag;
extern int g_GlobalDebugLevelFlag_WasSetByUnattendFile;
extern int g_CheckIfMetabaseValueWasWritten;
extern MyLogFile g_MyLogFile;

void Check_For_DebugServiceFlag(void)
{
    INFCONTEXT Context;
    TSTR strSectionName( MAX_PATH );
    TSTR strEntry( MAX_PATH );

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) 
    {
      return;
    }

    // The section name to look for in the unattended file
    if ( !strSectionName.Copy( UNATTEND_FILE_SECTION ) ||
         !strEntry.Copy( _T("") ) )
    {
      return;
    }

    //
    // Look for our special setting
    //
    if ( SetupFindFirstLine(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("DebugService"), &Context) ) 
    {
        SetupGetStringField(&Context, 1, strEntry.QueryStr(), strEntry.QuerySize(), NULL);
        if (0 == _tcsicmp(strEntry.QueryStr(), _T("1")) || 0 == _tcsicmp(strEntry.QueryStr(), _T("true")) )
        {
            SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 34101, strEntry.QueryStr());
        }
    }
    return;
}

void Check_For_DebugLevel(void)
{
    INFCONTEXT Context;
    TSTR strSectionName( MAX_PATH );
    TSTR strEntry( MAX_PATH );

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) 
    {
      return;
    }

    // The section name to look for in the unattended file
    if ( !strSectionName.Copy( UNATTEND_FILE_SECTION ) ||
         !strEntry.Copy( _T("") ) )
    {
      return;
    }

    //
    // Look for our special setting
    //
    if ( SetupFindFirstLine(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("DebugLevel"), &Context) ) 
        {
        SetupGetStringField(&Context, 1, strEntry.QueryStr(), strEntry.QuerySize(), NULL);

        if (IsValidNumber( strEntry.QueryStr() )) 
            {
                g_GlobalDebugLevelFlag = _ttoi( strEntry.QueryStr() );
                g_GlobalDebugLevelFlag_WasSetByUnattendFile = TRUE;

                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("DebugLevel=%d."),g_GlobalDebugLevelFlag));
            }

            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API )
            {
                g_CheckIfMetabaseValueWasWritten = TRUE;
            }
        }

    return;
}

void Check_Custom_IIS_INF(void)
{
    INFCONTEXT  Context;
    TSTR        strSectionName( MAX_PATH );
    TSTR_PATH   strFullPath( MAX_PATH );

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) 
    {
      return;
    }

    // The section name to look for in the unattended file
    if ( !strSectionName.Copy( UNATTEND_FILE_SECTION ) )
    {
      return;
    }

    //
    // Look for our special setting
    //
    if ( SetupFindFirstLine(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("AlternateIISINF"), &Context) &&
         SetupGetStringField(&Context, 1, strFullPath.QueryStr(), strFullPath.QuerySize(), NULL) &&
         strFullPath.ExpandEnvironmentVariables() 
       )
    {
      if (!IsFileExist( strFullPath.QueryStr() ))
      {
        iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_IIS_INF:AlternateIISINF=%s.Not Valid.ignoring unattend value. WARNING.\n"), strFullPath.QueryStr() ));
        return;
      }

      g_pTheApp->m_hInfHandleAlternate = SetupOpenInfFile( strFullPath.QueryStr(), NULL, INF_STYLE_WIN4, NULL);

      if ( !g_pTheApp->m_hInfHandleAlternate || 
           ( g_pTheApp->m_hInfHandleAlternate == INVALID_HANDLE_VALUE )
         )
      {
        iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_IIS_INF: SetupOpenInfFile failed on file: %s.\n"), strFullPath.QueryStr() ));
        return;
      }

      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Check_Custom_IIS_INF:AlternateIISINF=%s\n"), strFullPath.QueryStr() ));
    }
}


void Check_Custom_WWW_or_FTP_Path(void)
{
    INFCONTEXT  Context;
    TSTR        strSectionName( MAX_PATH );
    TSTR_PATH   strPath( MAX_PATH );

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) 
    {
      return;
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:start\n")));

    // The section name to look for in the unattended file
    if ( !strSectionName.Copy( UNATTEND_FILE_SECTION ) )
    {
      return;
    }

    //
    // FTP
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("PathFTPRoot"), &Context) &&
         SetupGetStringField(&Context, 1, strPath.QueryStr(), strPath.QuerySize(), NULL) &&
         strPath.ExpandEnvironmentVariables() )
    {
      if (IsValidDirectoryName( strPath.QueryStr() ))
      {
          iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s\n"), strPath.QueryStr() ));
          CustomFTPRoot( strPath.QueryStr() );
          g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_FTP;
      }
      else
      {
          iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s.Not Valid.ignoring unattend value. WARNING.\n"), strPath.QueryStr() ));
      }
    }

    //
    // WWW
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("PathWWWRoot"), &Context) &&
         SetupGetStringField(&Context, 1, strPath.QueryStr(), strPath.QuerySize(), NULL) &&
         strPath.ExpandEnvironmentVariables() )
    {
      if (IsValidDirectoryName( strPath.QueryStr() ))
      {
          iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s\n"), strPath.QueryStr() ));
          CustomWWWRoot( strPath.QueryStr() );
          g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_FTP;
      }
      else
      {
          iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s.Not Valid.ignoring unattend value. WARNING.\n"), strPath.QueryStr() ));
      }
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:end\n")));
    return;
}


CInitApp::CInitApp()
{
    m_err = 0;
    m_hInfHandle = NULL;
    m_hInfHandleAlternate = NULL;
    m_bAllowMessageBoxPopups = TRUE;
    m_bThereWereErrorsChkLogfile = FALSE;
    m_bThereWereErrorsFromMTS = FALSE;
    m_bWin95Migration = FALSE;

    m_bIISAdminWasDisabled = FALSE;

    // Product name and application name
    m_csAppName = _T("");
    m_csIISGroupName = _T("");

    // account + passwd for anonymous user
    m_csGuestName = _T("");
    m_csGuestPassword = _T("");
    m_csWAMAccountName = _T("");
    m_csWAMAccountPassword = _T("");
    m_csWWWAnonyName = _T("");
    m_csWWWAnonyPassword = _T("");
    m_csFTPAnonyName = _T("");
    m_csFTPAnonyPassword = _T("");

    dwUnattendConfig = 0;

    m_csWAMAccountName_Unattend = _T("");
    m_csWAMAccountPassword_Unattend = _T("");
    m_csWWWAnonyName_Unattend = _T("");
    m_csWWWAnonyPassword_Unattend = _T("");
    m_csFTPAnonyName_Unattend = _T("");
    m_csFTPAnonyPassword_Unattend = _T("");

    m_csWAMAccountName_Remove = _T("");
    m_csWWWAnonyName_Remove = _T("");
    m_csFTPAnonyName_Remove = _T("");

    // machine status
    m_csMachineName = _T("");
    m_csUsersDomain = _T("");
    m_csUsersAccount = _T("");

    m_fUninstallMapList_Dirty = FALSE;

    m_csWinDir = _T("");
    m_csSysDir = _T("");
    m_csSysDrive = _T("");

    m_csPathSource = _T("");
    m_csPathOldInetsrv = _T("");  // the primary destination used by previous iis/pws products
    m_csPathInetsrv = _T("");  // the primary destination defaults to m_csSysDir\inetsrv
    m_csPathInetpub = _T("");
    m_csPathFTPRoot = _T("");
    m_csPathWWWRoot = _T("");
    m_csPathWebPub = _T("");
    m_csPathProgramFiles = _T("");
    m_csPathIISSamples = _T("");
    m_csPathScripts = _T("");
    m_csPathASPSamp = _T("");
    m_csPathAdvWorks = _T("");
    m_csPathIASDocs = _T("");
    m_csPathOldPWSFiles = _T("");
    m_csPathOldPWSSystemFiles = _T("");

    m_dwOSServicePack = 0;
    m_eOS = OS_OTHERS;                  // OS_W95, OS_NT, OS_OTHERS
    m_fNT5 = FALSE;
    m_fW95 = FALSE;                 // TRUE if Win95 (build xxx) or greater

    m_eNTOSType = OT_NT_UNKNOWN;           // OT_PDC, OT_SAM, OT_BDC, OT_NTS, OT_NTW
    m_csPlatform = _T("");

    m_fTCPIP = FALSE;               // TRUE if TCP/IP is installed

    m_eUpgradeType = UT_NONE;       //  UT_NONE, UT_10, UT_20, etc.
    m_bUpgradeTypeHasMetabaseFlag = FALSE;
    m_eInstallMode = IM_FRESH;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    m_dwSetupMode = SETUPMODE_CUSTOM;
    m_bRefreshSettings = FALSE;
    m_bPleaseDoNotInstallByDefault = FALSE;

    m_fNTOperationFlags=0;
    m_fNTGuiMode=0;
    m_fNtWorkstation=0;
    m_fInvokedByNT = 0;

    m_fUnattended = FALSE;
    m_csUnattendFile = _T("");
    m_hUnattendFile = NULL;

    m_fEULA = FALSE;

    // TRUE if m_csPathOldInetsrv != m_csPathInetsrv, which means, 
    // we need to migrate the old inetsrv to the new one that is system32\inetsrv.
    m_fMoveInetsrv = FALSE;

    m_csPathSrcDir = _T("");
    m_csMissingFile = _T("");
    m_csMissingFilePath = _T("");
    m_fWebDownload = FALSE;
}

CInitApp::~CInitApp()
{
}

// function: IsUpgrade
//
// Return whether this is an upgrade or not
//
BOOL 
CInitApp::IsUpgrade()
{
  return ( m_eUpgradeType != UT_NONE );
}

// function: GetUpgradeVersion
//
// Return the version that we are upgrading from
//
DWORD 
CInitApp::GetUpgradeVersion()
{
  DWORD dwVer = 0;

  if ( !IsUpgrade() )
  {
    // This is not an upgrade, so return 0
    return 0;
  }

  switch ( m_eUpgradeType )
  {
  case UT_351:
  case UT_10_W95:
  case UT_10:
    return 1;
    break;
  case UT_20:
    dwVer = 2;
    break;
  case UT_30:
    dwVer = 3;
    break;
  case UT_40:
    dwVer = 4;
    break;
  case UT_50:
  case UT_51:
    dwVer = 5;
    break;
  case UT_60:
    dwVer = 6;
    break;
  case UT_NONE:
  default:
    dwVer = 0;
  }

  return dwVer;
}


// The one and only CInitApp object <Global variable>
// --------------------------------------------------
BOOL CInitApp::GetMachineName()
{
    TCHAR buf[ CNLEN + 10 ];
    DWORD dwLen = CNLEN + 10;

    m_csMachineName = _T("");

    // Get computername
    if ( GetComputerName( buf, &dwLen ))
    {
        if ( buf[0] != _T('\\') )
        {
            m_csMachineName = _T("\\");
            m_csMachineName += _T("\\");
        }
        m_csMachineName += buf;
    }
    else
    {
        m_err = IDS_CANNOT_GET_MACHINE_NAME;
    }

    return ( !(m_csMachineName.IsEmpty()) );
}


// Return TRUE, if NT or Win95
// --------------------------------------------------
BOOL CInitApp::GetOS()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VerInfo );

    switch (VerInfo.dwPlatformId) 
    {
    case VER_PLATFORM_WIN32_NT:
        m_eOS = OS_NT;
        break;
    case VER_PLATFORM_WIN32_WINDOWS:
        m_eOS = OS_W95;
        break;
    default:
        m_eOS = OS_OTHERS;
        break;
    }

    if ( m_eOS == OS_OTHERS ) {m_err = IDS_OS_NOT_SUPPORT;}
    return (m_eOS != OS_OTHERS);
}

// Support NT 4.0 (SP3) or greater
// --------------------------------------------------

BOOL CInitApp::GetOSVersion()
/*++

Routine Description:

    This function detects OS version. NT5 or greater is required to run this setup.

Arguments:

    None

Return Value:

    BOOL
    return FALSE, if we fails to detect the OS version, 
                  or it is a NT version which is smaller than v5.0

--*/
{
  BOOL fReturn = FALSE;

  if ( m_eOS == OS_NT )
  {
    OSVERSIONINFO vInfo;

    vInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx(&vInfo) )
    {
      // NT5 or greater is required.
      if ( vInfo.dwMajorVersion < 5 ) 
      {
        m_err = IDS_NT5_NEEDED;
        return FALSE;
      }

      // Start allowing NT 6 for Longhorn builds
      if ( ( vInfo.dwMajorVersion == 5 ) ||
           ( vInfo.dwMajorVersion == 6 ) )
      {
        m_fNT5 = TRUE;
        fReturn = TRUE;
      }
    }
  }

  // this line may be used for win98
  if (m_eOS == OS_W95)
  {
    fReturn = TRUE;
  }

  if ( !fReturn ) 
  {
    m_err = IDS_OS_VERSION_NOT_SUPPORTED;
  }

  return (fReturn);
}

// find out it's a NTS, PDC, BDC, NTW, SAM(PDC)
// --------------------------------------------------
BOOL CInitApp::GetOSType()
{
    BOOL fReturn = TRUE;

    if ( m_eOS == OS_NT )
    {
        // If we are in NT guimode setup
        // then the registry key stuff is not yet setup
        // use the passed in ocmanage.dll stuff to determine
        // what we are installing upon.
        if (g_pTheApp->m_fNTGuiMode)
        {
            if (g_pTheApp->m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
            else {m_eNTOSType = OT_NTS;}
        }
        else
        {

            m_eNTOSType = OT_NTS; // default to stand-alone NTS

            CRegKey regProductPath( HKEY_LOCAL_MACHINE, REG_PRODUCTOPTIONS, KEY_READ);
            if ( (HKEY)regProductPath )
            {
                CString strProductType;
                LONG lReturnedErrCode = regProductPath.QueryValue( _T("ProductType"), strProductType );
                if (lReturnedErrCode == ERROR_SUCCESS) 
                {
                    strProductType.MakeUpper();

                    // ToDo: Sam ?
                    if (strProductType == _T("WINNT")) 
                    {
                        m_eNTOSType = OT_NTW;
                    }
                    else if (strProductType == _T("SERVERNT")) 
                    {
                        m_eNTOSType = OT_NTS;
                    }
                    else if (strProductType == _T("LANMANNT"))
                    {
                        m_eNTOSType = OT_PDC_OR_BDC;
                    }
                    else 
                    {
                        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProductType=%1!s! (UnKnown). FAILER to detect ProductType\n"), strProductType));
                        fReturn = FALSE;
                    }
                }
                else 
                {
                    // Shoot, we can't get the registry key,
                    // let's try using the ocmanage.dll passed in stuff.
                    if (g_pTheApp->m_fNTGuiMode)
                    {
                        if (g_pTheApp->m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                        else {m_eNTOSType = OT_NTS;}
                    }
                    else
                    {
                        GetErrorMsg(lReturnedErrCode, REG_PRODUCTOPTIONS);
                        m_eNTOSType = OT_NTS; // default to stand-alone NTS
                    }
                }
            }
            else
            {
                // Shoot, we can't get the registry key,
                // let's try using the ocmanage.dll passed in stuff.
                if (g_pTheApp->m_fNTGuiMode)
                {
                    if (g_pTheApp->m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                    else {m_eNTOSType = OT_NTS;}
                }
                else
                {
                    GetErrorMsg(ERROR_CANTOPEN, REG_PRODUCTOPTIONS);
                }
            }
        }
    }

    if ( !fReturn )
        m_err = IDS_CANNOT_DETECT_OS_TYPE;

    return(fReturn);
}

// Get WinDir and SysDir of the machine
//  WinDir = C:\winnt           SysDir = C:\Winnt\system32
// --------------------------------------------------
BOOL CInitApp::GetSysDirs()
{
    BOOL fReturn = TRUE;
    TCHAR buf[_MAX_PATH];

    m_csWinDir = _T("");
    m_csSysDir = _T("");

    if ( !GetWindowsDirectory( buf, _MAX_PATH ) )
    {
      return FALSE;
    }
    
    m_csWinDir = buf;

    if ( !GetSystemDirectory( buf, _MAX_PATH ) )
    {
      return FALSE;
    }

    m_csSysDir = buf;

    if ( _tcslen( buf ) <= 2 )
    {
      return FALSE;
    }

    buf[2] = _T('\0');  // now buf contains the system drive letter
    m_csSysDrive = buf;

    return fReturn;
}

BOOL CInitApp::IsTCPIPInstalled()
/*++

Routine Description:

    This function detects whether TCP/IP is installed, 
    and set m_fTCPIP appropriately.

Arguments:

    None

Return Value:

    BOOL
    set m_fTCPIP appropriately, and always return TRUE here. 
    m_fTCPIP will be used later.

--*/
{
  // NT 5.0 STUFF
  m_fTCPIP = TCPIP_Check_Temp_Hack();

  return TRUE;
}



BOOL CInitApp::SetInstallMode()
{
    BOOL fReturn = TRUE;
    int iTempInstallFreshNT = TRUE;
    m_eInstallMode = IM_FRESH;
    m_eUpgradeType = UT_NONE;
    m_bUpgradeTypeHasMetabaseFlag = FALSE;

    // -----------------------------------
    // Get the install mode from NT setup (g_pTheApp->m_fNTUpgrade_Mode)
    // Can either be:  
    // 1. SETUPMODE_FRESH. user clicked on fresh option and wants to install NT5 fresh
    //    a. install iis fresh. do not attempt to upgrade the old iis stuff.
    // 2. SETUPMODE_UPGRADE. user clicked on upgrade option and wants to upgrade to NT5
    //    a. upgrade any iis installations
    //    b. if no old iis detected, then do not install iis
    // 3. SETUPMODE_MAINTENANCE.  user is running setup from the control panel add/remove.
    // -----------------------------------
    if (!m_fInvokedByNT)
    {
        // if we are not guimode or in add/remove
        // then we must be running standalone.
        // if we are running standalone, then everything is
        // either fresh or maintenance.
        m_eInstallMode = IM_FRESH;
        m_eUpgradeType = UT_NONE;
        if (TRUE == AreWeCurrentlyInstalled())
        {
            m_eInstallMode = IM_MAINTENANCE;
            m_eUpgradeType = UT_NONE;
            m_bUpgradeTypeHasMetabaseFlag = TRUE;
        }
        else
        {
            CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
            if ((HKEY) regINetStp)
            {
                // This must be an upgrade....
                if (SetUpgradeType() == TRUE)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=SETUPMODE_UPGRADE.Upgrading.\n")));
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=SETUPMODE_UPGRADE.NothingToUpgrade.\n")));
                }
            }
        }

        goto SetInstallMode_Exit;
    }

    // --------------------------------
    // Check if we are in the ADD/REMOVE mode...
    // --------------------------------
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_STANDALONE)
    {
        //
        // We are in add remove...
        //
        iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=IM_MAINTENANCE\n")));
        m_eInstallMode = IM_MAINTENANCE;
        m_eUpgradeType = UT_NONE;
        m_bUpgradeTypeHasMetabaseFlag = FALSE;
        goto SetInstallMode_Exit;
    }

    // --------------------------------
    //
    // FRESH IIS install
    // 
    // if we are not in NT upgrade
    // then set everything to do a fresh!
    //
    // --------------------------------
    iTempInstallFreshNT = TRUE;
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_WIN31UPGRADE){iTempInstallFreshNT = FALSE;}
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_WIN95UPGRADE){iTempInstallFreshNT = FALSE;}
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_NTUPGRADE){iTempInstallFreshNT = FALSE;}
    if (iTempInstallFreshNT)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=IM_FRESH\n")));
        m_eInstallMode = IM_FRESH;
        m_eUpgradeType = UT_NONE;
        m_bUpgradeTypeHasMetabaseFlag = FALSE;
        goto SetInstallMode_Exit;
    }
    
    // --------------------------------
    //
    // UPGRADE iis install
    //
    // if we get here then the user checked the "upgrade" button and
    // is trying to upgrade from an earlier WIN95/NT351/NT4/NT5 installation.
    //
    // --------------------------------
    //
    // Set Upgrade ONLY if there are iis components to upgrade!
    // do not install if there is nothing to upgrade
    ProcessSection(g_pTheApp->m_hInfHandle, _T("Set_Upgrade_Type_chk"));

    // if we processed the upgrade section from the inf and
    // we are still in a fresh install, then call this other
    // function to make sure we catch known iis upgrade types.
    if (g_pTheApp->m_eUpgradeType == UT_NONE)
        {SetUpgradeType();}

SetInstallMode_Exit:
    if (m_fInvokedByNT){DefineSetupModeOnNT();}
    return fReturn;
}


void CInitApp::DefineSetupModeOnNT()
/*++

Routine Description:

    This function defines IIS setup mode when invoked by NT5.

    NOTE:
    Since IIS setup does not run as a standalone program on NT5, 
    user won't see buttons like Minimum, Typical, Custom, 
    AddRemove, Reinstall, RemoveAll, UpgradeOnly, UpgradePlus 
    any more. Hence, we have a totally different way to decide 
    what mode the setup is running in.

Arguments:

    none

Return Value:

    set m_dwSetupMode appropriately.

--*/
{
    if (m_fInvokedByNT) {
        switch (m_eInstallMode) {
        case IM_FRESH:
            m_dwSetupMode = SETUPMODE_CUSTOM;
            break;
        case IM_MAINTENANCE:
            if (m_fNTGuiMode) {
                // invoked in NT GUI mode setup
                // treat minor os upgrade like a reinstall
                m_dwSetupMode = SETUPMODE_REINSTALL;
                m_bRefreshSettings = TRUE;
            } else {
                // invoked by ControlPanel\AddRemoveApplet
                m_dwSetupMode = SETUPMODE_ADDREMOVE;
            }
            break;
        case IM_UPGRADE:
            m_dwSetupMode = SETUPMODE_ADDEXTRACOMPS;
            break;
        default:
            break;
        }
    }

    return;
}

void GetVRootValue( CString strRegPath, CString csName, LPTSTR szRegName, CString &csRegValue)
{
    CString csRegName;

    strRegPath +=_T("\\Parameters\\Virtual Roots");
    CRegKey regVR( HKEY_LOCAL_MACHINE, strRegPath, KEY_READ);

    csRegName = szRegName;

    if ( (HKEY) regVR )
    {
        regVR.m_iDisplayWarnings = FALSE;

        csRegName = csName;
        if ( regVR.QueryValue( csName, csRegValue ) != ERROR_SUCCESS )
        {
            csName += _T(",");
            if ( regVR.QueryValue(csName, csRegValue) != ERROR_SUCCESS )
            {
                // well, we need to scan all the keys
                CRegValueIter regEnum( regVR );
                CString strName;
                DWORD dwType;
                int nLen = csName.GetLength();

                while ( regEnum.Next( &strName, &dwType ) == ERROR_SUCCESS )
                {
                    CString strLeft = strName.Left(nLen);
                    if ( strLeft.CompareNoCase(csName) == 0)
                    {
                        csRegName = strName;
                        regVR.QueryValue( strName, csRegValue );
                        break;
                    }
                }
            }
        }
        // remove the ending ",,something"
        int cPos = csRegValue.Find(_T(','));
        if ( cPos != (-1))
        {
            csRegValue = csRegValue.Left( cPos );
        }
    }
}

void CInitApp::DeriveInetpubFromWWWRoot(void)
{
    TSTR strParentDir( MAX_PATH );

    if ( !strParentDir.Resize( _tcslen( m_csPathWWWRoot.GetBuffer(0) ) ) )
    {
      // String is too long to deal with
      return;
    }

    // Try to figure out InetPub Root
    // ------------------------------
    // Get inetpub dir from wwwroot
    // take the m_csPathWWWRoot and back off one dir to find it.
    InetGetFilePath(m_csPathWWWRoot, strParentDir.QueryStr() );
    if ((IsFileExist( strParentDir.QueryStr() )))
    {
        m_csPathInetpub = strParentDir.QueryStr();
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Old InetPub='%1!s!'.  Exists.  so we'll use it.\n"), m_csPathInetpub));
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("Old InetPub='%1!s!'.  Does not exist.  we'll use the default. WARNING.\n"), strParentDir.QueryStr()));
    }

    return;
}

void CInitApp::GetOldInetSrvDir(void)
{
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);

    // Get old InetSrv dir
    // -------------------
    m_csPathOldInetsrv = m_csPathInetsrv;
    if ((HKEY)regINetStp) 
    {
        // Get the old inetsrv dir, and check if it's different
        regINetStp.m_iDisplayWarnings = FALSE;
        regINetStp.QueryValue( _T("InstallPath"), m_csPathOldInetsrv);
        if (-1 != m_csPathOldInetsrv.Find(_T('%')) )
        {
            // there is a '%' in the string
            TSTR_PATH strTempDir;

            if ( !strTempDir.Copy( m_csPathOldInetsrv.GetBuffer(0) ) ||
                 !strTempDir.ExpandEnvironmentVariables() )
            {
              return;
            }

            m_csPathOldInetsrv = strTempDir.QueryStr();
        }
        m_fMoveInetsrv = (m_csPathOldInetsrv.CompareNoCase(m_csPathInetsrv) != 0);
    }

    return;
}


void CInitApp::GetOldWWWRootDir(void)
{
    CString csOldWWWRoot;
    //
    // Try to get it from the old iis2,3,4 setup location if it's there.
    //
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regINetStp) 
    {
        //
        // get the old wwwroot from the registry if there.
        //
        regINetStp.m_iDisplayWarnings = FALSE;
        regINetStp.QueryValue(_T("PathWWWRoot"), csOldWWWRoot);
        if (-1 != csOldWWWRoot.Find(_T('%')) )
        {
          TSTR_PATH strTempDir;

          if ( !strTempDir.Copy( csOldWWWRoot.GetBuffer(0) ) &&
               !strTempDir.ExpandEnvironmentVariables() )
          {
            return;
          }

          csOldWWWRoot = strTempDir.QueryStr();
        }

        // The old wwwRoot may be a network drive.
        // what to do then?
        // at least check if we can access it!
        if ((IsFileExist(csOldWWWRoot)))
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Old WWWRoot='%1!s!'.  Exists.  so we'll use it.\n"), csOldWWWRoot));
            m_csPathWWWRoot = csOldWWWRoot;
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("OldWWWRoot='%1!s!'.  Does not exist.  we'll use the default. WARNING.\n"), csOldWWWRoot));
        }
    }

    //
    // Try to get it from the old iis2,3,4 Actual W3svc Service location if it's there.
    // and overwrite anything that we got from setup -- since w3svc is what is actually used!
    //
    GetVRootValue(REG_W3SVC, _T("/"), _T("/"), m_csPathWWWRoot);

    return;
}

void CInitApp::GetOldIISSamplesLocation(void)
{
    //
    // Try to get it from the old iis2,3,4 setup location if it's there.
    //
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY)regINetStp)
    {
        //
        // Get the location of the where the samples were installed.
        //
        m_csPathIISSamples.Empty();
        regINetStp.m_iDisplayWarnings = FALSE;
        regINetStp.QueryValue( _T("/IISSamples"), m_csPathIISSamples );
        if (-1 != m_csPathIISSamples.Find(_T('%')) )
        {
            TSTR_PATH strTempDir;

            if ( !strTempDir.Copy( m_csPathIISSamples.GetBuffer(0) ) &&
                !strTempDir.ExpandEnvironmentVariables() )
            {
              return;
            }

            m_csPathIISSamples = strTempDir.QueryStr();
        }
        if ( m_csPathIISSamples.IsEmpty()) 
        {
            //
            // if Samples path is empty then this an Upgrade, 
            // Guess where to put Sample Site
            //
            TSTR strParentDir( MAX_PATH );
            TSTR strDir( MAX_PATH );

            if ( !strParentDir.Resize( _tcslen( m_csPathWWWRoot.GetBuffer(0) ) ) ||
                 !strDir.Resize( _tcslen( m_csPathWWWRoot.GetBuffer(0) ) +  
                                 _tcslen( _T("iissamples" ) ) 
                               )
               )
            {
              return;
            }

            //
            // Get the parent Dir path
            //
            InetGetFilePath((LPCTSTR)m_csPathWWWRoot, strParentDir.QueryStr() );
            //
            // Append the samples dir to parent path
            //
            AppendDir(strParentDir.QueryStr(), _T("iissamples"), strDir.QueryStr() );
            m_csPathIISSamples = strDir.QueryStr();
        }
    }

    if (m_eUpgradeType == UT_10_W95) 
    {
        TSTR strParentDir( MAX_PATH );
        TSTR strDir( MAX_PATH );

        if ( !strParentDir.Resize( _tcslen( m_csPathWWWRoot.GetBuffer(0) ) + _tcslen( _T("iissamples") ) ) ||
             !strDir.Resize( _tcslen( m_csPathWWWRoot.GetBuffer(0) ) + _tcslen( _T("webpub") ) )
           )
        {
          return;
        }

        InetGetFilePath(m_csPathWWWRoot, strParentDir.QueryStr() );
        AppendDir(strParentDir.QueryStr() , _T("iissamples"), strDir.QueryStr() );
        m_csPathIISSamples = strDir.QueryStr() ;
        AppendDir(strParentDir.QueryStr() , _T("webpub"), strDir.QueryStr() );
        m_csPathWebPub = strDir.QueryStr() ;
    }

    return;
}

void CInitApp::GetOldIISDirs(void)
{
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    
    //
    // get values from the previous setup for II2/4 upgrade
    //

    // Try to get old WWW Root from the service itself
    // -----------------------
    GetOldWWWRootDir();
    // Set Inetpub from whatever we got from www root
    DeriveInetpubFromWWWRoot();

    // Reset Vars relying on Inetpub
    // -----------------------------
    m_csPathFTPRoot = m_csPathInetpub + _T("\\ftproot");
    m_csPathIISSamples = m_csPathInetpub + _T("\\iissamples");
    m_csPathScripts = m_csPathInetpub + _T("\\Scripts");
    m_csPathWebPub = m_csPathInetpub + _T("\\webpub");
    m_csPathASPSamp = m_csPathInetpub + _T("\\ASPSamp");
    m_csPathAdvWorks = m_csPathInetpub + _T("\\ASPSamp\\AdvWorks");

    // Try to get old FTP Root from the service itself
    // -----------------------
    GetVRootValue(REG_MSFTPSVC, _T("/"), _T("/"), m_csPathFTPRoot);

    // Get old iis samples location
    // ----------------------------
    GetOldIISSamplesLocation();

    // Get iis 3.0 locations.
    // ----------------------
    GetVRootValue(REG_W3SVC, _T("/Scripts"), _T("/Scripts"), m_csPathScripts);
    GetVRootValue(REG_W3SVC, _T("/ASPSamp"), _T("/ASPSamp"), m_csPathASPSamp);
    GetVRootValue(REG_W3SVC, _T("/AdvWorks"), _T("/AdvWorks"), m_csPathAdvWorks);
    GetVRootValue(REG_W3SVC, _T("/IASDocs"), _T("/IASDocs"), m_csPathIASDocs);

    // Get old InetSrv dir
    // -------------------
    GetOldInetSrvDir();

    return;
}



void CInitApp::SetInetpubDerivatives()
{
    m_csPathFTPRoot = m_csPathInetpub + _T("\\ftproot");
    m_csPathWWWRoot = m_csPathInetpub + _T("\\wwwroot");
    m_csPathWebPub = m_csPathInetpub + _T("\\webpub");
    m_csPathIISSamples = m_csPathInetpub + _T("\\iissamples");
    m_csPathScripts = m_csPathInetpub + _T("\\scripts");
    m_csPathASPSamp = m_csPathInetpub + _T("\\ASPSamp");
    m_csPathAdvWorks = m_csPathInetpub + _T("\\ASPSamp\\AdvWorks");

    switch (m_eInstallMode) 
    {
        case IM_DEGRADE:
        case IM_FRESH:
            // use the initialized values
            break;
        case IM_UPGRADE:
        case IM_MAINTENANCE:
            {
                // override, what ever we just set above!
                GetOldIISDirs();
                break;
            }
    }
}

void CInitApp::SetInetpubDir()
{
    m_csPathInetpub = m_csSysDrive + _T("\\Inetpub");
    // Check if the user wants to override this with a unattend setting
    Check_Custom_InetPub();
}

void CInitApp::ResetWAMPassword()
{
    LPTSTR pszPassword = NULL;
    // create a iwam password
    pszPassword = CreatePassword(LM20_PWLEN+1);
    if (pszPassword)
    {
        m_csWAMAccountPassword = pszPassword;
        GlobalFree(pszPassword);pszPassword = NULL;
    }
}

// Init/Set m_csGuestName, m_csGuestPassword, destinations
// -------------------------------------------------------
void CInitApp::SetSetupParams()
{
    // check if the debug level is set in the unattend file
    // ----------------------------------------------------
    Check_For_DebugLevel();

    // init m_csGuestName as IUSR_MachineName, init m_csGuestPassword as a random password
    TCHAR szGuestName[UNLEN+1];
    memset( (PVOID)szGuestName, 0, sizeof(szGuestName));

    CString csMachineName;
    csMachineName = m_csMachineName;
    csMachineName = csMachineName.Right(csMachineName.GetLength() - 2);
    LPTSTR pszPassword = NULL;

    // create a default guest name
    CString strDefGuest;
    MyLoadString( IDS_GUEST_NAME, strDefGuest);
    strDefGuest += csMachineName;
    _tcsncpy( szGuestName, (LPCTSTR) strDefGuest, LM20_UNLEN+1);
    m_csGuestName = szGuestName;
    // create a default guest password
    pszPassword = CreatePassword(LM20_PWLEN+1);
    if (pszPassword)
    {
        m_csGuestPassword = pszPassword;
        GlobalFree(pszPassword);pszPassword = NULL;
    }

    // Set the ftp/www users to use this default specified one...
    m_csWWWAnonyName = m_csGuestName;
    m_csWWWAnonyPassword = m_csGuestPassword;
    m_csFTPAnonyName = m_csGuestName;
    m_csFTPAnonyPassword = m_csGuestPassword;


     // init all 4 destinations
    m_csPathInetsrv = m_csSysDir + _T("\\inetsrv");

    m_csPathIASDocs = m_csPathInetsrv + _T("\\Docs");
    m_csPathProgramFiles = m_csSysDrive + _T("\\Program Files");
    CRegKey regCurrentVersion(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion"), KEY_READ);
    if ( (HKEY)regCurrentVersion ) 
    {
        if (regCurrentVersion.QueryValue(_T("ProgramFilesDir"), m_csPathProgramFiles) != 0)
            {m_csPathProgramFiles = m_csSysDrive + _T("\\Program Files");}
        else
        {
            if (-1 != m_csPathProgramFiles.Find(_T('%')) )
            {
                // there is a '%' in the string
                TCHAR szTempDir[_MAX_PATH];
                _tcscpy(szTempDir, m_csPathProgramFiles);
                if (ExpandEnvironmentStrings( (LPCTSTR)m_csPathProgramFiles, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                    {
                    m_csPathProgramFiles = szTempDir;
                    }
            }
        }
    }

    CRegKey regCurrentVersionSetup(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"), KEY_READ);
    if ( (HKEY)regCurrentVersionSetup ) 
    {
        // Get NT installation path
        if (regCurrentVersionSetup.QueryValue(_T("SourcePath"), m_csPathNTSrcDir) != 0)
            {m_csPathNTSrcDir = m_csSysDrive + _T("\\$WIN_NT$.~LS");}
        else
        {
            if (-1 != m_csPathNTSrcDir.Find(_T('%')) )
            {
                // there is a '%' in the string
                TCHAR szTempDir[_MAX_PATH];
                _tcscpy(szTempDir, m_csPathNTSrcDir);
                if (ExpandEnvironmentStrings( (LPCTSTR)m_csPathNTSrcDir, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                    {
                    m_csPathNTSrcDir = szTempDir;
                    }
            }
        }
    }


//#ifdef _CHICAGO_
    if (m_eUpgradeType == UT_10_W95) 
    {
        BOOL bOSR2 = TRUE; 
        CRegKey regVersion(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"), KEY_READ);
        if ((HKEY)regVersion) 
        {
            CString csString;
            // VersionNumber for OSR2 is 4.00.1111
            // VersionNumber for the original win95 is 4.00.950
            if (regVersion.QueryValue(_T("VersionNumber"), csString) == ERROR_SUCCESS) 
            {
                if (csString.Compare(_T("4.00.950")) == 0)
                    bOSR2 = FALSE;
            }
        }

        if (!bOSR2) 
        {
            g_pTheApp->m_csPathOldPWSFiles = m_csPathProgramFiles + _T("\\WebSvr");
            g_pTheApp->m_csPathOldPWSSystemFiles = m_csPathProgramFiles + _T("\\WebSvr\\System");
        }
        else 
        {
            g_pTheApp->m_csPathOldPWSFiles = m_csPathProgramFiles + _T("\\Personal Web Server");
            g_pTheApp->m_csPathOldPWSSystemFiles = m_csPathProgramFiles + _T("\\Personal Web Server\\WebServer");
        }
    }
//#endif //_CHICAGO

    return;
}

// Get Platform info
void CInitApp::GetPlatform()
{
    if ( m_eOS == OS_NT)
    {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        m_csPlatform = _T("x86");
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {m_csPlatform = _T("x86");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {m_csPlatform = _T("IA64");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {m_csPlatform = _T("AMD64");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_UNKNOWN) {m_csPlatform = _T("UNKNOWN");}

        // save the number of processors for this machine.
        m_dwNumberOfProcessors = si.dwNumberOfProcessors;

/* old
        TCHAR *p = _tgetenv(_T("PROCESSOR_ARCHITECTURE"));
        if ( p ) 
            {m_csPlatform = p;}
        else
            {m_csPlatform = _T("x86");}
*/
    }
    return;
}

BOOL CInitApp::GetMachineStatus()
{
    if ( ( !GetMachineName() )  ||    // m_csMachineName
         ( !GetOS() )           ||    // m_fOSNT
         ( !GetOSVersion() )    ||    // NT 4.0 (Build 1381) or greater
         ( !GetOSType() )       ||    // m_eOSType = NT_SRV or NT_WKS
         ( !GetSysDirs() )      ||    // m_csWinDir. m_csSysDir
         ( !IsTCPIPInstalled()) ||    // errmsg: if NO TCPIP is installed
         ( !SetInstallMode()) )       // errmsg: if down grade the product      
    {
        return FALSE;
    }

    SetSetupParams(); // Guest account, destinations
    ReGetMachineAndAccountNames();
    ResetWAMPassword();
    SetInetpubDir();
    SetInetpubDerivatives();
    UnInstallList_RegRead(); // Get Uninstall information
    UnInstallList_SetVars(); // set member variables for uninstall info
    // check for any unattend file\custom settings.
    Check_Unattend_Settings();

    GetPlatform();

    GetUserDomain();

    return TRUE;
}

int CInitApp::MsgBox(HWND hWnd, int iID, UINT nType, BOOL bGlobalTitle)
{
    if (iID == -1) {return IDOK;}

    CString csMsg, csTitle;
    MyLoadString(iID, csMsg);
    csTitle = m_csAppName;
    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CInitApp::MsgBox('%1!s!')\n"), csMsg));

    return (::MessageBoxEx(NULL, (LPCTSTR)csMsg, csTitle, nType | MB_SETFOREGROUND, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT)));
}

int CInitApp::MsgBox2(HWND hWnd, int iID,CString csInsertionString,UINT nType)
{
    if (iID == -1) {return IDOK;}
    CString csFormat, csMsg, csTitle;
    MyLoadString(iID, csFormat);
    csMsg.Format(csFormat, csInsertionString);
    csTitle = m_csAppName;
    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CInitApp::MsgBox2('%1!s!')\n"), csMsg));

    return (::MessageBoxEx(NULL, (LPCTSTR)csMsg, csTitle, nType | MB_SETFOREGROUND, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT)));
}

BOOL CInitApp::InitApplication()
// Return Value:
// TRUE: application is initiliazed correctly, continue processing
// FALSE: application is missing some required parameters, like the correct OS, TCPIP, etc.
//        setup should be terminated.
{
    BOOL fReturn = FALSE;

    do {
        // Get Machine Status: 
        // m_eInstallMode(Fresh, Maintenance, Upgrade, Degrade), 
        // m_eUpgradeType(PROD 2.0, PROD 3.0)

        if ( !GetMachineStatus() )
        {
            CString csMsg;
            MyLoadString(m_err, csMsg);
            ::MessageBoxEx(NULL, (LPCTSTR)csMsg, (LPCTSTR) g_pTheApp->m_csAppName , MB_SETFOREGROUND, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT));

            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("GetMachineStatus(); MessageBoxEx('%1!s!') FAILER\n"), csMsg));
            break;
        }

        if ( g_pTheApp->m_eInstallMode == IM_MAINTENANCE )
            {g_pTheApp->m_fEULA = TRUE;}

        fReturn = TRUE;

    } while (0);

    return fReturn;
}



// open the tcp/ip registry key 
// if it's there then tcp/ip is installed
int TCPIP_Check_Temp_Hack(void)
{
    int TheReturn = FALSE;

    CRegKey regTheKey(HKEY_LOCAL_MACHINE,_T("System\\CurrentControlSet\\Services\\Tcpip"),KEY_READ);
    if ((HKEY) regTheKey)
    {
        TheReturn = TRUE;
    }

    if (FALSE == TheReturn)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("DETECT:TCPIP not Installed (yet), but we'll proceed as if it were.")));
        TheReturn = TRUE;
    }
    
    return TheReturn;
}

void GetUserDomain(void)
{
    HANDLE hProcess, hAccessToken;
    TCHAR InfoBuffer[1000],szAccountName[200], szDomainName[200];
    
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    DWORD   dwInfoBufferSize;
    DWORD   dwAccountSize = sizeof(szAccountName)/sizeof(szAccountName[0]);
    DWORD   dwDomainSize = sizeof(szDomainName)/sizeof(szDomainName[0]);
    SID_NAME_USE snu;

    hProcess = GetCurrentProcess();
    OpenProcessToken(hProcess,TOKEN_READ,&hAccessToken);
    GetTokenInformation(hAccessToken,TokenUser,InfoBuffer,1000, &dwInfoBufferSize);
    if (LookupAccountSid(NULL, pTokenUser->User.Sid, szAccountName,&dwAccountSize,szDomainName, &dwDomainSize, &snu))
    {
        if (dwDomainSize)
        {
            g_pTheApp->m_csUsersDomain = szDomainName;
            //_tcscpy(g_szUsersDomain, szDomainName);
        }
        else 
        {
            g_pTheApp->m_csUsersDomain = _T(" ");
            //_tcscpy(g_szUsersDomain, _T(" "));
        }

        if (dwDomainSize)
        {
            g_pTheApp->m_csUsersAccount = szAccountName;
            //_tcscpy(g_szUsersAccount, szAccountName);        
        }
        else
        {
            g_pTheApp->m_csUsersAccount = _T(" ");
        }
    }
}

// This function should only be called in FRESH NT5 setup.
void CInitApp::ReGetMachineAndAccountNames()
{
    GetMachineName();

    // re-calculate the IUSR_ and IWAM_ account names
    TCHAR szGuestName[UNLEN+1];
    memset( (PVOID)szGuestName, 0, sizeof(szGuestName));

    CString csMachineName;
    csMachineName = m_csMachineName;
    csMachineName = csMachineName.Right(csMachineName.GetLength() - 2);
    CString strDefGuest;

    MyLoadString( IDS_GUEST_NAME, strDefGuest);
    strDefGuest += csMachineName;
    _tcsncpy( szGuestName, (LPCTSTR) strDefGuest, LM20_UNLEN+1);
    m_csGuestName = szGuestName;

    MyLoadString( IDS_WAM_ACCOUNT_NAME, strDefGuest);
    strDefGuest += csMachineName;
    _tcsncpy( szGuestName, (LPCTSTR) strDefGuest, LM20_UNLEN+1);
    m_csWAMAccountName = szGuestName;
}

void CInitApp::DumpAppVars(void)
{
    int iDoOnlyInThisMode = LOG_TYPE_TRACE;

    // only do this if the debug mode is trace.
    if (g_GlobalDebugLevelFlag >= iDoOnlyInThisMode)
    {

    iisDebugOut((iDoOnlyInThisMode, _T("=======================\n")));
   
    // machine status
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csMachineName=%1!s!\n"), m_csMachineName));
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csUsersDomain=%1!s!\n"), m_csUsersDomain));
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csUsersAccount=%1!s!\n"), m_csUsersAccount));

    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csWinDir=%1!s!\n"), m_csWinDir));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csSysDir=%1!s!\n"), m_csSysDir));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csSysDrive=%1!s!\n"), m_csSysDrive));;

    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathNTSrcDir=%1!s!\n"), m_csPathNTSrcDir));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathSource=%1!s!\n"), m_csPathSource));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathOldInetsrv=%1!s!\n"), m_csPathOldInetsrv));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathInetsrv=%1!s!\n"), m_csPathInetsrv));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathInetpub=%1!s!\n"), m_csPathInetpub));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathFTPRoot=%1!s!\n"), m_csPathFTPRoot));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathWWWRoot=%1!s!\n"), m_csPathWWWRoot));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathWebPub=%1!s!\n"), m_csPathWebPub));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathProgramFiles=%1!s!\n"), m_csPathProgramFiles));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathIISSamples=%1!s!\n"), m_csPathIISSamples));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathScripts=%1!s!\n"), m_csPathScripts));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathASPSamp=%1!s!\n"), m_csPathASPSamp));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathAdvWorks=%1!s!\n"), m_csPathAdvWorks));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathIASDocs=%1!s!\n"), m_csPathIASDocs));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathOldPWSFiles=%1!s!\n"), m_csPathOldPWSFiles));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathOldPWSSystemFiles=%1!s!\n"), m_csPathOldPWSSystemFiles));;
    
    if (m_eOS == OS_NT) {iisDebugOut((iDoOnlyInThisMode, _T("OS=NT\n")));}
    if (m_eOS == OS_W95) {iisDebugOut((iDoOnlyInThisMode, _T("OS=W95\n")));}
    if (m_eOS == OS_OTHERS) {iisDebugOut((iDoOnlyInThisMode, _T("OS=OTHER\n")));}

    if (m_eNTOSType == OT_NTW){iisDebugOut((iDoOnlyInThisMode, _T("m_eNTOSType=OT_NTW (Workstation)\n")));}
    if (m_eNTOSType == OT_NTS){iisDebugOut((iDoOnlyInThisMode, _T("m_eNTOSType=OT_NTS (Server)\n")));}
    if (m_eNTOSType == OT_PDC_OR_BDC){iisDebugOut((iDoOnlyInThisMode, _T("m_eNTOSType=OT_PDC_OR_BDC (Primary/Backup Domain Controller)\n")));}

    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPlatform=%1!s!\n"), m_csPlatform));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_dwNumberOfProcessors=%1!d!\n"), m_dwNumberOfProcessors));;

    if (m_fNT5) {iisDebugOut((iDoOnlyInThisMode, _T("OSVersion=5\n")));}
    if (m_fW95) {iisDebugOut((iDoOnlyInThisMode, _T("OSVersion=Win95\n")));}
    iisDebugOut((iDoOnlyInThisMode, _T("m_dwOSBuild=%d\n"), m_dwOSBuild));
    iisDebugOut((iDoOnlyInThisMode, _T("m_dwOSServicePack=0x%x\n"), m_dwOSServicePack));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fTCPIP Exists=%d\n"), m_fTCPIP));

    if (m_eUpgradeType == UT_NONE){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_NONE\n")));}
    if (m_eUpgradeType == UT_10_W95){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_10_W95\n")));}
    if (m_eUpgradeType == UT_351){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_351\n")));}
    if (m_eUpgradeType == UT_10){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_10\n")));}
    if (m_eUpgradeType == UT_20){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_20\n")));}
    if (m_eUpgradeType == UT_30){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_30\n")));}
    if (m_eUpgradeType == UT_40){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_40\n")));}
    if (m_eUpgradeType == UT_50){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_50\n")));}
    if (m_eUpgradeType == UT_51){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_51\n")));}
    if (m_eUpgradeType == UT_60){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_60\n")));}

    if (m_eInstallMode == IM_FRESH){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_FRESH\n")));}
    if (m_eInstallMode == IM_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_UPGRADE\n")));}
    if (m_eInstallMode == IM_MAINTENANCE){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_MAINTENANCE\n")));}
    if (m_eInstallMode == IM_DEGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_DEGRADE\n")));}

    if (m_dwSetupMode & SETUPMODE_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_UPGRADE\n")));}
    if (m_dwSetupMode == SETUPMODE_UPGRADEONLY){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_UPGRADEONLY\n")));}
    if (m_dwSetupMode == SETUPMODE_ADDEXTRACOMPS){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_ADDEXTRACOMPS\n")));}
    if (m_dwSetupMode & SETUPMODE_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_bUpgradeTypeHasMetabaseFlag=%d\n"),m_bUpgradeTypeHasMetabaseFlag));}

    if (m_dwSetupMode & SETUPMODE_MAINTENANCE){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE\n")));}
    if (m_dwSetupMode == SETUPMODE_ADDREMOVE){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_ADDREMOVE\n")));}
    if (m_dwSetupMode == SETUPMODE_REINSTALL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REINSTALL\n")));}
    if (m_dwSetupMode == SETUPMODE_REMOVEALL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REMOVEALL\n")));}

    if (m_dwSetupMode & SETUPMODE_FRESH){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH\n")));}
    if (m_dwSetupMode == SETUPMODE_MINIMAL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_MINIMAL\n")));}
    if (m_dwSetupMode == SETUPMODE_TYPICAL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_TYPICAL\n")));}
    if (m_dwSetupMode == SETUPMODE_CUSTOM){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_CUSTOM\n")));}

    iisDebugOut((iDoOnlyInThisMode, _T("m_bPleaseDoNotInstallByDefault=%d\n"), m_bPleaseDoNotInstallByDefault));
    
    //if (m_bRefreshSettings == TRUE){iisDebugOut((iDoOnlyInThisMode, _T("m_bRefreshSettings=refresh files + refresh all settings\n")));}
    //if (m_bRefreshSettings == FALSE){iisDebugOut((iDoOnlyInThisMode, _T("m_bRefreshSettings=refresh files only\n")));}

    if (m_eAction == AT_DO_NOTHING){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_DO_NOTHING\n")));}
    if (m_eAction == AT_REMOVE){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_REMOVE\n")));}
    if (m_eAction == AT_INSTALL_FRESH){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_INSTALL_FRESH\n")));}
    if (m_eAction == AT_INSTALL_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_INSTALL_UPGRADE\n")));}
    if (m_eAction == AT_INSTALL_REINSTALL){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_INSTALL_REINSTALL\n")));}

    iisDebugOut((iDoOnlyInThisMode, _T("m_fNTOperationFlags=0x%x\n"), m_fNTOperationFlags));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fNTGuiMode=%d\n"), m_fNTGuiMode));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fInvokedByNT=%d\n"), m_fInvokedByNT));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fNtWorkstation=%d\n"), m_fNtWorkstation));

    iisDebugOut((iDoOnlyInThisMode, _T("m_fUnattended=%d\n"), m_fUnattended));
    iisDebugOut((iDoOnlyInThisMode, _T("m_csUnattendFile=%s\n"), m_csUnattendFile));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathSrcDir=%1!s!\n"), m_csPathSrcDir));;
    iisDebugOut((iDoOnlyInThisMode, _T("=======================\n")));

    }
    return;
}


int AreWeCurrentlyInstalled()
{
    int iReturn = FALSE;
    DWORD dwMajorVersion = 0;

    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regINetStp)
    {
        LONG lReturnedErrCode = regINetStp.QueryValue(_T("MajorVersion"), dwMajorVersion);
        if (lReturnedErrCode == ERROR_SUCCESS)
        {
            if (dwMajorVersion == 5) 
            {
                iReturn = TRUE;
            }
        }
    }
    return iReturn;
}


#define sz_PreviousIISVersion_string _T("PreviousIISVersion")
int CInitApp::SetUpgradeType(void)
{
    int iReturn = FALSE;
    DWORD dwMajorVersion = 0;
    DWORD dwMinorVersion = 0;
    CString csFrontPage;

    m_eInstallMode = IM_UPGRADE;
    m_eUpgradeType = UT_NONE;
    m_bUpgradeTypeHasMetabaseFlag = FALSE;
    m_bPleaseDoNotInstallByDefault = TRUE;

    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regINetStp)
    {
        LONG lReturnedErrCode = regINetStp.QueryValue(_T("MajorVersion"), dwMajorVersion);
        if (lReturnedErrCode == ERROR_SUCCESS)
        {
            if (dwMajorVersion <= 1)
            {
                m_eUpgradeType = UT_10;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 2)
            {
                m_eUpgradeType = UT_20;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 3)
            {
                m_eUpgradeType = UT_30;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 4)
            {
                CString csSetupString;
                m_eUpgradeType = UT_40; 
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = TRUE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                regINetStp.m_iDisplayWarnings = FALSE;
                if (regINetStp.QueryValue(_T("SetupString"), csSetupString) == NERR_Success) 
                {
                    if (csSetupString.CompareNoCase(_T("K2 RTM")) != 0) 
                    {
                        // Error: upgrade not supported on K2 Beta versions
                        // Do a fresh if it's k2 beta2!!!!
                        m_eInstallMode = IM_FRESH;
                        m_eUpgradeType = UT_NONE;
                        m_bUpgradeTypeHasMetabaseFlag = FALSE;
                        m_bPleaseDoNotInstallByDefault = FALSE;
                        iReturn = FALSE;
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.Beta2.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                        goto SetUpgradeType_Exit;
                    }
                }
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 5) 
            {
                // There is a previous version of iis5 on the machine...
                // Could be they are upgrading from nt5Workstation to and nt5Server machine!
                // or from and server to a workstation!  what a nightmare!!!
                //m_eInstallMode = IM_FRESH;
                m_eUpgradeType = UT_50;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = TRUE;
                m_bPleaseDoNotInstallByDefault = FALSE;

                regINetStp.m_iDisplayWarnings = FALSE;
                if (regINetStp.QueryValue(_T("MinorVersion"), dwMinorVersion) == NERR_Success) 
                {
                    if (dwMinorVersion >= 1)
                    {
	                m_eUpgradeType = UT_51;
        	        m_eInstallMode = IM_UPGRADE;
                	m_bUpgradeTypeHasMetabaseFlag = TRUE;
	                m_bPleaseDoNotInstallByDefault = FALSE;
                    }
                }
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.0x%x\n"),sz_PreviousIISVersion_string, dwMajorVersion,dwMinorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 6) 
            {
                // There is a previous version of iis5 on the machine...
                // Could be they are upgrading from nt5Workstation to and nt5Server machine!
                // or from and server to a workstation!  what a nightmare!!!
                //m_eInstallMode = IM_FRESH;
                m_eUpgradeType = UT_60;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = TRUE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.0x%x\n"),sz_PreviousIISVersion_string, dwMajorVersion,dwMinorVersion));
                goto SetUpgradeType_Exit;
            }

            if (dwMajorVersion > 6)
            {
                m_eInstallMode = IM_UPGRADE;
                m_eUpgradeType = UT_60;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = TRUE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.0x%x\n"),sz_PreviousIISVersion_string, dwMajorVersion,dwMinorVersion));
                goto SetUpgradeType_Exit;
            }

            // if we get here, then that means
            // that we found a version like 7.0 or something
            // which we should not upgrade since it is newer than us.
            // but hey we're in upgrade mode, so we should set something
            m_eInstallMode = IM_UPGRADE;
            m_eUpgradeType = UT_NONE;
            m_bUpgradeTypeHasMetabaseFlag = FALSE;
            m_bPleaseDoNotInstallByDefault = TRUE;
            iReturn = FALSE;
            iisDebugOut((LOG_TYPE_TRACE, _T("%s=some other iis version\n"),sz_PreviousIISVersion_string));
        }
    }

    // -----------------------------------
    //
    // Check for other Rogue versions of IIS
    // 
    // win95 pws 1.0
    // win95 fontpage installed pws 1.0 (actually totally different from pws 1.0)
    //
    // on NT5 we are able to upgrade from:
    //   Win95 pws 1.0
    //   Win95 pws 4.0
    // on win95 pws 1.0, there was no inetstp dir
    // so we must check other things.
    // -----------------------------------
    {
    CRegKey regW3SVC(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_READ);
    if ((HKEY)regW3SVC) 
    {
        CByteArray baMajorVersion;
        regW3SVC.m_iDisplayWarnings = FALSE;
        if (regW3SVC.QueryValue(_T("MajorVersion"), baMajorVersion) == NERR_Success) 
        {
            // Check if we can read the MajorVersion value should be set to '\0' if pws 1.0
            if (baMajorVersion[0] == '\0')
            {
                m_eUpgradeType = UT_10_W95;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=1.\n"),sz_PreviousIISVersion_string));
                goto SetUpgradeType_Exit;
            }
        }
    }
    }

    //
    // on win 95 there could be an
    // installation of frontpg pws version 1.0
    // we don't support upgrading this, so we'll do a fresh if we ever get here.
    //
    csFrontPage = g_pTheApp->m_csSysDir + _T("\\frontpg.ini");
    if (IsFileExist(csFrontPage)) 
    {
        TCHAR buf[_MAX_PATH];
        GetPrivateProfileString(_T("FrontPage 1.1"), _T("PWSRoot"), _T(""), buf, _MAX_PATH, csFrontPage);
        if (*buf && IsFileExist(buf)) 
        {
            m_eInstallMode = IM_FRESH;
            m_eUpgradeType = UT_NONE;
            m_bUpgradeTypeHasMetabaseFlag = FALSE;
            m_bPleaseDoNotInstallByDefault = FALSE;
            iReturn = TRUE;
            iisDebugOut((LOG_TYPE_TRACE, _T("%s=1.FrontPage Installation.\n"),sz_PreviousIISVersion_string));
            goto SetUpgradeType_Exit;
        }
    }

    //
    // This could be an upgrade from WinNT 3.51
    // which could have an FTPSVC installed.
    // if it's here then install ftp.
    // Software\Microsoft\FTPSVC
    //
    {
    CRegKey regNT351FTP(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\FTPSVC"), KEY_READ);
    if ((HKEY) regNT351FTP)
    {
        m_eUpgradeType = UT_351;
        m_eInstallMode = IM_UPGRADE;
        m_bUpgradeTypeHasMetabaseFlag = FALSE;
        m_bPleaseDoNotInstallByDefault = FALSE;
        iReturn = TRUE;
        iisDebugOut((LOG_TYPE_TRACE, _T("%s=NT351.ftp.\n"),sz_PreviousIISVersion_string));
        goto SetUpgradeType_Exit;
    }
    }

    // if we get here...then
    // 1. we were not able to open the inetsrv reg
    // 2. did not find an old pws 1.0 installation
    // 3. did not find an old frontpg pws installation.
    // 4. did not find nt 3.51 FTPSVC installed.

    // since this is supposed to set the upgrade type, and there is nothing to upgrade...
    // then we will Not install.....
    //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("FRESH FRESH FRESH\n")));
    m_eInstallMode = IM_UPGRADE;
    m_eUpgradeType = UT_NONE;
    m_bUpgradeTypeHasMetabaseFlag = FALSE;
    m_bPleaseDoNotInstallByDefault = TRUE;
    iisDebugOut((LOG_TYPE_TRACE, _T("%s=None.\n"),sz_PreviousIISVersion_string));
    iReturn = FALSE;

SetUpgradeType_Exit:
    return iReturn;
}


int CInitApp::Check_Custom_InetPub(void)
{
    int         iReturn = FALSE;
    INFCONTEXT  Context;
    TSTR        strSectionName( MAX_PATH );
    TSTR_PATH   strCustomInetpub( MAX_PATH );

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) 
    {
      return iReturn;
    }

    // The section name to look for in the unattended file
    if ( !strSectionName.Copy( UNATTEND_FILE_SECTION ) )
    {
      return iReturn;
    }

    //
    // InetPub
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("PathInetpub"), &Context) &&
         SetupGetStringField(&Context, 1, strCustomInetpub.QueryStr() , strCustomInetpub.QuerySize(), NULL) &&
         strCustomInetpub.ExpandEnvironmentVariables() )
    {
      if (IsValidDirectoryName(strCustomInetpub.QueryStr()))
      {
        iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_InetPub:PathInetpub=%s\n"), strCustomInetpub.QueryStr() ));
        m_csPathInetpub = strCustomInetpub.QueryStr();
        iReturn = TRUE;
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_INETPUB;
      }
      else
      {
        iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_InetPub:PathInetpub=%s.Not Valid.ignoring unattend value. WARNING.\n"),strCustomInetpub.QueryStr()));
      }
    }

    return iReturn;
}


void CInitApp::Check_Unattend_Settings(void)
{
    // if there are unattended values specified for the ftp or www root,
    // then set them here.
    Check_Custom_WWW_or_FTP_Path();
    DeriveInetpubFromWWWRoot();

    // Check if there is an alternate iis.inf specified in the unattend file.
    // this way the user can change sections in the iis.inf file without changing the iis.inf file itself
    Check_Custom_IIS_INF();

    // Check if the user wants to use a specific iusr\iwam name.
    Check_Custom_Users();

	// Check if the user wants to not automatically start WWW and/or FTP services
	Check_SvcManualStart();

    // Check if user wants applications setup in inprocess by default (not pooled out of process)

    return;
}


void Check_SvcManualStart()
{
	// Unattend flag format
	// SvcManualStart=WWW,FTP

	INFCONTEXT Context;
	TCHAR szSectionName[_MAX_PATH];
	TCHAR szValue[_MAX_PATH] = _T("");

	// Do this only if unattended install
    if ( !g_pTheApp->m_fUnattended ) return;

	// The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

	if ( !SetupFindFirstLine_Wrapped( g_pTheApp->m_hUnattendFile, szSectionName, _T("SvcManualStart"), &Context) ) 
	{
		// No such line
		return;
	}

	int i = 1;	// This is the specific part of the line ( www, ftp )

	while( SetupGetStringField( &Context, i++, szValue, _MAX_PATH, NULL ) )
	{
		if ( *szValue )
		{
			if ( ::_tcsicmp( szValue, _T("WWW") ) == 0 )
			{
				g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_MANUAL_START_WWW;
				iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Manual start requested for WWW service\n")));
			}
			else if ( ::_tcsicmp( szValue, _T("FTP") ) == 0 )
			{
				g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_MANUAL_START_FTP;
				iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Manual start requested for FTP service\n")));
			}
		}	
	}
}



void Check_Custom_Users(void)
{
    INFCONTEXT Context;
    TSTR       strSectionName( MAX_PATH );
    TSTR_PATH  strValue( MAX_PATH );

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) 
    {
      return;
    }

    // The section name to look for in the unattended file
    if ( !strSectionName.Copy( UNATTEND_FILE_SECTION ) )
    {
      return;
    }

    //
    // IUSR:  BOTH FTP AND WWW
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IUSR"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      if (_tcsicmp(strValue.QueryStr(), _T("")) != 0)
      {
        // assign it to the appropriate member variables.
        g_pTheApp->m_csWWWAnonyName_Unattend = strValue.QueryStr();
        g_pTheApp->m_csFTPAnonyName_Unattend = strValue.QueryStr();

        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr specified for ftp/www\n")));
      }
    }

    //
    // IUSR:  BOTH FTP AND WWW password
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IUSR_PASS"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      // assign it to the appropriate member variables.
      if (_tcsicmp(strValue.QueryStr(), _T("")) != 0)
      {
        g_pTheApp->m_csWWWAnonyPassword_Unattend = strValue.QueryStr();
        g_pTheApp->m_csFTPAnonyPassword_Unattend = strValue.QueryStr();

        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr pass specified for ftp/www\n"))); 
      }
    }

    //
    // IUSR: FTP
    // If there a value specified here, then it will override the one taken from "IUSR"
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IUSR_FTP"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      if (_tcsicmp(strValue.QueryStr(), _T("")) != 0)
      {
        // assign it to the appropriate member variables.
        g_pTheApp->m_csFTPAnonyName_Unattend = strValue.QueryStr();

        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr specified for ftp\n"))); 
      }
    }

    //
    // IUSR: FTP password
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IUSR_FTP_PASS"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      if (_tcsicmp(strValue.QueryStr(), _T("")) != 0)
      {
        // assign it to the appropriate member variables.
        g_pTheApp->m_csFTPAnonyPassword_Unattend = strValue.QueryStr();
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr pass specified for ftp\n"))); 
      }

    }

    //
    // IUSR: WWW
    // If there a value specified here, then it will override the one taken from "IUSR"
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IUSR_WWW"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      // assign it to the appropriate member variables.
      g_pTheApp->m_csWWWAnonyName_Unattend = strValue.QueryStr();
      g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
      //g_pTheApp->m_csWWWAnonyPassword_Unattend = _T("");
      iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr specified for www\n"))); 
    }

    //
    // IUSR: WWW password
    // If there a value specified here, then it will override the one taken from "IUSR"
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IUSR_WWW_PASS"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      if (_tcsicmp(strValue.QueryStr(), _T("")) != 0)
      {
        // assign it to the appropriate member variables.
        g_pTheApp->m_csWWWAnonyPassword_Unattend = strValue.QueryStr();
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr pass specified for www\n"))); 
      }
    }

    //
    // IWAM: WWW
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IWAM"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      // assign it to the appropriate member variables.
      g_pTheApp->m_csWAMAccountName_Unattend = strValue.QueryStr();
      g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_NAME;

      iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iwam specified\n"))); 
    }

    //
    // IWAM: WWW password
    //
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, strSectionName.QueryStr(), _T("IWAM_PASS"), &Context) &&
         SetupGetStringField(&Context, 1, strValue.QueryStr() , strValue.QuerySize(), NULL) &&
         strValue.ExpandEnvironmentVariables() )
    {
      if (_tcsicmp(strValue.QueryStr(), _T("")) != 0)
      {
        // assign it to the appropriate member variables.
        g_pTheApp->m_csWAMAccountPassword_Unattend = strValue.QueryStr();
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_PASS;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iwam pass specified\n"))); 
      }
    }

    return;
}


// reads the registry and fills up the list
void CInitApp::UnInstallList_RegRead()
{
    int iGetOut = FALSE;
    CString csBoth;
    CString csKey;
    CString csData;

    CRegKey regInetstp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regInetstp)
    {
        int iPosition1;
        int iLength;
        CString csUninstallInfo;
        LONG lReturnedErrCode = regInetstp.QueryValue( REG_SETUP_UNINSTALLINFO, csUninstallInfo);
        if (lReturnedErrCode == ERROR_SUCCESS)
        {
            // add a "," to the end for parsing...
            iLength = csUninstallInfo.GetLength();
            if (iLength == 0)
            {
                goto UnInstallList_RegRead_Exit;
            }
            csUninstallInfo += _T(",");

            iPosition1 = 0;
#ifdef _CHICAGO_
            // quick fix so that it compiles under ansi
            // i guess Find(parm1,parm2) under ansi doesn't take 2 parms
#else
            int iPosition2;
            int iPosition3;

            iPosition1 = 0;
            iPosition2 = csUninstallInfo.Find(_T(','),iPosition1);
            iPosition3 = csUninstallInfo.Find(_T(','),iPosition2+1);
            if (-1 == iPosition3){iPosition3 = iLength + 1;}
            
            // loop thru and add to our list!
            iGetOut = FALSE;
            while (iGetOut == FALSE)
            {
                csKey = csUninstallInfo.Mid(iPosition1, iPosition2 - iPosition1);
                csData = csUninstallInfo.Mid(iPosition2+1, iPosition3 - (iPosition2 + 1));
                csKey.MakeUpper(); // uppercase the key
                //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_RegRead: %s=%s\n"),csKey,csData));

                // add to our list
                m_cmssUninstallMapList.SetAt(csKey, csData);

                iPosition1 = iPosition3+1;
                iPosition2 = csUninstallInfo.Find(_T(','),iPosition1);
                if (-1 == iPosition2){iGetOut = TRUE;}
                
                iPosition3 = csUninstallInfo.Find(_T(','),iPosition2+1);
                if (-1 == iPosition3)
                {
                    iPosition3 = iLength + 1;
                    iGetOut = TRUE;
                }
            }
#endif
        }
    }
UnInstallList_RegRead_Exit:
    m_fUninstallMapList_Dirty = FALSE;
    return;
}

void CInitApp::UnInstallList_RegWrite()
{
    int i = 0;
    POSITION pos;
    CString csKey;
    CString csData;
    CString csAllData;
    csAllData = _T("");

    if (TRUE == m_fUninstallMapList_Dirty)
    {
        // loop thru the list to see if, we already have this entry
        if (m_cmssUninstallMapList.IsEmpty())
        {
            CRegKey regInetstp(REG_INETSTP,HKEY_LOCAL_MACHINE);
            if ((HKEY) regInetstp)
                {regInetstp.DeleteValue(REG_SETUP_UNINSTALLINFO);}
            //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_RegWrite: empty\n")));
        }
        else
        {
            pos = m_cmssUninstallMapList.GetStartPosition();
            while (pos)
            {
                i++;
                csKey.Empty();
                csData.Empty();
                m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);
                if (i > 1)
                {
                    csAllData += _T(",");
                }
                csAllData += csKey;
                csAllData += _T(",");
                csAllData += csData;
            }
            // write out csAllData
            CRegKey regInetstp(REG_INETSTP,HKEY_LOCAL_MACHINE);
            if ((HKEY) regInetstp)
            {
                regInetstp.SetValue(REG_SETUP_UNINSTALLINFO,csAllData);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("UnInstallList_RegWrite: failed! not writen!!!\n")));
            }
        }
    }
}

void CInitApp::UnInstallList_Add(CString csItemUniqueKeyName,CString csDataToAdd)
{
    CString csGottenValue;

    csItemUniqueKeyName.MakeUpper(); // uppercase the key
    if (TRUE == m_cmssUninstallMapList.Lookup(csItemUniqueKeyName, csGottenValue))
    {
        // found the key, replace the value
        m_cmssUninstallMapList.SetAt(csItemUniqueKeyName, csDataToAdd);
    }
    else
    {
        // add the key and value pair
        m_cmssUninstallMapList.SetAt(csItemUniqueKeyName, csDataToAdd);
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("UnInstallList_Add:please addkey=%s,%s\n"),csItemUniqueKeyName,csDataToAdd));
    m_fUninstallMapList_Dirty = TRUE;
}

void CInitApp::UnInstallList_DelKey(CString csItemUniqueKeyName)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("UnInstallList_DelKey:please delkey=%s\n"),csItemUniqueKeyName));
    csItemUniqueKeyName.MakeUpper(); // uppercase the key
    m_cmssUninstallMapList.RemoveKey(csItemUniqueKeyName);
    m_fUninstallMapList_Dirty = TRUE;
}


void CInitApp::UnInstallList_DelData(CString csDataValue)
{
    POSITION pos;
    CString csKey;
    CString csData;
    
    // loop thru the list to see if, we already have this entry
    if (m_cmssUninstallMapList.IsEmpty())
    {
    }
    else
    {
        pos = m_cmssUninstallMapList.GetStartPosition();
        while (pos)
        {
            csKey.Empty();
            csData.Empty();
            m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);
            if ( _tcsicmp(csData, csDataValue) == 0)
            {
                UnInstallList_DelKey(csKey);
            }
        }
    }
}


void CInitApp::UnInstallList_Dump()
{
    POSITION pos;
    CString csKey;
    CString csData;
    
    // loop thru the list to see if, we already have this entry
    if (m_cmssUninstallMapList.IsEmpty())
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_Dump: empty\n")));
    }
    else
    {
        pos = m_cmssUninstallMapList.GetStartPosition();
        while (pos)
        {
            csKey.Empty();
            csData.Empty();
            m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("  UnInstallList_Dump: %s=%s\n"), csKey, csData));
        }
    }
}

// Get values from list into our Variables!
void CInitApp::UnInstallList_SetVars()
{
    POSITION pos;
    CString csKey;
    CString csData;
    
    // loop thru the list to see if, we already have this entry
    if (m_cmssUninstallMapList.IsEmpty())
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_Dump: empty\n")));
    }
    else
    {
        pos = m_cmssUninstallMapList.GetStartPosition();
        while (pos)
        {
            csKey.Empty();
            csData.Empty();
            m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);

            if ( _tcsicmp(csKey, _T("IUSR_WAM")) == 0)
            {
                m_csWAMAccountName_Remove = csData;
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UnInstallList_SetVars: m_csWAMAccountName_Remove=%s\n"), m_csWAMAccountName_Remove));
            }
            else if ( _tcsicmp(csKey, _T("IUSR_WWW")) == 0)
            {
                m_csWWWAnonyName_Remove = csData;
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UnInstallList_SetVars: m_csWWWAnonyName_Remove=%s\n"), m_csWWWAnonyName_Remove));
            }
            else if ( _tcsicmp(csKey, _T("IUSR_FTP")) == 0)
            {
                m_csFTPAnonyName_Remove = csData;
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UnInstallList_SetVars: m_csFTPAnonyName_Remove=%s\n"), m_csFTPAnonyName_Remove));
            }
        }
    }
}


CString CInitApp::UnInstallList_QueryKey(CString csItemUniqueKeyName)
{
    CString csGottenValue;
    csGottenValue.Empty();

    csItemUniqueKeyName.MakeUpper(); // uppercase the key
    m_cmssUninstallMapList.Lookup(csItemUniqueKeyName, csGottenValue);

    return csGottenValue;
}

// InitApplicationforSysPrep
//
// Do the initialization work necessary for sysprep to work
//
BOOL 
CInitApp::InitApplicationforSysPrep()
{
  if ( !GetSysDirs() )
  {
    return FALSE;
  }

  // Speficy this, so that it thinks it is an upgrade, and
  // we will set the current IUSR_ and IWAM_ correctly
  // later on
  m_eUpgradeType = UT_60;

  SetInetpubDir();
  SetInetpubDerivatives();

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\initapp.h ===
#include "itemlist.hxx"
#include "funcdict.hxx"

#ifndef _INITAPP_H_
#define _INITAPP_H_

typedef PVOID HINF;

#define USER_SPECIFIED_INFO_WWW_USER_NAME 0x00000001
#define USER_SPECIFIED_INFO_WWW_USER_PASS 0x00000002
#define USER_SPECIFIED_INFO_FTP_USER_NAME 0x00000004
#define USER_SPECIFIED_INFO_FTP_USER_PASS 0x00000008
#define USER_SPECIFIED_INFO_WAM_USER_NAME 0x00000010
#define USER_SPECIFIED_INFO_WAM_USER_PASS 0x00000020

#define USER_SPECIFIED_INFO_PATH_WWW     0x000000040
#define USER_SPECIFIED_INFO_PATH_FTP     0x000000080
#define USER_SPECIFIED_INFO_PATH_INETPUB 0x000000100

// SvcManualStart settings
#define USER_SPECIFIED_INFO_MANUAL_START_WWW 0x000000200
#define USER_SPECIFIED_INFO_MANUAL_START_FTP 0x000000400

int  TCPIP_Check_Temp_Hack(void);
void GetUserDomain(void);
int  AreWeCurrentlyInstalled();
void Check_Custom_WWW_or_FTP_Path(void);
void Check_Custom_Users(void);
void Check_Unattend_Settings(void);
int  Check_Custom_InetPub(void);
void Check_For_DebugServiceFlag(void);
void Check_SvcManualStart( void );


class CInitApp : public CObject
{
public:
        CInitApp();
        ~CInitApp();
public:
    int m_err;
    HINF m_hInfHandle;
    HINF m_hInfHandleAlternate;
    BOOL m_bAllowMessageBoxPopups;
    BOOL m_bThereWereErrorsChkLogfile;
    BOOL m_bThereWereErrorsFromMTS;
    BOOL m_bWin95Migration;
    BOOL m_bIISAdminWasDisabled;

    // Product name and application name
    CString m_csAppName;
    CString m_csIISGroupName;      // Start menu IIS Program Group Name

    // account + passwd for anonymous user
    CString m_csGuestName;
    CString m_csGuestPassword;

    CString m_csWAMAccountName;
    CString m_csWAMAccountPassword;
    CString m_csWWWAnonyName;
    CString m_csWWWAnonyPassword;
    CString m_csFTPAnonyName;
    CString m_csFTPAnonyPassword;

    // dwUnattendUserSpecified Values:
    //   USER_SPECIFIED_INFO_WWW_USER_NAME
    //   USER_SPECIFIED_INFO_WWW_USER_PASS
    //   USER_SPECIFIED_INFO_FTP_USER_NAME
    //   USER_SPECIFIED_INFO_FTP_USER_PASS
    //   USER_SPECIFIED_INFO_WAM_USER_NAME
    //   USER_SPECIFIED_INFO_WAM_USER_PASS
    // USER_SPECIFIED_INFO_PATH_WWW
    // USER_SPECIFIED_INFO_PATH_FTP
    // USER_SPECIFIED_INFO_PATH_INETPUB

    DWORD dwUnattendConfig;

    // storage for the user specified unattended iwam/iusr users
    CString m_csWAMAccountName_Unattend;
    CString m_csWAMAccountPassword_Unattend;
    CString m_csWWWAnonyName_Unattend;
    CString m_csWWWAnonyPassword_Unattend;
    CString m_csFTPAnonyName_Unattend;
    CString m_csFTPAnonyPassword_Unattend;

    // storage for the iusr/iwam accounts which need to get
    // removed during a removal, this could be different from
    // what is getting added -- since unattend parameters could
    // have been specified!
    CString m_csWAMAccountName_Remove;
    CString m_csWWWAnonyName_Remove;
    CString m_csFTPAnonyName_Remove;

    CMapStringToString m_cmssUninstallMapList;
    BOOL m_fUninstallMapList_Dirty;
   
    // machine status
    CString m_csMachineName;
    CString m_csUsersDomain;
    CString m_csUsersAccount;

    CString m_csWinDir;
    CString m_csSysDir;
    CString m_csSysDrive;

    CString m_csPathSource;
    CString m_csPathOldInetsrv;
    CString m_csPathInetsrv;
    CString m_csPathInetpub;
    CString m_csPathFTPRoot;
    CString m_csPathWWWRoot;
    CString m_csPathWebPub;
    CString m_csPathProgramFiles;
    CString m_csPathIISSamples;
    CString m_csPathScripts;
    CString m_csPathASPSamp;
    CString m_csPathAdvWorks;
    CString m_csPathIASDocs;
    CString m_csPathOldPWSFiles;
    CString m_csPathOldPWSSystemFiles;

    NT_OS_TYPE m_eNTOSType;
    OS m_eOS;
    DWORD m_dwOSBuild;
    DWORD m_dwOSServicePack;
    BOOL m_fNT5;                // TRUE if OS is NT
    BOOL m_fW95;                // TRUE if OS is NT
    CString m_csPlatform;       // Alpha, Mips, PPC, i386
    DWORD m_dwNumberOfProcessors;

    BOOL m_fTCPIP;               // TRUE if TCP/IP is installed

    UPGRADE_TYPE m_eUpgradeType;       //  UT_NONE, UT_10, UT_20, etc.
    BOOL m_bUpgradeTypeHasMetabaseFlag;
    INSTALL_MODE m_eInstallMode;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    DWORD m_dwSetupMode;
    BOOL m_bPleaseDoNotInstallByDefault;
    BOOL m_bRefreshSettings;    // FALSE: refresh files only, TRUE: refresh files + refresh all settings

    ACTION_TYPE m_eAction;    // AT_FRESH, AT_ADDREMOVE, AT_REINSTALL, AT_REMOVEALL, AT_UPGRADE

    // Some Specific flags set from ocmanage
    DWORDLONG m_fNTOperationFlags;
    BOOL m_fNTGuiMode;
    BOOL m_fNtWorkstation;
    BOOL m_fInvokedByNT; // superset of m_fNTGuiMode and ControlPanel which contains sysoc.inf

    BOOL m_fUnattended;
    CString m_csUnattendFile;
    HINF m_hUnattendFile;

    BOOL m_fEULA;
    BOOL m_fMoveInetsrv;

    CString m_csPathSrcDir;
    CString m_csPathNTSrcDir;
    CString m_csMissingFile;
    CString m_csMissingFilePath;
    BOOL m_fWebDownload;

    CFunctionDictionary FuncDict;

public:
    // Implementation
    int MsgBox(HWND hWnd, int strID, UINT nType, BOOL bGlobalTitle);
    int MsgBox2(HWND hWnd, int iID,CString csInsertionString,UINT nType);

public:
    BOOL InitApplication();
    void DumpAppVars();
    void ReGetMachineAndAccountNames();
    void DefineSetupModeOnNT();
    BOOL IsTCPIPInstalled();
    void SetInetpubDerivatives();
    void ResetWAMPassword();
    void UnInstallList_Add(CString csItemUniqueKeyName,CString csDataToAdd);
    void UnInstallList_DelKey(CString csItemUniqueKeyName);
    void UnInstallList_DelData(CString csDataValue);
    void UnInstallList_Dump();
    void UnInstallList_RegRead();
    void UnInstallList_RegWrite();
    void UnInstallList_SetVars();
    CString UnInstallList_QueryKey(CString csItemUniqueKeyName);
    BOOL IsUpgrade();
    DWORD GetUpgradeVersion();
    BOOL InitApplicationforSysPrep();

private:
    BOOL GetSysDirs();
    BOOL GetOS();
    BOOL GetOSVersion();
    BOOL GetOSType();
    BOOL SetInstallMode();
    void GetPlatform();
    BOOL GetMachineStatus();
    BOOL GetMachineName();
    int  SetUpgradeType();

    void SetSetupParams();
    void SetInetpubDir();
    void GetOldIISDirs();
    void GetOldWWWRootDir();
    void DeriveInetpubFromWWWRoot();
    void GetOldIISSamplesLocation();
    void GetOldInetSrvDir();
    int  Check_Custom_InetPub();
    void Check_Unattend_Settings();
};

/////////////////////////////////////////////////////////////////////////////
#endif  // _INITAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\funcdict.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        funcdict.cxx

   Abstract:

        Class that contains all the methods used by the .inf file

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdentry.h"
#include "metabase.hxx"
#include "reg.hxx"
#include "xmlupgrade.hxx"
#include "common.hxx"

// Constructor
//
// Initialize Everything
//
CFunctionDictionary::CFunctionDictionary()
{
  m_bFunctionsLoaded = FALSE;

  InitializeFunctions();
}

// Destructor
//
// Clean up memory
CFunctionDictionary::~CFunctionDictionary()
{
  DeleteFunctions();
}

// function: DeleteFunctions
// 
// Delete all of the functions that are defined
//
void 
CFunctionDictionary::DeleteFunctions()
{
  DWORD i;

  // Delete all functions
  for (i = 0; i < DICTIONARY_MAXFUNCTIONS; i++)
  {
    if ( m_pDict[i] )
    {
      delete (m_pDict[i]);
    }

    m_pDict[i] = NULL;
  }

  m_dwFunctions = 0;
  m_bFunctionsLoaded = FALSE;
}

// function: InitializeFunction
//
// Initiliaze all of the functions to NULL
//
void 
CFunctionDictionary::InitializeFunctions()
{
  DWORD i;

  m_dwFunctions = 0;

  // Initialize all to NULL
  for (i = 0; i < DICTIONARY_MAXFUNCTIONS; i++)
  {
    m_pDict[i] = NULL;
  }
}

// function: LoadFunction
//
// Loads all of the functions that we know about into our list
//
// Return Values:
//   TRUE - They loaded successfully
//   FALSE - They did not load successully
BOOL
CFunctionDictionary::LoadFunctions()
{
  DWORD dwNum = 0;
  DWORD i;
  BOOL bRet = TRUE;

  // Initlize the functions to NULL
  InitializeFunctions();

  // Create all of the pointers for the classes here
  m_pDict[dwNum++] = new (CRegistry_MoveValue);
//  m_pDict[dwNum++] = new (CRegistry_SetValue);
  m_pDict[dwNum++] = new (CRegistry_DeleteKey);
  m_pDict[dwNum++] = new (CMetaBase_SetValue);
  m_pDict[dwNum++] = new (CMetaBase_IsAnotherSiteonPort80);
  m_pDict[dwNum++] = new (CMetaBase_VerifyValue);
  m_pDict[dwNum++] = new (CMetaBase_DelIDOnEverySite);
  m_pDict[dwNum++] = new (CIsUpgrade);
  m_pDict[dwNum++] = new (CMetaBase_ImportRestrictionList);
  m_pDict[dwNum++] = new (CMetaBase_UpdateCustomDescList);
  m_pDict[dwNum++] = new (CXML_Metabase_Upgrade);
  m_pDict[dwNum++] = new (CXML_Metabase_VerifyVersion);
  m_pDict[dwNum++] = new (CXML_MBSchema_Upgrade);
  m_pDict[dwNum++] = new (CXML_MBSchema_VerifyVersion);
  m_pDict[dwNum++] = new (CFileSys_AddAcl);
  m_pDict[dwNum++] = new (CFileSys_RemoveAcl);
  m_pDict[dwNum++] = new (CFileSys_SetAcl);
  // ...

  // Make sure that we did not go over our function size limit
  ASSERT(dwNum <= DICTIONARY_MAXFUNCTIONS);

  // Make sure that they all loaded correctly
  for (i = 0; i < dwNum; i++)
  {
    if ( !m_pDict[i] )
    {
      bRet = FALSE;
      break;
    }
  }

  if ( bRet )
  {
    // We successfully created all the functions
    m_dwFunctions = dwNum;
    m_bFunctionsLoaded = TRUE;
    return TRUE;
  }

  // Since we failed, release all the pointers
  DeleteFunctions();

  return FALSE;
}

// function: FindFunction
//
// Find a function in the table, given its name
//
// Parameters:
//   szFunctionName - The name of the function
//
// Return:
//   NULL - Could not find function
//   pointer - pointer to the class for that function
//
CBaseFunction *
CFunctionDictionary::FindFunction(LPTSTR szFunctionName)
{
  DWORD i;

  if ( m_bFunctionsLoaded == FALSE )
  {
    if ( LoadFunctions() )
    {
      m_bFunctionsLoaded = TRUE;
    }
    else
    {
      return FALSE;
    }
  }

  for (i = 0; i < m_dwFunctions; i++)
  {
    if ( _tcscmp( szFunctionName, m_pDict[i]->GetMethodName() ) == 0 )
    {
      return (m_pDict[i]);
    }
  }

  return NULL;
}

// function: CallFunction
//
// Call a function that has been defined in this class
//
// Parameters
//   szFunctionName - The Name of the function
//   szParameters - The parameters to be sent in
//
// Return Values:
//   These return values indicate the return value of the function that was called.
//   Higher up, these will sometimes we used for conditional statements in the 
//   infs
//
BOOL 
CFunctionDictionary::CallFunction(LPTSTR szFunctionName, LPTSTR szParameters)
{
  CBaseFunction *pFunc;
  BOOL          bRet;

  pFunc = FindFunction( szFunctionName );

  if ( !pFunc )
  {
    iisDebugOut((LOG_TYPE_TRACE, _T("Function '%s' could not be found\n") , szFunctionName ) );

    // We could not find the function, so lets return.  (The return value does not indicate
    // that we did not succeeded it just indicates that the return function returned something)
    return FALSE;
  }

  iisDebugOut((LOG_TYPE_TRACE, _T("Calling function '%s'\n") , pFunc->GetMethodName() ) );

  bRet = pFunc->DoWork( szParameters );

  iisDebugOut((LOG_TYPE_TRACE, _T("Function '%s' returned 0x%08x\n") , pFunc->GetMethodName(), bRet ) );

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\itemlist.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        itemlist.cpp

   Abstract:

        Class to parse different parameters coming in from the inf

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"

// Constructor for CItemList
//
// Initialize everything to NULL's and 0's
CItemList::CItemList()
 : m_dwItemsinList(0),
   m_pItems(NULL)
{

}

// Destructor for CItemList
//
// 
CItemList::~CItemList()
{
  if ( m_pItems )
  {
    delete m_pItems;
    m_pItems = NULL;
  }
}

// function: FindNextItem
//
// Search through the string and find the begining of the 
// next item
//
// Parameters:
//   szLine - The string to be parsed
//   cTermChar - The termination character to use
//
// Return
//   NULL - No next termination character could be found
//   pointer - The string where the next splitting char is.
LPTSTR 
CItemList::FindNextItem(LPTSTR szLine, TCHAR cTermChar)
{
  LPTSTR szTermination = _tcschr(szLine, cTermChar);
  LPTSTR szOpenParen =  _tcschr(szLine, '(' );
  LPTSTR szCloseParen =  szOpenParen ? _tcschr(szOpenParen, ')' ) : NULL;

  if ( (szOpenParen == NULL) || 
       (szCloseParen == NULL) ||
       (szTermination < szOpenParen)
     )
  {
    return szTermination;
  }

  // If there is a (xxx), then lets find the termination char after that
  szTermination = _tcschr(szCloseParen, cTermChar);

  return szTermination;
}

// function: LoadSubList
// 
// Load a sublist of items
// A sublist, is a list inside of parenthesis
//
// Parameters
//   szList - The list of items (ie. "(test|foo|bar)"
// 
// Return 
//   TRUE - Loaded successfully
//   FALSE - Failed to load
BOOL 
CItemList::LoadSubList(LPTSTR szList)
{
  LPTSTR szOpenParen =  _tcschr(szList, '(' );
  LPTSTR szCloseParen =  szOpenParen ? _tcschr(szOpenParen, ')' ) : NULL;

  if (szOpenParen && szCloseParen)
  {
    BOOL bRet;

    *szCloseParen = '\0';
    bRet = LoadList(szList + 1);
    *szCloseParen = ')';

    return bRet;
  }

  return LoadList(szList);
}

// function: LoadList
//
// Load a list of items into our array
//
// Parameters:
//   szList - A string containind a comma seperated list of items
//
// Return:
//   FALSE - We could not load the list (either memory problems, or it was 
//                                       incorrectly formatted)
//   TRUE - We loaded the list
//
BOOL
CItemList::LoadList(LPTSTR szList)
{
  DWORD dwNumItems = 0;
  DWORD dwCurrentItem;
  DWORD dwListLen;
  LPTSTR szListCurrent;

  if (szList == NULL)
  {
    // No pointer was passed in
    return FALSE;
  }

  // Find the number of items in list
  szListCurrent = szList;
  if (*szListCurrent)
  {
    while (szListCurrent)
    {
      // Increment the Items
      dwNumItems++;

      szListCurrent = FindNextItem(szListCurrent, ITEMLIST_TERMINATIONCHARACTER);

      if (szListCurrent)
      {
        szListCurrent++;
      }
    }
  }

  dwListLen = (_tcslen(szList) + 1) * sizeof(TCHAR);
  if ( !m_Buff.Resize( dwListLen ) )
  {
    // Could not allocate memory
    return FALSE;
  }

  if ( dwNumItems )
  {
    if ( m_pItems )
    {
      delete m_pItems;
    }

    m_pItems = new ( LPTSTR[dwNumItems] );
    if ( !m_pItems )
    {
      // Could not allocate memory
      return FALSE;
    }
  }

  // Copy the List into our own memory
  memcpy(m_Buff.QueryPtr(), szList, dwListLen);
  m_dwItemsinList = dwNumItems;

  // Terminate each item in list, and set pointer accordingly
  szListCurrent = (LPTSTR) m_Buff.QueryPtr();
  dwCurrentItem = 0;
  while ( (szListCurrent) &&
          (dwCurrentItem < m_dwItemsinList )
        )
  {
    // Set pointer for each item
    m_pItems[dwCurrentItem++] = szListCurrent;

    szListCurrent = FindNextItem(szListCurrent, ITEMLIST_TERMINATIONCHARACTER);

    if (szListCurrent)
    {
      *szListCurrent = '\0';
      szListCurrent++;
    }
  }

  return TRUE;
}

// function: GetItem
//
// Get an item in the list, according to its index
//
// Parameters
//   dwIndex - Index of the Item (0 Based)
//
// Return:
//   A Pointer to the begining of that string

LPTSTR 
CItemList::GetItem(DWORD dwIndex)
{
  if ( dwIndex >= m_dwItemsinList )
  {
    return NULL;
  }

  return m_pItems[dwIndex];
}

// function: GetNumberOfItems
// 
// return the number of items in the list
//
DWORD 
CItemList::GetNumberOfItems()
{
  return m_dwItemsinList;
}

// function: FindItem
//
// Find an Item in the list
//
// Parameters:
//   szSearchString - The string that we want to find
// 
// Return
//   TRUE - It was found
//   FALSE - It was not found
BOOL 
CItemList::FindItem(LPTSTR szSearchString, BOOL bCaseSensitive )
{
  DWORD dwCurrentItem;

  for ( dwCurrentItem = 0; dwCurrentItem < m_dwItemsinList; dwCurrentItem++ )
  {
    if ( bCaseSensitive )
    { 
      // Case Sensitive Compare
      if ( _tcscmp( m_pItems[dwCurrentItem], szSearchString ) == 0)
      {
        // Found item
        return TRUE;
      }
    }
    else
    { 
      // Case Insensitive Compare
      if ( _tcsicmp( m_pItems[dwCurrentItem], szSearchString ) == 0)
      {
        // Found item
        return TRUE;
      }
    }
  }

  return FALSE;
}

// function: IsNumber
//
// Determines if the parameter that we are looking at is a number
//
// Parameter
//   dwIndex - The index of the parameter to look at
//
// Return
//   TRUE - It is a number
//   FALSE - It is not a number
BOOL
CItemList::IsNumber(DWORD dwIndex)
{
  LPTSTR szNumber = GetItem(dwIndex);
  BOOL bHex = FALSE;

  if (!szNumber)
  {
    return FALSE;
  }

  szNumber = SkipWhiteSpaces(szNumber);

  // Skip "0x" if it exists, if not we will assume base 10 number
  if ( _tcsncmp( szNumber, _T("0x"), 2 ) == 0)
  {
    szNumber += 2;
    bHex = TRUE;
  }

  while ( ( *szNumber != '\0' ) &&
          ( ( ( *szNumber >= '0' ) && ( *szNumber <= '9' ) ) || 
            ( ( *szNumber >= 'a' ) && ( *szNumber <= 'f' ) && ( bHex ) ) ||
            ( ( *szNumber >= 'A' ) && ( *szNumber <= 'F' ) && ( bHex ) )
          )
        )
  {
    szNumber ++;
  }

  szNumber = SkipWhiteSpaces(szNumber);

  return ( *szNumber == '\0' );
}

// function: GetNumber
//
// Get the value of this param as a number
//
// Parameters:
//   dwIndex - Index of item to find
DWORD 
CItemList::GetNumber(DWORD dwIndex)
{
  LPTSTR szNumber = GetItem(dwIndex);
  BOOL bHex = FALSE;
  DWORD dwVal = 0;

  if ( !szNumber ||
       !IsNumber(dwIndex) )
  {
    return 0;
  }

  szNumber = SkipWhiteSpaces(szNumber);

  // Skip "0x" if it exists, if not we will assume base 10 number
  if ( _tcsncmp( szNumber, _T("0x"), 2 ) == 0)
  {
    szNumber += 2;
    bHex = TRUE;
  }

  while ( ( ( *szNumber >= '0' ) && ( *szNumber <= '9' ) ) ||
          ( ( *szNumber >= 'a' ) && ( *szNumber <= 'f' ) ) ||
          ( ( *szNumber >= 'A' ) && ( *szNumber <= 'F' ) )
        )
  {
    dwVal = dwVal * (bHex ? 16 : 10);

    if ( ( *szNumber >= '0' ) && ( *szNumber <= '9' ) )
    {
      dwVal = dwVal + *szNumber - '0';
    } 
    else 
      if ( ( *szNumber >= 'a' ) && ( *szNumber <= 'f' ) )
      {
        dwVal = dwVal + 10 + *szNumber - 'a';
      } 
      else
        if ( ( *szNumber >= 'A' ) && ( *szNumber <= 'F' ) )
        {
          dwVal = dwVal + 10 + *szNumber - 'A';
        }

    szNumber++;
  }

  return dwVal;
}

// function: SkipWhiteSpaces
// 
// Skips white spaces
//
// Parameter
//   szLine - The line to start skipping st
//
// Return:
//   pointer to first non white character
//
LPTSTR 
CItemList::SkipWhiteSpaces(LPTSTR szLine)
{
  while ( ( *szLine == ' ' ) ||
          ( *szLine == '\t'))
  {
    szLine++;
  }

  return szLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\helper.cpp ===
#include "stdafx.h"
#include "lzexpand.h"
#include <loadperf.h>
#include <ole2.h>
#include <iis64.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "dcomperm.h"
#include "log.h"
#include "other.h"
#include "kill.h"
#include "strfn.h"
#include "shellutl.h"
#include "svc.h"
#include "setuser.h"
#include "wolfpack.h"
#include <wbemcli.h>
#include <direct.h>
#include <aclapi.h>
#include <wincrypt.h>
#include <Dsgetdc.h>
#include "parse.hxx"

// for backward compat
#define     PWS_TRAY_WINDOW_CLASS       _T("PWS_TRAY_WINDOW")

GUID g_FTPGuid      = { 0x91604620, 0x6305, 0x11ce, 0xae, 0x00, 0x00, 0xaa, 0x00, 0x4a, 0x38, 0xb9 };
GUID g_HTTPGuid     = { 0x585908c0, 0x6305, 0x11ce, 0xae, 0x00, 0x00, 0xaa, 0x00, 0x4a, 0x38, 0xb9 };
GUID g_InetInfoGuid = { 0xa5569b20, 0xabe5, 0x11ce, 0x9c, 0xa4, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x31 };
GUID g_GopherGuid   = { 0x62388f10, 0x58a2, 0x11ce, 0xbe, 0xc8, 0x00, 0xaa, 0x00, 0x47, 0xae, 0x4e };

// guid stuff
#define MY_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) extern "C" const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define MY_DEFINE_OLEGUID(name, l, w1, w2) MY_DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
MY_DEFINE_OLEGUID(IID_IPersistFile, 0x0000010b, 0, 0);
// must be defined after the guid stuff
#include "shlobj.h"

extern int g_GlobalGuiOverRide;
extern int g_GlobalTickValue;
extern int g_CheckIfMetabaseValueWasWritten;
extern HSPFILEQ g_GlobalFileQueueHandle;
extern int g_GlobalFileQueueHandle_ReturnError;

const TCHAR PARSE_ERROR_ENTRY_TO_BIG[] = _T("ProcessEntry_Entry:ParseError:%1!s!:%2!s! -- entry to big. FAIL.\n");
const TCHAR csz101_NOT_SPECIFIED[] = _T("%s():101 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz102_NOT_SPECIFIED[] = _T("%s():102 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz103_NOT_SPECIFIED[] = _T("%s():103 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz104_NOT_SPECIFIED[] = _T("%s():104 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz105_NOT_SPECIFIED[] = _T("%s():105 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz805_NOT_SPECIFIED[] = _T("%s():805 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");

typedef struct _MTS_ERROR_CODE_STRUCT
{
    int iMtsThingWeWereDoing;
    DWORD dwErrorCode;
} MTS_ERROR_CODE_STRUCT;

MTS_ERROR_CODE_STRUCT gTempMTSError;


const TCHAR ThingToDoNumType_100[] = _T("100=");
const TCHAR ThingToDoNumType_101[] = _T("101=");
const TCHAR ThingToDoNumType_102[] = _T("102=");
const TCHAR ThingToDoNumType_103[] = _T("103=");
const TCHAR ThingToDoNumType_104[] = _T("104=");
const TCHAR ThingToDoNumType_105[] = _T("105=");
const TCHAR ThingToDoNumType_106[] = _T("106=");

const TCHAR ThingToDoNumType_200[] = _T("200=");
const TCHAR ThingToDoNumType_701[] = _T("701=");
const TCHAR ThingToDoNumType_702[] = _T("702=");
const TCHAR ThingToDoNumType_703[] = _T("703=");
const TCHAR ThingToDoNumType_801[] = _T("801=");
const TCHAR ThingToDoNumType_802[] = _T("802=");
const TCHAR ThingToDoNumType_803[] = _T("803=");
const TCHAR ThingToDoNumType_804[] = _T("804=");
const TCHAR ThingToDoNumType_805[] = _T("805=");

typedef struct _ThingToDo {
    TCHAR szType[20];
    TCHAR szFileName[_MAX_PATH];
    TCHAR szData1[_MAX_PATH + _MAX_PATH];
    TCHAR szData2[_MAX_PATH];
    TCHAR szData3[_MAX_PATH];
    TCHAR szData4[_MAX_PATH];
    TCHAR szChangeDir[_MAX_PATH];

    TCHAR szOS[10];
    TCHAR szPlatformArchitecture[10];
    TCHAR szEnterprise[10];
    TCHAR szErrIfFileNotFound[10];
    TCHAR szMsgBoxBefore[10];
    TCHAR szMsgBoxAfter[10];
    TCHAR szDoNotDisplayErrIfFunctionFailed[10];
    TCHAR szProgressTitle[100];
} ThingToDo;


extern OCMANAGER_ROUTINES gHelperRoutines;

extern int g_GlobalDebugLevelFlag;
extern int g_GlobalDebugLevelFlag_WasSetByUnattendFile;
extern int g_GlobalDebugCallValidateHeap;
extern int g_GlobalDebugCrypto;
extern int g_GlobalFastLoad;


// Our Global List of Warnings to display after setup is completed.
CStringList gcstrListOfWarnings;
CStringList gcstrProgressBarTextStack;

CStringList gcstrListOfOleInits;

#define FUNCTION_PARAMS_NONE 0
#define FUNCTION_PARAMS_HMODULE 1


#define MAX_FAKE_METABASE_STRING_LEN 500



LCID g_MyTrueThreadLocale;

DWORD WINAPI GetNewlyCreatedThreadLocale(LPVOID lpParameter)
{
    g_MyTrueThreadLocale = GetThreadLocale ();
    return 0;
}

int CheckForWriteAccess(LPCTSTR szFile)
{
    int iReturn = FALSE;

    // check if the file exists
    // if it doesn't then return true!
    if (IsFileExist(szFile) != TRUE)
    {
        // we've got write access!
        return TRUE;
    }

    // try to open the file for write; if we can't, the file is read-only
    HANDLE hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // we've got write access!
        iReturn = TRUE;
        CloseHandle (hFile);
    }

    return iReturn;
}


/////////////////////////////////////////////////////////////////////////////
//++
// Return Value:
//    TRUE - the operating system is NTS Enterprise
//    FALSE - the operating system is not correct.
//--
/////////////////////////////////////////////////////////////////////////////
int iReturnTrueIfEnterprise(void)
{
    BOOL              fReturnValue;
    OSVERSIONINFOEX   osiv;
    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osiv.dwMajorVersion = 5;
    osiv.dwMinorVersion = 0;
    osiv.wServicePackMajor = 0;
    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;

    DWORDLONG   dwlConditionMask;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    fReturnValue = VerifyVersionInfo( &osiv,VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SUITENAME,dwlConditionMask );
    if ( fReturnValue != (BOOL) TRUE )
    {
        DWORD dwErrorCode = GetLastError();
    }

    return ( fReturnValue );
}


void GlobalOleInitList_Push(int iTrueOrFalse)
{
    if (FALSE == iTrueOrFalse)
    {
        gcstrListOfOleInits.AddTail(_T("TRUE"));
    }
    else
    {
        gcstrListOfOleInits.AddTail(_T("FALSE"));
    }
    return;
}

int GlobalOleInitList_Find(void)
{
    if (gcstrListOfOleInits.IsEmpty() == TRUE)
    {
        return FALSE;
    }
    return TRUE;
}

int GlobalOleInitList_Pop(void)
{
    CString csText;
    if (gcstrListOfOleInits.IsEmpty() == FALSE)
    {
        csText = gcstrListOfWarnings.RemoveTail();
        if (_tcsicmp(csText, _T("TRUE")) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

void ProgressBarTextStack_Push(CString csText)
{
    gcstrListOfWarnings.AddTail(csText);
    if (gHelperRoutines.OcManagerContext)
    {
        gHelperRoutines.SetProgressText(gHelperRoutines.OcManagerContext,csText);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetProgressText = %s\n"),csText));
    }
    return;
}

void ProgressBarTextStack_Push(LPTSTR szText)
{
    CString csText = szText;

    ProgressBarTextStack_Push( csText );
}


void ProgressBarTextStack_Pop(void)
{
    int iFoundLastEntry = FALSE;
    CString csText;
    // Get the last entry off of the stack and display it.
    if (gcstrListOfWarnings.IsEmpty() == FALSE)
    {
        csText = gcstrListOfWarnings.RemoveTail();
        if (gcstrListOfWarnings.IsEmpty() == FALSE)
        {
            csText = gcstrListOfWarnings.GetTail();
            if (csText)
            {
                iFoundLastEntry = TRUE;
            }
        }
    }

    if (iFoundLastEntry)
    {
        if (gHelperRoutines.OcManagerContext)
        {
            gHelperRoutines.SetProgressText(gHelperRoutines.OcManagerContext,csText);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetProgressText = %s\n"),csText));
        }
    }
    else
    {
        if (gHelperRoutines.OcManagerContext)
        {
            gHelperRoutines.SetProgressText(gHelperRoutines.OcManagerContext,_T(" "));
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetProgressText = ' '\n")));
        }
    }
    return;
}


void ListOfWarnings_Add(TCHAR * szEntry)
{
    //Add entry to the list of warnings if not already there
    if (_tcsicmp(szEntry, _T("")) != 0)
    {
        // Add it if it is not already there.
        if (TRUE != IsThisStringInThisCStringList(gcstrListOfWarnings, szEntry))
        {
            gcstrListOfWarnings.AddTail(szEntry);
        }
    }
    return;
}

void ListOfWarnings_Display(void)
{
    if (gcstrListOfWarnings.IsEmpty() == FALSE)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("************** WARNINGS START **************")));
        POSITION pos = NULL;
        CString csEntry;
        pos = gcstrListOfWarnings.GetHeadPosition();
        while (pos)
        {
            csEntry = gcstrListOfWarnings.GetAt(pos);
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s!\n"), csEntry));
            gcstrListOfWarnings.GetNext(pos);
        }
        iisDebugOut((LOG_TYPE_WARN, _T("************** WARNINGS END **************")));
    }
    return;
}

int DebugLevelRegistryOveride(TCHAR * szSectionName, TCHAR * ValueName, int * iValueToSet)
{
    int iReturn = FALSE;

    CRegKey regKey(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY)regKey)
    {
        // create the key to lookup
        // iis5_SectionName_ValueName
        // iis5_SetupInfo_
        if (szSectionName && ValueName)
        {
            TCHAR szTempRegString[255];
            DWORD dwValue = 0x0;
            _stprintf(szTempRegString, _T("IIS5:%s:%s"), szSectionName, ValueName);
            regKey.m_iDisplayWarnings = FALSE;
            if (regKey.QueryValue(szTempRegString, dwValue) == ERROR_SUCCESS)
            {
                if (dwValue <= 32000)
                {
                    *iValueToSet = (int) dwValue;
                    iReturn = TRUE;
                }
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RegistryINFValuesOveride:%s=%d."),szTempRegString, *iValueToSet));
            }
        }
    }
    return iReturn;
}


void GetDebugLevelFromInf(IN HINF hInfFileHandle)
{
    int iTempDisplayLogging = FALSE;
    INFCONTEXT Context;
    TCHAR szTempString[10] = _T("");

    //
    //  DebugLevel
    //
    if (!g_GlobalDebugLevelFlag_WasSetByUnattendFile)
    {
        iTempDisplayLogging = FALSE;
        g_GlobalDebugLevelFlag = LOG_TYPE_ERROR;
        if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DebugLevel"), &Context) )
            {
                SetupGetStringField(&Context, 1, szTempString, 10, NULL);

                if (IsValidNumber((LPCTSTR)szTempString))
                    {
                    g_GlobalDebugLevelFlag = _ttoi((LPCTSTR) szTempString);
                    iTempDisplayLogging = TRUE;
                    }

                if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API )
                {
                    g_CheckIfMetabaseValueWasWritten = TRUE;
                }
            }
        if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugLevel"), &g_GlobalDebugLevelFlag))
            {iTempDisplayLogging = TRUE;}
        if (iTempDisplayLogging)
            {iisDebugOut((LOG_TYPE_TRACE, _T("DebugLevel=%d."),g_GlobalDebugLevelFlag));}
    }
    else
    {
        if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugLevel"), &g_GlobalDebugLevelFlag))
            {iTempDisplayLogging = TRUE;}
        if (iTempDisplayLogging)
            {iisDebugOut((LOG_TYPE_TRACE, _T("DebugLevel=%d."),g_GlobalDebugLevelFlag));}
    }

    //
    //  DebugValidateHeap
    //
    iTempDisplayLogging = FALSE;
    g_GlobalDebugCallValidateHeap = TRUE;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DebugValidateHeap"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString))
            {
            g_GlobalDebugCallValidateHeap = _ttoi((LPCTSTR) szTempString);
            iTempDisplayLogging = TRUE;
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugValidateHeap"), &g_GlobalDebugCallValidateHeap))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("DebugValidateHeap=%d."),g_GlobalDebugCallValidateHeap));}

    //
    //  DebugCrypto
    //
    iTempDisplayLogging = FALSE;
    g_GlobalDebugCrypto = 0;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DebugCrypto"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString))
            {
            g_GlobalDebugCrypto = _ttoi((LPCTSTR) szTempString);
            iTempDisplayLogging = TRUE;
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugCrypto"), &g_GlobalDebugCrypto))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("DebugCrypto=%d."),g_GlobalDebugCrypto));}


    //
    //  FastDllInit
    //
    iTempDisplayLogging = FALSE;
    g_GlobalFastLoad = FALSE;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("FastDllInit"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString))
            {
            g_GlobalFastLoad = _ttoi((LPCTSTR) szTempString);
            iTempDisplayLogging = TRUE;
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("FastDllInit"), &g_GlobalFastLoad))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("GlobalFastLoad=%d."),g_GlobalFastLoad));}

    //
    //  Check if we should display messagebox popups
    //
    iTempDisplayLogging = FALSE;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DisplayMsgbox"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString))
            {
            int iTempNum = 0;
            iTempNum = _ttoi((LPCTSTR) szTempString);
            if (iTempNum > 0)
                {
                g_pTheApp->m_bAllowMessageBoxPopups = TRUE;
                iTempDisplayLogging = TRUE;
                }
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DisplayMsgbox"), &g_pTheApp->m_bAllowMessageBoxPopups))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("DisplayMsgbox=%d."),g_pTheApp->m_bAllowMessageBoxPopups));}

    return;
}


//****************************************************************************
//*
//* This routine will center a dialog in the active windows.
//*
//* ENTRY:
//*  hwndDlg     - Dialog window.
//*
//****************************************************************************
void uiCenterDialog( HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen;
    int     cyScreen;

    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0);

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect(hwndDlg,&rc);

    x = rc.left;    // Default is to leave the dialog where the template
    y = rc.top;     //  was going to place it.

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ((cyScreen - cyDlg) / 2);
    x = rcScreen.left + ((cxScreen - cxDlg) / 2);

    // Position the dialog.
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
}



/*

//***************************************************************************
//*                                                                         *
//* SYNOPSIS:   Checks if a specific key in the given section and given file*
//*             is defined.  IF so, get the value.  OW return -1            *
//*                                                                         *
//***************************************************************************
DWORD IsMyKeyExists( LPCTSTR lpSec, LPCTSTR lpKey, LPTSTR lpBuf, UINT uSize, LPCTSTR lpFile )
{
    DWORD dwRet;

    dwRet = GetPrivateProfileString( lpSec, lpKey, "ZZZZZZ", lpBuf, uSize, lpFile );

    if ( !lstrcmp( lpBuf, "ZZZZZZ" ) )
    {
         // no key defined
         dwRet = (DWORD)(-1);
    }
    return dwRet;
}


//***************************************************************************
//
// FormStrWithoutPlaceHolders( LPTSTR szDst, LPCTSTR szSrc, LPCTSTR lpFile );
//
// This function can be easily described by giving examples of what it
// does:
//        Input:  GenFormStrWithoutPlaceHolders(dest,"desc=%MS_XYZ%", hinf) ;
//                INF file has MS_VGA="Microsoft XYZ" in its [Strings] section!
//
//        Output: "desc=Microsoft XYZ" in buffer dest when done.
//
//
// ENTRY:
//  szDst         - the destination where the string after the substitutions
//                  for the place holders (the ones enclosed in "%' chars!)
//                  is placed. This buffer should be big enough (LINE_LEN)
//  szSrc         - the string with the place holders.
//
// EXIT:
//
// NOTES:
//  To use a '%' as such in the string, one would use %% in szSrc!
//  For the sake of simplicity, we have placed a restriction that the place
//  holder name string cannot have a '%' as part of it! If this is a problem
//  for internationalization, we can revisit this and support it too! Also,
//  the way it is implemented, if there is only one % in the string, it is
//  also used as such! Another point to note is that if the key is not
//  found in the [Strings] section, we just use the %strkey% as such in the
//  destination. This should really help in debugging.
//
//  Get/modified it from setupx: gen1.c
//***************************************************************************
DWORD FormStrWithoutPlaceHolders( LPTSTR szDst, LPCTSTR szSrc, LPCTSTR lpFile)
{
    int     uCnt ;
    DWORD   dwRet;
    TCHAR   *pszTmp;
    LPTSTR  pszSaveDst;

    pszSaveDst = szDst;
    // Do until we reach the end of source (null char)
    while( (*szDst++ = *szSrc) )
    {
        // Increment source as we have only incremented destination above
        if(*szSrc++ == '%')
        {
            if (*szSrc == '%')
            {
                // One can use %% to get a single percentage char in message
                szSrc++ ;
                continue ;
            }

            // see if it is well formed -- there should be a '%' delimiter
            if ( (pszTmp = strchr( szSrc, '%')) != NULL )
            {
                szDst--; // get back to the '%' char to replace

                // yes, there is a STR_KEY to be looked for in [Strings] sect.
                *pszTmp = '\0' ; // replace '%' with a NULL char

                dwRet = IsMyKeyExists( _T("Strings"), szSrc, szDst, _MAX_PATH, lpFile );
                if ( dwRet == -1 )
                {
                    *pszTmp = '%';      // put back original character
                    szSrc-- ;                    // get back to first '%' in Src
                    uCnt = DIFF(pszTmp - szSrc) + 1; // include 2nd '%'

                    // UGHHH... It copies 1 less byte from szSrc so that it can put
                    // in a NULL character, that I don't care about!!!
                    // Different from the normal API I am used to...
                    lstrcpyn( szDst, szSrc, uCnt + 1 ) ;
                    return (DWORD)-1;
                }
                else
                {
                    // all was well, Dst filled right, but unfortunately count not passed
                    // back, like it used too... :-( quick fix is a lstrlen()...
                    uCnt = lstrlen( szDst ) ;
                }

                *pszTmp = '%'  ; // put back original character
                szSrc = pszTmp + 1 ;      // set Src after the second '%'
                szDst += uCnt ;           // set Dst also right.
            }
            // else it is ill-formed -- we use the '%' as such!
            else
            {
                return (DWORD)-1;
            }
        }

    } // while
    return (DWORD)lstrlen(pszSaveDst);
}
*/


void LogImportantFiles(void)
{
    TCHAR buf[_MAX_PATH];
    if (g_pTheApp->m_hInfHandle)
    {
        LogFileVersionsForGroupOfSections(g_pTheApp->m_hInfHandle);
    }

    // display current files in inetsrv date/version.
    CString csTempPath = g_pTheApp->m_csPathInetsrv;
    LogFilesInThisDir(csTempPath);

    // display the setup iis.dll file
    GetSystemDirectory( buf, _MAX_PATH);
    csTempPath = buf;
    csTempPath = AddPath(csTempPath, _T("iis.dll"));
    LogFileVersion(csTempPath, TRUE);

    return;
}

#ifndef _CHICAGO_
int CreateIUSRAccount(CString csUsername, CString csPassword, INT* piNewlyCreatedUser)
{
    int err;
    CString csComment, csFullName;
    INT iUserWasDeleted = 0;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateIUSRAccount(): %1!s!\n"), csUsername));

    // delete the old user first
    //DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);

    // create the new user
    MyLoadString(IDS_USER_COMMENT, csComment);
    MyLoadString(IDS_USER_FULLNAME, csFullName);

    // Create user either returns NERR_Success or err code
    err = CreateUser(csUsername, csPassword, csComment, csFullName, FALSE, piNewlyCreatedUser);
        if (err == NERR_Success)
                {iisDebugOut((LOG_TYPE_TRACE, _T("CreateIUSRAccount(): Return 0x%x  Suceess\n"), err));}
        else
                {
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateIUSRAccount(): Return Err=0x%x  FAILURE. deleting and retrying.\n"), err));

        // try to delete it first then create it.
        DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);
        err = CreateUser(csUsername, csPassword, csComment, csFullName, FALSE, piNewlyCreatedUser);
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateIUSRAccount(): Return 0x%x\n"), err));
        }

    return err;
}

int CreateIWAMAccount(CString csUsername, CString csPassword,INT* piNewlyCreatedUser)
{
    int err;
    CString csComment, csFullName;
    INT iUserWasDeleted = 0;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateIWAMAccount(): %1!s!\n"), csUsername));
    //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("CreateIWAMAccount(): %1!s!\n"), csPassword));

    // delete the old user first
    //DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);

    // create the new user
    MyLoadString(IDS_WAMUSER_COMMENT, csComment);
    MyLoadString(IDS_WAMUSER_FULLNAME, csFullName);

    // Create user either returns NERR_Success or err code
    err = CreateUser(csUsername, csPassword, csComment, csFullName, TRUE, piNewlyCreatedUser);
        if (err == NERR_Success)
                {iisDebugOut((LOG_TYPE_TRACE, _T("CreateIWAMAccount(): Return 0x%x  Suceess\n"), err));}
        else
                {
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateIWAMAccount(): Return Err=0x%x  FAILURE. deleting and retrying.\n"), err));

        // try to delete it first then create it.
        DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);
        err = CreateUser(csUsername, csPassword, csComment, csFullName, TRUE, piNewlyCreatedUser);
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateIWAMAccount(): Return 0x%x\n"), err));
        }

    return err;
}
#endif //_CHICAGO_


INT InstallPerformance(CString nlsRegPerf,CString nlsDll,CString nlsOpen,CString nlsClose,CString nlsCollect )
{
    iisDebugOut_Start1(_T("InstallPerformance"),nlsDll);
    INT err = NERR_Success;

    if (g_pTheApp->m_eOS != OS_W95)
    {
        CRegKey regPerf( nlsRegPerf, HKEY_LOCAL_MACHINE );
        if (regPerf)
        {
            regPerf.SetValue(_T("Library"), nlsDll );
            regPerf.SetValue(_T("Open"),    nlsOpen );
            regPerf.SetValue(_T("Close"),   nlsClose );
            regPerf.SetValue(_T("Collect"), nlsCollect );
        }
    }

    iisDebugOut_End1(_T("InstallPerformance"),nlsDll);
    return(err);
}
//
// Add eventlog to the registry
//
INT AddEventLog(BOOL fSystem, CString nlsService, CString nlsMsgFile, DWORD dwType)
{
    iisDebugOut_Start1(_T("AddEventLog"),nlsMsgFile);
    INT err = NERR_Success;
    CString nlsLog = (fSystem)? REG_EVENTLOG_SYSTEM : REG_EVENTLOG_APPLICATION;
    nlsLog += _T("\\");
    nlsLog += nlsService;

    CRegKey regService( nlsLog, HKEY_LOCAL_MACHINE );
    if ( regService )
    {
        regService.SetValue( _T("EventMessageFile"), nlsMsgFile, TRUE );
        regService.SetValue( _T("TypesSupported"), dwType );
    }
    iisDebugOut_End1(_T("AddEventLog"),nlsMsgFile);
    return(err);
}

//
// Remove eventlog from the registry
//

INT RemoveEventLog( BOOL fSystem, CString nlsService )
{
    iisDebugOut_Start1(_T("RemoveEventLog"),nlsService);
    INT err = NERR_Success;
    CString nlsLog = (fSystem)? REG_EVENTLOG_SYSTEM : REG_EVENTLOG_APPLICATION;

    CRegKey regService( HKEY_LOCAL_MACHINE, nlsLog );
    if ( regService )
    {
        regService.DeleteTree( nlsService );
    }
    iisDebugOut_End1(_T("RemoveEventLog"),nlsService);
    return(err);
}

//
// Install SNMP agent to the registry
//
INT InstallAgent( CString nlsName, CString nlsPath )
{
    iisDebugOut_Start1(_T("InstallAgent"),nlsPath);
    INT err = NERR_Success;
    do
    {
        CString nlsSnmpParam = REG_SNMPPARAMETERS;
        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ( regSnmpParam == (HKEY)NULL )
            break;

        CString nlsSoftwareMSFT = _T("Software\\Microsoft");
        CRegKey regSoftwareMSFT( HKEY_LOCAL_MACHINE, nlsSoftwareMSFT );
        if ( (HKEY) NULL == regSoftwareMSFT )
            break;

        // add agent key
        CRegKey regAgent( nlsName, regSoftwareMSFT );
        if ( (HKEY) NULL == regAgent )
            break;

        CString nlsCurVersion = _T("CurrentVersion");
        CRegKey regAgentCurVersion( nlsCurVersion, regAgent );
        if ((HKEY) NULL == regAgentCurVersion )
            break;
        regAgentCurVersion.SetValue(_T("Pathname"), nlsPath );

        CRegKey regAgentParam( nlsName, regSnmpParam );
        if ((HKEY) NULL == regAgentParam )
            break;

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( nlsSnmpExt, HKEY_LOCAL_MACHINE );
        if ((HKEY) NULL == regSnmpExt )
            break;

        // find the first available number slot
        for ( INT i=0; ;i++ )
        {
            CString nlsPos;
            nlsPos.Format( _T("%d"),i);
            CString nlsValue;

            if ( regSnmpExt.QueryValue( nlsPos, nlsValue ) != NERR_Success )
            {
                // okay, an empty spot
                nlsValue.Format(_T("%s\\%s\\%s"),_T("Software\\Microsoft"),(LPCTSTR)nlsName,_T("CurrentVersion") );

                regSnmpExt.SetValue( nlsPos, nlsValue );
                break;
            } else
            {
                if ( nlsValue.Find( nlsName) != (-1))
                {
                    break;
                }
            }
        }

    } while (FALSE);

    iisDebugOut_End1(_T("InstallAgent"),nlsPath);
    return(err);
}

//
// Remove an SNMP agent from the registry
//

INT RemoveAgent( CString nlsServiceName )
{
    iisDebugOut_Start1(_T("RemoveAgent"),nlsServiceName);
    INT err = NERR_Success;
    do
    {
        CString nlsSoftwareAgent = _T("Software\\Microsoft");

        CRegKey regSoftwareAgent( HKEY_LOCAL_MACHINE, nlsSoftwareAgent );
        if ((HKEY)NULL == regSoftwareAgent )
            break;
        regSoftwareAgent.DeleteTree( nlsServiceName );

        CString nlsSnmpParam = REG_SNMPPARAMETERS;

        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ((HKEY) NULL == regSnmpParam )
            break;
        regSnmpParam.DeleteTree( nlsServiceName );

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( HKEY_LOCAL_MACHINE, nlsSnmpExt );
        if ((HKEY) NULL == regSnmpExt )
            break;

        CRegValueIter enumSnmpExt( regSnmpExt );

        CString strName;
        DWORD dwType;
        CString csServiceName;

        csServiceName = _T("\\") + nlsServiceName;
        csServiceName += _T("\\");

        while ( enumSnmpExt.Next( &strName, &dwType ) == NERR_Success )
        {
            CString nlsValue;

            regSnmpExt.QueryValue( strName, nlsValue );

            if ( nlsValue.Find( csServiceName ) != (-1))
            {
                // found it
                regSnmpExt.DeleteValue( (LPCTSTR)strName );
                break;
            }
        }
    } while (FALSE);

    iisDebugOut_End1(_T("RemoveAgent"),nlsServiceName);
    return(err);
}

void lodctr(LPCTSTR lpszIniFile)
{
#ifndef _CHICAGO_
    iisDebugOut_Start1(_T("lodctr"),lpszIniFile);
    CString csCmdLine = _T("lodctr ");
    csCmdLine += g_pTheApp->m_csSysDir;
    csCmdLine += _T("\\");
    csCmdLine += lpszIniFile;

    iisDebugOut_Start((_T("loadperf.dll:LoadPerfCounterTextStrings")));
    LoadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE);
    iisDebugOut_End((_T("loadperf.dll:LoadPerfCounterTextStrings")));
    iisDebugOut_End1(_T("lodctr"),lpszIniFile);
#endif
    return;
}

void unlodctr(LPCTSTR lpszDriver)
{
#ifndef _CHICAGO_
    iisDebugOut_Start1(_T("unlodctr"),lpszDriver);
    CString csCmdLine = _T("unlodctr ");
    csCmdLine += lpszDriver;
    iisDebugOut_Start(_T("loadperf.dll:UnloadPerfCounterTextStrings"));
    UnloadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE);
    iisDebugOut_End((_T("loadperf.dll:UnloadPerfCounterTextStrings")));
    iisDebugOut_End1(_T("unlodctr"),lpszDriver);
#endif
    return;
}


typedef void (*P_SslGenerateRandomBits)( PUCHAR pRandomData, LONG size );
P_SslGenerateRandomBits ProcSslGenerateRandomBits = NULL;

BOOL GenRandom(int *lpGoop, DWORD cbGoop)
{
    BOOL fRet = FALSE;
    HCRYPTPROV hProv = 0;

    if (::CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
        if (::CryptGenRandom(hProv,cbGoop,(BYTE *) lpGoop))
        {
                    fRet = TRUE;
        }

    if (hProv) ::CryptReleaseContext(hProv,0);

    return fRet;
}


int GetRandomNum(void)
{
    int RandomNum;
    UCHAR cRandomByte;

    RandomNum = rand();

    __try
    {

        // call the random number function
        if (!GenRandom(& RandomNum,1))
        {
            // if that fails then try this one...
            if ( ProcSslGenerateRandomBits != NULL )
            {
                (*ProcSslGenerateRandomBits)( &cRandomByte, 1 );
                RandomNum = cRandomByte;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("nException Caught in SCHANNEL.dll:ProcSslGenerateRandomBits()=0x%x.."),GetExceptionCode()));
    }

    return(RandomNum);
}

void ShuffleCharArray(int iSizeOfTheArray, TCHAR * lptsTheArray)
{
    int i;
    int iTotal;
    int RandomNum;

    iTotal = iSizeOfTheArray / sizeof(_TCHAR);
    for (i=0; i<iTotal;i++ )
    {
        // shuffle the array
        RandomNum=GetRandomNum();
        TCHAR c = lptsTheArray[i];
        lptsTheArray[i]=lptsTheArray[RandomNum%iTotal];
        lptsTheArray[RandomNum%iTotal]=c;
    }
    return;
}


// password categories
enum {STRONG_PWD_UPPER=0,
      STRONG_PWD_LOWER,
      STRONG_PWD_NUM,
      STRONG_PWD_PUNC};

#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS 26
#define NUM_NUMBERS 10
#define MIN_PWD_LEN 8

// password must contain at least one each of:
// uppercase, lowercase, punctuation and numbers
DWORD CreateGoodPassword(BYTE *szPwd, DWORD dwLen) {

    if (dwLen-1 < MIN_PWD_LEN)
        return ERROR_PASSWORD_RESTRICTION;

    HCRYPTPROV hProv;
    DWORD dwErr = 0;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) == FALSE)
        return GetLastError();

    // zero it out and decrement the size to allow for trailing '\0'
    ZeroMemory(szPwd,dwLen);
    dwLen--;

    // generate a pwd pattern, each byte is in the range
    // (0..255) mod STRONG_PWD_CATS
    // this indicates which character pool to take a char from
    BYTE *pPwdPattern = new BYTE[dwLen];
    BOOL fFound[STRONG_PWD_CATS];
    do {
        // bug!bug! does CGR() ever fail?
        CryptGenRandom(hProv,dwLen,pPwdPattern);

        fFound[STRONG_PWD_UPPER] =
        fFound[STRONG_PWD_LOWER] =
        fFound[STRONG_PWD_PUNC] =
        fFound[STRONG_PWD_NUM] = FALSE;

        for (DWORD i=0; i < dwLen; i++)
            fFound[pPwdPattern[i] % STRONG_PWD_CATS] = TRUE;

#ifdef _DEBUG
            if (!fFound[STRONG_PWD_UPPER] ||
                !fFound[STRONG_PWD_LOWER] ||
                !fFound[STRONG_PWD_PUNC] ||
                !fFound[STRONG_PWD_NUM]) {
                iisDebugOut((LOG_TYPE_TRACE,_T("Oops! Regen pattern required [%d, %d, %d, %d]\n"),
                    fFound[STRONG_PWD_UPPER],
                    fFound[STRONG_PWD_LOWER],
                    fFound[STRONG_PWD_PUNC],
                    fFound[STRONG_PWD_NUM]));
             }
#endif

    // check that each character category is in the pattern
    } while (!fFound[STRONG_PWD_UPPER] ||
                !fFound[STRONG_PWD_LOWER] ||
                !fFound[STRONG_PWD_PUNC] ||
                !fFound[STRONG_PWD_NUM]);

    // populate password with random data
    // this, in conjunction with pPwdPattern, is
    // used to determine the actual data
    CryptGenRandom(hProv,dwLen,szPwd);

    for (DWORD i=0; i < dwLen; i++) {
        BYTE bChar = 0;

        // there is a bias in each character pool because of the % function
        switch (pPwdPattern[i] % STRONG_PWD_CATS) {

            case STRONG_PWD_UPPER : bChar = 'A' + szPwd[i] % NUM_LETTERS;
                                    break;

            case STRONG_PWD_LOWER : bChar = 'a' + szPwd[i] % NUM_LETTERS;
                                    break;

            case STRONG_PWD_NUM :   bChar = '0' + szPwd[i] % NUM_NUMBERS;
                                    break;

            case STRONG_PWD_PUNC :
            default:                char *szPunc="!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
                                    DWORD dwLenPunc = lstrlenA(szPunc);
                                    bChar = szPunc[szPwd[i] % dwLenPunc];
                                    break;
        }

        szPwd[i] = bChar;

#ifdef _DEBUG
        iisDebugOut((LOG_TYPE_TRACE,_T("[%03d] Pattern is %d, index is %d, char is '%c'\n"),i,pPwdPattern[i] % STRONG_PWD_CATS,szPwd[i],bChar));
#endif

    }

    delete pPwdPattern;

    if (hProv != NULL)
        CryptReleaseContext(hProv,0);

    return dwErr;
}


//
// Create a random password
//
void CreatePasswordOld(TCHAR *pszPassword, int iSize)
{
    //
    // Use Maximum available password length, as
    // setting any other length might run afoul
    // of the minimum password length setting
    //
    int nLength = (iSize - 1);
    int iTotal = 0;
    int RandomNum = 0;
    int i;
    TCHAR six2pr[64] =
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'), _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'),
        _T('N'), _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'), _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z'),
        _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'),
        _T('n'), _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'), _T('x'), _T('y'), _T('z'),
        _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('*'), _T('_')
    };

    // create a random password
    ProcSslGenerateRandomBits = NULL;

    HINSTANCE hSslDll = LoadLibraryEx(_T("schannel.dll"), NULL, 0 );
    if ( hSslDll )
        {
        ProcSslGenerateRandomBits = (P_SslGenerateRandomBits)GetProcAddress( hSslDll, "SslGenerateRandomBits");
        }
    else
    {
        // check if this file has missing file it's supposed to be linked with.
        // or if the file has mismatched import\export dependencies with linked files.
#ifdef _WIN64
        // don't call cause it's broken
#else
        //Check_File_Dependencies(_T("schannel.dll"));
#endif
    }

    // See the random number generation for rand() call in GetRandomNum()
    time_t timer;
    time( &timer );
    srand( (unsigned int) timer );

    // shuffle around the global six2pr[] array
    ShuffleCharArray(sizeof(six2pr), (TCHAR*) &six2pr);
    // assign each character of the password array
    iTotal = sizeof(six2pr) / sizeof(_TCHAR);
    for ( i=0;i<nLength;i++ )
    {
        RandomNum=GetRandomNum();
        pszPassword[i]=six2pr[RandomNum%iTotal];
    }

    //
    // in order to meet a possible
    // policy set upon passwords..
    //
    // replace the last 4 chars with these:
    //
    // 1) something from !@#$%^&*()-+=
    // 2) something from 1234567890
    // 3) an uppercase letter
    // 4) a lowercase letter
    //
    TCHAR something1[12] = {_T('!'), _T('@'), _T('#'), _T('$'), _T('^'), _T('&'), _T('*'), _T('('), _T(')'), _T('-'), _T('+'), _T('=')};
    ShuffleCharArray(sizeof(something1), (TCHAR*) &something1);
    TCHAR something2[10] = {_T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9')};
    ShuffleCharArray(sizeof(something2),(TCHAR*) &something2);
    TCHAR something3[26] = {_T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'), _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'), _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'), _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z')};
    ShuffleCharArray(sizeof(something3),(TCHAR*) &something3);
    TCHAR something4[26] = {_T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'), _T('n'), _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'), _T('x'), _T('y'), _T('z')};
    ShuffleCharArray(sizeof(something4),(TCHAR*)&something4);

    RandomNum=GetRandomNum();
    iTotal = sizeof(something1) / sizeof(_TCHAR);
    pszPassword[nLength-4]=something1[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something2) / sizeof(_TCHAR);
    pszPassword[nLength-3]=something2[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something3) / sizeof(_TCHAR);
    pszPassword[nLength-2]=something3[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something4) / sizeof(_TCHAR);
    pszPassword[nLength-1]=something4[RandomNum%iTotal];

    pszPassword[nLength]=_T('\0');

    if (hSslDll)
        {FreeLibrary( hSslDll );}
}


// Creates a secure password
// caller must GlobalFree Return pointer
// iSize = size of password to create
LPTSTR CreatePassword(int iSize)
{
    LPTSTR pszPassword =  NULL;
    BYTE *szPwd = new BYTE[iSize];
    DWORD dwPwdLen = iSize;
    int i = 0;

    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    if (0 == CreateGoodPassword(szPwd,dwPwdLen))
    {
#if defined(UNICODE) || defined(_UNICODE)
        // convert it to unicode and copy it back into our unicode buffer.
        // compute the length
        i = MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, NULL, 0);
        if (i <= 0)
            {goto CreatePassword_Exit;}
        pszPassword = (LPTSTR) GlobalAlloc(GPTR, i * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        i =  MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, pszPassword, i);
        if (i <= 0)
            {
            GlobalFree(pszPassword);
            pszPassword = NULL;
            goto CreatePassword_Exit;
            }
        // make sure ends with null
        pszPassword[i - 1] = 0;
#else
        pszPassword = (LPSTR) GlobalAlloc(GPTR, _tcslen((LPTSTR) szPwd) * sizeof(TCHAR));
#endif
    }
    else
    {
        iisDebugOut((LOG_TYPE_WARN,_T("CreateGoodPassword FAILED, using other password generator\n")));
        // CreateGoodPassword failed...
        // lets go with one that we know works...
        pszPassword = (LPTSTR) GlobalAlloc(GPTR, iSize * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        CreatePasswordOld(pszPassword,iSize);
    }

CreatePassword_Exit:
    if (szPwd){delete szPwd;szPwd=NULL;}
    return pszPassword;
}


BOOL RunProgram( LPCTSTR pszProgram, LPTSTR CmdLine, BOOL fMinimized , DWORD dwWaitTimeInSeconds, BOOL fCreateNewConsole)
{
    DWORD dwProcessType = NORMAL_PRIORITY_CLASS;
    STARTUPINFO si;
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof( STARTUPINFO );
    if (fMinimized)
    {
        GetStartupInfo(&si);
        si.dwFlags |= STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_HIDE;

        // Per bug #321409
        // if you don't specify sw_hide, then this
        // "accessibility magnifier" app will get funky focus events during setup
        // from this CreateProcess.
        //si.wShowWindow = SW_SHOWMINIMIZED;
    }
    PROCESS_INFORMATION pi;

    if (fCreateNewConsole)
    {
        dwProcessType = CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("RunProgram:Start:Exe=%1!s!,Parm=%2!s!,NewConsole"),pszProgram, CmdLine));    }
    else
    {
        // for some reason, a cmd window pops up during setup when we call "iisreset.exe /scm"
        // only way to prevent this is specify DETACHED_PROCESS
        dwProcessType = DETACHED_PROCESS | NORMAL_PRIORITY_CLASS;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("RunProgram:Start:Exe=%1!s!,Parm=%2!s!"),pszProgram, CmdLine));
    }

    if (!CreateProcess( pszProgram, CmdLine, NULL, NULL, FALSE, dwProcessType, NULL, NULL, &si, &pi ))
    {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RunProgram:Failed:Exe=%1!s!\n, Parm=%2!s!"),pszProgram, CmdLine));
        return FALSE;
    }

    if ( pi.hProcess != NULL )
    {
        DWORD dwSecondsToWait;

        if (dwWaitTimeInSeconds == INFINITE)
        {
            dwSecondsToWait = INFINITE;
        }
        else
        {
            dwSecondsToWait = dwWaitTimeInSeconds * 1000;
        }
        DWORD dwEvent = WaitForSingleObject( pi.hProcess, dwSecondsToWait);
        if ( dwEvent != ERROR_SUCCESS )
        {
            // check if wait failed
            if ( dwEvent == WAIT_FAILED )
                {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RunProgram:WaitForSingleObject() ERROR.WAIT_FAILED.Err=0x%1!x!."),GetLastError()));}
            else if ( dwEvent == WAIT_ABANDONED )
                {iisDebugOutSafeParams((LOG_TYPE_WARN, _T("RunProgram:WaitForSingleObject() WARNING.WAIT_ABANDONED.Err=0x%1!x!."),dwEvent));}
            else if ( dwEvent == WAIT_OBJECT_0 )
                {iisDebugOutSafeParams((LOG_TYPE_WARN, _T("RunProgram:WaitForSingleObject() WARNING.WAIT_OBJECT_0.Err=0x%1!x!."),dwEvent));}
            else if ( dwEvent == WAIT_TIMEOUT )
                {iisDebugOutSafeParams((LOG_TYPE_WARN, _T("RunProgram:WaitForSingleObject() WARNING.WAIT_TIMEOUT.Err=0x%1!x!."),dwEvent));}
            else
                {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RunProgram:WaitForSingleObject() FAILED.Err=0x%1!x!."),dwEvent));}

            TerminateProcess( pi.hProcess, 1 );
            CloseHandle( pi.hThread );
        }
        CloseHandle( pi.hProcess );
    }

    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("RunProgram:End:Exe=%1!s!,Parm=%2!s!"),pszProgram, CmdLine));
    return TRUE;
}


void SetAppFriendlyName(LPCTSTR szKeyPath)
{
    CString csKeyPath, csPath, csDesc;
    CStringArray aPath, aDesc;
    int nArray = 0, i = 0;
    CMDKey cmdKey;

    // szKeyPath is in the form of LM/W3SVC/i
    csKeyPath = szKeyPath;

    csPath = csKeyPath + _T("/Root");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_ROOT, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/IISADMIN");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_IISADMIN, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/WEBPUB");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_WEBPUB, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/IISSAMPLES");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_IISSAMPLES, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/IISHELP");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_IISHELP, csDesc);
    aDesc.Add(csDesc);

    nArray = (int)aPath.GetSize();
    for (i=0; i<nArray; i++)
    {
        cmdKey.OpenNode(aPath[i]);
        if ( (METADATA_HANDLE)cmdKey )
        {
            CString csName;
            TCHAR szName[_MAX_PATH];
            DWORD attr, uType, dType, cbLen;
            BOOL b;
            b = cmdKey.GetData(MD_APP_FRIENDLY_NAME, &attr, &uType, &dType, &cbLen, (PBYTE)szName, _MAX_PATH);
            if (!b || !(*szName))
            {
                csName = aDesc[i];
                cmdKey.SetData(MD_APP_FRIENDLY_NAME,METADATA_INHERIT,IIS_MD_UT_WAM,STRING_METADATA,(csName.GetLength() + 1) * sizeof(TCHAR),(LPBYTE)(LPCTSTR)csName);
            }
            cmdKey.Close();
        }
    }

    return;
}

void SetInProc( LPCTSTR szKeyPath)
{
    CString csKeyPath, csPath;
    CStringArray aPath;
    int nArray = 0, i = 0;
    CMDKey cmdKey;

    // szKeyPath is in the form of LM/W3SVC/i
    csKeyPath = szKeyPath;

    csPath = csKeyPath + _T("/Root/IISSAMPLES");
    aPath.Add(csPath);
    csPath = csKeyPath + _T("/Root/IISHELP");
    aPath.Add(csPath);
    csPath = csKeyPath + _T("/Root/WEBPUB");
    aPath.Add(csPath);

    nArray = (int)aPath.GetSize();
    for (i=0; i<nArray; i++) {
        cmdKey.OpenNode(aPath[i]);
        if ( (METADATA_HANDLE)cmdKey )
        {
            CString csName;
            TCHAR szName[_MAX_PATH];
            DWORD attr, uType, dType, cbLen;
            BOOL b;

            b = cmdKey.GetData(MD_APP_ROOT, &attr, &uType, &dType, &cbLen, (PBYTE)szName, _MAX_PATH);
            cmdKey.Close();

            if (!b || !(*szName))
            {
                CreateInProc_Wrap(aPath[i], TRUE);
            }
        }
    }

    return;
}


//------------------------------------------------------------------------------
// Add a custom error string to the existing custom errors. We are only adding FILE type
// error so that is assumed.
// dwCustErr is the ID of the error
// intSubCode is the sub code of the error. Pass in -1 to get a * for all subcodes
// szFilePath is the file to link to the custom error
// szKeyPath is the path in the metabase to write to
//#define  SZ_CUSTOM_ERROR          _T("404,*,FILE,%s\\help\\iishelp\\common\\404.htm|")
void AddCustomError(IN DWORD dwCustErr, IN INT intSubCode, IN LPCTSTR szErrorString, IN LPCTSTR szKeyPath, IN BOOL fOverwriteExisting )
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().Start.%d:%d:%s:%s:%d\n"),dwCustErr,intSubCode,szErrorString,szKeyPath,fOverwriteExisting ));
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    BOOL    fFoundExisting = FALSE;

    CString csCustomErrorString;

    // start by building our new error string
    // if intSubCode is < 1 use a * instead of a numerical value
    if ( intSubCode < 0 )
        csCustomErrorString.Format( _T("%d,*,%s"), dwCustErr, szErrorString );
    else
        csCustomErrorString.Format( _T("%d,%d,%s"), dwCustErr, intSubCode, szErrorString );

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().part1:%s\n"),csCustomErrorString));

    cmdKey.OpenNode(szKeyPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_INHERIT;
        DWORD dwUType = IIS_MD_UT_FILE;
        DWORD dwDType = MULTISZ_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        if (_tcsicmp(szKeyPath,_T("LM/W3SVC/Info")) == 0)
        {
            dwAttr = METADATA_NO_ATTRIBUTES;
            dwUType = IIS_MD_UT_SERVER;
            cmdKey.GetData( MD_CUSTOM_ERROR_DESC,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,MULTISZ_METADATA);
        }
        else
        {
            cmdKey.GetData( MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA);
        }

        // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
        // passing in a null ponter of 0 size in order to get the length of the data, it will always
        // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
        // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
        // in again.

        TCHAR*      pErrors;
        DWORD       cbBuffer = dwLength;

        // add enough space to the allocated space that we can just append the string
        cbBuffer += (csCustomErrorString.GetLength() + 4) * sizeof(WCHAR);
        dwLength = cbBuffer;

        // allocate the space, if it fails, we fail
        // note that GPTR causes it to be initialized to zero
        pData = GlobalAlloc( GPTR, cbBuffer );
        if ( !pData )
            {
            cmdKey.Close();
            return;
            }
        pErrors = (TCHAR*)pData;

        // now get the data from the metabase
        BOOL f;
        if (_tcsicmp(szKeyPath,_T("LM/W3SVC/Info")) == 0)
        {
            f = cmdKey.GetData( MD_CUSTOM_ERROR_DESC,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,MULTISZ_METADATA );
        }
        else
        {
            f = cmdKey.GetData( MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA );
        }

        // if we have successfully retrieved the existing custom errors, then we need to scan them
        // and remove or find any duplicates. Then we can add our new custom error. Then we can write it
        // out. If we didn't retrieve it, then we should just try to write out what we have.
        if ( f )
            {
            // got the existing errors, scan them now - pErrors will be pointing at the second end \0
            // when it is time to exit the loop.
            while ( *pErrors )
                {
                CString csError = pErrors;
                CString cs;
                DWORD   dwTestErrorID;
                INT     intTestSubCode;

                // get the first error ID code
                cs = csError.Left( csError.Find(_T(',')) );
                csError = csError.Right( csError.GetLength() - (cs.GetLength() +1) );
                _stscanf( cs, _T("%d"), &dwTestErrorID );

                // get the second code
                cs = csError.Left( csError.Find(_T(',')) );
                if ( cs == _T('*') )
                    intTestSubCode = -1;
                else
                    _stscanf( cs, _T("%d"), &intTestSubCode );

                // if it is the same, then chop off this custom error string and do NOT increment pErrors
                if ( (dwTestErrorID == dwCustErr) && (intTestSubCode == intSubCode) )
                    {
                    fFoundExisting = TRUE;
                    // NOTE: if we are not overwriting existing, then just break because we
                    // won't be doing anything after all - we found an existing one
                    if ( !fOverwriteExisting )
                    {
                        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().Do not overwritexisting\n")));
                        break;
                    }

                    // get the location of the next string in the multisz
                    TCHAR* pNext = _tcsninc( pErrors, _tcslen(pErrors))+1;

                    // Get the length of the data to copy
                    DWORD   cbCopyLength = cbBuffer - DIFF((PBYTE)pNext - (PBYTE)pData);

                    // copy the memory down.
                    MoveMemory( pErrors, pNext, cbCopyLength );

                    // do not increment the string
                    continue;
                    }

                // increment pErrors to the next string
                pErrors = _tcsninc( pErrors, _tcslen(pErrors))+1;
                }
            }

        // check if we need to finish this or not
        if ( fOverwriteExisting || !fFoundExisting )
            {
                // append our new error to the end of the list. The value pErrors should be pointing
                // to the correct location to copy it in to
                _tcscpy( pErrors, csCustomErrorString );

                // calculate the correct data length for this thing
                // get the location of the end of the multisz
                TCHAR* pNext = _tcsninc( pErrors, _tcslen(pErrors))+2;
                // Get the length of the data to copy
                cbBuffer = DIFF((PBYTE)pNext - (PBYTE)pData);

                // write the new errors list back out to the metabase
                if (_tcsicmp(szKeyPath,_T("LM/W3SVC/Info")) == 0)
                {
                    cmdKey.SetData(MD_CUSTOM_ERROR_DESC,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,MULTISZ_METADATA,cbBuffer,(PUCHAR)pData);
                }
                else
                {
                    cmdKey.SetData(MD_CUSTOM_ERROR,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA,cbBuffer,(PUCHAR)pData);
                }
            }
        else
        {
            //
            //
            //
        }

        // always close the metabase key
        cmdKey.Close();
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().OpenNode failed:%s\n"),szKeyPath));
    }

    // clean up
    if ( pData ){GlobalFree(pData);pData=NULL;}
    iisDebugOut_End((_T("AddCustomError")));
    return;
}


ScriptMapNode *AllocNewScriptMapNode(LPTSTR szExt, LPTSTR szProcessor, DWORD dwFlags, LPTSTR szMethods)
{
    ScriptMapNode *pNew = NULL;

    pNew = (ScriptMapNode *)calloc(1, sizeof(ScriptMapNode));
    if (pNew)
    {
        _tcscpy(pNew->szExt, szExt);
        _tcscpy(pNew->szProcessor, szProcessor);
        pNew->dwFlags = dwFlags;
        _tcscpy(pNew->szMethods, szMethods);
        pNew->prev = NULL;
        pNew->next = NULL;
    }

    return pNew;
}

//
// The script map should not be sored because
// the order is infact important.
void InsertScriptMapList(ScriptMapNode *pList, ScriptMapNode *p, BOOL fReplace)
{
    ScriptMapNode *t;
    int i;
    int bFound = FALSE;

    if (!p) {return;}

#ifdef SCRIPTMAP_SORTED
    t = pList->next;
    while (t != pList)
    {
        i = _tcsicmp(t->szExt, p->szExt);

        // if the next entry in the list is less than what we have.
        // then
        if (i < 0)
        {
            t = t->next;
            // continue
        }

        if (i == 0)
        {
            if (fReplace)
            {
                // replace t
                p->next = t->next;
                p->prev = t->prev;
                (t->prev)->next = p;
                (t->next)->prev = p;
                free(t);
            }
            else
            {
                // don't replace t
                free(p);
            }
            return;
        }

        if (i > 0)
        {
            // location found: insert before t
            break;
        }
    }

    // insert before t
    p->next = t;
    p->prev = t->prev;
    (t->prev)->next = p;
    t->prev = p;
#else
    // loop thru the whole list and see if we can find our entry.
    // if we cannot find it then add it to the end.
    // if we can find it then replace it if we need to.
    bFound = FALSE;
    t = pList->next;
    while (t != pList)
    {
        i = _tcsicmp(t->szExt, p->szExt);

        // we found a match, do replace or don't replace
        if (i == 0)
        {
            bFound = TRUE;
            if (fReplace)
            {
                // replace t
                p->next = t->next;
                p->prev = t->prev;
                (t->prev)->next = p;
                (t->next)->prev = p;
                free(t);
            }
            else
            {
                // don't replace t
                free(p);
            }
            return;
        }

        // Go get the next one
        t = t->next;
    }

    // see if we found something
    if (FALSE == bFound)
    {
        // insert before t
        p->next = t;
        p->prev = t->prev;
        (t->prev)->next = p;
        t->prev = p;
    }
#endif

    return;
}

void FreeScriptMapList(ScriptMapNode *pList)
{
    ScriptMapNode *t = NULL, *p = NULL;

    t = pList->next;
    while (t != pList)
    {
        p = t->next;
        free(t);
        t = p;
    }

    t->prev = t;
    t->next = t;

    return;
}


void GetScriptMapListFromRegistry(ScriptMapNode *pList)
{
    iisDebugOut_Start(_T("GetScriptMapListFromRegistry"), LOG_TYPE_TRACE);
    int iFound = FALSE;

    GetScriptMapListFromClean(pList, _T("ScriptMaps_CleanList"));

    CRegKey regScriptMap( HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3svc\\Parameters\\Script Map"));
    if ((HKEY)regScriptMap )
    {
        // delete mappings of .bat and .cmd
        regScriptMap.DeleteValue( _T(".bat") );
        regScriptMap.DeleteValue( _T(".cmd") );

        CRegValueIter regEnum( regScriptMap );
        CString csExt, csProcessor, csMethods;
        CString csTemp;
        ScriptMapNode *pNode;

        while ( regEnum.Next( &csExt, &csProcessor ) == ERROR_SUCCESS )
        {
            iFound = FALSE;
            csTemp = csProcessor;
            csTemp.MakeLower();
            csMethods = _T("");

            if (csTemp.Right(7) == _T("asp.dll"))
            {
                // Make sure it points to the new location...
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
                // asp has special methods.

                // add PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH 6/17 per vanvan for Dav.
                csMethods = _T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH");
            }

            if (csTemp.Right(7) == _T("ism.dll"))
            {
                // Make sure it points to the new location...
                // remap since ism.dll has a security hole
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
            }

            if (csTemp.Right(12) == _T("httpodbc.dll"))
            {
                // Make sure it points to the new location...
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\httpodbc.dll");
            }

            if (csTemp.Right(9) == _T("ssinc.dll"))
            {
                // Make sure it points to the new location...
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\ssinc.dll");
            }

            // Add it to the script map
            pNode = AllocNewScriptMapNode((LPTSTR)(LPCTSTR)csExt, (LPTSTR)(LPCTSTR)csProcessor, MD_SCRIPTMAPFLAG_SCRIPT, _T(""));
            InsertScriptMapList(pList, pNode, FALSE);
        }
    }
    iisDebugOut_End(_T("GetScriptMapListFromRegistry"),LOG_TYPE_TRACE);
    return;
}

void GetScriptMapListFromMetabase(ScriptMapNode *pList, int iUpgradeType)
{
    iisDebugOut_Start(_T("GetScriptMapListFromMetabase"), LOG_TYPE_TRACE);

    //DumpScriptMapList();
    // When upgrading from a metabase we should not add other script maps
    // which the user probably explicitly removed!
    // GetScriptMapListFromClean(pList, _T("ScriptMaps_CleanList"));
    //DumpScriptMapList();

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;

    CString csBinPath;

    cmdKey.OpenNode(_T("LM/W3SVC"));
    if ( (METADATA_HANDLE)cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0))
        {
            if ( ! (bufData.Resize(cbLen)) )
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        ScriptMapNode *pNode;
        CString csString;
        TCHAR szExt[32], szProcessor[_MAX_PATH], szMethods[_MAX_PATH];
        DWORD dwFlags;
        int i;
        if (bFound && (dType == MULTISZ_METADATA))
        {
            p = (LPTSTR)pData;
            while (*p)
            {
                rest = p + _tcslen(p) + 1;

                // szExt,szProcessor,dwFlags[,szMethods]

                LPTSTR q = p;
                i = 0;
                while ( *q )
                {
                    if (*q == _T(','))
                    {
                        i++;
                        *q = _T('\0');
                        q = _tcsinc(q);
                        if (i == 1)
                            _tcscpy(szExt, p);
                        if (i == 2)
                            _tcscpy(szProcessor, p);
                        if (i == 3)
                            break;
                        p = q;
                    }
                    else
                    {
                        q = _tcsinc(q);
                    }
                }
                dwFlags = atodw(p);
                _tcscpy(szMethods, q);

                CString csProcessor = szProcessor;
                csProcessor.MakeLower();

                //
                // Check if this is the one for asp.dll
                //
                if (csProcessor.Right(7) == _T("asp.dll"))
                {
                    // metabase should now have inclusion list and not exclusion list, so
                    // don't do this for UT_50. 2/23/99 aaronl.

                    // But UT_40 have a exclusion list.
                    // So we have to make sure it have the full exclusion list
                    if ( iUpgradeType == UT_40)
                    {
                        CString csMethods = szMethods;
                        csMethods.MakeUpper();

                        // changed 4/21/98 aaronl, added 'Options'
                        // add PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH 6/17 per vanvan for Dav.
                        if (csMethods.Find(_T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH")) == -1)
                        {
                            if (csMethods.IsEmpty())
                            {
                                // if it's empty, then put to the default.
                                csMethods = _T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH");
                            }
                            else
                            {
                                if (csMethods.Find(_T("GET")) == -1)
                                {
                                    // We didn't find the "GET" verb so we can safely say
                                    // that we are looking at an exclusion list
                                    CString csMethodsNew;
                                    csMethodsNew = _T("");

                                    // is put in there? if not add it
                                    if (csMethods.Find(_T("PUT")) == -1) {csMethodsNew += _T("PUT,");}
                                    if (csMethods.Find(_T("DELETE")) == -1) {csMethodsNew += _T("DELETE,");}
                                    if (csMethods.Find(_T("OPTIONS")) == -1) {csMethodsNew += _T("OPTIONS,");}
                                    if (csMethods.Find(_T("PROPFIND")) == -1) {csMethodsNew += _T("PROPFIND,");}
                                    if (csMethods.Find(_T("PROPPATCH")) == -1) {csMethodsNew += _T("PROPPATCH,");}
                                    if (csMethods.Find(_T("MKCOL")) == -1) {csMethodsNew += _T("MKCOL,");}
                                    if (csMethods.Find(_T("COPY")) == -1) {csMethodsNew += _T("COPY,");}
                                    if (csMethods.Find(_T("MOVE")) == -1) {csMethodsNew += _T("MOVE,");}
                                    if (csMethods.Find(_T("LOCK")) == -1) {csMethodsNew += _T("LOCK,");}
                                    if (csMethods.Find(_T("UNLOCK")) == -1) {csMethodsNew += _T("UNLOCK,");}
                                    if (csMethods.Find(_T("MS-SEARCH")) == -1) {csMethodsNew += _T("MS-SEARCH,");}

                                    // has an extra ',' at the end
                                    //csMethods = _T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH,");
                                    csMethods = csMethodsNew;
                                    csMethods += szMethods;
                                }
                            }
                            _tcscpy(szMethods, csMethods);
                        }
                    }

                    // make sure it points to the new asp.dll location
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                //
                // Check if this is the one for ism.dll
                //
                if (csProcessor.Right(7) == _T("ism.dll"))
                {
                    // make sure it points to the new location
                    // remap since ism.dll has a security hole
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                //
                // Check if this is the one for httpodbc.dll
                //
                if (csProcessor.Right(12) == _T("httpodbc.dll"))
                {
                    // make sure it points to the new location
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\httpodbc.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                //
                // Check if this is the one for ssinc.dll
                //
                if (csProcessor.Right(9) == _T("ssinc.dll"))
                {
                    // make sure it points to the new location
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\ssinc.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                p = rest; // points to the next string
                pNode = AllocNewScriptMapNode(szExt, szProcessor, dwFlags | MD_SCRIPTMAPFLAG_SCRIPT, szMethods);
                //iisDebugOut((LOG_TYPE_TRACE, _T("Calling InsertScriptMapList=%s:%s:%d:%s.\n"),szExt,szProcessor,dwFlags | MD_SCRIPTMAPFLAG_SCRIPT,szMethods));
                InsertScriptMapList(pList, pNode, TRUE);
            }
        }
    }

    iisDebugOut_End(_T("GetScriptMapListFromMetabase"),LOG_TYPE_TRACE);
    return;
}

void DumpScriptMapList()
{
    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;

    CString csBinPath;

    cmdKey.OpenNode(_T("LM/W3SVC"));
    if ( (METADATA_HANDLE)cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0))
        {
            if ( ! (bufData.Resize(cbLen)) )
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        CString csString;
        TCHAR szExt[32], szProcessor[_MAX_PATH], szMethods[_MAX_PATH];
        DWORD dwFlags;
        int i;
        if (bFound && (dType == MULTISZ_METADATA))
        {
            p = (LPTSTR)pData;
            while (*p)
            {
                rest = p + _tcslen(p) + 1;

                // szExt,szProcessor,dwFlags[,szMethods]

                LPTSTR q = p;
                i = 0;
                while ( *q )
                {
                    if (*q == _T(','))
                    {
                        i++;
                        *q = _T('\0');
                        q = _tcsinc(q);
                        if (i == 1)
                            _tcscpy(szExt, p);
                        if (i == 2)
                            _tcscpy(szProcessor, p);
                        if (i == 3)
                            break;
                        p = q;
                    }
                    else
                    {
                        q = _tcsinc(q);
                    }
                }
                dwFlags = atodw(p);
                _tcscpy(szMethods, q);

                CString csProcessor = szProcessor;
                csProcessor.MakeLower();

                iisDebugOut((LOG_TYPE_TRACE, _T("DumpScriptMapList=%s,%s,%s\n"),szExt, csProcessor,szMethods));

                p = rest; // points to the next string
            }
        }
    }

    return;
}


void WriteScriptMapListToMetabase(ScriptMapNode *pList, LPTSTR szKeyPath, DWORD dwFlags)
{
    iisDebugOut_Start1(_T("WriteScriptMapListToMetabase"), szKeyPath, LOG_TYPE_TRACE);

    CString csString, csTemp;
    ScriptMapNode *t = NULL;
    int len = 0;

    t = pList->next;
    while (t != pList)
    {
        if ( *(t->szMethods) )
            csTemp.Format( _T("%s,%s,%d,%s|"), t->szExt, t->szProcessor, (t->dwFlags | dwFlags), t->szMethods );
        else
            csTemp.Format( _T("%s,%s,%d|"), t->szExt, t->szProcessor, (t->dwFlags | dwFlags) );
        len += csTemp.GetLength();

        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("WriteScriptMapListToMetabase().ADDEntry=%1!s!\n"), csTemp));

        csString += csTemp;
        t = t->next;
    }

    if (len > 0)
    {
        HGLOBAL hBlock = NULL;

        len++;
        hBlock = GlobalAlloc(GPTR, len * sizeof(TCHAR));
        if (hBlock)
        {
            LPTSTR s;
            s = (LPTSTR)hBlock;
            _tcscpy(s, csString);
            while (*s)
            {
                if (*s == _T('|'))
                    {*s = _T('\0');}
                s = _tcsinc(s);
            }

            CMDKey cmdKey;
            cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
            if ( (METADATA_HANDLE)cmdKey )
            {
                cmdKey.SetData(MD_SCRIPT_MAPS,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA,len * sizeof(TCHAR),(LPBYTE)hBlock);
                cmdKey.Close();
            }
        }
    }

    iisDebugOut_End1(_T("WriteScriptMapListToMetabase"),szKeyPath,LOG_TYPE_TRACE);
    //DumpScriptMapList();
    return;
}


// this function does not use the va_list stuff because if
// there ever is this case: iisDebugOut("<SYSTEMROOT>") it will hose
// because it will try to put something in the %s part when there were no
// variables passed in.
void iisDebugOutSafe2(int iLogType, TCHAR * acsString)
{
    // Check what type of log this should be.
    int iProceed = FALSE;

    if (iLogType == LOG_TYPE_ERROR)
        {SetErrorFlag(__FILE__, __LINE__);}

    switch(iLogType)
        {
        case LOG_TYPE_TRACE_WIN32_API:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
                {iProceed = TRUE;}
            break;
                case LOG_TYPE_TRACE:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_PROGRAM_FLOW:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_PROGRAM_FLOW)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_WARN:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_WARN)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_ERROR:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_ERROR)
                {iProceed = TRUE;}
            break;
        default:
            // this must be an error
            iProceed = TRUE;
            break;
    }

    if (iProceed)
    {
        if (LOG_TYPE_ERROR == iLogType)
        {
            g_MyLogFile.LogFileWrite(_T("!FAIL! "));
        }
        // always output to the log file
        g_MyLogFile.LogFileWrite(_T("%s"), acsString);
        //#if DBG == 1 || DEBUG == 1 || _DEBUG == 1
            // OK.  Here is the deal.
            // nt5 does not want to see any OutputDebugString stuff
            // so, we need to remove it for them.
            // Actually we'll check the registry key
            // to see if it is turned on for the ocmanage component.
            // if it is then, set it on for us.
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
            {
                if (LOG_TYPE_ERROR == iLogType)
                    {OutputDebugString(_T("!FAIL!"));}
                // output to screen
                if (g_MyLogFile.m_szLogPreLineInfo) {OutputDebugString(g_MyLogFile.m_szLogPreLineInfo);}
                OutputDebugString(acsString);

                // if it does not end if '\r\n' then make one.
                int nLen = _tcslen(acsString);
                if (acsString[nLen-1] != _T('\n'))
                        {OutputDebugString(_T("\r\n"));}
            }
        //#endif // DBG
    }
    return;
}


void iisDebugOut2(int iLogType, TCHAR *pszfmt, ...)
{
    // Check what type of log this should be.
    int iProceed = FALSE;

    switch(iLogType)
        {
        case LOG_TYPE_TRACE_WIN32_API:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
                {iProceed = TRUE;}
            break;
                case LOG_TYPE_TRACE:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_PROGRAM_FLOW:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_PROGRAM_FLOW)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_WARN:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_WARN)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_ERROR:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_ERROR)
                {iProceed = TRUE;}
            break;
        default:
            // this must be an error
            iProceed = TRUE;
            break;
    }

    if (iProceed)
    {
        TCHAR acsString[1000];
        // Encompass this whole iisdebugout deal in a try-catch.
        // not too good to have this one access violating.
        // when trying to produce a debugoutput!
        __try
        {
            va_list va;
            va_start(va, pszfmt);
            _vstprintf(acsString, pszfmt, va);
            va_end(va);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TCHAR szErrorString[100];
            _stprintf(szErrorString, _T("\r\n\r\nException Caught in iisDebugOut2().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
            OutputDebugString(szErrorString);
            g_MyLogFile.LogFileWrite(szErrorString);
        }

        // output to log file and the screen.
        iisDebugOutSafe2(iLogType, acsString);
    }
    return;
}


// This function requires inputs like this:
//   iisDebugOutSafeParams2("this %1!s! is %2!s! and has %3!d! args", "function", "kool", 3);
//   you must specify the %1 deals.  this is so that
//   if something like this is passed in "this %SYSTEMROOT% %1!s!", it will put the string into %1 not %s!
void iisDebugOutSafeParams2(int iLogType, TCHAR *pszfmt, ...)
{
    // Check what type of log this should be.
    int iProceed = FALSE;
    switch(iLogType)
        {
        case LOG_TYPE_TRACE_WIN32_API:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
                {iProceed = TRUE;}
            break;
                case LOG_TYPE_TRACE:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_PROGRAM_FLOW:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_PROGRAM_FLOW)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_WARN:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_WARN)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_ERROR:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_ERROR)
                {iProceed = TRUE;}
            break;
        default:
            // this must be an error
            iProceed = TRUE;
            break;
    }

    if (iProceed)
    {
        // The count of parameters do not match
        va_list va;
        TCHAR *pszFullErrMsg = NULL;

        va_start(va, pszfmt);

        __try
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING, (LPCVOID) pszfmt, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &va);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TCHAR szErrorString[100];
            _stprintf(szErrorString, _T("\r\n\r\nException Caught in iisDebugOutSafeParams2().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
            OutputDebugString(szErrorString);
            g_MyLogFile.LogFileWrite(szErrorString);
        }

        if (pszFullErrMsg)
        {
            // output to log file and the screen.
            iisDebugOutSafe2(iLogType, pszFullErrMsg);
        }
        va_end(va);

        if (pszFullErrMsg) {LocalFree(pszFullErrMsg);pszFullErrMsg=NULL;}
    }
    return;
}


void HandleSpecificErrors(DWORD iTheErrorCode, DWORD dwFormatReturn, CString csMsg, TCHAR pMsg[], CString *pcsErrMsg)
{
    CString csErrMsg;
    CString csExtraMsg;

    switch(iTheErrorCode)
        {
                case NTE_BAD_SIGNATURE:
            // load extra error message for this error!
            MyLoadString(IDS_BAD_SIGNATURE_RELNOTES, csExtraMsg);

            if (dwFormatReturn) {csErrMsg.Format(_T("%s\n\n0x%x=%s\n\n%s"), csMsg, iTheErrorCode, pMsg, csExtraMsg);}
            else{csErrMsg.Format(_T("%s\n\nErrorCode=0x%x.\n\n%s"), csMsg, iTheErrorCode, csExtraMsg);}
            break;
        case CO_E_RUNAS_LOGON_FAILURE:
            // we should get the mts runas user from the registry and display it.

        default:
            // Put everything into csErrMsg
            if (dwFormatReturn) {csErrMsg.Format(_T("%s\n\n0x%x=%s"), csMsg, iTheErrorCode, pMsg);}
            else{csErrMsg.Format(_T("%s\n\nErrorCode=0x%x."), csMsg, iTheErrorCode);}
            break;
    }

    // copy the error string into the passed in CString
    (*pcsErrMsg) = csErrMsg;
    return;
}


//***************************************************************************
//*
//* purpose:
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoTaskMemAlloc().Start.")));
    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoTaskMemAlloc().End.")));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}


DWORD CallProcedureInDll_wrap(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag,BOOL iFunctionPrototypeFlag)
{
    int bFinishedFlag = FALSE;
    UINT iMsg = NULL;
    DWORD dwReturn = ERROR_SUCCESS;
    TCHAR szExceptionString[50] = _T("");
    LogHeapState(FALSE, __FILE__, __LINE__);

        do
        {
        __try
        {
                    dwReturn = CallProcedureInDll(lpszDLLFile, lpszProcedureToCall, bDisplayMsgOnErrFlag, bInitOleFlag, iFunctionPrototypeFlag);
            LogHeapState(FALSE, __FILE__, __LINE__);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ExceptionCaught!:CallProcedureInDll_wrap(): File:%1!s!, Procedure:%2!s!\n"), lpszDLLFile, lpszProcedureToCall));
            switch (GetExceptionCode())
            {
            case EXCEPTION_ACCESS_VIOLATION:
                _tcscpy(szExceptionString, _T("EXCEPTION_ACCESS_VIOLATION"));
                break;
            case EXCEPTION_BREAKPOINT:
                _tcscpy(szExceptionString, _T("EXCEPTION_BREAKPOINT"));
                break;
            case EXCEPTION_DATATYPE_MISALIGNMENT:
                _tcscpy(szExceptionString, _T("EXCEPTION_DATATYPE_MISALIGNMENT"));
                break;
            case EXCEPTION_SINGLE_STEP:
                _tcscpy(szExceptionString, _T("EXCEPTION_SINGLE_STEP"));
                break;
            case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
                _tcscpy(szExceptionString, _T("EXCEPTION_ARRAY_BOUNDS_EXCEEDED"));
                break;
            case EXCEPTION_FLT_DENORMAL_OPERAND:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_DENORMAL_OPERAND"));
                break;
            case EXCEPTION_FLT_DIVIDE_BY_ZERO:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_DIVIDE_BY_ZERO"));
                break;
            case EXCEPTION_FLT_INEXACT_RESULT:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_INEXACT_RESULT"));
                break;
            case EXCEPTION_FLT_INVALID_OPERATION:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_INVALID_OPERATION"));
                break;
            case EXCEPTION_FLT_OVERFLOW:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_OVERFLOW"));
                break;
            case EXCEPTION_FLT_STACK_CHECK:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_STACK_CHECK"));
                break;
            case EXCEPTION_FLT_UNDERFLOW:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_UNDERFLOW"));
                break;
            case EXCEPTION_INT_DIVIDE_BY_ZERO:
                _tcscpy(szExceptionString, _T("EXCEPTION_INT_DIVIDE_BY_ZERO"));
                break;
            case EXCEPTION_INT_OVERFLOW:
                _tcscpy(szExceptionString, _T("EXCEPTION_INT_OVERFLOW"));
                break;
            case EXCEPTION_PRIV_INSTRUCTION:
                _tcscpy(szExceptionString, _T("EXCEPTION_PRIV_INSTRUCTION"));
                break;
            case EXCEPTION_NONCONTINUABLE_EXCEPTION:
                _tcscpy(szExceptionString, _T("EXCEPTION_NONCONTINUABLE_EXCEPTION"));
                break;
            default:
                _tcscpy(szExceptionString, _T("Unknown Exception Type"));
                break;
            }
            //MyMessageBox( NULL, IDS_REGSVR_CAUGHT_EXCEPTION, lpszProcedureToCall, lpszDLLFile, GetExceptionCode(), MB_OK | MB_SETFOREGROUND );
            MyMessageBox( NULL, IDS_REGSVR_CAUGHT_EXCEPTION, szExceptionString, lpszProcedureToCall, lpszDLLFile, GetExceptionCode(), MB_OK | MB_SETFOREGROUND );
            dwReturn = ERROR_PROCESS_ABORTED;
        }

                if (dwReturn == ERROR_SUCCESS)
                {
                        break;
                }
                else
                {
                        if (bDisplayMsgOnErrFlag == TRUE)
                        {
                iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
                                switch ( iMsg )
                                {
                                    case IDRETRY:
                                            break;
                    case IDIGNORE:
                                    case IDABORT:
                    default:
                        // return whatever err happened
                                            goto CallProcedureInDll_wrap_Exit;
                        break;
                                }
                        }
                        else
                        {
                                // return whatever err happened
                                goto CallProcedureInDll_wrap_Exit;
                        }

        }
    } while (dwReturn != ERROR_SUCCESS);

CallProcedureInDll_wrap_Exit:
    return dwReturn;
}


void AddOLEAUTRegKey()
{
    CRegKey regCLSID46(_T("CLSID\\{00020424-0000-0000-C000-000000000046}"),HKEY_CLASSES_ROOT);
    if ((HKEY)regCLSID46)
    {
#ifdef _CHICAGO_
        regCLSID46.SetValue(_T(""), _T("PSAutomation"));
#else
        regCLSID46.SetValue(_T(""), _T("PSOAInterface"));
#endif
    }

    CRegKey regInProcServer(_T("CLSID\\{00020424-0000-0000-C000-000000000046}\\InprocServer"),HKEY_CLASSES_ROOT);
    if ((HKEY)regInProcServer)
    {
        regInProcServer.SetValue(_T(""), _T("ole2disp.dll"));
    }

    CRegKey regInProcServer32(_T("CLSID\\{00020424-0000-0000-C000-000000000046}\\InprocServer32"),HKEY_CLASSES_ROOT);
    if ((HKEY)regInProcServer32)
    {
        regInProcServer32.SetValue(_T(""), _T("oleaut32.dll"));
        regInProcServer32.SetValue(_T("ThreadingModel"), _T("Both"));
    }

    return;
}


// Returns:
// ERROR_SUCCESS if successfull.
// ERROR_OPERATION_ABORTED if the operation failed and the user wants to abort setup!
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction)
{
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("RegisterOLEControl():File=%1!s!, Action=%2!d!\n"), lpszOcxFile, fAction));

    DWORD dwReturn = ERROR_SUCCESS;
    if (fAction)
        {
        dwReturn = CallProcedureInDll_wrap(lpszOcxFile, _T("DllRegisterServer"), TRUE, TRUE, FUNCTION_PARAMS_NONE);
        }
    else
        {
#if DBG == 1 || DEBUG == 1 || _DEBUG == 1
        // Show errors if this is a debug build
        dwReturn = CallProcedureInDll_wrap(lpszOcxFile, _T("DllUnregisterServer"), TRUE, TRUE, FUNCTION_PARAMS_NONE);
#else
        // Set 3rd parameter to false so that there are no MyMessageBox popups if any errors
        dwReturn = CallProcedureInDll_wrap(lpszOcxFile, _T("DllUnregisterServer"), FALSE, TRUE, FUNCTION_PARAMS_NONE);
#endif
        }
    return dwReturn;
}


typedef HRESULT (CALLBACK *HCRET)(void);
typedef HRESULT (*PFUNCTION2)(HMODULE myDllHandle);

DWORD CallProcedureInDll(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag, BOOL iFunctionPrototypeFlag)
{
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("------------------\n")));
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("CallProcedureInDll(%1!s!): %2!s!\n"), lpszDLLFile, lpszProcedureToCall));
    DWORD dwReturn = ERROR_SUCCESS;
    HINSTANCE hDll = NULL;

    // Diferent function prototypes...
    HCRET hProc = NULL;
    PFUNCTION2 hProc2 = NULL;
    int iTempProcGood = FALSE;
    HRESULT hRes = 0;

    BOOL bBalanceOLE = FALSE;
    HRESULT hInitRes = NULL;

    int err = NOERROR;

    // Variables to changing and saving dirs
    TCHAR szDirName[_MAX_PATH], szFilePath[_MAX_PATH];
    // Variable to set error string
    TCHAR szErrString[256];

    _tcscpy(szDirName, _T(""));
    _tcscpy(szErrString, _T(""));

    // perform a defensive check
    if ( FAILED(FTestForOutstandingCoInits()) )
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Outstanding CoInit in %s. WARNING."), lpszDLLFile));
    }


    // If we need to initialize the ole library then init it.
    if (bInitOleFlag)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):start.\n")));
        bBalanceOLE = iOleInitialize();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):end.\n")));
        if (FALSE == bBalanceOLE)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):start.\n")));
            hInitRes = OleInitialize(NULL);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):end.\n")));
                        // Ole Failed.
                        dwReturn = hInitRes;
            SetLastError(dwReturn);
                    if (bDisplayMsgOnErrFlag)
                    {
                            MyMessageBox(NULL, IDS_OLE_INIT_FAILED, lpszDLLFile, hInitRes, MB_OK | MB_SETFOREGROUND);
                    }
                goto CallProcedureInDll_Exit;
                }
        }

        // Check if the file exists
    if (!IsFileExist(lpszDLLFile))
        {
                dwReturn = ERROR_FILE_NOT_FOUND;
                if (bDisplayMsgOnErrFlag)
                {
                        MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, lpszDLLFile, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
                }
        SetLastError(dwReturn);
        goto CallProcedureInDll_Exit;
        }

    // Change Directory
    GetCurrentDirectory( _MAX_PATH, szDirName );
    InetGetFilePath(lpszDLLFile, szFilePath);

    // Change to The Drive.
    if (-1 == _chdrive( _totupper(szFilePath[0]) - 'A' + 1 )) {}
    if (SetCurrentDirectory(szFilePath) == 0) {}

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(lpszDLLFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
        if (!hDll)
        {
                // Failed to load library, Probably because some .dll file is missing.
                // Show the error message.
                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CallProcedureInDll():%1!s!:%2!s!:LoadLibraryEx FAILED.\n"), lpszDLLFile, lpszProcedureToCall));

                if ( GetLastError() != ERROR_SUCCESS )
                {
                  dwReturn = GetLastError();
                }
                else
                {
                  dwReturn = ERROR_FILE_NOT_FOUND;
                }

                if (bDisplayMsgOnErrFlag)
                {
                        MyMessageBox(NULL, IDS_LOADLIBRARY_FAILED, lpszDLLFile, TYPE_E_CANTLOADLIBRARY, MB_OK | MB_SETFOREGROUND);
                }
        SetLastError(dwReturn);

        // check if this file has missing file it's supposed to be linked with.
        // or if the file has mismatched import\export dependencies with linked files.
#ifdef _WIN64
        // don't call cause it's broken
#else
        //Check_File_Dependencies(lpszDLLFile);
#endif

        goto CallProcedureInDll_Exit;
        }

        // Ok module was successfully loaded.  now let's try to get the Address of the Procedure
        // Convert the function name to ascii before passing it to GetProcAddress()
        char AsciiProcedureName[255];
#if defined(UNICODE) || defined(_UNICODE)
    // convert to ascii
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)lpszProcedureToCall, -1, AsciiProcedureName, 255, NULL, NULL );
#else
    // the is already ascii so just copy
    strcpy(AsciiProcedureName, lpszProcedureToCall);
#endif

    iTempProcGood = TRUE;
    if (iFunctionPrototypeFlag == FUNCTION_PARAMS_HMODULE)
    {
        hProc2 = (PFUNCTION2)GetProcAddress(hDll, AsciiProcedureName);
        if (!hProc2){iTempProcGood = FALSE;}
    }
    else
    {
        hProc = (HCRET)GetProcAddress(hDll, AsciiProcedureName);
        if (!hProc){iTempProcGood = FALSE;}
    }
        if (!iTempProcGood)
        {
                // failed to load,find or whatever this function.
                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CallProcedureInDll():%1!s!:%2!s!:() FAILED.\n"), lpszDLLFile, lpszProcedureToCall));
            dwReturn = ERROR_PROC_NOT_FOUND;
                if (bDisplayMsgOnErrFlag)
                {
                        MyMessageBox(NULL, IDS_UNABLE_TO_LOCATE_PROCEDURE, lpszProcedureToCall, lpszDLLFile, ERROR_PROC_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
                }
        SetLastError(dwReturn);
        goto CallProcedureInDll_Exit;
        }

        // Call the function that we got the handle to
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("CallProcedureInDll: Calling '%1!s!'.Start\n"), lpszProcedureToCall));
    __try
    {
        if (iFunctionPrototypeFlag == FUNCTION_PARAMS_HMODULE)
        {
            hRes = (*hProc2)((HMODULE) g_MyModuleHandle);
        }
        else
        {
            hRes = (*hProc)();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in CallProcedureInDll().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        OutputDebugString(szErrorString);
        g_MyLogFile.LogFileWrite(szErrorString);
    }

        if (FAILED(hRes))
        {
        dwReturn = ERROR_FUNCTION_FAILED;
                if (bDisplayMsgOnErrFlag)
                {
                        MyMessageBox(NULL, IDS_ERR_CALLING_DLL_PROCEDURE, lpszProcedureToCall, lpszDLLFile, hRes, MB_OK | MB_SETFOREGROUND);
                }
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CallProcedureInDll: Calling '%1!s!'.End.FAILED. Err=%2!x!.\n"), lpszProcedureToCall, hRes));
        // this function returns E_FAIL but
        // the actual error is in GetLastError()
        // set the last error to whatever was returned from the function call
        SetLastError(hRes);
        }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("CallProcedureInDll: Calling '%1!s!'.End.SUCCESS.\n"), lpszProcedureToCall));
    }

CallProcedureInDll_Exit:
    if (hDll)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("FreeLibrary.start.\n")));
        FreeLibrary(hDll);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("FreeLibrary.end.\n")));
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Did not FreeLibrary: %1!s! !!!!!!!!!!!!\n"), lpszDLLFile));
    }
    if (_tcscmp(szDirName, _T("")) != 0){SetCurrentDirectory(szDirName);}
    // To close the library gracefully, each successful call to OleInitialize,
    // including those that return S_FALSE, must be balanced by a corresponding
    // call to the OleUninitialize function.
    iOleUnInitialize(bBalanceOLE);

    // perform a defensive check
    if ( FAILED(FTestForOutstandingCoInits()) )
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Outstanding CoInit in %s. WARNING."), lpszDLLFile));
    }

    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("------------------\n")));
    return dwReturn;
}


int IsThisStringInThisCStringList(CStringList &strList, LPCTSTR szStringToLookFor)
{
    int iReturn = FALSE;

    if (strList.IsEmpty() == FALSE)
    {
        POSITION pos = NULL;
        CString csOurString;
        int nLen = 0;

        pos = strList.GetHeadPosition();
        while (pos)
        {
            csOurString = strList.GetAt(pos);
            nLen += csOurString.GetLength() + 1;

            // check if we have a match.
            if (0 == _tcsicmp(csOurString, szStringToLookFor))
            {
                // we found a match, return true!
                iReturn = TRUE;
                goto IsThisStringInThisCStringList_Exit;
            }
            strList.GetNext(pos);
        }

    }

IsThisStringInThisCStringList_Exit:
    return iReturn;
}




int KillProcess_Wrap(LPCTSTR lpFullPathOrJustFileName)
{
    int iReturn = FALSE;

    TCHAR szJustTheFileName[_MAX_FNAME];

    // make sure to get only just the filename.
    ReturnFileNameOnly(lpFullPathOrJustFileName, szJustTheFileName);

        // Convert it to ansi for our "kill" function
        char szFile[_MAX_FNAME];
        #if defined(UNICODE) || defined(_UNICODE)
                WideCharToMultiByte( CP_ACP, 0, (WCHAR*)szJustTheFileName, -1, szFile, _MAX_FNAME, NULL, NULL );
        #else
                _tcscpy(szFile, szJustTheFileName);
        #endif

        if (KillProcessNameReturn0(szFile) == 0)
    {
        iReturn = TRUE;
    }

    return iReturn;
}


void ProgressBarTextStack_Set(int iStringID)
{
    CString csText;
    MyLoadString(iStringID, csText);
    ProgressBarTextStack_Push(csText);
}


void ProgressBarTextStack_Set(int iStringID, const CString& csFileName)
{
    CString csText, csPart;

    // configuring the %s deal....
    MyLoadString(iStringID, csPart);

    // configuring the "filename" deal....
    csText.Format(csPart,csFileName);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_Set(int iStringID, const CString& csString1, const CString& csString2)
{
    CString csText, csPart;

    // configuring the %s deal....
    MyLoadString(iStringID, csPart);

    // configuring the "filename" deal....
    csText.Format(csPart,csString1, csString2);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_Set(LPCTSTR szProgressTextString)
{
    ProgressBarTextStack_Push(szProgressTextString);
}

void ProgressBarTextStack_Inst_Set( int ServiceNameID, int iInstanceNum)
{
    CString csText, csSvcs;

    // Configuring Web Site %d
    MyLoadString(ServiceNameID, csSvcs);
    // Configuring Web Site 1
    csText.Format(csSvcs, iInstanceNum);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_InstVRoot_Set( int ServiceNameID, int iInstanceNum, CString csVRName)
{
    CString csText, csSvcs;
    // Configuring Web Site %d, %s
    MyLoadString(ServiceNameID, csSvcs);
    // Configuring Web Site 1, Virtual Dir %s
    csText.Format(csSvcs, iInstanceNum, csVRName);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_InstInProc_Set( int ServiceNameID, int iInstanceNum, CString csVRName)
{
    CString csText, csSvcs;

    // Configuring Web Site %d, %s
    MyLoadString(ServiceNameID, csSvcs);
    // Configuring Web Site 1, In process Application %s
    csText.Format(csSvcs, iInstanceNum, csVRName);

    ProgressBarTextStack_Push(csText);
}


int ProcessEntry_CheckOS(IN LPCTSTR szOSstring)
{
    int iTempFlag = TRUE;
    int iOSTypes = 0;
    if (szOSstring)
    {
        // This is workstation, check if we should be installing this on workstation...
        if (g_pTheApp->m_eNTOSType == OT_NTW)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szOSstring))
                {iOSTypes = _ttoi(szOSstring);}
            if (iOSTypes == 0) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2) {iTempFlag = TRUE;}
            if (iOSTypes == 2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 2) {iTempFlag = TRUE;}
        }

        if (g_pTheApp->m_eNTOSType == OT_NTS)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szOSstring))
                {iOSTypes = _ttoi(szOSstring);}
            if (iOSTypes == 0) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2) {iTempFlag = TRUE;}
            if (iOSTypes == 1+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1) {iTempFlag = TRUE;}
        }

        if (g_pTheApp->m_eNTOSType == OT_PDC_OR_BDC)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szOSstring))
                {iOSTypes = _ttoi(szOSstring);}
            if (iOSTypes == 0) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2) {iTempFlag = TRUE;}
            if (iOSTypes == 1+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1) {iTempFlag = TRUE;}
        }
    }

    return iTempFlag;
}

int ProcessEntry_CheckEnterprise(IN LPCTSTR szEnterprise)
{
    int iTempFlag = TRUE;
    int iEnterpriseFlag = 0;
    if (szEnterprise)
    {
        if (IsValidNumber((LPCTSTR)szEnterprise))
            {iEnterpriseFlag = _ttoi(szEnterprise);}

        // This entry should only get installed on enterprise.
        // so check if this machine is an enterprise machine...
        if (iEnterpriseFlag != 0)
        {
            // if this is not an enterprise machine.
            // then return false, since it should not be installed.
            if (TRUE == iReturnTrueIfEnterprise())
            {
                iTempFlag = TRUE;
            }
            else
            {
                iTempFlag = FALSE;
            }
        }
    }

    return iTempFlag;
}

int ProcessEntry_PlatArch(IN LPCTSTR szPlatArch)
{
    int iTempFlag = TRUE;
    int iPlatArchTypes = 0;
    if (szPlatArch)
    {
        // This is x86, then check if we should be installing on x86
        if (_tcsicmp(g_pTheApp->m_csPlatform, _T("x86")) == 0)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szPlatArch))
                {iPlatArchTypes = _ttoi(szPlatArch);}
            if (iPlatArchTypes == 0) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 1+2) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 1) {iTempFlag = TRUE;}
        }

        if (_tcsicmp(g_pTheApp->m_csPlatform, _T("IA64")) == 0)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szPlatArch))
                {iPlatArchTypes = _ttoi(szPlatArch);}
            if (iPlatArchTypes == 0) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 1+2) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 2) {iTempFlag = TRUE;}
        }
    }
    return iTempFlag;
}


void ProcessEntry_AskLast(ThingToDo ParsedLine, int iWhichOneToUse)
{
    if (_tcsicmp(ParsedLine.szMsgBoxAfter, _T("1")) == 0)
    {
        // just incase we have don't display user messagebox off.
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
        // Make sure there are MyMessageBox popups!
        // Make sure there are MyMessageBox popups!
        g_pTheApp->m_bAllowMessageBoxPopups = TRUE;
        if (iWhichOneToUse == 2)
            {MyMessageBox( NULL, IDS_COMPLETED_FILE_CALL,ParsedLine.szData1,MB_OK | MB_SETFOREGROUND );}
        else
            {MyMessageBox( NULL, IDS_COMPLETED_FILE_CALL,ParsedLine.szFileName,MB_OK | MB_SETFOREGROUND );}
        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
    }
    return;
}


int ProcessEntry_AskFirst(ThingToDo ParsedLine, int iWhichOneToUse)
{
    int iReturn = TRUE;
    int iReturnTemp = 0;

    // check if we need to ask the user if they want to call it for sure.
    if (_tcsicmp(ParsedLine.szMsgBoxBefore, _T("1")) == 0)
    {
        // just incase we have don't display user messagebox off.
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
        // Make sure there are MyMessageBox popups!
        g_pTheApp->m_bAllowMessageBoxPopups = TRUE;
        if (iWhichOneToUse == 2)
        {
            iReturnTemp = MyMessageBox(NULL, IDS_BEFORE_CALLING_FILE, ParsedLine.szData1, MB_YESNO | MB_SETFOREGROUND);
        }
        else
        {
            iReturnTemp = MyMessageBox(NULL, IDS_BEFORE_CALLING_FILE, ParsedLine.szFileName, MB_YESNO | MB_SETFOREGROUND);
        }
        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

        // display the messagebox
        if (IDYES != iReturnTemp)
        {
            iReturn = FALSE;
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_AskFirst:MyMessageBox Response = IDNO. Exiting.\n")));
        }
    }

    return iReturn;
}

int ProcessEntry_CheckAll(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = TRUE;

    // Check if we pass for os system
    if (!ProcessEntry_CheckOS(ParsedLine.szOS))
    {
        iReturn = FALSE;
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ProcessEntry_CheckAll():File=%s. Section=%s. Should not be setup on this OS platform (workstation, server, etc...).  Skipping.\n"),ParsedLine.szFileName, szTheSection));
        goto ProcessEntry_CheckAll_Exit;
    }

    // check if we pass for platform arch
    if (!ProcessEntry_PlatArch(ParsedLine.szPlatformArchitecture))
    {
        iReturn = FALSE;
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ProcessEntry_CheckAll():File=%s. Section=%s. Should not be setup on this plat arch (%s).  Skipping.\n"), ParsedLine.szFileName, szTheSection, ParsedLine.szPlatformArchitecture));
        goto ProcessEntry_CheckAll_Exit;
    }

    // check if we pass for enterprise
    if (!ProcessEntry_CheckEnterprise(ParsedLine.szEnterprise))
    {
        iReturn = FALSE;
        goto ProcessEntry_CheckAll_Exit;
    }

ProcessEntry_CheckAll_Exit:
    return iReturn;
}



int ProcessEntry_CallDll(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("1")) != 0 && _tcsicmp(ParsedLine.szType, _T("2")) != 0 )
    {
        goto ProcessEntry_CallDll_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine ) )
    {
        goto ProcessEntry_CallDll_Exit;
    }

    // Make sure we have a value for the entry point..
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_CallDll_Exit;
    }

    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_CallDll_Exit;
    }

    // make sure the szFileName exists
    if (!IsFileExist(ParsedLine.szFileName))
    {
        // The file does not exists.
        // Check if we need to display an error!
        if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0)
        {
            // display the messagebox
            MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, ParsedLine.szFileName, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_CallDll():FileDoesNotExist=%s.\n"),ParsedLine.szFileName));
        }
        //goto ProcessEntry_CallDll_Exit;
    }

    // At this point the file exists...
    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    // update the progress bar if we need to
    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_CallDll_Exit;
    }

    // Call the function!!!!!
    if (_tcsicmp(ParsedLine.szType, _T("2")) == 0)
    {
        // Initialize OLE

        // check if they want us to pass them the hmodule for this module
        // so they can call our exported functions (for logging)
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, TRUE, FUNCTION_PARAMS_HMODULE);
        }
        else
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, TRUE, FUNCTION_PARAMS_NONE);
        }
    }
    else
    {
        // do not initialize ole!

        // check if they want us to pass them the hmodule for this module
        // so they can call our exported functions (for logging)
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, FALSE, FUNCTION_PARAMS_HMODULE);
        }
        else
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, FALSE, FUNCTION_PARAMS_NONE);
        }
    }

    iReturn = TRUE;

    if (ParsedLine.szChangeDir)
    {
        if (szDirBefore)
        {
            // change back to the original dir
            SetCurrentDirectory(szDirBefore);
        }
    }

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);


ProcessEntry_CallDll_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}



int ProcessEntry_Call_Exe(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempNotMinimizedFlag = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    int iReturnCode = FALSE;
    int iType = 0;
    DWORD dwTimeOut = INFINITE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("3")) != 0)
    {
        goto ProcessEntry_Call_Exe_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Call_Exe_Exit;
    }

    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_Call_Exe_Exit;
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Call_Exe_Exit;
    }

    // make sure the szFileName exists
    if (!IsFileExist(ParsedLine.szFileName))
    {
        // The file does not exists.
        // Check if we need to display an error!
        if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0)
        {
            // display the messagebox
            MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, ParsedLine.szFileName, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_Call_Exe():FileDoesNotExist=%s.\n"),ParsedLine.szFileName));
        }
        //goto ProcessEntry_Call_Exe_Exit;
    }

    // Run The Executable...
    // iShowErrorsOnFail
    iReturnCode = FALSE;
    iType = 0;
    TCHAR szFullPathString[_MAX_PATH + _MAX_PATH + _MAX_PATH];
    _tcscpy(szFullPathString, ParsedLine.szFileName);
    _tcscat(szFullPathString, _T(" "));
    _tcscat(szFullPathString, ParsedLine.szData1);

    // Check if they specified timeout in sections.
    dwTimeOut = INFINITE;
    if (_tcsicmp(ParsedLine.szData2, _T("")) != 0)
        {dwTimeOut = atodw(ParsedLine.szData2);}

    if (_tcsicmp(ParsedLine.szData3, _T("")) != 0)
        {iType = _ttoi(ParsedLine.szData3);}

    if (_tcsicmp(ParsedLine.szData4, _T("")) != 0)
        {iTempNotMinimizedFlag = TRUE;}

    if (ParsedLine.szData1 && _tcsicmp(ParsedLine.szData1, _T("")) != 0)
        {
            switch (iType)
            {
                case 1:
                        iReturnCode = RunProgram(ParsedLine.szFileName, ParsedLine.szData1, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
                        break;
                case 2:
                        iReturnCode = RunProgram(szFullPathString, NULL, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
                        break;
                default:
                        iReturnCode = RunProgram(NULL, szFullPathString, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
            }
       }
    else
        {
        iReturnCode = RunProgram(ParsedLine.szFileName, NULL, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
        }
    if (iReturnCode != TRUE)
        {
        if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
        else{iisDebugOut((LOG_TYPE_TRACE, _T("RunProgram(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }


    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir)
        {if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

ProcessEntry_Call_Exe_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


// 100=4
int ProcessEntry_Internal_iisdll(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    int iReturnCode = FALSE;
    DWORD dwTimeOut = INFINITE;

    int iFound = FALSE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("4")) != 0)
    {
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_TRACE,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    // Get the internal function to call...
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_common")) == 0)
        {iReturnCode = Register_iis_common();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_core")) == 0)
        {iReturnCode = Register_iis_core();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_inetmgr")) == 0)
        {iReturnCode = Register_iis_inetmgr();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_pwmgr")) == 0)
        {iReturnCode = Register_iis_pwmgr();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_doc")) == 0)
        {iReturnCode = Register_iis_doc();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_www")) == 0)
        {iReturnCode = Register_iis_www();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_ftp")) == 0)
        {iReturnCode = Register_iis_ftp();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_old_asp")) == 0)
        {iReturnCode = Unregister_old_asp();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_common")) == 0)
        {iReturnCode = Unregister_iis_common();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_core")) == 0)
        {iReturnCode = Unregister_iis_core();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_inetmgr")) == 0)
        {iReturnCode = Unregister_iis_inetmgr();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_pwmgr")) == 0)
        {iReturnCode = Unregister_iis_pwmgr();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_www")) == 0)
        {iReturnCode = Unregister_iis_www();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_ftp")) == 0)
        {iReturnCode = Unregister_iis_ftp();iFound=TRUE;}


    if (iFound != TRUE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  _T("%s():FAILURE. Internal Function Does not exist. entry=%s. Section=%s.\n"), _T("ProcessEntry_Internal_iisdll"), csEntry, szTheSection));
    }

    /*
    if (iReturnCode != TRUE)
        {
        if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
        else{iisDebugOut((LOG_TYPE_TRACE, _T("RunProgram(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }
    */


    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir)
        {if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

ProcessEntry_Internal_iisdll_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_Call_Section(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("0")) != 0 && _tcsicmp(ParsedLine.szType, _T("5")) != 0 && _tcsicmp(ParsedLine.szType, _T("6")) != 0 )
    {
        goto ProcessEntry_6_Exit;
    }

    // make sure we have a INF Section
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_6_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, ParsedLine.szData1, ParsedLine) )
    {
        goto ProcessEntry_6_Exit;
    }

    // set the show erros on fail flag
    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    // update the progress bar if we need to
    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 2))
    {
        goto ProcessEntry_6_Exit;
    }


    //
    //
    // Run The INF Section ...
    //
    // ParsedLine.szData1
    //

    if ( _tcsicmp(ParsedLine.szType, _T("5")) == 0)
    {
        //
        // Do another one of these "special" install sections
        //
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
        iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));

            // Check if it failed...
            if (FALSE == iTempFlag)
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("SetupInstallFromInfSection(%s). section missing\n"), ParsedLine.szData1));
            }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("6")) == 0)
    {
        //
        // Do a regular ole inf section
        //
        TSTR strTempSectionName;

        if ( strTempSectionName.Copy( ParsedLine.szData1 ) &&
             GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTempSectionName)
           )
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling InstallInfSection:%1!s!:Start.\n"), ParsedLine.szData1));
            iTempFlag = InstallInfSection_NoFiles(g_pTheApp->m_hInfHandle,_T(""),strTempSectionName.QueryStr());
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling InstallInfSection:%1!s!:End.\n"), ParsedLine.szData1));

            // Check if it failed...
            if (FALSE == iTempFlag)
            {
                // the call failed..
                iisDebugOut((LOG_TYPE_WARN, _T("SetupInstallFromInfSection(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("0")) == 0)
    {
        //
        // Do a special installsection deal which queues files in the ocm manage global file queue.
        //
        if (g_GlobalFileQueueHandle)
        {
            // SP_COPY_NOPRUNE = setupapi has a new deal which will prune files from the copyqueue if they already exist on the system.
            //                   however, the problem with the new deal is that the pruning code does not check if you have the same file
            //                   queued in the delete or rename queue.  specify SP_COPY_NOPRUNE to make sure that our file never gets
            //                   pruned (removed) from the copy queue. aaronl 12/4/98
            int iCopyType = SP_COPY_NOPRUNE;
            //int iCopyType = SP_COPY_FORCE_NEWER | SP_COPY_NOPRUNE;
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0)
                {iCopyType = _ttoi(ParsedLine.szData2);}

            TSTR strTempSectionName;

            if ( strTempSectionName.Copy( ParsedLine.szData1 ) &&
                 GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTempSectionName)
               )
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("Calling SetupInstallFilesFromInfSection:%1!s!, copytype=%2!d!:Start.\n"), ParsedLine.szData1, iCopyType));
                iTempFlag = SetupInstallFilesFromInfSection(g_pTheApp->m_hInfHandle,NULL,g_GlobalFileQueueHandle,strTempSectionName.QueryStr(),NULL,iCopyType);
                g_GlobalFileQueueHandle_ReturnError = iTempFlag;
            }
        }

        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling SetupInstallFilesFromInfSection:%1!s!:End.\n"), ParsedLine.szData1));

        // Check if it failed...
        if (FALSE == iTempFlag)
        {
            // the call failed..
            iisDebugOut((LOG_TYPE_WARN, _T("SetupInstallFromInfSection(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));
        }
    }

    iReturn = TRUE;

    if (ParsedLine.szChangeDir)
    {
        if (szDirBefore)
        {
            // change back to the original dir
            SetCurrentDirectory(szDirBefore);
        }
    }

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,2);

ProcessEntry_6_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_Misc1(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("7")) != 0 && _tcsicmp(ParsedLine.szType, _T("8")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("9")) != 0 && _tcsicmp(ParsedLine.szType, _T("10")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("11")) != 0 && _tcsicmp(ParsedLine.szType, _T("12")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("12")) != 0 && _tcsicmp(ParsedLine.szType, _T("13")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("14")) != 0 && _tcsicmp(ParsedLine.szType, _T("17")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("18")) != 0
         )
    {
        goto ProcessEntry_Misc1_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Misc1_Exit;
    }

    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        // type 10
        // type 12 do not need filename
        if ( _tcsicmp(ParsedLine.szType, _T("10")) != 0 && _tcsicmp(ParsedLine.szType, _T("12")) != 0)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }
    }

    //
    // Counters.ini files are always in the system dir
    // tack on the extra stuff, and make sure the file exists...
    //
    if ( _tcsicmp(ParsedLine.szType, _T("7")) == 0)
    {
        CString csFullFilePath;
        csFullFilePath = g_pTheApp->m_csSysDir;
        csFullFilePath += _T("\\");
        csFullFilePath += ParsedLine.szFileName;
        // make sure the szFileName exists
        if (!IsFileExist(csFullFilePath))
        {
            // The file does not exists.
            // Check if we need to display an error!
            if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0)
            {
                // display the messagebox
                MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, csFullFilePath, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_Misc1():FileDoesNotExist=%s.\n"),csFullFilePath));
            }
            goto ProcessEntry_Misc1_Exit;
        }
    }

    //
    // Check if the binary exists for addevent log!
    //
    if ( _tcsicmp(ParsedLine.szType, _T("9")) == 0)
    {
        // make sure the szFileName exists
        if (!IsFileExist(ParsedLine.szFileName))
        {
            // The file does not exists.
            // Check if we need to display an error!
            if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0)
            {
                // display the messagebox
                MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, ParsedLine.szFileName, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_Misc1():FileDoesNotExist=%s.\n"),ParsedLine.szFileName));
            }
            goto ProcessEntry_Misc1_Exit;
        }
    }

    // if this is for addevent log, then check for the other information...
    //  AddEventLog( TRUE, _T("W3SVC"), csBinPath, 0x0 );
    //  InstallPerformance(REG_WWWPERFORMANCE, _T("w3ctrs.DLL"), _T("OpenW3PerformanceData"), _T("CloseW3PerformanceData"), _T("CollectW3PerformanceData"));
    if ( _tcsicmp(ParsedLine.szType, _T("9")) == 0 || _tcsicmp(ParsedLine.szType, _T("13")) == 0)
    {
        // make sure we have a szData1 entry (
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        // make sure we have a szData3 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("13")) == 0)
        {
            // make sure we have a szData4 entry
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_Misc1_Exit;
            }
        }

    }


    // if this is for addevent log, then check for the other information...
    //RemoveEventLog( FALSE, _T("W3Ctrs") );
    if ( _tcsicmp(ParsedLine.szType, _T("10")) == 0)
    {
        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }
    }

    // if this is for installAgent, check for other data..
    //
    // INT InstallAgent( CString nlsName, CString nlsPath )
    // INT RemoveAgent( CString nlsServiceName )
    //
    if ( _tcsicmp(ParsedLine.szType, _T("11")) == 0 || _tcsicmp(ParsedLine.szType, _T("12")) == 0)
    {
        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Misc1_Exit;
    }


    //
    // send this to the lodctr function...
    // lodctr(_T("w3ctrs.ini"));
    //
    // see if it's lodctr or unlodctr ....
    //
    if ( _tcsicmp(ParsedLine.szType, _T("7")) == 0)
    {
        lodctr(ParsedLine.szFileName);
    }

    // if this is a unlodctr, should look like this....
    //
    // unlodctr( _T("W3SVC") );
    //
    if ( _tcsicmp(ParsedLine.szType, _T("8")) == 0)
    {
        unlodctr(ParsedLine.szFileName);
    }

    // if this is a AddEventLog, should look like this...
    //
    // AddEventLog( TRUE, _T("W3SVC"), csBinPath, 0x0 );
    //
    if ( _tcsicmp(ParsedLine.szType, _T("9")) == 0)
    {
        int iTempSystemFlag = 0;
        int dwTempEventLogtype = 0;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0){iTempSystemFlag = 1;}
        dwTempEventLogtype = atodw(ParsedLine.szData3);
        // Call event log registration function
        AddEventLog( iTempSystemFlag, ParsedLine.szData1, ParsedLine.szFileName, dwTempEventLogtype);
    }

    // if this is a RemoveEventLog, should look like this...
    //
    // RemoveEventLog( FALSE, _T("W3Ctrs") );
    //
    if ( _tcsicmp(ParsedLine.szType, _T("10")) == 0)
    {
        int iTempSystemFlag = 0;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0){iTempSystemFlag = 1;}
        // Call event log registration function
        RemoveEventLog(iTempSystemFlag, ParsedLine.szData1);
    }

    // if this is installagent
    //
    // INT InstallAgent( CString nlsName, CString nlsPath )
    // INT RemoveAgent( CString nlsServiceName )
    //
    if ( _tcsicmp(ParsedLine.szType, _T("11")) == 0)
    {
        InstallAgent(ParsedLine.szData1, ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("12")) == 0)
    {
        RemoveAgent(ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("13")) == 0)
    {
        InstallPerformance(ParsedLine.szData1, ParsedLine.szFileName, ParsedLine.szData2, ParsedLine.szData3, ParsedLine.szData4);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("14")) == 0)
    {
        CString csPath = ParsedLine.szFileName;
        CreateLayerDirectory(csPath);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("17")) == 0)
    {
        int iUseWildCards = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iUseWildCards = TRUE;}

        CString csPath = ParsedLine.szFileName;
        if (iUseWildCards)
        {
            TCHAR szTempDir[_MAX_DRIVE + _MAX_PATH];
            TCHAR szTempFileName[_MAX_PATH + _MAX_EXT];
            if (ReturnFilePathOnly(csPath,szTempDir))
            {
                if (TRUE == ReturnFileNameOnly(csPath, szTempFileName))
                   {DeleteFilesWildcard(szTempDir,szTempFileName);}
            }
        }
        else
        {
            InetDeleteFile(csPath);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("18")) == 0)
    {
        int iTempDeleteEvenIfFull = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iTempDeleteEvenIfFull = 1;}

        CString csPath = ParsedLine.szFileName;
        if (iTempDeleteEvenIfFull)
        {
            RecRemoveDir(csPath);
        }
        else
        {
            RecRemoveEmptyDir(csPath);
        }
    }

    // We called the function, so return true.
    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir){if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    ProcessEntry_AskLast(ParsedLine, 1);


ProcessEntry_Misc1_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_SVC_Clus(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iReturnTemp = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    DWORD dwFailed = ERROR_SUCCESS;


    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("50")) != 0 && _tcsicmp(ParsedLine.szType, _T("51")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("52")) != 0 && _tcsicmp(ParsedLine.szType, _T("53")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("54")) != 0 && _tcsicmp(ParsedLine.szType, _T("55")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("56")) != 0 && _tcsicmp(ParsedLine.szType, _T("57")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("58")) != 0 && _tcsicmp(ParsedLine.szType, _T("59")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("60")) != 0 && _tcsicmp(ParsedLine.szType, _T("61")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("62")) != 0 && _tcsicmp(ParsedLine.szType, _T("63")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("64")) != 0 && _tcsicmp(ParsedLine.szType, _T("65")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("66")) != 0  && _tcsicmp(ParsedLine.szType, _T("67")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("68")) != 0  && _tcsicmp(ParsedLine.szType, _T("69")) != 0
        )
    {
        goto ProcessEntry_SVC_Clus_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_SVC_Clus_Exit;
    }

    if (_tcsicmp(ParsedLine.szType, _T("66")) == 0 || _tcsicmp(ParsedLine.szType, _T("67")) == 0)
    {
        // make sure not to require 102 parameter for 66 or 67
    }
    else
    {
        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("50")) == 0 || _tcsicmp(ParsedLine.szType, _T("52")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }

        CString csFullFilePath;
        // Check if the file exists....
        if ( _tcsicmp(ParsedLine.szType, _T("50")) == 0)
        {
            csFullFilePath = g_pTheApp->m_csSysDir;
            csFullFilePath += _T("\\Drivers\\");
            csFullFilePath += ParsedLine.szFileName;
        }
        else
        {
            csFullFilePath = ParsedLine.szFileName;
        }
        // make sure the szFileName exists
        if (!IsFileExist(csFullFilePath))
        {
            // The file does not exists.
            // Check if we need to display an error!
            if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0)
            {
                // display the messagebox
                MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, csFullFilePath, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
                goto ProcessEntry_SVC_Clus_Exit;
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("o ProcessEntry_SVC_Clus():FileDoesNotExist=%s.\n"),csFullFilePath));
            }
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }
    }


    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_SVC_Clus_Exit;
    }

    // Run The Executable...
    // iShowErrorsOnFail
    dwFailed = ERROR_SUCCESS;
    // Call the function!!!!!
    if (_tcsicmp(ParsedLine.szType, _T("50")) == 0)
    {
        // Create the driver, retry if failed...
        dwFailed = CreateDriver_Wrap(ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szFileName, TRUE);
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("CreateDriver(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }
    if (_tcsicmp(ParsedLine.szType, _T("51")) == 0)
    {
        // Remove driver.
        dwFailed = InetDeleteService( ParsedLine.szData1 );
        if (dwFailed != 0)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("InetDeleteService(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
        // flag the reboot flag.
        SetRebootFlag();
    }
    if (_tcsicmp(ParsedLine.szType, _T("52")) == 0)
    {
        // Create the service, retry if failed...
        dwFailed = CreateService_wrap(ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szFileName, ParsedLine.szData3, ParsedLine.szData4, TRUE);
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("CreateService(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }

    }

    if (_tcsicmp(ParsedLine.szType, _T("53")) == 0)
    {
        // Remove Service.
        dwFailed = InetDeleteService( ParsedLine.szData1 );
        if (dwFailed != 0 && dwFailed != ERROR_SERVICE_DOES_NOT_EXIST)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("InetDeleteService(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }

    if (_tcsicmp(ParsedLine.szType, _T("54")) == 0)
    {
        // Start Service
        dwFailed = InetStartService(ParsedLine.szData1);
        if (dwFailed == 0 || dwFailed == ERROR_SERVICE_ALREADY_RUNNING)
        {
            // yeah, the service started.
            iReturn = TRUE;
        }
        else
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_WARN, _T("InetStartService(%s).  Unable to start.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
    }

    if (_tcsicmp(ParsedLine.szType, _T("55")) == 0)
    {
        int iAddToRestartList=FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) {iAddToRestartList=TRUE;}

        // Stop Service
        dwFailed = StopServiceAndDependencies(ParsedLine.szData1, iAddToRestartList);
        if (dwFailed == FALSE)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            // yeah, the service stopped.
            iReturn = TRUE;
        }
    }

    if (_tcsicmp(ParsedLine.szType, _T("56")) == 0 || _tcsicmp(ParsedLine.szType, _T("57")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("56")) == 0) {iAdd = TRUE;}
        // map/unmap to HTTP
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_HTTPGuid, 0, 80, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("58")) == 0 || _tcsicmp(ParsedLine.szType, _T("59")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("58")) == 0) {iAdd = TRUE;}
        // map/unmap to FTP
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_FTPGuid, 0, 21, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("60")) == 0 || _tcsicmp(ParsedLine.szType, _T("61")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("60")) == 0) {iAdd = TRUE;}
        // map/unmap to Gopher
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_GopherGuid, 0, 70, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("62")) == 0 || _tcsicmp(ParsedLine.szType, _T("63")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("62")) == 0) {iAdd = TRUE;}
        // map/unmap to Inetinfo
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_InetInfoGuid, 0x64e, 0x558, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("64")) == 0 || _tcsicmp(ParsedLine.szType, _T("65")) == 0)
    {
        iReturn = TRUE;

        // make sure we have everything
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }

        if (_tcsicmp(ParsedLine.szType, _T("64")) == 0)
        {
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_SVC_Clus_Exit;
            }
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_SVC_Clus_Exit;
            }

            // this function only takes wide characters...
#ifndef _CHICAGO_
            iReturn = RegisterIisServerInstanceResourceType(ParsedLine.szFileName,ParsedLine.szData1,ParsedLine.szData2,ParsedLine.szData3);
#else
            iisDebugOut((LOG_TYPE_TRACE,  _T("RegisterIisServerInstanceResourceType(): not supported under ansi. only unicode.") ));
#endif
        }
        else
        {
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) {iTempFlag = TRUE;}

            // this function only takes wide characters...
#ifndef _CHICAGO_
            iReturn = UnregisterIisServerInstanceResourceType(ParsedLine.szFileName,ParsedLine.szData1,iTempFlag,TRUE);
#else
            iisDebugOut((LOG_TYPE_TRACE,  _T("UnregisterIisServerInstanceResourceType(): not supported under ansi. only unicode.") ));
#endif
        }
        // iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("66")) == 0)
    {
#ifndef _CHICAGO_
        DWORD dwReturn = 0;
        dwReturn = BringALLIISClusterResourcesOffline();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOffline ret=%d\n"),dwReturn));
#endif
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("67")) == 0)
    {
#ifndef _CHICAGO_
        DWORD dwReturn = 0;
        dwReturn = BringALLIISClusterResourcesOnline();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOnline ret=%d\n"),dwReturn));
#endif
        iReturn = TRUE;
    }

    //    Add/remove interactive flag to/from service
    if (_tcsicmp(ParsedLine.szType, _T("68")) == 0 || _tcsicmp(ParsedLine.szType, _T("69")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("68")) == 0) {iAdd = TRUE;}

        InetConfigServiceInteractive(ParsedLine.szData1, iAdd);
        iReturn = TRUE;
    }

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

ProcessEntry_SVC_Clus_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}



int ProcessEntry_Dcom(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    DWORD dwFailed = ERROR_SUCCESS;

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("70")) != 0 && _tcsicmp(ParsedLine.szType, _T("71")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("72")) != 0 && _tcsicmp(ParsedLine.szType, _T("73")) != 0 &&
                _tcsicmp(ParsedLine.szType, _T("74")) != 0 && _tcsicmp(ParsedLine.szType, _T("75")) != 0 &&
                _tcsicmp(ParsedLine.szType, _T("76")) != 0 && _tcsicmp(ParsedLine.szType, _T("77")) != 0
        )
    {
        goto ProcessEntry_Dcom_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Dcom_Exit;
    }

    // make sure we have a szData1 entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_Dcom_Exit;
    }

    if (_tcsicmp(ParsedLine.szType, _T("74")) == 0 ||
                _tcsicmp(ParsedLine.szType, _T("75")) == 0 ||
                _tcsicmp(ParsedLine.szType, _T("76")) == 0 ||
                _tcsicmp(ParsedLine.szType, _T("77")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Dcom_Exit;
        }
        }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Dcom_Exit;
    }

    // Run The Executable...
    // iShowErrorsOnFail
    dwFailed = ERROR_SUCCESS;

    // Call the function!!!!!

        // Set dcom launch and access permissions
        if (_tcsicmp(ParsedLine.szType, _T("70")) == 0 || _tcsicmp(ParsedLine.szType, _T("71")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

                if (_tcsicmp(ParsedLine.szType, _T("70")) == 0)
                {
                        dwFailed = ChangeDCOMLaunchACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, TRUE, TRUE, bDumbCall);
                }
                else
                {
                        dwFailed = ChangeDCOMLaunchACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, FALSE, FALSE, bDumbCall);
                }
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMAccessACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }
        if (_tcsicmp(ParsedLine.szType, _T("72")) == 0 || _tcsicmp(ParsedLine.szType, _T("73")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

                if (_tcsicmp(ParsedLine.szType, _T("72")) == 0)
                {
                        dwFailed = ChangeDCOMAccessACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, TRUE, TRUE, bDumbCall);
                }
                else
                {
                        dwFailed = ChangeDCOMAccessACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, FALSE, FALSE, bDumbCall);
                }
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMAccessACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }

        // dcom launch and access permissions
    if (_tcsicmp(ParsedLine.szType, _T("74")) == 0 || _tcsicmp(ParsedLine.szType, _T("75")) == 0)
    {
        BOOL bDumbCall = FALSE;
        BOOL bAddInteractivebyDefault = TRUE;

        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("0")) == 0)
            {bAddInteractivebyDefault = FALSE;}

                if (_tcsicmp(ParsedLine.szType, _T("74")) == 0)
                {
                        dwFailed = ChangeAppIDLaunchACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, TRUE, TRUE, bDumbCall,bAddInteractivebyDefault);
                }
                else
                {
                        dwFailed = ChangeAppIDLaunchACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, FALSE, FALSE, bDumbCall,bAddInteractivebyDefault);
                }
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeAppIDLaunchACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }

        // dcom launch and access permissions
        if (_tcsicmp(ParsedLine.szType, _T("76")) == 0 || _tcsicmp(ParsedLine.szType, _T("77")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

                if (_tcsicmp(ParsedLine.szType, _T("76")) == 0)
                {
                        dwFailed = ChangeAppIDAccessACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, TRUE, TRUE, bDumbCall);
                }
                else
                {
                        dwFailed = ChangeAppIDAccessACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, FALSE, FALSE, bDumbCall);
                }
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeAppIDAccessACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }


    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Dcom_Exit:
    return iReturn;
}

// function: IsMachineInDomain
//
// Test to see if the machine is in a domain, or if it
// is in a workstation
//
// Return Values:
//   TRUE - In a domain
//   FALSE - Not in a domain
//
int IsMachineInDomain()
{
    DWORD dwRet;
    LPBYTE pDomain = NULL;

    // Retrieve the domain which this computer trusts.
    // Hence: success->in a domain; error->not in a domain
    dwRet = NetGetAnyDCName(NULL,NULL,&pDomain);

    if (pDomain)
    {
        NetApiBufferFree(pDomain);
    }

    if (dwRet == NERR_Success)
    {
        return TRUE;
    }

    // Default Return Value is FALSE
    return FALSE;
}

// function: RetrieveDomain
//
// Retrieve the domain that the current machine is in
//
// Parameters:
//   [out] csDomainName - The name of the domain
//
// Return:
//   TRUE - It worked
//   FALSE - It Failed
//
int RetrieveDomain(CString &csDomainName)
{
  PDOMAIN_CONTROLLER_INFO pDci;

  if ( NO_ERROR != DsGetDcName( NULL,   // Localhost
                                NULL,   // No specific domain
                                NULL,   // No Guid Specified
                                NULL,   // No Site
                                0,      // No Flags
                                &pDci)
                                )
  {
      return FALSE;
  }

  // Copy string into csDomainName
  csDomainName = pDci->DomainName;

  NetApiBufferFree(pDci);

  return TRUE;
}

int ProcessEntry_If(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iTempFlag2 = FALSE;

    int ifTrueStatementExists = FALSE;
    int ifFalseStatementExists = FALSE;

    // Get the type.
    if (_tcsicmp(ParsedLine.szType, _T("39")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("40")) != 0 && _tcsicmp(ParsedLine.szType, _T("41")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("42")) != 0 && _tcsicmp(ParsedLine.szType, _T("43")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("44")) != 0 && _tcsicmp(ParsedLine.szType, _T("45")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("46")) != 0 && _tcsicmp(ParsedLine.szType, _T("47")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("48")) != 0 && _tcsicmp(ParsedLine.szType, _T("49")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("100")) != 0 && _tcsicmp(ParsedLine.szType, _T("119")) != 0
        )
    {
        goto ProcessEntry_If_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_If_Exit;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("40")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        if ((HKEY) regTheKey) {iTempFlag = TRUE;}
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("41")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        CString strReturnQueryValue;
        if ((HKEY) regTheKey)
        {
            if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData2, strReturnQueryValue))
                {iTempFlag = TRUE;}

            // If we failed to read it as a string, try a dword
            if (FALSE == iTempFlag)
            {
                DWORD dwTheReturnDword = 0;
                if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData2, dwTheReturnDword))
                    {iTempFlag = TRUE;}
            }

            // If we failed to read it as dword, try a binary
            if (FALSE == iTempFlag)
            {
                CByteArray baData;
                if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData2, baData))
                    {iTempFlag = TRUE;}
            }
        }

        if (iTempFlag == TRUE)
        {
            if (ifTrueStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            if (ifFalseStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("42")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the filename or dir exists...
        iTempFlag = FALSE;
        if (IsFileExist(ParsedLine.szFileName))
            {iTempFlag = TRUE;}
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("43")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        // ParsedLine.szData1 = Software\Microsoft\etc..\TheValueToCheck
        // so take off the last one and use that as the value to look up.
        TCHAR theRegValuePart[100];
        LPTSTR pszTempPointer = NULL;
        pszTempPointer = _tcsrchr((LPTSTR) ParsedLine.szData1, _T('\\'));
        if (pszTempPointer)
        {
            *pszTempPointer = _T('\0');
            //set the "\" to a null
            // increment to after the pointer
            pszTempPointer = _tcsninc( pszTempPointer, _tcslen(pszTempPointer))+1;
            _tcscpy(theRegValuePart, pszTempPointer );
        }
        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Var:Key=%1!s!:Value=%2!s!.\n"), ParsedLine.szData1, theRegValuePart));

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        DWORD dwTheReturnDword = 0;
        if ((HKEY) regTheKey)
        {
            if (ERROR_SUCCESS == regTheKey.QueryValue(theRegValuePart, dwTheReturnDword))
                {
                    // Check against the value they want to check against.
                    DWORD dwCheckDword = atodw(ParsedLine.szData2);
                    if (dwTheReturnDword == dwCheckDword)
                        {
                        iTempFlag = TRUE;
                        }
                }
        }

        if (iTempFlag == TRUE)
        {
            if (ifTrueStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            if (ifFalseStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("44")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        // ParsedLine.szData1 = Software\Microsoft\etc..\TheValueToCheck
        // so take off the last one and use that as the value to look up.
        TCHAR theRegValuePart[100];
        LPTSTR pszTempPointer = NULL;
        pszTempPointer = _tcsrchr((LPTSTR) ParsedLine.szData1, _T('\\'));
        if (pszTempPointer)
        {
            *pszTempPointer = _T('\0');
            //set the "\" to a null
            // increment to after the pointer
            pszTempPointer = _tcsninc( pszTempPointer, _tcslen(pszTempPointer))+1;
            _tcscpy(theRegValuePart, pszTempPointer );
        }
        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Var:Key=%1!s!:Value=%2!s!.\n"), ParsedLine.szData1, theRegValuePart));

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        CString strReturnQueryValue;
        if ((HKEY) regTheKey)
        {
            if (ERROR_SUCCESS == regTheKey.QueryValue(theRegValuePart, strReturnQueryValue))
                {
                    if (_tcsicmp(strReturnQueryValue,ParsedLine.szData2) == 0)
                        {
                        iTempFlag = TRUE;
                        }
                }
        }

        if (iTempFlag == TRUE)
        {
            if (ifTrueStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            if (ifFalseStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("45")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the Service exists...
        iTempFlag = FALSE;
        if (CheckifServiceExist(ParsedLine.szFileName) == 0 )
        {
            // yes the service exists..
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("46")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the Service exists...and is running..
        iTempFlag = FALSE;

        if (InetQueryServiceStatus(ParsedLine.szFileName) == SERVICE_RUNNING)
        {
            // yes the service exists..and is running...
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("47")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4
        // Check if the values match.
        iTempFlag = FALSE;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:check if [%1!s!=%2!s!]\n"), ParsedLine.szFileName, ParsedLine.szData1));

        if ( _tcsicmp(ParsedLine.szFileName, ParsedLine.szData1) == 0)
            {
            iTempFlag = TRUE;
            }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("48")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the language specified in the .inf corresponds to
        // our systems language.
        iTempFlag = FALSE;

        // Get our language
        // set iTempFlag to true if it matches the same language they specified.
        DWORD           thid;
        LCID ThisThreadsLocale = GetThreadLocale();
        LCID SystemDefaultLocale = GetSystemDefaultLCID();
        LCID UserDefaultLocale = GetUserDefaultLCID();

        HANDLE hHackThread = CreateThread (NULL,0,GetNewlyCreatedThreadLocale,NULL,0,&thid);
        if (hHackThread)
        {
            // wait for 10 secs only
            DWORD res = WaitForSingleObject (hHackThread,10*1000);
            if (res == WAIT_TIMEOUT)
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ERROR GetNewlyCreatedThreadLocale thread never finished...\n")));
                // iTempFlag will be false.
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("ThisThreadsLocale=%0x, GetNewlyCreatedThreadLocale=%0x\n"),ThisThreadsLocale,g_MyTrueThreadLocale));
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SystemDefaultLocale=%0x, UserDefaultLocale=%0x\n"),SystemDefaultLocale,UserDefaultLocale));

                CloseHandle (hHackThread);

                // Check if g_MyTrueThreadLocale matches the one in the .inf file!
                DWORD dwTheLocaleSpecifiedinINF = 0;
                dwTheLocaleSpecifiedinINF = atodw(ParsedLine.szFileName);
                if (g_MyTrueThreadLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
                else if (ThisThreadsLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
                else if (SystemDefaultLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
                else if (UserDefaultLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Failed to start GetNewlyCreatedThreadLocale thread. error =%0x\n"),GetLastError()));
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("49")) == 0)
    {
        BOOL bOperator_EqualTo = 0;
        BOOL bOperator_GreaterThan = 0;
        BOOL bOperator_LessThan = 0;

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        // make sure there is an operator "=,>,<,>=,<="
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        iTempFlag = FALSE;
        LPTSTR pchResult;
        pchResult = _tcschr( ParsedLine.szData1, _T('=') );
        if(pchResult){bOperator_EqualTo = TRUE;iTempFlag = TRUE;}

        pchResult = NULL;
        pchResult = _tcschr( ParsedLine.szData1, _T('>') );
        if(pchResult){bOperator_GreaterThan = TRUE;iTempFlag = TRUE;}

        pchResult = NULL;
        pchResult = _tcschr( ParsedLine.szData1, _T('<') );
        if(pchResult){bOperator_LessThan = TRUE;iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        // make sure the version to compare it to is specified
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure to return true from here on!
        iReturn = TRUE;

        // check if the file exists
        // Check if the filename or dir exists...
        if (!IsFileExist(ParsedLine.szFileName))
            {goto ProcessEntry_If_Exit;}

        BOOL bThisIsABinary = FALSE;
        TCHAR szExtensionOnly[_MAX_EXT] = _T("");
        _tsplitpath(ParsedLine.szFileName, NULL, NULL, NULL, szExtensionOnly);

        // Get version info for dll,exe,ocx only
        if (_tcsicmp(szExtensionOnly, _T(".exe")) == 0){bThisIsABinary=TRUE;}
        if (_tcsicmp(szExtensionOnly, _T(".dll")) == 0){bThisIsABinary=TRUE;}
        if (_tcsicmp(szExtensionOnly, _T(".ocx")) == 0){bThisIsABinary=TRUE;}
        if (FALSE == bThisIsABinary)
        {
            // no version, bail
            goto ProcessEntry_If_Exit;
        }

        DWORD  dwMSVer, dwLSVer = 0;
        TCHAR  szLocalizedVersion[100] = _T("");

        // the file exists, lets get the file version and compare it with
        // the inputed version, if the fileversion is <= inputversion, then do TRUE section,
        // otherwise to FALSE section

        // get the fileinformation
        MyGetVersionFromFile(ParsedLine.szFileName, &dwMSVer, &dwLSVer, szLocalizedVersion);
        if (!dwMSVer)
            {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:No Version in %1!s!, or filenot found\n"), ParsedLine.szFileName));
            // no version, leave
            goto ProcessEntry_If_Exit;
            }

        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:check if [%1!s! (%2!s!  %3!s!  %4!s!)]\n"), ParsedLine.szFileName, szLocalizedVersion, ParsedLine.szData1));

        int iTempVerValue = 0;
        iTempVerValue = VerCmp(szLocalizedVersion,ParsedLine.szData1);
        if (0 == iTempVerValue)
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:VerCmp=%d\n"), iTempVerValue));
            goto ProcessEntry_If_Exit;
        }

        iTempFlag = FALSE;
        if (bOperator_EqualTo)
        {
            // check if the above operation was equal
            if (1 == iTempVerValue){iTempFlag = TRUE;}
        }

        if (bOperator_GreaterThan)
        {
            // check if the above operation was greater than
            if (2 == iTempVerValue){iTempFlag = TRUE;}
        }

        if (bOperator_LessThan)
        {
            // check if the above operation was less than
            if (3 == iTempVerValue){iTempFlag = TRUE;}
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("39")) == 0)
    {
        BOOL bOperator_EqualTo = 0;
        BOOL bOperator_GreaterThan = 0;
        BOOL bOperator_LessThan = 0;

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        // make sure the description string to comprare it to is specified
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure to return true from here on!
        iReturn = TRUE;

        // check if the file exists
        // Check if the filename or dir exists...
        if (!IsFileExist(ParsedLine.szFileName))
            {goto ProcessEntry_If_Exit;}

        TCHAR  szFileDescriptionInfo[_MAX_PATH] = _T("");

        // Get the file description info

        // get the DescriptionInfo
        if (!MyGetDescriptionFromFile(ParsedLine.szFileName, szFileDescriptionInfo))
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:No file desc in %1!s!, or filenot found\n"), ParsedLine.szFileName));
            goto ProcessEntry_If_Exit;
        }

        iTempFlag = FALSE;
        if ( _tcsicmp(szFileDescriptionInfo,ParsedLine.szData1) == 0)
        {
            // if they match the do the true!
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("100")) == 0)
    {
        TCHAR buf[_MAX_PATH];
        GetSystemDirectory(buf, _MAX_PATH);

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the Service exists...
        iTempFlag = FALSE;
        if (IsThisDriveNTFS(buf) == 0 )
        {
            // yes it is FAT
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("119")) == 0)
    {

        if ( IsMachineInDomain() )
        {
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0 )
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0 )
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }

    }


    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_If_Exit:
    return iReturn;
}





int ProcessEntry_Metabase(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iShowErrorsOnFail = TRUE;
    int iReturn = FALSE;
    int iTempFlag = FALSE;

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("82")) != 0 && _tcsicmp(ParsedLine.szType, _T("83")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("84")) != 0 && _tcsicmp(ParsedLine.szType, _T("85")) != 0
        )
    {
        goto ProcessEntry_Metabase_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Metabase_Exit;
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if ( _tcsicmp(ParsedLine.szType, _T("82")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        // Check if hte szData1 includes a "/*"
        // if it does, then that means to do it for every server instance.
        iTempFlag = FALSE;
        if (_tcsstr(ParsedLine.szFileName, _T("/*")))
            {iTempFlag = TRUE;}

        // Check if we need to do this for every server instance.
        if (iTempFlag)
        {
            CString csTempString;
            CString BeforeString;
            CString AfterString;

            csTempString = ParsedLine.szFileName;
            BeforeString = csTempString;
            AfterString = _T("");

            // Find the "/*" and get the stuff before it.
            int iWhere = 0;
            iWhere = csTempString.Find(_T("/*"));
            if (-1 != iWhere)
            {
                // there is a '/*' in the string
                BeforeString = csTempString.Left(iWhere);

                // Get the after comma vlues
                CString csVeryTemp;
                csVeryTemp = _T("/*");
                AfterString = csTempString.Right( csTempString.GetLength() - (iWhere + csVeryTemp.GetLength()));
            }

            CStringArray arrayInstance;
            int nArray = 0, i = 0;
            if (CheckifServiceExist(_T("IISADMIN")) == 0 )
            {
                CMDKey cmdKey;
                //cmdKey.OpenNode(ParsedLine.szFileName);
                cmdKey.OpenNode(BeforeString);
                if ( (METADATA_HANDLE) cmdKey )
                    {
                    // enumerate thru this key for other keys...
                    CMDKeyIter cmdKeyEnum(cmdKey);
                    CString csKeyName;
                    while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS)
                    {
                        // make sure that it's a number that we are adding.
                        if (IsValidNumber(csKeyName))
                        {
                            arrayInstance.Add(csKeyName);
                        }
                    }
                    cmdKey.Close();

                    nArray = (int)arrayInstance.GetSize();
                    for (i=0; i<nArray; i++)
                    {
                        /*
                        // Recurse Thru This nodes entries
                        // Probably look something like these...
                        [/W3SVC]
                        [/W3SVC/1/ROOT/IISSAMPLES/ExAir]
                        [/W3SVC/1/ROOT/IISADMIN]
                        [/W3SVC/1/ROOT/IISHELP]
                        [/W3SVC/1/ROOT/specs]
                        [/W3SVC/2/ROOT]
                        [/W3SVC/2/ROOT/IISADMIN]
                        [/W3SVC/2/ROOT/IISHELP]
                        etc...
                        */
                        CString csPath;
                        csPath = BeforeString;
                        csPath += _T("/");
                        csPath += arrayInstance[i];
                        csPath += AfterString;

                        // delete the metabase node.
                        cmdKey.OpenNode(csPath);
                        if ( (METADATA_HANDLE)cmdKey )
                        {
                            cmdKey.DeleteNode(ParsedLine.szData1);
                            cmdKey.Close();
                        }
                    }
                }
            }
        }
        else
        {
            // delete the metabase node.
            if (CheckifServiceExist(_T("IISADMIN")) == 0 )
            {
                CMDKey cmdKey;
                cmdKey.OpenNode(ParsedLine.szFileName);
                if ( (METADATA_HANDLE)cmdKey )
                {
                    cmdKey.DeleteNode(ParsedLine.szData1);
                    cmdKey.Close();
                }
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("83")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        // Check if hte szData1 includes a "/*"
        // if it does, then that means to do it for every server instance.
        iTempFlag = FALSE;
        if (_tcsstr(ParsedLine.szFileName, _T("/*")))
            {iTempFlag = TRUE;}

        // Check if we need to do this for every server instance.
        if (iTempFlag)
        {
            CString csTempString;
            CString BeforeString;
            CString AfterString;

            csTempString = ParsedLine.szFileName;
            BeforeString = csTempString;
            AfterString = _T("");

            // Find the "/*" and get the stuff before it.
            int iWhere = 0;
            iWhere = csTempString.Find(_T("/*"));
            if (-1 != iWhere)
            {
                // there is a '/*' in the string
                BeforeString = csTempString.Left(iWhere);

                // Get the after comma vlues
                CString csVeryTemp;
                csVeryTemp = _T("/*");
                AfterString = csTempString.Right( csTempString.GetLength() - (iWhere + csVeryTemp.GetLength()));
            }

            CStringArray arrayInstance;
            int nArray = 0, i = 0;
            if (CheckifServiceExist(_T("IISADMIN")) == 0 )
            {
                CMDKey cmdKey;
                //cmdKey.OpenNode(ParsedLine.szFileName);
                cmdKey.OpenNode(BeforeString);
                if ( (METADATA_HANDLE) cmdKey )
                    {
                    // enumerate thru this key for other keys...
                    CMDKeyIter cmdKeyEnum(cmdKey);
                    CString csKeyName;
                    while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS)
                    {
                        // make sure that it's a number that we are adding.
                        if (IsValidNumber(csKeyName))
                        {
                            arrayInstance.Add(csKeyName);
                        }
                    }
                    cmdKey.Close();

                    nArray = (int)arrayInstance.GetSize();
                    for (i=0; i<nArray; i++)
                    {
                        /*
                        // Recurse Thru This nodes entries
                        // Probably look something like these...
                        [/W3SVC]
                        [/W3SVC/1/ROOT/IISSAMPLES/ExAir]
                        [/W3SVC/1/ROOT/IISADMIN]
                        [/W3SVC/1/ROOT/IISHELP]
                        [/W3SVC/1/ROOT/specs]
                        [/W3SVC/2/ROOT]
                        [/W3SVC/2/ROOT/IISADMIN]
                        [/W3SVC/2/ROOT/IISHELP]
                        etc...
                        */
                        CString csPath;
                        csPath = BeforeString;
                        csPath += _T("/");
                        csPath += arrayInstance[i];
                        csPath += AfterString;

                        // DO WHATEVER YOU NEED TO DO.
                        int arrayInstanceNum = _ttoi(arrayInstance[i]);
                        // Add the virtual root

                        iTempFlag = FALSE;
                        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}

                        // make sure it ParsedLine.szData1 starts with a "/"
                        TCHAR szTempString[_MAX_PATH];

                        SafeCopy(szTempString, ParsedLine.szData1, sizeof(szTempString)/sizeof(TCHAR));
                        if (szTempString[0] != _T('/'))
                            {_stprintf(ParsedLine.szData1, _T("/%s"), szTempString);}

                        if (iTempFlag)
                        {
                            AddMDVRootTree(csPath, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, arrayInstanceNum);
                        }
                        else
                        {
                            AddMDVRootTree(csPath, ParsedLine.szData1, ParsedLine.szData2, NULL, arrayInstanceNum);
                        }
                    }
                }
            }
        }
        else
        {
            // Add the virtual root
            if (CheckifServiceExist(_T("IISADMIN")) == 0 )
            {
                iTempFlag = FALSE;
                if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}

                // make sure it ParsedLine.szData1 starts with a "/"
                TCHAR szTempString[_MAX_PATH];
                SafeCopy(szTempString, ParsedLine.szData1, sizeof(szTempString)/sizeof(TCHAR));
                if (szTempString[0] != _T('/'))
                    {_stprintf(ParsedLine.szData1, _T("/%s"), szTempString);}

                if (iTempFlag)
                {
                    AddMDVRootTree(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, 0);
                }
                else
                {
                    AddMDVRootTree(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, NULL, 0);
                }


            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("84")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        // call that particular migration section
        TSTR strTheSection;

        if ( strTheSection.Copy( ParsedLine.szFileName ) &&
             GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection )
           )
        {
            MigrateInfSectionToMD(g_pTheApp->m_hInfHandle, strTheSection.QueryStr() );
        }
    }

#ifndef _CHICAGO_
    if ( _tcsicmp(ParsedLine.szType, _T("85")) == 0)
    {
        int iTheReturn = TRUE;
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTheReturn = ChangeUserPassword(ParsedLine.szFileName,ParsedLine.szData1);
        if (FALSE == iTheReturn)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, _T("ChangeUserPassword failed"), ParsedLine.szFileName, MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeUserPassword(%s).  Failed..\n"), ParsedLine.szFileName));}
        }
    }
#endif

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Metabase_Exit:
    return iReturn;
}


int ProcessEntry_Misc2(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("15")) != 0 && _tcsicmp(ParsedLine.szType, _T("16")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("78")) != 0 && _tcsicmp(ParsedLine.szType, _T("79")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("80")) != 0 && _tcsicmp(ParsedLine.szType, _T("81")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("86")) != 0 && _tcsicmp(ParsedLine.szType, _T("87")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("88")) != 0 && _tcsicmp(ParsedLine.szType, _T("89")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("90")) != 0 && _tcsicmp(ParsedLine.szType, _T("91")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("92")) != 0 && _tcsicmp(ParsedLine.szType, _T("93")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("94")) != 0 && _tcsicmp(ParsedLine.szType, _T("95")) != 0 &&
                _tcsicmp(ParsedLine.szType, _T("96")) != 0 && _tcsicmp(ParsedLine.szType, _T("97")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("98")) != 0 && _tcsicmp(ParsedLine.szType, _T("99")) != 0
        )
    {
        goto ProcessEntry_Misc2_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Misc2_Exit;
    }

    // make sure we have a progresstitle
    if ( _tcsicmp(ParsedLine.szType, _T("15")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz805_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("15")) == 0)
    {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("16")) == 0)
    {
        ProgressBarTextStack_Pop();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("78")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        if (!IsFileExist(ParsedLine.szFileName))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_other():'%s' does not exist.\n"),ParsedLine.szFileName));
            goto ProcessEntry_Misc2_Exit;
        }

        MakeSureDirAclsHaveAtLeastRead((LPTSTR) ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("79")) == 0)
    {
        int ifTrueStatementExists = FALSE;
        int ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifFalseStatementExists = TRUE;}

        iTempFlag = FALSE;
        iTempFlag = IsMetabaseCorrupt();
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szFileName));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szFileName);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szFileName, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("80")) == 0)
    {
        // initialize ole
        iisDebugOut_Start((_T("ole32:OleInitialize")));
        int iBalanceOLE = iOleInitialize();
        iisDebugOut_End((_T("ole32:OleInitialize")));
        // add it to the stack of ole inits and uninits...
        GlobalOleInitList_Push(iBalanceOLE);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("81")) == 0)
    {
        // Uninitialize ole.
        // Check if there is a corresponding oleinit, if there is,
        // then uninit, else uninit anyways.
        // Grab the last thing on the stack...
        // if there is one, then do whatever it is.
        // if there is none, then OleUninitialize anyway
        if (GlobalOleInitList_Find() == TRUE)
        {
            if (TRUE == GlobalOleInitList_Pop())
            {
                iOleUnInitialize(TRUE);
            }
            else
            {
                iOleUnInitialize(FALSE);
            }
        }
        else
        {
            iOleUnInitialize(TRUE);
        }

    }

    if ( _tcsicmp(ParsedLine.szType, _T("86")) == 0)
    {
        // See if there is an extra param in the other field
        int iTicksToAdvance = 1;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0)
        {
            if (IsValidNumber((LPCTSTR)ParsedLine.szFileName))
                {iTicksToAdvance = _ttoi((LPCTSTR)ParsedLine.szFileName);}
        }
        AdvanceProgressBarTickGauge(iTicksToAdvance);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("87")) == 0)
    {
        LogFilesInThisDir(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("88")) == 0)
    {
        LogFileVersion(ParsedLine.szFileName, TRUE);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("89")) == 0)
    {
        // make sure the metabase writes all the information to disk now.
        WriteToMD_ForceMetabaseToWriteToDisk();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("90")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        DWORD dwTheID = _ttol(ParsedLine.szFileName);
        //iisDebugOut((LOG_TYPE_ERROR,  _T("Values: %s, %d"), ParsedLine.szFileName, dwTheID));

        if ( ( dwTheID == 32802 ) &&  // DomainName
             ( _tcsicmp(ParsedLine.szData1, _T("")) == 0)
           )
        {
            CString DomainName;

            if ( RetrieveDomain(DomainName) )
            {
                SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle,dwTheID,DomainName.GetBuffer(0));
            }
        }
        else
        {
            SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle,dwTheID,ParsedLine.szData1);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("91")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        DWORD dwTheID = atodw(ParsedLine.szFileName);
        SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle,dwTheID,ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("92")) == 0)
    {
        // 100=92|101=Inst mode (0,1,2,3)|102=UpgType(UT_10,etc..)|103=UpgTypeHasMetabaseFlag (0|1)|104=AllCompOffByDefaultFlag
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        //m_eInstallMode = IM_FRESH;
        //m_eUpgradeType = UT_NONE;
        //m_bUpgradeTypeHasMetabaseFlag = FALSE;
        //m_bPleaseDoNotInstallByDefault = TRUE;
        if (_tcsicmp(ParsedLine.szFileName, _T("1")) == 0)
            {g_pTheApp->m_eInstallMode = IM_FRESH;}
        if (_tcsicmp(ParsedLine.szFileName, _T("2")) == 0)
            {g_pTheApp->m_eInstallMode = IM_UPGRADE;}
        if (_tcsicmp(ParsedLine.szFileName, _T("3")) == 0)
            {g_pTheApp->m_eInstallMode = IM_MAINTENANCE;}

        if (_tcsicmp(ParsedLine.szData1, _T("UT_NONE")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_NONE;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_351")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_351;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_10")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_10;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_20")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_20;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_30")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_30;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_40")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_40;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_50")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_50;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_51")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_51;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_60")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_60;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_10_W95")) == 0)
            {g_pTheApp->m_eUpgradeType = UT_10_W95;}

        g_pTheApp->m_bUpgradeTypeHasMetabaseFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {g_pTheApp->m_bUpgradeTypeHasMetabaseFlag = TRUE;}

        g_pTheApp->m_bPleaseDoNotInstallByDefault = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("1")) == 0)
            {g_pTheApp->m_bPleaseDoNotInstallByDefault = TRUE;}
    }

    if ( _tcsicmp(ParsedLine.szType, _T("93")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("1")) == 0) {iTempFlag = TRUE;}
        StopAllServicesRegardless(iTempFlag);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("94")) == 0)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("95")) == 0)
    {
        // Check if the specified file has a version >= iis4.
        // if it does then rename the file.

        // make sure it has a 101
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        // make sure the file exists.
        if (!IsFileExist(ParsedLine.szFileName))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_other():'%s' does not exist.\n"),ParsedLine.szFileName));
            goto ProcessEntry_Misc2_Exit;
        }

        DWORD dwMajorVersion = 0x0;
        DWORD dwMinorVersion = 0x0;
        // make sure it has a 102
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        // make sure it has a 103
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        else
        {
            dwMajorVersion = atodw(ParsedLine.szData2);
        }

        // make sure it has a 104
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        else
        {
            dwMinorVersion = atodw(ParsedLine.szData3);
        }

        // Check if the file has a larger version.
        //DWORD dwNtopMSVer = 0x40002;
        //DWORD dwNtopLSVer = 0x26e0001;
        if (FALSE == IsFileLessThanThisVersion(ParsedLine.szFileName, dwMajorVersion, dwMinorVersion))
        {
            // ok, this is a 'special' built file that the user built themselves.
            // let's rename it to something else.

            // check if the "to" filename exists.
            iTempFlag = FALSE;
            int I1 = 0;
            TCHAR szTempFileName[_MAX_PATH];
            SafeCopy(szTempFileName, ParsedLine.szData1, _MAX_PATH);
            do
            {
                if (!IsFileExist(szTempFileName) || (I1 > 10))
                {
                    iTempFlag = TRUE;
                    // rename it
                    if (MoveFileEx( ParsedLine.szFileName, szTempFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
                        {iisDebugOut((LOG_TYPE_WARN, _T("%s was renamed to %s for safety because it is probably a user compiled file. WARNING."),ParsedLine.szFileName, szTempFileName));}
                    else
                        {iisDebugOut((LOG_TYPE_ERROR, _T("Rename of %s to %s for safety because it is probably a user compiled file. FAILED."),ParsedLine.szFileName, szTempFileName));}
                }
                else
                {
                    // add on some other stuff.
                    I1++;
                    _stprintf(szTempFileName, _T("%s%d"), ParsedLine.szData1, I1);
                }
            } while (iTempFlag == FALSE);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("96")) == 0)
    {
                // show messagebox
                int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
                g_pTheApp->m_bAllowMessageBoxPopups = TRUE;
                MyMessageBox(NULL, ParsedLine.szData1, ParsedLine.szFileName, MB_OK | MB_SETFOREGROUND);
                g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("97")) == 0)
    {
        // do nothing...
    }


    if ( _tcsicmp(ParsedLine.szType, _T("98")) == 0)
    {
        //Reboot
        SetRebootFlag();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("99")) == 0)
    {
        // dump internal variables
        g_pTheApp->DumpAppVars();
        int iDoExtraStuff = 0;

        if (ParsedLine.szFileName && _tcsicmp(ParsedLine.szFileName, _T("")) != 0)
        {
            if (IsValidNumber((LPCTSTR)ParsedLine.szFileName))
                {
                iDoExtraStuff = _ttoi((LPCTSTR)ParsedLine.szFileName);
                }
        }

        if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
        {
            if (iDoExtraStuff >= 2)
            {
                // display locked dlls by setup
                LogThisProcessesDLLs();
                // display running processes
                LogCurrentProcessIDs();
                // free some memory used for the task list
                FreeTaskListMem();
                UnInit_Lib_PSAPI();
            }

            // display running services
            if (iDoExtraStuff >= 1)
            {
                LogEnumServicesStatus();
            }
            // log file versions
            LogImportantFiles();
            // check if temp dir is writeable
            LogCheckIfTempDirWriteable();
        }
    }

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Misc2_Exit:
    return iReturn;
}

// function: SafeCopy
//
// - Copy a string from one to another.
// - This function takes the length of the destination to make sure we don't
//   copy too much.
// - This will always make sure that it is null terminated
//
// Return
//   A pointer to the destination string
//
LPTSTR
SafeCopy( LPTSTR szDestination, LPTSTR szSource, DWORD dwSize)
{
  LPTSTR szRet;

  // This is an assumption, so lets make sure it is true
  ASSERT( dwSize != 0 );

  szRet = _tcsncpy( szDestination, szSource, dwSize); // Copy string
  szDestination[dwSize - 1] = '\0';           // NULL Terminate

  return szRet;
}

// function: SafeCat
//
// - Concatanate one string onto another
// - This function takes the length of the destination to make sure we don't
//   copy too much.
// - This will always make sure that it is null terminated
//
// Return
//   A pointer to the destination string
//
LPTSTR
SafeCat( LPTSTR szDestination, LPTSTR szSource, DWORD dwSize)
{
  LPTSTR szRet;

  // This is an assumption, so lets make sure it is true
  ASSERT( dwSize != 0 );

  szRet = _tcsncat( szDestination, szSource, dwSize); // Copy string
  szDestination[dwSize - 1] = '\0';           // NULL Terminate

  return szRet;
}

int ProcessEntry_Misc3(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int ifTrueStatementExists = FALSE;
    int ifFalseStatementExists = FALSE;

    int iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("101")) != 0 && _tcsicmp(ParsedLine.szType, _T("102")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("103")) != 0 && _tcsicmp(ParsedLine.szType, _T("104")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("105")) != 0 && _tcsicmp(ParsedLine.szType, _T("106")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("107")) != 0 && _tcsicmp(ParsedLine.szType, _T("108")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("109")) != 0 && _tcsicmp(ParsedLine.szType, _T("110")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("111")) != 0 && _tcsicmp(ParsedLine.szType, _T("112")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("113")) != 0 && _tcsicmp(ParsedLine.szType, _T("114")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("115")) != 0 && _tcsicmp(ParsedLine.szType, _T("116")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("117")) != 0 && _tcsicmp(ParsedLine.szType, _T("118")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("119")) != 0
       )
    {
        goto ProcessEntry_Misc3_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Misc3_Exit;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("101")) == 0)
    {
        // Remove filter
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        // Check for extra flag
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iTempFlag = TRUE;}

                // Remove the filter
                RemoveMetabaseFilter(ParsedLine.szFileName, iTempFlag);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("102")) == 0)
    {
        // Remove bad filters
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Check for extra flag
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iTempFlag = TRUE;}

        // Remove the filter
        RemoveIncompatibleMetabaseFilters(ParsedLine.szFileName,iTempFlag);

    }

    if ( _tcsicmp(ParsedLine.szType, _T("103")) == 0)
    {
                // Compile mof file

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

                // Remove the filter
                HRESULT hres = MofCompile(ParsedLine.szFileName);
        if (FAILED(hres))
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, hres, MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("MofCompile(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName,hres));}
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("104")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // okay we have either szData3 or szData4
        // Check Entry point exists
        iTempFlag = FALSE;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:check for entrypoint [%1!s! (%2!s!)]\n"), ParsedLine.szFileName, ParsedLine.szData1));

                // check if entry point exists
                DWORD dwReturn = DoesEntryPointExist(ParsedLine.szFileName,ParsedLine.szData1);
        if (ERROR_SUCCESS == dwReturn)
        {
            iTempFlag = TRUE;
        }
        else
        {
            if (ERROR_FILE_NOT_FOUND == dwReturn)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("FileNot found:[%1!s!]\n"), ParsedLine.szFileName));
            }
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("105")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // see if we got the extra param
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // see if we got the extra param to say -- do this for the special group
        INT iTempFlag2 = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag2 = TRUE;}


        // call function to  CreateGroup
#ifndef _CHICAGO_
        HRESULT hr;

        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            // add group
            hr = CreateGroup(ParsedLine.szFileName,ParsedLine.szData1,TRUE, iTempFlag2);
            if (FAILED(hr))
            {
                iisDebugOut((LOG_TYPE_WARN, _T("CreateGroup:%s,%s.failed.code=0x%x\n"),ParsedLine.szFileName, ParsedLine.szData1,hr));
            }
        }
        else
        {
            // remove group
            hr = CreateGroup(ParsedLine.szFileName,ParsedLine.szData1,FALSE, iTempFlag2);
            if (FAILED(hr))
            {
                iisDebugOut((LOG_TYPE_WARN, _T("DeleteGroup:%s,%s.failed.code=0x%x\n"),ParsedLine.szFileName, ParsedLine.szData1,hr));
            }
        }
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("106")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // call function to  CreateGroup
        DWORD dwPermissions = MD_ACR_ENUM_KEYS;
        dwPermissions = atodw(ParsedLine.szData1);
#ifndef _CHICAGO_
        iTempFlag = TRUE;
        if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            if (DoesAdminACLExist(ParsedLine.szFileName) == TRUE)
                {iTempFlag = FALSE;}
        }
        // if this is upgrading from win95, then make sure to write the acl...
        if (g_pTheApp->m_bWin95Migration){iTempFlag = TRUE;}
        if (iTempFlag)
        {
            SetAdminACL_wrap(ParsedLine.szFileName,dwPermissions,TRUE);
        }
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("107")) == 0)
    {
        // Run the ftp, upgrade code to move registry stuff to the metabase
        FTP_Upgrade_RegToMetabase(g_pTheApp->m_hInfHandle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("108")) == 0)
    {
        // Run the w3svc, upgrade code to move registry stuff to the metabase
        WWW_Upgrade_RegToMetabase(g_pTheApp->m_hInfHandle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("109")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        UpgradeFilters(ParsedLine.szFileName);
    }


    if ( _tcsicmp(ParsedLine.szType, _T("110")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
#ifndef _CHICAGO_
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0)
        {
            // add
            RegisterAccountToLocalGroup(_T("system"),ParsedLine.szFileName,TRUE);
            RegisterAccountToLocalGroup(_T("service"),ParsedLine.szFileName,TRUE);
            RegisterAccountToLocalGroup(_T("networkservice"),ParsedLine.szFileName,TRUE);
        }
        else
        {
            // remove
            RegisterAccountToLocalGroup(_T("system"),ParsedLine.szFileName,FALSE);
            RegisterAccountToLocalGroup(_T("service"),ParsedLine.szFileName,FALSE);
            RegisterAccountToLocalGroup(_T("networkservice"),ParsedLine.szFileName,FALSE);
        }
#endif
    }


    if ( _tcsicmp(ParsedLine.szType, _T("111")) == 0)
    {
        iTempFlag = FALSE;
        DWORD dwAccessMask = 0x0;

        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        if ( _tcsicmp(ParsedLine.szData2, _T("")) != 0 )
        {
          // Get access mask if it is available
          dwAccessMask = atodw(ParsedLine.szData2);
        }

#ifndef _CHICAGO_
        AddUserToMetabaseACL_Rec(ParsedLine.szFileName,ParsedLine.szData1, dwAccessMask);
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("112")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

#ifndef _CHICAGO_
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            // add
            RegisterAccountToLocalGroup(ParsedLine.szData1,ParsedLine.szFileName,TRUE);
        }
        else
        {
            // remove
            RegisterAccountToLocalGroup(ParsedLine.szData1,ParsedLine.szFileName,FALSE);
        }
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("113")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}
#ifndef _CHICAGO_
        DWORD dwAccessMask = atodw(ParsedLine.szData3);
        DWORD dwInheritMask = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
        SetRegistryKeySecurity(hRootKeyType,ParsedLine.szData1,ParsedLine.szData2,dwAccessMask,dwInheritMask,TRUE,ParsedLine.szData4);
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("114")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        // rename the metabase node.
        if (CheckifServiceExist(_T("IISADMIN")) == 0 )
        {
            CMDKey cmdKey;
            cmdKey.OpenNode(ParsedLine.szFileName);
            if ( (METADATA_HANDLE)cmdKey )
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("RenameNode:%s=%s\n"),ParsedLine.szData1,ParsedLine.szData2));
                cmdKey.RenameNode(ParsedLine.szData1, ParsedLine.szData2);
                cmdKey.Close();
            }
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("115")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the language specified in the .inf corresponds to
        // our systems language.
        iTempFlag = FALSE;

        // Get our language
        // set iTempFlag to true if it matches the same language they specified.

        DWORD dwCodePage = GetACP();
        DWORD dwTheCodePageSpecifiedinINF = 0;
        dwTheCodePageSpecifiedinINF = atodw(ParsedLine.szFileName);

        iisDebugOut((LOG_TYPE_TRACE, _T("CodePage=0x%x,%d\n"),dwCodePage,dwCodePage));

        if (dwTheCodePageSpecifiedinINF == dwCodePage)
        {
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("116")) == 0)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateDummyMetabaseBin\n")));
        CreateDummyMetabaseBin();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("117")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // okay we have either szData1 or szData2
        iTempFlag = CheckForWriteAccess(ParsedLine.szFileName);

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("118")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
#ifndef _CHICAGO_

        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        if ( _ttoi(ParsedLine.szData4) == 1 )
        {
            RemovePrincipalFromFileAcl(ParsedLine.szFileName,ParsedLine.szData1);
        }
        else
        {
            // don't remove any iheritance, keep all inheritance
            BOOL DontInheritFromParentAndOverWriteAccess = FALSE;
            DWORD dwInheritMask = 0;
            INT iAceType = ACCESS_ALLOWED_ACE_TYPE;
            DWORD dwAccessMask = atodw(ParsedLine.szData2);

            // see if the "special" parameter was passed in...
            // we had to use szData4 since we don't have a szData5 :-(
            if ( _ttoi(ParsedLine.szData4) == 2 )
            {
                DontInheritFromParentAndOverWriteAccess = TRUE;
                dwInheritMask = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
            }
            else
            {
                DontInheritFromParentAndOverWriteAccess = FALSE;
                //dwInheritMask = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERITED_ACE;
                dwInheritMask = 0;
            }

            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0)
            {
                iAceType = _ttoi(ParsedLine.szData3);
            }

            SetDirectorySecurity(ParsedLine.szFileName,ParsedLine.szData1,iAceType,dwAccessMask,dwInheritMask,DontInheritFromParentAndOverWriteAccess);
        }

#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("119")) == 0)
    {
      SetDIRIDforThisInf(g_pTheApp->m_hInfHandle,FALSE);
    }

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Misc3_Exit:
    return iReturn;
}


int ProcessEntry_other(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("19")) != 0 && _tcsicmp(ParsedLine.szType, _T("20")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("21")) != 0 && _tcsicmp(ParsedLine.szType, _T("22")) != 0 &&
                 _tcsicmp(ParsedLine.szType, _T("23")) != 0 && _tcsicmp(ParsedLine.szType, _T("24")) != 0 &&
                 _tcsicmp(ParsedLine.szType, _T("25")) != 0 && _tcsicmp(ParsedLine.szType, _T("26")) != 0 &&
                 _tcsicmp(ParsedLine.szType, _T("27")) != 0 && _tcsicmp(ParsedLine.szType, _T("28")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("29")) != 0 && _tcsicmp(ParsedLine.szType, _T("30")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("31")) != 0 && _tcsicmp(ParsedLine.szType, _T("32")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("33")) != 0 && _tcsicmp(ParsedLine.szType, _T("34")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("35")) != 0 && _tcsicmp(ParsedLine.szType, _T("36")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("37")) != 0 && _tcsicmp(ParsedLine.szType, _T("38")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("120"))
         )
    {
        goto ProcessEntry_other_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_other_Exit;
    }

    if (_tcsicmp(ParsedLine.szType, _T("28")) != 0)
    {
        if (_tcsicmp(ParsedLine.szType, _T("37")) != 0)
        {
            // make sure we have a filename entry
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_other_Exit;
            }
        }
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0)
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_other_Exit;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("19")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddGroup:%1!s!\n"),ParsedLine.szFileName));
        MyAddGroup(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("20")) == 0)
    {
                if ( _tcsicmp(ParsedLine.szData1, _T("1")) == 0)
                {
                        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteGroup:%1!s!. even if not empty.\n"),ParsedLine.szFileName));
                        MyDeleteGroup(ParsedLine.szFileName);
                }
                else
                {
                        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteGroup:%1!s!. only if empty.\n"),ParsedLine.szFileName));
                        if (MyIsGroupEmpty(ParsedLine.szFileName)) {MyDeleteGroup(ParsedLine.szFileName);}
                }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("21")) == 0)
    {

        //MyAddItem(csGroupName, csAppName, csProgram, NULL, NULL);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddItem:Type=%1!s!,%2!s!,%3!s!,%4!s!,%5!s!\n"),ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, ParsedLine.szData4));
        if ( _tcsicmp(ParsedLine.szData3, _T("")) == 0 && _tcsicmp(ParsedLine.szData4, _T("")) == 0)
        {
            MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, NULL, NULL, NULL);
        }
        else
        {
            // if ParsedLine.szData4 is a directory, then
            // the start in dir should be used there.

            // if ParsedLine.szData4 is a filename, then
            // the start in dir should be used there.
            // and you ought to use the filename specified for the icon
            if (IsFileExist(ParsedLine.szData4))
            {
                DWORD retCode = GetFileAttributes(ParsedLine.szData4);

                if (retCode & FILE_ATTRIBUTE_DIRECTORY)
                {
                    // It is a directory, so pass in only the directory information
                    MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, ParsedLine.szData4, NULL);
                }
                else
                {
                    // it is a file so get the directory and pass in the filename as well.
                    TCHAR szDirOnly[_MAX_PATH];
                    TCHAR szDirOnly2[_MAX_PATH];
                    _tcscpy(szDirOnly, _T(""));
                    _tcscpy(szDirOnly2, _T(""));
                    InetGetFilePath(ParsedLine.szData4, szDirOnly);

                    // change e:\winnt\system32 to %systemroot%\system32 if we need to.
                    ReverseExpandEnvironmentStrings(szDirOnly, szDirOnly2);

                    MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, szDirOnly2, ParsedLine.szData4);
                }

            }
            else
            {
                MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, NULL, NULL, NULL);
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("22")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteItem:%1!s!,%2!s!\n"),ParsedLine.szFileName, ParsedLine.szData1));
        MyDeleteItem(ParsedLine.szFileName, ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("23")) == 0)
    {
                //MyAddDeskTopItem(csAppName, csProgram, NULL, NULL, csProgram, 7);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddDeskTopItem:Type=%1!s!,%2!s!,%3!s!\n"),ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2));
        if ( _tcsicmp(ParsedLine.szData2, _T("")) == 0)
        {
                        // icon number not specified
                        MyAddDeskTopItem(ParsedLine.szFileName, ParsedLine.szData1, NULL, NULL, ParsedLine.szData1, 7);
        }
        else
        {
                        // icon specified use what they said to use
                        int iIconIndex = 7 ;
            if (IsValidNumber((LPCTSTR)ParsedLine.szData2))
                {iIconIndex = _ttoi((LPCTSTR)ParsedLine.szData2);}
                        MyAddDeskTopItem(ParsedLine.szFileName, ParsedLine.szData1, NULL, NULL, ParsedLine.szData1, iIconIndex);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("24")) == 0)
    {
        // Check which version they want....
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0)
        {
            BOOL bDeleteItsDirToo = _ttoi(ParsedLine.szData1);
            iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteDeskTopItem2:%1!s!,%2!d!\n"),ParsedLine.szFileName,bDeleteItsDirToo));
            MyDeleteDeskTopItem2(ParsedLine.szFileName, bDeleteItsDirToo);
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteDeskTopItem:%1!s!\n"),ParsedLine.szFileName));
            MyDeleteDeskTopItem(ParsedLine.szFileName);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("120")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("DeleteFromGroup:%1!s!\n"),ParsedLine.szFileName));
        DeleteFromGroup(ParsedLine.szFileName, ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("25")) == 0)
    {
                //MyAddSendToItem(csAppName, csProgram, NULL, NULL);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddSendToItem:Type=%1!s!,%2!s!\n"),ParsedLine.szFileName, ParsedLine.szData1));
                MyAddSendToItem(ParsedLine.szFileName, ParsedLine.szData1, NULL, NULL);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("26")) == 0)
    {
                //MyDeleteSendToItem(csAppName);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteSendToItem:%1!s!\n"),ParsedLine.szFileName));
        MyDeleteSendToItem(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("27")) == 0)
    {
                if (ParsedLine.szFileName)
                {
                        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0)
                        {
                INT iUserWasNewlyCreated = 0;
                //CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword);
#ifndef _CHICAGO_
                                CreateIUSRAccount( (LPTSTR)(LPCTSTR) ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1,&iUserWasNewlyCreated);
#endif //_CHICAGO_
                        }
                }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("28")) == 0)
    {
                if (ParsedLine.szFileName)
                {
                        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0)
                        {
#ifndef _CHICAGO_
                int iUserWasDeleted = 0;
                                DeleteGuestUser( (LPTSTR)(LPCTSTR) ParsedLine.szFileName,&iUserWasDeleted);
                // if the user was deleted, then remove it
                // from the uninstall list!
                if (1 == iUserWasDeleted)
                {
                    g_pTheApp->UnInstallList_DelData(ParsedLine.szFileName);
                }
#endif
                        }
                }
    }

    // move location of directory recursive
    if ( _tcsicmp(ParsedLine.szType, _T("29")) == 0)
    {
                if (ParsedLine.szFileName && _tcsicmp(ParsedLine.szFileName, _T("")) != 0)
                {
            // Check if the from directory even exist...
            // see if the file exists
            if (IsFileExist(ParsedLine.szFileName))
            {
                if (ParsedLine.szData1 && _tcsicmp(ParsedLine.szData1, _T("")) != 0)
                {
                    if (TRUE == MoveFileEx( ParsedLine.szFileName, ParsedLine.szData1, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("MoveFileEx:%1!s! to %2!s!.  success.\n"),ParsedLine.szFileName, ParsedLine.szData1));
                    }
                    else
                    {
                        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("MoveFileEx:%1!s! to %2!s!.  failed.\n"),ParsedLine.szFileName, ParsedLine.szData1));
                    }
                }
            }
                }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("30")) == 0)
    {
                if (ParsedLine.szFileName && _tcsicmp(ParsedLine.szFileName, _T("")) != 0)
                {
                        BOOL b;
                        BOOL bInstalled = FALSE;
                        CString csFile;

                        b = AddFontResource(ParsedLine.szFileName);
                        if (!b)
                        {
                                csFile = g_pTheApp->m_csWinDir + _T("\\Fonts\\");
                                csFile += ParsedLine.szFileName;
                                b = AddFontResource((LPCTSTR)csFile);
                                if (!b)
                                {
                                        iisDebugOut((LOG_TYPE_ERROR, _T("AddFontResource:FAILED:, csFile=%s, err=0x%x,\n"), csFile, GetLastError()));
                                }
                        }

                        if (b)
                        {
                        SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
                        }

                }
        }

    if ( _tcsicmp(ParsedLine.szType, _T("31")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        AddURLShortcutItem( ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("32")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddItem:Type=%1!s!,%2!s!,%3!s!\n"),ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2));
        MyAddItemInfoTip(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("33")) == 0)
    {
        CString strUseThisFileName;
        int iShowErrorsOnFail = TRUE;
        if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
            {iShowErrorsOnFail = FALSE;}

        // the user can specify a filename or
        // they can specify a registry location to get the filename from
        // if the registry location is not there then use the filename.

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        strUseThisFileName = ParsedLine.szFileName;

        // if we have a valid registry entry then use that.
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0)
        {
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0)
            {
                if (_tcsicmp(ParsedLine.szData3, _T("")) != 0)
                {
                    // try to get the filename stored there.
                    HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
                    // check if the registry key exists...
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

                    iTempFlag = FALSE;
                    CRegKey regTheKey(hRootKeyType, ParsedLine.szData2,KEY_READ);
                    CString strReturnQueryValue;
                    if ((HKEY) regTheKey)
                    {
                        if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData3, strReturnQueryValue))
                            {
                            strUseThisFileName = strReturnQueryValue;
                            iTempFlag = TRUE;
                            }
                    }
                }
            }
        }

        // check if the the filename we want to use
        // needs to get expanded "%windir%\myfile" or something.
        if (-1 != strUseThisFileName.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, strUseThisFileName);
            if (ExpandEnvironmentStrings( (LPCTSTR)strUseThisFileName, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {
                strUseThisFileName = szTempDir;
                }
        }

        if (TRUE == iTempFlag)
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateAnEmptyFile:%1!s!. From Registry location.\n"),strUseThisFileName));
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateAnEmptyFile:%1!s!\n"),strUseThisFileName));
        }

        if (TRUE != CreateAnEmptyFile(strUseThisFileName))
            {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, strUseThisFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_TRACE, _T("CreateAnEmptyFile(%s).  Failed.  Err=0x%x.\n"), strUseThisFileName, GetLastError() ));}
            }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("34")) == 0)
    {
        CString strUseThisFileName;
        TCHAR szUseThisFileName[_MAX_PATH];

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        strUseThisFileName = ParsedLine.szFileName;

        // if we have a valid registry entry then use that.
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0)
        {
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0)
            {
                if (_tcsicmp(ParsedLine.szData4, _T("")) != 0)
                {
                    // try to get the filename stored there.
                    HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
                    // check if the registry key exists...
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

                    iTempFlag = FALSE;
                    CRegKey regTheKey(hRootKeyType, ParsedLine.szData3, KEY_READ);
                    CString strReturnQueryValue;
                    if ((HKEY) regTheKey)
                    {
                        if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData4, strReturnQueryValue))
                            {
                            strUseThisFileName = strReturnQueryValue;
                            iTempFlag = TRUE;
                            }
                    }
                }
            }
        }

        // check if the the filename we want to use
        // needs to get expanded "%windir%\myfile" or something.
        if (-1 != strUseThisFileName.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, strUseThisFileName);
            if (ExpandEnvironmentStrings( (LPCTSTR)strUseThisFileName, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {
                strUseThisFileName = szTempDir;
                }
        }

        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile:%1!s!,%2!s!\n"),strUseThisFileName, ParsedLine.szData1));
        _tcscpy(szUseThisFileName, strUseThisFileName);
        GrantUserAccessToFile(szUseThisFileName, ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("35")) == 0)
    {
        DWORD dwID = 0;
        DWORD dwAttrib = 0;
        DWORD dwUserType = 0;
        DWORD dwTheData = 0;
        INT iOverwriteFlag = FALSE;

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        // make sure we have a szData3 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        dwID = atodw(ParsedLine.szData1);
        dwAttrib = METADATA_INHERIT;
        dwUserType = atodw(ParsedLine.szData2);
        dwTheData = atodw(ParsedLine.szData3);

        iOverwriteFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData4, _T("1")) == 0)
            {iOverwriteFlag = TRUE;}

        if (CheckifServiceExist(_T("IISADMIN")) == 0 )
        {
            WriteToMD_DwordEntry(ParsedLine.szFileName, dwID, dwAttrib, dwUserType, dwTheData, iOverwriteFlag);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("36")) == 0)
    {
        // Functionality removed because no longer used
        iisDebugOut((LOG_TYPE_ERROR,  _T("1==36 is no longer supported") ));
    }

    if ( _tcsicmp(ParsedLine.szType, _T("37")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == TRUE)
        {
            int MyLogErrorType = LOG_TYPE_TRACE;
            if (_tcsicmp(ParsedLine.szData1, _T("0")) == 0)
                {MyLogErrorType = LOG_TYPE_ERROR;}
            if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0)
                {MyLogErrorType = LOG_TYPE_WARN;}
            if (_tcsicmp(ParsedLine.szData1, _T("2")) == 0)
                {MyLogErrorType = LOG_TYPE_PROGRAM_FLOW;}
            if (_tcsicmp(ParsedLine.szData1, _T("3")) == 0)
                {MyLogErrorType = LOG_TYPE_TRACE;}
            if (_tcsicmp(ParsedLine.szData1, _T("4")) == 0)
                {MyLogErrorType = LOG_TYPE_TRACE_WIN32_API;}
            iisDebugOut((MyLogErrorType, _T("%s"), ParsedLine.szFileName));
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("38")) == 0)
    {
        BOOL bOK = FALSE;
        BOOL bDeleteOld = FALSE;
        BOOL bOverWriteToFile = FALSE;

        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        bDeleteOld = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) {bDeleteOld = TRUE;}
        bOverWriteToFile = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("1")) == 0) {bOverWriteToFile = TRUE;}

        if (IsFileExist(ParsedLine.szFileName))
        {
            //Save file attributes so they can be restored after we are done.
            DWORD dwSourceAttrib = GetFileAttributes(ParsedLine.szFileName);

            //Now set the file attributes to normal to ensure file ops succeed.
            SetFileAttributes(ParsedLine.szFileName, FILE_ATTRIBUTE_NORMAL);

            //from=ParsedLine.szFileName
            //to=ParsedLine.szData1
            // check if the 'to' filename exists.
            if (!IsFileExist(ParsedLine.szData1))
            {
                    // go ahead and try to copy it over
                    bOK = CopyFile(ParsedLine.szFileName, ParsedLine.szData1, FALSE);
                    if (bOK)
                    {
                        SetFileAttributes(ParsedLine.szData1, dwSourceAttrib);
                        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s! copied to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                        // the file was copied. let's delete it now.
                        if (bDeleteOld)
                        {
                            if(!DeleteFile(ParsedLine.szFileName))
                            {
                                MoveFileEx(ParsedLine.szFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                            }
                        }
                        else
                        {
                            // set this files attribs back to what it was
                            SetFileAttributes(ParsedLine.szFileName, dwSourceAttrib);
                        }
                    }
                    else
                    {
                        // we were unable to copy the file over!
                        // don't delete the old one.
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                    }
            }
            else
            {
                // the 'to' file exists, shall we overwrite it?
                if (bOverWriteToFile)
                {
                    if(DeleteFile(ParsedLine.szData1))
                    {
                        bOK = FALSE;
                        bOK = CopyFile(ParsedLine.szFileName, ParsedLine.szData1, FALSE);
                        if (bOK)
                        {
                            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s! copied to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                            // the file was copied. let's delete it now.
                            if (bDeleteOld)
                            {
                                if(!DeleteFile(ParsedLine.szFileName))
                                {
                                    MoveFileEx(ParsedLine.szFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                                }
                            }
                            else
                            {
                                // set this files attribs back to what it was
                                SetFileAttributes(ParsedLine.szFileName, dwSourceAttrib);
                            }
                        }
                        else
                        {
                            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                        }
                    }
                    else
                    {
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.  file#2 cannot be deleted.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                    }
                }
                else
                {
                    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.  file#2 already exists.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                }
            }
        }
    }

    // We called the function, so return true.
    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir){if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    ProcessEntry_AskLast(ParsedLine, 1);

ProcessEntry_other_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_Entry(IN HINF hFile, IN LPCTSTR szTheSection, IN CString csOneParseableLine)
{
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("ProcessEntry_Entry:%1!s!, %2!s!\n"),szTheSection, csOneParseableLine));
    int iReturn = FALSE;
    int iReturnTemp = FALSE;
    int iTempFlag = FALSE;

    ThingToDo ParsedLine;

    _tcscpy(ParsedLine.szType, _T(""));
    _tcscpy(ParsedLine.szFileName, _T(""));
    _tcscpy(ParsedLine.szData1, _T(""));
    _tcscpy(ParsedLine.szData2, _T(""));
    _tcscpy(ParsedLine.szData3, _T(""));
    _tcscpy(ParsedLine.szData4, _T(""));
    _tcscpy(ParsedLine.szChangeDir, _T(""));

    _tcscpy(ParsedLine.szOS, _T(""));
    _tcscpy(ParsedLine.szPlatformArchitecture, _T(""));
    _tcscpy(ParsedLine.szEnterprise, _T(""));
    _tcscpy(ParsedLine.szErrIfFileNotFound, _T(""));
    _tcscpy(ParsedLine.szMsgBoxBefore, _T(""));
    _tcscpy(ParsedLine.szMsgBoxAfter, _T(""));
    _tcscpy(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T(""));
    _tcscpy(ParsedLine.szProgressTitle, _T(""));

    // parse the line and put into another big cstring list
    CStringList strListOrderImportant;
    //
    // Parse the long string and put into another list
    //
    LPTSTR      lpBuffer = NULL;
    lpBuffer = (LPTSTR) LocalAlloc(LPTR, (csOneParseableLine.GetLength() + 1) * sizeof(TCHAR) );
    if ( !lpBuffer )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:Failed to allocate memory.")));
        return iReturn;
    }

    _tcscpy(lpBuffer, csOneParseableLine);
    TCHAR *token = NULL;
    token = _tcstok(lpBuffer, _T("|"));
    while (token != NULL)
    {
        strListOrderImportant.AddTail(token);
        token = _tcstok(NULL, _T("|"));
    }

    // Loop thru the new list and set variables
    int i = 0;
    int iFoundMatch = FALSE;
    POSITION pos = NULL;
    CString csEntry;
    int iEntryLen = 0;

    pos = strListOrderImportant.GetHeadPosition();
    while (pos)
    {
        iFoundMatch = FALSE;
        csEntry = strListOrderImportant.GetAt(pos);
        iEntryLen=(csEntry.GetLength() + 1) * sizeof(TCHAR);

        // Look for "100:"
        // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
        if (csEntry.Left(4) == ThingToDoNumType_100 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szType)) {_tcscpy(ParsedLine.szType, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR,  (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_100,csEntry));}

            iFoundMatch = TRUE;
        }

        // 101=File
        if (csEntry.Left(4) == ThingToDoNumType_101 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szFileName)) {_tcscpy(ParsedLine.szFileName, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_101, csEntry));}
            if (-1 != csEntry.Find(_T('<')) )
            {
                // there is a < in the string
                int iWhere = 0;
                CString csValue2;
                csEntry.MakeUpper();
                if (csEntry.Find(_T("<SYSTEMROOT>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMROOT> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMROOT>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMROOT>"));
                    csValue2 = g_pTheApp->m_csWinDir + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szFileName)) {_tcscpy(ParsedLine.szFileName, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ParseError:%s.1:%1!s! -- entry to big\n"),ThingToDoNumType_101,csEntry));}
                }

                if (csEntry.Find(_T("<SYSTEMDRIVE>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMDRIVE> deal.  Now replace it with the real systemdrive
                    iWhere = csEntry.Find(_T("<SYSTEMDRIVE>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMDRIVE>"));
                    csValue2 = g_pTheApp->m_csSysDrive + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szFileName)) {_tcscpy(ParsedLine.szFileName, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_101,csEntry));}
                }
            }

            iFoundMatch = TRUE;
        }

        // ThingToDoNumType_102=szData1
        if (csEntry.Left(4) == ThingToDoNumType_102 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData1)) {_tcscpy(ParsedLine.szData1, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_102,csEntry));}
            iFoundMatch = TRUE;
            if (-1 != csEntry.Find(_T('<')) )
            {
                // there is a < in the string
                int iWhere = 0;
                CString csValue2;
                csEntry.MakeUpper();
                if (csEntry.Find(_T("<SYSTEMROOT>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMROOT> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMROOT>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMROOT>"));
                    csValue2 = g_pTheApp->m_csWinDir + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szData1)) {_tcscpy(ParsedLine.szData1, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ParseError:%s.1:%1!s! -- entry to big\n"),ThingToDoNumType_102, csEntry));}
                }

                if (csEntry.Find(_T("<SYSTEMDRIVE>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMDRIVE> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMDRIVE>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMDRIVE>"));
                    csValue2 = g_pTheApp->m_csSysDrive + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szData1)) {_tcscpy(ParsedLine.szData1, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_102,csEntry));}
                }
            }
        }


        // ThingToDoNumType_103=szData2
        if (csEntry.Left(4) == ThingToDoNumType_103 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData2)) {_tcscpy(ParsedLine.szData2, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_103,csEntry));}
            iFoundMatch = TRUE;
        }
        // ThingToDoNumType_104=szData3
        if (csEntry.Left(4) == ThingToDoNumType_104 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData3)) {_tcscpy(ParsedLine.szData3, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_104,csEntry));}
            iFoundMatch = TRUE;
        }

        // ThingToDoNumType_105=szData4
        if (csEntry.Left(4) == ThingToDoNumType_105 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData4)) {_tcscpy(ParsedLine.szData4, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_105,csEntry));}
            iFoundMatch = TRUE;
        }



        // 200=ChangeToThisDirFirst
        if (csEntry.Left(4) == ThingToDoNumType_200 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szChangeDir)) {_tcscpy(ParsedLine.szChangeDir, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_200,csEntry));}
            iFoundMatch = TRUE;

            if (-1 != csEntry.Find(_T('<')) )
            {
                // there is a < in the string
                int iWhere = 0;
                CString csValue2;
                csEntry.MakeUpper();
                if (csEntry.Find(_T("<SYSTEMROOT>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMROOT> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMROOT>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMROOT>"));
                    csValue2 = g_pTheApp->m_csWinDir + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szChangeDir)) {_tcscpy(ParsedLine.szChangeDir, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ParseError:%s.1:%1!s! -- entry to big\n"),ThingToDoNumType_200,csEntry));}
                }

                if (csEntry.Find(_T("<SYSTEMDRIVE>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMDRIVE> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMDRIVE>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMDRIVE>"));
                    csValue2 = g_pTheApp->m_csSysDrive + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szChangeDir)) {_tcscpy(ParsedLine.szChangeDir, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_200,csEntry));}
                }
            }

        }

        // 701=OS (0=ALL,1=NTS,2=NTW,4=NTDC)
        if (csEntry.Left(4) == ThingToDoNumType_701 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szOS)) {_tcscpy(ParsedLine.szOS, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_701,csEntry));}
            iFoundMatch = TRUE;
        }

        // 702=PlatformArchitecture (0=ALL,1=x86,2=alpha)
        if (csEntry.Left(4) == ThingToDoNumType_702 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szPlatformArchitecture)) {_tcscpy(ParsedLine.szPlatformArchitecture, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_702,csEntry));}
            iFoundMatch = TRUE;
        }

        // 703=Enterprise (1=yes,0=no)
        if (csEntry.Left(4) == ThingToDoNumType_703 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szEnterprise)) {_tcscpy(ParsedLine.szEnterprise, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_703,csEntry));}
            iFoundMatch = TRUE;
        }

        // 801=ErrIfFileNotFound (1=Show error if filenot found, 0=don't show error)
        if (csEntry.Left(4) == ThingToDoNumType_801 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szErrIfFileNotFound)) {_tcscpy(ParsedLine.szErrIfFileNotFound, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_801,csEntry));}
            iFoundMatch = TRUE;
        }

        // 802=Ask User if they want to call this function with msgbox (1=yes,0=no)
        if (csEntry.Left(4) == ThingToDoNumType_802 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szMsgBoxBefore)) {_tcscpy(ParsedLine.szMsgBoxBefore, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_802,csEntry));}
            iFoundMatch = TRUE;
        }

        // 803=notify use after calling the function (1=yes,0=no)
        if (csEntry.Left(4) == ThingToDoNumType_803 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szMsgBoxAfter)) {_tcscpy(ParsedLine.szMsgBoxAfter, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_803,csEntry));}
            iFoundMatch = TRUE;
        }

        // 804=szDoNotDisplayErrIfFunctionFailed (1= dont Show error , 0=show error)
        if (csEntry.Left(4) == ThingToDoNumType_804 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szDoNotDisplayErrIfFunctionFailed)) {_tcscpy(ParsedLine.szDoNotDisplayErrIfFunctionFailed, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_804,csEntry));}
            iFoundMatch = TRUE;
        }

        // 805=szProgressTitle
        if (csEntry.Left(4) == ThingToDoNumType_805 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szProgressTitle)) {_tcscpy(ParsedLine.szProgressTitle, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_805,csEntry));}
            iFoundMatch = TRUE;
        }

        if (iFoundMatch != TRUE)
        {
            // We didn't find a match, so output the problem to the logs..
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_Entry():UnknownOption '%1!s!'.  Section=%2!s!..\n"),csEntry, szTheSection));
        }

        // Get next value
        strListOrderImportant.GetNext(pos);
        i++;
    }

    iFoundMatch = FALSE;
    /*
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_Entry:PleaseProcess:type=%1!s!,filename=%2!s!,data=%3!s!,os=%4!s!,plat=%5!s!,errnofile=%6!s!,msgb=%7!s!,msga=%8!s!,noerr=%9!s!\n"),
        ParsedLine.szType,
        ParsedLine.szFileName,
        ParsedLine.szData1,
        ParsedLine.szOS,
        ParsedLine.szPlatformArchitecture,
        ParsedLine.szEnterprise
        ParsedLine.szErrIfFileNotFound,
        ParsedLine.szMsgBoxBefore,
        ParsedLine.szMsgBoxAfter,
        ParsedLine.szDoNotDisplayErrIfFunctionFailed
        ));
    */
    if (i >= 1)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("...ProcessEntry:100=%1!s!...\n"),ParsedLine.szType));

        // Get the type.
        //
        // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
        //
        if ( _tcsicmp(ParsedLine.szType, _T("1")) == 0 || _tcsicmp(ParsedLine.szType, _T("2")) == 0 )
        {
            // 100=1=DllFunction,2=DllFunctionInitOle
            // We are doing a call to a function in a DLL.
            iReturnTemp = ProcessEntry_CallDll(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        // 100=7,8,9,10,11,12,13,14
        if ( _tcsicmp(ParsedLine.szType, _T("7")) == 0 || _tcsicmp(ParsedLine.szType, _T("8")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("9")) == 0 || _tcsicmp(ParsedLine.szType, _T("10")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("11")) == 0 || _tcsicmp(ParsedLine.szType, _T("12")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("13")) == 0 || _tcsicmp(ParsedLine.szType, _T("14")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("17")) == 0 || _tcsicmp(ParsedLine.szType, _T("18")) == 0
            )
        {
            iReturnTemp = ProcessEntry_Misc1(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("19")) == 0 || _tcsicmp(ParsedLine.szType, _T("20")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("21")) == 0 || _tcsicmp(ParsedLine.szType, _T("22")) == 0 ||
                        _tcsicmp(ParsedLine.szType, _T("23")) == 0 || _tcsicmp(ParsedLine.szType, _T("24")) == 0 ||
                        _tcsicmp(ParsedLine.szType, _T("25")) == 0 || _tcsicmp(ParsedLine.szType, _T("26")) == 0 ||
                        _tcsicmp(ParsedLine.szType, _T("27")) == 0 || _tcsicmp(ParsedLine.szType, _T("28")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("29")) == 0 || _tcsicmp(ParsedLine.szType, _T("30")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("31")) == 0 || _tcsicmp(ParsedLine.szType, _T("32")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("33")) == 0 || _tcsicmp(ParsedLine.szType, _T("34")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("35")) == 0 || _tcsicmp(ParsedLine.szType, _T("36")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("37")) == 0 || _tcsicmp(ParsedLine.szType, _T("38")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("120")) == 0
            )
        {
            iReturnTemp = ProcessEntry_other(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("39")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("40")) == 0 || _tcsicmp(ParsedLine.szType, _T("41")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("42")) == 0 || _tcsicmp(ParsedLine.szType, _T("43")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("44")) == 0 || _tcsicmp(ParsedLine.szType, _T("45")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("46")) == 0 || _tcsicmp(ParsedLine.szType, _T("47")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("48")) == 0 || _tcsicmp(ParsedLine.szType, _T("49")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("100")) == 0 || _tcsicmp(ParsedLine.szType, _T("119")) == 0
                         )
        {
            iReturnTemp = ProcessEntry_If(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("50")) == 0 || _tcsicmp(ParsedLine.szType, _T("51")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("52")) == 0 || _tcsicmp(ParsedLine.szType, _T("53")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("54")) == 0 || _tcsicmp(ParsedLine.szType, _T("55")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("56")) == 0 || _tcsicmp(ParsedLine.szType, _T("57")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("58")) == 0 || _tcsicmp(ParsedLine.szType, _T("59")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("60")) == 0 || _tcsicmp(ParsedLine.szType, _T("61")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("62")) == 0 || _tcsicmp(ParsedLine.szType, _T("63")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("64")) == 0 || _tcsicmp(ParsedLine.szType, _T("65")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("66")) == 0 || _tcsicmp(ParsedLine.szType, _T("67")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("68")) == 0 || _tcsicmp(ParsedLine.szType, _T("69")) == 0
            )
        {
            iReturnTemp = ProcessEntry_SVC_Clus(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("70")) == 0 || _tcsicmp(ParsedLine.szType, _T("71")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("72")) == 0 || _tcsicmp(ParsedLine.szType, _T("73")) == 0 ||
                         _tcsicmp(ParsedLine.szType, _T("74")) == 0 || _tcsicmp(ParsedLine.szType, _T("75")) == 0 ||
                         _tcsicmp(ParsedLine.szType, _T("76")) == 0 || _tcsicmp(ParsedLine.szType, _T("77")) == 0
                         )
        {
            iReturnTemp = ProcessEntry_Dcom(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("82")) == 0 || _tcsicmp(ParsedLine.szType, _T("83")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("84")) == 0 || _tcsicmp(ParsedLine.szType, _T("85")) == 0
             )
        {
            iReturnTemp = ProcessEntry_Metabase(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("15")) == 0 || _tcsicmp(ParsedLine.szType, _T("16")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("78")) == 0 || _tcsicmp(ParsedLine.szType, _T("79")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("80")) == 0 || _tcsicmp(ParsedLine.szType, _T("81")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("86")) == 0 || _tcsicmp(ParsedLine.szType, _T("87")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("88")) == 0 || _tcsicmp(ParsedLine.szType, _T("89")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("90")) == 0 || _tcsicmp(ParsedLine.szType, _T("91")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("92")) == 0 || _tcsicmp(ParsedLine.szType, _T("93")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("94")) == 0 || _tcsicmp(ParsedLine.szType, _T("95")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("96")) == 0 || _tcsicmp(ParsedLine.szType, _T("97")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("98")) == 0 || _tcsicmp(ParsedLine.szType, _T("99")) == 0
             )
        {
            iReturnTemp = ProcessEntry_Misc2(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("101")) == 0 || _tcsicmp(ParsedLine.szType, _T("102")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("103")) == 0 || _tcsicmp(ParsedLine.szType, _T("104")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("105")) == 0 || _tcsicmp(ParsedLine.szType, _T("106")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("107")) == 0 || _tcsicmp(ParsedLine.szType, _T("108")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("109")) == 0 || _tcsicmp(ParsedLine.szType, _T("110")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("111")) == 0 || _tcsicmp(ParsedLine.szType, _T("112")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("113")) == 0 || _tcsicmp(ParsedLine.szType, _T("114")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("115")) == 0 || _tcsicmp(ParsedLine.szType, _T("116")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("117")) == 0 || _tcsicmp(ParsedLine.szType, _T("118")) == 0
             )
        {
            iReturnTemp = ProcessEntry_Misc3(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        //
        // 100= 3=Executable
        //
        if ( _tcsicmp(ParsedLine.szType, _T("3")) == 0)
        {
            iReturnTemp = ProcessEntry_Call_Exe(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        //
        // 100= 4=Call InternalSectionInIISDll
        //
        if ( _tcsicmp(ParsedLine.szType, _T("4")) == 0)
        {

            iReturnTemp = ProcessEntry_Internal_iisdll(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        //
        // 100= 0=DoINFSection queue file ops special
        // 100= 5=DoSection
        // 100= 6=DoINFSection
        //
        if ( _tcsicmp(ParsedLine.szType, _T("0")) == 0 || _tcsicmp(ParsedLine.szType, _T("5")) == 0 || _tcsicmp(ParsedLine.szType, _T("6")) == 0 )
        {
            iReturnTemp = ProcessEntry_Call_Section(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if (TRUE != iFoundMatch)
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ExecuteThing:Unknown Type:%1!s! FAILURE.\n"),ParsedLine.szType));
        }
    }

    if (lpBuffer) {LocalFree(lpBuffer);lpBuffer=NULL;}
    return iReturn;
}


int DoesThisSectionExist(IN HINF hFile, IN LPCTSTR szTheSection)
{
    int iReturn = FALSE;

    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    if (SetupFindFirstLine_Wrapped(hFile, szTheSection, NULL, &Context))
        {iReturn = TRUE;}

    return iReturn;
}

// DoesTheInstallDrivePreserveAcls
//
// Does the drive that we are installing to preserve the ACL's
// that we set on stuff (ie. Is it NTFS)
//
// Parameters:
//   pbPreservesAcls [out] - Are ACL's preserved or not
//
// Return Values
//  TRUE - Successfully did query
//  FALSE - Failed to do query
BOOL
DoesTheInstallDrivePreserveAcls( LPBOOL pbPreservesAcls )
{
  DWORD         dwSystemFlags;
  TSTR_PATH     strDrivePath;
  static  BOOL  bAlreadyDidCheck = FALSE;
  static  BOOL  bPreservesAcls = FALSE;

  if ( !bAlreadyDidCheck )
  {
    // Create Drive path with trailing '\'
    if ( !strDrivePath.Copy( g_pTheApp->m_csSysDrive ) ||
         !strDrivePath.PathAppend( _T("") ) )
    {
      // Failed to create drive path
      return FALSE;
    }

    if ( !GetVolumeInformation( strDrivePath.QueryStr(),
                                NULL,         // Volume Name Buffer
                                0,            // Size of Buffer
                                NULL,         // Serial Number Buffer
                                NULL,         // Max Component Lenght
                                &dwSystemFlags,  // System Flags
                                NULL,         // FS Type
                                0 ) )
    {
      // Failed to do query
      return FALSE;
    }

    bPreservesAcls = ( dwSystemFlags & FS_PERSISTENT_ACLS ) != 0;
    bAlreadyDidCheck = TRUE;
  }

  // Do not do query more than one, so remember that we did it
  *pbPreservesAcls = bPreservesAcls;

  return TRUE;
}

int GetSectionNameToDo(IN HINF hFile, TSTR *pstrSectionName )
{
    iisDebugOut_Start1(_T("GetSectionNameToDo"), pstrSectionName->QueryStr() );
    int iReturn = FALSE;

    // Check if this section has other sections which have something else appended to it.
    //
    // for example:
    // csTheSection = iis_www_reg_CreateIISPackage
    //
    // could have:
    // iis_www_reg_CreateIISPackage.UT_NONE
    // iis_www_reg_CreateIISPackage.UT_351
    // iis_www_reg_CreateIISPackage.UT_10
    // iis_www_reg_CreateIISPackage.UT_20
    // iis_www_reg_CreateIISPackage.UT_30
    // iis_www_reg_CreateIISPackage.UT_40
    // iis_www_reg_CreateIISPackage.UT_50
    // iis_www_reg_CreateIISPackage.UT_51
    // iis_www_reg_CreateIISPackage.UT_60
    // iis_www_reg_CreateIISPackage.UT_10_W95.GUIMODE
    //
    // In That case, we only want to do the iis_www_reg_CreateIISPackage.UT_40
    // and not do the iis_www_reg_CreateIISPackage one!
    //
    // Check for other upgrade specific sections...
    // if we find one then do that, otherwise, just do the regular section...
    TCHAR szTheSectionToDo[100];
    TCHAR szTheUT[30];
    _tcscpy(szTheUT,_T("UT_NONE"));
    if (g_pTheApp->m_eUpgradeType == UT_351){_tcscpy(szTheUT,_T("UT_351"));}
    if (g_pTheApp->m_eUpgradeType == UT_10){_tcscpy(szTheUT,_T("UT_10"));}
    if (g_pTheApp->m_eUpgradeType == UT_20){_tcscpy(szTheUT,_T("UT_20"));}
    if (g_pTheApp->m_eUpgradeType == UT_30){_tcscpy(szTheUT,_T("UT_30"));}
    if (g_pTheApp->m_eUpgradeType == UT_40){_tcscpy(szTheUT,_T("UT_40"));}
    if (g_pTheApp->m_eUpgradeType == UT_50){_tcscpy(szTheUT,_T("UT_50"));}
    if (g_pTheApp->m_eUpgradeType == UT_51){_tcscpy(szTheUT,_T("UT_51"));}
    if (g_pTheApp->m_eUpgradeType == UT_60){_tcscpy(szTheUT,_T("UT_60"));}
    if (g_pTheApp->m_eUpgradeType == UT_10_W95){_tcscpy(szTheUT,_T("UT_10_W95"));}

    BOOL bSectionFound = FALSE;
    // If this is an upgrade from win95 then tack that one on...
    if (g_pTheApp->m_bWin95Migration)
    {
        // Check for guimode of this...
        if (g_pTheApp->m_fNTGuiMode)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s.MIG95.GUIMODE"), pstrSectionName->QueryStr(),szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }

        if (bSectionFound == FALSE)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s.MIG95"), pstrSectionName->QueryStr(),szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }
    }

    // check with out the extract mig95 thingy
    if (bSectionFound == FALSE)
    {
        if (g_pTheApp->m_fNTGuiMode)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s.GUIMODE"), pstrSectionName->QueryStr(),szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }

        if (bSectionFound == FALSE)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s"), pstrSectionName->QueryStr(),szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }
    }

    // if we didn't find a specific section, then see if this is an upgrade
    // and if there is upgrade type box.
    if (bSectionFound == FALSE)
    {
        if (_tcsicmp(szTheUT, _T("UT_NONE")) != 0)
        {
            if (TRUE == g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
            if (g_pTheApp->m_fNTGuiMode)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYMETABASEUPGRADE.GUIMODE"), pstrSectionName->QueryStr());
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            if (bSectionFound == FALSE)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYMETABASEUPGRADE"), pstrSectionName->QueryStr());
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            }

            if (bSectionFound == FALSE)
            {
            if (g_pTheApp->m_fNTGuiMode)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYUPGRADE.GUIMODE"), pstrSectionName->QueryStr());
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            if (bSectionFound == FALSE)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYUPGRADE"), pstrSectionName->QueryStr());
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            }
        }
    }
    // if we didn't find a specific section, then turn the regular one.
    if (bSectionFound == FALSE)
    {
            if (g_pTheApp->m_fNTGuiMode)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.GUIMODE"), pstrSectionName->QueryStr());
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }

            if (bSectionFound == FALSE)
            {
                _tcscpy(szTheSectionToDo, pstrSectionName->QueryStr());
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
    }

    if (bSectionFound == FALSE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetSectionNameToDo.[%s].Section not found.\n"), pstrSectionName->QueryStr()));
        iReturn = FALSE;
    }
    else
    {
        iReturn = pstrSectionName->Copy( szTheSectionToDo );
    }

    iisDebugOut_End1(_T("GetSectionNameToDo"), pstrSectionName->QueryStr());
    return iReturn;
}




int ProcessSection(IN HINF hFile, IN LPCTSTR szTheSection)
{
    int iReturn = FALSE;
    CStringList strList;
    CParse ParseLine;
    TSTR strTheSection;

    if ( !strTheSection.Copy( szTheSection ) )
    {
      return FALSE;
    }

    if (GetSectionNameToDo(hFile, &strTheSection ))
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("ProcessSection.[%s].Start.\n"), strTheSection.QueryStr() ));
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, strTheSection.QueryStr() ))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos = NULL;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos)
                {
                    csEntry = strList.GetAt(pos);

                    if ( ( csEntry.Get