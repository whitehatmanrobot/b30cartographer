    *pmask &= (pMap->GenericAll | ACCESS_SYSTEM_SECURITY);

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CPrintSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes)
{
    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::GetInheritTypes");
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    *ppInheritTypes = siPrintInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siPrintInheritTypes);

    TraceLeaveResult(S_OK);
}

//
// The base class versions of ReadObjectSecurity and WriteObjectSecurity
// use Get/SetNamedSecurityInfo, et al.  These API's are generic,
// involve lots of conversions, and are problematic.  Since there is no
// inheritance propagation required for printers, override them here
// and use GetPrinter/SetPrinter.
//
STDMETHODIMP
CPrintSecurity::ReadObjectSecurity(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr;
    DWORD dwErr = NOERROR;
    HANDLE hPrinter;
    PRINTER_DEFAULTS pd = {0};
    DWORD dwLength = 0;

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::ReadObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    if (si & (DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        pd.DesiredAccess |= READ_CONTROL;

    if (si & SACL_SECURITY_INFORMATION)
        pd.DesiredAccess |= ACCESS_SYSTEM_SECURITY;

    __try
    {
        *ppSD = NULL;

        if (OpenPrinter((LPTSTR)pszObject, &hPrinter, &pd))
        {
            PPRINTER_INFO_3 ppi = NULL;

            if (GetPrinterAlloc(hPrinter, 3, (LPBYTE*)&ppi))
            {
                //
                // Rather than allocating a new buffer and copying the
                // security descriptor, we can re-use the existing buffer
                // by simply moving the security descriptor to the top.
                //
                dwLength = GetSecurityDescriptorLength(ppi->pSecurityDescriptor);
                *ppSD = ppi;
                // This is an overlapped copy, so use MoveMemory.
                MoveMemory(*ppSD,
                           ppi->pSecurityDescriptor,
                           dwLength);
            }
            else
                dwErr = GetLastError();

            ClosePrinter(hPrinter);
        }
        else
            dwErr = GetLastError();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_PROC_NOT_FOUND;
    }

    hr = HRESULT_FROM_WIN32(dwErr);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CPrintSecurity::WriteObjectSecurity(LPCTSTR pszObject,
                                    SECURITY_INFORMATION si,
                                    PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr;
    DWORD dwErr = NOERROR;
    HANDLE hPrinter;
    PRINTER_DEFAULTS pd = {0};

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::WriteObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    if (si & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        pd.DesiredAccess |= WRITE_OWNER;

    if (si & SACL_SECURITY_INFORMATION)
        pd.DesiredAccess |= ACCESS_SYSTEM_SECURITY;

    if (si & DACL_SECURITY_INFORMATION)
        pd.DesiredAccess |= WRITE_DAC;

    __try
    {
        if (OpenPrinter((LPTSTR)pszObject, &hPrinter, &pd))
        {
            PRINTER_INFO_3 pi = { pSD };

            if (!SetPrinter(hPrinter, 3, (LPBYTE)&pi, 0))
                dwErr = GetLastError();

            ClosePrinter(hPrinter);
        }
        else
            dwErr = GetLastError();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = ERROR_PROC_NOT_FOUND;
    }

    hr = HRESULT_FROM_WIN32(dwErr);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CPrintSecurity::GetInheritSource(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\printsi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       printsi.h
//
//  This file contains the definition of the CPrintSecurity object.
//
//--------------------------------------------------------------------------

#ifndef _PRINTSI_H_
#define _PRINTSI_H_

#include "si.h"

STDMETHODIMP
CheckPrinterAccess(LPCTSTR pszObjectName,
                   LPDWORD pdwAccessGranted,
                   LPTSTR  pszServer,
                   ULONG   cchServer);

DWORD LoadWinSpool();

class CPrintSecurity : public CSecurityInformation
{
public:
    CPrintSecurity(SE_OBJECT_TYPE seType) : CSecurityInformation(seType) {}

    STDMETHOD(Initialize)(HDPA   hItemList,
                          DWORD  dwFlags,
                          LPTSTR pszServer,
                          LPTSTR pszObject);

    // ISecurityInformation methods
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,     // override
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);


protected:
    // Override these
    STDMETHOD(ReadObjectSecurity)(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD);
    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);
};

#endif  /* _PRINTSI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//  This file contains the resource IDs for all resources required by
//  this module.
//
//--------------------------------------------------------------------------

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//
// Dialogs
//

#define IDD_SET_SECURITY_ERROR              1

//
// Dialog control IDs
//

#define IDC_STATIC                          -1
#define IDC_FILENAME                        100
#define IDC_ERROR_TXT                       101
#define IDC_MSG1                            102
#define IDC_MSG2                            103

//
// General String IDs
//
#define IDS_RSHX_BASE                       0

#define IDS_SECURITY_MENU                   (IDS_RSHX_BASE+0)
#define IDS_SECURITY_HELPSTRING             (IDS_RSHX_BASE+1)
#define IDS_PROPPAGE_TITLE                  (IDS_RSHX_BASE+2)
#define IDS_NONE                            (IDS_RSHX_BASE+3)
#define IDS_MULTISEL_ELLIPSIS               (IDS_RSHX_BASE+4)
#define IDS_BAD_DACL_INTERSECTION           (IDS_RSHX_BASE+5)
#define IDS_BAD_SACL_INTERSECTION           (IDS_RSHX_BASE+6)
#define IDS_READ_DIR_ERR                    (IDS_RSHX_BASE+7)
#define IDS_FMT_VOLUME_DISPLAY              (IDS_RSHX_BASE+9)
#define IDS_FMT_UNKNOWN_ERROR               (IDS_RSHX_BASE+10)
#define IDS_FMT_WRITE_OWNER_ERR             (IDS_RSHX_BASE+11)
#define IDS_RESET_OWNER_TREE                (IDS_RSHX_BASE+12)
#define IDS_RESET_DACL_TREE                 (IDS_RSHX_BASE+13)
#define IDS_RESET_SACL_TREE                 (IDS_RSHX_BASE+14)
#define IDS_RESET_SEC_TREE                  (IDS_RSHX_BASE+15)
#define IDS_RSHX_LAST                       (IDS_RSHX_BASE+15)


//
// String IDs for NTFS permission names
//
#define IDS_NTFS_BASE                       (IDS_RSHX_LAST+1)

#define IDS_NTFS_GENERIC_ALL                (IDS_NTFS_BASE+0)
#define IDS_NTFS_GENERIC_READ               (IDS_NTFS_BASE+1)
#define IDS_NTFS_GENERIC_WRITE              (IDS_NTFS_BASE+2)
#define IDS_NTFS_GENERIC_EXECUTE            (IDS_NTFS_BASE+3)

#define IDS_NTFS_GENERAL_MODIFY             (IDS_NTFS_BASE+4)
#define IDS_NTFS_GENERAL_PUBLISH            (IDS_NTFS_BASE+5)
#define IDS_NTFS_GENERAL_DEPOSIT            (IDS_NTFS_BASE+6)
#define IDS_NTFS_GENERAL_READ               (IDS_NTFS_BASE+7)
#define IDS_NTFS_GENERAL_LIST               (IDS_NTFS_BASE+8)

#define IDS_NTFS_STD_DELETE                 (IDS_NTFS_BASE+16)
#define IDS_NTFS_STD_READ_CONTROL           (IDS_NTFS_BASE+17)
#define IDS_NTFS_STD_WRITE_DAC              (IDS_NTFS_BASE+18)
#define IDS_NTFS_STD_WRITE_OWNER            (IDS_NTFS_BASE+19)
#define IDS_NTFS_STD_SYNCHRONIZE            (IDS_NTFS_BASE+20)
#define IDS_NTFS_ACCESS_SYSTEM_SECURITY     (IDS_NTFS_BASE+21)

#define IDS_NTFS_FILE_READ_DATA             (IDS_NTFS_BASE+22)
#define IDS_NTFS_FILE_WRITE_DATA            (IDS_NTFS_BASE+23)
#define IDS_NTFS_FILE_APPEND_DATA           (IDS_NTFS_BASE+24)
#define IDS_NTFS_FILE_READ_EA               (IDS_NTFS_BASE+25)
#define IDS_NTFS_FILE_WRITE_EA              (IDS_NTFS_BASE+26)
#define IDS_NTFS_FILE_EXECUTE               (IDS_NTFS_BASE+27)
#define IDS_NTFS_FILE_DELETE_CHILD          (IDS_NTFS_BASE+28)
#define IDS_NTFS_FILE_READ_ATTR             (IDS_NTFS_BASE+29)
#define IDS_NTFS_FILE_WRITE_ATTR            (IDS_NTFS_BASE+30)
#define IDS_NTFS_FILE_CREATE_PIPE           (IDS_NTFS_BASE+31)

#define IDS_NTFS_FOLDER                     (IDS_NTFS_BASE+32)
#define IDS_NTFS_FOLDER_SUBITEMS            (IDS_NTFS_BASE+33)
#define IDS_NTFS_FOLDER_SUBFOLDER           (IDS_NTFS_BASE+34)
#define IDS_NTFS_FOLDER_FILE                (IDS_NTFS_BASE+35)
#define IDS_NTFS_SUBITEMS_ONLY              (IDS_NTFS_BASE+36)
#define IDS_NTFS_SUBFOLDER_ONLY             (IDS_NTFS_BASE+37)
#define IDS_NTFS_FILE_ONLY                  (IDS_NTFS_BASE+38)
#define IDS_SET_PERM_ON_NETWORK_DRIVE       (IDS_NTFS_BASE+39)
#define IDS_SET_SACL_ON_NETWORK_DRIVE       (IDS_NTFS_BASE+40)
#define IDS_RESET_PERM_FAILED		    (IDS_NTFS_BASE+41)
#define IDS_RESET_AUDITING_FAILED	    (IDS_NTFS_BASE+42)	

#define IDS_NTFS_LAST                       (IDS_NTFS_BASE+47)

//
// String IDs for Printer permission names
//
#define IDS_PRINT_BASE                      (IDS_NTFS_LAST+1)

#define IDS_PRINT_PRINT                     (IDS_PRINT_BASE+0)
#define IDS_PRINT_ADMINISTER                (IDS_PRINT_BASE+1)
#define IDS_PRINT_ADMINISTER_JOBS           (IDS_PRINT_BASE+2)
#define IDS_PRINT_DELETE                    (IDS_PRINT_BASE+3)
#define IDS_PRINT_READ                      (IDS_PRINT_BASE+4)
#define IDS_PRINT_CHANGE_PERM               (IDS_PRINT_BASE+5)
#define IDS_PRINT_CHANGE_OWNER              (IDS_PRINT_BASE+6)
#define IDS_PRINT_JOB_ALL                   (IDS_PRINT_BASE+7)

#define IDS_PRINT_PRINTER                   (IDS_PRINT_BASE+8)
#define IDS_PRINT_DOCUMENT_ONLY             (IDS_PRINT_BASE+9)
#define IDS_PRINT_PRINTER_DOCUMENT          (IDS_PRINT_BASE+10)

#define IDS_PRINT_LAST                      (IDS_PRINT_BASE+15)

#define IDS_MULTIPLE_SELECTION_READ_ERROR   (IDS_PRINT_LAST+1)
#define IDS_MULTIPLE_SELECTION_READ_ERROR_1 (IDS_PRINT_LAST+2)
#define IDS_PERMISSION_PROPOGATION_CANCEL   (IDS_PRINT_LAST+3)	
#define IDS_AUDITING_PROPOGATION_CANCEL	    (IDS_PRINT_LAST+4)
#define IDS_OWNER_PROPOGATION_CANCEL        (IDS_PRINT_LAST+5)
#define IDS_ACL_ON_SYSTEMROOT		    (IDS_PRINT_LAST+6)
#define IDS_ACL_ON_UNDER_SYSTEM_DRIVE	    (IDS_PRINT_LAST+7)
#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\sources.inc ===
TARGETNAME=rshx32
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=DllMain
DLLDEF=$(O)\$(TARGETNAME).def

INCLUDES=..;..\..\inc;$(BASE_INC_PATH)

DELAYLOAD=ole32.dll;netapi32.dll;mpr.dll;winspool.drv
DLOAD_ERROR_HANDLER = kernel32

LINKLIBS=\
    ..\..\common\winnt\$(O)\common.lib     \

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SHELL_LIB_PATH)\comctlp.lib   \
    $(SDK_LIB_PATH)\shell32.lib     \
    $(SHELL_LIB_PATH)\shell32p.lib  \
    $(SHELL_LIB_PATH)\shlwapip.lib  \
    $(SDK_LIB_PATH)\shlwapi.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\winspool.lib    \
    $(SDK_LIB_PATH)\netapi32.lib    \
    $(SDK_LIB_PATH)\mpr.lib         \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\authz.lib        \

SOURCES=\
     ..\rshx32.rc       \
     ..\rshx32.cpp      \
     ..\cstrings.cpp    \
     ..\si.cpp          \
     ..\ntfssi.cpp      \
     ..\printsi.cpp     \
     ..\util.cpp        \

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\rshx32.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\rshx32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rshx32.h
//
//  Remote administration shell extension.
//
//--------------------------------------------------------------------------

#ifndef _RSHX32_H_
#define _RSHX32_H_

#ifndef UNICODE
#error "No ANSI support yet"
#endif

extern "C"
{
    #include <nt.h>         // for SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <seopaque.h>   // RtlObjectAceSid, etc.
    #include <sertlp.h>     // RtlpOwnerAddrSecurityDescriptor, etc.
}

#define INC_OLE2
#include <windows.h>
#include "resource.h"   // resource IDs

#ifndef RC_INVOKED

#include <winspool.h>
#include <shellapi.h>   // HDROP, ShellExecuteEx
#include <shlobj.h>     // CF_IDLIST
#include <shlwapi.h>    // StrChr
#include <commctrl.h>   // property page stuff
#include <comctrlp.h>   // DPA
#include <aclapi.h>
#include <aclui.h>
#include <common.h>
#include "cstrings.h"
#include "util.h"
extern "C"
{
#include "authz.h"
}
#include "ntfssi.h"
#include "printsi.h"


#include <shlobjp.h>    // ILCombine


#define ALL_SECURITY_ACCESS     (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY)

// Magic debug flags
#define TRACE_RSHX32        0x00000001
#define TRACE_SI            0x00000002
#define TRACE_NTFSSI        0x00000004
#define TRACE_PRINTSI       0x00000008
#define TRACE_UTIL          0x00000010
#define TRACE_NTFSCOMPARE   0x00000020
#define TRACE_ALWAYS        0xffffffff          // use with caution

//
// Global variables
//
extern HINSTANCE        g_hInstance;
extern LONG             g_cRefThisDll;
extern CLIPFORMAT       g_cfShellIDList;
extern CLIPFORMAT       g_cfPrinterGroup;
extern CLIPFORMAT       g_cfMountedVolume;

#endif // RC_INVOKED
#endif // _RSHX32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\rshx32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rshx32.cpp
//
//  Remote administration shell extension.
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "rshx32.h"
#include <winnetwk.h>   // WNetGetConnection
#include <lm.h>
#include <lmdfs.h>      // NetDfsGetClientInfo
#include <atlconv.h>

#include <initguid.h>
DEFINE_GUID(CLSID_NTFSSecurityExt, 0x1f2e5c40, 0x9550, 0x11ce, 0x99, 0xd2, 0x00, 0xaa, 0x00, 0x6e, 0x08, 0x6c);
DEFINE_GUID(CLSID_PrintSecurityExt, 0xf37c5810, 0x4d3f, 0x11d0, 0xb4, 0xbf, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x23);

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

#define RSX_SECURITY_CHECKED    0x00000001L
#define RSX_HAVE_SECURITY       0x00000002L

#define DOBJ_RES_CONT           0x00000001L
#define DOBJ_RES_ROOT           0x00000002L
#define DOBJ_VOL_NTACLS         0x00000004L     // NTFS or OFS


class CRShellExtCF : public IClassFactory
{
protected:
    ULONG m_cRef;
    SE_OBJECT_TYPE m_seType;

public:
    CRShellExtCF(SE_OBJECT_TYPE seType);
    ~CRShellExtCF();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, void **);
    STDMETHODIMP LockServer(BOOL);
};

class CRShellExt : public IShellExtInit, IShellPropSheetExt, IContextMenu
{
protected:
    ULONG           m_cRef;
    SE_OBJECT_TYPE  m_seType;
    IDataObject    *m_lpdobj; // interface passed in by shell
    HRESULT         m_hrSecurityCheck;
    DWORD           m_dwSIFlags;
    LPTSTR          m_pszServer;
    LPTSTR          m_pszObject;
    HDPA            m_hItemList;
    BOOL            m_bShowLossInheritedAclWarning;

public:
    CRShellExt(SE_OBJECT_TYPE seType);
    ~CRShellExt();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellExtInit method
    STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);

    // IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    //IContextMenu methods
    STDMETHODIMP QueryContextMenu(HMENU hMenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd,
                                  UINT uFlags,
                                  UINT *reserved,
                                  LPSTR pszName,
                                  UINT cchMax);
private:
    STDMETHODIMP DoSecurityCheck(LPIDA pIDA);
    STDMETHODIMP CheckForSecurity(LPIDA pIDA);
    STDMETHODIMP CreateSI(LPSECURITYINFO *ppsi);
    STDMETHODIMP AddSecurityPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    BOOL IsAddPrinterWizard() const;

    STDMETHODIMP AddMountedVolumePage(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                      LPARAM               lParam);

};
typedef CRShellExt* PRSHELLEXT;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HINSTANCE        g_hInstance = NULL;
LONG             g_cRefThisDll = 0;
CLIPFORMAT       g_cfShellIDList = 0;
CLIPFORMAT       g_cfPrinterGroup = 0;
CLIPFORMAT       g_cfMountedVolume = 0;
HMODULE          g_hAclui = NULL;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

void GetFileInfo(LPCTSTR pszPath,
                 LPDWORD pdwFileType,
                 LPTSTR  pszServer,
                 ULONG   cchServer,
                 BOOL *pbShowLossInheritedAclWarning = NULL);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// General routines                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

/*++

Routine Description:

    Dll's entry point.

    In order to service requests for file selection information from
    any of the file manager extensions to be included in this library,
    we must first register a window class to accept these requests.

    The Microsoft_Network provider transfers information via a private
    clipboard format called "Net Resource" which we must register.

Arguments:

    Same as DllEntryPoint.

Return Values:

    Same as DllEntryPoint.

--*/

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, void * /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        g_cfShellIDList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_cfPrinterGroup = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PRINTERGROUP);
        g_cfMountedVolume = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
        DebugProcessAttach();
        TraceSetMaskFromCLSID(CLSID_NTFSSecurityExt);
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        break;

    case DLL_PROCESS_DETACH:
        if (g_hAclui)
            FreeLibrary(g_hAclui);
        DebugProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}


/*++

Routine Description:

    Called by shell to create a class factory object.

Arguments:

    rclsid - reference to class id specifier.
    riid   - reference to interface id specifier.
    ppv    - pointer to location to receive interface pointer.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr;
    SE_OBJECT_TYPE seType;

    *ppv = NULL;

    if (IsEqualCLSID(rclsid, CLSID_NTFSSecurityExt))
        seType = SE_FILE_OBJECT;
    else if (IsEqualCLSID(rclsid, CLSID_PrintSecurityExt))
        seType = SE_PRINTER;
    else
        return CLASS_E_CLASSNOTAVAILABLE;

    CRShellExtCF *pShellExtCF = new CRShellExtCF(seType);   // ref == 1

    if (!pShellExtCF)
        return E_OUTOFMEMORY;

    hr = pShellExtCF->QueryInterface(riid, ppv);

    pShellExtCF->Release();     // release initial ref

    return hr;
}


/*++

Routine Description:

    Called by shell to find out if dll can be unloaded.

Arguments:

    None.

Return Values:

    Returns S_OK if dll can be unloaded, S_FALSE if not.

--*/

STDAPI DllCanUnloadNow()
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}


STDAPI DllRegisterServer(void)
{
    return CallRegInstall(g_hInstance, "DefaultInstall");
}


STDAPI DllUnregisterServer(void)
{
    return CallRegInstall(g_hInstance, "DefaultUninstall");
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRShellExtCF::CRShellExtCF(SE_OBJECT_TYPE seType) : m_cRef(1), m_seType(seType)
{
    InterlockedIncrement(&g_cRefThisDll);
}

CRShellExtCF::~CRShellExtCF()
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG) CRShellExtCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRShellExtCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRShellExtCF::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Support for IClassFactory::CreateInstance.

Arguments:

    pUnkOuter - pointer to controlling unknown.
    riid      - reference to interface id specifier.
    ppvObj    - pointer to location to receive interface pointer.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDMETHODIMP CRShellExtCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CRShellExt *pShellExt = new CRShellExt(m_seType);// ref count == 1

    if (!pShellExt)
        return E_OUTOFMEMORY;

    HRESULT hr = pShellExt->QueryInterface(riid, ppvObj);
    pShellExt->Release();                       // release initial ref

    return hr;
}



/*++

Routine Description:

    Support for IClassFactory::LockServer (not implemented).

Arguments:

    fLock - true if lock count to be incremented.

Return Values:

    Returns E_NOTIMPL.

--*/

STDMETHODIMP CRShellExtCF::LockServer(BOOL /*fLock*/)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRShellExt::CRShellExt(SE_OBJECT_TYPE seType) : m_cRef(1), m_seType(seType),
    m_dwSIFlags(SI_EDIT_ALL | SI_ADVANCED | SI_EDIT_EFFECTIVE), m_hrSecurityCheck((HRESULT)-1),
    m_hItemList(NULL),
    m_bShowLossInheritedAclWarning(FALSE)
{
    InterlockedIncrement(&g_cRefThisDll);
}

CRShellExt::~CRShellExt()
{
    DoRelease(m_lpdobj);

    LocalFreeString(&m_pszServer);
    LocalFreeString(&m_pszObject);

    LocalFreeDPA(m_hItemList);

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRShellExt::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CRShellExt::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CRShellExt::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPSHELLEXTINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppv = (LPCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppv = (LPSHELLPROPSHEETEXT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IShellExtInit)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Support for IShellExtInit::Initialize.

Arguments:

    pidlFolder - pointer to id list identifying parent folder.
    lpdobj     - pointer to IDataObject interface for selected object(s).
    hKeyProgId - registry key handle.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDMETHODIMP CRShellExt::Initialize(LPCITEMIDLIST /*pidlFolder*/, IDataObject *lpdobj, HKEY /*hKeyProgID*/)
{
    DoRelease(m_lpdobj);

    m_lpdobj = lpdobj; // processed in AddPages

    if (m_lpdobj)
        m_lpdobj->AddRef();

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IShellPropSheetExt)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    Support for IShellPropSheetExt::AddPages.

Arguments:

    lpfnAddPage - pointer to function called to add a page.
    lParam      - lParam parameter to be passed to lpfnAddPage.

Return Values:

    Returns HRESULT signifying success or failure.

--*/

STDMETHODIMP
CRShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                     LPARAM               lParam)
{
    HRESULT hr;
    STGMEDIUM medium = {0};
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    LPIDA pIDA = NULL;

    TraceEnter(TRACE_RSHX32, "CRShellExt::AddPages");

    if (IsSimpleUI())
        ExitGracefully(hr, E_FAIL, "No Security page in simple mode");

    //  
    //Check if Security Tab is hidden by privacy policy
    //NTRAID#NTBUG9-223899-2001/03/06-hiteshr
    //
    if(IsUIHiddenByPrivacyPolicy())
        ExitGracefully(hr, E_FAIL, "Security Page is hidden by Privacy Policy");

    // Get the ID List data
    hr = m_lpdobj->GetData(&fe, &medium);
    if (FAILED(hr) && m_seType == SE_FILE_OBJECT)
        TraceLeaveResult(AddMountedVolumePage(lpfnAddPage, lParam));

    FailGracefully(hr, "Can't get ID List format from data object");

    pIDA = (LPIDA)GlobalLock(medium.hGlobal);
    TraceAssert(pIDA != NULL);

    // Only support single selection for printers
    if (m_seType == SE_PRINTER && pIDA->cidl != 1)
        ExitGracefully(hr, E_FAIL, "Printer multiple selection not supported");

    hr = DoSecurityCheck(pIDA);

    if (S_OK == hr)
        hr = AddSecurityPage(lpfnAddPage, lParam);

exit_gracefully:

    if (pIDA)
        GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    TraceLeaveResult(hr);
}



/*++

Routine Description:

    Support for IShellPropSheetExt::ReplacePages (not supported).

Arguments:

    uPageID         - page to replace.
    lpfnReplaceWith - pointer to function called to replace a page.
    lParam          - lParam parameter to be passed to lpfnReplaceWith.

Return Values:

    Returns E_FAIL.

--*/

STDMETHODIMP
CRShellExt::ReplacePage(UINT                 /* uPageID */,
                        LPFNADDPROPSHEETPAGE /* lpfnReplaceWith */,
                        LPARAM               /* lParam */)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IContextMenu)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  FUNCTION: IContextMenu::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT)
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    indexMenu  - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//

STDMETHODIMP
CRShellExt::QueryContextMenu(HMENU hMenu,
                             UINT indexMenu,
                             UINT idCmdFirst,
                             UINT /*idCmdLast*/,
                             UINT uFlags)
{
    HRESULT hr = ResultFromShort(0);
    STGMEDIUM medium = {0};
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return hr;

    TraceEnter(TRACE_RSHX32, "CRShellExt::QueryContextMenu");

    // Get the ID List data
    hr = m_lpdobj->GetData(&fe, &medium);
    if (SUCCEEDED(hr))
    {
        LPIDA pIDA = (LPIDA)GlobalLock(medium.hGlobal);
        TraceAssert(pIDA != NULL);

        // Only support single selection
        if (pIDA->cidl == 1)
        {
            if (S_OK == DoSecurityCheck(pIDA))
            {
                TCHAR szSecurity[32];
                if (LoadString(g_hInstance, IDS_SECURITY_MENU, szSecurity, ARRAYSIZE(szSecurity)))
                {
                    MENUITEMINFO mii;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_TYPE | MIIM_ID;
                    mii.fType = MFT_STRING;
                    mii.wID = idCmdFirst;
                    mii.dwTypeData = szSecurity;
                    mii.cch = lstrlen(szSecurity);

                    InsertMenuItem(hMenu, indexMenu, TRUE /*fByPosition*/, &mii);

                    hr = ResultFromShort(1);    // Return number of items we added
                }
            }
        }
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

    TraceLeaveResult(hr);
}

//
//  FUNCTION: IContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//

STDMETHODIMP
CRShellExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hr = S_OK;
    STGMEDIUM medium;
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Don't support named verbs
    if (HIWORD(lpcmi->lpVerb))
        return E_NOTIMPL;

    TraceEnter(TRACE_RSHX32, "CRShellExt::InvokeCommand");

    // We only have one command, so we should get zero here
    TraceAssert(LOWORD(lpcmi->lpVerb) == 0);

    // This must be true for us to have added the command to the menu
    TraceAssert(S_OK == m_hrSecurityCheck);

    //
    // Call ShellExecuteEx to execute the "Properties" verb on this object, and
    // tell it to select the security property page.
    //

    // Get the ID List data
    hr = m_lpdobj->GetData(&fe, &medium);

    if (SUCCEEDED(hr))
    {
        LPIDA pIDA = (LPIDA)GlobalLock(medium.hGlobal);
        LPITEMIDLIST pidl;

        // We only support single selection for context menus
        TraceAssert(pIDA && pIDA->cidl == 1);

        // Build a fully qualified ID List for this object
        pidl = ILCombine((LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[0]),
                         (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[1]));

        if (pidl != NULL)
        {
            TCHAR szTitle[64];
            SHELLEXECUTEINFO sei =
            {
                sizeof(SHELLEXECUTEINFO),
                (lpcmi->fMask  & (SEE_MASK_HOTKEY | SEE_MASK_ICON)) | SEE_MASK_INVOKEIDLIST,
                lpcmi->hwnd,
                c_szProperties,     // lpVerb ("Properties")
                NULL,               // lpFile
                szTitle,            // lpParameters ("Security")
                NULL,               // lpDirectory,
                lpcmi->nShow,       // nShow
                NULL,               // hInstApp
                (LPVOID)pidl,       // lpIDList
                NULL,               // lpClass
                NULL,               // hkeyClass
                lpcmi->dwHotKey,    // dwHotKey
                lpcmi->hIcon,       // hIcon
                NULL                // hProcess
            };

            LoadString(g_hInstance, IDS_PROPPAGE_TITLE, szTitle, ARRAYSIZE(szTitle));

            // Put up the properties dialog
            if (!ShellExecuteEx(&sei))
            {
                DWORD dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }

            ILFree(pidl);
        }

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

#if 0
    //
    // SHObjectProperties builds a pidl to the object and then calls
    // ShellExecuteEx.  Similar to above, but it does more work to obtain the
    // ID lists (which we already have).
    //
    SHObjectProperties(lpcmi->hwnd,
                       m_seType == SE_PRINTER ? SHOP_PRINTERNAME : SHOP_FILEPATH,
                       m_pszObject,
                       TEXT("Security"));
#endif

    TraceLeaveResult(hr);
}

//
//  FUNCTION: IContextMenu::GetCommandString(UINT, UINT, UINT, LPSTR, UINT)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//
STDMETHODIMP
CRShellExt::GetCommandString(UINT_PTR /*idCmd*/,
                             UINT uFlags,
                             LPUINT /*reserved*/,
                             LPSTR pszName,
                             UINT cchMax)
{
    if (uFlags == GCS_HELPTEXT)
    {
        LoadString(g_hInstance, IDS_SECURITY_HELPSTRING, (LPTSTR)pszName, cchMax);
        return S_OK;
    }

    // Must be some other flag that we don't handle
    return E_NOTIMPL;
}


//
//  FUNCTION: CRShellExt::DoSecurityCheck(LPIDA)
//
//  PURPOSE: Helper function called by the Property Sheet and Context Menu
//           extension code.  Used to determine whether to add the menu item
//           or property sheet.
//
//  PARAMETERS:
//      pIDA - pointer to ID List Array specifying selected objects
//
//  RETURN VALUE: none
//
//  COMMENTS:
//      The results are stored in m_hrSecurityCheck, m_dwSIFlags, m_pszServer, and m_pszObject
//
STDMETHODIMP CRShellExt::DoSecurityCheck(LPIDA pIDA)
{
    if (((HRESULT)-1) == m_hrSecurityCheck)
    {
        if (m_seType == SE_PRINTER && IsAddPrinterWizard())
            m_hrSecurityCheck = HRESULT_FROM_WIN32(ERROR_NO_SECURITY_ON_OBJECT);
        else
            m_hrSecurityCheck = CheckForSecurity(pIDA);
    }
    return m_hrSecurityCheck;
}

//
//  PURPOSE: Helper function called by CRShellExt::DoSecurityCheck
//
//  PARAMETERS: pIDA - pointer to ID List array
//
//  RETURN VALUE: HRESULT - S_OK if ACL editing can proceed
//
//  COMMENTS:
//      The results are stored in m_dwSIFlags, m_pszServer, and m_pszObject
//
STDMETHODIMP CRShellExt::CheckForSecurity(LPIDA pIDA)
{
    HRESULT hr;
    TCHAR szServer[MAX_PATH];
    LPTSTR pszItem = NULL;
    //    LPTSTR pszAlternate = NULL;
    DWORD dwFlags = 0;
    UINT cItems;
    IShellFolder2 * psf = NULL;
    LPCITEMIDLIST pidl;
    DWORD dwAttr;
    DWORD dwPrivs[] = { SE_SECURITY_PRIVILEGE, SE_TAKE_OWNERSHIP_PRIVILEGE };
    HANDLE hToken = INVALID_HANDLE_VALUE;
    ACCESS_MASK dwAccess = 0;
    UINT i;
    
    TraceEnter(TRACE_RSHX32, "CRShellExt::CheckForSecurity");
    TraceAssert(m_pszServer == NULL);   // Shouldn't get called twice
    TraceAssert(pIDA != NULL);
    
    szServer[0] = TEXT('\0');
    
    cItems = pIDA->cidl;
    TraceAssert(cItems >= 1);
    
    //We don't show effective perm page for multiple selection
    if (cItems > 1)
        m_dwSIFlags &= ~SI_EDIT_EFFECTIVE;
    
    IShellFolder2 *psfRoot = NULL;
    LPCITEMIDLIST pidlFolder = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[0]);
    hr = BindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IShellFolder2, &psfRoot));
    FailGracefully(hr, "Unable to bind to folder");
    TraceAssert(psfRoot);
    
    
    // Create list for item paths
    TraceAssert(NULL == m_hItemList);
    m_hItemList = DPA_Create(4);
    if (NULL == m_hItemList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA");
    
    //
    // Get the first item and see if it supports security
    //
    LPCITEMIDLIST pidlItem = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[1]);
    hr = BindToFolderIDListParent(psfRoot, pidlItem, IID_PPV_ARG(IShellFolder2, &psf), &pidl);
    FailGracefully(hr, "Unable to get item name");
    
    hr = IDA_GetItemName(psf, pidl, &pszItem);
    FailGracefully(hr, "Unable to get item name");
    
    dwAttr = SFGAO_FOLDER | SFGAO_STREAM | SFGAO_FILESYSTEM;
    hr = psf->GetAttributesOf(1, &pidl, &dwAttr);
    FailGracefully(hr, "Unable to get item attributes");
    
    DoRelease(psf);
    
    //
    //If ACLUI is invoked for filesystem and object is not of filesystem
    //return E_FAIL
    //
    if ((m_seType == SE_FILE_OBJECT) && !(dwAttr & SFGAO_FILESYSTEM))
        ExitGracefully(hr, E_FAIL, "Not a filesystem object");
    
    // in the case that an item is both folder and stream, assume its a stream (.zip, .cab file)
    // and not a container
    if ((dwAttr & (SFGAO_FOLDER | SFGAO_STREAM)) == SFGAO_FOLDER)
        dwFlags |= DOBJ_RES_CONT;
    
    //
    // Check access on the first item only. If we can write the DACL
    // on the first one, we will try (later) to write to all items
    // in the selection and report any errors at that time.
    //
    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));
    
    switch (m_seType)
    {
    case SE_FILE_OBJECT:
        GetFileInfo(pszItem, &dwFlags, szServer, ARRAYSIZE(szServer),&m_bShowLossInheritedAclWarning);
        if (dwFlags & DOBJ_VOL_NTACLS)
            hr = CheckFileAccess(pszItem, &dwAccess);
        else
            hr = HRESULT_FROM_WIN32(ERROR_NO_SECURITY_ON_OBJECT);
        break;
        
    case SE_PRINTER:
        // Printers are containers (they contain documents)
        // and they don't have a parent (for acl editing purposes)
        dwFlags = DOBJ_RES_CONT | DOBJ_RES_ROOT;
        hr = CheckPrinterAccess(pszItem, &dwAccess, szServer, ARRAYSIZE(szServer));
        break;
        
    default:
        hr = E_UNEXPECTED;
    }
    FailGracefully(hr, "No access");
    
    // If we can't do anything security related, and only one item
    // was selected bail out.
    // Continue in case of multiple selection. We will show the
    // error with the name of problem file when security page 
    // is brought up.
    if (!(dwAccess & ALL_SECURITY_ACCESS) && (cItems == 1))
        ExitGracefully(hr, E_ACCESSDENIED, "No access");
    
    // Remember the server name
    if (TEXT('\0') != szServer[0])
    {
        hr = LocalAllocString(&m_pszServer, szServer);
        FailGracefully(hr, "LocalAlloc failed");
    }
    
    // Remember the item path
    DPA_AppendPtr(m_hItemList, pszItem);
    pszItem = NULL;
    
    if (!(dwAccess & WRITE_DAC))
        m_dwSIFlags |= SI_READONLY;
    
    if (!(dwAccess & WRITE_OWNER))
    {
        if (!(dwAccess & READ_CONTROL))
            m_dwSIFlags &= ~SI_EDIT_OWNER;
        else
            m_dwSIFlags |= SI_OWNER_READONLY;
    }
    
    if (!(dwAccess & ACCESS_SYSTEM_SECURITY))
        m_dwSIFlags &= ~SI_EDIT_AUDITS;
    
    //
    // Check the rest of the selection.  If any part of a multiple
    // selection doesn't support ACLs or the selection isn't homogenous,
    // then we can't create the security page.
    //
    for (i = 2; i <= cItems; i++)
    {
        DWORD dw = 0;
        
        // We only do multiple selections for files
        TraceAssert(SE_FILE_OBJECT == m_seType);
        LPCITEMIDLIST pidlItem1 = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[i]);
        hr = BindToFolderIDListParent(psfRoot, pidlItem1, IID_PPV_ARG(IShellFolder2, &psf), &pidl);
        FailGracefully(hr, "Unable to get item name");
        
        hr = IDA_GetItemName(psf, pidl, &pszItem);
        FailGracefully(hr, "Unable to get item name");
        
        dwAttr = SFGAO_FOLDER | SFGAO_STREAM | SFGAO_FILESYSTEM;
        hr = psf->GetAttributesOf(1, &pidl, &dwAttr);
        FailGracefully(hr, "Unable to get item attributes");
        
        DoRelease(psf);
        //
        //If ACLUI is invoked for filesystem and object is not of filesystem
        //return E_FAIL
        //
        if ((m_seType == SE_FILE_OBJECT) && !(dwAttr & SFGAO_FILESYSTEM))
            ExitGracefully(hr, E_FAIL, "Not a filesystem object");
        
        if ((dwAttr & (SFGAO_FOLDER | SFGAO_STREAM)) == SFGAO_FOLDER)
            dw |= DOBJ_RES_CONT;
        
        if ((dw & DOBJ_RES_CONT) != (dwFlags & DOBJ_RES_CONT))
            ExitGracefully(hr, E_FAIL, "Incompatible multiple selection");
        
        GetFileInfo(pszItem, &dw, szServer, ARRAYSIZE(szServer));
        
        // Compare against first item.  All flags and the server name
        // must match, otherwise we can't edit the ACLs.
        if (dw == dwFlags &&
            ((NULL == m_pszServer && TEXT('\0') == szServer[0]) ||
            (NULL != m_pszServer && 0 == lstrcmpi(m_pszServer, szServer))))
        {
            // Remember the item path
            DPA_AppendPtr(m_hItemList, pszItem);
            pszItem = NULL;
        }
        else
            ExitGracefully(hr, E_FAIL, "Incompatible multiple selection");
    }
    
    //
    // If everything has succeeded up to this point, save some flags
    // and the server and object name strings
    //
    if (dwFlags & DOBJ_RES_CONT)
        m_dwSIFlags |= SI_CONTAINER;
    
    //
    // For Root objects (e.g. "D:\") hide the ACL Protection checkbox,
    // since these objects don't appear to have parents.
    //
    if (dwFlags & DOBJ_RES_ROOT)
        m_dwSIFlags |= SI_NO_ACL_PROTECT;
    
    // Get the "Normal" display name to use as the object name
    hr = IDA_GetItemName(psfRoot, (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[1]),
        szServer, ARRAYSIZE(szServer), SHGDN_NORMAL);
    FailGracefully(hr, "Unable to get item name");
    if (cItems > 1)
    {
        int nLength = lstrlen(szServer);
        LoadString(g_hInstance, IDS_MULTISEL_ELLIPSIS, szServer + nLength, ARRAYSIZE(szServer) - nLength);
    }
    hr = LocalAllocString(&m_pszObject, szServer);
    
exit_gracefully:
    
    ReleasePrivileges(hToken);
    
    DoRelease(psf);
    DoRelease(psfRoot);
    
    LocalFreeString(&pszItem);
    
    TraceLeaveResult(hr);
}


//
//  FUNCTION: CRShellExt::CreateSI(LPSECURITYINFO *)
//
//  PURPOSE: Create a SecurityInformation object of the correct type
//
//  PARAMETERS: ppsi - Location to store ISecurityInformation pointer
//
//  RETURN VALUE: HRESULT signifying success or failure
//
//  COMMENTS:
//
STDMETHODIMP
CRShellExt::CreateSI(LPSECURITYINFO *ppsi)
{
    HRESULT hr;
    CSecurityInformation *psi;

    TraceEnter(TRACE_RSHX32, "CRShellExt::CreateSI");
    TraceAssert(ppsi != NULL);

    *ppsi = NULL;

    switch (m_seType)
    {
    case SE_FILE_OBJECT:
        psi = new CNTFSSecurity(m_seType,m_bShowLossInheritedAclWarning);  // ref == 1
        break;

    case SE_PRINTER:
        psi = new CPrintSecurity(m_seType); // ref == 1
        break;

    default:
        TraceLeaveResult(E_UNEXPECTED);
    }

    if (psi == NULL)
        TraceLeaveResult(E_OUTOFMEMORY);

    hr = psi->Initialize(m_hItemList,
                         m_dwSIFlags,
                         m_pszServer,
                         m_pszObject);
    if (SUCCEEDED(hr))
    {
        *ppsi = psi;

        // The SecurityInfo object takes responsibility for these
        m_hItemList = NULL;
        m_pszServer = NULL;
        m_pszObject = NULL;
        m_hrSecurityCheck = (HRESULT)-1;
    }
    else
        psi->Release();

    TraceLeaveResult(hr);
}

typedef HPROPSHEETPAGE (WINAPI *PFN_CREATESECPAGE)(LPSECURITYINFO);

HPROPSHEETPAGE _CreateSecurityPage(LPSECURITYINFO psi)
{
    HPROPSHEETPAGE hPage = NULL;
    const TCHAR szAclui[] = TEXT("aclui.dll");
    const char szCreateSecPage[] = "CreateSecurityPage";

    if (!g_hAclui)
        g_hAclui = LoadLibrary(szAclui);

    if (g_hAclui)
    {
        static PFN_CREATESECPAGE s_pfnCreateSecPage = NULL;

        if (!s_pfnCreateSecPage)
            s_pfnCreateSecPage = (PFN_CREATESECPAGE)GetProcAddress(g_hAclui, szCreateSecPage);

        if (s_pfnCreateSecPage)
            hPage = (*s_pfnCreateSecPage)(psi);
    }

    return hPage;
}

STDMETHODIMP
CRShellExt::AddSecurityPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    LPSECURITYINFO psi;

    hr = CreateSI(&psi);            // ref == 1

    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hPermPage = _CreateSecurityPage(psi);

        if (hPermPage)
        {
            if (!lpfnAddPage(hPermPage, lParam))
                DestroyPropertySheetPage(hPermPage);
        }
        else
        {
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }

        psi->Release();             // release initial ref
    }
    return hr;
}

//
//  PURPOSE: Check for the Add Printer wizard
//
//  PARAMETERS: none
//
//  RETURN VALUE: TRUE if the selected object is the Add Printer wizard,
//                FALSE otherwise
//
//  COMMENTS:
//
BOOL CRShellExt::IsAddPrinterWizard() const
{
    BOOL bRetval = FALSE;
    STGMEDIUM medium;
    FORMATETC fe = { g_cfPrinterGroup, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    TCHAR szFile[MAX_PATH];

    TraceEnter(TRACE_RSHX32, "CRShellExt::IsAddPrinterWizard");
    TraceAssert(m_seType == SE_PRINTER);

    //
    // Fail the call if m_lpdobj is NULL.
    //
    if ( m_lpdobj && SUCCEEDED( m_lpdobj->GetData( &fe, &medium ) ) )
    {
        //
        // Get the selected item name.
        //
        if ( DragQueryFile( (HDROP)medium.hGlobal, 0, szFile, ARRAYSIZE( szFile ) ) )
        {
            //
            // Check if this is the magic Add Printer Wizard shell object.
            // The check is not case sensitive and the string is not localized.
            //
            if ( 0 == lstrcmpi( szFile, TEXT("WinUtils_NewObject") ) )
            {
                TraceMsg("Found Add Printer wizard");
                bRetval = TRUE;
            }
        }

        //
        // Release the storage medium.
        //
        ReleaseStgMedium( &medium );
    }

    TraceLeaveValue(bRetval);
}



//
//  FUNCTION: CRShellExt::AddMountedVolumePage()
//
//  PURPOSE: Create Security page for mounted volume properties
//
//  PARAMETERS: lpfnAddPage - pointer to function called to add a page.
//              lParam      - lParam parameter to be passed to lpfnAddPage.
//
//  RETURN VALUE: HRESULT signifying success or failure
//
//  COMMENTS:
//
STDMETHODIMP
CRShellExt::AddMountedVolumePage(LPFNADDPROPSHEETPAGE lpfnAddPage,
                                 LPARAM               lParam)
{
    HRESULT hr = S_OK;
    STGMEDIUM medium = {0};
    FORMATETC fe = { g_cfMountedVolume, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    TCHAR szMountPoint[MAX_PATH];
    TCHAR szVolumeID[MAX_PATH];
    TCHAR szLabel[64];
    LPTSTR pszVolID = NULL;
    DWORD dwVolFlags = 0;
    DWORD dwPrivs[] = { SE_SECURITY_PRIVILEGE, SE_TAKE_OWNERSHIP_PRIVILEGE };
    HANDLE hToken = INVALID_HANDLE_VALUE;
    ACCESS_MASK dwAccess = 0;
    BOOL bHasSecurity = FALSE;

    TraceEnter(TRACE_RSHX32, "CRShellExt::AddMountedVolumePage");
    TraceAssert(m_seType == SE_FILE_OBJECT);
    TraceAssert(m_lpdobj);

    // Try to get the mounted volume host folder path
    hr = m_lpdobj->GetData(&fe, &medium);
    FailGracefully(hr, "Not a mounted volume");

    // Get the host folder path
    if (!DragQueryFile((HDROP)medium.hGlobal, 0, szMountPoint, ARRAYSIZE(szMountPoint)))
        ExitGracefully(hr, E_FAIL, "Can't get mount point from storage medium");

    PathAddBackslash(szMountPoint);

    // Get the volume ID, which looks like
    // "\\?\Volume{9e2df3f5-c7f1-11d1-84d5-000000000000}\"
    if (!GetVolumeNameForVolumeMountPoint(szMountPoint, szVolumeID, ARRAYSIZE(szVolumeID)))
        ExitGracefully(hr, E_FAIL, "GetVolumeNameForVolumeMountPoint failed");

    if (GetVolumeInformation(szMountPoint, //szVolumeID,
                             szLabel,
                             ARRAYSIZE(szLabel),
                             NULL,
                             NULL,
                             &dwVolFlags,
                             NULL,
                             0))
    {
        if (dwVolFlags & FS_PERSISTENT_ACLS)
        {
            bHasSecurity = TRUE;
        }
    }
    else if (GetLastError() == ERROR_ACCESS_DENIED)
    {
        // If we can't get the volume information because we don't have
        // access, then there must be security!
        bHasSecurity = TRUE;
    }

    if (!bHasSecurity)
        ExitGracefully(hr, E_FAIL, "Volume inaccessible or not NTFS");

    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));

    hr = CheckFileAccess(szVolumeID, &dwAccess);
    FailGracefully(hr, "Volume inaccessible");

    // If we can't do anything security related, don't continue.
    if (!(dwAccess & ALL_SECURITY_ACCESS))
        ExitGracefully(hr, E_ACCESSDENIED, "No security access");

    if (!(dwAccess & WRITE_DAC))
        m_dwSIFlags |= SI_READONLY;

    if (!(dwAccess & WRITE_OWNER))
    {
        if (!(dwAccess & READ_CONTROL))
            m_dwSIFlags &= ~SI_EDIT_OWNER;
        else
            m_dwSIFlags |= SI_OWNER_READONLY;
    }

    if (!(dwAccess & ACCESS_SYSTEM_SECURITY))
        m_dwSIFlags &= ~SI_EDIT_AUDITS;

    m_dwSIFlags |= SI_CONTAINER | SI_NO_ACL_PROTECT;



    if (!FormatStringID(&m_pszObject,
                        g_hInstance,
                        IDS_FMT_VOLUME_DISPLAY,
                        szLabel,
                        szMountPoint))
    {
        LocalAllocString(&m_pszObject, szLabel);
    }

    if (!m_pszObject)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to build volume display string");

    m_hItemList = DPA_Create(1);
    if (!m_hItemList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create item list");

    hr = LocalAllocString(&pszVolID, szVolumeID);
    FailGracefully(hr, "Unable to copy volume ID string");

    DPA_AppendPtr(m_hItemList, pszVolID);
    pszVolID = NULL;

    hr = AddSecurityPage(lpfnAddPage, lParam);

exit_gracefully:

    ReleasePrivileges(hToken);
    LocalFreeString(&pszVolID);
    ReleaseStgMedium(&medium);
    TraceLeaveResult(hr);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous helper functions                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



BOOL
IsDfsPath(LPTSTR pszPath,       // in
          LPTSTR pszServer,     // out
          UINT   cchServer)    // out
{
    BOOL bIsDfs = FALSE;
    WCHAR szPath[MAX_PATH];
    PDFS_INFO_3 pDI3 = NULL;
    WCHAR szServer[MAX_PATH];

    USES_CONVERSION;

    if (!PathIsUNC(pszPath))
        return FALSE;     // local machine

    lstrcpynW(szPath, T2CW(pszPath), ARRAYSIZE(szPath));

    // Check for DFS
    for (;;)
    {
        DWORD dwErr;

        __try
        {
            // This is delay-loaded by the linker, so
            // must wrap with an exception handler.
            dwErr = NetDfsGetClientInfo(szPath,
                                        NULL,
                                        NULL,
                                        3,
                                        (LPBYTE*)&pDI3);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }

        if (NERR_Success == dwErr)
        {
            for (ULONG i = 0; i < pDI3->NumberOfStorages; i++)
            {
                if (DFS_STORAGE_STATE_ONLINE & pDI3->Storage[i].State)
                {
                    bIsDfs = TRUE;

                    szServer[0] = L'\\';
                    szServer[1] = L'\\';
                    lstrcpynW(&szServer[2], pDI3->Storage[i].ServerName, ARRAYSIZE(szServer)-2);

                    // If this server is active, quit looking
                    if (DFS_STORAGE_STATE_ACTIVE & pDI3->Storage[i].State)
                        break;
                }
            }
            break;
        }
        else if (NERR_DfsNoSuchVolume == dwErr)
        {
            // If we're at the root, then we can't go any farther.
            if (PathIsRoot(szPath))
                break;

            // Remove the last path element and try again, if nothing is 
            //removed, break, don't go in infinite loop
            if (!PathRemoveFileSpec(szPath))
                break;
        }
        else
        {
            // Some other error, bail
            break;
        }
    }

    if (bIsDfs)
    {
        lstrcpyn(pszServer, W2T(szServer), cchServer);
    }

    if (NULL != pDI3)
        NetApiBufferFree(pDI3);

    return bIsDfs;
}


void
GetVolumeInfo(LPCTSTR pszPath,
              BOOL    bIsFolder,
              LPDWORD pdwFlags,
              LPTSTR  pszVolume,
              ULONG   cchVolume)
{
    TCHAR szVolume[MAX_PATH];
    TCHAR szVolumeID[MAX_PATH];

    //
    // The path can be DFS or contain volume mount points, so start
    // with the full path and try GetVolumeInformation on successively
    // shorter paths until it succeeds or we run out of path.
    //
    // However, if it's a volume mount point, we're interested in the
    // the host folder's volume so back up one level to start.  The
    // child volume is handled separately (see AddMountedVolumePage).
    //

    lstrcpyn(szVolume, pszPath, ARRAYSIZE(szVolume));

    if (!bIsFolder
        || GetVolumeNameForVolumeMountPoint(szVolume, szVolumeID, ARRAYSIZE(szVolumeID)))
    {
        PathRemoveFileSpec(szVolume);
    }

    for (;;)
    {
        PathAddBackslash(szVolume); // GetVolumeInformation likes a trailing '\'

        if (GetVolumeInformation(szVolume,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 pdwFlags,
                                 NULL,
                                 0))
        {
            break;
        }

        // Access denied implies that we've reached the deepest volume
        // in the path; we just can't get the flags.  It also implies
        // security, so assume persistent acls.
        if (ERROR_ACCESS_DENIED == GetLastError())
        {
            *pdwFlags = FS_PERSISTENT_ACLS;
            break;
        }

        // If we're at the root, then we can't go any farther.
        if (PathIsRoot(szVolume))
            break;

        // Remove the last path element and try again
        PathRemoveBackslash(szVolume);
        //if nothing is removed break instead of going in infinite loop
        if (!PathRemoveFileSpec(szVolume))
            break;
    }

    if (pszVolume)
    {
        PathRemoveBackslash(szVolume);
        lstrcpyn(pszVolume, szVolume, cchVolume);
    }
}

/*
This function checks if pszPath is a root share. pszPath is in the format 
\\server\share where "share" is shared out directory on "server". Function
attempts to get the local path of "share" on "server" directory. If local
path is root, pszPath is a root share. In all other cases (including failures)
its not. Only members of the Administrators or Account Operators local group or 
those with Communication, Print, or Server operator group membership can 
successfully execute the NetShareGetInfo function at level 2, so its likely
we will encounter failures and in those cases we will simply treat this as
non-root share.
*/
BOOL IsShareRoot(LPCTSTR pszPath)
{
    if(!pszPath)
    {
        return FALSE;
    }

    DWORD dwReturn = FALSE;
    do
    {
        //Check if pszPath is in format \\server\share
        if(!PathIsUNCServerShare(pszPath))
            break;
        
        //pszShare will point to "share" 
        LPWSTR pszShare = PathFindFileName(pszPath);

        if(!pszShare)
            break;
        
        WCHAR szServer[MAX_PATH];
        if(FAILED(StringCchCopy(szServer,ARRAYSIZE(szServer),pszPath)))
            break;;

        //Remove the "share" portion, szServer will contain \\server
        if(!PathRemoveFileSpec(szServer))
            break;

        //Get the local path of the share on the server
        SHARE_INFO_2 *pbuf = NULL;
        NET_API_STATUS status = NetShareGetInfo(szServer,
                                                pszShare,
                                                2,
                                                (LPBYTE *)&pbuf);
    
        if(status != NERR_Success)
            break;

        if(pbuf && pbuf->shi2_path && PathIsRoot(pbuf->shi2_path))
        {
            dwReturn = TRUE;
        }

        if(pbuf)
        {
            NetApiBufferFree(pbuf);
            pbuf = NULL;
        }
    }while(0);

    return dwReturn;
}
                    




/*
Setting permissions can result, in some special cases, in loss of inherited aces.
pbShowLossInheritedAclWarning is set to TRUE if that's the case and we show 
a warning.
*/
void
GetFileInfo(LPCTSTR pszPath,
            LPDWORD pdwFileType,
            LPTSTR  pszServer,
            ULONG   cchServer,
            BOOL *pbShowLossInheritedAclWarning)
{
    DWORD dwVolumeFlags = 0;
    TCHAR szVolume[MAX_PATH];
    LPTSTR pszUNC = NULL;

    TraceEnter(TRACE_RSHX32, "GetFileInfo");
    TraceAssert(NULL != pszServer);

    pszServer[0] = TEXT('\0');

    if(pbShowLossInheritedAclWarning)
        *pbShowLossInheritedAclWarning = FALSE;


    if (!PathIsUNC(pszPath) && S_OK == GetRemotePath(pszPath, &pszUNC))
        pszPath = pszUNC;

    //If path is in format "\\server\share", special case this case
    //to determine if it's a root.
    //NTRAID#NTBUG9-501402-2002/05/06-hiteshr
    if(PathIsUNCServerShare(pszPath))
    {
        //check if "share" is root on the "\\server"
        if(IsShareRoot(pszPath))
        {
            *pdwFileType |= DOBJ_RES_ROOT;
        }
        else if(pbShowLossInheritedAclWarning)
        {
            //It's a UNC share which is not root. Setting acl will result in loss of 
            //inherited aces
            *pbShowLossInheritedAclWarning = TRUE;
        }
    }
    else if (PathIsRoot(pszPath))
    {
        *pdwFileType |= DOBJ_RES_ROOT;
        if(pbShowLossInheritedAclWarning)
        {
            if(GetDriveType(pszPath) == DRIVE_REMOTE)
            {
                //This is a remote drive and we have been unable to determine 
                //if its root of drive. By default we assume, it's not root of 
                //drive and show warning.
                *pbShowLossInheritedAclWarning = TRUE;
            }
        }
    }

    GetVolumeInfo(pszPath,
                  *pdwFileType & DOBJ_RES_CONT,
                  &dwVolumeFlags,
                  szVolume,
                  ARRAYSIZE(szVolume));
    if (dwVolumeFlags & FS_PERSISTENT_ACLS)
    {
        *pdwFileType |= DOBJ_VOL_NTACLS;

        if (IsDfsPath(szVolume, pszServer, cchServer))
        {
        }
        else if (PathIsUNC(szVolume))
        {
            LPTSTR pSlash = StrChr(&szVolume[2], TEXT('\\'));
            if (pSlash)
                cchServer = min(cchServer, (ULONG)(pSlash - szVolume) + 1);
            lstrcpyn(pszServer, szVolume, cchServer);
        }
    }

    LocalFreeString(&pszUNC);

    TraceLeaveVoid();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\si.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       si.h
//
//  This file contains the definition of the CSecurityInformation
//  base class.
//
//--------------------------------------------------------------------------

#ifndef _SI_H_
#define _SI_H_

class CSecurityInformation : public ISecurityInformation, IEffectivePermission, ISecurityObjectTypeInfo
{
protected:
    ULONG           m_cRef;
    SE_OBJECT_TYPE  m_seType;
    HDPA            m_hItemList;
    DWORD           m_dwSIFlags;
    LPTSTR          m_pszServerName;
    LPTSTR          m_pszObjectName;
    HWND            m_hwndOwner;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check
    BOOL            m_bIsStandAlone;

public:
    CSecurityInformation(SE_OBJECT_TYPE seType);
    virtual ~CSecurityInformation();

    STDMETHOD(Initialize)(HDPA   hItemList,
                          DWORD  dwFlags,
                          LPTSTR pszServer,
                          LPTSTR pszObject);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess) PURE;
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask) PURE;
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes) PURE;
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);

    STDMETHOD(GetEffectivePermission) (  const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength);

    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray) PURE;


protected:
    STDMETHOD(ReadObjectSecurity)(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD);
    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);

    AUTHZ_RESOURCE_MANAGER_HANDLE GetAUTHZ_RM(){ return m_ResourceManager; }

    BOOL IsFile(){ return !(m_dwSIFlags & SI_CONTAINER); }
};

#endif  /* _SI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\si.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       si.cpp
//
//  This file contains the implementation of the CSecurityInformation
//  base class.
//
//--------------------------------------------------------------------------

#include "rshx32.h"
#include <shlapip.h> 


#include <dsrole.h>
BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC)
{
    BOOL bStandalone = TRUE;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole = NULL;

    //
    // Find out if target machine is a standalone machine or joined to
    // an NT domain.
    //

    __try
    {
        if (pbIsDC)
            *pbIsDC = FALSE;

        DsRoleGetPrimaryDomainInformation(pszMachine,
                                          DsRolePrimaryDomainInfoBasic,
                                          (PBYTE*)&pDsRole);
    }
    __finally
    {
    }

    if (NULL != pDsRole)
    {
        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            bStandalone = TRUE;
        }
        else
            bStandalone = FALSE;

        if (pbIsDC)
        {
            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                *pbIsDC = TRUE;
            }
        }

        DsRoleFreeMemory(pDsRole);
    }

    return bStandalone;
}


void
ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    SECURITY_DESCRIPTOR_CONTROL wSDControl;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bDefaulted;
    BOOL bPresent;
    PACE_HEADER pAce;
    UINT cAces;

    TraceEnter(TRACE_SI, "ProtectACLs");

    if (0 == si || NULL == pSD)
        TraceLeaveVoid();   // Nothing to do

    // Get the ACL protection control bits
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    wSDControl &= SE_DACL_PROTECTED | SE_SACL_PROTECTED;

    if ((si & DACL_SECURITY_INFORMATION) && !(wSDControl & SE_DACL_PROTECTED))
    {
        wSDControl |= SE_DACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

        // Theoretically, modifying the DACL in this way can cause it to be
        // no longer canonical.  However, the only way this can happen is if
        // there is an inherited Deny ACE and a non-inherited Allow ACE.
        // Since this function is only called for root objects, this means
        // a) the server DACL must have a Deny ACE and b) the DACL on this
        // object must have been modified later.  But if the DACL was
        // modified through the UI, then we would have eliminated all of the
        // Inherited ACEs already.  Therefore, it must have been modified
        // through some other means.  Considering that the DACL originally
        // inherited from the server never has a Deny ACE, this situation
        // should be extrememly rare.  If it ever does happen, the ACL
        // Editor will just tell the user that the DACL is non-canonical.
        //
        // Therefore, let's ignore the possibility here.

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    if ((si & SACL_SECURITY_INFORMATION) && !(wSDControl & SE_SACL_PROTECTED))
    {
        wSDControl |= SE_SACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefaulted);

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED | SE_SACL_PROTECTED, wSDControl);

    TraceLeaveVoid();
}


CSecurityInformation::CSecurityInformation(SE_OBJECT_TYPE seType)
: m_cRef(1), m_seType(seType), m_hwndOwner(NULL),m_ResourceManager(NULL),m_bIsStandAlone(FALSE)   
{
    InterlockedIncrement(&g_cRefThisDll);
    AuthzInitializeResourceManager(AUTHZ_RM_FLAG_NO_AUDIT,
                                   NULL,
                                   NULL,
                                   NULL,
                                   L"Dummy",                                  
                                   &m_ResourceManager );

}

CSecurityInformation::~CSecurityInformation()
{
    LocalFreeDPA(m_hItemList);
    LocalFreeString(&m_pszObjectName);
    LocalFreeString(&m_pszServerName);
    AuthzFreeResourceManager(m_ResourceManager);

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}

STDMETHODIMP
CSecurityInformation::Initialize(HDPA   hItemList,
                                 DWORD  dwFlags,
                                 LPTSTR pszServer,
                                 LPTSTR pszObject)
{
    TraceEnter(TRACE_SI, "CSecurityInformation::Initialize");
    TraceAssert(hItemList != NULL);
    TraceAssert(DPA_GetPtrCount(hItemList) > 0);
    TraceAssert(pszObject != NULL);
    TraceAssert(m_pszObjectName == NULL);   // only initialize once

    m_hItemList = hItemList;
    m_dwSIFlags = dwFlags;
    m_pszServerName = pszServer;
    m_pszObjectName = pszObject;
    m_bIsStandAlone = IsStandalone(pszServer, NULL);


    TraceLeaveResult(S_OK);
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSecurityInformation::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInformation::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CSecurityInformation::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IEffectivePermission))
    {
        *ppv = (LPEFFECTIVEPERMISSION)this;
        m_cRef++;
        return S_OK;
    }
    else if((m_seType != SE_PRINTER) && IsEqualIID(riid, IID_ISecurityObjectTypeInfo))
    {
        *ppv = (LPSecurityObjectTypeInfo)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CSecurityInformation::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    TraceEnter(TRACE_SI, "CSecurityInformation::GetObjectInformation");
    TraceAssert(pObjectInfo != NULL &&
                !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    pObjectInfo->dwFlags = m_dwSIFlags;
    pObjectInfo->hInstance = g_hInstance;
    pObjectInfo->pszServerName = m_pszServerName;
    pObjectInfo->pszObjectName = m_pszObjectName;

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CSecurityInformation::GetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD,
                                  BOOL fDefault)
{
    HRESULT hr = S_OK;
    LPTSTR pszItem;

    TraceEnter(TRACE_SI, "CSecurityInformation::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    *ppSD = NULL;

    //Default security descriptor not supported
    if (fDefault)
        ExitGracefully(hr, E_NOTIMPL, "Default security descriptor not supported");

    // Get the name of the first item
    pszItem = (LPTSTR)DPA_GetPtr(m_hItemList, 0);
    if (NULL == pszItem)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");

    hr = ReadObjectSecurity(pszItem, si, ppSD);

    // If this is a Root object, then we pretend that the ACLs are
    // always protected and no ACEs are inherited.
    if (SUCCEEDED(hr) && (m_dwSIFlags & SI_NO_ACL_PROTECT))
       ProtectACLs(si & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION), *ppSD);

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInformation::SetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    HCURSOR hcurPrevious = (HCURSOR)INVALID_HANDLE_VALUE;
    UINT cItems;
    int i;

    TraceEnter(TRACE_SI, "CSecurityInformation::SetSecurity");
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    if (NULL == m_hItemList)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");

    hcurPrevious = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Apply the new permissions to every item in the list
    //
    for (i = 0; i < DPA_GetPtrCount(m_hItemList); i++)
    {
        LPTSTR pszItem = (LPTSTR)DPA_FastGetPtr(m_hItemList, i);
        hr = WriteObjectSecurity(pszItem, si, pSD);
        FailGracefully(hr, "Unable to write new security descriptor");
        if (IsFile())  // If this is a file, delete it's thumbnail from the database, it will get put back if appropriate
        {
            DeleteFileThumbnail(pszItem);
        }
    }

exit_gracefully:

    // Restore previous cursor
    if (hcurPrevious != INVALID_HANDLE_VALUE)
        SetCursor(hcurPrevious);

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInformation::PropertySheetPageCallback(HWND hwnd,
                                                UINT uMsg,
                                                SI_PAGE_TYPE uPage)
{
    if (SI_PAGE_PERM == uPage)
    {
        switch (uMsg)
        {
        case PSPCB_SI_INITDIALOG:
            do
            {
                m_hwndOwner = hwnd;
            } while (hwnd = GetParent(hwnd));

            break;

        case PSPCB_RELEASE:
            m_hwndOwner = NULL;
            break;
        }
    }
    return S_OK;
}


STDMETHODIMP
CSecurityInformation::ReadObjectSecurity(LPCTSTR pszObject,
                                         SECURITY_INFORMATION si,
                                         PSECURITY_DESCRIPTOR *ppSD)
{
    DWORD dwErr;

    TraceEnter(TRACE_SI, "CSecurityInformation::ReadObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    //
    // This is kinda screwy.  The new APIs are being removed from NT5, but have
    // already been added to NT4 SP4.  The old APIs have new functionality on NT5,
    // but not on NT4 SPx.  Since we need the new functionality (auto-inheritance),
    // we have to call the new (defunct) API on NT4 and the old API on NT5.
    //
    dwErr = GetNamedSecurityInfo((LPTSTR)pszObject,
                                 m_seType,
                                 si,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 ppSD);

    TraceLeaveResult(HRESULT_FROM_WIN32(dwErr));
}


STDMETHODIMP
CSecurityInformation::WriteObjectSecurity(LPCTSTR pszObject,
                                          SECURITY_INFORMATION si,
                                          PSECURITY_DESCRIPTOR pSD)
{
    DWORD dwErr;

    TraceEnter(TRACE_SI, "CSecurityInformation::WriteObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    //
    // This is kinda screwy.  The new APIs are being removed from NT5, but have
    // already been added to NT4 SP4.  The old APIs have new functionality on NT5,
    // but not on NT4 SPx.  Since we need the new functionality (auto-inheritance),
    // we have to call the new (defunct) API on NT4 and the old API on NT5.
    //

    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    DWORD dwRevision;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    BOOL bDefaulted;
    BOOL bPresent;

    //
    // Get pointers to various security descriptor parts for
    // calling SetNamedSecurityInfo
    //
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);
    GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted);
    GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted);

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_DACL_PROTECTED)
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    }
    if (si & SACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_SACL_PROTECTED)
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    }

    dwErr = SetNamedSecurityInfo((LPTSTR)pszObject,
                                 m_seType,
                                 si,
                                 psidOwner,
                                 psidGroup,
                                 pDacl,
                                 pSacl);

    TraceLeaveResult(HRESULT_FROM_WIN32(dwErr));
}

OBJECT_TYPE_LIST g_DefaultOTL[] = {
                                    {0, 0, (LPGUID)&GUID_NULL},
                                    };
BOOL SkipLocalGroup(LPCWSTR pszServerName, PSID psid)
{

	SID_NAME_USE use;
	WCHAR szAccountName[MAX_PATH];
	WCHAR szDomainName[MAX_PATH];
	DWORD dwAccountLen = MAX_PATH;
	DWORD dwDomainLen = MAX_PATH;

	if(LookupAccountSid(pszServerName,
						 psid,
						 szAccountName,
						 &dwAccountLen,
						 szDomainName,
						 &dwDomainLen,
						 &use))
	{
		if(use == SidTypeWellKnownGroup)
			return TRUE;
	}

	//Built In sids have first subauthority of 32 ( s-1-5-32 )
	//
	if((*(GetSidSubAuthorityCount(psid)) >= 1 ) && (*(GetSidSubAuthority(psid,0)) == 32))
		return TRUE;

	return FALSE;
}

		

STDMETHODIMP 
CSecurityInformation::GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength)
{

    AUTHZ_RESOURCE_MANAGER_HANDLE RM = NULL;    //Used for access check
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_ACCESS_REQUEST AReq;
    AUTHZ_ACCESS_REPLY AReply;
    HRESULT hr = S_OK;    
    DWORD dwFlags;

    TraceEnter(TRACE_SI, "CDSSecurityInfo::GetEffectivePermission");
    TraceAssert(pUserSid && IsValidSecurityDescriptor(pSD));
    TraceAssert(ppObjectTypeList != NULL);
    TraceAssert(pcObjectTypeListLength != NULL);
    TraceAssert(ppGrantedAccessList != NULL);
    TraceAssert(pcGrantedAccessListLength != NULL);

    AReq.ObjectTypeList = g_DefaultOTL;
    AReq.ObjectTypeListLength = ARRAYSIZE(g_DefaultOTL);
    AReply.GrantedAccessMask = NULL;
    AReply.Error = NULL;

    //Get RM
    if( (RM = GetAUTHZ_RM()) == NULL )
        ExitGracefully(hr, E_UNEXPECTED, "LocalAlloc failed");    

    //Initialize the client context

	BOOL bSkipLocalGroup = SkipLocalGroup(pszServerName, pUserSid);
    
    if( !AuthzInitializeContextFromSid(bSkipLocalGroup? AUTHZ_SKIP_TOKEN_GROUPS :0,
                                       pUserSid,
                                       RM,
                                       NULL,
                                       luid,                                      
                                       NULL,
                                       &CC) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr, 
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzInitializeContextFromSid Failed");
    }



    //Do the Access Check

    AReq.DesiredAccess = MAXIMUM_ALLOWED;
    AReq.PrincipalSelfSid = NULL;
    AReq.OptionalArguments = NULL;

    AReply.ResultListLength = AReq.ObjectTypeListLength;
    AReply.SaclEvaluationResults = NULL;
    if( (AReply.GrantedAccessMask = (PACCESS_MASK)LocalAlloc(LPTR, sizeof(ACCESS_MASK)*AReply.ResultListLength) ) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");
    if( (AReply.Error = (PDWORD)LocalAlloc(LPTR, sizeof(DWORD)*AReply.ResultListLength)) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");
    
    if( !AuthzAccessCheck(0,
                          CC,
                          &AReq,
                          NULL,
                          pSD,
                          NULL,
                          0,
                          &AReply,
                          NULL) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr,                        
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzAccessCheck Failed");
    }

exit_gracefully:

    if(CC)
        AuthzFreeContext(CC);
    
    if(!SUCCEEDED(hr))
    {
        if(AReply.GrantedAccessMask)
            LocalFree(AReply.GrantedAccessMask);
        if(AReply.Error)
            LocalFree(AReply.Error);
        AReply.Error = NULL;
        AReply.GrantedAccessMask = NULL;
    }
    else
    {
        *ppObjectTypeList = AReq.ObjectTypeList;                                  
        *pcObjectTypeListLength = AReq.ObjectTypeListLength;
        *ppGrantedAccessList = AReply.GrantedAccessMask;
        *pcGrantedAccessListLength = AReq.ObjectTypeListLength;
    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       util.cpp
//
//  This file contains misc functions.
//
//--------------------------------------------------------------------------

#include "rshx32.h"
#include <shlobjp.h>    // SHFree
#include <shlwapip.h>   // IsOS
#include <safeboot.h>   // SAFEBOOT_* flags


STDMETHODIMP
IDA_BindToFolder(LPIDA pIDA, LPSHELLFOLDER *ppsf)
{
    HRESULT hr;
    LPSHELLFOLDER psfDesktop;

    TraceEnter(TRACE_UTIL, "IDA_BindToFolder");
    TraceAssert(pIDA != NULL);
    TraceAssert(ppsf != NULL);

    *ppsf = NULL;

    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlFolder = (LPCITEMIDLIST)ByteOffset(pIDA, pIDA->aoffset[0]);

        if (ILIsEmpty(pidlFolder))
        {
            // We're binding to the desktop
            *ppsf = psfDesktop;
        }
        else
        {
            hr = psfDesktop->BindToObject(pidlFolder,
                                          NULL,
                                          IID_IShellFolder,
                                          (PVOID*)ppsf);
            psfDesktop->Release();
        }
    }

    TraceLeaveResult(hr);
}


STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR pszName,
                UINT cchName,
                SHGNO uFlags)
{
    STRRET str;
    HRESULT hr;

    hr = psf->GetDisplayNameOf(pidl, uFlags, &str);

    if (SUCCEEDED(hr))
    {
        DWORD dwErr;
        LPSTR psz;

        switch (str.uType)
        {
        case STRRET_WSTR:
            lstrcpyn(pszName, str.pOleStr, cchName);

            //
            // Since this string was alocated from the shell's IMalloc heap,
            // we must free it to the same place.
            //
            SHFree(str.pOleStr);
            break;

        case STRRET_OFFSET:
            psz = (LPSTR)ByteOffset(pidl, str.uOffset);
            goto GetItemName_ANSI;

        case STRRET_CSTR:
            psz = str.cStr;
GetItemName_ANSI:

            if (!MultiByteToWideChar(CP_ACP,
                                     0,
                                     psz,
                                     -1,
                                     pszName,
                                     cchName))
            {
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }

    return hr;
}


STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR *ppszName,
                SHGNO uFlags)
{
    TCHAR szName[MAX_PATH];
    HRESULT hr = IDA_GetItemName(psf, pidl, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
        hr = LocalAllocString(ppszName, szName);
    else
        *ppszName = NULL;
    return hr;
}


//
// Helper functions used by DPA_CompareSecurityIntersection
//
BOOL
IsEqualSID(PSID pSid1, PSID pSid2)
{
    //
    // Are they both NULL?
    //
    if (pSid1 || pSid2)
    {
        //
        // At least one is non-NULL, so if one is NULL then they can't
        // be equal.
        //
        if (pSid1 == NULL || pSid2 == NULL)
            return FALSE;

        //
        // Both are non-NULL. Check the SIDs.
        //
        if (!EqualSid(pSid1, pSid2))
            return FALSE;
    }

    return TRUE;
}

BOOL
IsEqualACL(PACL pA1, PACL pA2)
{
    //
    // Are they both NULL?
    //
    if (pA1 || pA2)
    {
        //
        // At least one is non-NULL, so if one is NULL then they can't
        // be equal.
        //
        if (pA1 == NULL || pA2 == NULL)
            return FALSE;

        //
        // At this point we know that both are non-NULL.  Check the
        // sizes and contents.
        //
        // could do a lot more here
        if (pA1->AclSize != pA2->AclSize || memcmp(pA1, pA2, pA1->AclSize))
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CompareSecurityDescriptors
//
//  Synopsis:   Determines if 2 security descriptors are identical.  It does
//              this by comparing control fields, owner/group, and acls.
//
//  Arguments:  [IN]  pSD1         - 1st SD to compare
//              [IN]  pSD2         - 2nd SD to compare
//              [OUT] pfOwnerConflict - (optional) Set to TRUE if the Owner SIDs are not equal
//              [OUT] pfGroupConflict - (optional) Set to TRUE if the Group SIDs are not equal
//              [OUT] pfDACLConflict  - (optional) Set to TRUE if the DACLs are not equal
//              [OUT] pfSACLConflict  - (optional) Set to TRUE if the SACLs are not equal
//
//  Returns:    nothing
//
//
//----------------------------------------------------------------------------

#define DACL_CONTROL_MASK   (SE_DACL_PRESENT | SE_DACL_DEFAULTED | SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED)
#define SACL_CONTROL_MASK   (SE_SACL_PRESENT | SE_SACL_DEFAULTED | SE_SACL_AUTO_INHERITED | SE_SACL_PROTECTED)

void
CompareSecurityDescriptors(PSECURITY_DESCRIPTOR pSD1,
                           PSECURITY_DESCRIPTOR pSD2,
                           BOOL                *pfOwnerConflict,
                           BOOL                *pfGroupConflict,
                           BOOL                *pfSACLConflict,
                           BOOL                *pfDACLConflict)
{
    PISECURITY_DESCRIPTOR pS1 = (PISECURITY_DESCRIPTOR)pSD1;
    PISECURITY_DESCRIPTOR pS2 = (PISECURITY_DESCRIPTOR)pSD2;

    //
    // Are the pointers identical?
    // This includes the case where both are NULL.
    //
    if (pS1 == pS2)
    {
        if (pfOwnerConflict)
            *pfOwnerConflict = FALSE;
        if (pfGroupConflict)
            *pfGroupConflict = FALSE;
        if (pfSACLConflict)
            *pfSACLConflict = FALSE;
        if (pfDACLConflict)
            *pfDACLConflict = FALSE;
        return;
    }

    //
    // Is (only) one of them NULL?  If so, then we can't compare so
    // assume that nothing matches.
    //
    if (!pS1 || !pS2)
    {
        if (pfOwnerConflict)
            *pfOwnerConflict = TRUE;
        if (pfGroupConflict)
            *pfGroupConflict = TRUE;
        if (pfSACLConflict)
            *pfSACLConflict = TRUE;
        if (pfDACLConflict)
            *pfDACLConflict = TRUE;
        return;
    }

    //
    // Owner
    //
    if (pfOwnerConflict)
    {
        if ((pS1->Control & SE_OWNER_DEFAULTED) != (pS2->Control & SE_OWNER_DEFAULTED))
        {
            *pfOwnerConflict = TRUE;
        }
        else
        {
            *pfOwnerConflict = !IsEqualSID(RtlpOwnerAddrSecurityDescriptor(pS1),
                                           RtlpOwnerAddrSecurityDescriptor(pS2));
        }
    }

    //
    // Group
    //
    if (pfGroupConflict)
    {
        if ((pS1->Control & SE_GROUP_DEFAULTED) != (pS2->Control & SE_GROUP_DEFAULTED))
        {
            *pfGroupConflict = TRUE;
        }
        else
        {
            *pfGroupConflict = !IsEqualSID(RtlpGroupAddrSecurityDescriptor(pS1),
                                           RtlpGroupAddrSecurityDescriptor(pS2));
        }
    }

    //
    // Sacl
    //
    if (pfSACLConflict)
    {
        if ((pS1->Control & SACL_CONTROL_MASK) != (pS2->Control & SACL_CONTROL_MASK))
        {
            *pfSACLConflict = TRUE;
        }
        else
        {
            *pfSACLConflict = !IsEqualACL(RtlpSaclAddrSecurityDescriptor(pS1),
                                          RtlpSaclAddrSecurityDescriptor(pS2));
        }
    }

    //
    // Dacl
    //
    if (pfDACLConflict)
    {
        if ((pS1->Control & DACL_CONTROL_MASK) != (pS2->Control & DACL_CONTROL_MASK))
        {
            *pfDACLConflict = TRUE;
        }
        else
        {
            *pfDACLConflict = !IsEqualACL(RtlpDaclAddrSecurityDescriptor(pS1),
                                          RtlpDaclAddrSecurityDescriptor(pS2));
        }
    }
}


/*******************************************************************

    NAME:       DPA_CompareSecurityIntersection

    SYNOPSIS:   Determines if the selected objects have
                equivalent security descriptors

    ENTRY:      hItemList - DPA containing item names
                pfnReadSD - callback function to read the Security Descriptor
                                for a single item.
                pfOwnerConflict - (optional) Set to TRUE if not all Owner SIDs are equal
                pfGroupConflict - (optional) Set to TRUE if not all Group SIDs are equal
                pfDACLConflict  - (optional) Set to TRUE if not all DACLs are equal
                pfSACLConflict  - (optional) Set to TRUE if not all SACLs are equal
                ppszOwnerConflict - (optional) The name of the first item
                                with a different Owner is returned here.
                                Free with LocalFreeString.
                ppszGroupConflict - (optional) similar to ppszOwnerConflict
                ppszDaclConflict - (optional) similar to ppszOwnerConflict
                ppszSaclConflict - (optional) similar to ppszOwnerConflict
				ppszFailureMsg - Message to display in case of failure.

    RETURNS:    S_OK if successful, HRESULT error code otherwise

    NOTES:      The function may exit without checking all objects if all of
                the requested flags become FALSE.  All out parameters are
                valid if the function succeeds, and undetermined otherwise.

    HISTORY:
        JeffreyS 18-Feb-1997     Created

********************************************************************/

STDMETHODIMP
DPA_CompareSecurityIntersection(HDPA         hItemList,
                                PFN_READ_SD  pfnReadSD,
                                BOOL        *pfOwnerConflict,
                                BOOL        *pfGroupConflict,
                                BOOL        *pfSACLConflict,
                                BOOL        *pfDACLConflict,
                                LPTSTR      *ppszOwnerConflict,
                                LPTSTR      *ppszGroupConflict,
                                LPTSTR      *ppszSaclConflict,
                                LPTSTR      *ppszDaclConflict,
								LPTSTR		*ppszFailureMsg,
                                LPBOOL       pbCancel)
{
    HRESULT hr = S_OK;
    DWORD dwErr;
    SECURITY_INFORMATION si = 0;
    DWORD dwPriv = SE_SECURITY_PRIVILEGE;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    LPTSTR pszItem;
    LPTSTR pszFile;
    PSECURITY_DESCRIPTOR pSD1 = NULL;
    PSECURITY_DESCRIPTOR pSD2 = NULL;
    int i;

#if DBG
    DWORD dwTimeStart = GetTickCount();
#endif

    TraceEnter(TRACE_UTIL, "DPA_CompareSecurityIntersection");
    TraceAssert(hItemList != NULL);
    TraceAssert(pfnReadSD != NULL);

    if (pfOwnerConflict)
    {
        *pfOwnerConflict = FALSE;
        si |= OWNER_SECURITY_INFORMATION;
    }
    if (pfGroupConflict)
    {
        *pfGroupConflict = FALSE;
        si |= GROUP_SECURITY_INFORMATION;
    }
    if (pfSACLConflict)
    {
        *pfSACLConflict = FALSE;

        // SeAuditPrivilege must be enabled to read the SACL.
        hToken = EnablePrivileges(&dwPriv, 1);
        if (INVALID_HANDLE_VALUE != hToken)
        {
            si |= SACL_SECURITY_INFORMATION;
        }
        else
        {
            // Leave *pfSACLConflict set to FALSE
            pfSACLConflict = NULL;
            TraceMsg("Security privilege not enabled -- not checking SACL");
        }
    }
    if (pfDACLConflict)
    {
        *pfDACLConflict = FALSE;
        si |= DACL_SECURITY_INFORMATION;
    }

    if (ppszOwnerConflict != NULL)
        *ppszOwnerConflict = NULL;
    if (ppszGroupConflict != NULL)
        *ppszGroupConflict = NULL;
    if (ppszSaclConflict != NULL)
        *ppszSaclConflict = NULL;
    if (ppszDaclConflict != NULL)
        *ppszDaclConflict = NULL;

    if (si == 0 || DPA_GetPtrCount(hItemList) < 2)
        ExitGracefully(hr, S_OK, "Nothing requested or list contains only one item");

    if (pbCancel && *pbCancel)
        ExitGracefully(hr, S_OK, "DPA_CompareSecurityIntersection cancelled");

    //
    // Get the first item name and load its security descriptor.
    //
    pszItem = (LPTSTR)DPA_FastGetPtr(hItemList, 0);
    if (NULL == pszItem)
        ExitGracefully(hr, E_UNEXPECTED, "Item list is empty");

    dwErr = (*pfnReadSD)(pszItem, si, &pSD1);
    if (dwErr)
	{
		//Incase of multiple of selection, if we fail to read the security descriptor
		//of single item, security page should be disabled.
		LPTSTR pszSystemError = NULL;
		LPTSTR pszFailureMsg = NULL;
		if (GetSystemErrorText(&pszSystemError, dwErr))
		{
			//often last two chars are \r\n sequence which break our formatting.
			DWORD dwLen = wcslen(pszSystemError);
			if(dwLen >= 2 && pszSystemError[dwLen-2] == 0x0d && pszSystemError[dwLen-1] ==0x0a)
			{
				pszSystemError[dwLen-2] = 0;
			}
			FormatStringID(&pszFailureMsg, g_hInstance, IDS_MULTIPLE_SELECTION_READ_ERROR, pszItem, pszSystemError);
		}
		else
		{
			FormatStringID(&pszFailureMsg, g_hInstance, IDS_MULTIPLE_SELECTION_READ_ERROR_1, pszItem);			
		}

		*ppszFailureMsg = pszFailureMsg;
        ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to read Security Descriptor");
	}

    //
    // Go through the rest of the list and compare their security
    // descriptors to the first one.
    //
    for (i = 1; i < DPA_GetPtrCount(hItemList) && si != 0; i++)
    {
        if (pbCancel && *pbCancel)
            ExitGracefully(hr, S_OK, "DPA_CompareSecurityIntersection cancelled");

        pszItem = (LPTSTR)DPA_FastGetPtr(hItemList, i);
        if (NULL == pszItem)
            ExitGracefully(hr, E_UNEXPECTED, "Unable to retrieve item name from list");

        dwErr = (*pfnReadSD)(pszItem, si, &pSD2);
        if (dwErr)
		{
			//Incase of multiple of selection, if we fail to read the security descriptor
			//of single item, security page should be disabled.
			LPTSTR pszSystemError = NULL;
			LPTSTR pszFailureMsg = NULL;
			if (GetSystemErrorText(&pszSystemError, dwErr))
			{
				//often last two chars are \r\n sequence which break our formatting.
				DWORD dwLen = wcslen(pszSystemError);
				if(dwLen >= 2 && pszSystemError[dwLen-2] == 0x0d && pszSystemError[dwLen-1] ==0x0a)
				{
					pszSystemError[dwLen-2] = 0;
				}
				FormatStringID(&pszFailureMsg, g_hInstance, IDS_MULTIPLE_SELECTION_READ_ERROR, pszItem, pszSystemError);
			}
			else
			{
				FormatStringID(&pszFailureMsg, g_hInstance, IDS_MULTIPLE_SELECTION_READ_ERROR_1, pszItem);			
			}

			*ppszFailureMsg = pszFailureMsg;
			ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to read Security Descriptor");
		}

        CompareSecurityDescriptors(pSD1,
                                   pSD2,
                                   pfOwnerConflict,
                                   pfGroupConflict,
                                   pfSACLConflict,
                                   pfDACLConflict);
        if (pSD2 != NULL)
        {
            LocalFree(pSD2);
            pSD2 = NULL;
        }

        //
        // Get the leaf name of the item to return as the conflict name
        //
        pszFile = PathFindFileName(pszItem);
        if (!pszFile)
            pszFile = pszItem;

        // If we find an owner that doesn't match, we can stop checking owners
        if (pfOwnerConflict && *pfOwnerConflict)
        {
            pfOwnerConflict = NULL;
            si &= ~OWNER_SECURITY_INFORMATION;

            if (ppszOwnerConflict)
                LocalAllocString(ppszOwnerConflict, pszFile);
        }

        // Ditto for the group
        if (pfGroupConflict && *pfGroupConflict)
        {
            pfGroupConflict = NULL;
            si &= ~GROUP_SECURITY_INFORMATION;

            if (ppszGroupConflict)
                LocalAllocString(ppszGroupConflict, pszFile);
        }

        // Same for SACLs
        if (pfSACLConflict && *pfSACLConflict)
        {
            pfSACLConflict = NULL;
            si &= ~SACL_SECURITY_INFORMATION;

            if (ppszSaclConflict)
                LocalAllocString(ppszSaclConflict, pszFile);
        }

        // Same for DACLs
        if (pfDACLConflict && *pfDACLConflict)
        {
            pfDACLConflict = NULL;
            si &= ~DACL_SECURITY_INFORMATION;

            if (ppszDaclConflict)
                LocalAllocString(ppszDaclConflict, pszFile);
        }
    }

exit_gracefully:

    // Release any privileges we enabled
    ReleasePrivileges(hToken);

    if (FAILED(hr))
    {
        LocalFreeString(ppszOwnerConflict);
        LocalFreeString(ppszGroupConflict);
        LocalFreeString(ppszSaclConflict);
        LocalFreeString(ppszDaclConflict);
    }

    if (pSD1 != NULL)
        LocalFree(pSD1);

#if DBG
    Trace((TEXT("DPA_CompareSecurityIntersection done: %d"), GetTickCount() - dwTimeStart));
#endif

    TraceLeaveResult(hr);
}


//*************************************************************
//
//  GetRemotePath
//
//  Purpose:    Return UNC version of a path
//
//  Parameters: pszInName - initial path
//              ppszOutName - UNC path returned here
//
//
//  Return:     HRESULT
//              S_OK - UNC path returned
//              S_FALSE - drive not connected (UNC not returned)
//              or failure code
//
//  Notes:      The function fails is the path is not a valid
//              network path.  If the path is already UNC,
//              a copy is made without validating the path.
//              *ppszOutName must be LocalFree'd by the caller.
//
//*************************************************************

DWORD _WNetGetConnection(LPCTSTR pszLocal, LPTSTR pszRemote, LPDWORD pdwLen)
{
    DWORD dwErr = ERROR_PROC_NOT_FOUND;

    // This is the only function we call in mpr.dll, and it's delay-loaded
    // so wrap it with SEH.
    __try
    {
        dwErr = WNetGetConnection(pszLocal, pszRemote, pdwLen);
    }
    __finally
    {
    }

    return dwErr;
}

STDMETHODIMP
GetRemotePath(LPCTSTR pszInName, LPTSTR *ppszOutName)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

    TraceEnter(TRACE_UTIL, "GetRemotePath");
    TraceAssert(pszInName);
    TraceAssert(ppszOutName);

    *ppszOutName = NULL;

    

    if (pszInName[1] == TEXT(':'))
    {
        DWORD dwErr;
        TCHAR szLocalName[3];
        TCHAR szRemoteName[MAX_PATH];
        DWORD dwLen = ARRAYSIZE(szRemoteName);

        szLocalName[0] = pszInName[0];
        szLocalName[1] = pszInName[1];
        szLocalName[2] = TEXT('\0');

        dwErr = _WNetGetConnection(szLocalName, szRemoteName, &dwLen);

        if (NO_ERROR == dwErr)
        {
            hr = S_OK;
            dwLen = lstrlen(szRemoteName);
        }
        else if (ERROR_NOT_CONNECTED == dwErr)
        {
            ExitGracefully(hr, S_FALSE, "Drive not connected");
        }
        else if (ERROR_MORE_DATA != dwErr)
            ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "WNetGetConnection failed");
        // if dwErr == ERROR_MORE_DATA, dwLen already has the correct value

        // Skip the drive letter and add the length of the rest of the path
        // (including NULL)
        pszInName += 2;
        DWORD dwOutputLen = dwLen + lstrlen(pszInName) + 1;

        // We should never get incomplete paths, so we should always
        // see a backslash after the "X:".  If this isn't true, then
        // we should call GetFullPathName above.
        TraceAssert(TEXT('\\') == *pszInName);

        // Allocate the return buffer
        *ppszOutName = (LPTSTR)LocalAlloc(LPTR, dwOutputLen * SIZEOF(TCHAR));
        if (!*ppszOutName)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

        if (ERROR_MORE_DATA == dwErr)
        {
            // Try again with the bigger buffer
            dwErr = _WNetGetConnection(szLocalName, *ppszOutName, &dwLen);
            hr = HRESULT_FROM_WIN32(dwErr);
            FailGracefully(hr, "WNetGetConnection failed");
        }
        else
        {
            // WNetGetConnection succeeded. Copy the result
            lstrcpy(*ppszOutName, szRemoteName);
        }

        // Copy the rest of the path
        hr = StringCchCat(*ppszOutName,dwOutputLen,pszInName);
    }
    else if (PathIsUNC(pszInName))
    {
        // Just copy the path without validating it
        hr = LocalAllocString(ppszOutName, pszInName);
    }

exit_gracefully:

    if (FAILED(hr))
    {
        LocalFreeString(ppszOutName);
    }
    else
    {
        if(*ppszOutName)
        {
            //Trailing backshash causes IsShareRoot to fail.
            //NTRAID#NTBUG9-533576-2002/05/06-hiteshr
            PathRemoveBackslash(*ppszOutName);
        }
    }


    TraceLeaveResult(hr);
}


/*******************************************************************

    NAME:       LocalFreeDPA

    SYNOPSIS:   LocalFree's all pointers in a Dynamic Pointer
                Array and then frees the DPA.

    ENTRY:      hList - handle of list to destroy

    RETURNS:    nothing

********************************************************************/
int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    if (pVoid)
        LocalFree(pVoid);
    return 1;
}

void
LocalFreeDPA(HDPA hList)
{
    if (hList != NULL)
        DPA_DestroyCallback(hList, _LocalFreeCB, 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSafeMode
//
//  Synopsis:   Checks the registry to see if the system is in safe mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//----------------------------------------------------------------------------

BOOL
IsSafeMode(void)
{
    BOOL    fIsSafeMode = FALSE;
    LONG    ec;
    HKEY    hkey;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        DWORD dwValue;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
                             TEXT("OptionValue"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

        if (ec == NO_ERROR)
        {
            fIsSafeMode = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey(hkey);
    }

    return fIsSafeMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsGuestAccessMode
//
//  Synopsis:   Checks the registry to see if the system is using the
//              Guest-only network access mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Modified and changed name
//
//----------------------------------------------------------------------------

BOOL
IsForcedGuestModeOn(void)
{
    BOOL fIsForcedGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForcedGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        LONG    ec;
        HKEY    hkey;

        // Professional, not in a domain. Check the ForceGuest value.

        ec = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                    0,
                    KEY_QUERY_VALUE,
                    &hkey
                    );

        if (ec == NO_ERROR)
        {
            DWORD dwValue;
            DWORD dwValueSize = sizeof(dwValue);

            ec = RegQueryValueEx(hkey,
                                 TEXT("ForceGuest"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwValue,
                                 &dwValueSize);

            if (ec == NO_ERROR && 1 == dwValue)
            {
                fIsForcedGuestModeOn = TRUE;
            }

            RegCloseKey(hkey);
        }
    }

    return fIsForcedGuestModeOn;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSimpleUI
//
//  Synopsis:   Checks whether to show the simple version of the UI.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Removed CTRL key check
//
//----------------------------------------------------------------------------

BOOL
IsSimpleUI(void)
{
    // Show old UI in safe mode and anytime network access involves
    // true user identity (server, pro with GuestMode off).
    
    // Show simple UI anytime network access is done using the Guest
    // account (personal, pro with GuestMode on) except in safe mode.

    return (!IsSafeMode() && IsForcedGuestModeOn());
}


HRESULT BindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    IShellFolder *psfRelease = NULL;

    if (!psf)
    {
        hr = SHGetDesktopFolder(&psf);
		if(SUCCEEDED(hr))
		{
			psfRelease = psf;
		}
    }

    if (psf)
    {
        if (!pidl || ILIsEmpty(pidl))
        {
            hr = psf->QueryInterface(riid, ppv);
        }
        else
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppv);
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }

    if (psfRelease)
    {
        psfRelease->Release();
    }

    if (SUCCEEDED(hr) && (*ppv == NULL))
    {
        // Some shell extensions (eg WS_FTP) will return success and a null out pointer
        hr = E_FAIL;
    }

    return hr;
}
LPITEMIDLIST ILCloneParent(LPCITEMIDLIST pidl)
{   
    LPITEMIDLIST pidlParent = ILClone(pidl);
    if (pidlParent)
        ILRemoveLastID(pidlParent);

    return pidlParent;
}
// psfRoot is the base of the bind.  If NULL, then we use the shell desktop.
// If you want to bind relative to the explorer root (e.g., CabView, MSN),
// then use SHBindToIDListParent.
HRESULT BindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hr;

    // Old shell32 code in some cases simply whacked the pidl,
    // but this is unsafe.  Do what shdocvw does and clone/remove:
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent) 
    {
        hr = BindToObjectEx(psfRoot, pidlParent, NULL, riid, ppv);
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsUIHiddenByPrivacyPolicy
//
//  Synopsis:   Checks if Security Tab is hidden by privacy policy
//				NTRAID#NTBUG9-223899-2001/03/06-hiteshr
//  History:    06-March-01 hiteshr Created
//
//----------------------------------------------------------------------------

BOOL
IsUIHiddenByPrivacyPolicy(void)
{
    BOOL fIsUIHiddenByPrivacyPolicy = FALSE;
	
	LONG    ec;
    HKEY    hkey = NULL;

    
    ec = RegOpenKeyEx(HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                      0,
                      KEY_QUERY_VALUE,
                      &hkey
                      );

	if (ec == NO_ERROR)
    {
		DWORD dwValue = 0;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
						     TEXT("NoSecurityTab"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

		if (ec == NO_ERROR && 1 == dwValue)
        {
			fIsUIHiddenByPrivacyPolicy = TRUE;
		}

		RegCloseKey(hkey);
	}
	return fIsUIHiddenByPrivacyPolicy;
}

//+----------------------------------------------------------------------------
//  Function:SetAclOnRemoteNetworkDrive   
//  Synopsis: If Z: is a mapped drive( mapped to \\machineA\share), when 
//			  we set DACL/SACL on Z:, Security API's cannot determine
//			  the parent of "share" on machineA and so we lose all the
//			  inherited aces. All UI can do is to detect such cases and
//			  show a warning. Thats what this function does. 
//  Arguments:hItemList List of items on which security is going to be set
//			  si: SECURITY_INFORMATION
//			  pSD: Security Descriptor to be set
//			  hWndPopupOwner: Owner window for message box
//  Returns:    
//-----------------------------------------------------------------------------
BOOL SetAclOnRemoteNetworkDrive(HDPA hItemList,
								SECURITY_INFORMATION si,
								PSECURITY_DESCRIPTOR pSD,
								HWND hWndPopupOwner)
{
	if(!hItemList || !pSD)
	{
		ASSERT(hItemList);
		ASSERT(pSD);
		return FALSE;
	}

	//We care only about DACL and SACL
	if(!(si & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
	{
		return TRUE;
	}

	SECURITY_DESCRIPTOR_CONTROL Control = 0;
	DWORD dwRevision = 0;
	//Check if DACL or SACL is protected
	if(!GetSecurityDescriptorControl(pSD,&Control,&dwRevision))
	{
		return FALSE;
	}

	//If inheritance is prevented for this object,there is no loss of inheritance
	//so we are fine
	if( ((si & DACL_SECURITY_INFORMATION) && (Control & SE_DACL_PROTECTED)) ||
		((si & SACL_SECURITY_INFORMATION) && (Control & SE_SACL_PROTECTED)))
	{
		return TRUE;
	}

    LPTSTR pszPath = (LPTSTR)DPA_FastGetPtr(hItemList, 0);

    int nMsgId = (si & DACL_SECURITY_INFORMATION) ? IDS_SET_PERM_ON_NETWORK_DRIVE : IDS_SET_SACL_ON_NETWORK_DRIVE;
		
	//Ok, this is a remote network drive, display Warning.
	//We display only one warning per list
	if (IDNO == MsgPopup(hWndPopupOwner,
							MAKEINTRESOURCE(nMsgId),
							MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
							MB_YESNO|MB_DEFBUTTON2| MB_ICONWARNING | MB_SETFOREGROUND,
							g_hInstance,
							pszPath))
	{
		return FALSE;
	}

	return TRUE;
}

//+----------------------------------------------------------------------------
//  Function:GetSystemPaths   
//  Synopsis:Extract the value for environment variables SystemDrive
//           and SystemRoot
//-----------------------------------------------------------------------------
void
GetSystemPaths(LPWSTR * ppszSystemDrive,
               LPWSTR * ppszSystemRoot)
{
    static WCHAR szSystemDrive[] = L"%SystemDrive%";
    static WCHAR szSystemRoot[] = L"%SystemRoot%";

    do
    {
        //Get SystemDrive
        DWORD dwLen = ExpandEnvironmentStrings(szSystemDrive,
                                               NULL,
                                               0);
        if(dwLen)
        {
            //dwLen contains space for NULL char. 1 is added for "\".
            //SystemDrive is in format C:, while we want in the format C:"\"
            DWORD dwArrayLen = dwLen + 1;
            *ppszSystemDrive = (LPWSTR)LocalAlloc(LPTR,dwArrayLen*sizeof(WCHAR));
            if(!*ppszSystemDrive)
                break;       

            dwLen = ExpandEnvironmentStrings(szSystemDrive,
                                             *ppszSystemDrive,
                                             dwArrayLen);
            if(!dwLen)
            {
                LocalFree(*ppszSystemDrive);
                *ppszSystemDrive = NULL;
            }
            else
            {
                HRESULT hr = StringCchCat(*ppszSystemDrive,
                                          dwArrayLen,
                                          L"\\");
                if(FAILED(hr))
                {
                    ASSERT(SUCCEEDED(hr));
                    LocalFree(*ppszSystemDrive);
                    *ppszSystemDrive = NULL;
                }
            }                            
        }


        //Get SystemRoot
        dwLen = ExpandEnvironmentStrings(szSystemRoot,
                                         NULL,
                                         0);
        if(dwLen)
        {
            *ppszSystemRoot = (LPWSTR)LocalAlloc(LPTR,dwLen*sizeof(WCHAR));
            if(!*ppszSystemRoot)
                break;       

            dwLen = ExpandEnvironmentStrings(szSystemRoot,
                                             *ppszSystemRoot,
                                             dwLen);
            if(!dwLen)
            {
                ASSERT(dwLen);
                LocalFree(*ppszSystemRoot);
                *ppszSystemRoot = NULL;
            }
        }

    }while(0);
}

//+----------------------------------------------------------------------------
//  Function:SetAclOnSystemPaths   
//  Synopsis:changing acl of SystemDrive or on or under SystemRoot results in
//           problem. This function detects if user is changing acl on these
//           system folder and shows appropriate warning.
//  Returns: TRUE if its fine to set ACL , FALSE if not.
//-----------------------------------------------------------------------------                
BOOL SetAclOnSystemPaths(HDPA hItemList,
						 LPCWSTR pszSystemDrive,
                         LPCWSTR pszSystemRoot,
                         SECURITY_INFORMATION si,
						 HWND hWndPopupOwner)
{
	if(!hItemList)
	{
		ASSERT(hItemList);
		return FALSE;
	}

	//We care only about DACL 
	if(!(si & DACL_SECURITY_INFORMATION))
	{
		return TRUE;
	}

    DWORD dwLenSystemRoot = 0;
    if(pszSystemRoot)
    {
        dwLenSystemRoot = (DWORD)wcslen(pszSystemRoot);
    }

	//Now Check each item in hItemList 
	for (int i = 0; i < DPA_GetPtrCount(hItemList); i++)
    {
        LPTSTR pszPath = (LPTSTR)DPA_FastGetPtr(hItemList, i);

        if(!pszPath)
            continue;

        //Check for system drive
        if(pszSystemDrive && 
           CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT, 
                                       0, 
                                       pszSystemDrive, 
                                       -1, 
                                       pszPath, 
                                       -1))
        {
		    if (IDNO == MsgPopup(hWndPopupOwner,
							     MAKEINTRESOURCE(IDS_ACL_ON_SYSTEMROOT),
							     MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
							     MB_YESNO|MB_DEFBUTTON2| MB_ICONWARNING | MB_SETFOREGROUND,
							     g_hInstance))
		    {
			    return FALSE;
		    }
            break;
        }


        //Check if its under systemroot
        DWORD dwlenPath = wcslen(pszPath);

        if(dwLenSystemRoot && (dwlenPath >= dwLenSystemRoot) && 
           (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT, 
                                       NORM_IGNORECASE, 
                                       pszSystemRoot, 
                                       dwLenSystemRoot, 
                                       pszPath, 
                                       dwLenSystemRoot)))
        {

		    if (IDNO == MsgPopup(hWndPopupOwner,
							     MAKEINTRESOURCE(IDS_ACL_ON_UNDER_SYSTEM_DRIVE),
							     MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
							     MB_YESNO|MB_DEFBUTTON2| MB_ICONWARNING | MB_SETFOREGROUND,
							     g_hInstance))
		    {
			    return FALSE;
		    }
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       util.h
//
//  miscellaneous utility functions
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

STDMETHODIMP
IDA_BindToFolder(LPIDA pIDA, LPSHELLFOLDER *ppsf);

STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR pszName,
                UINT cchName,
                SHGNO uFlags = SHGDN_FORPARSING);
STDMETHODIMP
IDA_GetItemName(LPSHELLFOLDER psf,
                LPCITEMIDLIST pidl,
                LPTSTR *ppszName,
                SHGNO uFlags = SHGDN_FORPARSING);

typedef DWORD (WINAPI *PFN_READ_SD)(LPCTSTR pszItemName,
                                    SECURITY_INFORMATION si,
                                    PSECURITY_DESCRIPTOR* ppSD);

STDMETHODIMP
DPA_CompareSecurityIntersection(HDPA         hItemList,
                                PFN_READ_SD  pfnReadSD,
                                BOOL        *pfOwnerConflict,
                                BOOL        *pfGroupConflict,
                                BOOL        *pfSACLConflict,
                                BOOL        *pfDACLConflict,
                                LPTSTR      *ppszOwnerConflict,
                                LPTSTR      *ppszGroupConflict,
                                LPTSTR      *ppszSaclConflict,
                                LPTSTR      *ppszDaclConflict,
								LPTSTR		*ppszFailureMsg,
                                LPBOOL       pbCancel);

STDMETHODIMP
GetRemotePath(LPCTSTR pszInName, LPTSTR *ppszOutName);

void
LocalFreeDPA(HDPA hList);

BOOL
IsSafeMode(void);

BOOL
IsGuestAccessMode(void);

BOOL
IsSimpleUI(void);

BOOL 
IsUIHiddenByPrivacyPolicy(void);

HRESULT BindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
HRESULT BindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);
BOOL SetAclOnRemoteNetworkDrive(HDPA hItemList,
								SECURITY_INFORMATION si,
								PSECURITY_DESCRIPTOR pSD,
								HWND hWndPopupOwner);

void
GetSystemPaths(LPWSTR * ppszSystemDrive,
               LPWSTR * ppszSystemRoot);

BOOL SetAclOnSystemPaths(HDPA hItemList,
						 LPCWSTR pszSystemDrive,
                         LPCWSTR pszSystemRoot,
                         SECURITY_INFORMATION si,
						 HWND hWndPopupOwner);

#endif  /* _UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\ctv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctv.cpp
//
//--------------------------------------------------------------------------

// ctv.cpp : Implementation of CCtvApp and DLL registration.

#include "stdafx.h"
#include "ctv.h"

CCtvApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
        { 0xcd6c7865, 0x5864, 0x11d0, { 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CCtvApp::InitInstance - DLL initialization
BOOL CCtvApp::InitInstance()
{
    BOOL bInit = COleControlModule::InitInstance();

    return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CCtvApp::ExitInstance - DLL termination
int CCtvApp::ExitInstance()
{
    return COleControlModule::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ctv.rc
//
#define IDS_TV                          1
#define IDB_TV                          1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\inc\tvintf.h ===
#ifndef __TVINTF_H_
#define __TVINTF_H_
/*++

Copyright (c) Microsoft Corporation

Module Name:

    tvintf.h

Abstract:

    header file to define interfaces between Device Manager snapin
    and TreeView OCX.

Author:

    William Hsieh (williamh) created

Revision History:


--*/


// Interface designed for snapin to connect/disconnect, control, retreive
// information to/from the Tree view ocx.
class IDMTVOCX : public IUnknown
{
    public: virtual HTREEITEM InsertItem(LPTV_INSERTSTRUCT pis) = 0;
    public: virtual HRESULT DeleteItem(HTREEITEM hItem) = 0;
    public: virtual HRESULT DeleteAllItems() = 0;
    public: virtual HIMAGELIST SetImageList(INT iImage, HIMAGELIST himl) = 0;
    public: virtual HRESULT SetItem(TV_ITEM* pitem) = 0;
    public: virtual HRESULT Expand(UINT Flags, HTREEITEM htiem) = 0;
    public: virtual HRESULT SelectItem(UINT Flags, HTREEITEM hitem) = 0;
    public: virtual HRESULT SetStyle(DWORD dwStyle) = 0;
    public: virtual HWND    GetWindowHandle() = 0;
    public: virtual HRESULT GetItem(TV_ITEM* pti) = 0;
    public: virtual HTREEITEM GetNextItem(UINT Flags, HTREEITEM htiRef) = 0;
    public: virtual HRESULT SelectItem(HTREEITEM hti) = 0;
    public: virtual UINT    GetCount() = 0;
    public: virtual HTREEITEM GetSelectedItem() = 0;
    public: virtual HRESULT Connect(IComponent* pIComponent, MMC_COOKIE cookie) = 0;
    public: virtual HRESULT SetActiveConnection(MMC_COOKIE cookie) = 0;
    public: virtual MMC_COOKIE	  GetActiveConnection() = 0;
    public: virtual HRESULT SetRedraw(BOOL Redraw) = 0;
    public: virtual BOOL    EnsureVisible(HTREEITEM hitem) = 0;
};


typedef enum tagTvNotifyCode
{
    TV_NOTIFY_CODE_CLICK = 0,
    TV_NOTIFY_CODE_DBLCLK,
    TV_NOTIFY_CODE_RCLICK,
    TV_NOTIFY_CODE_RDBLCLK,
    TV_NOTIFY_CODE_KEYDOWN,
    TV_NOTIFY_CODE_CONTEXTMENU,
    TV_NOTIFY_CODE_EXPANDING,
    TV_NOTIFY_CODE_EXPANDED,
    TV_NOTIFY_CODE_SELCHANGING,
    TV_NOTIFY_CODE_SELCHANGED,
    TV_NOTIFY_CODE_GETDISPINFO,
    TV_NOTIFY_CODE_FOCUSCHANGED,
    TV_NOTIFY_CODE_UNKNOWN
} TV_NOTIFY_CODE, *PTV_NOTIFY_CODE;

// interface DECLSPEC_UUID("8e0ba98a-d161-11d0-8353-00a0c90640bf")
class ISnapinCallback : public IUnknown
{
public:
virtual HRESULT STDMETHODCALLTYPE tvNotify(HWND hwndTV, MMC_COOKIE cookie,
					   TV_NOTIFY_CODE Code,
					   LPARAM arg, LPARAM param) = 0;
};

extern const IID IID_ISnapinCallback;
extern const IID IID_IDMTVOCX;

template<class ISome>
class SafeInterfacePtr
{
public:
    SafeInterfacePtr(ISome* pInterface = NULL)
    {
    	m_pISome = pInterface;
    	if (m_pISome)
    	    m_pISome->AddRef();
    }
    ~SafeInterfacePtr()
    {
    	SafeRelease();
    }
    void SafeRelease()
    {
    	if (m_pISome)
    	{
    	    m_pISome->Release();
    	    m_pISome = NULL;
    	}
    }
    void Attach(ISome* pInterface)
    {
    	ASSERT(!m_pISome);
    	ASSERT(pInterface);
    	m_pISome = pInterface;
    	m_pISome->AddRef();
    }
    void Detach()
    {
    	ASSERT(m_pISome);
    	m_pISome->Release();
    	m_pISome = NULL;
    }
    ISome* operator->()
    {
    	return m_pISome;
    }
    ISome& operator*()
    {
	    return *m_pISome;
    }
    operator ISome*()
    {
    	return m_pISome;
    }
    ISome ** operator&()
    {
	    return &m_pISome;
    }

private:
    ISome*  m_pISome;
};


#endif	//__TVINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\ctvctl.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    ctvctl.h

Abstract:

    header file for ctvctl.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "..\inc\tvintf.h"

// CTVCtl.h : Declaration of the CTVCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl : See CTVCtl.cpp for implementation.

class CTVCtrl : public COleControl
{
        DECLARE_DYNCREATE(CTVCtrl)

// Constructor
public:
        CTVCtrl();

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CTVCtrl)
        public:
        virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
        virtual void DoPropExchange(CPropExchange* pPX);
        virtual void OnResetState();
        virtual BOOL PreTranslateMessage(MSG* pMsg);
        //}}AFX_VIRTUAL

// Implementation
protected:
        ~CTVCtrl();

        DECLARE_OLECREATE_EX(CTVCtrl)    // Class factory and guid
        DECLARE_OLETYPELIB(CTVCtrl)      // GetTypeInfo
        DECLARE_OLECTLTYPE(CTVCtrl)      // Type name and misc status

        // Subclassed control support
        BOOL PreCreateWindow(CREATESTRUCT& cs);
        BOOL IsSubclassedControl();
        LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
        //{{AFX_MSG(CTVCtrl)
        afx_msg void OnDestroy();
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG
        afx_msg LRESULT OnOcmNotify(WPARAM wParam, LPARAM lParam);
        DECLARE_MESSAGE_MAP()

// Dispatch maps
        //{{AFX_DISPATCH(CTVCtrl)
        //}}AFX_DISPATCH
        DECLARE_DISPATCH_MAP()

// Event maps
        //{{AFX_EVENT(CTVCtrl)
        //}}AFX_EVENT
        DECLARE_EVENT_MAP()

protected:
        DECLARE_INTERFACE_MAP()
        BEGIN_INTERFACE_PART(DMTVOCX, IDMTVOCX)
            public: virtual HTREEITEM InsertItem(LPTV_INSERTSTRUCT pis);
            public: virtual HRESULT DeleteItem(HTREEITEM hItem);
            public: virtual HRESULT DeleteAllItems();
            public: virtual HIMAGELIST SetImageList(INT iImage, HIMAGELIST himl);
            public: virtual HRESULT SetItem(TV_ITEM* pitem);
            public: virtual HRESULT Expand(UINT Flags, HTREEITEM htiem);
            public: virtual HRESULT SelectItem(UINT Flags, HTREEITEM hitem);
            public: virtual HRESULT SetStyle(DWORD dwStyle);
            public: virtual HWND    GetWindowHandle();
            public: virtual HRESULT GetItem(TV_ITEM* pti);
            public: virtual HTREEITEM GetNextItem(UINT Flags, HTREEITEM htiRef);
            public: virtual HRESULT SelectItem(HTREEITEM hti);
            public: virtual UINT    GetCount();
            public: virtual HTREEITEM GetSelectedItem();
            public: virtual HRESULT Connect(IComponent* pIComponent, MMC_COOKIE);
            public: virtual HRESULT SetActiveConnection(MMC_COOKIE cookie);
            public: virtual MMC_COOKIE    GetActiveConnection();
            public: virtual HRESULT SetRedraw(BOOL Redraw);
            public: virtual BOOL    EnsureVisible(HTREEITEM hitem);
        END_INTERFACE_PART(DMTVOCX)

private:
        HTREEITEM InsertItem(LPTV_INSERTSTRUCT pis);
        HRESULT DeleteItem(HTREEITEM hItem);
        HRESULT DeleteAllItems();
        HIMAGELIST SetImageList(INT iImage, HIMAGELIST himl);
        HRESULT SetItem(TV_ITEM* pitem);
        HRESULT Expand(UINT Flags, HTREEITEM htiem);
        HRESULT SelectItem(UINT Flags, HTREEITEM hitem);
        HRESULT SetStyle(DWORD dwStyle);
        HWND    GetWindowHandle();
        HRESULT GetItem(TV_ITEM* pti);
        HTREEITEM GetNextItem(UINT Flags, HTREEITEM htiRef);
        HRESULT SelectItem(HTREEITEM hti);
        UINT    GetCount();
        HTREEITEM HitTest(LONG x, LONG y, UINT* phtFlags);
        HTREEITEM GetSelectedItem();
        HRESULT Connect(IComponent* pIComponent, MMC_COOKIE cookie);
        HRESULT SetActiveConnection(MMC_COOKIE cookie);
        MMC_COOKIE      GetActiveConnection();
        HRESULT SetRedraw(BOOL Redraw);
        BOOL    EnsureVisible(HTREEITEM hitem);
        TV_NOTIFY_CODE DoMouseNotification(UINT code, MMC_COOKIE* pcookie,LPARAM* parg, LPARAM* param);

// private data
        MMC_COOKIE      m_ActiveCookie;
        int     m_nConnections;
        BOOL    m_HasFocus;
        IComponent* m_pIComponent;
        ISnapinCallback* m_pISnapinCallback;
        BOOL    m_Destroyed;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\ctvctl.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    ctvctl.cpp

Abstract:

    This module implements TreeView OCX for Device Manager snapin

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// CTVCtl.cpp : Implementation of the CTVCtrl OLE control class.
#include "stdafx.h"
#include <afxcmn.h>
#include "ctv.h"
#include "CTVCtl.h"
#include "resource.h"

#define GET_X_LPARAM(lParam) (int)(short)LOWORD(lParam)
#define GET_Y_LPARAM(lParam) (int)(short)HIWORD(lParam)

IMPLEMENT_DYNCREATE(CTVCtrl, COleControl)

BEGIN_INTERFACE_MAP(CTVCtrl, COleControl)
INTERFACE_PART(CTVCtrl, IID_IDMTVOCX, DMTVOCX)
END_INTERFACE_MAP()


const IID IID_IDMTVOCX = {0x142525f2,0x59d8,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}};
const IID IID_ISnapinCallback = {0x8e0ba98a,0xd161,0x11d0,{0x83,0x53,0x00,0xa0,0xc9,0x06,0x40,0xbf}};



ULONG EXPORT CTVCtrl::XDMTVOCX::AddRef()
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->ExternalAddRef();
}
ULONG EXPORT CTVCtrl::XDMTVOCX::Release()
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->ExternalRelease();
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::QueryInterface(
                                                REFIID iid,
                                                void ** ppvObj
                                                )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->ExternalQueryInterface(&iid, ppvObj);
}

HTREEITEM EXPORT CTVCtrl::XDMTVOCX::InsertItem(
                                              LPTV_INSERTSTRUCT pis
                                              )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->InsertItem(pis);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::DeleteItem(
                                            HTREEITEM hitem
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->DeleteItem(hitem);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::DeleteAllItems(
                                                )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->DeleteAllItems();
}

HIMAGELIST EXPORT CTVCtrl::XDMTVOCX::SetImageList(
                                                 INT iImage,
                                                 HIMAGELIST himl
                                                 )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetImageList(iImage, himl);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::SetItem(
                                         TV_ITEM* pitem
                                         )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetItem(pitem);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::Expand(
                                        UINT Flags,
                                        HTREEITEM hitem
                                        )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->Expand(Flags, hitem);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::SelectItem(
                                            UINT Flags,
                                            HTREEITEM hitem
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SelectItem(Flags, hitem);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::SetStyle(
                                          DWORD dwStyle
                                          )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetStyle(dwStyle);
}

HWND EXPORT CTVCtrl::XDMTVOCX::GetWindowHandle(
                                              )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetWindowHandle();
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::GetItem(
                                         TV_ITEM* pti
                                         )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetItem(pti);
}

HTREEITEM EXPORT CTVCtrl::XDMTVOCX::GetNextItem(
                                               UINT Flags,
                                               HTREEITEM htiRef
                                               )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetNextItem(Flags, htiRef);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::SelectItem(
                                            HTREEITEM hti
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SelectItem(hti);
}

UINT EXPORT CTVCtrl::XDMTVOCX::GetCount(
                                       )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetCount();
}

HTREEITEM EXPORT CTVCtrl::XDMTVOCX::GetSelectedItem(
                                                   )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetSelectedItem();
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::Connect(
                                         IComponent* pIComponent,
                                         MMC_COOKIE  cookie
                                         )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->Connect(pIComponent, cookie);
}

HRESULT EXPORT CTVCtrl::XDMTVOCX::SetActiveConnection(
                                                     MMC_COOKIE cookie
                                                     )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetActiveConnection(cookie);
}

MMC_COOKIE EXPORT CTVCtrl::XDMTVOCX::GetActiveConnection()
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->GetActiveConnection();
}

long EXPORT CTVCtrl::XDMTVOCX::SetRedraw(BOOL Redraw)
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->SetRedraw(Redraw);
}

BOOL EXPORT CTVCtrl::XDMTVOCX::EnsureVisible(
                                            HTREEITEM hitem
                                            )
{
    METHOD_PROLOGUE(CTVCtrl, DMTVOCX)
    return pThis->EnsureVisible(hitem);
}


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTVCtrl, COleControl)
//{{AFX_MSG_MAP(CTVCtrl)
ON_WM_DESTROY()
ON_WM_CONTEXTMENU()
//}}AFX_MSG_MAP
ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
ON_MESSAGE(OCM_NOTIFY, OnOcmNotify)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CTVCtrl, COleControl)
//{{AFX_DISPATCH_MAP(CTVCtrl)
//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CTVCtrl, COleControl)
//{{AFX_EVENT_MAP(CTVCtrl)
// NOTE - ClassWizard will add and remove event map entries
//    DO NOT EDIT what you see in these blocks of generated code !
//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CTVCtrl, "CTREEVIEW.CTreeViewCtrl.1",
                       0xcd6c7868, 0x5864, 0x11d0, 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CTVCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DTV =
{ 0xcd6c7866, 0x5864, 0x11d0, { 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a}};
const IID BASED_CODE IID_DTVEvents =
{ 0xcd6c7867, 0x5864, 0x11d0, { 0xab, 0xf0, 0, 0x20, 0xaf, 0x6b, 0xb, 0x7a}};


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwTVOleMisc =
OLEMISC_ACTIVATEWHENVISIBLE |
OLEMISC_SETCLIENTSITEFIRST |
OLEMISC_INSIDEOUT |
OLEMISC_CANTLINKINSIDE |
OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CTVCtrl, IDS_TV, _dwTVOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::CTVCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CTVCtrl
BOOL CTVCtrl::CTVCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister) {
        return AfxOleRegisterControlClass(
                                         AfxGetInstanceHandle(),
                                         m_clsid,
                                         m_lpszProgID,
                                         IDS_TV,
                                         IDB_TV,
                                         afxRegApartmentThreading,
                                         _dwTVOleMisc,
                                         _tlid,
                                         _wVerMajor,
                                         _wVerMinor);
    } else {
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::CTVCtrl - Constructor
CTVCtrl::CTVCtrl()
{
    InitializeIIDs(&IID_DTV, &IID_DTVEvents);

    m_nConnections = 0;
    m_pIComponent =  NULL;
    m_pISnapinCallback = NULL;
    m_Destroyed = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::~CTVCtrl - Destructor
CTVCtrl::~CTVCtrl()
{
    if (m_pISnapinCallback) {
        m_pISnapinCallback->Release();
    }

    if (m_pIComponent) {
        m_pIComponent->Release();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::OnDraw - Drawing function
void CTVCtrl::OnDraw(
                    CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
    DoSuperclassPaint(pdc, rcBounds);
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::DoPropExchange - Persistence support
void CTVCtrl::DoPropExchange(CPropExchange* pPX)
{
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::OnResetState - Reset control to default state
void CTVCtrl::OnResetState()
{
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::PreCreateWindow - Modify parameters for CreateWindowEx
BOOL CTVCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.lpszClass = _T("SysTreeView32");
    
    //
    // Turn off WS_EX_NOPARENTNOTIFY style bit so that our parents
    // receive mouse clicks on our window. I do not know why MFC
    // fundation class turns this on for an OCX.
    //
    cs.dwExStyle &= ~(WS_EX_NOPARENTNOTIFY);
    
    return COleControl::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::IsSubclassedControl - This is a subclassed control
BOOL CTVCtrl::IsSubclassedControl()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CTVCtrl::OnOcmCommand - Handle command messages
LRESULT CTVCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTVCtrl message handlers



///////////////////////////////////////////////////////////////////////
///
/// Tree View functions
///
HRESULT
CTVCtrl::Connect(
                IComponent* pIComponent,
                MMC_COOKIE cookie
                )
{
    HRESULT hr = S_OK;

    if (0 == m_nConnections) {
        ASSERT(NULL == m_pIComponent);

        m_pIComponent  = pIComponent;
        m_pIComponent->AddRef();
        hr = m_pIComponent->QueryInterface(IID_ISnapinCallback,
                                           reinterpret_cast<void**>(&m_pISnapinCallback)
                                          );
    }

    // A single snapin may have multiple nodes that uses us as result pane
    // display media, therefore, we may be connected mutlple times.
    // However, we get created only when MMC creates a new snapin instance.
    // This means, every connection call must provide the same
    // pIComponent and pConsole.
    //
    ASSERT(m_pIComponent == pIComponent);

    if (SUCCEEDED(hr)) {
        m_nConnections++;
        hr = SetActiveConnection(cookie);
    }
    
    return hr;
}

HRESULT
CTVCtrl::SetActiveConnection(
                            MMC_COOKIE cookie
                            )
{
    m_ActiveCookie = cookie;
    return S_OK;
}

MMC_COOKIE
CTVCtrl::GetActiveConnection()
{
    return m_ActiveCookie;
}

HTREEITEM CTVCtrl::InsertItem(
                             LPTV_INSERTSTRUCT pis
                             )
{
    return (HTREEITEM)SendMessage(TVM_INSERTITEM, 0, (LPARAM)pis);
}

HRESULT CTVCtrl::DeleteItem(
                           HTREEITEM hitem
                           )
{
    if (SendMessage(TVM_DELETEITEM, 0, (LPARAM)hitem)) {
        return S_OK;
    } else {
        return E_UNEXPECTED;
    }
}

HRESULT CTVCtrl::DeleteAllItems()
{
    return DeleteItem((HTREEITEM)TVI_ROOT);
}

HIMAGELIST CTVCtrl::SetImageList(
                                INT iImage,
                                HIMAGELIST hmil
                                )
{
    return (HIMAGELIST)SendMessage(TVM_SETIMAGELIST, (WPARAM)iImage, (LPARAM)hmil);
}

HRESULT CTVCtrl::SetItem(
                        TV_ITEM* pitem
                        )
{
    if (SendMessage(TVM_SETITEM, 0, (LPARAM)pitem)) {
        return S_OK;
    } else {
        return E_UNEXPECTED;
    }
}

HRESULT CTVCtrl::Expand(
                       UINT Flags,
                       HTREEITEM hitem
                       )
{
    if (SendMessage(TVM_EXPAND, (WPARAM) Flags, (LPARAM)hitem)) {
        return S_OK;
    } else {
        return E_UNEXPECTED;
    }
}

HRESULT CTVCtrl::SelectItem(
                           UINT Flags,
                           HTREEITEM hitem
                           )
{
    if (SendMessage(TVM_SELECTITEM, (WPARAM)Flags, (LPARAM)hitem)) {
        return S_OK;
    } else {
        return E_UNEXPECTED;
    }
}

HRESULT CTVCtrl::SetStyle(
                         DWORD dwStyle
                         )
{
    if (ModifyStyle(0, dwStyle)) {
        return S_OK;
    } else {
        return E_UNEXPECTED;
    }
}

HWND CTVCtrl::GetWindowHandle(
                             )
{
    return m_hWnd;
}


HRESULT CTVCtrl::GetItem(
                        TV_ITEM* pti
                        )
{
    if (SendMessage(TVM_GETITEM, 0, (LPARAM)pti)) {
        return S_OK;
    } else {
        return E_UNEXPECTED;
    }
}

HTREEITEM CTVCtrl::GetNextItem(
                              UINT Flags,
                              HTREEITEM htiRef
                              )
{
    return (HTREEITEM) SendMessage(TVM_GETNEXTITEM, (WPARAM)Flags, (LPARAM)htiRef);
}

HRESULT CTVCtrl::SelectItem(
                           HTREEITEM hti
                           )
{
    if (SendMessage(TVM_SELECTITEM, 0, (LPARAM) hti)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

UINT CTVCtrl::GetCount(
                      )
{
    return (UINT)SendMessage(TVM_GETCOUNT, 0, 0);
}

HTREEITEM CTVCtrl::HitTest(
                          LONG x,
                          LONG y,
                          UINT* pFlags
                          )
{
    POINT pt;
    pt.x = x;
    pt.y = y;

    ScreenToClient(&pt);

    TV_HITTESTINFO tvhti;
    tvhti.pt = pt;

    HTREEITEM hti = (HTREEITEM)SendMessage(TVM_HITTEST, 0, (LPARAM)&tvhti);

    if (hti && pFlags) {
        *pFlags = tvhti.flags;
    }

    return hti;
}

HTREEITEM CTVCtrl::GetSelectedItem(
                                  )
{
    return (HTREEITEM)SendMessage(TVM_GETNEXTITEM, TVGN_CARET, 0);
}

HRESULT CTVCtrl::SetRedraw(
                          BOOL Redraw
                          )
{
    if (Redraw) {
        Invalidate();
    }

    return S_OK;
}

BOOL CTVCtrl::EnsureVisible(
                           HTREEITEM hitem
                           )
{
    return (BOOL)SendMessage(TVM_ENSUREVISIBLE, 0, (LPARAM)hitem);
}

LRESULT
CTVCtrl::OnOcmNotify(
                    WPARAM wParam,
                    LPARAM lParam
                    )
{

    LPARAM param, arg;
    MMC_COOKIE cookie = 0;

    HRESULT hr = S_FALSE;
    TV_NOTIFY_CODE NotifyCode;
    TV_ITEM TI;

    NotifyCode = TV_NOTIFY_CODE_UNKNOWN;
    
    switch (((NMHDR*)lParam)->code) {
    
    case NM_RCLICK:
    case NM_RDBLCLK:
    case NM_CLICK:
    case NM_DBLCLK:
        NotifyCode = DoMouseNotification(((NMHDR*)lParam)->code, &cookie,
                                         &arg, &param);
        break;
    
    case TVN_KEYDOWN:
        TI.hItem = GetSelectedItem();
        TI.mask = TVIF_PARAM;
        if (TI.hItem && SUCCEEDED(GetItem(&TI))) {
            cookie = (MMC_COOKIE)TI.lParam;
            NotifyCode = TV_NOTIFY_CODE_KEYDOWN;
            param = ((TV_KEYDOWN*)lParam)->wVKey;
            arg = (LPARAM)TI.hItem;
        }
        break;
    
    case NM_SETFOCUS:
        TI.hItem = GetSelectedItem();
        TI.mask = TVIF_PARAM;
        if (TI.hItem && SUCCEEDED(GetItem(&TI))) {
            cookie = (MMC_COOKIE)TI.lParam;
            NotifyCode = TV_NOTIFY_CODE_FOCUSCHANGED;
            param = 1;
            arg = (LPARAM)TI.hItem;
        }
        break;
    
    case TVN_SELCHANGEDA:
    case TVN_SELCHANGEDW:
        NotifyCode = TV_NOTIFY_CODE_SELCHANGED;
        arg = (LPARAM)((NM_TREEVIEW*)lParam)->itemNew.hItem;
        cookie = (MMC_COOKIE)((NM_TREEVIEW*)lParam)->itemNew.lParam;
        param = (LPARAM)((NM_TREEVIEW*)lParam)->action;
        break;
    
    case TVN_ITEMEXPANDEDA:
    case TVN_ITEMEXPANDEDW:
        NotifyCode = TV_NOTIFY_CODE_EXPANDED;
        arg = (LPARAM)((NM_TREEVIEW*)lParam)->itemNew.hItem;
        cookie = (MMC_COOKIE)((NM_TREEVIEW*)lParam)->itemNew.lParam;
        param = (LPARAM)((NM_TREEVIEW*)lParam)->action;
        break;

    default:
        NotifyCode = TV_NOTIFY_CODE_UNKNOWN;
        break;
    }

    if (TV_NOTIFY_CODE_UNKNOWN != NotifyCode && m_pISnapinCallback) {
        
        hr = m_pISnapinCallback->tvNotify(*this, cookie, NotifyCode, arg, param);
        
        if (S_FALSE == hr) {
            //
            // Translate RCLICK to context menu
            //
            if (TV_NOTIFY_CODE_RCLICK == NotifyCode) {
                
                SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, GetMessagePos());
                hr = S_OK;
            }

            //
            // Translate Shift-F10 or VK_APPS to context menu 
            //
            else if (TV_NOTIFY_CODE_KEYDOWN == NotifyCode && 
                     (VK_F10 == param && GetKeyState(VK_SHIFT) < 0) ||
                     (VK_APPS == param)) {
                
                RECT rect;
                *((HTREEITEM*)&rect) = (HTREEITEM)arg;
                
                if (SendMessage(TVM_GETITEMRECT, TRUE, (LPARAM)&rect)) {
                    
                    POINT pt;
                    pt.x = (rect.left + rect.right) / 2;
                    pt.y = (rect.top + rect.bottom) / 2;
                    ClientToScreen(&pt);
                    SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
                    hr = S_OK;
                }
            }
        }
    }

    //
    // On a TVN_KEYDOWN we should always return 0, otherwise the treeview
    // control gets confused.
    //
    if (((NMHDR*)lParam)->code == TVN_KEYDOWN) {

        hr = S_FALSE;
    }

    ASSERT(S_OK == hr || S_FALSE == hr);

    if (S_OK == hr) {
        
        return 1;
    }

    return 0;
}

TV_NOTIFY_CODE
CTVCtrl::DoMouseNotification(
                            UINT Code,
                            MMC_COOKIE* pcookie,
                            LPARAM* parg,
                            LPARAM* pparam
                            )
{
    DWORD MsgPos;
    POINT point;

    ASSERT(pparam && parg && pcookie);
    *pparam = 0;
    *parg = 0;
    MsgPos = GetMessagePos();
    point.x = GET_X_LPARAM(MsgPos);
    point.y = GET_Y_LPARAM(MsgPos);
    UINT htFlags;
    HTREEITEM hti = HitTest(point.x, point.y, &htFlags);

    TV_NOTIFY_CODE NotifyCode = TV_NOTIFY_CODE_UNKNOWN;

    if (hti && (htFlags & TVHT_ONITEM)) {
        
        TV_ITEM TI;
        TI.hItem = hti;
        TI.mask = TVIF_PARAM;

        if (SUCCEEDED(GetItem(&TI))) {
            
            switch (Code) {
            
            case NM_RCLICK:
                NotifyCode = TV_NOTIFY_CODE_RCLICK;
                break;
            
            case NM_RDBLCLK:
                NotifyCode = TV_NOTIFY_CODE_RDBLCLK;
                break;
            
            case NM_CLICK:
                NotifyCode = TV_NOTIFY_CODE_CLICK;
                break;
            
            case NM_DBLCLK:
                NotifyCode = TV_NOTIFY_CODE_DBLCLK;
                break;
            
            default:
                NotifyCode = TV_NOTIFY_CODE_UNKNOWN;
                break;
            }

            if (TV_NOTIFY_CODE_UNKNOWN != NotifyCode) {
                
                *parg = (LPARAM)hti;
                *pparam = htFlags;
                *pcookie = (MMC_COOKIE)TI.lParam;
            }
        }
    }

    return NotifyCode;
}

// OnDestroy may be called on two occasions:
// (1). We are the current active result pane window and MMC
//      is destroying our parent window(MDI client). Note that
//      if we are not the active result pane window, this function
//      will not get called until (2).
// (2). our reference count has reached zero.
//
//  When (1) happens, the snapin may be still holding reference to us
//  thus, even though our window has been destroyed (2) still happens
//  (unless PostNcDestory is done which MFC reset m_hWnd)and we end up
//  destoying the window twice.
//  So, we keep an eye on OnDestroy and do nothing after it has been called.
//  We can not wait for PostNcDestroy because we have no idea when it would
//  come.
//
void CTVCtrl::OnDestroy()
{
    if (!m_Destroyed) {
        COleControl::OnDestroy();
        m_Destroyed = TRUE;
    }
}

void CTVCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
{
    POINT pt = point;
    UINT htFlags;
    HTREEITEM hti = HitTest(pt.x, pt.y, &htFlags);

    if (hti) {
        TV_ITEM TI;
        TI.hItem = hti;
        TI.mask = TVIF_PARAM;
        if (SUCCEEDED(GetItem(&TI))) {
            m_pISnapinCallback->tvNotify(*this, (MMC_COOKIE)TI.lParam,
                                         TV_NOTIFY_CODE_CONTEXTMENU,
                                         (LPARAM)hti, (LPARAM)&point );
        }
    }
}

// The upmost frame window may have its own accelerator table and may take
// away certain key combinations we really need.
BOOL CTVCtrl::PreTranslateMessage(MSG* pMsg)
{
    if (WM_KEYDOWN == pMsg->message &&
        (VK_DELETE == pMsg->wParam ||
         VK_RETURN == pMsg->wParam)) {
        OnKeyDown((UINT)pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));
        return TRUE;
    }

    else if (WM_SYSKEYDOWN == pMsg->message && VK_F10 == pMsg->wParam &&
             GetKeyState(VK_SHIFT) < 0) {
        // Shift-F10 will be translated to WM_CONTEXTMENU
        OnSysKeyDown((UINT)pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));
        return TRUE;
    }

    return COleControl::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\ctv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       ctv.h
//
//--------------------------------------------------------------------------

// ctv.h : main header file for CTV.DLL

#if !defined( __AFXCTL_H__ )
    #error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCtvApp : See ctv.cpp for implementation.

class CCtvApp : public COleControlModule
{
public:
    BOOL InitInstance();
    int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls
#include <mmc.h>

extern const IID IID_ITreeViewPrivate;
extern const IID IID_IMMCSnapin;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\ocx\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\ccookie.h ===
#ifndef __CCOOKIE__H__
#define __CCOOKIE_H__
/*++

Copyright (C) Microsoft Corporation

Module Name:

    ccookie.h

Abstract:

    definition and implementation for CCookie class

Author:

    William Hsieh (williamh) created

Revision History:


--*/



class CCookie;
class CResultItem;
class CScopeItem;

class CCookie
{
public:
    CCookie(COOKIE_TYPE ct)
    : m_pScopeItem(NULL), m_pResultItem(NULL), m_Type(ct),
      m_pChild(NULL), m_pSibling(NULL), m_pParent(NULL),
      m_Flags(0), m_lParam(0)
      {
      }

    ~CCookie()
    {
        //
        // Delete the subtree
        //
        if (m_pChild) {
            delete m_pChild;
        }
        
        if (m_pSibling) {
            delete m_pSibling;
        }
    }
    void SetScopeItem(CScopeItem* pScopeItem)
    {
        //
        // Can only set it onece or memory leak could occur
        //
        ASSERT(NULL == m_pScopeItem);
        m_pScopeItem = pScopeItem;
    }
    void SetResultItem(CResultItem* pResultItem)
    {
        //
        // Can only set once or memory leak could occur
        //
        ASSERT(NULL == m_pResultItem);
        m_pResultItem = pResultItem;
    }
    COOKIE_TYPE GetType()
    {
        return m_Type;
    }
    CScopeItem* GetScopeItem()
    {
        return m_pScopeItem;
    }
    CResultItem* GetResultItem()
    {
        return m_pResultItem;
    }
    CCookie* GetChild()
    {
        return m_pChild;
    }
    CCookie* GetSibling()
    {
        return m_pSibling;
    }
    CCookie* GetParent()
    {
        return m_pParent;
    }
    void SetChild(CCookie* pCookie)
    {
        m_pChild = pCookie;
    }
    void SetSibling(CCookie* pCookie)
    {
        m_pSibling = pCookie;
    }
    void SetParent(CCookie* pCookie)
    {
        m_pParent = pCookie;
    }
    BOOL IsScopeItem()
    {
        return (!m_pResultItem && m_pScopeItem);
    }
    DWORD IsFlagsOn(DWORD Flags)
    {
        return (m_Flags & Flags);
    }
    void TurnOnFlags(DWORD Flags)
    {
        m_Flags |= Flags;
    }
    void TurnOffFlags(DWORD Flags)
    {
        m_Flags &= ~Flags;
    }
    LPARAM      m_lParam;

private:
    COOKIE_TYPE     m_Type;
    CScopeItem*     m_pScopeItem;
    CResultItem*    m_pResultItem;
    CCookie*        m_pParent;
    CCookie*        m_pSibling;
    CCookie*        m_pChild;
    DWORD       m_Flags;
};
#endif // __CCOOKIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\about.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    about.h

Abstract:

    header file defines CDevMgrAbout class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __ABOUT_H_
#define __ABOUT_H_


class CDevMgrAbout : public ISnapinAbout
{
public:
    CDevMgrAbout() :m_Ref(1)
    {}
// IUNKNOWN interface
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
// ISnapinAbout interface
    STDMETHOD(GetSnapinDescription)(LPOLESTR *ppDescription);
    STDMETHOD(GetProvider)(LPOLESTR* ppProvider);
    STDMETHOD(GetSnapinVersion)(LPOLESTR *ppVersion);
    STDMETHOD(GetSnapinImage)(HICON *phIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* phSmall,
                    HBITMAP* phSmallOpen,
                    HBITMAP* phLarge,
                    COLORREF* pcrMask);
private:
    HRESULT LoadResourceOleString(int StringId, LPOLESTR* ppString);
    LONG            m_Ref;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\about.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    about.cpp

Abstract:

    This module implemets ISnapinAbout inteface(CDevMgrAbout class).

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "about.h"

//
// IUnknown interface
//
ULONG
CDevMgrAbout::AddRef()
{
    return ::InterlockedIncrement(&m_Ref);
}

ULONG
CDevMgrAbout::Release()
{
    ASSERT( 0 != m_Ref );
    ULONG cRef = ::InterlockedDecrement(&m_Ref);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP
CDevMgrAbout::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;


    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)this;
    }
    
    else if (IsEqualIID(riid, IID_ISnapinAbout))
    {
        *ppv = (ISnapinAbout*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    return hr;
}

// ISnapinAbout interface

STDMETHODIMP
CDevMgrAbout::GetSnapinDescription(
    LPOLESTR *ppDescription
    )
{
    return LoadResourceOleString(IDS_PROGRAM_ABOUT, ppDescription);
}

STDMETHODIMP
CDevMgrAbout::GetProvider(
    LPOLESTR *ppProvider
    )
{
    return LoadResourceOleString(IDS_PROGRAM_PROVIDER, ppProvider);
}

STDMETHODIMP
CDevMgrAbout::GetSnapinVersion(
    LPOLESTR *ppVersion
    )
{
    return LoadResourceOleString(IDS_PROGRAM_VERSION, ppVersion);
}

STDMETHODIMP
CDevMgrAbout::GetSnapinImage(
    HICON* phIcon
    )
{
    if (!phIcon)
    {
        return E_INVALIDARG;
    }

    *phIcon = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR));
    
    if (!*phIcon)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP
CDevMgrAbout::GetStaticFolderImage(
    HBITMAP* phSmall,
    HBITMAP* phSmallOpen,
    HBITMAP* phLarge,
    COLORREF* pcrMask
    )
{
    if (!phSmall || !phSmallOpen || !phLarge || !pcrMask)
    {
        return E_INVALIDARG;
    }

    *phSmall = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SYSDM16));
    *phSmallOpen = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SYSDM16));
    *phLarge =::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_SYSDM32));
    *pcrMask = RGB(255, 0, 255);
    
    if (NULL == *phSmall || NULL == *phSmallOpen || NULL == *phLarge)
    {
        if (NULL != *phSmall)
        {
            ::DeleteObject(*phSmall);
            *phSmall = NULL;
        }
        
        if (NULL != *phSmallOpen)
        {
            ::DeleteObject(*phSmallOpen);
            *phSmallOpen = NULL;
        }

        if (NULL != *phLarge)
        {
            ::DeleteObject(*phLarge);
            *phLarge = NULL;
        }

        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// private routine to allocate ole task memory and load the given resource
// string(indicated by its string id) to the allocated memory.
// INPUT:
//  StringId -- the string resource id
//  LPOLESTR* -- place holder to hold the ole string pointer
// OUTPUT:
//  standard OLE HRESULT
HRESULT
CDevMgrAbout::LoadResourceOleString(
    int StringId,
    LPOLESTR* ppolestr
    )
{
    if (!ppolestr)
    {
        return E_INVALIDARG;
    }

    TCHAR Text[MAX_PATH];
    
    // get the string
    ::LoadString(g_hInstance, StringId, Text, ARRAYLEN(Text));
    
    try
    {
        *ppolestr = AllocOleTaskString(Text);
    }
    catch (CMemoryException* e)
    {
        e->Delete();

        if (*ppolestr)
        {
            FreeOleTaskString(*ppolestr);
            *ppolestr = NULL;
        }
    }

    if (!*ppolestr)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\api.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    api.cpp

Abstract:

    This module implements Device Manager exported APIs.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "devgenpg.h"
#include "devdrvpg.h"
#include "devpopg.h"
#include "api.h"
#include "printer.h"
#include "tswizard.h"


STDAPI_(BOOL)
DeviceManager_ExecuteA(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCWSTR   lpMachineName,
    int       nCmdShow
    )
/*++

    See DeviceManager_Execute function below.

--*/
{
    try
    {
        CTString tstrMachineName(lpMachineName);
        
        return DeviceManager_Execute(hwndStub, 
                                     hAppInstance,
                                     (LPCTSTR)tstrMachineName, 
                                     nCmdShow
                                     );
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return FALSE;
}

STDAPI_(BOOL)
DeviceManager_ExecuteW(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCWSTR   lpMachineName,
    int       nCmdShow
    )
/*++

    See DeviceManager_Execute function below.

--*/
{
    try
    {
        CTString tstrMachineName(lpMachineName);
    
        return DeviceManager_Execute(hwndStub, 
                                     hAppInstance,
                                     (LPCTSTR)tstrMachineName, 
                                     nCmdShow
                                     );
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return FALSE;
}

BOOL
DeviceManager_Execute(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR   lpMachineName,
    int       nCmdShow
    )
/*++

Routine Description:

    This function is executed via a rundll command line and can have the 
    following form:
    
        rundll32.exe devmgr.dll, DeviceManager_Execute
        rundll32.exe devmgr.dll, DeviceManager_Execute <remote machine name>
        
    This function will call ShelExecuteEx to create a new device manager process,
    where the new device manager can be for the local machine or for a machine
    name that is passed in on the rundll command line. 
Arguments:

    hwndStub - Windows handle to receive any message boxes that might be 
               displayed.
    
    hAppInstance - HINSTANCE.
    
    lpMachineName - Name of a remote machine that the new device manager 
                    process should connect to and show it's devices.
    
    nCmdShow - Flag that specifies how device manager should be shown when
               it is opened. It can be one of the SW_ values (i.e. SW_SHOW).

Return Value:

    returns TRUE if the device manager process was successfully created, or
    FALSE otherwise.

--*/
{
    SHELLEXECUTEINFO sei;
    TCHAR Parameters[MAX_PATH];
    String strMachineOptions;
    String strParameters;

    if (lpMachineName &&
        !VerifyMachineName(lpMachineName)) {
        //
        // We were unable to connect to the remote machine either because it
        // doesn't exist, or because we don't have the proper access.
        // The VerifyMachineName API sets the appropriate last error code.
        //
        return FALSE;
    }
    
    if (lpMachineName == NULL) {
        //
        // The lpMachineName was NULL so don't add a machine name to the command 
        // line.
        //
        strMachineOptions.Empty();
    } else {
        strMachineOptions.Format(DEVMGR_MACHINENAME_OPTION, lpMachineName);
    }

    WCHAR* FilePart;
    DWORD Size;
    
    Size = SearchPath(NULL, DEVMGR_MSC_FILE, NULL, ARRAYLEN(Parameters), Parameters, &FilePart);
    
    if (Size && (Size <= MAX_PATH)) {
        strParameters = Parameters;
    } else {
        strParameters = DEVMGR_MSC_FILE;
    }

    //
    // If we have a machine name then add it onto the end.
    //
    if (!strMachineOptions.IsEmpty()) {
        strParameters += MMC_COMMAND_LINE;
        strParameters += strMachineOptions;
    }

    memset(&sei, 0, sizeof(sei));
    sei.cbSize = sizeof(sei);
    sei.hwnd = hwndStub;
    sei.nShow = nCmdShow;
    sei.hInstApp = hAppInstance;
    sei.lpFile = MMC_FILE;
    sei.lpParameters = (LPTSTR)strParameters;
    
    return ShellExecuteEx(&sei);
}

BOOL
AddPageCallback(
    HPROPSHEETPAGE hPage,
    LPARAM lParam
    )
{
    CPropSheetData* ppsData = (CPropSheetData*)lParam;
    
    ASSERT(ppsData);
    
    return ppsData->InsertPage(hPage);
}

void
ReportCmdLineError(
    HWND hwndParent,
    int ErrorStringID,
    LPCTSTR Caption
    )
{
    String strTitle, strMsg;

    strMsg.LoadString(g_hInstance, ErrorStringID);
    
    if (!Caption)
    {
        strTitle.LoadString(g_hInstance, IDS_NAME_DEVMGR);

        Caption = (LPTSTR)strTitle;
    }

    MessageBox(hwndParent, (LPTSTR)strMsg, Caption, MB_OK | MB_ICONERROR);
}

STDAPI_(void)
DeviceProperties_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPSTR lpCmdLine,
    int   nCmdShow
    )
/*++

    See DeviceProperties_RunDLL function below.

--*/
{

    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProperties_RunDLL(hwndStub, 
                                hAppInstance,
                                (LPCTSTR)tstrCmdLine,   
                                nCmdShow
                                );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

STDAPI_(void)
DeviceProperties_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPWSTR lpCmdLine,
    int    nCmdShow
    )
/*++

    See DeviceProperties_RunDLL function below.

--*/
{
    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProperties_RunDLL(hwndStub, 
                                hAppInstance,
                                (LPCTSTR)tstrCmdLine, 
                                nCmdShow
                                );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

void
DeviceProperties_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    )
/*++

Routine Description:

    This API will bring up the property pages for the specified device. Other
    options, such as the remote machine name, whether the device manager tree
    should be shown or not, whether the resource tab should be shows, and 
    whether the troubleshooter should be automatically launched, can also be
    specified.
    
    This function is executed via a rundll command line and can have the 
    following form:
    
        rundll32.exe devmgr.dll, DeviceProperties_RunDLL <options>

    Additional command line options that are excepted are:
        /MachineName <machine name>
            If this option is specified then the API will bring up the properties
            for the specified device on this remote machine.
        
        /DeviceId <device instance Id>
            If this option is specified then this will be the device for which
            the properties will be displayed for.
            NOTE: The caller must either specify a DeviceId or use the 
            ShowDeviceTree command line option.
        
        /ShowDeviceTree
            If this command line option is specified then the property sheet
            will be displayed in front of the entire device manager tree.
        
        /Flags <flags>
            The following flags are supported:
            DEVPROP_SHOW_RESOURCE_TAB       0x00000001
            DEVPROP_LAUNCH_TROUBLESHOOTER   0x00000002
            
Arguments:

    hwndStub - Windows handle to receive any message boxes that might be 
               displayed.
    
    hAppInstance - HINSTANCE.
    
    lpCmdLine - Name of a remote machine that the new device manager 
                process should connect to and show it's devices.
    
    nCmdShow - Flag that specifies how device manager should be shown when
               it is opened. It can be one of the SW_ values (i.e. SW_SHOW).

Return Value:

    none

--*/
{
    UNREFERENCED_PARAMETER(hAppInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    try
    {
        CRunDLLCommandLine CmdLine;
        CmdLine.ParseCommandLine(lpCmdLine);
    
        if (NULL == CmdLine.GetDeviceID())
        {
            ReportCmdLineError(hwndStub, IDS_NO_DEVICEID);
            return;
        }
        
        //
        // Let the DevicePropertiesEx API do all the appropriate error checking.
        //
        DevicePropertiesEx(hwndStub, 
                           CmdLine.GetMachineName(), 
                           CmdLine.GetDeviceID(),
                           CmdLine.GetFlags(),
                           CmdLine.ToShowDeviceTree()
                           );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
        return;
    }
}

STDAPI_(int)
DevicePropertiesA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    BOOL ShowDeviceTree
    )
/*++

    See DevicePropertiesEx function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  DEVPROP_SHOW_RESOURCE_TAB,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

STDAPI_(int)
DevicePropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    BOOL ShowDeviceTree
    )
/*++

    See DevicePropertiesEx function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  DEVPROP_SHOW_RESOURCE_TAB,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

STDAPI_(int)
DevicePropertiesExA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    )
/*++

    See DevicePropertiesEx function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  Flags,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

STDAPI_(int)
DevicePropertiesExW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    )
/*++

    See DevicePropertiesEx function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceID);
        
        return DevicePropertiesEx(hwndParent, 
                                  (LPCTSTR)tstrMachineName,
                                  (LPCTSTR)tstrDeviceID, 
                                  Flags,
                                  ShowDeviceTree
                                  );
    }
    
    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    
    return 0;
}

int
DevicePropertiesEx(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    )
/*++

Routine Description:

    This API will bring up the property page for the specified device.                    
 
Arguments:

    hwndParent - the caller's window handle to be used as the owner window
                 of the property page and any other windows this API may create.
                 
    MachineName - optional machine name. If given, it must be in its fully
                  qualified form. NULL means local machine
                  
    DeviceId - device instance id of the device that this API should create
               the property sheet for.                                    
               
    Flags - the following flags are supported:
        DEVPROP_SHOW_RESOURCE_TAB       0x00000001 - show the resource tab, by
                                                     default the resource tab
                                                     is not shown.
        DEVPROP_LAUNCH_TROUBLESHOOTER   0x00000002 - Automatically launch the
                                                     troubleshooter for this 
                                                     device.
                                                     
    ShowDeviceTree - If specified then the device manager tree is shown. If
                     the DeviceID is specified then only that device is shown
                     in the tree, otherwise all devices are shown.
                   

Return Value:

    The return value from PropertySheet, including ID_PSREBOOTSYSTEM if 
    a reboot is needed due to any user actions.
    
    -1 is returned in case of an error.

--*/
{
    HPROPSHEETPAGE hPage;
    DWORD DiFlags;
    DWORD DiFlagsEx;

    //
    // Verify that a DeviceID was passed in unless they want to show the 
    // whole device tree.
    //
    if ((!DeviceID || (TEXT('\0') == *DeviceID))  && !ShowDeviceTree) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    //
    // Verify that valid flags are passed in
    //
    if (Flags &~ DEVPROP_BITS) {
        
        SetLastError(ERROR_INVALID_FLAGS);
        return -1;
    }

    if (MachineName &&
        !VerifyMachineName(MachineName)) {
        //
        // We were unable to connect to the remote machine either because it
        // doesn't exist, or because we don't have the proper access.
        // The VerifyMachineName API sets the appropriate last error code.
        //
        return -1;
    }

    if (ShowDeviceTree) {

        return PropertyRunDeviceTree(hwndParent, MachineName, DeviceID);
    }

    int Result = -1;

    CDevice* pDevice;
    PVOID Context;

    try {

        CMachine TheMachine(MachineName);

        // create the machine just for this device
        if (!TheMachine.Initialize(hwndParent, DeviceID)) {

            SetLastError(ERROR_NO_SUCH_DEVINST);
            return -1;
        }

        if (!TheMachine.GetFirstDevice(&pDevice, Context)) {

            SetLastError(ERROR_NO_SUCH_DEVINST);
            return -1;
        }

        //
        // If the troubleshooter should be launched then set the appropriate
        // BOOL inside of the pDevice class.
        //
        if (Flags & DEVPROP_LAUNCH_TROUBLESHOOTER) {
        
            pDevice->m_bLaunchTroubleShooter = TRUE;
        }
        
        CPropSheetData& psd = pDevice->m_psd;

        //
        // Initialize CPropSheetData without ConsoleHandle
        //
        if (psd.Create(g_hInstance, hwndParent, MAX_PROP_PAGES, 0l)) {

            psd.m_psh.pszCaption = pDevice->GetDisplayName();

            //
            // Add any class/device specific property pages.
            //
            TheMachine.DiGetClassDevPropertySheet(*pDevice, &psd.m_psh,
                                                  MAX_PROP_PAGES,
                                                  TheMachine.IsLocal() ? 
                                                        DIGCDP_FLAG_ADVANCED :
                                                        DIGCDP_FLAG_REMOTE_ADVANCED);

            //
            // Add the general tab
            //
            DiFlags = TheMachine.DiGetFlags(*pDevice);
            DiFlagsEx = TheMachine.DiGetExFlags(*pDevice);

            if (DiFlags & DI_GENERALPAGE_ADDED) {

                String strWarning;

                strWarning.LoadString(g_hInstance, IDS_GENERAL_PAGE_WARNING);

                MessageBox(hwndParent, (LPTSTR)strWarning, pDevice->GetDisplayName(),
                    MB_ICONEXCLAMATION | MB_OK);

                //
                // fall through to create our general page.
                //
            }

            SafePtr<CDeviceGeneralPage> GenPagePtr;
            CDeviceGeneralPage* pGeneralPage = new CDeviceGeneralPage();
            GenPagePtr.Attach(pGeneralPage);

            hPage = pGeneralPage->Create(pDevice);

            if (hPage) {

                if (psd.InsertPage(hPage, 0)) {

                    GenPagePtr.Detach();
                }

                else {

                    ::DestroyPropertySheetPage(hPage);
                }
            }

            //
            // Add the driver tab
            //
            if (!(DiFlags & DI_DRIVERPAGE_ADDED)) {

                SafePtr<CDeviceDriverPage> DrvPagePtr;
                CDeviceDriverPage* pDriverPage = new CDeviceDriverPage();
                DrvPagePtr.Attach(pDriverPage);

                hPage = pDriverPage->Create(pDevice);

                if (hPage) {

                    if (psd.InsertPage(hPage)) {

                        DrvPagePtr.Detach();
                    }

                    else {

                        ::DestroyPropertySheetPage(hPage);
                    }
                }
            }

            //
            // Add the resource tab
            //
            if ((Flags & DEVPROP_SHOW_RESOURCE_TAB) &&
                pDevice->HasResources() && 
                !(DiFlags & DI_RESOURCEPAGE_ADDED)) {

                TheMachine.DiGetExtensionPropSheetPage(*pDevice,
                        AddPageCallback,
                        SPPSR_SELECT_DEVICE_RESOURCES,
                        (LPARAM)&psd
                        );
            }

#ifndef _WIN64
            //
            // Add the power tab if this is the local machine
            //
            if (TheMachine.IsLocal() && !(DiFlagsEx & DI_FLAGSEX_POWERPAGE_ADDED)) 
            {
                //
                // Check if the device support power management
                //
                CPowerShutdownEnable ShutdownEnable;
                CPowerWakeEnable WakeEnable;
    
                if (ShutdownEnable.Open(pDevice->GetDeviceID()) || WakeEnable.Open(pDevice->GetDeviceID())) {
    
                    ShutdownEnable.Close();
                    WakeEnable.Close();
    
                    SafePtr<CDevicePowerMgmtPage> PowerMgmtPagePtr;
    
                    CDevicePowerMgmtPage* pPowerPage = new CDevicePowerMgmtPage;
                    PowerMgmtPagePtr.Attach(pPowerPage);
                    hPage = pPowerPage->Create(pDevice);
    
                    if (hPage) {
    
                        if (psd.InsertPage(hPage)) {
    
                            PowerMgmtPagePtr.Detach();
                        }
    
                        else {
    
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
            }
#endif

            //
            // Add any Bus property pages if this is the local machine
            //
            if (TheMachine.IsLocal()) 
            {
                CBusPropPageProvider* pBusPropPageProvider = new CBusPropPageProvider();
                SafePtr<CBusPropPageProvider> ProviderPtr;
                ProviderPtr.Attach(pBusPropPageProvider);
    
                if (pBusPropPageProvider->EnumPages(pDevice, &psd)) {
    
                    psd.AddProvider(pBusPropPageProvider);
                    ProviderPtr.Detach();
                }
            }

            Result = (int)psd.DoSheet();

            if (-1 != Result) {

                if (TheMachine.DiGetExFlags(*pDevice) & DI_FLAGSEX_PROPCHANGE_PENDING) {


                    //
                    // property change pending, issue a DICS_PROPERTYCHANGE
                    // to the class installer
                    //
                    SP_PROPCHANGE_PARAMS pcp;
                    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

                    pcp.Scope = DICS_FLAG_GLOBAL;
                    pcp.StateChange = DICS_PROPCHANGE;

                    TheMachine.DiSetClassInstallParams(*pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );

                    TheMachine.DiCallClassInstaller(DIF_PROPERTYCHANGE, *pDevice);
                    TheMachine.DiTurnOnDiFlags(*pDevice, DI_PROPERTIES_CHANGE);
                    TheMachine.DiTurnOffDiExFlags(*pDevice, DI_FLAGSEX_PROPCHANGE_PENDING);
                }

                //
                // Merge restart/reboot flags
                //
                DiFlags = TheMachine.DiGetFlags(*pDevice);

                if (DI_NEEDREBOOT & DiFlags) {

                    Result |= ID_PSREBOOTSYSTEM;
                }

                if (DI_NEEDRESTART & DiFlags) {

                    Result |= ID_PSRESTARTWINDOWS;
                }
            }
        }
    }

    catch (CMemoryException* e) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }
    return -1;
}

STDAPI_(UINT)
DeviceProblemTextA(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPSTR   Buffer,
    UINT    BufferSize
    )
/*++

Routine Description:

    This API gets the problem description associated with the specified
    problem code.

Arguments:

    hMachine - not used.
    
    DevNode - not used.
    
    ProblemNumber - CM problem code to get the problem text for.
    
    Buffer - Buffer to receive the problem text.
    
    BufferSize - size of Buffer in characters. This can be 0 if the caller
                 wants to know how large of a buffer they should allocate.

Return Value:

    UINT required size to hold the problem text string, or 0 in case of
    an error.  Use GetLastError() for extended error information.

--*/
{
    UNREFERENCED_PARAMETER(hMachine);
    UNREFERENCED_PARAMETER(DevNode);

    WCHAR* wchBuffer = NULL;
    UINT RealSize = 0;

    if (BufferSize && !Buffer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (BufferSize)
    {
        try
        {
            wchBuffer = new WCHAR[BufferSize];
        }

        catch (CMemoryException* e)
        {
            e->Delete();
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
    }

    RealSize = GetDeviceProblemText(ProblemNumber, wchBuffer, BufferSize);
    if (RealSize && BufferSize > RealSize)
    {
        ASSERT(wchBuffer);
        RealSize = WideCharToMultiByte(CP_ACP, 0, wchBuffer, RealSize,
                        Buffer, BufferSize, NULL, NULL);
        
        Buffer[RealSize] = '\0';
    }

    if (wchBuffer)
    {
        delete [] wchBuffer;
    }

    return RealSize;
}

STDAPI_(UINT)
DeviceProblemTextW(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPWSTR Buffer,
    UINT   BufferSize
    )
/*++

Routine Description:

    This API gets the problem description associated with the specified
    problem code.

Arguments:

    hMachine - not used.
    
    DevNode - not used.
    
    ProblemNumber - CM problem code to get the problem text for.
    
    Buffer - Buffer to receive the problem text.
    
    BufferSize - size of Buffer in characters. This can be 0 if the caller
                 wants to know how large of a buffer they should allocate.

Return Value:

    UINT required size to hold the problem text string, or 0 in case of
    an error.  Use GetLastError() for extended error information.

--*/
{
    UNREFERENCED_PARAMETER(hMachine);
    UNREFERENCED_PARAMETER(DevNode);

    return GetDeviceProblemText(ProblemNumber, Buffer, BufferSize);
}

int
PropertyRunDeviceTree(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID
    )
{

    SHELLEXECUTEINFOW sei;
    TCHAR Parameters[MAX_PATH];
    String strParameters;
    String strMachineOptions;
    String strDeviceIdOptions;
    String strCommandOptions;
    TCHAR* FilePart;
    DWORD Size;
    
    Size = SearchPath(NULL, DEVMGR_MSC_FILE, NULL, MAX_PATH, Parameters, &FilePart);
    
    if (Size && Size <= MAX_PATH) {
        strParameters = Parameters;
    } else {
        
        strParameters = DEVMGR_MSC_FILE;
    }

    strParameters += MMC_COMMAND_LINE;

    if (MachineName != NULL) {
        
        strMachineOptions.Format(DEVMGR_MACHINENAME_OPTION, MachineName);
        strParameters += strMachineOptions;
    }

    if (DeviceID != NULL) {
        
        strDeviceIdOptions.Format(DEVMGR_DEVICEID_OPTION, DeviceID);
        strParameters += strDeviceIdOptions;
        
        strCommandOptions.Format(DEVMGR_COMMAND_OPTION, DEVMGR_CMD_PROPERTY);
        strParameters += strCommandOptions;
    }

    memset(&sei, 0, sizeof(sei));
    sei.cbSize = sizeof(sei);
    sei.hwnd = hwndParent;
    sei.nShow = SW_NORMAL;
    sei.hInstApp = g_hInstance;
    sei.lpFile = MMC_FILE;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.lpParameters = (LPTSTR)strParameters;
    
    if (ShellExecuteEx(&sei) && sei.hProcess)
    {
        WaitForSingleObject(sei.hProcess, INFINITE);
        CloseHandle(sei.hProcess);
        return 1;
    }

    return 0;
}

STDAPI_(void)
DeviceProblenWizard_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPSTR lpCmdLine,
    int   nCmdShow
    )
/*++

    See DeviceProblemWizard_RunDLL function below.

--*/
{

    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProblenWizard_RunDLL(hwndStub, 
                                   hAppInstance,
                                   (LPCTSTR)tstrCmdLine,   
                                   nCmdShow
                                   );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

STDAPI_(void)
DeviceProblenWizard_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPWSTR lpCmdLine,
    int    nCmdShow
    )
/*++

    See DeviceProblemWizard_RunDLL function below.

--*/
{
    try
    {
        CTString tstrCmdLine(lpCmdLine);
    
        DeviceProblenWizard_RunDLL(hwndStub, 
                                   hAppInstance,
                                   (LPCTSTR)tstrCmdLine, 
                                   nCmdShow
                                   );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
    }
}

void
DeviceProblenWizard_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    )
/*++

Routine Description:

    This API will bring up the problem wizard (troubleshooter) for the 
    specified device.
        
    This function is executed via a rundll command line and can have the 
    following form:
    
        rundll32.exe devmgr.dll, DeviceProblemWizard_RunDLL /DeviceId <device instance Id>

Arguments:

    hwndStub - Windows handle to receive any message boxes that might be 
               displayed.
    
    hAppInstance - HINSTANCE.
    
    lpCmdLine - Name of a remote machine that the new device manager 
                process should connect to and show it's devices.
    
    nCmdShow - Flag that specifies how device manager should be shown when
               it is opened. It can be one of the SW_ values (i.e. SW_SHOW).

Return Value:

    none

--*/
{
    UNREFERENCED_PARAMETER(hAppInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    try
    {
        CRunDLLCommandLine CmdLine;
        CmdLine.ParseCommandLine(lpCmdLine);
    
        //
        // Let the DeviceProblemWizard handle all of the parameter validation.
        //
        DeviceProblemWizard(hwndStub, 
                            CmdLine.GetMachineName(), 
                            CmdLine.GetDeviceID()
                            );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
        return;
    }
}

STDAPI_(int)
DeviceProblemWizardA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceId
    )
/*++

    See DeviceProblemWizard function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceId(DeviceId);
        return DeviceProblemWizard(hwndParent, tstrMachineName, tstrDeviceId);
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return 0;
}

STDAPI_(int)
DeviceProblemWizardW(
    HWND hwndParent,
    LPCWSTR  MachineName,
    LPCWSTR  DeviceId
    )
/*++

    See DeviceProblemWizard function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceId(DeviceId);
        return DeviceProblemWizard(hwndParent, tstrMachineName, tstrDeviceId);
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return 0;
}

int
DeviceProblemWizard(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    )
/*++

Routine Description:

    This API will launch the device troubleshooter for the specified
    device instance Id.  
    
    The troubleshooter can have any form, including HTML help, help center
    pages, or an actual Win32 troubleshooter.  The troubleshooter also should
    be specific to the CM Problem code that the device has, but if no 
    troubleshooter exists for the CM Problem code, then a more generic 
    troubleshooter will be launched.

Arguments:

    hwndParent - the caller's window handle to be used as the owner window
                 of the property page and any other windows this API may create.
                 
    MachineName - Must be NULL.  Currently there is no support for remote
                  troubleshooters
                  
    DeviceId - device instance id of the device that this API should launch
               the troubleshooter.     

Return Value:

    1 if a troubleshooter is successfully launched, 0 otherwise.  Use 
    GetLastError to get extended error information if 0 is returned.

--*/
{
    int   iRet = 0;
    DWORD Problem, Status;

    if (!DeviceId) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (MachineName) {
        //
        // Currently getting troubleshooters are remote machines is not
        // implemented.
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
    }

    try
    {
        CMachine TheMachine(NULL);

        //
        // create the machine just for this device
        //
        if (!TheMachine.Initialize(hwndParent, DeviceId))
        {
            SetLastError(ERROR_NO_SUCH_DEVINST);
            iRet = 0;
            goto clean0;
        }

        PVOID Context;
        CDevice* pDevice;
        if (!TheMachine.GetFirstDevice(&pDevice, Context))
        {
            SetLastError(ERROR_NO_SUCH_DEVINST);
            iRet = 0;
            goto clean0;
        }

        if (pDevice->GetStatus(&Status, &Problem)) {
            //
            // if the device is a phantom device, use the CM_PROB_PHANTOM
            //
            if (pDevice->IsPhantom()) {

                Problem = CM_PROB_PHANTOM;
            }

            //
            // if the device is not started and no problem is assigned to it
            // fake the problem number to be failed start.
            //
            if (!(Status & DN_STARTED) && !Problem && pDevice->IsRAW()) {

                Problem = CM_PROB_FAILED_START;
            }
        }

        CProblemAgent* pProblemAgent = new CProblemAgent(pDevice, Problem, TRUE);

        if (pProblemAgent) {

            pProblemAgent->FixIt(hwndParent);
        }

        iRet = 1;
    
clean0:;

    } catch(CMemoryException* e) {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return iRet;
}

STDAPI_(int)
DeviceAdvancedPropertiesA(
    HWND hwndParent,
    LPTSTR MachineName,
    LPTSTR DeviceId
    )
/*++

    See DeviceAdvancedProperties function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceId);
        
        return DeviceAdvancedProperties(hwndParent, 
                                        (LPCTSTR)tstrMachineName,
                                        (LPCTSTR)tstrDeviceID
                                        );
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }

    return 0;
}

STDAPI_(int)
DeviceAdvancedPropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    )
/*++

    See DeviceAdvancedProperties function below.

--*/
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceId);
    
        return DeviceAdvancedProperties(hwndParent, 
                                        (LPCTSTR)tstrMachineName,
                                        (LPCTSTR)tstrDeviceID
                                        );
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }

    return 0;
}

int DeviceAdvancedProperties(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    )
/*++

Routine Description:

    This API creates a property sheet and asks the given device's property
    page provider to add any advanced pages to the property sheet.
    
    The purpose of this API is for an application to manage device advanced
    properties only.  Standard property pages (General, Driver, Resource,
    Power, Bus pages) are not added.
    
    We get these advanced pages by calling SetupDiGetClassDevPropertySheet
    with DIGCDP_FLAG_ADVANCED, for the local machine case, and
    DIGCDP_FLAG_REMOTE_ADVANCED if a remote MachineName is passed in.

    NOTE: If the device does not have any advanced property pages, then no UI
    is displayed.
 
Arguments:

    hwndParent - the caller's window handle to be used as the owner window
                 of the property page and any other windows this API may create.
                 
    MachineName - optional machine name. If given, it must be in its fully
                  qualified form. NULL means local machine
                  
    DeviceId - device instance id of the device that this API should create
               the property sheet for.                                    

Return Value:

    The return value from PropertySheet, including ID_PSREBOOTSYSTEM if 
    a reboot is needed due to any user actions.
    
    -1 is returned in case of an error.

--*/
{
    if (!DeviceId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    if (MachineName &&
        !VerifyMachineName(MachineName)) {
        //
        // We were unable to connect to the remote machine either because it
        // doesn't exist, or because we don't have the proper access.
        // The VerifyMachineName API sets the appropriate last error code.
        //
        return -1;
    }

    CMachine TheMachine(MachineName);
    CDevice* pDevice;
    PVOID    Context;
    
    try
    {
        if (TheMachine.Initialize(hwndParent, DeviceId) &&
            TheMachine.GetFirstDevice(&pDevice, Context))
        {

            TheMachine.EnableRefresh(FALSE);

            CPropSheetData& psd = pDevice->m_psd;
        
            //initialize CPropSheetData without ConsoleHandle
            if (psd.Create(g_hInstance, hwndParent, MAX_PROP_PAGES, 0l))
            {
                psd.m_psh.pszCaption = pDevice->GetDisplayName();
                if (TheMachine.DiGetClassDevPropertySheet(*pDevice, &psd.m_psh,
                                       MAX_PROP_PAGES,
                                       TheMachine.IsLocal() ?
                                            DIGCDP_FLAG_ADVANCED :
                                            DIGCDP_FLAG_REMOTE_ADVANCED))
                {
                    int Result = (int)psd.DoSheet();
                    
                    if (-1 != Result)
                    {
                        // merge restart/reboot flags
                        DWORD DiFlags = TheMachine.DiGetFlags(*pDevice);
                        
                        if (DI_NEEDREBOOT & DiFlags)
                        {
                            Result |= ID_PSREBOOTSYSTEM;
                        }

                        if (DI_NEEDRESTART & DiFlags)
                        {
                            Result |= ID_PSRESTARTWINDOWS;
                        }
                    }
            
                    return Result;
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\cdriver.h ===
#ifndef _CDRIVER_H__
#define _CDRIVER_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    cdriver.h

Abstract:

    header file for cdriver.cpp. Defined CDriverFile, CDriver and CService

Author:

    William Hsieh (williamh) created

Revision History:


--*/
class CDriverFile
{
public:
    CDriverFile() : m_Win32Error(ERROR_FILE_NOT_FOUND), m_Attributes(0xFFFFFFFF),
        m_IsDriverBlocked(FALSE)
    {};
    BOOL Create(LPCTSTR ServiceName, 
                BOOL LocalMachine, 
                DWORD Win32Error = ERROR_FILE_NOT_FOUND,
                LPCTSTR pszDigitalSigner = NULL,
                HSDB hSDBDrvMain = NULL);
    LPCTSTR GetProvider()
    {
        return m_strProvider.IsEmpty() ? NULL : (LPCTSTR)m_strProvider;
    }
    LPCTSTR GetCopyright(void)
    {
        return m_strCopyright.IsEmpty() ? NULL : (LPCTSTR)m_strCopyright;

    }
    LPCTSTR GetVersion(void)
    {
        return m_strVersion.IsEmpty() ? NULL : (LPCTSTR)m_strVersion;
    }
    LPCTSTR GetFullPathName(void)
    {
        return m_strFullPathName.IsEmpty() ? NULL : (LPCTSTR)m_strFullPathName;
    }
    BOOL HasVersionInfo()
    {
        return m_HasVersionInfo;
    }
    DWORD GetWin32Error()
    {
        return m_Win32Error;
    }
    DWORD GetAttributes()
    {
        return m_Attributes;
    }
    LPCTSTR GetInfDigitalSigner(void)
    {
        return m_strDigitalSigner.IsEmpty() ? NULL : (LPCTSTR)m_strDigitalSigner;
    }
    BOOL IsDriverBlocked()
    {
        return m_IsDriverBlocked;
    }
    LPCTSTR GetBlockedDriverHtmlHelpID(void)
    {
        return m_strHtmlHelpID.IsEmpty() ? NULL : (LPCTSTR)m_strHtmlHelpID;
    }
    BOOL operator ==(CDriverFile& OtherDrvFile);

private:
    BOOL    GetVersionInfo();
    String  m_strFullPathName;
    String  m_strProvider;
    String  m_strCopyright;
    String  m_strVersion;
    String  m_strDigitalSigner;
    String  m_strHtmlHelpID;
    BOOL    m_HasVersionInfo;
    BOOL    m_IsDriverBlocked;
    DWORD   m_Win32Error;
    DWORD   m_Attributes;
};

class CDriver
{
public:
    CDriver() : m_pDevice(NULL), m_OnLocalMachine(TRUE), m_DriverListBuilt(FALSE),
        m_hSDBDrvMain(NULL)
    {
        m_DigitalSigner.Empty();
    }
    ~CDriver();
    BOOL Create(SC_HANDLE hscManager, LPTSTR tszServiceName);
    BOOL Create(CDevice* pDevice);
    BOOL GetFirstDriverFile(CDriverFile** ppDrvFile, PVOID& Context);
    BOOL GetNextDriverFile(CDriverFile** ppDrvFile, PVOID& Context);
    void AddDriverFile(CDriverFile* pDrvFile);
    BOOL IsLocal()
    {
        return m_OnLocalMachine;
    }
    int GetCount()
    {
        return m_listDriverFile.GetCount();
    }
    BOOL BuildDriverList(BOOL bFunctionAndFiltersOnly = FALSE);
    void GetDriverSignerString(String& strDriverSigner);

private:
    // call back must be a static function(because of the hidden this parameter
    static UINT ScanQueueCallback(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
    void AddFunctionAndFilterDrivers(CDevice* pDevice, HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE);
    void CreateFromService(CDevice* pDevice, PCTSTR ServiceName, HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE);
    BOOL GetFullPathFromImagePath(LPCTSTR ImagePath, LPTSTR FullPath, UINT FullPathLength);
    CList<CDriverFile*,CDriverFile* > m_listDriverFile;
    CDevice* m_pDevice;
    BOOL m_OnLocalMachine;
    BOOL m_DriverListBuilt;
    String m_DigitalSigner;
    HSDB m_hSDBDrvMain;
};

#endif // _CDRIVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\api.h ===
#ifndef __API_H__
#define __API_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    api.h

Abstract:

    header file for api.cpp

    Note that no other file can #include "api.h" because the file contains
    definitions, not just declarations.

Author:

    William Hsieh (williamh) created

Revision History:


--*/



// Exported APIs

BOOL
DeviceManager_ExecuteA(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCSTR    lpMachineName,
    int       nCmdShow
    );

STDAPI_(BOOL)
DeviceManager_ExecuteW(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCWSTR   lpMachineName,
    int       nCmdShow
    );

BOOL
DeviceManager_Execute(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR   lpMachineName,
    int       nCmdShow
    );

STDAPI_(void)
DeviceProperties_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPSTR lpCmdLine,
    int   nCmdShow
    );

STDAPI_(void)
DeviceProperties_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPWSTR lpCmdLine,
    int   nCmdShow
    );

STDAPI_(int)
DevicePropertiesExA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesExW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    BOOL ShowDeviceTree
    );

//
// DevicePropertiesEx Flags
//
#define DEVPROP_SHOW_RESOURCE_TAB       0x00000001
#define DEVPROP_LAUNCH_TROUBLESHOOTER   0x00000002
#define DEVPROP_BITS                    0x00000003


STDAPI_(UINT)
DeviceProblemTextA(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPSTR Buffer,
    UINT   BufferSize
    );

STDAPI_(UINT)
DeviceProblemTextW(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPWSTR Buffer,
    UINT   BufferSize
    );

//////////////////////////////////////////////////////////////////////////
////////
////////
///////
const TCHAR*    MMC_FILE = TEXT("mmc.exe");
const TCHAR*    DEVMGR_MSC_FILE = TEXT("devmgmt.msc");
const TCHAR*    MMC_COMMAND_LINE = TEXT(" /s ");
const TCHAR*    DEVMGR_MACHINENAME_OPTION = TEXT(" /dmmachinename %s");
const TCHAR*    DEVMGR_DEVICEID_OPTION = TEXT(" /dmdeviceid %s");
const TCHAR*    DEVMGR_COMMAND_OPTION = TEXT(" /dmcommand %s");
const TCHAR*    DEVMGR_CMD_PROPERTY  = TEXT("property");

const TCHAR*    RUNDLL_MACHINENAME     = TEXT("machinename");
const TCHAR*    RUNDLL_DEVICEID        = TEXT("deviceid");
const TCHAR*    RUNDLL_SHOWDEVICETREE  = TEXT("showdevicetree");
const TCHAR*    RUNDLL_FLAGS           = TEXT("flags");


void
ReportCmdLineError(
    HWND hwndParent,
    int  ErrorStringID,
    LPCTSTR Caption = NULL
    );
BOOL AddPageCallback(
    HPROPSHEETPAGE hPage,
    LPARAM lParam
    );

int
PropertyRunDeviceTree(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID
    );



int
DevicePropertiesEx(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

void
DeviceProperties_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

int
DeviceAdvancedPropertiesA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceId
    );

STDAPI_(int)
DeviceAdvancedPropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    );
int
DeviceAdvancedProperties(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    );



void
DeviceProblenWizard_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

void
DeviceProblenWizard_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

void
DeviceProblenWizard_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

STDAPI_(int)
DeviceProblemWizardA(
    HWND      hwndParent,
    LPCSTR    MachineName,
    LPCSTR    DeviceId
    );

STDAPI_(int)
DeviceProblemWizardW(
    HWND    hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    );

int
DeviceProblemWizard(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    );

//
// Object to parse command line passed in the lpCmdLine parameter
// passed in DeviceProperties_RunDLL APIs
//
class CRunDLLCommandLine : public CCommandLine
{
public:
    CRunDLLCommandLine() : m_ShowDeviceTree(FALSE), m_Flags(0), m_WaitMachineName(FALSE),
        m_WaitDeviceID(FALSE), m_WaitFlags(FALSE)
    {}
    virtual void ParseParam(LPCTSTR Param, BOOL bFlag)
    {
        if (bFlag)
        {
            if (!lstrcmpi(RUNDLL_MACHINENAME, Param))
            {
                m_WaitMachineName = TRUE;
            }
            if (!lstrcmpi(RUNDLL_DEVICEID, Param))
            {
                m_WaitDeviceID = TRUE;
            }
            if (!lstrcmpi(RUNDLL_SHOWDEVICETREE, Param))
            {
                m_ShowDeviceTree = TRUE;
            }
            if (!lstrcmpi(RUNDLL_FLAGS, Param)) {
                m_WaitFlags = TRUE;
            }
        }
        else
        {
            if (m_WaitMachineName)
            {
                m_strMachineName = Param;
                m_WaitMachineName = FALSE;
            }
            if (m_WaitDeviceID)
            {
                m_strDeviceID = Param;
                m_WaitDeviceID = FALSE;
            }
            if (m_WaitFlags) {
                m_Flags = (DWORD)StrToInt(Param);
                m_WaitFlags = FALSE;
            }
        }
    }
    LPCTSTR GetMachineName()
    {
        return (m_strMachineName.IsEmpty()) ? NULL : (LPCTSTR)m_strMachineName;
    }
    LPCTSTR GetDeviceID()
    {
        return (m_strDeviceID.IsEmpty()) ? NULL : (LPCTSTR)m_strDeviceID;
    }
    BOOL  ToShowDeviceTree()
    {
        return m_ShowDeviceTree;
    }
    DWORD GetFlags()
    {
        return m_Flags;
    }

private:
    BOOL    m_WaitMachineName;
    BOOL    m_WaitDeviceID;
    BOOL    m_WaitFlags;
    String  m_strDeviceID;
    String  m_strMachineName;
    BOOL    m_ShowDeviceTree;
    DWORD   m_Flags;
};

//
// Object to return the corresponding LPTSTR for the given
// string.
//
class CTString
{
public:
    CTString(LPCWSTR pWString);
    CTString(LPCSTR pString);
    ~CTString()
    {
        if (m_Allocated && m_pTString)
        {
            delete [] m_pTString;
        }
    }
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pTString;
    }
private:
    LPTSTR  m_pTString;
    BOOL    m_Allocated;
};


CTString::CTString(
    LPCWSTR pWString
    )
{
    m_pTString = NULL;
    m_Allocated = FALSE;
    m_pTString = (LPTSTR)pWString;
}

CTString::CTString(
    LPCSTR pAString
    )
{
    m_pTString = NULL;
    m_Allocated = FALSE;
    int aLen = pAString ? (int)strlen(pAString) : 0;
    if (aLen)
    {
        int tLen;
        tLen = MultiByteToWideChar(CP_ACP, 0, pAString, aLen, NULL, 0);
        
        if (tLen)
        {
            m_pTString = new TCHAR[tLen + 1];
            MultiByteToWideChar(CP_ACP, 0, pAString, aLen, m_pTString, tLen);
            m_pTString[tLen] = _T('\0');
        }
        
        m_Allocated = TRUE;
    }
}
#endif // __API_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\cdriver.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    CDriver.cpp

Abstract:

    This module implements CDriver and CService classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "cdriver.h"

const TCHAR*  tszStringFileInfo = TEXT("StringFileInfo\\%04X%04X\\");
const TCHAR*  tszFileVersion = TEXT("FileVersion");
const TCHAR*  tszLegalCopyright = TEXT("LegalCopyright");
const TCHAR*  tszCompanyName = TEXT("CompanyName");
const TCHAR*  tszTranslation = TEXT("VarFileInfo\\Translation");
const TCHAR*  tszStringFileInfoDefault = TEXT("StringFileInfo\\040904B0\\");


BOOL
CDriver::Create(
    CDevice* pDevice
    )
{
    HKEY hKey;
    TCHAR InfName[MAX_PATH];

    ASSERT(pDevice);

    m_pDevice = pDevice;
    m_OnLocalMachine  = pDevice->m_pMachine->IsLocal();

    CMachine* pMachine = m_pDevice->m_pMachine;

    ASSERT(pMachine);

    //
    // We can't get the driver list on remote machines
    //
    if (!m_OnLocalMachine) {
        return TRUE;
    }

    m_hSDBDrvMain = SdbInitDatabase(SDB_DATABASE_MAIN_DRIVERS, NULL);

    //
    // Open drvice's driver registry key to get the InfPath
    //
    hKey = pMachine->DiOpenDevRegKey(*m_pDevice, DICS_FLAG_GLOBAL,
                 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE != hKey) {

        DWORD regType;
        DWORD Len = sizeof(InfName);
        CSafeRegistry regDrv(hKey);

        //
        // Get the inf path from the driver key
        //
        if (regDrv.GetValue(REGSTR_VAL_INFPATH,
                            &regType,
                            (PBYTE)InfName,
                            &Len)) {

            String strInfPath;

            if (strInfPath.GetSystemWindowsDirectory()) {

                //
                // Tack on an extra back slash if one is needed
                //
                if (_T('\\') != strInfPath[strInfPath.GetLength() - 1]) {
                    strInfPath += (LPCTSTR)TEXT("\\");
                }

                strInfPath += (LPCTSTR)TEXT("INF\\");
                strInfPath += (LPCTSTR)InfName;

                pMachine->GetInfDigitalSigner((LPCTSTR)strInfPath, m_DigitalSigner);
            }
        }
    }

    return TRUE;
}

BOOL
CDriver::BuildDriverList(
    BOOL             bFunctionAndFiltersOnly
    )
{
    SP_DRVINFO_DATA DrvInfoData;
    HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS DevInstParams;

    //
    // If we already built up the list of driver files then we don't need
    // to do it again.
    //
    if (m_DriverListBuilt) {
        return m_listDriverFile.GetCount();
    }

    ASSERT(m_pDevice);

    if (!m_OnLocalMachine) {
        AddFunctionAndFilterDrivers(m_pDevice);
        return m_listDriverFile.GetCount();
    }

    CMachine* pMachine = m_pDevice->m_pMachine;
    ASSERT(pMachine);

    hFileQueue = SetupOpenFileQueue();

    //
    // Only build up the list of files from the INF if bFunctionAndFiltersOnly
    // is not TRUE.
    //
    if (!bFunctionAndFiltersOnly) {
        DevInstParams.cbSize = sizeof(DevInstParams);

        pMachine->DiGetDeviceInstallParams(*m_pDevice, &DevInstParams);

        //
        // Set the DI_FLAGSEX_INSTALLEDDRIVER flag before calling SetupDiBuildDriverInfoList.
        // This will have it only put the installed driver into the list.
        //
        DevInstParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER |
                                  DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

        if (pMachine->DiSetDeviceInstallParams(*m_pDevice,
                           &DevInstParams) &&
            pMachine->DiBuildDriverInfoList(*m_pDevice,
                                            SPDIT_CLASSDRIVER)) {


            DrvInfoData.cbSize = sizeof(DrvInfoData);

            //
            // There should only be one driver in this list.  If there isn't any
            // drivers in this list then there must not be a driver currently
            // installed on this device.
            //
            if (pMachine->DiEnumDriverInfo(*m_pDevice, SPDIT_CLASSDRIVER, 0, &DrvInfoData)) {

                //
                // Set this as the selected driver
                //
                if (pMachine->DiSetSelectedDriver(*m_pDevice, &DrvInfoData)) {
                    //
                    // Get a list of all the files installed for this device
                    //
                    if (INVALID_HANDLE_VALUE != hFileQueue) {

                        DevInstParams.FileQueue = hFileQueue;
                        DevInstParams.Flags |= DI_NOVCP;

                        if (pMachine->DiSetDeviceInstallParams(*m_pDevice, &DevInstParams) &&
                            pMachine->DiCallClassInstaller(DIF_INSTALLDEVICEFILES, *m_pDevice)) {
                            //
                            // Dereference the file queue so that we can close it
                            //
                            DevInstParams.FileQueue = NULL;
                            DevInstParams.Flags &= ~DI_NOVCP;
                            pMachine->DiSetDeviceInstallParams(*m_pDevice, &DevInstParams);
                        }
                    }
                }

            } else {

                //
                // We did not find a match...so just destroy it.
                //
                pMachine->DiDestroyDriverInfoList(*m_pDevice,
                                                  SPDIT_CLASSDRIVER);
            }
        }
    }

    //
    // Add the funtion and device and class upper and lower filters, sometimes
    // these aren't added via the INF file directly so this makes sure they
    // show up in the list.
    //
    AddFunctionAndFilterDrivers(m_pDevice, hFileQueue);

    if (hFileQueue != INVALID_HANDLE_VALUE) {
        //
        // Scan the file queue.
        //
        DWORD ScanResult;
        SetupScanFileQueue(hFileQueue,
                           SPQ_SCAN_USE_CALLBACK_SIGNERINFO,
                           NULL,
                           ScanQueueCallback,
                           (PVOID)this,
                           &ScanResult
                           );

        //
        // Close the file queue
        //
        SetupCloseFileQueue(hFileQueue);
    }

    m_DriverListBuilt = TRUE;

    return m_listDriverFile.GetCount();
}

void
CDriver::AddDriverFile(
    CDriverFile* pNewDrvFile
    )
{
    //
    // Check to see if this driver already exists in the list.
    //
    POSITION pos = m_listDriverFile.GetHeadPosition();

    while (NULL != pos) {
        CDriverFile* pDrvFile = m_listDriverFile.GetNext(pos);

        if (lstrcmpi(pDrvFile->GetFullPathName(), pNewDrvFile->GetFullPathName()) == 0) {
            //
            // This file already exists in the list so just return without
            // adding it.
            //
            return;
        }
    }

    m_listDriverFile.AddTail(pNewDrvFile);
}

void
CDriver::AddFunctionAndFilterDrivers(
    CDevice* pDevice,
    HSPFILEQ hFileQueue
    )
{
    TCHAR ServiceName[MAX_PATH];
    ULONG BufferLen;
    HKEY hKey;
    DWORD regType;

    //
    // Get the function driver
    //
    if (pDevice->m_pMachine->DiGetDeviceRegistryProperty(*pDevice,
                     SPDRP_SERVICE,
                     NULL,
                     (PBYTE)ServiceName,
                     sizeof(ServiceName),
                     NULL
                     )) {
        CreateFromService(pDevice, ServiceName, hFileQueue);
    }

    //
    // Add the upper and lower device filters
    //
    for (int i = 0; i<2; i++) {
        BufferLen = 0;
        pDevice->m_pMachine->DiGetDeviceRegistryProperty(
                *pDevice,
                i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                NULL,
                NULL,
                BufferLen,
                &BufferLen
                );

        if (BufferLen != 0) {
            PTSTR Buffer = new TCHAR[BufferLen+2];

            if (Buffer) {
                ZeroMemory(Buffer, BufferLen+2);

                if (pDevice->m_pMachine->DiGetDeviceRegistryProperty(
                        *pDevice,
                        i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                        NULL,
                        (PBYTE)Buffer,
                        BufferLen,
                        &BufferLen
                        )) {
                    for (PTSTR SingleItem = Buffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {
                        CreateFromService(pDevice, SingleItem, hFileQueue);
                    }
                }

                delete [] Buffer;
            }
        }
    }

    //
    // Add the upper and lower class filters
    //
    GUID ClassGuid;
    pDevice->ClassGuid(ClassGuid);
    hKey = m_pDevice->m_pMachine->DiOpenClassRegKey(&ClassGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regClass(hKey);

        for (int i = 0; i<2; i++) {
            BufferLen = 0;
            regClass.GetValue(i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                              &regType,
                              NULL,
                              &BufferLen
                              );
            if (BufferLen != 0) {
                PTSTR Buffer = new TCHAR[BufferLen+2];

                if (Buffer) {
                    ZeroMemory(Buffer, BufferLen+2);

                    if (regClass.GetValue(i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                              &regType,
                              (PBYTE)Buffer,
                              &BufferLen
                              )) {
                        for (PTSTR SingleItem = Buffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {
                            CreateFromService(pDevice, SingleItem, hFileQueue);
                        }
                    }

                    delete [] Buffer;
                }
            }
        }
    }

}

void
CDriver::CreateFromService(
    CDevice* pDevice,
    PCTSTR ServiceName,
    HSPFILEQ hFileQueue
    )
{
    SC_HANDLE hscManager = NULL;
    SC_HANDLE hscService = NULL;

    if (!ServiceName) {
        return;
    }

    try
    {
        BOOL ComposePathNameFromServiceName = TRUE;

        hscManager = OpenSCManager(m_OnLocalMachine ? NULL : pDevice->m_pMachine->GetMachineFullName(),
                       NULL, GENERIC_READ);

        if (NULL != hscManager)
        {
            hscService =  OpenService(hscManager, ServiceName, GENERIC_READ);
            if (NULL != hscService)
            {
                DWORD BytesRequired;

                // first, probe for buffer size
                if (!QueryServiceConfig(hscService, NULL, 0, &BytesRequired) &&
                    ERROR_INSUFFICIENT_BUFFER == GetLastError())
                {
                    TCHAR FullPath[MAX_PATH];
                    BufferPtr<BYTE> BufPtr(BytesRequired);
                    LPQUERY_SERVICE_CONFIG pqsc;
                    pqsc = (LPQUERY_SERVICE_CONFIG)(PBYTE)BufPtr;
                    DWORD Size;

                    if (QueryServiceConfig(hscService, pqsc, BytesRequired, &Size) &&
                        pqsc->lpBinaryPathName &&
                        (TEXT('\0') != pqsc->lpBinaryPathName[0]))
                    {
                        ComposePathNameFromServiceName = FALSE;

                        //
                        // Make sure we have a valid full path.
                        //
                        if (GetFullPathFromImagePath(pqsc->lpBinaryPathName,
                                                     FullPath,
                                                     ARRAYLEN(FullPath))) {

                            if (hFileQueue != INVALID_HANDLE_VALUE) {
                                //
                                // Add the file to the queue.
                                //
                                TCHAR TargetPath[MAX_PATH];
                                StringCchCopy(TargetPath, ARRAYLEN(TargetPath), FullPath);
                                PTSTR p = (PTSTR)StrRChr(TargetPath, NULL, TEXT('\\'));
                                if (p) {
                                    *p = TEXT('\0');
                                }

                                SetupQueueCopy(hFileQueue,
                                               NULL,
                                               NULL,
                                               pSetupGetFileTitle(FullPath),
                                               NULL,
                                               NULL,
                                               TargetPath,
                                               NULL,
                                               0
                                               );
                            } else {
                                //
                                // No file queue was passed in so just manually
                                // add this to our list of driver files.
                                //
                                SafePtr<CDriverFile> DrvFilePtr;
                                CDriverFile* pDrvFile = new CDriverFile();
                                DrvFilePtr.Attach(pDrvFile);

                                //
                                // We will set the GetWin32Error to 0xFFFFFFFF which will
                                // cause the UI to say 'not available' for the
                                // signature.
                                //
                                if (pDrvFile->Create(FullPath,
                                                     m_OnLocalMachine,
                                                     0xFFFFFFFF,
                                                     NULL,
                                                     m_hSDBDrvMain))
                                {
                                    AddDriverFile(pDrvFile);
                                    DrvFilePtr.Detach();
                                }
                            }
                        }
                    }
                }

                CloseServiceHandle(hscService);
                hscService = NULL;
            }

            CloseServiceHandle(hscManager);
            hscManager = NULL;
        }

        if (ComposePathNameFromServiceName)
        {
            String strFullPathName;
            strFullPathName.GetSystemDirectory();
            strFullPathName += (LPCTSTR)TEXT("\\drivers\\");
            strFullPathName += (LPCTSTR)ServiceName;
            strFullPathName += (LPCTSTR)TEXT(".sys");

            if (hFileQueue != INVALID_HANDLE_VALUE) {
                //
                // Add the file to the queue.
                //
                String strTargetPath;
                strTargetPath = strFullPathName;
                PTSTR p = (PTSTR)StrRChr((LPCTSTR)strTargetPath, NULL, TEXT('\\'));
                if (p) {
                    *p = TEXT('\0');
                }

                SetupQueueCopy(hFileQueue,
                               NULL,
                               NULL,
                               pSetupGetFileTitle((LPCTSTR)strFullPathName),
                               NULL,
                               NULL,
                               strTargetPath,
                               NULL,
                               0
                               );
            } else {
                //
                // No file queue was passed in so just manually
                // add this to our list of driver files.
                //
                SafePtr<CDriverFile> DrvFilePtr;
                CDriverFile* pDrvFile = new CDriverFile();
                DrvFilePtr.Attach(pDrvFile);

                //
                // We will set the GetWin32Error to 0xFFFFFFFF which will
                // cause the UI to say 'not available' for the
                // signature.
                //
                if (pDrvFile->Create((LPCTSTR)strFullPathName,
                                     m_OnLocalMachine,
                                     0xFFFFFFFF,
                                     NULL,
                                     m_hSDBDrvMain))
                {
                    AddDriverFile(pDrvFile);
                    DrvFilePtr.Detach();
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        UNREFERENCED_PARAMETER(e);

        if (hscService)
        {
            CloseServiceHandle(hscService);
        }

        if (hscManager)
        {
            CloseServiceHandle(hscManager);
        }
        throw;
    }
}

CDriver::~CDriver()
{
    if (!m_listDriverFile.IsEmpty())
    {
        POSITION pos = m_listDriverFile.GetHeadPosition();

        while (NULL != pos) {
            CDriverFile* pDrvFile = m_listDriverFile.GetNext(pos);
            delete pDrvFile;
        }

        m_listDriverFile.RemoveAll();
    }

    if (m_hSDBDrvMain) {
        SdbReleaseDatabase(m_hSDBDrvMain);
    }
}

//
// Can not throw a exception from this function because it is a callback
//
UINT
CDriver::ScanQueueCallback(
    PVOID Context,
    UINT  Notification,
    UINT_PTR  Param1,
    UINT_PTR  Param2
    )
{
    UNREFERENCED_PARAMETER(Param2);

    try
    {
        if (SPFILENOTIFY_QUEUESCAN_SIGNERINFO == Notification && Param1)
        {
            CDriver* pDriver = (CDriver*)Context;

            if (pDriver)
            {
                SafePtr<CDriverFile> DrvFilePtr;
                CDriverFile* pDrvFile = new CDriverFile();
                DrvFilePtr.Attach(pDrvFile);

                //
                // When creating the CDriver set the Win32Error to 0xFFFFFFFF
                // if the user is loged in as a guest.  This is because we
                // cannot tell if a file is digitally signed if the user is
                // a guest.  If the user is not a guest then use the Win32Error
                // returned from setupapi.
                //
                if (pDrvFile->Create((LPCTSTR)((PFILEPATHS_SIGNERINFO)Param1)->Target,
                                     pDriver->IsLocal(),
                                     pDriver->m_pDevice->m_pMachine->IsUserAGuest()
                                       ? 0xFFFFFFFF
                                       : ((PFILEPATHS_SIGNERINFO)Param1)->Win32Error,
                                     ((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner,
                                     pDriver->m_hSDBDrvMain
                                     ))
                {
                    pDriver->AddDriverFile(pDrvFile);
                    DrvFilePtr.Detach();
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

BOOL
CDriver::GetFirstDriverFile(
    CDriverFile** ppDrvFile,
    PVOID&  Context
    )
{
    ASSERT(ppDrvFile);

    if (!m_listDriverFile.IsEmpty())
    {
        POSITION pos = m_listDriverFile.GetHeadPosition();
        *ppDrvFile = m_listDriverFile.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    Context = NULL;
    *ppDrvFile = NULL;

    return FALSE;
}

BOOL
CDriver::GetNextDriverFile(
    CDriverFile** ppDrvFile,
    PVOID&  Context
    )
{
    ASSERT(ppDrvFile);

    POSITION pos = (POSITION)Context;

    if (NULL != pos)
    {
        *ppDrvFile = m_listDriverFile.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppDrvFile = NULL;
    return FALSE;
}

void
CDriver::GetDriverSignerString(
    String& strDriverSigner
    )
{
    if (m_DigitalSigner.IsEmpty()) {

        strDriverSigner.LoadString(g_hInstance, IDS_NO_DIGITALSIGNATURE);

    } else {

        strDriverSigner = m_DigitalSigner;
    }
}

BOOL
CDriver::GetFullPathFromImagePath(
    LPCTSTR ImagePath,
    LPTSTR  FullPath,
    UINT    FullPathLength
    )
{
    TCHAR OriginalCurrentDirectory[MAX_PATH];
    LPTSTR pRelativeString;
    LPTSTR lpFilePart;

    if (!ImagePath || (ImagePath[0] == TEXT('\0'))) {
        return FALSE;
    }

    //
    // If we aren't on a local machine then just return the file name and not
    // the full path.
    //
    if (!m_OnLocalMachine) {
        if (SUCCEEDED(StringCchCopy(FullPath, FullPathLength, pSetupGetFileTitle(ImagePath)))) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    //
    // First check if the ImagePath happens to be a valid full path.
    //
    if (GetFileAttributes(ImagePath) != 0xFFFFFFFF) {
        ::GetFullPathName(ImagePath, FullPathLength, FullPath, &lpFilePart);
        return TRUE;
    }

    pRelativeString = (LPTSTR)ImagePath;

    //
    // If the ImagePath starts with "\SystemRoot" or "%SystemRoot%" then
    // remove those values.
    //
    if (StrCmpNI(ImagePath, TEXT("\\SystemRoot\\"), lstrlen(TEXT("\\SystemRoot\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("\\SystemRoot\\"));
    } else if (StrCmpNI(ImagePath, TEXT("%SystemRoot%\\"), lstrlen(TEXT("%SystemRoot%\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("%SystemRoot%\\"));
    }

    //
    // At this point pRelativeString should point to the image path relative to
    // the windows directory.
    //
    if (!GetSystemWindowsDirectory(FullPath, FullPathLength)) {
        return FALSE;
    }

    if (!GetCurrentDirectory(ARRAYLEN(OriginalCurrentDirectory), OriginalCurrentDirectory)) {
        OriginalCurrentDirectory[0] = TEXT('\0');
    }

    if (!SetCurrentDirectory(FullPath)) {
        return FALSE;
    }

    ::GetFullPathName(pRelativeString, FullPathLength, FullPath, &lpFilePart);

    if (OriginalCurrentDirectory[0] != TEXT('\0')) {
        SetCurrentDirectory(OriginalCurrentDirectory);
    }

    return TRUE;
}

BOOL
CDriverFile::Create(
    LPCTSTR ServiceName,
    BOOL LocalMachine,
    DWORD Win32Error,
    LPCTSTR DigitalSigner,
    HSDB hSDBDrvMain
    )
{
    if (!ServiceName || (TEXT('\0') == ServiceName[0]))
    {
        return FALSE;
    }

    m_Win32Error = Win32Error;

    if (DigitalSigner) {
        m_strDigitalSigner = DigitalSigner;
    }

    //
    // For remote machine, we can not verify if the driver file exits.
    // we only show the driver name.
    //
    if (LocalMachine) {
        m_Attributes = GetFileAttributes(ServiceName);

        if (0xFFFFFFFF != m_Attributes) {
            m_strFullPathName = ServiceName;

        } else {
            //
            // The driver is a service. Do not search for the current director --
            // GetFullPathName is useless here.
            // Search for Windows dir and System directory
            //
            String strBaseDir;

            if (strBaseDir.GetSystemWindowsDirectory()) {

                if (_T('\\') != strBaseDir[strBaseDir.GetLength() - 1]) {
                    strBaseDir += (LPCTSTR)TEXT("\\");
                }

                strBaseDir += (LPCTSTR)pSetupGetFileTitle(ServiceName);
                m_Attributes = GetFileAttributes((LPCTSTR)strBaseDir);

                if (0xFFFFFFFF == m_Attributes)
                {
                    if (strBaseDir.GetSystemDirectory()) {

                        if (_T('\\') != strBaseDir[strBaseDir.GetLength() - 1]) {
                            strBaseDir += (LPCTSTR)TEXT("\\");
                        }

                        strBaseDir += (LPCTSTR)pSetupGetFileTitle(ServiceName);
                        m_Attributes = GetFileAttributes(strBaseDir);
                    }
                }

                //
                // hopeless, we could find the path
                //
                if (0xFFFFFFFF == m_Attributes)
                {
                    return FALSE;
                }

                m_strFullPathName = strBaseDir;

            } else {

                return FALSE;
            }
        }

        m_HasVersionInfo = GetVersionInfo();
    }

    else {
        m_strFullPathName = ServiceName;

        //
        //we do not have version info
        //
        m_HasVersionInfo = FALSE;
    }

    if (!m_strFullPathName.IsEmpty() && hSDBDrvMain != NULL) {
        TAGREF tagref = TAGREF_NULL;
        HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;
        SDBENTRYINFO entryinfo;
        DWORD cbSize;

        tagref = SdbGetDatabaseMatch(hSDBDrvMain,
                                     (LPTSTR)m_strFullPathName,
                                     INVALID_HANDLE_VALUE,
                                     NULL,
                                     0
                                     );

        if (tagref != TAGREF_NULL) {
            //
            // This driver is in the database.
            //
            m_IsDriverBlocked = TRUE;

            //
            // Call SdbReadDriverInformation to get the database GUID and the
            // driver GUID for this entry.
            //
            ZeroMemory(&entryinfo, sizeof(entryinfo));
            if (SdbReadDriverInformation(hSDBDrvMain,
                                         tagref,
                                         &entryinfo)) {
                //
                // Open up the App help information database and query for the
                // html link.
                //
                hAppHelpInfoContext = SdbOpenApphelpInformation(&(entryinfo.guidDB),
                                                                &(entryinfo.guidID));

                if (hAppHelpInfoContext) {

                    cbSize = 0;
                    PBYTE pBuffer = NULL;

                    cbSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                        ApphelpHelpCenterURL,
                                                        NULL,
                                                        0);

                    if (cbSize &&
                        ((pBuffer = new BYTE[cbSize]) != NULL)) {

                        cbSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                            ApphelpHelpCenterURL,
                                                            (LPVOID)pBuffer,
                                                            cbSize);

                        if (cbSize) {
                            m_strHtmlHelpID = (LPTSTR)pBuffer;
                        }

                        delete [] pBuffer;
                    }

                    SdbCloseApphelpInformation(hAppHelpInfoContext);
                }
            }
        }
    }

    return TRUE;
}

BOOL
CDriverFile::GetVersionInfo()
{
    DWORD Size, dwHandle;

    Size = GetFileVersionInfoSize((LPTSTR)(LPCTSTR)m_strFullPathName, &dwHandle);

    if (!Size)
    {
        return FALSE;
    }

    BufferPtr<BYTE> BufPtr(Size);
    PVOID pVerInfo = BufPtr;

    if (GetFileVersionInfo((LPTSTR)(LPCTSTR)m_strFullPathName, dwHandle, Size,
                pVerInfo))
    {
        // get VarFileInfo\Translation
        PVOID pBuffer;
        UINT Len;
        String strStringFileInfo;

        if (!VerQueryValue(pVerInfo, (LPTSTR)tszTranslation, &pBuffer, &Len))
        {
            strStringFileInfo = tszStringFileInfoDefault;
        }

        else
        {
            strStringFileInfo.Format(tszStringFileInfo, *((WORD*)pBuffer),
                         *(((WORD*)pBuffer) + 1));
        }

        String str;
        str = strStringFileInfo + tszFileVersion;

        if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len))
        {
            m_strVersion = (LPTSTR)pBuffer;
            str = strStringFileInfo + tszLegalCopyright;

            if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len))
            {
                m_strCopyright = (LPTSTR)pBuffer;
                str = strStringFileInfo + tszCompanyName;

                if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len))
                {
                    m_strProvider = (LPTSTR)pBuffer;
                }
            }
        }
    }

    return TRUE;
}


BOOL
CDriverFile::operator ==(
    CDriverFile& OtherDrvFile
    )
{
    return \
       m_HasVersionInfo == OtherDrvFile.HasVersionInfo() &&
       (GetFullPathName() == OtherDrvFile.GetFullPathName() ||
        (GetFullPathName() && OtherDrvFile.GetFullPathName() &&
         !lstrcmpi(GetFullPathName(), OtherDrvFile.GetFullPathName())
        )
       ) &&
       (GetProvider() == OtherDrvFile.GetProvider() ||
        (GetProvider() && OtherDrvFile.GetProvider() &&
         !lstrcmpi(GetProvider(), OtherDrvFile.GetProvider())
        )
       ) &&
       (GetCopyright() == OtherDrvFile.GetCopyright() ||
        (GetCopyright() && OtherDrvFile.GetCopyright() &&
         !lstrcmpi(GetCopyright(), OtherDrvFile.GetCopyright())
        )
       ) &&
       (GetVersion() == OtherDrvFile.GetVersion() ||
        (GetVersion() && OtherDrvFile.GetVersion() &&
         !lstrcmpi(GetVersion(), OtherDrvFile.GetVersion())
        )
       );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\cfolder.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    cfolder.cpp

Abstract:

    This module implements CFolder and its releated classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "clsgenpg.h"
#include "devgenpg.h"
#include "devdrvpg.h"
#include "devpopg.h"
#include "devdetpg.h"
#include "hwprof.h"
#include "devrmdlg.h"
#include "printer.h"
#include <devguid.h>
#include <initguid.h>
#include <oleacc.h>


const TCHAR* OCX_TREEVIEW = TEXT("{CD6C7868-5864-11D0-ABF0-0020AF6B0B7A}");

const MMCMENUITEM ViewDevicesMenuItems[TOTAL_VIEWS] =
{
    {IDS_VIEW_DEVICESBYTYPE, IDS_MENU_STATUS_DEVBYTYPE, IDM_VIEW_DEVICESBYTYPE, VIEW_DEVICESBYTYPE},
    {IDS_VIEW_DEVICESBYCONNECTION, IDS_MENU_STATUS_DEVBYCONNECTION, IDM_VIEW_DEVICESBYCONNECTION, VIEW_DEVICESBYCONNECTION},
    {IDS_VIEW_RESOURCESBYTYPE, IDS_MENU_STATUS_RESBYTYPE, IDM_VIEW_RESOURCESBYTYPE, VIEW_RESOURCESBYTYPE},
    {IDS_VIEW_RESOURCESBYCONNECTION, IDS_MENU_STATUS_RESBYCONNECTION, IDM_VIEW_RESOURCESBYCONNECTION, VIEW_RESOURCESBYCONNECTION}
};

const RESOURCEID ResourceTypes[TOTAL_RESOURCE_TYPES] =
{
    ResType_Mem,
    ResType_IO,
    ResType_DMA,
    ResType_IRQ
};


///////////////////////////////////////////////////////////////////
/// CScopeItem implementations
///

BOOL
CScopeItem::Create()
{
    m_strName.LoadString(g_hInstance, m_iNameStringId);
    m_strDesc.LoadString(g_hInstance, m_iDescStringId);
    return TRUE;
}

HRESULT
CScopeItem::GetDisplayInfo(
                          LPSCOPEDATAITEM pScopeDataItem
                          )
{
    if (!pScopeDataItem) {
        return E_INVALIDARG;
    }

    if (SDI_STR & pScopeDataItem->mask) {
        pScopeDataItem->displayname = (LPTSTR)(LPCTSTR)m_strName;
    }

    if (SDI_IMAGE & pScopeDataItem->mask) {
        pScopeDataItem->nImage = m_iImage;
    }

    if (SDI_OPENIMAGE & pScopeDataItem->mask) {
        pScopeDataItem->nOpenImage = m_iOpenImage;
    }

    return S_OK;
}

BOOL
CScopeItem::EnumerateChildren(
                             int Index,
                             CScopeItem** ppScopeItem
                             )
{
    if (!ppScopeItem || Index >= m_listChildren.GetCount()) {
        return FALSE;
    }

    POSITION pos = m_listChildren.FindIndex(Index);
    *ppScopeItem = m_listChildren.GetAt(pos);

    return TRUE;
}

HRESULT
CScopeItem::Reset()
{
    //
    // We have not enumerated!
    //
    m_Enumerated = FALSE;

    //
    // If there are folders created from this scope item,
    // walk through all of them and tell each one
    // to reset the cached machine object
    //
    HRESULT hr = S_OK;

    if (!m_listFolder.IsEmpty()) {
        CFolder* pFolder;
        POSITION pos = m_listFolder.GetHeadPosition();

        while (NULL != pos) {
            pFolder = m_listFolder.GetNext(pos);
            hr = pFolder->Reset();
        }
    }

    return hr;
}

CCookie*
CScopeItem::FindSelectedCookieData(
                                  CResultView** ppResultView
                                  )
{
    CFolder* pFolder;
    CResultView* pResultView;

    //
    // This routine returns the Selected Cookie in the result view if it has
    // the focus.  This is done by locating the folder from the scopeitem.
    // If the folder is not selected, the current result view is accessed to
    // get the current selected cookie.  If any of these fail a NULL value is
    // returned.  Optionally the current CResultView class is returned.
    //
    POSITION pos = m_listFolder.GetHeadPosition();

    while (NULL != pos) {
        pFolder = m_listFolder.GetNext(pos);

        if (this == pFolder->m_pScopeItem) {
            if (!pFolder->m_bSelect &&
                (pResultView = pFolder->GetCurResultView()) != NULL) {
                if (ppResultView) {
                    *ppResultView = pResultView;
                }

                return pResultView->GetSelectedCookie();
            }
        }
    }

    return NULL;
}

CScopeItem::~CScopeItem()
{
    if (!m_listChildren.IsEmpty()) {
        CScopeItem* pChild;
        POSITION pos;

        pos = m_listChildren.GetHeadPosition();

        while (NULL != pos) {
            pChild = m_listChildren.GetNext(pos);
            delete pChild;
        }

        m_listChildren.RemoveAll();
    }

    if (!m_listFolder.IsEmpty()) {
        POSITION pos;
        pos = m_listFolder.GetHeadPosition();

        while (NULL != pos) {
            //
            // DO NOT delete it!!!!
            //
            (m_listFolder.GetNext(pos))->Release();
        }

        m_listFolder.RemoveAll();
    }
}

CFolder*
CScopeItem::CreateFolder(
                        CComponent* pComponent
                        )
{
    ASSERT(pComponent);

    CFolder* pFolder;
    pFolder = new CFolder(this, pComponent);

    if (pFolder) {
        m_listFolder.AddTail(pFolder);
        pFolder->AddRef();
    }

    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return pFolder;
}

HRESULT
CScopeItem::AddMenuItems(
                        LPCONTEXTMENUCALLBACK pCallback,
                        long* pInsertionAllowed
                        )
{
    CCookie* pSelectedCookie;
    CResultView* pResultView;

    if ((pSelectedCookie = FindSelectedCookieData(&pResultView)) != NULL) {
        //
        // Add menu items for the Action menu.
        //
        return pResultView->AddMenuItems(pSelectedCookie, pCallback,
                                         pInsertionAllowed, FALSE);
    }

    else {
        return S_OK;
    }
}

HRESULT
CScopeItem::MenuCommand(
                       long lCommandId
                       )
{
    CCookie* pSelectedCookie;
    CResultView* pResultView;

    if ((pSelectedCookie = FindSelectedCookieData(&pResultView)) != NULL) {
        //
        // Handle menu requests for the Action menu.
        //
        return pResultView->MenuCommand(pSelectedCookie, lCommandId);
    }

    else {
        return S_OK;
    }
}

HRESULT
CScopeItem::QueryPagesFor()
{
    //
    // We do not have property pages for scope item
    //
    CCookie* pSelectedCookie;

    if ((pSelectedCookie = FindSelectedCookieData(NULL)) != NULL) {
        return S_OK;
    }

    else {
        return S_FALSE;
    }
}

HRESULT
CScopeItem::CreatePropertyPages(
                               LPPROPERTYSHEETCALLBACK lpProvider,
                               LONG_PTR handle
                               )
{
    CCookie* pSelectedCookie;
    CResultView* pResultView;

    if ((pSelectedCookie = FindSelectedCookieData(&pResultView)) != NULL) {
        return pResultView->CreatePropertyPages(pSelectedCookie, lpProvider, handle);
    }

    else {
        return S_OK;
    }
}


///////////////////////////////////////////////////////////////////
/// CFolder implementations
///

CFolder::CFolder(
                CScopeItem* pScopeItem,
                CComponent* pComponent
                )
{
    ASSERT(pScopeItem && pComponent);

    m_pScopeItem = pScopeItem;
    m_pComponent = pComponent;
    m_Show = FALSE;
    m_pMachine = NULL;
    m_bSelect = FALSE;
    m_pOleTaskString = NULL;
    m_Ref = 0;
    m_FirstTimeOnShow = TRUE;
    m_Signature = FOLDER_SIGNATURE_DEVMGR;
    m_pViewTreeByType = NULL;
    m_pViewTreeByConnection = NULL;
    m_pViewResourcesByType = NULL;
    m_pViewResourcesByConnection = NULL;
    m_CurViewType = VIEW_DEVICESBYTYPE;
    m_pCurView = m_pViewTreeByType;
    m_ShowHiddenDevices = FALSE;
}

CFolder::~CFolder()
{
    if (m_pViewTreeByType) {
        delete m_pViewTreeByType;
    }

    if (m_pViewTreeByConnection) {
        delete m_pViewTreeByConnection;
    }

    if (m_pViewResourcesByType) {
        delete m_pViewResourcesByType;
    }

    if (m_pViewResourcesByConnection) {
        delete m_pViewResourcesByConnection;
    }
}

HRESULT
CFolder::Compare(
                MMC_COOKIE cookieA,
                MMC_COOKIE cookieB,
                int  nCol,
                int* pnResult
                )
{
    UNREFERENCED_PARAMETER(cookieA);
    UNREFERENCED_PARAMETER(cookieB);
    UNREFERENCED_PARAMETER(nCol);
    
    ASSERT(pnResult);

    //
    // We do not have anything in the result pane, thus
    // comparision makes no sense.
    //
    *pnResult = 0;

    return S_OK;
}

HRESULT
CFolder::GetDisplayInfo(
                       LPRESULTDATAITEM pResultDataItem
                       )
{
    if (!pResultDataItem) {
        return E_POINTER;
    }

    ASSERT(m_pScopeItem);

    //
    // This only take care of scope pane item (displaying scope pane node
    // on the result pane). The derived classes should take care of
    // result items.
    //
    if (RDI_STR & pResultDataItem->mask) {
        if (0 == pResultDataItem->nCol) {
            if (m_pOleTaskString)
                FreeOleTaskString(m_pOleTaskString);
            m_pOleTaskString = AllocOleTaskString(m_pScopeItem->GetNameString());

            if (m_pOleTaskString) {
                pResultDataItem->str = m_pOleTaskString;
            }

            else {
                m_strScratch = m_pScopeItem->GetNameString();
                pResultDataItem->str = (LPTSTR)(LPCTSTR)m_strScratch;
            }
        }

        else if (2 == pResultDataItem->nCol) {
            if (m_pOleTaskString) {
                FreeOleTaskString(m_pOleTaskString);
            }

            m_pOleTaskString = AllocOleTaskString(m_pScopeItem->GetDescString());

            if (m_pOleTaskString) {
                pResultDataItem->str = m_pOleTaskString;
            }

            else {
                m_strScratch = m_pScopeItem->GetDescString();
                pResultDataItem->str = (LPTSTR)(LPCTSTR)m_strScratch;
            }
        }

        else {
            return S_FALSE;
        }
    }

    if (RDI_IMAGE & pResultDataItem->mask) {
        pResultDataItem->nImage = m_pScopeItem->GetImageIndex();
    }

    return S_OK;
}

HRESULT
CFolder::AddMenuItems(
                     CCookie* pCookie,
                     LPCONTEXTMENUCALLBACK pCallback,
                     long* pInsertionAllowed
                     )
{
    ASSERT(pCookie);

    HRESULT hr = S_OK;

    //
    // If the cookie points to a scope item, add view menu items
    //
    if (NULL == pCookie->GetResultItem()) {

        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) {
            long Flags;

            for (int i = 0; i < TOTAL_VIEWS; i++) {
                if (m_CurViewType == ViewDevicesMenuItems[i].Type) {
                    Flags = MF_ENABLED | MF_CHECKED | MFT_RADIOCHECK;
                }

                else {
                    Flags = MF_ENABLED;
                }

                hr = AddMenuItem(pCallback,
                                 ViewDevicesMenuItems[i].idName,
                                 ViewDevicesMenuItems[i].idStatusBar,
                                 ViewDevicesMenuItems[i].lCommandId,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                                 Flags,
                                 0);
                if (FAILED(hr)) {
                    break;
                }
            }

            //
            // Add "Show hidden devices" menu item
            //
            if (SUCCEEDED(hr)) {
                hr = AddMenuItem(pCallback, 0, 0, 0, CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                                 MF_ENABLED, CCM_SPECIAL_SEPARATOR);

                if (SUCCEEDED(hr)) {
                    if (m_ShowHiddenDevices) {
                        Flags = MF_ENABLED | MF_CHECKED;
                    }

                    else {
                        Flags = MF_ENABLED;
                    }

                    hr = AddMenuItem(pCallback, IDS_SHOW_ALL, IDS_MENU_STATUS_HIDDEN_DEVICES, IDM_SHOW_ALL,
                                     CCM_INSERTIONPOINTID_PRIMARY_VIEW, Flags, 0);
                }
            }
        }
    }

    else {
        if (m_pCurView) {
            //
            // Add menu items for the Context menu in the result pane.
            //
            hr = m_pCurView->AddMenuItems(pCookie, pCallback,
                                          pInsertionAllowed, TRUE);
        }

        else {
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT
CFolder::MenuCommand(
                    CCookie* pCookie,
                    long lCommandId
                    )
{
    if (NULL == pCookie->GetResultItem()) {
        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        //
        // Convert menu id to view type;
        //
        VIEWTYPE ViewType = m_CurViewType;
        BOOL fShowHiddenDevices = m_ShowHiddenDevices;

        switch (lCommandId) {
        case IDM_VIEW_DEVICESBYTYPE:
            ViewType = VIEW_DEVICESBYTYPE;
            break;

        case IDM_VIEW_DEVICESBYCONNECTION:
            ViewType = VIEW_DEVICESBYCONNECTION;
            break;

        case IDM_VIEW_RESOURCESBYTYPE:
            ViewType = VIEW_RESOURCESBYTYPE;
            break;

        case IDM_VIEW_RESOURCESBYCONNECTION:
            ViewType = VIEW_RESOURCESBYCONNECTION;
            break;

        case IDM_SHOW_ALL:
            fShowHiddenDevices = !fShowHiddenDevices;
            break;

        default:
            //not view menu. do nothing
            return S_OK;
            break;
        }

        if (!SelectView(ViewType, fShowHiddenDevices)) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        //
        // Reselect the scopeitem
        //
        return m_pComponent->m_pConsole->SelectScopeItem(*m_pScopeItem);
    }

    else {
        if (m_pCurView) {
            //
            // Handle menu requests for the Context menu in the result pane.
            //
            return m_pCurView->MenuCommand(pCookie, lCommandId);
        }

        else {
            return S_OK;
        }
    }
}

HRESULT
CFolder::QueryPagesFor(
                      CCookie* pCookie
                      )
{
    //
    // We do not have property pages for scope item
    //
    if (NULL == pCookie->GetResultItem()) {
        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        return S_FALSE;
    }

    //
    // The cookie points to result item, let the current
    // view handle it
    //
    if (m_pCurView) {
        return m_pCurView->QueryPagesFor(pCookie);
    }

    else {
        return S_FALSE;
    }
}

HRESULT
CFolder::CreatePropertyPages(
                            CCookie* pCookie,
                            LPPROPERTYSHEETCALLBACK lpProvider,
                            LONG_PTR handle
                            )
{
    if (NULL == pCookie->GetResultItem()) {
        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        return S_OK;
    }

    if (m_pCurView) {
        return m_pCurView->CreatePropertyPages(pCookie, lpProvider, handle);
    }

    else {
        return S_OK;
    }
}

BOOL
CFolder::SelectView(
                   VIEWTYPE ViewType,
                   BOOL     fShowHiddenDevices
                   )
{
    CResultView* pNewView;

    if (m_CurViewType == ViewType &&
        m_ShowHiddenDevices == fShowHiddenDevices &&
        m_pCurView) {
        return TRUE;
    }

    switch (ViewType) {
    case VIEW_DEVICESBYTYPE:
        if (!m_pViewTreeByType) {
            m_pViewTreeByType = new CViewTreeByType();

            if (m_pViewTreeByType) {

                m_pViewTreeByType->SetFolder(this);
            }
        }

        pNewView = m_pViewTreeByType;
        break;

    case VIEW_DEVICESBYCONNECTION:
        if (!m_pViewTreeByConnection) {
            m_pViewTreeByConnection = new CViewTreeByConnection();

            if (m_pViewTreeByConnection) {

                m_pViewTreeByConnection->SetFolder(this);
            }
        }

        pNewView = m_pViewTreeByConnection;
        break;

    case VIEW_RESOURCESBYTYPE:
        if (!m_pViewResourcesByType) {
            m_pViewResourcesByType = new CViewResourceTree(IDS_STATUS_RESOURCES_BYTYPE);

            if (m_pViewResourcesByType) {

                m_pViewResourcesByType->SetFolder(this);
            }
        }

        pNewView = m_pViewResourcesByType;
        break;

    case VIEW_RESOURCESBYCONNECTION:
        if (!m_pViewResourcesByConnection) {
            m_pViewResourcesByConnection = new CViewResourceTree(IDS_STATUS_RESOURCES_BYCONN);

            if (m_pViewResourcesByConnection) {

                m_pViewResourcesByConnection->SetFolder(this);
            }
        }

        pNewView = m_pViewResourcesByConnection;
        break;

    default:
        pNewView = NULL;
        break;
    }

    if (pNewView) {
        //
        // Let the view know that it is being diselected.
        //
        if (m_pCurView) {
            if (m_CurViewType != ViewType) {
                m_pComponent->SetDirty();
            }
        }

        //
        // Let the new active view know that it is being selected.
        //
        m_pCurView = pNewView;
        m_CurViewType = ViewType;
        m_ShowHiddenDevices = fShowHiddenDevices;
    }

    return TRUE;
}

HRESULT
CFolder::OnShow(
               BOOL fShow
               )
{
    if (fShow && !m_pMachine) {

        ASSERT(m_pComponent);

        if (!m_pComponent->AttachFolderToMachine(this, &m_pMachine)) {
            
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    m_Show = fShow;

    if (m_pMachine) {

        if (!SelectView(m_CurViewType, m_ShowHiddenDevices)) {
            
            return E_UNEXPECTED;
        }

        if (m_pCurView) {
            
            if (m_FirstTimeOnShow && m_Show) {
                
                int ReturnValue;

                //
                // Subsequent calls are not the first time anymore.
                //
                m_FirstTimeOnShow = FALSE;

                //
                // This is the first time we show the folder.
                // Put up a message box to warn user if
                // (1) The machine is a remote machine or
                // (2) The user does not have the Adminstator privilege.
                // (3) We can not connect to the remote machine
                //
                ASSERT(m_pComponent && m_pComponent->m_pConsole);

                //
                // Connect to a remote machine
                //
                if (!m_pMachine->IsLocal()) {
                    
                    if (!VerifyMachineName(m_pMachine->GetRemoteMachineFullName())) {
                        //
                        // Display a warning if we cannot connect to the remote machine
                        //
                        String strWarningFormat;
                        String strWarningMsg;
                        LPVOID lpLastError = NULL;

                        if (strWarningFormat.LoadString(g_hInstance, IDS_INVALID_COMPUTER_NAME) &&
                            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                          FORMAT_MESSAGE_FROM_SYSTEM | 
                                          FORMAT_MESSAGE_IGNORE_INSERTS,
                                          NULL,
                                          GetLastError(),
                                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                          (LPTSTR)&lpLastError,
                                          0,
                                          NULL)) {

                            strWarningMsg.Format((LPTSTR)strWarningFormat,
                                      m_pMachine->GetMachineDisplayName(), 
                                      lpLastError);

                            m_pComponent->m_pConsole->MessageBox((LPTSTR)strWarningMsg,
                                                                 (LPCTSTR)g_strDevMgr,
                                                                 MB_ICONERROR | MB_OK,
                                                                 &ReturnValue);
                        }

                        if (lpLastError) {

                            LocalFree(lpLastError);
                        }
                    } else {
                        //
                        // Otherwise display a warning that we are connect to a remote machine and
                        // device manager will run in a neutered mode.
                        //
                        String strMsg;
                        String strWarningMsg;
                        
                        if (strMsg.LoadString(g_hInstance, IDS_REMOTE_WARNING2) &&
                            strWarningMsg.LoadString(g_hInstance, IDS_REMOTE_WARNING1)) {
                            
                            strWarningMsg += strMsg;
                            m_pComponent->m_pConsole->MessageBox((LPCTSTR)strWarningMsg,
                                                                 (LPCTSTR)g_strDevMgr,
                                                                 MB_ICONEXCLAMATION | MB_OK,
                                                                 &ReturnValue);
                        }
                    }
                } else if (!g_IsAdmin) {
                    //
                    // If we are running locally but the user does not have 
                    // sufficient privileges then tell the user we will run
                    // in read-only mode.
                    //
                    String strWarningMsg;
                    strWarningMsg.LoadString(g_hInstance, IDS_NOADMIN_WARNING);
                    m_pComponent->m_pConsole->MessageBox(strWarningMsg,
                                                         (LPCTSTR)g_strDevMgr,
                                                         MB_ICONEXCLAMATION | MB_OK,
                                                         &ReturnValue);
                }
            }

            return m_pCurView->OnShow(fShow);
        }
    }

    return S_OK;
}

HRESULT
CFolder::OnRestoreView(
                      BOOL* pfHandled
                      )
{
    ASSERT(pfHandled);

    if (!pfHandled) {
        return E_INVALIDARG;
    }

    HRESULT hr = OnShow(TRUE);

    if (SUCCEEDED(hr)) {
        *pfHandled = TRUE;
    }

    return hr;
}

HRESULT
CFolder::GetResultViewType(
                          LPOLESTR* ppViewType,
                          long*     pViewOptions
                          )
{
    ASSERT(pViewOptions);

    if (!SelectView(m_CurViewType, m_ShowHiddenDevices)) {
        return E_UNEXPECTED;
    }

    if (m_pCurView) {
        return m_pCurView->GetResultViewType(ppViewType, pViewOptions);
    }

    *pViewOptions  = MMC_VIEW_OPTIONS_NONE;

    return S_FALSE;
}

HRESULT
CFolder::Reset()
{
    //
    // Delete all views so that we will create new ones
    // when OnShow is called.
    //
    if (m_pViewTreeByType) {
        delete m_pViewTreeByType;
        m_pViewTreeByType = NULL;
    }

    if (m_pViewTreeByConnection) {
        delete m_pViewTreeByConnection;
        m_pViewTreeByConnection = NULL;
    }

    if (m_pViewResourcesByType) {
        delete m_pViewResourcesByType;
        m_pViewResourcesByType = NULL;
    }

    if (m_pViewResourcesByConnection) {
        delete m_pViewResourcesByConnection;
        m_pViewResourcesByConnection = NULL;
    }

    m_pCurView = NULL;
    m_FirstTimeOnShow = TRUE;
    m_pMachine = NULL;

    return S_OK;
}

HRESULT
CFolder::MachinePropertyChanged(
                               CMachine* pMachine
                               )
{
    //
    // Ignore the tvNotify(SELCHANGED) messages while the tree is changed.
    //
    if (m_pCurView) {
        m_pCurView->SetSelectOk(FALSE);
    }

    if (pMachine) {
        m_pMachine = pMachine;
    }

    if (m_pViewTreeByType) {
        m_pViewTreeByType->MachinePropertyChanged(pMachine);
    }

    if (m_pViewTreeByConnection) {
        m_pViewTreeByConnection->MachinePropertyChanged(pMachine);
    }

    if (m_pViewResourcesByType) {
        m_pViewResourcesByType->MachinePropertyChanged(pMachine);
    }

    if (m_pViewResourcesByConnection) {
        m_pViewResourcesByConnection->MachinePropertyChanged(pMachine);
    }

    if (m_pCurView) {
        m_pCurView->SetSelectOk(TRUE);
    }

    if (m_Show && pMachine) {
        OnShow(TRUE);
    }

    return S_OK;
}

HRESULT
CFolder::GetPersistData(
                       PBYTE pBuffer,
                       int BufferSize
                       )
{
    DEVMGRFOLDER_STATES states;
    states.Type = COOKIE_TYPE_SCOPEITEM_DEVMGR;
    states.CurViewType = m_CurViewType;
    states.ShowHiddenDevices = m_ShowHiddenDevices;

    if (BufferSize && !pBuffer) {
        return E_INVALIDARG;
    }

    if (BufferSize >= sizeof(states)) {
        ::memcpy(pBuffer, &states, sizeof(states));
        return S_OK;
    }

    return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
}

HRESULT
CFolder::SetPersistData(
                       PBYTE pData,
                       int Size
                       )
{
    if (!pData) {
        return E_POINTER;
    }

    if (!Size) {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    PDEVMGRFOLDER_STATES pStates = (PDEVMGRFOLDER_STATES)pData;

    if (COOKIE_TYPE_SCOPEITEM_DEVMGR == pStates->Type) {
        if ((VIEW_DEVICESBYTYPE == pStates->CurViewType) ||
            (VIEW_DEVICESBYCONNECTION == pStates->CurViewType) ||
            (VIEW_RESOURCESBYTYPE == pStates->CurViewType) ||
            (VIEW_RESOURCESBYCONNECTION == pStates->CurViewType)) {
            m_CurViewType = pStates->CurViewType;

            if (m_pCurView) {
                m_pCurView->OnShow(TRUE);
            }

            m_ShowHiddenDevices = pStates->ShowHiddenDevices;

            return S_OK;
        }
    }

    return E_UNEXPECTED;
}

HRESULT
CFolder::tvNotify(
                 HWND hwndTV,
                 CCookie* pCookie,
                 TV_NOTIFY_CODE Code,
                 LPARAM arg,
                 LPARAM param
                 )
{
    if (m_pCurView) {
        return m_pCurView->tvNotify(hwndTV, pCookie, Code, arg, param);
    }

    else {
        return S_FALSE;
    }
}

HRESULT
CFolder::OnOcxNotify(
                    MMC_NOTIFY_TYPE event,
                    LPARAM arg,
                    LPARAM param
                    )
{
    if (m_pCurView) {
        return m_pCurView->OnOcxNotify(event, arg, param);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//// CResultView implementations
////

CResultView::~CResultView()
{
    if (m_pCookieComputer) {
        if (m_pIDMTVOCX) {
            m_pIDMTVOCX->DeleteAllItems();
        }

        delete m_pCookieComputer;
    }

    if (m_pIDMTVOCX) {
        m_pIDMTVOCX->Release();
    }

    DestroySavedTreeStates();
}

HRESULT
CResultView::OnShow(
                   BOOL fShow
                   )
{
    if (!fShow) {
        return S_OK;
    }

    SafeInterfacePtr<IUnknown> pUnk;
    HRESULT hr;
    CComponent* pComponent = m_pFolder->m_pComponent;
    ASSERT(pComponent);
    ASSERT(pComponent->m_pConsole);

    hr  = S_OK;

    if (NULL == m_pIDMTVOCX) {
        hr = pComponent->m_pConsole->QueryResultView(&pUnk);

        if (SUCCEEDED(hr)) {
            //
            // Get our OCX private interface
            //
            hr = pUnk->QueryInterface(IID_IDMTVOCX, (void**)&m_pIDMTVOCX);
        }

        if (SUCCEEDED(hr)) {
            m_pIDMTVOCX->Connect(pComponent, (MMC_COOKIE)this);
            m_hwndTV = m_pIDMTVOCX->GetWindowHandle();
            m_pIDMTVOCX->SetActiveConnection((MMC_COOKIE)this);
            
            //
            // Set up the annotation map for screen readers.
            //
            IAccPropServices *pAccPropSvc = NULL;
            hr = CoCreateInstance(CLSID_AccPropServices, 
                                  NULL,
                                  CLSCTX_SERVER,
                                  IID_IAccPropServices,
                                  (void**)&pAccPropSvc);
            
            if ((hr == S_OK) && pAccPropSvc) {
                pAccPropSvc->SetHwndPropStr(m_hwndTV, (DWORD)OBJID_CLIENT, 0, PROPID_ACC_DESCRIPTIONMAP, (LPTSTR)m_stringAnnotationMap);
                pAccPropSvc->Release();
            }
            
            DisplayTree();

            String strStartupCommand;
            String strStartupDeviceId;

            strStartupCommand = GetStartupCommand();
            strStartupDeviceId = GetStartupDeviceId();

            if (!strStartupCommand.IsEmpty() && !strStartupDeviceId.IsEmpty() &&
                !strStartupCommand.CompareNoCase(DEVMGR_COMMAND_PROPERTY)) {
                hr = DoProperties(m_hwndTV, m_pSelectedCookie);
            }
        }
    }

    else {
        m_pIDMTVOCX->SetActiveConnection((MMC_COOKIE)this);

        if (!DisplayTree()) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

inline
LPCTSTR
CResultView::GetStartupDeviceId()
{
    return m_pFolder->m_pComponent->GetStartupDeviceId();
}

inline
LPCTSTR
CResultView::GetStartupCommand()
{
    return m_pFolder->m_pComponent->GetStartupCommand();
}

//
// This function is called when  machine states have changed.
//
// INPUT:
//      pMachine -- if NULL, the machine is being destroy.
//
// OUTPUT:
//      stanard OLE return code
HRESULT
CResultView::MachinePropertyChanged(
                                   CMachine* pMachine
                                   )
{
    if (pMachine) {
        m_pMachine = pMachine;
    }

    else {
        //
        // pMachine is NULL, the CMachine we associated with is being destroyed.
        //
        if (m_pCookieComputer) {
            ASSERT(!m_pSelectedItem && m_listExpandedItems.IsEmpty());

            //
            // Save the expanded states
            //
            SaveTreeStates(m_pCookieComputer);

            m_pIDMTVOCX->DeleteAllItems();
            m_pIDMTVOCX->SetImageList(TVSIL_NORMAL, NULL);

            delete m_pCookieComputer;

            //
            // Reset these because they are no longer valid.
            //
            m_pCookieComputer = NULL;
        }
    }

    return S_OK;
}

//
// This function saves the subtree states rooted by pCookieStart.
// It creates an identifier for each expanded node and inserts
// the identifier to the class memember, m_listExpandedItems.
//
// It also saves the selected cookie by creating an identifier and
// saving it in m_pSelectedItem.
//
// This function may throw CMemoryException
//
// INPUT:
//      pCookieStart -- subtree root
// OUTPUT:
//      NONE
void
CResultView::SaveTreeStates(
                           CCookie* pCookieStart
                           )
{
    CItemIdentifier* pItem;

    //
    // If we have a selected item, create an identifier for it
    //
    if (m_pSelectedCookie) {
        m_pSelectedItem = m_pSelectedCookie->GetResultItem()->CreateIdentifier();
        m_pSelectedCookie = NULL;
    }

    while (pCookieStart) {
        if (pCookieStart->IsFlagsOn(COOKIE_FLAGS_EXPANDED)) {
            pItem = pCookieStart->GetResultItem()->CreateIdentifier();
            m_listExpandedItems.AddTail(pItem);
        }

        if (pCookieStart->GetChild()) {
            SaveTreeStates(pCookieStart->GetChild());
        }

        pCookieStart = pCookieStart->GetSibling();
    }
}

void
CResultView::DestroySavedTreeStates()
{
    if (!m_listExpandedItems.IsEmpty()) {
        POSITION pos;
        pos = m_listExpandedItems.GetHeadPosition();

        while (NULL != pos) {
            delete m_listExpandedItems.GetNext(pos);
        }

        m_listExpandedItems.RemoveAll();
    }

    if (m_pSelectedItem) {
        delete m_pSelectedItem;
        m_pSelectedItem = NULL;
    }
}

//
// This function restores the expanded and selected state for the cookie.
//
// INPUT:
//      pCookie -- cookie to restore states for
// OUTPUT:
//      NONE
void
CResultView::RestoreSavedTreeState(
                                  CCookie* pCookie
                                  )
{
    //
    // If the cookie was expanded before, mark it so that DisplayTree
    // will expand it.
    //
    if (!m_listExpandedItems.IsEmpty()) {
        POSITION pos = m_listExpandedItems.GetHeadPosition();
        CItemIdentifier* pItem;

        while (NULL != pos) {
            pItem = m_listExpandedItems.GetNext(pos);

            if (*pItem == *pCookie) {
                pCookie->TurnOnFlags(COOKIE_FLAGS_EXPANDED);
                break;
            }
        }
    }

    if (m_pSelectedItem && (*m_pSelectedItem == *pCookie)) {
        m_pSelectedCookie = pCookie;
    }
}

BOOL
CResultView::DisplayTree()
{
    BOOL Result = FALSE;

    ASSERT(m_pIDMTVOCX);

    ::SendMessage(m_hwndTV, WM_SETREDRAW, FALSE, 0L);

    //
    // Ignore the tvNotify(SELCHANGED) messages while the tree is changed.
    //
    SetSelectOk(FALSE);

    m_pIDMTVOCX->DeleteAllItems();

    //
    // Only display the tree if there is something to display
    //
    if (m_pCookieComputer) {

        m_pIDMTVOCX->SetImageList(TVSIL_NORMAL, m_pMachine->DiGetClassImageList());
        m_pIDMTVOCX->SetStyle(TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT);

        BOOL HasProblem = FALSE;

        //
        // Walks down the tree started from m_pCookieComputer
        //
        Result = DisplaySubtree(NULL, m_pCookieComputer, &HasProblem);

        if (HasProblem && Result) {
            m_pIDMTVOCX->Expand(TVE_EXPAND, (HTREEITEM)m_pCookieComputer->m_lParam);
        }

        //
        // If we have a pre-selected item, use it. Otherwise, use computer
        // as the selected node.
        //
        HTREEITEM hSelectedItem = (m_pSelectedCookie && m_pSelectedCookie->m_lParam) ?
                                  (HTREEITEM)m_pSelectedCookie->m_lParam :
                                  (HTREEITEM)m_pCookieComputer->m_lParam;
        SetSelectOk(TRUE);

        if (hSelectedItem) {
            m_pIDMTVOCX->SelectItem(TVGN_CARET, hSelectedItem);
            m_pIDMTVOCX->EnsureVisible(hSelectedItem);
        }
    }

    ::SendMessage(m_hwndTV, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(m_hwndTV, NULL, TRUE);

    return Result;
}

//
// This function walks through the given cookie subtree rooted by pCookie
// and insert each node into the TreeView OCX.
// INPUT:
//      htiParent -- HTREEITEM for the new cookie to be inserted
//                   if NULL is given, TVI_ROOT is assumed.
//      pCookie   -- the subtree root cookie to be displayed.
// OUTPUT:
//      none.
//
BOOL
CResultView::DisplaySubtree(
                           HTREEITEM htiParent,
                           CCookie* pCookie,
                           BOOL* pReportProblem
                           )
{
    TV_INSERTSTRUCT ti;
    CResultItem* pRltItem;
    HTREEITEM hti;
    BOOL bResource;
    BOOL fShowHiddenDevices = m_pFolder->ShowHiddenDevices();

    while (pCookie) {
        pRltItem = pCookie->GetResultItem();
        ti.item.state = INDEXTOOVERLAYMASK(0);
        bResource = FALSE;

        //
        // The cookie is not yet in the treeview.
        //
        pCookie->m_lParam = 0;

        if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
            CDevice* pDevice = (CDevice*)pRltItem;

            //
            // This is a hidden device and we are not showing hidden devices
            //
            // Note that we need to special case these devices because they
            // are not shown in the tree view, but their visible children are shown.
            //
            if (!fShowHiddenDevices && pDevice->IsHidden()) {

                //
                // If the cookie has children, display them
                //
                CCookie* pCookieChild = pCookie->GetChild();
                BOOL ChildProblem = FALSE;

                if (pCookieChild) {
                    DisplaySubtree(htiParent, pCookieChild, &ChildProblem);
                }

                //
                // Continue on with the next device. This will skip all of the display
                // code below.
                //
                pCookie = pCookie->GetSibling();
                continue;
            }

            //
            // If the device is disabled then set the OVERLAYMASK to the Red X
            //
            if (pDevice->IsDisabled()) {
                ti.item.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
                *pReportProblem = TRUE;
            }

            //
            // If the device has a problem then set the OVERLAYMASK to the Yellow !
            //
            else if (pDevice->HasProblem()) {
                ti.item.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
                *pReportProblem = TRUE;
            }

            //
            // if the device does not present, then set the state to TVIS_CUT. This grays out
            // the icon a bit so it looks like a ghost icon.
            //
            else if (pDevice->IsPhantom()) {
                ti.item.state = TVIS_CUT;
            }
        }

        else if (COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
            CClass* pClass = (CClass*)pRltItem;

            //
            // If we don't have any devices to show for this class, or this
            // is a NoDisplayClass and we are not showing hidden devices,
            // then just get our next sibling and continue without showing
            // this class.
            //
            if ((0 == pClass->GetNumberOfDevices(fShowHiddenDevices)) ||
                (!fShowHiddenDevices && pClass->NoDisplay())) {

                //
                // Continue on with the next device. This will skip all of the display
                // code below.
                //
                pCookie = pCookie->GetSibling();
                continue;
            }
        }

        //
        // Is this a resource?
        //
        else if (COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
                 COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
                 COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
                 COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType()) {
            bResource = TRUE;

            //
            // If this is a FORCED CONFIG resource then overlay the forced
            // config icon
            //
            if (((CResource*)pCookie->GetResultItem())->IsForced()) {
                ti.item.state = INDEXTOOVERLAYMASK(IDI_FORCED_OVL-IDI_CLASSICON_OVERLAYFIRST+1);
            }
        }


        ti.hParent = (htiParent != NULL) ? htiParent : TVI_ROOT;
        ti.hInsertAfter = TVI_SORT;
        ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE;
        ti.item.iImage = ti.item.iSelectedImage = pRltItem->GetImageIndex();

        if (bResource) {
            ti.item.pszText = (LPTSTR)((CResource*)pRltItem)->GetViewName();
        }

        else {
            ti.item.pszText = (LPTSTR)pRltItem->GetDisplayName();
        }

        ti.item.lParam = (LPARAM)pCookie;
        ti.item.stateMask = TVIS_OVERLAYMASK | TVIS_CUT;
        hti = m_pIDMTVOCX->InsertItem(&ti);

        //
        // Save the HTREEITEM
        //
        pCookie->m_lParam = (LPARAM)hti;

        if (NULL != hti) {
            //
            // If the cookie has children, display them
            //
            CCookie* pCookieChild = pCookie->GetChild();
            BOOL ChildProblem = FALSE;

            if (pCookieChild) {
                if (bResource && htiParent &&
                    GetDescriptionStringID() == IDS_STATUS_RESOURCES_BYTYPE) {
                    //
                    // This is a child of a resource being viewed by type,
                    // so the tree needs to be flattened.  This is done by
                    // using the same parent.
                    //
                    DisplaySubtree(htiParent, pCookieChild, &ChildProblem);
                }

                else {
                    DisplaySubtree(hti, pCookieChild, &ChildProblem);
                }
            }

            //
            // If any of the device's children have a problem, or if
            // it was previously expanded, then expand it.
            //
            if (ChildProblem || pCookie->IsFlagsOn(COOKIE_FLAGS_EXPANDED)) {
                m_pIDMTVOCX->Expand(TVE_EXPAND, hti);
            }

            //
            // Propogate the child's problem state back to the parent
            //
            *pReportProblem |= ChildProblem;
        }

        pCookie = pCookie->GetSibling();
    }

    return TRUE;
}

HRESULT
CResultView::GetResultViewType(
                              LPOLESTR* ppViewType,
                              long*     pViewOptions
                              )
{
    ASSERT(ppViewType && pViewOptions);

    //
    // The caller is responsible for freeing the memory we allocated.
    //
    LPOLESTR polestr;
    polestr = AllocOleTaskString(OCX_TREEVIEW);

    if (!polestr) {
        return E_OUTOFMEMORY;
    }

    *ppViewType = polestr;

    //
    // We have not list view options
    //
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    return S_OK;
}

HRESULT
CResultView::AddMenuItems(
                         CCookie* pCookie,
                         LPCONTEXTMENUCALLBACK pCallback,
                         long*   pInsertionAllowed,
                         BOOL fContextMenu                   // True if for result view context menu
                         )
{
    HRESULT hr = S_OK;
    CDevice* pDevice = NULL;

    if (CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed) {
        switch (pCookie->GetType()) {
        case COOKIE_TYPE_RESULTITEM_DEVICE:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
            if (m_pMachine->IsLocal() && g_IsAdmin) {
                if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
                    pDevice = (CDevice*) pCookie->GetResultItem();
                } else {
                    //
                    // This is a resource item, get the pointer for the device
                    // object from the resource object.
                    //
                    CResource* pResource = (CResource*) pCookie->GetResultItem();
                    if (pResource) {
                        pDevice = pResource->GetDevice();
                    }
                }

                if (pDevice == NULL) {
                    break;
                }
                
                CClass* pClass = pDevice->GetClass();

                //
                // All devices can have their driver's updated except for legacy devices.
                //
                if (!IsEqualGUID(*pClass, GUID_DEVCLASS_LEGACYDRIVER)) {
                    hr = AddMenuItem(pCallback, IDS_UPDATEDRIVER, 
                                     IDS_MENU_STATUS_UPDATEDRIVER, IDM_UPDATEDRIVER,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, 0);
                }

                //
                // Only show the Enable/Disable menu item if the device
                // can be disabled.
                //
                if (pDevice->IsDisableable()) {
                    if (pDevice->IsStateDisabled()) {
                        hr = AddMenuItem(pCallback, IDS_ENABLE, 
                                         IDS_MENU_STATUS_ENABLE, IDM_ENABLE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                         MF_ENABLED, 0);
                    } else {
                        hr = AddMenuItem(pCallback, IDS_DISABLE, 
                                         IDS_MENU_STATUS_DISABLE, IDM_DISABLE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                         MF_ENABLED, 0);
                    }
                }

                //
                // Only show the uninstall menu item if the device can be
                // uninstalled.
                //
                if (SUCCEEDED(hr) &&
                    pDevice->IsUninstallable()) {
                    hr = AddMenuItem(pCallback, IDS_REMOVE, 
                                     IDS_MENU_STATUS_REMOVE, IDM_REMOVE,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, 0);
                }
            }

            // FALL THROUGH........

        case COOKIE_TYPE_RESULTITEM_CLASS:
            if (g_IsAdmin) {

                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, 0, 0, 0,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, CCM_SPECIAL_SEPARATOR);
                }
                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, IDS_REFRESH,
                                     IDS_MENU_STATUS_SCAN_CHANGES, IDM_REFRESH,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, 0);
                }
            }

            if (fContextMenu) {
                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, 0, 0, 0,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, CCM_SPECIAL_SEPARATOR);
                }
                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, IDS_PROPERTIES, 
                                     IDS_MENU_STATUS_PROPERTIES, IDM_PROPERTIES,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_DEFAULT, CCM_SPECIAL_DEFAULT_ITEM);
                }
            }

            break;

        case COOKIE_TYPE_RESULTITEM_COMPUTER:
        case COOKIE_TYPE_RESULTITEM_RESTYPE:
            if (g_IsAdmin) {
            
                hr = AddMenuItem(pCallback, IDS_REFRESH,
                                 IDS_MENU_STATUS_SCAN_CHANGES, IDM_REFRESH,
                                 CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                 MF_ENABLED, 0);
            }
            break;

        default:
            break;
        }
    }

    return hr;
}

// This function handles menu command for the device tree.
//
// INPUT: pCookie  -- the cookie
//        lCommandId -- the command. See AddMenuItems for valid command
//                      id for each type of cookie.
//
// OUTPUT:  HRESULT S_OK if succeeded.
//                  S_XXX error code.

HRESULT
CResultView::MenuCommand(
                        CCookie* pCookie,
                        long     lCommandId
                        )
{
    HRESULT hr = S_OK;

    //TRACE1(TEXT("Menu command, commandid = %lx\n"), lCommandId);
    ASSERT(pCookie);

    CResultItem* pResultItem = pCookie->GetResultItem();
    ASSERT(pResultItem);

    CDevice* pDevice = NULL;

    switch (pCookie->GetType()) {
    case COOKIE_TYPE_RESULTITEM_DEVICE:
        pDevice = (CDevice*)pResultItem;
        break;

    case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
        CResource* pResource = (CResource*)pResultItem;
        if (pResource) {
            pDevice = pResource->GetDevice();
        }
        break;
    }

    switch (lCommandId) {
    case IDM_UPDATEDRIVER:
        if (pDevice) {
            BOOL Installed;
            DWORD RestartFlags = 0;
            DWORD Status = 0, Problem = 0;

            //
            // If the device has the DN_WILL_BE_REMOVED flag set and the user is
            // attempting to update the driver then we will prompt them for a 
            // reboot and include text in the prompt that explains this device
            // is in the process of being removed.
            //
            if (pDevice->GetStatus(&Status, &Problem) &&
                (Status & DN_WILL_BE_REMOVED)) {

                PromptForRestart(m_hwndTV, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
            
            } else {
                //
                // Disable Refreshing while the Update Driver Wizard is up.
                //
                pDevice->m_pMachine->EnableRefresh(FALSE);
    
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
                Installed = pDevice->m_pMachine->InstallDevInst(m_hwndTV, pDevice->GetDeviceID(), TRUE, &RestartFlags);
    
                if (hCursorOld) {
                    SetCursor(hCursorOld);
                }
    
                //
                // Prompt for a restart if one is needed.  If the user does NOT answer
                // YES to the restart dialog then schedule a refresh since we might not
                // get one from a WM_DEVICECHANGE.
                //
                if (m_pMachine->IsLocal()) {
                    if (PromptForRestart(NULL, RestartFlags) == IDNO) {
                        pDevice->m_pMachine->ScheduleRefresh();
                    }
                }
    
                //
                // Enable Refreshing now that we are done updating the driver.
                //
                pDevice->m_pMachine->EnableRefresh(TRUE);
            }
        }
        break;

    case IDM_ENABLE:
    case IDM_DISABLE:
        if (pDevice) {
            DWORD RestartFlags = 0;
            DWORD Status = 0, Problem = 0;
            
            //
            // If the device has the DN_WILL_BE_REMOVED flag set and the user is
            // attempting to enable/disable the driver then we will prompt them for a 
            // reboot and include text in the prompt that explains this device
            // is in the process of being removed.
            //
            if (pDevice->GetStatus(&Status, &Problem) &&
                (Status & DN_WILL_BE_REMOVED)) {

                PromptForRestart(m_hwndTV, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS);
            
            } else {

                RestartFlags = pDevice->EnableDisableDevice(m_hwndTV,
                                                            (lCommandId == IDM_ENABLE));
    
                //
                // Update the toolbar buttons since the device just changed.
                //
                m_pFolder->m_pComponent->UpdateToolbar(pCookie);
    
                //
                // Prompt for a Restart if we are running locally.  
                // The PromptForRestart() API checks the flags to determine
                // if a restart is actually needed.
                //
                if (m_pMachine->IsLocal()) {
                    if (PromptForRestart(NULL, RestartFlags) == IDNO) {
                        m_pMachine->ScheduleRefresh();
                    }
                }
            }
        }
        break;

    case IDM_REMOVE:
        if (pDevice) {
            hr = RemoveDevice(pDevice);
        }
        break;

    case IDM_REFRESH:
        //
        // This will force every attached folder to recreate
        // its machine data
        //
        ASSERT(m_pMachine);

        if (!m_pMachine->Reenumerate()) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        break;

    case IDM_PROPERTIES:
        hr = DoProperties(m_hwndTV, pCookie);
        break;

    default:
        hr = S_OK;
        break;
    }

    return hr;
}

// This function reports if property pages are available for the
// given cookie. Returning S_FALSE,  the cookie's "properties" menu
// item will not displayed.
//
// INPUT: pCookie  -- the cookie
//
// OUTPUT:  HRESULT S_OK if pages are available for the cookie.
//                  S_FALSE if no pages are available for the cookie.
HRESULT
CResultView::QueryPagesFor(
                          CCookie* pCookie
                          )
{
    ASSERT(pCookie);

    if (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
        return S_OK;
    }

    return S_FALSE;
}

// This function creates property page(s) for the given cookie.
//
// INPUT: pCookie  -- the cookie
//        lpProvider -- interface pointer to IPROPERTYSHEETCALLBACK
//                      used to add HPROPSHEETPAGE to the property sheet.
//        handle     -- handle for property change notification
//                      The handle is required for MMCPropertyChangeNotify
//                      API.
// OUTPUT:  HRESULT S_OK if succeeded.
//                  S_FALSE if no pages are added.
//                  S_XXX error code.
HRESULT
CResultView::CreatePropertyPages(
                                CCookie* pCookie,
                                LPPROPERTYSHEETCALLBACK lpProvider,
                                LONG_PTR    handle
                                )
{
//
// Design issue:
// We depend on the general page to do some houeskeeping works on the
// property sheet which is owned  and controlled by MMC running in a
// separate thread. General page is always the first page and its window
// is always created. If we need to subclass the property sheet someday,
// having our own General page always assure that we will get the window
// handle to the property sheet.
//
// The most important housekeeping work the General page does is to inform the
// associate device or class when a property sheet is being created
// or destroyed. A device can not be removed if it has a property sheet
// running. The machine can not refresh the device tree if there are property
// sheet(s) running on any devices/classes it contains. Property sheets
// created by a folder should be canceled when the folder is being
// destroyed.
//
// So far, no class installers have attempted to add their own General
// page and I believe it will be true in the future because 1). the page
// is too complicated and overloaded with features(and hard to implement) and
// 2). no major gains can be obtained by implementing a new one.
// To warn the developers who does their own General page,we will have a
// message box warn them about this and proceed with OUR general page.
//
    ASSERT(pCookie);

    CPropSheetData* ppsd = NULL;
    CMachine* pNewMachine = NULL;

    switch (pCookie->GetType()) {
    case COOKIE_TYPE_RESULTITEM_CLASS:
        CClass* pClass;
        pClass = (CClass*) pCookie->GetResultItem();
        ASSERT(pClass);
        
        //
        // Create a new CMachine object that just contains this specific device
        // and it's class.  We need to do this since the CDevice and CClass of 
        // the cookie that was passed into this API will get destroyed whenever
        // we get a WM_DEVICECHANGE notification.
        //
        PVOID Context;
        pNewMachine = new CMachine(m_pMachine->GetMachineFullName());

        CClass* pNewClass;

        if (pNewMachine->Initialize(NULL, NULL, *pClass) &&
            pNewMachine->GetFirstClass(&pNewClass, Context) &&
            pNewClass) {

            pNewMachine->m_ParentMachine = m_pMachine;
            m_pMachine->AttachChildMachine(pNewMachine);
            pNewMachine->SetPropertySheetShouldDestroy();

            ppsd = &pNewClass->m_psd;
    
            if (ppsd->Create(g_hInstance, m_hwndTV, MAX_PROP_PAGES, handle)) {
                CDevInfoList* pClassDevInfo;
    
                //
                // The CDevInfoList object is maintained by the CClass
                // object.
                //
                pClassDevInfo = pNewClass->GetDevInfoList();
    
                if (pClassDevInfo && pClassDevInfo->DiGetClassDevPropertySheet(NULL, 
                                                                               &ppsd->m_psh, 
                                                                               MAX_PROP_PAGES, 
                                                                               pNewMachine->IsLocal() ?
                                                                               DIGCDP_FLAG_ADVANCED : 
                                                                               DIGCDP_FLAG_REMOTE_ADVANCED)) {
                    if (pClassDevInfo->DiGetFlags(NULL) & DI_GENERALPAGE_ADDED) {
                        TCHAR szText[MAX_PATH];
                        LoadResourceString(IDS_GENERAL_PAGE_WARNING, szText,
                                           ARRAYLEN(szText));
    
                        int ReturnValue;
                        m_pFolder->m_pComponent->m_pConsole->MessageBox(
                                                                       szText, pNewClass->GetDisplayName(),
                                                                       MB_ICONEXCLAMATION | MB_OK, &ReturnValue);
                        //
                        // fall through to create our general page.
                        //
                    }
    
                    SafePtr<CClassGeneralPage> GenPagePtr;
                    CClassGeneralPage* pGenPage;
                    pGenPage = new CClassGeneralPage;
    
                    if (pGenPage) {
                        GenPagePtr.Attach(pGenPage);
                        HPROPSHEETPAGE hPage = pGenPage->Create(pNewClass);
    
                        //
                        // General page has to be the first page
                        //
                        if (ppsd->InsertPage(hPage, 0)) {
                            GenPagePtr.Detach();
                        } else {
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
            }
        }
        break;

    case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
    case COOKIE_TYPE_RESULTITEM_DEVICE:
        CDevice* pDevice;
        CDevice* pNewDevice;

        pNewDevice = NULL;

        if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
            pDevice = (CDevice*) pCookie->GetResultItem();
        } else {
            //
            // This is a resource item, get the pointer for the device
            // object from the resource object.
            //
            CResource* pResource = (CResource*) pCookie->GetResultItem();
            ASSERT(pResource);
            pDevice = pResource->GetDevice();
        }
        ASSERT(pDevice);

        //
        // Create a new CMachine object that just contains this specific device
        // and it's class.  We need to do this since the CDevice and CClass of 
        // the cookie that was passed into this API will get destroyed whenever
        // we get a WM_DEVICECHANGE notification.
        //
        PVOID DeviceContext;
        pNewMachine = new CMachine(m_pMachine->GetMachineFullName());

        if (pNewMachine->Initialize(NULL, pDevice->GetDeviceID()) &&
            pNewMachine->GetFirstDevice(&pNewDevice, DeviceContext) &&
            pNewDevice) {

            pNewMachine->m_ParentMachine = m_pMachine;
            m_pMachine->AttachChildMachine(pNewMachine);
            pNewMachine->SetPropertySheetShouldDestroy();

            ppsd = &pNewDevice->m_psd;
    
            if (ppsd->Create(g_hInstance, m_hwndTV, MAX_PROP_PAGES, handle)) {
    
                //
                // Add any class/device specific property pages
                //
                pNewMachine->DiGetClassDevPropertySheet(*pNewDevice, 
                                                        &ppsd->m_psh, 
                                                        MAX_PROP_PAGES, 
                                                        pNewMachine->IsLocal() ?
                                                            DIGCDP_FLAG_ADVANCED :
                                                            DIGCDP_FLAG_REMOTE_ADVANCED);
    
                //
                // Add the general tab
                //
                DWORD DiFlags = pNewMachine->DiGetFlags(*pNewDevice);
                SafePtr<CDeviceGeneralPage> GenPagePtr;
    
                if (DiFlags & DI_GENERALPAGE_ADDED) {
                    TCHAR szText[MAX_PATH];
                    LoadResourceString(IDS_GENERAL_PAGE_WARNING, szText,
                                       ARRAYLEN(szText));
    
                    int ReturnValue;
                    m_pFolder->m_pComponent->m_pConsole->MessageBox(
                                                                   szText, pNewDevice->GetDisplayName(),
                                                                   MB_ICONEXCLAMATION | MB_OK, &ReturnValue);
                    //
                    // fall through to create our general page.
                    //
                }
    
                CDeviceGeneralPage* pGenPage = new CDeviceGeneralPage;
    
                if (pGenPage) {
                    GenPagePtr.Attach(pGenPage);
                    HPROPSHEETPAGE hPage = pGenPage->Create(pNewDevice);
    
                    if (hPage) {
                        //
                        // General page has to be the first page
                        //
                        if (ppsd->InsertPage(hPage, 0)) {
                            GenPagePtr.Detach();
                        } else {
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
    
                //
                // Add the driver tab
                //
                SafePtr<CDeviceDriverPage> DrvPagePtr;
    
                if (!(DiFlags & DI_DRIVERPAGE_ADDED)) {
                    CDeviceDriverPage* pPage = new CDeviceDriverPage;
    
                    if (pPage) {
                        DrvPagePtr.Attach(pPage);
                        HPROPSHEETPAGE hPage = pPage->Create(pNewDevice);
    
                        if (hPage) {
                            if (ppsd->InsertPage(hPage)) {
                                DrvPagePtr.Detach();
                            } else {
                                ::DestroyPropertySheetPage(hPage);
                            }
                        }
                    }
                }
    
    
                //
                // add the details tab
                //
                // If the environment variable DEVMGR_SHOW_DETAILS does exist and it
                // is not 0 then we will show the details tab
                //
                TCHAR Buffer[MAX_PATH];
                DWORD BufferLen;
    
                if (((BufferLen = ::GetEnvironmentVariable(TEXT("DEVMGR_SHOW_DETAILS"),
                                                           Buffer,
                                                           ARRAYLEN(Buffer))) != 0) &&
                    ((BufferLen > 1) ||
                     (lstrcmp(Buffer, TEXT("0"))))) {
    
                    SafePtr<CDeviceDetailsPage> DetailsPagePtr;
    
                    CDeviceDetailsPage* pDetailsPage = new CDeviceDetailsPage;
                    DetailsPagePtr.Attach(pDetailsPage);
                    HPROPSHEETPAGE hPage = pDetailsPage->Create(pNewDevice);
    
                    if (hPage) {
                        if (ppsd->InsertPage(hPage)) {
                            DetailsPagePtr.Detach();
                        } else {
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
    
                //
                // Add the resource tab
                //
                if (pNewDevice->HasResources() && !(DiFlags & DI_RESOURCEPAGE_ADDED)) {
                    pNewMachine->DiGetExtensionPropSheetPage(*pNewDevice,
                                                            AddPropPageCallback,
                                                            SPPSR_SELECT_DEVICE_RESOURCES,
                                                            (LPARAM)ppsd
                                                           );
                }
    
#ifndef _WIN64
                DWORD DiFlagsEx = pNewMachine->DiGetExFlags(*pNewDevice);
                
                //
                // Add the power management tab
                //
                if (pNewMachine->IsLocal() && !(DiFlagsEx & DI_FLAGSEX_POWERPAGE_ADDED)) {
                    //
                    // Check if the device support power management
                    //
                    CPowerShutdownEnable ShutdownEnable;
                    CPowerWakeEnable WakeEnable;
    
                    if (ShutdownEnable.Open(pNewDevice->GetDeviceID()) || WakeEnable.Open(pNewDevice->GetDeviceID())) {
                        ShutdownEnable.Close();
                        WakeEnable.Close();
                        SafePtr<CDevicePowerMgmtPage> PowerMgmtPagePtr;
                        CDevicePowerMgmtPage* pPowerPage = new CDevicePowerMgmtPage;
    
                        if (pPowerPage) {
                            PowerMgmtPagePtr.Attach(pPowerPage);
                            HPROPSHEETPAGE hPage = pPowerPage->Create(pNewDevice);
    
                            if (hPage) {
                                if (ppsd->InsertPage(hPage)) {
                                    PowerMgmtPagePtr.Detach();
                                } else {
                                    ::DestroyPropertySheetPage(hPage);
                                }
                            }
                        }
                    }
                }
#endif
    
                //
                // Add any Bus specific property pages if this is the local machine
                //
                if (pNewMachine->IsLocal()) {
                    CBusPropPageProvider* pBusPropPageProvider = new CBusPropPageProvider();
    
                    if (pBusPropPageProvider) {
                        SafePtr<CBusPropPageProvider> ProviderPtr;
                        ProviderPtr.Attach(pBusPropPageProvider);
    
                        if (pBusPropPageProvider->EnumPages(pNewDevice, ppsd)) {
                            ppsd->AddProvider(pBusPropPageProvider);
                            ProviderPtr.Detach();
                        }
                    }
                }
            }
        }
        break;

    default:
        break;
    }

    if (ppsd &&
        ppsd->m_psh.nPages) {
        PROPSHEETHEADER& psh = ppsd->m_psh;

        for (UINT Index = 0; Index < psh.nPages; Index++) {
            lpProvider->AddPage(psh.phpage[Index]);
        }
        return S_OK;
    }

    //
    // If we didn't add any pages then we need to delete the new CMachine we
    // created.
    //
    if (pNewMachine) {

        delete pNewMachine;
    }

    //
    // No pages are added, return S_FALSE so that the responsible
    // Component can do its clean up
    //
    return S_FALSE;
}

// This function handles notification codes from the TV OCX.
//
//  INPUT:
//      hwndTV  -- the Window handle of the TV OCX.
//      pCookie -- the cookie
//      Code    -- notification code.
//      arg     -- argument to the given notification code.
//      param   -- another parameter to the given notificaton code.
//
//  OUTPUT:
//      HRESULT -- S_OK if this function has processed the notification
//                 and the caller should not do any further processing.
//                 S_FALSE if the caller should do more processing.
HRESULT
CResultView::tvNotify(
                     HWND hwndTV,
                     CCookie* pCookie,
                     TV_NOTIFY_CODE Code,
                     LPARAM arg,
                     LPARAM param
                     )
{
    HRESULT hr;

    UNREFERENCED_PARAMETER(arg);

    if (m_hwndTV != hwndTV) {
        return S_FALSE;
    }

    //
    // Presume that we do not handle the notification
    //
    hr = S_FALSE;

    switch (Code) {
    case TV_NOTIFY_CODE_DBLCLK:
        if ((TVHT_ONITEM & param) &&
            (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType())) {
            if (SUCCEEDED(DoProperties(hwndTV, pCookie)))
                hr = S_OK;
        }
        break;

    case TV_NOTIFY_CODE_CONTEXTMENU:
        if (SUCCEEDED(DoContextMenu(hwndTV, pCookie, (POINT*)param)))
            hr = S_OK;
        break;

    case TV_NOTIFY_CODE_EXPANDED:
        if (TVE_EXPAND & param) {
            pCookie->TurnOnFlags(COOKIE_FLAGS_EXPANDED);
        } else if (TVE_COLLAPSE & param) {
            pCookie->TurnOffFlags(COOKIE_FLAGS_EXPANDED);
        }
        ASSERT(S_FALSE == hr);
        break;

    case TV_NOTIFY_CODE_FOCUSCHANGED:
        // gaining the focus, set the console verbs and toolbar buttons
        if (param) {
            UpdateConsoleVerbs(pCookie);
            m_pFolder->m_pComponent->UpdateToolbar(pCookie);
        }
        break;

    case TV_NOTIFY_CODE_SELCHANGED:
        if (m_SelectOk) {
            // These messages are ignored while the tree is being changed.
            m_pSelectedCookie = pCookie;

            UpdateConsoleVerbs(pCookie);
            m_pFolder->m_pComponent->UpdateToolbar(pCookie);
        }

        break;

    case TV_NOTIFY_CODE_KEYDOWN:
        if (VK_RETURN == param) {
            if (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
                if (SUCCEEDED(DoProperties(hwndTV, pCookie)))
                    hr = S_OK;
            }
        }

        else if (VK_DELETE == param &&
                 COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
            
            //
            // Remove the selected device
            //
            CDevice* pDevice = (CDevice*)pCookie->GetResultItem();
            RemoveDevice(pDevice);
        }
        break;

    case TV_NOTIFY_CODE_RCLICK:
    case TV_NOTIFY_CODE_CLICK:
        if (pCookie && pCookie->m_lParam) {
            m_pIDMTVOCX->SelectItem(TVGN_CARET, (HTREEITEM)pCookie->m_lParam);
        }

    case TV_NOTIFY_CODE_GETDISPINFO:
    default:
        ASSERT(S_FALSE == hr);
        break;
    }

    return hr;
}

//
// This function updates console verbs based on the selected cookie type.
//
HRESULT
CResultView::UpdateConsoleVerbs(
                               CCookie* pCookie
                               )
{
    BOOL bPropertiesEnabled = FALSE;
    BOOL bPrintEnabled = FALSE;

    if (!m_pFolder->m_bSelect) {

        switch (pCookie->GetType()) {
        
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
        case COOKIE_TYPE_RESULTITEM_CLASS:
        case COOKIE_TYPE_RESULTITEM_DEVICE:
            bPropertiesEnabled = TRUE;
            bPrintEnabled = TRUE;
            break;
    
        case COOKIE_TYPE_RESULTITEM_COMPUTER:
            bPrintEnabled = TRUE;
            break;
    
        default:
            break;
        }
    }

    //
    // Only show the Print button/Action menu item when a something is selected.
    //
    if (bPrintEnabled) {

        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, FALSE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, TRUE);

    } else {

        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
    }

    //
    // Only show the properties button/Action menu item when a device/class is selected.
    //
    if (bPropertiesEnabled) {
        
        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    
    } else {

        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);
    }

    return S_OK;
}

HRESULT
CResultView::OnOcxNotify(
                        MMC_NOTIFY_TYPE event,
                        LPARAM arg,
                        LPARAM param
                        )
{
    HRESULT hr = S_OK;
    TV_ITEM TI;

    UNREFERENCED_PARAMETER(arg);

    switch (event) {
    case MMCN_BTN_CLICK:
        if ((MMC_CONSOLE_VERB)param == MMC_VERB_PROPERTIES) {
            ASSERT(m_pIDMTVOCX);
            TI.hItem = m_pIDMTVOCX->GetSelectedItem();

            if (TI.hItem) {
                TI.mask = TVIF_PARAM;
                hr =  m_pIDMTVOCX->GetItem(&TI);

                if (SUCCEEDED(hr)) {
                    hr = DoProperties(m_hwndTV,  (CCookie*)TI.lParam);
                }
            }
        }
        break;

    case MMCN_PRINT:
        hr = DoPrint();
        break;

    case MMCN_SELECT:
        ASSERT(m_pIDMTVOCX);
        TI.hItem = m_pIDMTVOCX->GetSelectedItem();

        if (TI.hItem) {
            TI.mask = TVIF_PARAM;
            hr = m_pIDMTVOCX->GetItem(&TI);

            if (SUCCEEDED(hr)) {
                hr = UpdateConsoleVerbs((CCookie*)TI.lParam);    
            }
        }
        break;

    default:
        break;
    }

    return hr;
}

// This function creates the propperty sheet for the given cookie.
// INPUT:
//      hwndTV  -- the window handle to the TV OCX, used as the parent
//                 window of the property sheet.
//      pCookie -- the cookie.
// OUTPUT:
//      HRESULT S_OK if the function succeeded.
//              S_FALSE if no property sheet will be created.
//              S_XXXX other error.
HRESULT
CResultView::DoProperties(
                         HWND hwndTV,
                         CCookie* pCookie
                         )
{
    HRESULT hr;

    //
    // If a property sheet is aleady up for the node, bring the
    // property sheet to the foreground.
    //
    HWND hWnd = NULL;

    if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
        CDevice* pDevice = (CDevice*)pCookie->GetResultItem();
        ASSERT(pDevice);
        hWnd = pDevice->m_pMachine->GetDeviceWindowHandle(pDevice->GetDeviceID());
    }

    else if (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType()) {
        //
        // This is a resource item, get the pointer for the device
        // object from the resource object.
        //
        CResource* pResource = (CResource*) pCookie->GetResultItem();
        ASSERT(pResource);
        CDevice* pDevice = pResource->GetDevice();
        ASSERT(pDevice);
        hWnd = pDevice->m_pMachine->GetDeviceWindowHandle(pDevice->GetDeviceID());
    }

    else if (COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
        CClass* pClass = (CClass*)pCookie->GetResultItem();
        ASSERT(pClass);
        hWnd = pClass->m_pMachine->GetClassWindowHandle(*pClass);
    }

    if (hWnd) {
        //
        // Notify the property sheet that it should go to foreground
        // Do not call SetForegroundWindow here because the subclassed
        // treeview control will grab the focus right after
        // we have brought the property sheet to foreground.
        //
        ::PostMessage(hWnd, PSM_QUERYSIBLINGS, QSC_TO_FOREGROUND, 0L);
        return S_OK;
    }

    //
    // No property sheet is up for this cookie, create a brand new property
    // sheet for it.
    //
    SafeInterfacePtr<IComponent> pComponent;
    SafeInterfacePtr<IPropertySheetProvider> pSheetProvider;
    SafeInterfacePtr<IDataObject> pDataObject;
    SafeInterfacePtr<IExtendPropertySheet> pExtendSheet;
    pComponent.Attach((IComponent*) m_pFolder->m_pComponent);

    if (FAILED(pComponent->QueryInterface(IID_IExtendPropertySheet, (void**) &pExtendSheet)) ||
        FAILED(pComponent->QueryDataObject((MMC_COOKIE)pCookie, CCT_RESULT, &pDataObject)) ||
        FAILED(m_pFolder->m_pComponent->m_pConsole->QueryInterface(IID_IPropertySheetProvider,
                                                                   (void**) &pSheetProvider)) ||
        S_OK == pSheetProvider->FindPropertySheet((MMC_COOKIE)pCookie, pComponent, pDataObject) ||
        S_OK != pExtendSheet->QueryPagesFor(pDataObject)) {
        return S_FALSE;
    }

    hr = pSheetProvider->CreatePropertySheet(
                                            pCookie->GetResultItem()->GetDisplayName(),
                                            TRUE, // not wizard
                                            (MMC_COOKIE)pCookie, pDataObject,
                                            MMC_PSO_NOAPPLYNOW  // do not want the apply button
                                            );
    if (SUCCEEDED(hr)) {
        HWND hNotifyWindow;

        if (!SUCCEEDED(m_pFolder->m_pComponent->m_pConsole->GetMainWindow(&hNotifyWindow)))
            hNotifyWindow = NULL;

        hNotifyWindow = FindWindowEx(hNotifyWindow, NULL, TEXT("MDIClient"), NULL);
        hNotifyWindow = FindWindowEx(hNotifyWindow, NULL, TEXT("MMCChildFrm"), NULL);
        hNotifyWindow = FindWindowEx(hNotifyWindow, NULL, TEXT("MMCView"), NULL);
        hr = pSheetProvider->AddPrimaryPages(pComponent, TRUE, hNotifyWindow, FALSE);

        if (SUCCEEDED(hr)) {
            pSheetProvider->AddExtensionPages();
            hr = pSheetProvider->Show((LONG_PTR)hwndTV, 0);
        } else {
            //
            // Failed to add primary Component's property page, destroy
            // the property sheet
            //
            pSheetProvider->Show(-1, 0);
        }
    }

    return hr;
}

// This function creates a context menu for the given cookie
// INPUT:
//      hwndTV  -- the TV OCX window, as the window the context menu to be
//                 attached to.
//      pCookie -- the cookie
//      pPoint  -- the location where the context menu should anchor in
//                 screen coordinate.
HRESULT
CResultView::DoContextMenu(
                          HWND hwndTV,
                          CCookie* pCookie,
                          POINT* pPoint
                          )
{
    HRESULT hr = S_FALSE;
    CMachine *pMachine = NULL;

    //
    // ISSUE: JasonC 8/14/99
    //
    // If we have a valid cookie then we need to get the CMachine for the given
    // cookie if there is one.  Then we need to disable refreshing while the
    // context menu is being displayed.  The reason for this is that if we
    // refresh while the menu is displayed but before the user chooses an option
    // then the cookie is no longer valid.  The real problem here is that we rebuild
    // all of the classes on a refresh which makes any cookie floating around invalid.
    // I am sure that there is more of these bugs lurking around in the code and this
    // needs to be addressed by a better overall change after NT 5.0.
    //
    if (pCookie) {
        CDevice *pDevice;
        CResource *pResource;
        CClass *pClass;

        switch (pCookie->GetType()) {
        
        case COOKIE_TYPE_RESULTITEM_DEVICE:
            pDevice = (CDevice*)pCookie->GetResultItem();
            if (pDevice) {
                pMachine = pDevice->m_pMachine;
            }
            break;

        case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
            pResource = (CResource*)pCookie->GetResultItem();
            if (pResource) {
                pDevice = pResource->GetDevice();

                if (pDevice) {
                    pMachine = pDevice->m_pMachine;
                }
            }
            break;

        case COOKIE_TYPE_RESULTITEM_CLASS:
            pClass = (CClass*)pCookie->GetResultItem();
            if (pClass) {
                pMachine = pClass->m_pMachine;
            }
            break;

        default:
            pMachine = NULL;
        }
    }

    //
    // Disable Refreshing while the context menu is up.
    //
    if (pMachine) {
        pMachine->EnableRefresh(FALSE);
    }

    SafeInterfacePtr<IDataObject> pDataObject;
    SafeInterfacePtr<IContextMenuProvider> pMenuProvider;
    SafeInterfacePtr<IComponent> pComponent;
    pComponent.Attach((IComponent*)m_pFolder->m_pComponent);
    m_hwndTV = hwndTV;

    if (FAILED(pComponent->QueryDataObject((MMC_COOKIE)pCookie, CCT_RESULT, &pDataObject)) ||
        FAILED(m_pFolder->m_pComponent->m_pConsole->QueryInterface(IID_IContextMenuProvider,
                                                                   (void**)&pMenuProvider))) {
        hr = S_FALSE;
        goto clean0;
    }

    pMenuProvider->EmptyMenuList();
    CONTEXTMENUITEM MenuItem;
    MenuItem.strName = NULL;
    MenuItem.strStatusBarText = NULL;
    MenuItem.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    MenuItem.lInsertionPointID = 0;
    MenuItem.fFlags = 0;
    MenuItem.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

    if (SUCCEEDED(pMenuProvider->AddItem(&MenuItem)) &&
        SUCCEEDED(pMenuProvider->AddPrimaryExtensionItems(pComponent,
                                                          pDataObject)) &&
        SUCCEEDED(pMenuProvider->AddThirdPartyExtensionItems(pDataObject))) {
        long Selected;
        pMenuProvider->ShowContextMenu(hwndTV, pPoint->x, pPoint->y, &Selected);
        hr = S_OK;
        goto clean0;
    }

    clean0:

    //
    // Enable Refreshing again now that the context menu is gone
    //
    if (pMachine) {
        pMachine->EnableRefresh(TRUE);
    }

    return hr;
}

HRESULT
CResultView::DoPrint()
{
    DWORD ReportTypeEnableMask;
    ReportTypeEnableMask = REPORT_TYPE_MASK_ALL;
    HTREEITEM hSelectedItem;
    CCookie* pCookie = NULL;

    m_pMachine->EnableRefresh(FALSE);

    if (m_pIDMTVOCX) {

        hSelectedItem = m_pIDMTVOCX->GetSelectedItem();

        if (hSelectedItem) {

            TV_ITEM TI;
            TI.hItem = hSelectedItem;
            TI.mask = TVIF_PARAM;

            if (SUCCEEDED(m_pIDMTVOCX->GetItem(&TI))) {

                pCookie = (CCookie*)TI.lParam;
            }
        }
    }

    if (!pCookie || (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_RESOURCE_DMA != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_RESOURCE_IO != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_DEVICE != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_CLASS != pCookie->GetType())) {

        ReportTypeEnableMask &= ~(REPORT_TYPE_MASK_CLASSDEVICE);
    }

    if (!g_PrintDlg.PrintDlg(m_pMachine->OwnerWindow(), ReportTypeEnableMask)) {

        m_pMachine->EnableRefresh(TRUE);
        return S_OK;
    }

    if (!g_PrintDlg.HDC()) {

        m_pMachine->EnableRefresh(TRUE);
        return E_OUTOFMEMORY;
    }

    //
    // Create the printer
    //
    CPrinter  ThePrinter(m_pMachine->OwnerWindow(), g_PrintDlg.HDC());
    TCHAR DocTitle[MAX_PATH];
    LoadString(g_hInstance, IDS_PRINT_DOC_TITLE, DocTitle, ARRAYLEN(DocTitle));
    int PrintStatus = 0;

    switch (g_PrintDlg.ReportType()) {
    case REPORT_TYPE_SUMMARY:
        PrintStatus = ThePrinter.StartDoc(DocTitle);

        if (PrintStatus) {
            
            ThePrinter.SetPageTitle(IDS_PRINT_SUMMARY_PAGE_TITLE);
            PrintStatus = ThePrinter.PrintResourceSummary(*m_pMachine);
        }
        break;

    case REPORT_TYPE_CLASSDEVICE:
        ASSERT(pCookie);
        PrintStatus = ThePrinter.StartDoc(DocTitle);

        if (PrintStatus) {

            ThePrinter.SetPageTitle(IDS_PRINT_CLASSDEVICE_PAGE_TITLE);

            if (COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
                
                PrintStatus = ThePrinter.PrintClass((CClass*)pCookie->GetResultItem());

            } else {
                
                CDevice* pDevice;

                if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
                    
                    pDevice = (CDevice*) pCookie->GetResultItem();
                
                } else {
                    
                    //
                    // This is a resource item, get the pointer for the
                    // device object from the resource object.
                    //
                    CResource* pResource = (CResource*) pCookie->GetResultItem();
                    ASSERT(pResource);
                    pDevice = pResource->GetDevice();
                }

                ASSERT(pDevice);
                PrintStatus = ThePrinter.PrintDevice(pDevice);
            }
        }
        break;

    case REPORT_TYPE_SUMMARY_CLASSDEVICE:
        PrintStatus = ThePrinter.StartDoc(DocTitle);

        if (PrintStatus) {
            
            ThePrinter.SetPageTitle(IDS_PRINT_SUMMARY_CLASSDEVICE_PAGE_TITLE);
            PrintStatus = ThePrinter.PrintAll(*m_pMachine);
        }
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    //
    // Flush the last page
    //
    ThePrinter.FlushPage();

    if (PrintStatus) {

        ThePrinter.EndDoc();
    
    } else {

        ThePrinter.AbortDoc();
    }

    m_pMachine->EnableRefresh(TRUE);

    return S_OK;
}

HRESULT
CResultView::RemoveDevice(
                         CDevice* pDevice
                         )
{
    //
    // Must be an admin and on the local machine to remove a device.
    //
    if (!m_pMachine->IsLocal() || !g_IsAdmin) {
        
        return S_FALSE;
    }

    //
    // Make sure the device can be uninstalled
    //
    if (!pDevice->IsUninstallable()) {

        return S_FALSE;
    }

    //
    // Make sure there is no property sheet up for this device.
    // If it does exist, show a message box for the user and bring up
    // the property sheet to the foreground if the user
    // agree to do so.
    //
    HWND hwndPropSheet;
    hwndPropSheet = pDevice->m_psd.GetWindowHandle();
    int MsgBoxResult;
    TCHAR szText[MAX_PATH];

    if (hwndPropSheet) {
        LoadResourceString(IDS_PROPSHEET_WARNING, szText, ARRAYLEN(szText));
        MsgBoxResult = m_pFolder->m_pComponent->MessageBox(szText,
                                                           pDevice->GetDisplayName(),
                                                           MB_ICONEXCLAMATION | MB_OKCANCEL);

        if (IDOK == MsgBoxResult) {
            SetForegroundWindow(hwndPropSheet);
        }

        //
        // Can not wait for the property sheet because it is running
        // in a separate thread.
        //
        return S_OK;
    }

    BOOL Refresh = (pDevice->IsPhantom() || 
                    pDevice->HasProblem() || 
                    !pDevice->IsStarted());

    CRemoveDevDlg TheDlg(pDevice);

    //
    // Before removing device, disable refresh. This effectively disables
    // device change notification processing. While we are in the middle
    // of removing device, it is not a good idea to process any
    // device change notification. When the removal is done,
    // we will re-enable the refresh.
    //
    m_pMachine->EnableRefresh(FALSE);

    if (IDOK == TheDlg.DoModal(m_hwndTV, (LPARAM) &TheDlg)) {
        DWORD DiFlags;
        DiFlags = m_pMachine->DiGetFlags(*pDevice);

        //
        // We don't check to see if we are running locally at this
        // point because we won't let the user remove the device in
        // the first place if we are not running locally.
        //
        if (PromptForRestart(NULL, DiFlags, IDS_REMOVEDEV_RESTART) == IDNO) {

            Refresh = TRUE;
        }

        //
        // Enable refresh since we disabled it in the beginning.
        //
        // We only need to force a refresh here if the device that
        // was removed was a Phantom device or a device that is not
        // started.  This is because Phantom devices don't have kernel
        // devnodes and so they won't generate a WM_DEVICECHANGE like 
        // live started devnodes will.
        //
        if (Refresh) {

            m_pMachine->ScheduleRefresh();
        }

        m_pMachine->EnableRefresh(TRUE);
    }

    else {
        m_pMachine->EnableRefresh(TRUE);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//// CViewDeviceTree implementations
////

HRESULT
CViewDeviceTree::OnShow(
                       BOOL fShow
                       )
{
    if (!fShow) {
        return S_OK;
    }

    if (!m_pCookieComputer) {
        CreateDeviceTree();
    }

    return CResultView::OnShow(fShow);
}

// This function creates a the root device for the device tree.
// INPUT:
//      NONE.
// OUTPUT:
//      TRUE if the device is created(Rooted at m_pCookieComputer).
//      FALSE if the device is not created.
BOOL
CViewDeviceTree::CreateDeviceTree()
{
    ASSERT(NULL == m_pCookieComputer);
    m_pMachine = m_pFolder->m_pMachine;

    //
    // We shouldn't be here if there is not a machine created.
    //
    ASSERT(m_pMachine);

    CComputer* pComputer = m_pMachine->m_pComputer;

    //
    // Make sure there is at least a computer
    //
    if (pComputer) {
        m_pCookieComputer = new CCookie(COOKIE_TYPE_RESULTITEM_COMPUTER);

        if (m_pCookieComputer) {

            m_pCookieComputer->SetResultItem(pComputer);
            m_pCookieComputer->SetScopeItem(m_pFolder->m_pScopeItem);

            //
            // Make sure that the computer is expanded and selected.
            //
            m_pCookieComputer->TurnOnFlags(COOKIE_FLAGS_EXPANDED);

            //
            // If there was no selection, choose the computer
            //
            if (!m_pSelectedItem || (*m_pSelectedItem == *m_pCookieComputer)) {
                m_pSelectedCookie = m_pCookieComputer;
            }

            return TRUE;
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//// CViewTreeByType implementations
////

// This function creates a "view-by-type: device tree rooted at
// m_pCookieComputer.
//
// INPUT:
//      NONE.
// OUTPUT:
//      TRUE if the tree is created successfully.
//      FALSE if tree is not created.
BOOL
CViewTreeByType::CreateDeviceTree()
{
    if (!CViewDeviceTree::CreateDeviceTree()) {
        return FALSE;
    }

    ASSERT(m_pCookieComputer);
    CClass* pClass;
    CDevice* pDevice;
    CCookie* pCookieClass;
    CCookie* pCookieClassParent;
    CCookie* pCookieClassSibling;
    CCookie* pCookieDevice;
    CCookie* pCookieDeviceParent;
    CCookie* pCookieDeviceSibling;

    //
    // Do not have sibling at this moment;
    //
    pCookieClassSibling = NULL;

    //
    // All classes are children of computer
    //
    pCookieClassParent = m_pCookieComputer;

    pCookieDeviceParent;
    pCookieDeviceSibling;
    String strStartupDeviceId;
    strStartupDeviceId = GetStartupDeviceId();
    PVOID ContextClass, ContextDevice;

    if (m_pMachine->GetFirstClass(&pClass, ContextClass)) {
        do {
            //
            // We do not display a class if it does not have any
            // devices in it.
            //
            if (pClass->GetNumberOfDevices(TRUE)) {
                pCookieClass = new CCookie(COOKIE_TYPE_RESULTITEM_CLASS);
                pCookieClass->SetResultItem(pClass);
                pCookieClass->SetScopeItem(m_pFolder->m_pScopeItem);

                //
                // If the class was expanded before, mark it
                // so that DisplayTree will expand it
                //
                RestoreSavedTreeState(pCookieClass);

                //
                // No sibling: this is the first child
                //
                if (pCookieClassParent && !pCookieClassSibling) {
                    pCookieClassParent->SetChild(pCookieClass);
                }

                pCookieClass->SetParent(pCookieClassParent);

                if (pCookieClassSibling) {
                    pCookieClassSibling->SetSibling(pCookieClass);
                }

                pCookieClassSibling = pCookieClass;

                //
                // Classes are parent of devices
                //
                pCookieDeviceParent = pCookieClass;
                pCookieDeviceSibling = NULL;

                if (pClass->GetFirstDevice(&pDevice, ContextDevice)) {
                    do {
                        pCookieDevice = new CCookie(COOKIE_TYPE_RESULTITEM_DEVICE);
                        pCookieDevice->SetResultItem(pDevice);
                        pCookieDevice->SetScopeItem(m_pFolder->m_pScopeItem);

                        if (!strStartupDeviceId.IsEmpty() &&
                            !strStartupDeviceId.CompareNoCase(pDevice->GetDeviceID())) {
                            m_pSelectedCookie = pCookieDevice;
                        } else {
                            if (m_pSelectedItem && (*m_pSelectedItem == *pCookieDevice)) {
                                m_pSelectedCookie = pCookieDevice;
                            }
                        }

                        //
                        // No sibling: this is the first child
                        //
                        if (pCookieDeviceParent && !pCookieDeviceSibling) {
                            pCookieDeviceParent->SetChild(pCookieDevice);
                        }

                        pCookieDevice->SetParent(pCookieDeviceParent);

                        if (pCookieDeviceSibling) {
                            pCookieDeviceSibling->SetSibling(pCookieDevice);
                        }

                        pCookieDeviceSibling = pCookieDevice;

                    } while (pClass->GetNextDevice(&pDevice, ContextDevice));
                }
            }

        } while (m_pMachine->GetNextClass(&pClass, ContextClass));
    }

    DestroySavedTreeStates();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//// CViewTreeByConnection implementations
////

BOOL
CViewTreeByConnection::CreateDeviceTree()
{
    if (!CViewDeviceTree::CreateDeviceTree()) {
        return FALSE;
    }

    ASSERT(m_pCookieComputer);
    CComputer* pComputer = (CComputer*)m_pCookieComputer->GetResultItem();
    CDevice* pDeviceStart = pComputer->GetChild();
    ASSERT(pDeviceStart);

    //
    // Collect all the normal devices.
    //
    CreateSubtree(m_pCookieComputer, NULL, pDeviceStart);

    //
    // Add phantom devices to m_pCookieComputer subtree.
    //
    PVOID Context;

    if (m_pMachine->GetFirstDevice(&pDeviceStart, Context)) {
        //
        // Locate the end of the CookieComputer Sibling list to add the
        // phantom devices to.
        //
        CCookie* pCookieSibling = NULL;
        CCookie* pNext = m_pCookieComputer->GetChild();

        while (pNext != NULL) {
            pCookieSibling = pNext;
            pNext = pCookieSibling->GetSibling();
        }

        do {
            if (pDeviceStart->IsPhantom()) {
                CCookie* pCookie;
                pCookie = new CCookie(COOKIE_TYPE_RESULTITEM_DEVICE);
                pCookie->SetResultItem(pDeviceStart);
                pCookie->SetScopeItem(m_pFolder->m_pScopeItem);

                if (pCookieSibling) {
                    pCookieSibling->SetSibling(pCookie);
                } else {
                    m_pCookieComputer->SetChild(pCookie);
                }

                pCookie->SetParent(m_pCookieComputer);
                pCookieSibling = pCookie;

                //
                // See if we have to expand the node
                //
                RestoreSavedTreeState(pCookie);
            }

        } while (m_pMachine->GetNextDevice(&pDeviceStart, Context));
    }

    DestroySavedTreeStates();

    return TRUE;
}

//
//This function creates a cookie subtree by walking down the
//a device subtree led by the given pDeviceStart
//INPUT:
//  pCookieParent -- the parent of the newly created subtree
//  pCookieSibling -- the sibling of the newly create subtree
//  pDeviceStart   -- the device to start with
//
//OUTPUT:
//  TRUE if the subtree is created and inserted successfully.
//
// This function may throw CMemoryException
//
BOOL
CViewTreeByConnection::CreateSubtree(
                                    CCookie* pCookieParent,
                                    CCookie* pCookieSibling,
                                    CDevice* pDeviceStart
                                    )
{
    CCookie* pCookie;
    CDevice* pDeviceChild;
    String strStartupDeviceId;
    CClass*  pClass;
    strStartupDeviceId = GetStartupDeviceId();

    while (pDeviceStart) {
        pClass = pDeviceStart->GetClass();

        pCookie = new CCookie(COOKIE_TYPE_RESULTITEM_DEVICE);

        if (pCookie) {
            pCookie->SetResultItem(pDeviceStart);
            pCookie->SetScopeItem(m_pFolder->m_pScopeItem);

            if (!strStartupDeviceId.IsEmpty() &&
                !strStartupDeviceId.CompareNoCase(pDeviceStart->GetDeviceID())) {
                m_pSelectedCookie = pCookie;
            }

            //
            // No sibling: this is the first child
            //
            if (pCookieParent && !pCookieSibling) {
                pCookieParent->SetChild(pCookie);
            }

            pCookie->SetParent(pCookieParent);

            if (pCookieSibling) {
                pCookieSibling->SetSibling(pCookie);
            }

            //
            // See if we have to expand the node
            //
            RestoreSavedTreeState(pCookie);

            pDeviceChild = pDeviceStart->GetChild();

            if (pDeviceChild) {
                CreateSubtree(pCookie, NULL, pDeviceChild);
            }

            pCookieSibling = pCookie;

        }

        pDeviceStart = pDeviceStart->GetSibling();
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//// CViewResourceTree implementations
////

CViewResourceTree::~CViewResourceTree()
{
    int i;

    //
    // Destroy all the CResource objects
    //
    for (i = 0; i < TOTAL_RESOURCE_TYPES; i++) {
        if (m_pResourceList[i]) {
            delete m_pResourceList[i];
            m_pResourceList[i] = NULL;
        }

        if (m_pResourceType[i]) {
            delete m_pResourceType[i];
            m_pResourceType[i] = NULL;
        }
    }
}

//
// This functions handle MMC standard MMCN_SHOW command
//
// This function may throw CMemoryException
//
HRESULT
CViewResourceTree::OnShow(
                         BOOL fShow
                         )
{
    if (!fShow) {
        return S_OK;
    }

    if (!m_pCookieComputer) {
        CreateResourceTree();
    }

    return CResultView::OnShow(fShow);
}

//
// This function creates resource lists and cookie trees.
// The resources are recorded in the member m_pResourceList[]
// and the cookie tree is rooted at m_pCookieComputer[];
//
// This function may throw CMemoryException
//
void
CViewResourceTree::CreateResourceTree()
{
    int i;
    CCookie* pCookieTypeSibling = NULL;

    ASSERT(!m_pCookieComputer);
    m_pMachine = m_pFolder->m_pMachine;
    ASSERT(m_pMachine);

    //
    // Make sure there is at least a computer.
    //
    if (!m_pMachine->m_pComputer) {
        return;
    }

    m_pCookieComputer = new CCookie(COOKIE_TYPE_RESULTITEM_COMPUTER);

    if (!m_pCookieComputer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    m_pCookieComputer->SetResultItem(m_pMachine->m_pComputer);
    m_pCookieComputer->SetScopeItem(m_pFolder->m_pScopeItem);
    m_pCookieComputer->TurnOnFlags(COOKIE_FLAGS_EXPANDED);

    //
    // If no selected item recorded, default to the computer node
    //
    if (!m_pSelectedItem || (*m_pSelectedItem == *m_pCookieComputer)) {
        m_pSelectedCookie = m_pCookieComputer;
    }

    //
    // Check each resource type (mem, io, dma, irq) and create a result item
    // if resources exist for the resource type.
    //
    for (i = 0; i < TOTAL_RESOURCE_TYPES; i++) {
        RESOURCEID ResType = ResourceTypes[i];

        //
        // If there is an existing m_pResourceList then delete it.
        //
        if (m_pResourceList[i]) {
            delete m_pResourceList[i];    
        }

        m_pResourceList[i] = new CResourceList(m_pMachine, ResType);

        PVOID Context;
        CResource* pRes;

        if (m_pResourceList[i] && 
            m_pResourceList[i]->GetFirst(&pRes, Context)) {
            //
            // Resource items exist, create the resource type result item.
            //
            CCookie* pCookieFirst = NULL;

            //
            // If there is an existing m_pResourceType then delete it.
            //
            if (m_pResourceType[i]) {
                delete m_pResourceType[i];
            }

            m_pResourceType[i] = new CResourceType(m_pMachine, ResType);

            CCookie* pCookieType = new CCookie(COOKIE_TYPE_RESULTITEM_RESTYPE);

            if (pCookieType) {
                pCookieType->SetResultItem(m_pResourceType[i]);
                pCookieType->SetScopeItem(m_pFolder->m_pScopeItem);
                pCookieType->SetParent(m_pCookieComputer);

                if (pCookieTypeSibling) {
                    pCookieTypeSibling->SetSibling(pCookieType);
                } else {
                    m_pCookieComputer->SetChild(pCookieType);
                }
                pCookieTypeSibling = pCookieType;

                RestoreSavedTreeState(pCookieType);

                //
                // Create the resource result item for each resource.
                //
                while (pRes) {
                    CCookie* pCookie = new CCookie(CookieType(ResType));
                    pCookie->SetResultItem(pRes);
                    pCookie->SetScopeItem(m_pFolder->m_pScopeItem);

                    if (pCookieFirst) {
                        InsertCookieToTree(pCookie, pCookieFirst, TRUE);
                    } else {
                        pCookieFirst = pCookie;
                        pCookieType->SetChild(pCookie);
                        pCookie->SetParent(pCookieType);
                    }
                    RestoreSavedTreeState(pCookie);

                    //
                    // Get the next resource item.
                    //
                    m_pResourceList[i]->GetNext(&pRes, Context);
                }
            }
        }
    }

    //
    // The saved tree states have been merged into the newly
    // create cookie tree. destroy the states
    //
    DestroySavedTreeStates();
}

//
// This function insert the given cookie into a existing cookie subtree
// rooted at pCookieRoot.  If the resource is I/O or MEMORY then the cookie is
// inserted as a child of any resource it is enclosed by.
//
//INPUT:
//     pCookie -- the cookie to be inserted.
//     pCookieRoot -- the subtree root cookie
//     ForcedInsert -- TRUE to insert the cookie as the sibling of
//                     of pCookieRoot.
//OUTPUT:
//  None
BOOL
CViewResourceTree::InsertCookieToTree(
                                     CCookie* pCookie,
                                     CCookie* pCookieRoot,
                                     BOOL     ForcedInsert
                                     )
{
    CResource* pResRef;
    CResource* pResThis = (CResource*)pCookie->GetResultItem();
    CCookie* pCookieLast = NULL;

    while (pCookieRoot) {
        //
        // Only check for enclosed resources for I/O and MEMORY.
        //
        if (COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
            COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType()) {
            pResRef = (CResource*)pCookieRoot->GetResultItem();

            if (pResThis->EnclosedBy(*pResRef)) {
                //
                // This cookie is either the pCookieRoot child or grand child
                // figure out which one it is
                //
                if (!pCookieRoot->GetChild()) {
                    pCookieRoot->SetChild(pCookie);
                    pCookie->SetParent(pCookieRoot);
                } else if (!InsertCookieToTree(pCookie, pCookieRoot->GetChild(), FALSE)) {
                    //
                    // The cookie is not a grand child of pCookieRoot.
                    // search for the last child of pCookieRoot
                    //
                    CCookie* pCookieSibling;
                    pCookieSibling = pCookieRoot->GetChild();

                    while (pCookieSibling->GetSibling()) {
                        pCookieSibling = pCookieSibling->GetSibling();
                    }

                    pCookieSibling->SetSibling(pCookie);
                    pCookie->SetParent(pCookieRoot);
                }

                return TRUE;
            }
        }

        pCookieLast = pCookieRoot;
        pCookieRoot = pCookieRoot->GetSibling();
    }

    if (ForcedInsert) {
        if (pCookieLast) {
            //
            // When we reach here, pCookieLast is the last child
            //
            pCookieLast->SetSibling(pCookie);
            pCookie->SetParent(pCookieLast->GetParent());
        }

        return TRUE;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//// CBusPropPageProvider implementations
////

//
// This function loads the bus property sheet pages provider
// to enumerate pages for the device
// INPUT:
//      pDevice -- object represents the device
//      ppsd    -- object represents where property pages should be added
// OUTPUT:
//      TRUE if succeeded.
//      FLASE if no pages are added.
BOOL
CBusPropPageProvider::EnumPages(
                               CDevice* pDevice,
                               CPropSheetData* ppsd
                               )
{
    ASSERT(!m_hDll);

    //
    // Enum bus property pages if there are any
    // if the a bus guid can not be found on the device, no bus property pages
    //
    String strBusGuid;

    if (pDevice->m_pMachine->CmGetBusGuidString(pDevice->GetDevNode(), strBusGuid)) {
        CSafeRegistry regDevMgr;
        CSafeRegistry regBusTypes;
        CSafeRegistry regBus;

        if (regDevMgr.Open(HKEY_LOCAL_MACHINE, REG_PATH_DEVICE_MANAGER) &&
            regBusTypes.Open(regDevMgr, REG_STR_BUS_TYPES) &&
            regBus.Open(regBusTypes, strBusGuid)) {
            String strEnumPropPage;

            if (regBus.GetValue(REGSTR_VAL_ENUMPROPPAGES_32, strEnumPropPage)) {
                PROPSHEET_PROVIDER_PROC PropPageProvider;

                if (LoadEnumPropPage32(strEnumPropPage, &m_hDll, (FARPROC*)&PropPageProvider)) {
                    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
                    PropPageRequest.cbSize = sizeof(PropPageRequest);
                    PropPageRequest.DeviceInfoSet = (HDEVINFO)*(pDevice->m_pMachine);
                    PropPageRequest.DeviceInfoData = *pDevice;
                    PropPageRequest.PageRequested = SPPSR_ENUM_ADV_DEVICE_PROPERTIES;

                    if (PropPageProvider(&PropPageRequest,
                                         (LPFNADDPROPSHEETPAGE)AddPropPageCallback,
                                         (LPARAM)ppsd
                                        ))
                        return TRUE;
                }
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\cfolder.h ===
#ifndef __CFOLDER_H__
#define __CFOLDER_H__
/*++

Copyright (C) Microsoft Corporation

Module Name:

    cfolder.h

Abstract:

    header file for cfolder.cpp.

Author:

    William Hsieh (williamh) created

Revision History:


--*/

class CFolder;
class CResultView;
class CViewTreeByType;
class CViewTreeByConnection;
class CViewResourceTree;
class CComponent;

const int IMAGE_INDEX_START = 20;
const int IMAGE_INDEX_DEVMGR    = IMAGE_INDEX_START;
const int OPEN_IMAGE_INDEX_DEVMGR = IMAGE_INDEX_DEVMGR;

typedef enum tagViewType {
    VIEW_DEVICESBYTYPE = 0,
    VIEW_DEVICESBYCONNECTION,
    VIEW_RESOURCESBYTYPE,
    VIEW_RESOURCESBYCONNECTION,
    VIEW_NONE
}VIEWTYPE, *PVIEWTYPE;

typedef struct tagMMCMenuItem {
    int     idName;
    int     idStatusBar;
    long    lCommandId;
    VIEWTYPE Type;
}MMCMENUITEM, *PMMCMENUITEM;

const VIEWTYPE VIEW_FIRST = VIEW_DEVICESBYTYPE;
const VIEWTYPE VIEW_LAST = VIEW_RESOURCESBYCONNECTION;

const int TOTAL_VIEWS = VIEW_LAST - VIEW_FIRST + 1;
const int TOTAL_RESOURCE_TYPES = 4;

extern const MMCMENUITEM ViewDevicesMenuItems[];

typedef struct tagDevMgrFolderStates {
    COOKIE_TYPE Type;
    VIEWTYPE    CurViewType;
    BOOL        ShowHiddenDevices;
}DEVMGRFOLDER_STATES, *PDEVMGRFOLDER_STATES;

typedef DWORD FOLDER_SIGNATURE;

const FOLDER_SIGNATURE_DEVMGR  = 0x00FF00FF;

//
// This is the class created and maintained by IComponentData
//
class CScopeItem {
public:
    CScopeItem(COOKIE_TYPE ct, int iImage, int iOpenImage, int iNameStringId, int iDescStringId, int iDisplayNameFormatId)
    {
        UNREFERENCED_PARAMETER(iDisplayNameFormatId);
        
        m_iImage = iImage;
        m_iOpenImage = iOpenImage;
        m_iNameStringId = iNameStringId;
        m_iDescStringId = iDescStringId;
        m_Enumerated = FALSE;
        m_hScopeItem = NULL;
        m_Type = ct;
    }
    virtual CFolder* CreateFolder(CComponent* pComponent);
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* pInsertionAllowed);
    virtual HRESULT MenuCommand(long lCommandId);
    virtual HRESULT QueryPagesFor();
    virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                        LONG_PTR handle);
    virtual ~CScopeItem();
    virtual BOOL Create();
    HRESULT GetDisplayInfo(LPSCOPEDATAITEM pScopeDataItem);
    void SetScopeItemID(HSCOPEITEM hScopeItem)
    {
        m_hScopeItem = hScopeItem;
    }
    const int   GetImageIndex() const
    {
        return m_iImage;
    }
    const int   GetOpenImageIndex() const
    {
        return m_iOpenImage;
    }
    const TCHAR* GetNameString()    const
    {
        return(LPCTSTR)m_strName;
    }
    const TCHAR* GetDescString() const
    {
        return(LPCTSTR)m_strDesc;
    }
    operator HSCOPEITEM()
    {
        return m_hScopeItem;
    }
    BOOL EnumerateChildren(int Index, CScopeItem** ppChild);
    int  GetChildCount()
    {
        return m_listChildren.GetCount();
    }
    COOKIE_TYPE GetType()
    {
        return m_Type;
    }
    void SetHandle(HSCOPEITEM hScopeItem)
    {
        m_hScopeItem = hScopeItem;
    }

    BOOL IsEnumerated()
    {
        return m_Enumerated;
    }
    void Enumerated()
    {
        m_Enumerated = TRUE;
    }
    HRESULT Reset();

protected:
    CCookie* FindSelectedCookieData(CResultView** ppResultView);
    int        m_iNameStringId;
    int        m_iDescStringId;
    int        m_iImage;
    int        m_iOpenImage;
    String     m_strName;
    String     m_strDesc;
    BOOL       m_Enumerated;
    HSCOPEITEM m_hScopeItem;
    COOKIE_TYPE m_Type;
    CList<CFolder*, CFolder*> m_listFolder;
    CList<CScopeItem*, CScopeItem*> m_listChildren;
};


// While ScopeItem objects are created and managed by CComponentData,
// CFolder objects are created and managed by CComponent class.
// CComponent objects are created and managed by CComponentData.
// A CComponent object is created when a new window is created.
// For each CScopeItem, CComponent creates a CFolder object to
// represent that CScopeItem in the CComponent's window.
// CFolder is responsible for painting the result pane that represents
// the visual states of its associated CScopeItem.
//
class CFolder {
public:
    CFolder(CScopeItem* pScopeItem, CComponent* pComponent);
    virtual ~CFolder();

    virtual HRESULT Compare(MMC_COOKIE cookieA, MMC_COOKIE cookieB, int nCol, int* pnResult);
    virtual HRESULT GetDisplayInfo(LPRESULTDATAITEM pResultDataItem);
    virtual HRESULT AddMenuItems(CCookie* pCookie, LPCONTEXTMENUCALLBACK pCallback, long* pInsertionAllowed);
    virtual HRESULT MenuCommand(CCookie* pCookie, long lCommandId);
    virtual HRESULT QueryPagesFor(CCookie* pCookie);
    virtual HRESULT CreatePropertyPages(CCookie* pCookie, LPPROPERTYSHEETCALLBACK lpProvider,
                                        LONG_PTR handle);
    virtual HRESULT OnShow(BOOL fShow);
    virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
    virtual CResultView* GetCurResultView()
    {
        return m_pCurView;
    }
    virtual int GetPersistDataSize()
    {
        return sizeof(DEVMGRFOLDER_STATES);
    }
    virtual HRESULT GetPersistData(PBYTE pBuffer, int BufferSize);
    virtual HRESULT SetPersistData(PBYTE pData, int Size);
    LPCTSTR GetNameString()
    {
        return m_pScopeItem->GetNameString();
    }
    LPCTSTR GetDescString()
    {
        return m_pScopeItem->GetDescString();
    }
    FOLDER_SIGNATURE GetSignature()
    {
        return m_Signature;
    }
    virtual HRESULT tvNotify(HWND hwndTV, CCookie* pCookie, TV_NOTIFY_CODE Code, LPARAM arg, LPARAM param);
    virtual HRESULT MachinePropertyChanged(CMachine* pMachine);
    virtual HRESULT OnOcxNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    virtual HRESULT OnRestoreView(BOOL* pfHandled);
    virtual HRESULT OnSelect()
    {
        // If the folder is selected, reset the console verbs.
        if (m_bSelect)
            return S_FALSE;
        else
            return S_OK;
    }
    ULONG AddRef()
    {
        return ++m_Ref;
    }
    ULONG Release()
    {
        ASSERT(m_Ref);
        --m_Ref;

        if (!m_Ref) {
            delete this;
            return 0;
        }
        return m_Ref;
    }
    virtual HRESULT Reset();
    BOOL ShowHiddenDevices()
    {
        return m_ShowHiddenDevices;
    }
    BOOL SelectView(VIEWTYPE ViewType, BOOL fShowHiddenDevices);
    HRESULT DoProperties(HWND hwndParent, CCookie* pCookie);
    CComponent*     m_pComponent;
    CScopeItem*     m_pScopeItem;
    CMachine*       m_pMachine;
    BOOL            m_bSelect;          // Saved by MMCN_SELECT for MenuCommand

protected:
    FOLDER_SIGNATURE m_Signature;
    BOOL        m_Show;
    String      m_strScratch;
    LPOLESTR    m_pOleTaskString;
    ULONG       m_Ref;

private:
    CViewTreeByType*        m_pViewTreeByType;
    CViewTreeByConnection*  m_pViewTreeByConnection;
    CViewResourceTree*      m_pViewResourcesByType;
    CViewResourceTree*      m_pViewResourcesByConnection;
    CResultView*            m_pCurView;
    VIEWTYPE                m_CurViewType;
    BOOL                    m_ShowHiddenDevices;
    BOOL                    m_FirstTimeOnShow;
};

class CResultView {
public:
    CResultView(int DescStringId) :
        m_DescStringId(DescStringId),
        m_pFolder(NULL),
        m_pMachine(NULL),
        m_pCookieComputer(NULL),
        m_pIDMTVOCX(NULL),
        m_hwndTV(NULL),
        m_pSelectedCookie(NULL),
        m_SelectOk(FALSE),
        m_pSelectedItem(NULL)
    {
        String stringWorking, stringProblem, stringDisabled, stringForced;

        stringWorking.LoadString(g_hInstance, IDS_ANNOTATION_WORKING);
        stringProblem.LoadString(g_hInstance, IDS_ANNOTATION_PROBLEM);
        stringDisabled.LoadString(g_hInstance, IDS_ANNOTATION_DISABLED);
        stringForced.LoadString(g_hInstance, IDS_ANNOTATION_FORCED);

        m_stringAnnotationMap.Format(TEXT("A:2:%d:%s:%d:%s:%d:%s:%d:%s:"),
            0,
            (LPTSTR)stringWorking,
            (IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1),
            (LPTSTR)stringProblem,
            (IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1),
            (LPTSTR)stringDisabled,
            (IDI_FORCED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1),
            (LPTSTR)stringForced);
    }
    virtual ~CResultView();
    virtual HRESULT GetDisplayInfo(LPRESULTDATAITEM pResultDataItem)
    {
        UNREFERENCED_PARAMETER(pResultDataItem);
        return S_OK;
    }
    virtual HRESULT OnShow(BOOL fShow);
    LPCTSTR GetStartupDeviceId();
    LPCTSTR GetStartupCommand();
    void SetFolder(CFolder* pFolder)
    {
        m_pFolder = pFolder;
    }
    int GetDescriptionStringID()
    {
        return m_DescStringId;
    }
    virtual CCookie* GetSelectedCookie()
    {
        return m_pSelectedCookie;
    }
    void SetSelectOk(BOOL fSelect)
    {
        m_SelectOk = fSelect;
    }
    HRESULT MachinePropertyChanged(CMachine* pMachine);
    void SaveTreeStates(CCookie* pCookieStart);
    void DestroySavedTreeStates();
    void RestoreSavedTreeState(CCookie* pCookie);
    BOOL DisplayTree();
    HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
    HRESULT AddMenuItems(CCookie* pCookie, LPCONTEXTMENUCALLBACK pCallback,
                         long* pInsertionAllowed, BOOL fContextMenu);
    HRESULT MenuCommand(CCookie* pCookie, long lCommandId);
    HRESULT QueryPagesFor(CCookie* pCookie);
    HRESULT CreatePropertyPages(CCookie* pCookie, LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle);
    HRESULT tvNotify(HWND hwndTV, CCookie* pCookie, TV_NOTIFY_CODE Code, LPARAM arg, LPARAM param);
    HRESULT OnOcxNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    HRESULT DoProperties(HWND hwndParent, CCookie* pCookie);
    HRESULT DoContextMenu(HWND hwndParent, CCookie* pCookie, POINT* pPoint);
    HRESULT DoPrint();

protected:
    BOOL    DisplaySubtree(HTREEITEM htiParent, CCookie* pCookieStart, BOOL* pReportProblem = NULL);
    HRESULT UpdateConsoleVerbs(CCookie* pCookie);
    CFolder*    m_pFolder;
    int         m_DescStringId;
    CMachine*   m_pMachine;
    CCookie*    m_pCookieComputer;
    IDMTVOCX*   m_pIDMTVOCX;
    CCookie*    m_pSelectedCookie;
    BOOL        m_SelectOk;
    HWND        m_hwndTV;
    CList<CItemIdentifier*, CItemIdentifier*> m_listExpandedItems;
    CItemIdentifier*        m_pSelectedItem;
    String      m_stringAnnotationMap;

private:
    HRESULT RemoveDevice(CDevice* pDevice);
};

class CViewDeviceTree : public CResultView {
public:
    CViewDeviceTree(int DescStringId)
        : CResultView(DescStringId)
        {}
    virtual ~CViewDeviceTree() {}
    virtual HRESULT OnShow(BOOL fShow);
    virtual BOOL  CreateDeviceTree();

protected:
private:
};

class CViewTreeByType : public CViewDeviceTree {
public:
    CViewTreeByType()
        : CViewDeviceTree(IDS_STATUS_DEVICES_BYTYPE)
        {}
    virtual BOOL CreateDeviceTree();
};

class CViewTreeByConnection : public CViewDeviceTree {
public:
    CViewTreeByConnection()
        : CViewDeviceTree(IDS_STATUS_DEVICES_BYCONN)
        {}
    virtual BOOL CreateDeviceTree();
private:
    BOOL CreateSubtree(CCookie* pCookieParent, CCookie* pCookieSibling, CDevice* pDeviceStart);
};

class CViewResourceTree : public CResultView {
public:
    CViewResourceTree(int DescStringId)
    : CResultView(DescStringId)
    {
        int i;

        for (i = 0; i < TOTAL_RESOURCE_TYPES; i++) {
            m_pResourceList[i] = NULL;
            m_pResourceType[i] = NULL;
        }
    }
    ~CViewResourceTree();
    virtual HRESULT OnShow(BOOL fShow);
protected:
    private:
    void    CreateResourceTree();
    void    CreateResourceSubtree(CCookie* pCookieParent,
                                  CCookie* pCookieSibling,
                                  CDevice* pDevice, CCookie** ppLastCookie = NULL);
    BOOL    InsertCookieToTree(CCookie* pCookie, CCookie* pCookieStart,
                               BOOL ForcedInsert);
    void    DestroyResourceTree();
    CResourceList*  m_pResourceList[TOTAL_RESOURCE_TYPES];
    CResourceType*  m_pResourceType[TOTAL_RESOURCE_TYPES];
};

typedef BOOL (CALLBACK* PROPSHEET_PROVIDER_PROC)(
                                                PSP_PROPSHEETPAGE_REQUEST   PropPageRequest,
                                                LPFNADDPROPSHEETPAGE    lpfnAddPropPageProc,
                                                LPARAM          lParam
                                                );

class CPropPageProvider {
public:
    CPropPageProvider() : m_hDll(NULL)
    {}
    virtual ~CPropPageProvider()
    {
        if (m_hDll)
            FreeLibrary(m_hDll);
    }
    virtual BOOL EnumPages(CDevice* pDevice, CPropSheetData* ppsd) = 0;
protected:
    HMODULE m_hDll;
};

class CBusPropPageProvider : public CPropPageProvider {
public:
    virtual BOOL EnumPages(CDevice* pDevice, CPropSheetData* ppsd);
};

#endif // __CFOLDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\clsgenpg.h ===
// clsgenpg.h : header file
//

#ifndef __CLSGENPG_H__
#define __CLSGENPG_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    clsgenpg.h

Abstract:

    header file for clsgenpg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"

#define IDH_DISABLEHELP	(DWORD(-1))

class CClassGeneralPage : public CPropSheetPage
{
public:
    CClassGeneralPage() : m_pClass(NULL),
			  CPropSheetPage(g_hInstance, IDD_CLSGEN_PAGE)
	{}
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    virtual UINT DestroyCallback();

    HPROPSHEETPAGE Create(CClass* pClass);

private:
    CClass* m_pClass;
};

#endif // __CLSGENPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\cnode.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    cnode.cpp

Abstract:

    This module implements CDevice, CClass, CResource and CComputer classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "cdriver.h"
#include "hwprof.h"
#include "sysinfo.h"
#include <initguid.h>
#include <mountmgr.h>
#include <devguid.h>
#include <wdmguid.h>


//
// CClass implementation
//
CClass::CClass(
    CMachine* pMachine,
    GUID* pGuid
    )
{
    m_Guid = *pGuid;
    ASSERT(pMachine);
    ASSERT(pGuid);

    m_NoDisplay = FALSE;
    m_pMachine = pMachine;
    m_TotalDevices = 0;
    m_TotalHiddenDevices = 0;
    m_pDevInfoList = NULL;
    m_pos = NULL;

    if (!m_pMachine->DiGetClassFriendlyNameString(pGuid, m_strDisplayName)) 
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN);
    }
    
    m_pMachine->DiGetClassImageIndex(pGuid, &m_iImage);

    HKEY hKey = m_pMachine->DiOpenClassRegKey(pGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) 
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_NODISPLAYCLASS, NULL, NULL, NULL, NULL)) 
        {
            m_NoDisplay = TRUE;
        }
        
        RegCloseKey(hKey);
    }
}

CDevInfoList*
CClass::GetDevInfoList(
    HWND hwndParent
    )
{
    if (!m_pDevInfoList) 
    {
        HDEVINFO hDevInfo = m_pMachine->DiCreateDeviceInfoList(&m_Guid, hwndParent);

        if (hDevInfo && INVALID_HANDLE_VALUE != hDevInfo) 
        {
            m_pDevInfoList = new CDevInfoList(hDevInfo, hwndParent);
        }
    }
    
    return m_pDevInfoList;
}

inline
CItemIdentifier*
CClass::CreateIdentifier()
{
    return new CClassIdentifier(*this);
}

CClass::~CClass()
{
    m_listDevice.RemoveAll();

    if (m_pDevInfoList)
    {
        delete m_pDevInfoList;
    }
}

HICON
CClass::LoadIcon()
{
    HICON hClassIcon;

    if (!m_pMachine->DiLoadClassIcon(&m_Guid, &hClassIcon, NULL))
    {
        return NULL;
    }
    
    return hClassIcon;
}

void
CClass::AddDevice(CDevice* pDevice)
{
    ASSERT(pDevice);

    m_listDevice.AddTail(pDevice);
    m_TotalDevices++;

    if (pDevice->IsHidden()) {
    
        m_TotalHiddenDevices++;
    }
}

BOOL
CClass::GetFirstDevice(
    CDevice** ppDevice,
    PVOID&    Context
    )
{
    ASSERT(ppDevice);

    if (!m_listDevice.IsEmpty()) 
    {
        POSITION pos;

        pos = m_listDevice.GetHeadPosition();
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;

        return TRUE;
    }
    
    *ppDevice = NULL;

    return FALSE;
}

BOOL
CClass::GetNextDevice(
    CDevice** ppDevice,
    PVOID&    Context
    )
{
    ASSERT(ppDevice);

    POSITION pos = (POSITION)(Context);

    if(NULL != pos) 
    {
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    *ppDevice = NULL;

    return FALSE;
}

void
CClass::PropertyChanged()
{
    if (!m_pMachine->DiGetClassFriendlyNameString(&m_Guid, m_strDisplayName))
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN);
    }
    
    m_pMachine->DiGetClassImageIndex(&m_Guid, &m_iImage);

    if (m_pDevInfoList) 
    {
        delete m_pDevInfoList;
        m_pDevInfoList = NULL;
    }
    
    HKEY hKey = m_pMachine->DiOpenClassRegKey(&m_Guid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) 
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_NODISPLAYCLASS, NULL, NULL, NULL, NULL))
        {
            m_NoDisplay = TRUE;
        }
        
        RegCloseKey(hKey);
    }
}

// CDevice implementation
//
CDevice::CDevice(
    CMachine* pMachine,
    CClass* pClass,
    PSP_DEVINFO_DATA pDevData
    )
{
    ASSERT(pMachine && pDevData && pClass);
    
    m_DevData = *pDevData;
    m_pClass = pClass;
    m_pMachine = pMachine;
    m_pSibling = NULL;
    m_pParent = NULL;
    m_pChild = NULL;

    if (!m_pMachine->CmGetDescriptionString(m_DevData.DevInst, m_strDisplayName))
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN_DEVICE);
    }
    
    m_pMachine->CmGetDeviceIDString(m_DevData.DevInst, m_strDeviceID);
    m_iImage = m_pClass->GetImageIndex();
}

inline
CItemIdentifier*
CDevice::CreateIdentifier()
{
    return new CDeviceIdentifier(*this);
}

void
CDevice::PropertyChanged()
{
    if (!m_pMachine->CmGetDescriptionString(m_DevData.DevInst, m_strDisplayName))
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN_DEVICE);
    }
    
    m_pMachine->CmGetDeviceIDString(m_DevData.DevInst, m_strDeviceID);
    m_iImage = m_pClass->GetImageIndex();
}

HICON
CDevice::LoadClassIcon()
{
    HICON hClassIcon;
    hClassIcon = NULL;

    if (m_pMachine->DiLoadClassIcon(&m_DevData.ClassGuid, &hClassIcon, NULL))
    {
        return hClassIcon;
    }

    return NULL;
}

BOOL
CDevice::GetStatus(
    DWORD* pStatus,
    DWORD* pProblem
    )
{
    return  m_pMachine->CmGetStatus(m_DevData.DevInst, pProblem, pStatus);
}

BOOL
CDevice::GetCapabilities(
    DWORD* pCapabilities
    )
{
    return m_pMachine->CmGetCapabilities(m_DevData.DevInst, pCapabilities);
}

BOOL
CDevice::GetPowerCapabilities(
    DWORD* pCapabilities
    )
{
    CM_POWER_DATA CmPowerData;
    ULONG Size;

    Size = sizeof(CmPowerData);
    if (m_pMachine->CmGetRegistryProperty(m_DevData.DevInst,
                                          CM_DRP_DEVICE_POWER_DATA,
                                          &CmPowerData,
                                          &Size
                                          ) == CR_SUCCESS) {

        *pCapabilities = CmPowerData.PD_Capabilities;
        return TRUE;
    }

    *pCapabilities = 0;
    return FALSE;
}

BOOL
CDevice::IsRAW()
{
    DWORD Capabilities;
    
    return (m_pMachine->CmGetCapabilities(m_DevData.DevInst, &Capabilities) &&
            (CM_DEVCAP_RAWDEVICEOK & Capabilities));
}

BOOL
CDevice::IsHidden()
{
    CClass *pClass = GetClass();

    //
    // A device is hidden if one of the following are TRUE:
    //
    // - It's class is a NoDisplayClass
    // - It has the DN_NO_SHOW_IN_DM Status flag set
    // - It is a Phantom devnode
    //
    return (NoShowInDM() || IsPhantom() || pClass->NoDisplay());
}

BOOL
CDevice::IsPhantom()
{
    DWORD Status, Problem;

    return !m_pMachine->CmGetStatus(m_DevData.DevInst, &Problem, &Status) &&
            (CR_NO_SUCH_VALUE == m_pMachine->GetLastCR() ||
            CR_NO_SUCH_DEVINST == m_pMachine->GetLastCR());
}

BOOL
CDevice::NoShowInDM()
{
    DWORD Status, Problem;
    Status = 0;
    
    if (GetStatus(&Status, &Problem) &&
        (Status & DN_NO_SHOW_IN_DM)) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::IsUninstallable(
    )
/*++

    This function determins whether a device can be uninstalled. A device
    cannot be uninstalled if it is a ROOT device and it does not have
    the DN_DISABLEABLE DevNode status bit set.
    
Return Value:
    TRUE if the device can be uninstalled.
    FALSE if the device cannot be uninstalled.    
    
--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem) &&
        !(Status & DN_DISABLEABLE) &&
         (Status & DN_ROOT_ENUMERATED)) {

        return FALSE;
    }
    
    return TRUE;
}

BOOL
CDevice::IsDisableable(
    )
/*++

    This function determins whether a device can be disabled or not by 
    checking the DN_DISABLEABLE DevNode status bit.
    
    A device that is currently Hardware Disabled cannot be software disabled.
    
Return Value:
    TRUE if the device can be disabled.
    FALSE if the device cannot be disabled.    

--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem) &&
        (Status & DN_DISABLEABLE) &&
        (CM_PROB_HARDWARE_DISABLED != Problem)) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::IsDisabled(
    )
/*++

    A device is disabled if it has the problem CM_PROB_DISABLED.  
    
Return Value:    
    TRUE if device is disabled.
    FALSE if device is NOT disabled.
    
--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem)) 
    {
        return ((Status & DN_HAS_PROBLEM) && (CM_PROB_DISABLED == Problem));
    }

    return FALSE;
}

BOOL
CDevice::IsStateDisabled(
    )
/*++

    A device state is disabled if it has the CONFIGFLAG_DISABLED ConfigFlag
    set or the CSCONFIGFLAG_DISABLED Config Specific ConfigFlag disabled in 
    the current profile.
    
    Note that a device disabled State has nothing to do with whether the device
    is currently physically disabled or not.  The disabled state is just a registry
    flag that tells Plug and Play what to do with the device the next time it is 
    started.
    
Return Value:    
    TRUE if device's state is disabled.
    FALSE if device's state is NOT disabled.
    
--*/
{
    ULONG hwpfCurrent;
    DWORD Flags;

    //
    // Check if the device state is globally disabled by checking it's ConfigFlags
    //
    GetConfigFlags(&Flags);
    if (Flags & CONFIGFLAG_DISABLED) {
        return TRUE;
    }

    //
    // Check if the device state is disabled in the current hardware profile by 
    // checking it's Config Specific ConfigFlags.
    //
    if (m_pMachine->CmGetCurrentHwProfile(&hwpfCurrent) &&
        m_pMachine->CmGetHwProfileFlags(m_DevData.DevInst, hwpfCurrent, &Flags) &&
        (Flags & CSCONFIGFLAG_DISABLED)) {
        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::IsStarted()
{
    DWORD Status, Problem;    
    
    //
    // Check to see if the DN_STARTED devnode status flag is set.
    //
    if (GetStatus(&Status, &Problem) &&
        (Status & DN_STARTED))
    {
        return TRUE;
    }
    
    return FALSE;
}

BOOL
CDevice::HasProblem(
    )
/*++

    This function returns whether a device has a problem or not.
    
Return Value:    
    TRUE if device has a problem.
    FALSE if device does not have a problem.
    
--*/
{
    DWORD Status, Problem;    
    
    if (GetStatus(&Status, &Problem))
    {
        //
        // If the DN_HAS_PROBLEM or DN_PRIVATE_PROBLEM status bits are set
        // then this device has a problem, unless the problem is CM_PROB_MOVED.
        //
        if ((Status & DN_PRIVATE_PROBLEM) ||
            ((Status & DN_HAS_PROBLEM) && (Problem != CM_PROB_MOVED)))
        {
            return TRUE;
        }

        //
        // If the device is not started and RAW capable then it also has a problem
        //
        if (!(Status & DN_STARTED) && IsRAW()) 
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
CDevice::NeedsRestart(
    )
/*++

    This function returns whether a device needs a restart or not.  It checks the
    DN_NEED_RESTART Status flag.  
    
Return Value:    
    TRUE if device needs the computer to be restarted for it to work properly.
    FALSE if device does not need the computer to be restarted.
    
--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem)) 
    {
        return (Status & DN_NEED_RESTART);
    }

    return FALSE;
}

BOOL
CDevice::IsPCIDevice()
{
    GUID BusGuid;

    if (m_pMachine->CmGetBusGuid(GetDevNode(), &BusGuid) &&
        IsEqualGUID(BusGuid, GUID_BUS_TYPE_PCI)) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::GetConfigFlags(
    DWORD* pFlags
    )
{
    return m_pMachine->CmGetConfigFlags(m_DevData.DevInst, pFlags);
}

BOOL
CDevice::GetConfigSpecificConfigFlags(
    DWORD* pCSStatus
    )
{
    ULONG hwpfCurrent;

    if (m_pMachine->CmGetCurrentHwProfile(&hwpfCurrent) &&
        m_pMachine->CmGetHwProfileFlags(m_DevData.DevInst, hwpfCurrent, pCSStatus)) {
        
        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::GetKnownLogConf(LOG_CONF* plc, DWORD* plcType)
{
    return m_pMachine->CmGetKnownLogConf(m_DevData.DevInst, plc, plcType);
}

BOOL
CDevice::HasResources()
{
    return m_pMachine->CmHasResources(m_DevData.DevInst);
}

void
CDevice::GetMFGString(
    String& strMFG
    )
{
    m_pMachine->CmGetMFGString(m_DevData.DevInst, strMFG);

    if (strMFG.IsEmpty()) 
    {
        strMFG.LoadString(g_hInstance, IDS_UNKNOWN);
    }
}

void
CDevice::GetProviderString(
    String& strProvider
    )
{
    m_pMachine->CmGetProviderString(m_DevData.DevInst, strProvider);
    
    if (strProvider.IsEmpty()) {
    
        strProvider.LoadString(g_hInstance, IDS_UNKNOWN);
    }
}

void
CDevice::GetDriverDateString(
    String& strDriverDate
    )
{
    FILETIME ft;

    strDriverDate.Empty();

    //
    // First try to get the driver date FileTime data from the registry,
    // this way we can localize the date.
    //
    if (m_pMachine->CmGetDriverDateData(m_DevData.DevInst, &ft)) {

        SYSTEMTIME SystemTime;
        TCHAR DriverDate[MAX_PATH];

        DriverDate[0] = TEXT('\0');

        if (FileTimeToSystemTime(&ft, &SystemTime)) {

            if (GetDateFormat(LOCALE_USER_DEFAULT,
                          DATE_SHORTDATE,
                          &SystemTime,
                          NULL,
                          DriverDate,
                          ARRAYLEN(DriverDate)
                          ) != 0) {

                strDriverDate = DriverDate;
            }
        }

    } else {
    
        //
        // We couldn't get the FileTime data so just get the DriverDate string
        // from the registry.
        //
        m_pMachine->CmGetDriverDateString(m_DevData.DevInst, strDriverDate);
    }

    if (strDriverDate.IsEmpty()) {
    
        strDriverDate.LoadString(g_hInstance, IDS_NOT_AVAILABLE);
    }
}

void
CDevice::GetDriverVersionString(
    String& strDriverVersion
    )
{
    m_pMachine->CmGetDriverVersionString(m_DevData.DevInst, strDriverVersion);

    if (strDriverVersion.IsEmpty()) {
    
        strDriverVersion.LoadString(g_hInstance, IDS_NOT_AVAILABLE);
    }
}

LPCTSTR
CDevice::GetClassDisplayName()
{
    if (m_pClass)
    {
        return m_pClass->GetDisplayName();
    }
    
    else
    {
        return NULL;
    }
}

BOOL
CDevice::NoChangeUsage()
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (m_pMachine->DiGetDeviceInstallParams(&m_DevData, &dip))
    {
        return (dip.Flags & DI_PROPS_NOCHANGEUSAGE);
    }
    
    else
    {
        return TRUE;
    }
}

CDriver*
CDevice::CreateDriver()
{
    CDriver* pDriver = NULL;

    pDriver = new CDriver();

    if (!pDriver) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    pDriver->Create(this);

    return pDriver;
}

DWORD
CDevice::EnableDisableDevice(
    HWND hDlg,
    BOOL Enabling
    )
{
    BOOL Disabling = !Enabling;
    BOOL Canceled;
    Canceled = FALSE;
    DWORD RestartFlags = 0;
    DWORD ConfigFlags;
    HCURSOR hCursorOld = NULL;
    BOOL Refresh = FALSE;

    //
    // Disable refreshing the TREE while we are enabling/disabling this device
    //
    m_pMachine->EnableRefresh(FALSE);

    if (!GetConfigFlags(&ConfigFlags)) {
        ConfigFlags = 0;
    }

    //
    // Only want the disabled bit
    //
    ConfigFlags &= CONFIGFLAG_DISABLED;

    CHwProfileList* pHwProfileList = new CHwProfileList();
    
    if (!pHwProfileList) {
        goto clean0;
    }

    pHwProfileList->Create(this, ConfigFlags);

    //
    // Get the current profile
    //
    CHwProfile* phwpf;

    if (!(pHwProfileList->GetCurrentHwProfile(&phwpf))) {
        goto clean0;
    }

    //
    // Can only enable a device that is currently disabled
    //
    if (IsStateDisabled() && Enabling) {
        phwpf->SetEnablePending();
    }

    //
    // Can only disable a device that is currently enabled
    //
    else if (!IsStateDisabled() && Disabling) {
        phwpf->SetDisablePending();
    }

    //
    // If we don't have a valid enable or disable then exit
    //
    if (!(phwpf->IsEnablePending()) && !(phwpf->IsDisablePending())) {
        goto clean0;
    }

    //
    // This device is not a boot device so just display the normal disable
    // warning to the user.
    //
    if (Disabling) {
        int MsgBoxResult;
        TCHAR szText[MAX_PATH];
        
        LoadResourceString(IDS_WARN_NORMAL_DISABLE, szText, ARRAYLEN(szText));
        MsgBoxResult = MessageBox(hDlg, 
                                  szText,
                                  GetDisplayName(),
                                  MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2
                                  );

        if (IDYES != MsgBoxResult) {
            goto clean0;
        }
    }

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // If this isn't a live devnode then we need to do a manual refresh if we
    // are diabling the device.
    // 
    Refresh = (!Enabling &&
               (IsPhantom() || 
                HasProblem() || 
                !IsStarted()));

    m_pMachine->DiTurnOnDiFlags(*this, DI_NODI_DEFAULTACTION);

    SP_PROPCHANGE_PARAMS pcp;
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    //
    // Now ask the class installer if the device can be specifically enabled/disabled
    //
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.StateChange = DICS_DISABLE;
    
    if (phwpf->IsEnablePending()) {
        pcp.StateChange = DICS_ENABLE;
    }
    
    pcp.HwProfile = phwpf->GetHwProfile();

    m_pMachine->DiSetClassInstallParams(*this,
                                        &pcp.ClassInstallHeader,
                                        sizeof(pcp)
                                        );
            
    m_pMachine->DiCallClassInstaller(DIF_PROPERTYCHANGE, *this);
    Canceled = (ERROR_CANCELLED == GetLastError());
    
    //
    // class installer has not objection of our enabling/disabling,
    // do real enabling/disabling.
    //
    if (!Canceled) {
        if (phwpf->IsDisablePending()) {
            pcp.StateChange = DICS_DISABLE;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = phwpf->GetHwProfile();
            m_pMachine->DiSetClassInstallParams(*this,
                                                &pcp.ClassInstallHeader,
                                                sizeof(pcp)
                                                );
                    
            m_pMachine->DiChangeState(*this);
        }
                    
        else {
            //
            // We are enabling the device,
            // do a specific enabling then a globally enabling.
            // the globally enabling will start the device
            // The implementation here is different from
            // Win9x which does a global enabling, a config
            // specific enabling and then a start.
            //
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = phwpf->GetHwProfile();
            m_pMachine->DiSetClassInstallParams(*this,
                                                &pcp.ClassInstallHeader,
                                                sizeof(pcp)
                                                );
                        
            m_pMachine->DiChangeState(*this);

            //
            // This call will start the device is it not started.
            //
            pcp.Scope = DICS_FLAG_GLOBAL;
            m_pMachine->DiSetClassInstallParams(*this,
                                                &pcp.ClassInstallHeader,
                                                sizeof(pcp)
                                                );
                        
            m_pMachine->DiChangeState(*this);
        }
                    
        if (phwpf->IsEnablePending()) {
            phwpf->ResetEnablePending();
        }
        
        else if (phwpf->IsDisablePending()) {
            phwpf->ResetDisablePending();
        }

        //
        // signal that the property of the device is changed.
        //
        m_pMachine->DiTurnOnDiFlags(*this, DI_PROPERTIES_CHANGE);

        //
        // See if we need a restart.
        //
        RestartFlags |= (m_pMachine->DiGetFlags(*this)) & (DI_NEEDRESTART | DI_NEEDREBOOT);

        if (NeedsRestart()) {
            RestartFlags |= DI_NEEDRESTART;
        }
    }

    //
    // Remove class install parameters, this also reset
    // DI_CLASSINATLLPARAMS
    //
    m_pMachine->DiSetClassInstallParams(*this, NULL, 0);

    m_pMachine->DiTurnOffDiFlags(*this, DI_NODI_DEFAULTACTION);

clean0:
    if (pHwProfileList) {
        delete pHwProfileList;
    }

    //
    // Enable the tree for refreshing.
    // We will only schedule a refresh ourselves if the device was not started 
    // before we tried to disable it, and we are not going to prompt for a reboot.
    // In all other cases we should get a WM_DEVICECHANGE which will cause us
    // to refresh our tree.
    //
    if (Refresh && !NeedsRestart()) {
        m_pMachine->ScheduleRefresh();
    }

    m_pMachine->EnableRefresh(TRUE);

    if (hCursorOld != NULL) {
        SetCursor(hCursorOld);
    }

    return RestartFlags;
}

//
// CComputer implementation
//
CComputer::CComputer(
    CMachine* pMachine,
    DEVNODE dnRoot
    )
{
    ASSERT(pMachine);
    ASSERT(!GetChild() && !GetParent() && !GetSibling());
    
    m_pMachine = pMachine;
    m_strDisplayName.Empty();
    m_strDisplayName = pMachine->GetMachineDisplayName();
    m_iImage = pMachine->GetComputerIconIndex();
    m_dnRoot = dnRoot;
}

inline
CItemIdentifier*
CComputer::CreateIdentifier()
{
    return new CComputerIdentifier(*this);
}


CResource::CResource(
    CDevice* pDevice,
    RESOURCEID ResType,
    DWORDLONG dlBase,
    DWORDLONG dlLen,
    BOOL Forced,
    BOOL Free
    )
{
    m_pChild = NULL;
    m_pSibling = NULL;
    m_pParent =  NULL;
    m_ResType = ResType;
    m_dlBase = dlBase;
    m_dlLen = dlLen;
    m_Forced = Forced;
    m_dlEnd = m_dlBase + m_dlLen - 1;
    m_Allocated = !Free;
    ASSERT(pDevice);
    m_pDevice = pDevice;
    m_iImage = pDevice->GetImageIndex();
    ASSERT(ResType >= ResType_Mem && ResType <= ResType_IRQ);

    m_strDisplayName.Empty();
    m_strDisplayName = pDevice->GetDisplayName();

    if (ResType_IRQ == m_ResType)
    {
        String strBus;

        strBus.LoadString(g_hInstance, 
                          pDevice->IsPCIDevice() ? IDS_PCI : IDS_ISA
                          );

        m_strViewName.Format(TEXT("%2d    "), m_dlBase);
        m_strViewName = strBus + m_strViewName;
    }
    
    else if (ResType_DMA == m_ResType)
    {
        m_strViewName.Format(TEXT("%2d    " ), m_dlBase);
    }
    
    else 
    {
#ifdef _WIN64
        m_strViewName.Format(TEXT("[%016I64X - %016I64X]  "), m_dlBase, m_dlEnd);
#else
        m_strViewName.Format(TEXT("[%08lX - %08lX]  "), (ULONG)m_dlBase, (ULONG)m_dlEnd);
#endif
    }
    
    if (m_Allocated) 
    {
        m_strViewName += pDevice->GetDisplayName();
    }
}

BOOL
CResource::operator <=(
    const CResource& resSrc
    )
{
    DWORDLONG dlBase, dlLen;

    resSrc.GetValue(&dlBase, &dlLen);

    if (m_dlBase < dlBase)
        return TRUE;
    
    //
    // If this resource contain the given resource,
    // we are smaller!
    //
    if (m_dlBase == dlBase)
        return (m_dlBase + m_dlLen > dlBase + dlLen);
    
    return FALSE;
}

BOOL
CResource::EnclosedBy(
    const CResource& resSrc
    )
{
    DWORDLONG dlBase, dlLen;
    resSrc.GetValue(&dlBase, &dlLen);
    return m_dlBase >= dlBase && m_dlBase + m_dlLen <= dlBase + dlLen;
}


CResourceType::CResourceType(
    CMachine* pMachine,
    RESOURCEID ResType
    )
{
    int iStringID;

    m_ResType = ResType;
    m_pChild = NULL;
    m_pSibling = NULL;
    m_pParent =  NULL;
    m_pMachine = pMachine;
    ASSERT(ResType >= ResType_Mem && ResType <= ResType_IRQ);

    switch (ResType)
    {
    case ResType_IRQ:
        iStringID = IDS_VIEW_RESOURCE_IRQ;
        break;
    
    case ResType_IO:
        iStringID = IDS_VIEW_RESOURCE_IO;
        break;
    
    case ResType_DMA:
        iStringID = IDS_VIEW_RESOURCE_DMA;
        break;
    
    case ResType_Mem:
        iStringID = IDS_VIEW_RESOURCE_MEM;
        break;
    
    default:
        iStringID = IDS_UNKNOWN;
        break;
    }

    m_strDisplayName.Empty();
    m_strDisplayName.LoadString(g_hInstance, iStringID);
    m_iImage = pMachine->GetResourceIconIndex();
}

inline
CItemIdentifier*
CResourceType::CreateIdentifier()
{
    return new CResourceTypeIdentifier(*this);
}


// This function creates CResourceList object to contain the designated
// resources for the given device.
// INPUT:
//      pDevice -- the device
//      ResType  -- what type of resource
//      LogConfType -- what type of logconf
// OUTPUT:
//      NONE.
//
// This function may throw CMemoryException
//
CResourceList::CResourceList(
    CDevice* pDevice,
    RESOURCEID ResType,
    ULONG LogConfType,
    ULONG AltLogConfType
    )
{
    ASSERT(ResType_All != ResType);
    ASSERT(BOOT_LOG_CONF == LogConfType ||
           FORCED_LOG_CONF == LogConfType ||
           ALLOC_LOG_CONF == LogConfType);
    ASSERT(pDevice);

    UNREFERENCED_PARAMETER(AltLogConfType);

    LOG_CONF lc;
    RES_DES rd, rdPrev;
    rdPrev;
    RESOURCEID ResId;
    BOOL Forced;
    CMachine* pMachine = pDevice->m_pMachine;
    ASSERT(pMachine);

    rdPrev = 0;

    //
    // Even though we have a valid logconf, it does not mean
    // GetNextResDes would succeed because the ResType is not
    // ResType_All.
    //
    if (pMachine->CmGetFirstLogConf(pDevice->GetDevNode(), &lc, LogConfType)) 
    {
        if (pMachine->CmGetNextResDes(&rd, lc, ResType, &ResId)) 
        {
            ULONG DataSize;
            DWORDLONG dlBase, dlLen;
            
            do 
            {
                DataSize = pMachine->CmGetResDesDataSize(rd);

                if (DataSize) 
                {
                    BufferPtr<BYTE> DataPtr(DataSize);

                    if (pMachine->CmGetResDesData(rd, DataPtr, DataSize)) 
                    {
                        //
                        // Need this to use a different image overlay for
                        // forced allocated resource
                        //
                        Forced = pMachine->CmGetFirstLogConf(pDevice->GetDevNode(),
                                NULL, FORCED_LOG_CONF);
                        
                        if (ExtractResourceValue(ResType, DataPtr, &dlBase, &dlLen)) 
                        {
                            SafePtr<CResource> ResPtr;
                            CResource* pRes;
    
                            pRes = new CResource(pDevice, ResType, dlBase,
                                                 dlLen, Forced, FALSE);
                                                 
                            if (pRes) 
                            {
                                ResPtr.Attach(pRes);
                                InsertResourceToList(pRes);
                                ResPtr.Detach();
                            }
                        }
                    }
                }
                
                if (rdPrev)
                {
                    pMachine->CmFreeResDesHandle(rdPrev);
                }
                
                rdPrev = rd;

            } while (pMachine->CmGetNextResDes(&rd, rdPrev, ResType, &ResId));
            
            //
            // free the last resource descriptor handle
            //
            pMachine->CmFreeResDesHandle(rd);
        }

        pMachine->CmFreeLogConfHandle(lc);
    }
}



// This function creates CResourceList object to contain the designated
// resources for the given machine.
// INPUT:
//  pMachine -- the machine
//  ResType  -- what type of resource
//  LogConfType -- what type of logconf
// OUTPUT:
//  NONE.
//
// This function may throw CMemoryException
//
CResourceList::CResourceList(
    CMachine* pMachine,
    RESOURCEID ResType,
    ULONG LogConfType,
    ULONG AltLogConfType
    )
{
    ASSERT(ResType_All != ResType);
    ASSERT(BOOT_LOG_CONF == LogConfType ||
           FORCED_LOG_CONF == LogConfType ||
           ALLOC_LOG_CONF == LogConfType ||
           ALL_LOG_CONF == LogConfType);

    ASSERT(pMachine);

    if (pMachine->GetNumberOfDevices()) 
    {
        ASSERT(pMachine->m_pComputer && pMachine->m_pComputer->GetChild());

        CDevice* pFirstDevice;

        pFirstDevice = pMachine->m_pComputer->GetChild();
        CreateSubtreeResourceList(pFirstDevice, ResType, LogConfType, AltLogConfType);
    }
}

//
// This function extracts resource value from the provided buffer
//
// INPUT:
//  ResType     -- resource type the data contain
//  pData       -- the raw data
//  pdlBase     -- buffer to hold the base of the value
//  pdlLen      -- buffer to hold the length of the value
//
// OUTPUT:
//  TRUE if this is a valid resource descriptor or FALSE if we should ignore it.
//  
// NOTE:
//  If the return value is FALSE then pdlBase and pdlLen are not filled in.
//
BOOL
CResourceList::ExtractResourceValue(
    RESOURCEID ResType,
    PVOID pData,
    DWORDLONG* pdlBase,
    DWORDLONG* pdlLen
    )
{
    BOOL bValidResDes = TRUE;

    ASSERT(pData && pdlBase && pdlLen);

    switch (ResType)
    {
    case ResType_Mem:
        if (pMemResData(pData)->MEM_Header.MD_Alloc_Base <= pMemResData(pData)->MEM_Header.MD_Alloc_End) {
        
            *pdlBase = pMemResData(pData)->MEM_Header.MD_Alloc_Base;
            *pdlLen = pMemResData(pData)->MEM_Header.MD_Alloc_End - *pdlBase + 1;
        } else {
            //
            // If base > end then ignore this resource descriptor
            //
            *pdlBase = 0;
            *pdlLen = 0;
            bValidResDes = FALSE;
        }
        break;
            
    case ResType_IRQ:
        *pdlBase = pIRQResData(pData)->IRQ_Header.IRQD_Alloc_Num;
        // IRQ len is always 1
        *pdlLen = 1;
        break;
            
    case ResType_DMA:
        *pdlBase = pDMAResData(pData)->DMA_Header.DD_Alloc_Chan;
        // DMA len is always 1
        *pdlLen = 1;
        break;
            
    case ResType_IO:
        if (pIOResData(pData)->IO_Header.IOD_Alloc_Base <= pIOResData(pData)->IO_Header.IOD_Alloc_End) {
        
            *pdlBase = pIOResData(pData)->IO_Header.IOD_Alloc_Base;
            *pdlLen = pIOResData(pData)->IO_Header.IOD_Alloc_End -
                *pdlBase + 1;
        } else {
            //
            // If base > end then ignore this resource descriptor
            //
            *pdlBase = 0;
            *pdlLen = 0;
            bValidResDes = FALSE;
        }
        break;
          
    default:
        ASSERT(FALSE);
        *pdlBase = 0;
        *pdlLen = 0;
        break;
    }

    return bValidResDes;
}


//
//This function creates resources for the given subtree rooted at
//the given device
//
//INPUT:
//  pDevice -- the root device of the subtree
//  ResType -- resource type to be created
//  LogConfType -- logconf type to be created from
//
//OUTPUT:
//  NONE
//
// This function may throw CMemoryException
//
void
CResourceList::CreateSubtreeResourceList(
    CDevice* pDeviceStart,
    RESOURCEID ResType,
    ULONG LogConfType,
    ULONG AltLogConfType
    )
{
    LOG_CONF lc;
    RES_DES rd, rdPrev;
    RESOURCEID ResId;
    BOOL Forced;
    CMachine* pMachine = pDeviceStart->m_pMachine;
    ASSERT(pMachine);

    while (pDeviceStart) 
    {
        //
        // We will try to get a LogConf for either the LogConfType (which defaults to
        // ALLOC_LOG_CONF) or the AltLogConfType (which defaults to BOOT_LOG_CONF).
        // We need to do this because on Win2000 a device that only has a BOOT_LOG_CONF
        // will still consume those resources, even if it does not have an ALLOC_LOG_CONF.
        // So we need to first check the ALLOC_LOG_CONF and if that fails check the
        // BOOT_LOG_CONF.
        //
        if (pMachine->CmGetFirstLogConf(pDeviceStart->GetDevNode(), &lc, LogConfType) ||
            pMachine->CmGetFirstLogConf(pDeviceStart->GetDevNode(), &lc, AltLogConfType)) 
        {
            rdPrev = 0;

            if (pMachine->CmGetNextResDes(&rd, lc, ResType, &ResId)) 
            {
                ULONG DataSize;
                DWORDLONG dlBase, dlLen;

                do 
                {
                    DataSize = pMachine->CmGetResDesDataSize(rd);

                    if (DataSize) 
                    {
                        //
                        // Need this to use a different image overlay for
                        // forced allocated resource
                        //
                        Forced = pMachine->CmGetFirstLogConf(pDeviceStart->GetDevNode(),
                                NULL, FORCED_LOG_CONF);
                                
                        BufferPtr<BYTE> DataPtr(DataSize);
                        
                        if (pMachine->CmGetResDesData(rd, DataPtr, DataSize)) 
                        {
                            if (ExtractResourceValue(ResType, DataPtr, &dlBase, &dlLen))
                            {
                                SafePtr<CResource> ResPtr;
                                
                                CResource* pRes;
                                
                                pRes = new CResource(pDeviceStart, ResType, dlBase,
                                        dlLen, Forced, FALSE);
                                ResPtr.Attach(pRes);
                                InsertResourceToList(pRes);
                                ResPtr.Detach();
                            }
                        }
                    }
                    
                    if (rdPrev)
                        pMachine->CmFreeResDesHandle(rdPrev);
                    
                    rdPrev = rd;
                    
                }while (pMachine->CmGetNextResDes(&rd, rdPrev, ResType, &ResId));
                
                //
                // Free the last resource descriptor handle
                //
                pMachine->CmFreeResDesHandle(rd);
            }
            
            pMachine->CmFreeLogConfHandle(lc);
        }
        
        if (pDeviceStart->GetChild())
            CreateSubtreeResourceList(pDeviceStart->GetChild(), ResType, LogConfType, AltLogConfType);
        
        pDeviceStart = pDeviceStart->GetSibling();
    }
}


// This function creates a resource tree
// INPUT:
//  ppResRoot   -- buffer to receive the tree root
//
BOOL
CResourceList::CreateResourceTree(
    CResource** ppResRoot
    )
{
    ASSERT(ppResRoot);

    *ppResRoot = NULL;

    if (!m_listRes.IsEmpty()) 
    {
        POSITION pos = m_listRes.GetHeadPosition();
        CResource* pResFirst;

        pResFirst = m_listRes.GetNext(pos);
        *ppResRoot = pResFirst;

        while (NULL != pos) 
        {
            CResource* pRes = m_listRes.GetNext(pos);
            InsertResourceToTree(pRes, pResFirst, TRUE);
        }
    }
    
    return TRUE;
}

BOOL
CResourceList::InsertResourceToTree(
    CResource* pRes,
    CResource* pResRoot,
    BOOL       ForcedInsert
    )
{
    CResource* pResLast = NULL;

    while (pResRoot) 
    {
        if (pRes->EnclosedBy(*pResRoot)) 
        {
            //
            // This resource is either the pResRoot child or grand child
            // figure out which one it is
            //
            if (!pResRoot->GetChild()) 
            {
                pResRoot->SetChild(pRes);
                pRes->SetParent(pResRoot);
            }
            
            else if (!InsertResourceToTree(pRes, pResRoot->GetChild(), FALSE)) 
            {
                //
                // The Resource is not a grand child of pResRoot.
                // search for the last child of pResRoot
                //
                CResource* pResSibling;
                pResSibling = pResRoot->GetChild();

                while (pResSibling->GetSibling()) 
                    pResSibling = pResSibling->GetSibling();
                
                pResSibling->SetSibling(pRes);
                pRes->SetParent(pResRoot);
            }
            
            return TRUE;
        }
        
        pResLast = pResRoot;
        pResRoot = pResRoot->GetSibling();
    }
    
    if (ForcedInsert) 
    {
        if (pResLast) {
            // when we reach here, pResLast is the last child
            pResLast->SetSibling(pRes);
            pRes->SetParent(pResLast->GetParent());
        }

        return TRUE;
    }
    
    return FALSE;
}


CResourceList::~CResourceList()
{
    if (!m_listRes.IsEmpty()) 
    {
        POSITION pos = m_listRes.GetHeadPosition();

        while (NULL != pos) 
        {
            delete m_listRes.GetNext(pos);
        }
        
        m_listRes.RemoveAll();
    }
}

BOOL
CResourceList::GetFirst(
    CResource** ppRes,
    PVOID&      Context
    )
{
    ASSERT(ppRes);

    if (!m_listRes.IsEmpty()) 
    {
        POSITION pos = m_listRes.GetHeadPosition();
        *ppRes = m_listRes.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    Context = NULL;
    *ppRes = NULL;

    return FALSE;
}

BOOL
CResourceList::GetNext(
    CResource** ppRes,
    PVOID&      Context
    )
{
    ASSERT(ppRes);

    POSITION pos = (POSITION)Context;

    if (NULL != pos) 
    {
        *ppRes = m_listRes.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    *ppRes = NULL;
    return FALSE;
}

//
// This function inserts the given resource to class's resource list
// The resources are kept in accending sorted order
void
CResourceList::InsertResourceToList(
    CResource* pRes
    )
{
    POSITION pos;
    CResource* pSrc;
    DWORDLONG dlBase, dlLen;
    pRes->GetValue(&dlBase, &dlLen);

    pos = m_listRes.GetHeadPosition();

    while (NULL != pos) 
    {
        POSITION posSave = pos;
        pSrc = m_listRes.GetNext(pos);

        if (*pRes <= *pSrc) 
        {
            m_listRes.InsertBefore(posSave, pRes);
            return;
        }
    }
    
    m_listRes.AddTail(pRes);
}


inline
CItemIdentifier*
CResource::CreateIdentifier()
{
    return new CResourceIdentifier(*this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\clsgenpg.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    clsgenpg.cpp

Abstract:

    This module implements CClassGeneralPage -- class general property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// clsgenpg.cpp : implementation file
//

#include "devmgr.h"
#include "clsgenpg.h"

// help topic ids
const DWORD g_a108HelpIDs[]=
{
    IDC_CLSGEN_DESC, IDH_DISABLEHELP,
    IDC_CLSGEN_ICON, IDH_DISABLEHELP,
    IDC_CLSGEN_NAME, IDH_DISABLEHELP,
    0, 0,
};

BOOL
CClassGeneralPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    // notify CPropSheetData about the page creation
    // the controls will be initialize in UpdateControls virtual function.
    m_pClass->m_psd.PageCreateNotify(m_hDlg);
    return CPropSheetPage::OnInitDialog(ppsp);
}

UINT
CClassGeneralPage::DestroyCallback()
{
    // the property sheet is going away, consolidate the changes on the
    // device.
    // We do this because this is the page we are sure will be created --
    // this page is ALWAYS the first page.
    //

    // The DevInfoList returned from GetDevInfoList() function
    // is maintained by the class object during its lifetime.
    // we must NOT release the object.
    CDevInfoList* pClassDevInfo = m_pClass->GetDevInfoList();

    if (pClassDevInfo)
    {
        if (pClassDevInfo->DiGetExFlags(NULL) & DI_FLAGSEX_PROPCHANGE_PENDING)
        {
            //
            // property change pending, issue a DICS_PROPERTYCHANGE to the
            // class installer. A DICS_PROPCHANGE would basically remove the
            // device subtree and reenumerate it. If each property page issues
            // its own DICS_PROPCHANGE command, the device subtree would
            // be removed/reenumerate several times even though one is enough.
            // A property page sets DI_FLAGEX_PROPCHANGE_PENDING when it needs
            // a DICS_PROPCHANGE command to be issued.
            //
            SP_PROPCHANGE_PARAMS pcp;
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

            pcp.Scope = DICS_FLAG_GLOBAL;
            pcp.StateChange = DICS_PROPCHANGE;
            pClassDevInfo->DiSetClassInstallParams(NULL,
                                                   &pcp.ClassInstallHeader,
                                                   sizeof(pcp)
                                                   );
                                                   
            pClassDevInfo->DiCallClassInstaller(DIF_PROPERTYCHANGE, NULL);
            pClassDevInfo->DiTurnOnDiFlags(NULL, DI_PROPERTIES_CHANGE);
            pClassDevInfo->DiTurnOffDiExFlags(NULL, DI_FLAGSEX_PROPCHANGE_PENDING);
        }
        
        DWORD RestartFlags = pClassDevInfo->DiGetFlags();

        //
        // Do not use our window handle(or its parent) as the parent
        // to the newly create dialog because they are in "detroyed state".
        // WM_CLOSE does not help either.
        // NULL window handle(Desktop) should be okay here.
        //
        // We only want to prompt for a reboot if device manager is connected
        // to the local machine.
        //
        if (RestartFlags && m_pClass->m_pMachine->IsLocal())
        {
            //
            // First try and send a MMCPropertyChangeNotify message to our
            // CComponent so that it can prompt for a reboot inside the 
            // device manager thread instead of our thread.  If this is not 
            // done then the property sheet will hang around after device
            // manager has gone away...which will cause a "hung app" dialog
            // to appear.
            //
            CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(NULL, RestartFlags, 0);

            if (!m_pClass->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                //
                // There isn't a CComponent around, so this is just a property
                // sheet running outside of MMC.
                //
                pNRR->Release();
                PromptForRestart(NULL, RestartFlags);
            }
        }

        // notify CPropSheetData that the property sheet is going away
        m_pClass->m_psd.PageDestroyNotify(m_hDlg);
        if (RestartFlags & DI_PROPERTIES_CHANGE)
        {
            // Class properties changed. We need to refresh the machine.
            // Since we are running in a separate thread, we can not
            // call the refresh function, instead, we schedule it.
            // This must be done before enabling refresh.
            //
            m_pClass->m_pMachine->ScheduleRefresh();
        }
    }

    //
    // Destory the CMachine.
    //
    CMachine* pMachine;
    pMachine = m_pClass->m_pMachine;

    if (pMachine->ShouldPropertySheetDestroy()) {
    
        delete pMachine;
    }

    return CPropSheetPage::DestroyCallback();
}

void
CClassGeneralPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam)
        m_pClass = (CClass*)lParam;

    HICON hClassIcon = m_pClass->LoadIcon();
    if (hClassIcon)
    {
        HICON hIconOld;
        m_IDCicon = IDC_CLSGEN_ICON;    // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLSGEN_ICON, STM_SETICON,
                                               (WPARAM)hClassIcon,
                                               0
                                               );

        if (NULL != hIconOld)
            DestroyIcon(hIconOld);
    }
    
    SetDlgItemText(m_hDlg, IDC_CLSGEN_NAME, m_pClass->GetDisplayName());
}

HPROPSHEETPAGE
CClassGeneralPage::Create(
    CClass* pClass
    )
{
    m_pClass = pClass;
    m_psp.lParam = (LPARAM) this;
    
    return CreatePage();
}



BOOL
CClassGeneralPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a108HelpIDs);
            
    return FALSE;
}


BOOL
CClassGeneralPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a108HelpIDs);
            
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\cnode.h ===
#ifndef __CNODE_H__
#define __CNODE_H__
/*++

Copyright (C) Microsoft Corporation

Module Name:

    cnode.h

Abstract:

    header file for cnode.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/


class CResultItem;
class CResultComputer;
class CResultClass;
class CResultDevice;
class CDriverList;
class CDriver;
class CHwProfile;
class CMachine;
class CItemIdentifier;
class CDeviceIdentifier;
class CClassIdentifier;
class CComputerIdentifier;
class CResourceIdentifier;
class CResourceTypeIdentifier;

#define ALL_LOG_CONF        BOOT_LOG_CONF + ALLOC_LOG_CONF + FORCED_LOG_CONF

inline
COOKIE_TYPE CookieType(RESOURCEID ResType)
{
    if (ResType_Mem == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY;
    }

    else if (ResType_IO == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_IO;
    }

    else if (ResType_DMA == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_DMA;
    }

    else if (ResType_IRQ == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ;
    }

    else
    {
        ASSERT(FALSE);
        return COOKIE_TYPE_UNKNOWN;
    }
}

///
/// class to represent a result pane item
///

class CResultItem
{

public:
    CResultItem() : m_pMachine(NULL)
    {}

    virtual ~CResultItem() {};
    LPCTSTR GetDisplayName() const
    {
        return (LPCTSTR)m_strDisplayName;
    }

    int GetImageIndex()
    {
        return m_iImage;
    }
    virtual CItemIdentifier* CreateIdentifier() = 0;
    CMachine*   m_pMachine;

protected:
    int     m_iImage;
    String  m_strDisplayName;
};



class CClass : public CResultItem
{
public:
    CClass(CMachine* pMachine, LPGUID pGuid);

    virtual ~CClass();
    BOOL GetFirstDevice(CDevice** ppDevice, PVOID& pContext);
    BOOL GetNextDevice(CDevice** ppDevice, PVOID& Context);
    operator GUID&()
    {
        return m_Guid;
    }
    operator LPGUID()
    {
        return &m_Guid;
    }
    BOOL operator ==(const CClass& OtherClass)
    {
        return IsEqualGUID(m_Guid, (GUID&)OtherClass);
    }
    CDevInfoList* GetDevInfoList(HWND hwndParent = NULL);
    HICON LoadIcon();
    void AddDevice(CDevice* pDevice);
    int GetNumberOfDevices(BOOL Hidden = FALSE)
    {
            return Hidden ? m_TotalDevices :
                 m_TotalDevices - m_TotalHiddenDevices;
    }
    BOOL NoDisplay()
    {
        return m_NoDisplay;
    }
    virtual CItemIdentifier* CreateIdentifier();
    void PropertyChanged();

    CPropSheetData m_psd;

private:
    CClass(const CClass& ClassSrc);
    CClass& operator=(const CClass& ClassSrc);
    GUID    m_Guid;
    CList<CDevice*, CDevice*> m_listDevice;
    BOOL    m_NoDisplay;
    POSITION    m_pos;
    CDevInfoList* m_pDevInfoList;
    int     m_TotalDevices;
    int     m_TotalHiddenDevices;
};

class CDevice : public CResultItem
{
public:
    CDevice() : m_pClass(NULL), m_pSibling(NULL), m_pChild(NULL),
        m_pParent(NULL), m_bLaunchTroubleShooter(FALSE)
    {}
    CDevice(CMachine* pMachine, CClass* pClass, PSP_DEVINFO_DATA pDevData);

    operator SP_DEVINFO_DATA&()
    {
        return m_DevData;
    }
    operator PSP_DEVINFO_DATA()
    {
        return &m_DevData;
    }
    BOOL operator ==(LPCTSTR DeviceID)
    {
        return (0 == m_strDeviceID.CompareNoCase(DeviceID));
    }

    CDevice* GetChild()
    {
        return m_pChild;
    }
    CDevice* GetParent()
    {
        return m_pParent;
    }
    CDevice* GetSibling()
    {
        return m_pSibling;
    }
    void SetChild(CDevice* pDevice)
    {
        m_pChild = pDevice;
    }
    void SetParent(CDevice* pDevice)
    {
        m_pParent = pDevice;
    }
    void SetSibling(CDevice* pDevice)
    {
        m_pSibling = pDevice;
    }
    CClass* GetClass()
    {
        return m_pClass;
    }
    virtual DEVNODE GetDevNode()
    {
        return m_DevData.DevInst;
    }
    LPCTSTR GetDeviceID() const
    {
        return (m_strDeviceID.IsEmpty()) ? NULL : (LPCTSTR)m_strDeviceID;
    }
    BOOL IsHidden();
    BOOL IsPhantom();
    BOOL NoShowInDM();
    BOOL IsPCIDevice();
    virtual CItemIdentifier* CreateIdentifier();
    HICON LoadClassIcon();
    BOOL GetStatus(DWORD* pStatus, DWORD* pProblem);
    BOOL GetCapabilities(DWORD* pCapabilities);
    BOOL GetPowerCapabilities(DWORD* pCapabilities);
    BOOL IsRAW();
    BOOL IsUninstallable();
    BOOL IsDisableable();
    BOOL IsDisabled();
    BOOL IsStateDisabled();
    BOOL IsStarted();
    BOOL HasProblem();
    BOOL NeedsRestart();
    BOOL GetConfigFlags(DWORD* pFlags);
    BOOL GetConfigSpecificConfigFlags(DWORD* pCSStatus);
    BOOL GetKnownLogConf(LOG_CONF* plc, DWORD* plcType);
    BOOL HasResources();
    void GetMFGString(String& strMFG);
    void GetProviderString(String& strMFG);
    void GetDriverDateString(String& strMFG);
    void GetDriverVersionString(String& strMFG);
    LPCTSTR  GetClassDisplayName();
    void ClassGuid(GUID& ClassGuid)
    {
        ASSERT(m_pClass);
        ClassGuid = *m_pClass;
    }
    BOOL  NoChangeUsage();
    CDriver* CreateDriver();
    DWORD EnableDisableDevice(HWND hDlg, BOOL Enabling);
    void PropertyChanged();
    CPropSheetData m_psd;
    BOOL m_bLaunchTroubleShooter;

private:
    CDevice(const CDevice& DeviceSrc);
    CDevice& operator=(const CDevice& DeviceSrc);

    CDevice*        m_pParent;
    CDevice*        m_pSibling;
    CDevice*        m_pChild;
    String          m_strDeviceID;
    SP_DEVINFO_DATA m_DevData;
    CClass*         m_pClass;
};

class CComputer : public CDevice
{
public:
    CComputer(CMachine* pMachine, DEVNODE dnRoot);
    virtual DEVNODE GetDevNode()
    {
        return m_dnRoot;
    }
    virtual CItemIdentifier* CreateIdentifier();

private:
    DEVNODE m_dnRoot;
    CComputer(const CComputer& ComputerSrc);
    CComputer& operator=(const CComputer& ComputerSrc);
};

class CResource : public CResultItem
{
public:
    CResource(CDevice* pDevice, RESOURCEID ResType, DWORDLONG dlBase, DWORDLONG dlLen,
          BOOL Forced, BOOL Free = FALSE);
    BOOL IsForced()
    {
        return m_Forced;
    }
    void GetValue(DWORDLONG* pdlBase, DWORDLONG* pdlLen) const
    {
        ASSERT(pdlBase && pdlLen);
        *pdlBase = m_dlBase;
        *pdlLen = m_dlLen;
    }
    virtual CItemIdentifier* CreateIdentifier();

    LPCTSTR GetViewName()
    {
            return (LPCTSTR)m_strViewName;
    }

    CDevice* GetDevice()
    {
        return m_pDevice;
    }
    CResource* GetChild()
    {
        return m_pChild;
    }
    CResource* GetSibling()
    {
        return m_pSibling;
    }
    CResource* GetParent()
    {
        return m_pParent;
    }
    void SetChild(CResource* pRes)
    {
        m_pChild = pRes;
    }
    void SetParent(CResource* pRes)
    {
        m_pParent = pRes;
    }
    void SetSibling(CResource* pRes)
    {
        m_pSibling = pRes;
    }
    BOOL operator <=(const CResource& resSrc);
    BOOL EnclosedBy(const CResource& resSrc);
    RESOURCEID ResType()
    {
        return m_ResType;
    }
    CDevice*    m_pDevice;

private:
    CResource(const CResource& resSrc);
    CResource& operator=(const CResource& resSrc);
    RESOURCEID  m_ResType;
    DWORDLONG   m_dlBase;
    DWORDLONG   m_dlEnd;
    DWORDLONG   m_dlLen;
    BOOL        m_Forced;
    CResource*  m_pChild;
    CResource*  m_pSibling;
    CResource*  m_pParent;
    BOOL        m_Allocated;
    String      m_strViewName;
};

#define pIRQResData(pData) ((IRQ_RESOURCE*)pData)
#define pDMAResData(pData) ((DMA_RESOURCE*)pData)
#define pMemResData(pData) ((MEM_RESOURCE*)pData)
#define pIOResData(pData)  ((IO_RESOURCE*)pData)


class CResourceType : public CResultItem
{
public:
    CResourceType(CMachine* pMachine, RESOURCEID ResType);

    virtual CItemIdentifier* CreateIdentifier();

    CResource* GetChild()
    {
        return m_pChild;
    }
    CResourceType* GetSibling()
    {
        return m_pSibling;
    }
    CComputer* GetParent()
    {
        return m_pParent;
    }
    void SetChild(CResource* pRes)
    {
        m_pChild = pRes;
    }
    void SetParent(CComputer* pComp)
    {
        m_pParent = pComp;
    }
    void SetSibling(CResourceType* pResT)
    {
        m_pSibling = pResT;
    }
    RESOURCEID GetResType()
    {
        return m_ResType;
    }

private:
    CResourceType(const CResourceType& resSrc);
    CResourceType& operator=(const CResourceType& resSrc);
    RESOURCEID      m_ResType;
    CResource*      m_pChild;
    CResourceType*  m_pSibling;
    CComputer*      m_pParent;
};


class CResourceList
{
public:
    CResourceList(CDevice* pDevice, RESOURCEID ResType, 
                  ULONG LogConfType = ALLOC_LOG_CONF, ULONG AltLogConfType = BOOT_LOG_CONF);
    CResourceList(CMachine* pMachine, RESOURCEID ResType, 
                  ULONG LogConfType = ALLOC_LOG_CONF, ULONG AltLogConfType = BOOT_LOG_CONF);
    ~CResourceList();
    int GetCount()
    {
        return m_listRes.GetCount();
    }
    BOOL GetFirst(CResource** ppRes, PVOID& pContext);
    BOOL GetNext(CResource** ppRes, PVOID& Context);
    BOOL CreateResourceTree(CResource** ppRoot);
    static BOOL ExtractResourceValue(RESOURCEID ResType, PVOID pData,
                     DWORDLONG* pdlBase, DWORDLONG* pdlLen);
private:
    BOOL InsertResourceToTree(CResource* pRes, CResource* pResRoot, BOOL ForcedInsert);
    CResourceList(const CResourceList& Src);
    CResourceList& operator=(const CResourceList& Src);

    void CreateSubtreeResourceList(CDevice* pDeviceStart, RESOURCEID ResType, 
                                   ULONG LogConfType, ULONG AltLogConfType);
    CList<CResource*, CResource*> m_listRes;
    void InsertResourceToList(CResource* pRes);
};


class CItemIdentifier
{
public:
    CItemIdentifier()
    {}
    virtual ~CItemIdentifier()
    {}
    virtual BOOL operator==(CCookie& Cookie) = 0;
};


class CClassIdentifier : public CItemIdentifier
{
public:
    CClassIdentifier(CClass& Class)
    {
        m_Guid = (GUID&)Class;
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_CLASS == Cookie.GetType() &&
           IsEqualGUID(m_Guid, *((CClass*)Cookie.GetResultItem()));
    }

private:
    GUID    m_Guid;
};

class CDeviceIdentifier : public CItemIdentifier
{
public:
    CDeviceIdentifier(CDevice& Device)
    {
        ASSERT(Device.GetDeviceID());
        m_strDeviceId = Device.GetDeviceID();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_DEVICE == Cookie.GetType() &&
           !lstrcmpi(m_strDeviceId, ((CDevice*)Cookie.GetResultItem())->GetDeviceID());
    }

private:
    String  m_strDeviceId;
};

class CResourceIdentifier : public CItemIdentifier
{
public:
    CResourceIdentifier(CResource& Res)
    {
        m_CookieType = CookieType(Res.ResType());
        m_strDisplayName = Res.GetDisplayName();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return m_CookieType == Cookie.GetType() &&
           !lstrcmpi((LPCTSTR)m_strDisplayName, Cookie.GetResultItem()->GetDisplayName());
    }

private:
    COOKIE_TYPE     m_CookieType;
    String          m_strDisplayName;
};

class CResourceTypeIdentifier : public CItemIdentifier
{
public:
    CResourceTypeIdentifier(CResourceType& ResType)
    {
        m_ResType = ResType.GetResType();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_RESTYPE == Cookie.GetType() &&
           m_ResType == ((CResourceType*)Cookie.GetResultItem())->GetResType();
    }

private:
    RESOURCEID      m_ResType;
};

class CComputerIdentifier : public CItemIdentifier
{
public:
    CComputerIdentifier(CComputer& Computer)
    {
        ASSERT(Computer.GetDisplayName());
        m_strName = Computer.GetDisplayName();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_COMPUTER == Cookie.GetType() &&
               !lstrcmpi((LPCTSTR)m_strName, Cookie.GetResultItem()->GetDisplayName());
    }

private:
    String  m_strName;
};


#endif // __CNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\componet.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    componet.cpp

Abstract:

    This module implemets CComponent class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"
#include <devguid.h>

//
// ctor and dtor
//

CComponent::CComponent(
    CComponentData* pComponentData
    )
{
    m_pComponentData = pComponentData;
    m_pHeader = NULL;
    m_pConsole = NULL;
    m_pResult = NULL;
    m_pConsoleVerb = NULL;
    m_pCurFolder = NULL;
    m_pPropSheetProvider = NULL;
    m_pDisplayHelp = NULL;
    m_Dirty = FALSE;
    m_pControlbar = NULL;
    m_pToolbar = NULL;
    
    //
    // Increment object count(used by CanUnloadNow)
    //
    ::InterlockedIncrement(&CClassFactory::s_Objects);
    m_Ref = 1;
}

CComponent::~CComponent()
{
    //
    // Decrement object count(used by CanUnloadNow)
    //
    ASSERT( 0 != CClassFactory::s_Objects );
    ::InterlockedDecrement(&CClassFactory::s_Objects);
}

//
// IUNKNOWN interface
//
ULONG
CComponent::AddRef()
{
    return ::InterlockedIncrement(&m_Ref);
}

ULONG
CComponent::Release()
{
    ASSERT( 0 != m_Ref );
    ULONG cRef = ::InterlockedDecrement(&m_Ref);
    if ( 0 == cRef )
    {
        delete this;
    }    
    return cRef;
}

STDMETHODIMP
CComponent::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)(IComponent*)this;
    }
    
    else if (IsEqualIID(riid, IID_IComponent))
    {
        *ppv = (IComponent*)this;
    }
    
    else if (IsEqualIID(riid, IID_IResultDataCompare))
    {
        *ppv = (IResultDataCompare*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (IExtendContextMenu*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendControlbar))
    {
        *ppv = (IExtendControlbar*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (IExtendPropertySheet*)this;
    }

    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppv = (IPersistStream*)this;
    }

    else if (IsEqualIID(riid, IID_ISnapinCallback))
    {
        *ppv = (ISnapinCallback*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }
    
    return hr;
}


//
// IComponent interface implementation
//
STDMETHODIMP
CComponent::GetResultViewType(
    MMC_COOKIE cookie,
    LPOLESTR* ppViewType,
    long* pViewOptions
    )
{
    if (!ppViewType || !pViewOptions)
    {
        return E_INVALIDARG;
    }

    try
    {
        CFolder* pFolder;
        pFolder = FindFolder(cookie);
        
        if (pFolder)
        {
            return pFolder->GetResultViewType(ppViewType, pViewOptions);
        }

        else
        {
            return S_OK;
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return S_FALSE;
    }
}

STDMETHODIMP
CComponent::Initialize(
    LPCONSOLE lpConsole
    )
{
    HRESULT hr;

    if (!lpConsole)
    {
        return E_INVALIDARG;
    }

    m_pConsole = lpConsole;
    lpConsole->AddRef();

    hr = lpConsole->QueryInterface(IID_IHeaderCtrl, (void**)&m_pHeader);

    if (SUCCEEDED(hr))
    {
        lpConsole->SetHeader(m_pHeader);
        hr = lpConsole->QueryInterface(IID_IResultData, (void**)&m_pResult);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = lpConsole->QueryConsoleVerb(&m_pConsoleVerb);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = lpConsole->QueryInterface(IID_IPropertySheetProvider,
                                       (void**)&m_pPropSheetProvider);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = lpConsole->QueryInterface(IID_IDisplayHelp, (void**)&m_pDisplayHelp);
    }

    if (FAILED(hr))
    {
        TRACE((TEXT("CComponent::Initialize failed\n")));
    }

    return hr;
}

#if DBG
TCHAR *mmcNotifyStr[] = {
    TEXT("UNKNOWN"),
    TEXT("ACTIVATE"),
    TEXT("ADD_IMAGES"),
    TEXT("BTN_CLICK"),
    TEXT("CLICK"),
    TEXT("COLUMN_CLICK"),
    TEXT("CONTEXTMENU"),
    TEXT("CUTORMOVE"),
    TEXT("DBLCLICK"),
    TEXT("DELETE"),
    TEXT("DESELECT_ALL"),
    TEXT("EXPAND"),
    TEXT("HELP"),
    TEXT("MENU_BTNCLICK"),
    TEXT("MINIMIZED"),
    TEXT("PASTE"),
    TEXT("PROPERTY_CHANGE"),
    TEXT("QUERY_PASTE"),
    TEXT("REFRESH"),
    TEXT("REMOVE_CHILDREN"),
    TEXT("RENAME"),
    TEXT("SELECT"),
    TEXT("SHOW"),
    TEXT("VIEW_CHANGE"),
    TEXT("SNAPINHELP"),
    TEXT("CONTEXTHELP"),
    TEXT("INITOCX"),
    TEXT("FILTER_CHANGE"),
    TEXT("FILTERBTN_CLICK"),
    TEXT("RESTORE_VIEW"),
    TEXT("PRINT"),
    TEXT("PRELOAD"),
    TEXT("LISTPAD"),
    TEXT("EXPANDSYNC")
    };
#endif

STDMETHODIMP
CComponent::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param
    )
{
    HRESULT hr;

    INTERNAL_DATA tID;

#if DBG
    UINT i = event - MMCN_ACTIVATE + 1;
    if (event > MMCN_EXPANDSYNC || event < MMCN_ACTIVATE)
    {
        i = 0;
    }
    //TRACE((TEXT("Componet:Notify, event = %lx %s\n"), event, mmcNotifyStr[i]));
#endif

    try
    {
        if (DOBJ_CUSTOMOCX == lpDataObject)
        {
            return OnOcxNotify(event, arg, param);
        }

        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         (PBYTE)&tID, sizeof(tID));

        if (SUCCEEDED(hr))
        {
            switch(event)
            {
            case MMCN_ACTIVATE:
                hr = OnActivate(tID.cookie, arg, param);
                break;

            case MMCN_VIEW_CHANGE:
                hr = OnViewChange(tID.cookie, arg, param);
                break;

            case MMCN_SHOW:
                hr = OnShow(tID.cookie, arg, param);
                break;

            case MMCN_CLICK:
                hr = OnResultItemClick(tID.cookie, arg, param);
                break;
                
            case MMCN_DBLCLICK:
                hr = OnResultItemDblClick(tID.cookie, arg, param);
                break;
                
            case MMCN_MINIMIZED:
                hr = OnMinimize(tID.cookie, arg, param);
                break;
                
            case MMCN_BTN_CLICK:
                hr = OnBtnClick(tID.cookie, arg, param);
                break;
                
            case MMCN_SELECT:
                hr = OnSelect(tID.cookie, arg, param);
                break;
                
            case MMCN_ADD_IMAGES:
                hr = OnAddImages(tID.cookie, (IImageList*)arg, param);
                break;
                
            case MMCN_RESTORE_VIEW:
                hr = OnRestoreView(tID.cookie, arg, param);
                break;
                
            case MMCN_CONTEXTHELP:
                hr = OnContextHelp(tID.cookie, arg, param);
                break;
                
            default:
                hr = S_OK;
                break;
            }
        }
        
        else
        {
            if (MMCN_ADD_IMAGES == event)
            {
                OnAddImages(0, (IImageList*)arg, (HSCOPEITEM)param);
            } else if (MMCN_PROPERTY_CHANGE == event) {
                CNotifyRebootRequest* pNRR = (CNotifyRebootRequest*)param;

                if (pNRR) {
                    PromptForRestart(pNRR->m_hWnd ? pNRR->m_hWnd : m_pComponentData->m_hwndMain, 
                                     pNRR->m_RestartFlags, 
                                     pNRR->m_StringId);
                    pNRR->Release();
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponent::Destroy(
    MMC_COOKIE cookie
    )
{
    //
    // cookie must point to the static node
    //
    ASSERT(0 == cookie);

    try
    {
        DetachAllFoldersFromMachine();
        DestroyFolderList(cookie);

        if (m_pToolbar)
        {
            m_pToolbar->Release();
        }
        
        if (m_pControlbar)
        {
            m_pControlbar->Release();
        }

        //
        // Release the interfaces that we QI'ed
        //
        if (m_pConsole != NULL)
        {
            //
            // Tell the console to release the header control interface
            //
            m_pConsole->SetHeader(NULL);
            m_pHeader->Release();

            m_pResult->Release();

            m_pConsoleVerb->Release();

            m_pDisplayHelp->Release();

            //
            // Release the IFrame interface last
            //
            m_pConsole->Release();
        }

        if (m_pPropSheetProvider)
        {
            m_pPropSheetProvider->Release();
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
    }
    
    return S_OK;
}

STDMETHODIMP
CComponent::QueryDataObject(
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    LPDATAOBJECT* ppDataObject
    )
{
    try
    {
        ASSERT(m_pComponentData);
        
        //
        // Delegate to IComponentData
        //
        return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CComponent::GetDisplayInfo(
    LPRESULTDATAITEM pResultDataItem
    )
{
    try
    {
        CFolder* pFolder = FindFolder(pResultDataItem->lParam);
        
        if (pFolder)
        {
            return pFolder->GetDisplayInfo(pResultDataItem);
        }
        
        else
        {
            return S_OK;
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CComponent::CompareObjects(
    LPDATAOBJECT lpDataObjectA,
    LPDATAOBJECT lpDataObjectB
    )
{
    try
    {
        ASSERT(m_pComponentData);
        
        //
        // Delegate to ComponentData
        //
        return m_pComponentData->CompareObjects(lpDataObjectA, lpDataObjectB);
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////////////
/// IResultDataCompare implementation
///

// This compare is used to sort the item's in the listview.
// lUserParam - user param passed in when IResultData::Sort() was called.
// cookieA    -- first item
// cookieB    -- second item
// pnResult contains the column on entry. This function has the compared
// result in the location pointed by this parameter.
// the valid compare results are:
// -1 if cookieA  "<" cookieB
// 0  if cookieA "==" cookieB
// 1 if cookieA ">" cookieB
//
//

STDMETHODIMP
CComponent::Compare(
    LPARAM lUserParam,
    MMC_COOKIE cookieA,
    MMC_COOKIE cookieB,
    int* pnResult
    )
{
    if (!pnResult)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    
    try
    {
        int nCol = *pnResult;
        CFolder* pFolder = (CFolder*)lUserParam;
        
        if (pFolder)
        {
            hr = pFolder->Compare(cookieA, cookieB, nCol, pnResult);
        }

        else
        {
            hr = m_pCurFolder->Compare(cookieA, cookieB, nCol, pnResult);
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////
/// Snapin's IExtendContextMenu implementation -- delegate to IComponentData
////
// Note that IComponentData also has its own IExtendContextMenu
// interface implementation. The difference is that
// IComponentData only deals with scope items while we only
// deal with result item except for cutomer view menu.
//
//
STDMETHODIMP
CComponent::AddMenuItems(
    LPDATAOBJECT lpDataObject,
    LPCONTEXTMENUCALLBACK pCallback,
    long*   pInsertionAllowed
    )
{
    HRESULT hr;
    INTERNAL_DATA tID;
    
    try
    {
        //
        // If lpDataObject is DOBJ_CUSTOMOCX then the user is viewing
        // the Action menu.
        //
        if (DOBJ_CUSTOMOCX == lpDataObject) 
        {
            ASSERT(m_pCurFolder);

            hr = m_pCurFolder->m_pScopeItem->AddMenuItems(pCallback, pInsertionAllowed);
        }

        //
        // If we have a valid cookie then the user is using the context menu
        // or the View menu
        //
        else
        {
            hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                             reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                             );

            if (SUCCEEDED(hr))
            {
                ASSERT(m_pCurFolder);

                hr = m_pCurFolder->AddMenuItems(GetActiveCookie(tID.cookie),
                                            pCallback, pInsertionAllowed
                                            );
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr  = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponent::Command(
    long nCommandID,
    LPDATAOBJECT lpDataObject
    )
{
    INTERNAL_DATA tID;

    HRESULT hr;
    try
    {
        //
        // Menu item from the Action menu
        //
        if (DOBJ_CUSTOMOCX == lpDataObject) 
        {
            ASSERT(m_pCurFolder);

            hr = m_pCurFolder->m_pScopeItem->MenuCommand(nCommandID);
        }

        //
        // Context menu item or View menu item
        //
        else
        {
            hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                              (PBYTE)&tID, sizeof(tID));
            if (SUCCEEDED(hr))
            {
                ASSERT(m_pCurFolder);
                
                hr = m_pCurFolder->MenuCommand(GetActiveCookie(tID.cookie), nCommandID);
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//

MMCBUTTON g_SnapinButtons[] =
{
    { 0, IDM_REFRESH,      TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_REFRESH,      (BSTR)IDS_TOOLTIP_REFRESH },
    { 0, 0,                TBSTATE_ENABLED, TBSTYLE_SEP,    NULL,                          NULL },
    { 4, IDM_UPDATEDRIVER, TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_UPDATEDRIVER, (BSTR)IDS_TOOLTIP_UPDATEDRIVER },
    { 2, IDM_REMOVE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_REMOVE,       (BSTR)IDS_TOOLTIP_REMOVE },
    { 1, IDM_ENABLE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_ENABLE,       (BSTR)IDS_TOOLTIP_ENABLE },
    { 3, IDM_DISABLE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_DISABLE,      (BSTR)IDS_TOOLTIP_DISABLE },
};

#define CBUTTONS_ARRAY          ARRAYLEN(g_SnapinButtons)

String* g_astrButtonStrings = NULL;    // dynamic array of Strings
BOOL g_bLoadedStrings = FALSE;


STDMETHODIMP
CComponent::SetControlbar(
    LPCONTROLBAR pControlbar
    )
{
    if (pControlbar != NULL)
    {
        //
        // Hold on to the controlbar interface.
        //
        if (m_pControlbar)
        {
            m_pControlbar->Release();
        }

        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr = S_FALSE;

        if (!m_pToolbar)
        {
            //
            // Create the Toolbar
            //
            hr = m_pControlbar->Create(TOOLBAR, this,
                                       reinterpret_cast<LPUNKNOWN*>(&m_pToolbar));
            ASSERT(SUCCEEDED(hr));

            //
            // Add the bitmap
            //
            HBITMAP hBitmap = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR));
            hr = m_pToolbar->AddBitmap(4, hBitmap, 16, 16, RGB(255, 0, 255));
            ASSERT(SUCCEEDED(hr));

            if (!g_bLoadedStrings)
            {
                //
                // Load strings
                //
                g_astrButtonStrings = new String[2*CBUTTONS_ARRAY];
                
                for (UINT i = 0; i < CBUTTONS_ARRAY; i++)
                {
                    if (g_astrButtonStrings &&
                        g_SnapinButtons[i].lpButtonText &&
                        g_astrButtonStrings[i*2].LoadString(g_hInstance,
                                (UINT)((ULONG_PTR)g_SnapinButtons[i].lpButtonText))) {

                        g_SnapinButtons[i].lpButtonText =
                            const_cast<BSTR>((LPCTSTR)(g_astrButtonStrings[i*2]));
                    
                    } else {
                        g_SnapinButtons[i].lpButtonText = NULL;
                    }

                    if (g_astrButtonStrings &&
                        g_SnapinButtons[i].lpTooltipText &&
                        g_astrButtonStrings[(i*2)+1].LoadString(g_hInstance,
                                (UINT)((ULONG_PTR)g_SnapinButtons[i].lpTooltipText))) {

                        g_SnapinButtons[i].lpTooltipText =
                                const_cast<BSTR>((LPCTSTR)(g_astrButtonStrings[(i*2)+1]));
                    
                    } else {
                        g_SnapinButtons[i].lpTooltipText = NULL;
                    }
                }

                g_bLoadedStrings = TRUE;
            }

            //
            // Add the buttons to the toolbar
            //
            hr = m_pToolbar->AddButtons(CBUTTONS_ARRAY, g_SnapinButtons);
            ASSERT(SUCCEEDED(hr));
        }
    }

    return S_OK;
}

STDMETHODIMP
CComponent::ControlbarNotify(
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param
    )
{
    switch (event)
    {
    case MMCN_BTN_CLICK:
        //
        // arg - Data object of the currently selected scope or result pane item.
        // param - CmdID of the button.
        //
        switch (param)
        {
        case IDM_REFRESH:
        case IDM_ENABLE:
        case IDM_REMOVE:
        case IDM_DISABLE:
        case IDM_UPDATEDRIVER:

            //
            // The arg parameter is supposed to be the data object of the
            // currently selected scope or result pane item, but it seems
            // to always passes 0xFFFFFFFF. So the ScopeItem MenuCommand is
            // used because it uses the selected cookie instead.
            //
            // Handle toolbar button requests.
            //
            return m_pCurFolder->m_pScopeItem->MenuCommand((LONG)param);

        default:
            break;
        }

        break;

    case MMCN_SELECT:
        //
        // param - Data object of the item being selected.
        // For select, if the cookie has toolbar items attach the toolbar.
        // Otherwise detach the toolbar.
        //
        HRESULT hr;

        if (LOWORD(arg))
        {
            //
            // LOWORD(arg) being set indicated this is for the scope pane item.
            //
            if (HIWORD(arg))
            {
                //
                // Detach the Controlbar.
                //
                hr = m_pControlbar->Detach(reinterpret_cast<LPUNKNOWN>(m_pToolbar));
                ASSERT(SUCCEEDED(hr));
            }

            else
            {
                //
                // Attach the Controlbar.
                //
                hr = m_pControlbar->Attach(TOOLBAR,
                                           reinterpret_cast<LPUNKNOWN>(m_pToolbar));
                ASSERT(SUCCEEDED(hr));
            }
        }
        break;

    default:
        break;
    }

    return S_OK;
}

//
// This function updates the toolbar buttons based on the selected cookie type.
//
HRESULT
CComponent::UpdateToolbar(
    CCookie* pCookie
    )
{
    if (!m_pToolbar)
    {
        return S_OK;
    }

    //
    // Everything is hidden by default
    //
    BOOL fRemoveHidden = TRUE;
    BOOL fRefreshHidden = TRUE;
    BOOL fUpdateHidden = TRUE;
    BOOL fDisableHidden = TRUE;
    BOOL fEnableHidden = TRUE;

    switch (pCookie->GetType())
    {
    case COOKIE_TYPE_RESULTITEM_DEVICE:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
        if(m_pComponentData->m_pMachine->IsLocal() && g_IsAdmin)
        {
            CDevice* pDevice = NULL;
            CClass* pClass;

            if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
                pDevice = (CDevice*)pCookie->GetResultItem();
            } else {
                //
                // This is a resource item, get the pointer for the device
                // object from the resource object.
                //
                CResource* pResource = (CResource*) pCookie->GetResultItem();
                if (pResource) {
                    pDevice = pResource->GetDevice();
                }
            }

            if (pDevice)
            {
                pClass = pDevice->GetClass();

                //
                // Device can be disabled
                //
                if (pDevice->IsDisableable()) {
            
                    if (pDevice->IsStateDisabled()) {

                        fEnableHidden = FALSE;
                
                    } else {

                        fDisableHidden = FALSE;
                    }
                }

                //
                // Device cannot be disabled
                //
                else
                {
                    //
                    // Hide both the enable and disable buttons in case the
                    // previously selected node was a device.
                    //
                    m_pToolbar->SetButtonState(IDM_ENABLE, HIDDEN, TRUE);
                    m_pToolbar->SetButtonState(IDM_DISABLE, HIDDEN, TRUE);
                }

                //
                // Only show the uninstall button if the device can be uninstalled.
                //
                if (pDevice->IsUninstallable()) {
            
                    fRemoveHidden = FALSE;
                }

                //
                // Display Update Driver button for everything except legacy drivers.
                //
                fUpdateHidden = IsEqualGUID(*pClass, GUID_DEVCLASS_LEGACYDRIVER) ? TRUE : FALSE;

                //
                // Display refresh (Scan...) button.
                //
                fRefreshHidden = FALSE;
            }
            break;
        }
        else
        {
            //
            // Must be an admin and on the local machine to remove or
            // enable/disable a device.
            //
            //
            // Fall through to hide the remove and enable/disable buttons.
            //
        }

    case COOKIE_TYPE_RESULTITEM_COMPUTER:
    case COOKIE_TYPE_RESULTITEM_CLASS:
    case COOKIE_TYPE_RESULTITEM_RESTYPE:
        
        //
        // Display refresh (enumerate) button if the user is an Administrator
        //
        if (g_IsAdmin) {
        
            fRefreshHidden = FALSE;
        }

        break;

    default:
        break;
    }
    
    //
    // Hide or show the buttons
    //
    m_pToolbar->SetButtonState(IDM_REMOVE, HIDDEN, fRemoveHidden);
    m_pToolbar->SetButtonState(IDM_REFRESH, HIDDEN, fRefreshHidden);
    m_pToolbar->SetButtonState(IDM_UPDATEDRIVER, HIDDEN, fUpdateHidden);
    m_pToolbar->SetButtonState(IDM_DISABLE, HIDDEN, fDisableHidden);
    m_pToolbar->SetButtonState(IDM_ENABLE, HIDDEN, fEnableHidden);

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//// Snapin's IExtendPropertySheet implementation
////

STDMETHODIMP
CComponent::QueryPagesFor(
    LPDATAOBJECT lpDataObject
    )
{
    HRESULT hr;

    if (!lpDataObject)
    {
        return E_INVALIDARG;
    }

    INTERNAL_DATA tID;
    
    try
    {
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                         );
        
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pCurFolder);
            hr = m_pCurFolder->QueryPagesFor(GetActiveCookie(tID.cookie));
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr  = S_FALSE;
    }

    return hr;
}

STDMETHODIMP
CComponent::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT lpDataObject
    )
{
    HRESULT hr;

    if (!lpProvider || !lpDataObject)
    {
        return E_INVALIDARG;
    }

    INTERNAL_DATA tID;
    
    try
    {
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                         );
        
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pCurFolder);
            hr = m_pCurFolder->CreatePropertyPages(GetActiveCookie(tID.cookie),
                                           lpProvider, handle
                                           );
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Snapin's IPersistStream implementation

STDMETHODIMP
CComponent::GetClassID(
    CLSID* pClassID
    )
{
    if(!pClassID)
    {
        return E_POINTER;
    }

    *pClassID = m_pComponentData->GetCoClassID();
    return S_OK;
}

STDMETHODIMP
CComponent::IsDirty()
{
    return m_Dirty ? S_OK : S_FALSE;
}

STDMETHODIMP
CComponent::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )
{
    if (!pcbSize)
    {
        return E_INVALIDARG;
    }

    //         total folders        folder signature
    int Size =  sizeof(int) + m_listFolder.GetCount() * sizeof(FOLDER_SIGNATURE)
                + sizeof(CLSID);
    
    CFolder* pFolder;
    POSITION pos = m_listFolder.GetHeadPosition();
    
    while (NULL != pos)
    {
        pFolder = m_listFolder.GetNext(pos);
        ASSERT(pFolder);
        Size += pFolder->GetPersistDataSize();
    }
    
    ULISet32(*pcbSize, Size);
    return S_OK;
}


// save data format

STDMETHODIMP
CComponent::Save(
    IStream* pStm,
    BOOL fClearDirty
    )
{
    HRESULT hr = S_OK;

    SafeInterfacePtr<IStream> StmPtr(pStm);

    int Count;
    POSITION pos;
    try
    {
        //
        // write out CLSID
        //
        hr = pStm->Write(&CLSID_DEVMGR, sizeof(CLSID), NULL);
        if (SUCCEEDED(hr))
        {
            Count = m_listFolder.GetCount();
            CFolder* pFolder;
            
            //
            // write out folder count
            //
            hr = pStm->Write(&Count, sizeof(Count), NULL);
            
            if (SUCCEEDED(hr) && Count)
            {
                pos = m_listFolder.GetHeadPosition();
                
                while (NULL != pos)
                {
                    pFolder = m_listFolder.GetNext(pos);
                    
                    //
                    // write folder signature
                    //
                    FOLDER_SIGNATURE Signature = pFolder->GetSignature();
                    hr = pStm->Write(&Signature, sizeof(Signature), NULL);
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = SaveFolderPersistData(pFolder, pStm, fClearDirty);
                    }
                    
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }

    if (fClearDirty)
    {
        m_Dirty = FALSE;
    }

    return hr;
}

STDMETHODIMP
CComponent::Load(
    IStream* pStm
    )
{
    HRESULT hr = S_OK;

    CLSID clsid;
    SafeInterfacePtr<IStream> StmPtr(pStm);

    ASSERT(pStm);

    //
    // Read the clsid
    //
    try
    {
        hr = pStm->Read(&clsid, sizeof(clsid), NULL);
        if (SUCCEEDED(hr) && clsid ==  CLSID_DEVMGR)
        {
            CFolder* pFolder;
            int FolderCount;

            //
            // Folder list must be create before Load.
            // DO NOT rely on that IComponent::Initialize comes before IStream::Load
            //
            ASSERT(m_listFolder.GetCount());

            //
            // Load folder count
            //
            hr = pStm->Read(&FolderCount, sizeof(FolderCount), NULL);
            if (SUCCEEDED(hr))
            {
                ASSERT(m_listFolder.GetCount() == FolderCount);
                
                //
                // Get folder signature
                // go through every folder
                //
                for (int i = 0; i < FolderCount; i++)
                {
                    FOLDER_SIGNATURE Signature;
                    hr = pStm->Read(&Signature, sizeof(Signature), NULL);
                    
                    if (SUCCEEDED(hr))
                    {
                        POSITION pos;
                        pos = m_listFolder.GetHeadPosition();
                        
                        while (NULL != pos)
                        {
                            pFolder = m_listFolder.GetNext(pos);
                            
                            if (pFolder->GetSignature() == Signature)
                            {
                                hr = LoadFolderPersistData(pFolder, pStm);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    m_Dirty = FALSE;
    
    return hr;
}

HRESULT
CComponent::SaveFolderPersistData(
    CFolder* pFolder,
    IStream* pStm,
    BOOL fClearDirty
    )
{
    HRESULT hr = S_OK;
    int Size;
    SafeInterfacePtr<IStream> StmPtr(pStm);

    UNREFERENCED_PARAMETER(fClearDirty);

    try
    {
        Size = pFolder->GetPersistDataSize();
        
        //
        // Always write the length even though it can be 0.
        //
        hr = pStm->Write(&Size, sizeof(Size), NULL);
        
        if (SUCCEEDED(hr) && Size)
        {
            BufferPtr<BYTE> Buffer(Size);
            pFolder->GetPersistData(Buffer, Size);
            hr = pStm->Write(Buffer, Size, NULL);
        }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT
CComponent::LoadFolderPersistData(
    CFolder* pFolder,
    IStream* pStm
    )
{
    HRESULT hr = S_OK;

    SafeInterfacePtr<IStream> StmPtr(pStm);

    int Size = 0;
    hr = pStm->Read(&Size, sizeof(Size), NULL);
    
    if (SUCCEEDED(hr) && Size)
    {
        BufferPtr<BYTE> Buffer(Size);
        hr = pStm->Read(Buffer, Size, NULL);
        
        if (SUCCEEDED(hr))
        {
            hr = pFolder->SetPersistData(Buffer, Size);
        }
    }

    return hr;
}

//
// This function attaches the given folder the the machine created
// by the component data. The machine notifies every attached folder
// when there are state changes in the machine.
//
// INPUT:
//      pFolder     -- the folder to be attached
//      ppMachind   -- to receive a pointer to the machine
// OUTPUT:
//      TRUE if the folder is attached successfully.
//      FALSE if the attachment failed.
//
//
BOOL
CComponent::AttachFolderToMachine(
    CFolder* pFolder,
    CMachine** ppMachine
    )
{
    if (!pFolder)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // Initialize the machine.
    if (m_pComponentData->InitializeMachine())
    {
        *ppMachine = m_pComponentData->m_pMachine;
        (*ppMachine)->AttachFolder(pFolder);
        return TRUE;
    }
    
    return FALSE;
}

//
// This function detaches all the component's folders from the machine
//
void
CComponent::DetachAllFoldersFromMachine()
{
    if (m_pComponentData->m_pMachine)
    {
        CMachine* pMachine = m_pComponentData->m_pMachine;

        CFolder* pFolder;
        POSITION pos = m_listFolder.GetHeadPosition();
        
        while (NULL != pos)
        {
            pFolder = m_listFolder.GetNext(pos);
            pMachine->DetachFolder(pFolder);
        }
    }
}

HRESULT
CComponent::CreateFolderList(
    CCookie* pCookie
    )
{
    CCookie* pCookieChild;
    CScopeItem* pScopeItem;
    CFolder* pFolder;

    ASSERT(pCookie);

    HRESULT hr = S_OK;
    
    do
    {
        pScopeItem = pCookie->GetScopeItem();
        ASSERT(pScopeItem);
        pFolder =  pScopeItem->CreateFolder(this);
        
        if (pFolder)
        {
            m_listFolder.AddTail(pFolder);
            pFolder->AddRef();
            pCookieChild = pCookie->GetChild();
            
            if (pCookieChild)
            {
                hr = CreateFolderList(pCookieChild);
            }

            pCookie = pCookie->GetSibling();
        }

        else
        {
           hr = E_OUTOFMEMORY;
        }

    } while (SUCCEEDED(hr) && pCookie);
    
    return hr;
}

BOOL
CComponent::DestroyFolderList(
    MMC_COOKIE cookie
    )
{
    UNREFERENCED_PARAMETER(cookie);
    
    if (!m_listFolder.IsEmpty())
    {
        POSITION pos = m_listFolder.GetHeadPosition();
        
        while (NULL != pos)
        {
            CFolder* pFolder = m_listFolder.GetNext(pos);
            
            //
            // DONOT delete it!!!!!!!
            //
            pFolder->Release();
        }

        m_listFolder.RemoveAll();
    }

    return TRUE;
}

CFolder*
CComponent::FindFolder(
    MMC_COOKIE cookie
    )
{
    CCookie* pCookie = GetActiveCookie(cookie);
    CFolder* pFolder;
    POSITION pos = m_listFolder.GetHeadPosition();
    
    while (NULL != pos)
    {
        pFolder = m_listFolder.GetNext(pos);
        
        if (pCookie->GetScopeItem() == pFolder->m_pScopeItem)
        {
            return pFolder;
        }
    }

    return NULL;
}

int
CComponent::MessageBox(
    LPCTSTR Msg,
    LPCTSTR Caption,
    DWORD Flags
    )
{
    int Result;
    ASSERT(m_pConsole);
    
    if (SUCCEEDED(m_pConsole->MessageBox(Msg, Caption, Flags, &Result)))
    {
        return Result;
    }

    else
    {
        return IDCANCEL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\componet.h ===
#ifndef __COMPONET_H_
#define __COMPONET_H_

/*++

Copyright (C) Microsoft Corporation

Module Name:

    componet.h

Abstract:

    header file defines CComponent class

Author:

    William Hsieh (williamh) created

Revision History:


--*/


class CComponent :
public IComponent,
public IResultDataCompare,
public IExtendContextMenu,
public IExtendControlbar,
public IExtendPropertySheet,
public IPersistStream,
public ISnapinCallback {
public:
    CComponent(CComponentData* pComponentData);
    ~CComponent();

    //
    // IUNKNOWN
    //
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

public:
    //
    // IComponent interface members
    //
    STDMETHOD(Initialize)(LPCONSOLE pConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, MMC_COOKIE param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                               LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // IResultDataCompare interface member
    //
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

    //
    // IExtendContextMenu
    //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                            LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long* pInsertionAllowed
                           );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    //
    // IExtendControlbar
    //
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IExtendPropertySheet
    //
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    //
    // IPersistStream
    //
    STDMETHOD(GetClassID)(CLSID* pClassId);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream* pStm);
    STDMETHOD(Save)(IStream* pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    //
    // ISnapinCallback
    //
    STDMETHOD(tvNotify)(HWND hwndTV, MMC_COOKIE cookie, TV_NOTIFY_CODE Code, LPARAM arg, LPARAM param);

protected:
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnResultItemClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnResultItemDblClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnViewChange(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnBtnClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnAddImages(MMC_COOKIE cookie, IImageList* pIImageList, HSCOPEITEM hScopeItem);
    HRESULT OnOcxNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    HRESULT OnRestoreView(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextHelp(MMC_COOKIE cookie, LPARAM arg, LPARAM param);

    //
    // Helper functions
    //
    HRESULT DoPropertySheet(MMC_COOKIE cookie);

public:
    void SetDirty()
    {
        m_Dirty = TRUE;
    }
    HRESULT UpdateToolbar(CCookie* pCookie);
    HRESULT CreateFolderList(CCookie* pCookie);
    CScopeItem* FindScopeItem(MMC_COOKIE cookie)
    {
        return m_pComponentData->FindScopeItem(cookie);
    }
    CCookie* GetActiveCookie(MMC_COOKIE cookie)
    {
        return m_pComponentData->GetActiveCookie(cookie);
    }
    CMachine* GetMachine()
    {
        return m_pComponentData->m_pMachine;
    }
    LPCTSTR GetStartupDeviceId()
    {
        return m_pComponentData->m_strStartupDeviceId;
    }
    LPCTSTR GetStartupCommand()
    {
        return m_pComponentData->m_strStartupCommand;
    }
    HRESULT LoadScopeIconsForResultPane(IImageList* pIImageList);

    int MessageBox(LPCTSTR Msg, LPCTSTR Caption, DWORD Flags);
    BOOL AttachFolderToMachine(CFolder* pFolder, CMachine** ppMachine);

    LPCONSOLE       m_pConsole;         // Console's Interface
    LPHEADERCTRL    m_pHeader;          // Result pane's header control interface

    LPRESULTDATA    m_pResult;          // Interface pointer to the result pane
    LPCONSOLEVERB   m_pConsoleVerb;     
    LPPROPERTYSHEETPROVIDER m_pPropSheetProvider;
    LPDISPLAYHELP   m_pDisplayHelp;
    LPTOOLBAR       m_pToolbar;         // Toolbar for view
    LPCONTROLBAR    m_pControlbar;      // Control bar to hold toolbar

private:
    CFolder* FindFolder(MMC_COOKIE cookie);
    BOOL DestroyFolderList(MMC_COOKIE cookie);
    HRESULT SaveFolderPersistData(CFolder* pFolder, IStream* pStm, BOOL fClearDirty);
    HRESULT LoadFolderPersistData(CFolder* pFolder, IStream* pStm);
    void DetachAllFoldersFromMachine();
    CComponentData* m_pComponentData;
    CFolder*        m_pCurFolder;
    CList<CFolder*, CFolder*> m_listFolder;
    BOOL            m_Dirty;
    LONG            m_Ref;
};

#endif  // __COMPONET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\compdata.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    compdata.h

Abstract:

    header file defines CComponentData class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

extern const WCHAR* const DM_COMPDATA_SIGNATURE;

class CComponent;

class CComponentData :
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public ISnapinHelp
{
public:
    CComponentData();
    ~CComponentData();

    //
    // IUNKNOWN interface
    //
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    //
    // IComponentData interface
    //
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // IExtendPropertySheet
    //
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    //
    // IExtendContextMenu
    //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK lpCallbackUnknown,
                long* pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    //
    // IPersistStream
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream* pStm);
    STDMETHOD(Save)(IStream* pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(GetClassID)(CLSID* pClassID);
    virtual const CLSID& GetCoClassID() = 0;
    virtual BOOL IsPrimarySnapin() = 0;

    //
    //ISnapinHelp
    //
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompileHelpFile);

    //
    // Helper functions
    //
    CCookie*    GetActiveCookie(MMC_COOKIE cookie)
    {
        return (NULL == cookie) ? m_pCookieRoot : (CCookie*)cookie;
    }
    CScopeItem* FindScopeItem(MMC_COOKIE cookie);
    BOOL InitializeMachine()
    {
        ASSERT(m_pMachine);
        
        if (m_pMachine)
        {
            return m_pMachine->Initialize(m_hwndMain, NULL);
        }

        return FALSE;
    }
    String m_strMachineName;
    CMachine*   m_pMachine;
    COOKIE_TYPE m_ctRoot;
    String     m_strStartupDeviceId;
    String     m_strStartupCommand;
    void SetDirty()
    {
        m_IsDirty = TRUE;
    }
    LPCONSOLENAMESPACE  m_pScope;
    LPCONSOLE       m_pConsole;
    HWND            m_hwndMain;

private:
    //
    // Event notification functions
    //
    HRESULT OnDelete(MMC_COOKIE cookie, MMC_COOKIE arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnBtnClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT CreateScopeItems();
    HRESULT CreateCookieSubtree(CScopeItem* pScopeItem, CCookie* pCookieParent);
    HRESULT LoadScopeIconsForScopePane();
    HRESULT ResetScopeItem(CScopeItem* pScopeItem);
    HRESULT DoStartupProperties(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle,
                    LPDATAOBJECT pDataObject);


    BOOL            m_IsDirty;
    CCookie*        m_pCookieRoot;
    CScopeItem*     m_pScopeItemRoot;
    LONG            m_Ref;
};

//
// Primary snapin
//
class CComponentDataPrimary : public CComponentData
{
public:
    virtual const CLSID& GetCoClassID()
    {
        return CLSID_DEVMGR;
    }
    virtual BOOL IsPrimarySnapin()
    {
        return TRUE;
    }
};

//
// Extension snapin
//
class CComponentDataExtension : public CComponentData
{
public:
    virtual const CLSID& GetCoClassID()
    {
        return CLSID_DEVMGR_EXTENSION;
    }
    virtual BOOL IsPrimarySnapin()
    {
        return FALSE;
    }
};

typedef struct tagCompDataPersistInfo
{
    DWORD       Size;
    WCHAR       Signature[16];
    COOKIE_TYPE RootCookie;
    WCHAR       ComputerFullName[MAX_PATH + 3];
} COMPDATA_PERSISTINFO, *PCOMPDATA_PERSISTINFO;

#endif      //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\dataobj.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    dataobj.h

Abstract:

    header file defines CDataObject class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject;
class CDataObjectRoot;
class CDataObjectDeviceTreeByType;
class CDataObjectDeviceTreeByConnection;
class CCookie;


class CDataObject : public IDataObject
{
public:
    CDataObject() : m_Ref(1)
    {}
    ~CDataObject()
    {}

// IUnknown interface
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

//  IDataObject interface
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    virtual HRESULT Initialize(DATA_OBJECT_TYPES Type, COOKIE_TYPE ct, CCookie* pCookie, String& strMachineName);

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc) 
    {
        UNREFERENCED_PARAMETER(lpFormatetc);
        return E_NOTIMPL; 
    };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    {
        UNREFERENCED_PARAMETER(lpFormatetcIn);
        UNREFERENCED_PARAMETER(lpFormatetcOut);
        return E_NOTIMPL; 
    };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    {
        UNREFERENCED_PARAMETER(lpFormatetc);
        UNREFERENCED_PARAMETER(lpMedium);
        UNREFERENCED_PARAMETER(bRelease);
        return E_NOTIMPL; 
    };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    {
        UNREFERENCED_PARAMETER(lpFormatetc);
        UNREFERENCED_PARAMETER(advf);
        UNREFERENCED_PARAMETER(pAdvSink);
        UNREFERENCED_PARAMETER(pdwConnection);
        return E_NOTIMPL; 
    };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    {
        UNREFERENCED_PARAMETER(dwConnection);
        return E_NOTIMPL; 
    };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    {
        UNREFERENCED_PARAMETER(ppEnumAdvise);
        return E_NOTIMPL; 
    };


public:

// Clipboard formats that are required by the console
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;  
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfSnapinInternal;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfMachineName;
    static unsigned int    m_cfClassGuid;
    static unsigned int    m_cfDeviceID;
protected:
    COOKIE_TYPE        m_ct;
    CCookie*           m_pCookie;
    int            m_idsNodeName;
private:
    DATA_OBJECT_TYPES      m_Type;
    String         m_strMachineName;
    LONG           m_Ref;
};

extern HRESULT ExtractData(IDataObject* pIDataObject, unsigned int cfClipFormat,
               BYTE* pBuffer, DWORD cbBuffer
               );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\compdata.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    compdata.cpp

Abstract:

    This module implemets CComponentData class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"
#include "genpage.h"

const WCHAR* const DM_COMPDATA_SIGNATURE = L"Device Manager";

CComponentData::CComponentData()
{
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pCookieRoot = NULL;
    m_pScopeItemRoot = NULL;
    
    //
    // Static scope item default to device manager
    //
    m_ctRoot = COOKIE_TYPE_SCOPEITEM_DEVMGR;
    m_hwndMain = NULL;
    m_pMachine = NULL;
    m_IsDirty = FALSE;
    
    //
    // Increment object count (used by CanUnloadNow)
    //
    ::InterlockedIncrement(&CClassFactory::s_Objects);
    m_Ref = 1;
}

CComponentData::~CComponentData()
{
    //
    // All QIed interfaces should be released during
    // Destroy method
    //
    ASSERT(NULL == m_pScope);
    ASSERT(NULL == m_pConsole);
    ASSERT(NULL == m_pCookieRoot);
    
    //
    // decrement object count(used by CanUnloadNow)
    //
    ASSERT( 0 != CClassFactory::s_Objects );
    
    ::InterlockedDecrement(&CClassFactory::s_Objects);
}

//
// IUnknown interface
//
ULONG
CComponentData::AddRef()
{
    return ::InterlockedIncrement(&m_Ref);
}

ULONG
CComponentData::Release()
{
    ASSERT( 0 != m_Ref );
    ULONG cRef = ::InterlockedDecrement(&m_Ref);    
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP
CComponentData::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;


    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)(IComponentData*)this;
    }
    
    else if (IsEqualIID(riid, IID_IComponentData))
    {
        *ppv = (IComponentData*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (IExtendContextMenu*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (IExtendPropertySheet*)this;
    }
    
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppv = (IPersistStream*)this;
    }
    
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (ISnapinHelp*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//  IComponentData implementation
///

STDMETHODIMP
CComponentData::Initialize(
    LPUNKNOWN pUnknown
    )
{
    if (!pUnknown)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    
    try
    {
        //
        // This function should be called only once.
        //
        ASSERT(NULL == m_pScope);
    
        //
        // Get the IConsoleNameSpace interface
        //
        hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void**)&m_pScope);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_pConsole);
            
            if (SUCCEEDED(hr))
            {
                //
                // Retreive the console main window. It will be used
                // as the parent window of property sheets and
                // parent handle for setupapi calls
                //
                m_pConsole->GetMainWindow(&m_hwndMain);
                LoadScopeIconsForScopePane();
            }
            else
            {
                //
                // Unable to get the IConsole Interface
                //
                m_pScope->Release();
            }
        }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// This function creates a new CComponent
// A Component will be created when a new "window" is being created.
//
STDMETHODIMP
CComponentData::CreateComponent(
    LPCOMPONENT* ppComponent
    )
{
    HRESULT hr;

    if (!ppComponent)
    {
        return E_INVALIDARG;
    }

    try
    {
        CComponent* pComponent = new CComponent(this);
        
        //
        // Return the IComponent interface
        //
        hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
        pComponent->Release();
        
        if (SUCCEEDED(hr))
        {
            hr = CreateScopeItems();
    
            if (SUCCEEDED(hr))
            {
                hr = pComponent->CreateFolderList(m_pCookieRoot);
            }
            else
            {
                pComponent->Release();
                *ppComponent = NULL;
            }
        }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponentData::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM    arg,
    LPARAM    param
    )
{
    HRESULT hr;

    try
    {
        //
        // On MMCN_PROPERTY_CHANGE event, lpDataObject is invalid
        // Donot touch it.
        //
        if (MMCN_PROPERTY_CHANGE == event)
        {
            PPROPERTY_CHANGE_INFO pPCI = (PPROPERTY_CHANGE_INFO) param;
            
            if (pPCI && PCT_STARTUP_INFODATA == pPCI->Type)
            {
                PSTARTUP_INFODATA pSI = (PSTARTUP_INFODATA)&pPCI->InfoData;
                ASSERT(pSI->Size == sizeof(STARTUP_INFODATA));
                
                if (pSI->MachineName[0] != _T('\0'))
                {
                    m_strMachineName = pSI->MachineName;
                }
                
                m_ctRoot = pSI->ct;
                SetDirty();
            }

            return S_OK;
        }

        else if (MMCN_EXPAND == event)
        {
            return OnExpand(lpDataObject, arg, param);
        }
        
        else if (MMCN_REMOVE_CHILDREN == event)
        {
            //
            // This is basically a hack!!!!
            // When the target computer is switched in Computer Management
            // snapin (we are an extention to it), we basically get
            // a MMCN_REMOVE_CHILDREN followed by MMCN_EXPAND.
            // The right thing for MMC to do is to create a new IComponent
            // for each new machine so that each IComponent can maintain
            // its own states (thus, its own folders).
            // Well, it is not a perfect world and we are forced to use
            // the old IComponent. So here we notify each scope node
            // which in turns will notify all the CFolders.
            //
            // After reset, each folder does not attach to any CMachine object
            // (thus, its m_pMachine will be NULL). Each folder will attach
            // to the new machine object when its OnShow method is called
            // the very "first" time.
            //
            if (!IsPrimarySnapin() && m_pScopeItemRoot)
            {
                m_pMachine->DestroyNotifyWindow();
                ResetScopeItem(m_pScopeItemRoot);
            }

            return S_OK;
        }
    
        ASSERT(m_pScope);
        INTERNAL_DATA tID;
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                 (PBYTE)&tID, sizeof(tID));
    
    
        if (SUCCEEDED(hr))
        {
            switch (event) {
            case MMCN_DELETE:
                hr = OnDelete(tID.cookie, arg, param);
                break;
            case MMCN_RENAME:
                hr = OnRename(tID.cookie, arg, param);
                break;
            case MMCN_CONTEXTMENU:
                hr = OnContextMenu(tID.cookie, arg, param);
                break;
            case MMCN_BTN_CLICK:
                hr = OnBtnClick(tID.cookie, arg, param);
                break;
            default:
                hr = S_OK;
                break;
            }
        }
    }
    
    catch(CMemoryException* e)
    {
        e->Delete();
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP
CComponentData::GetDisplayInfo(
    SCOPEDATAITEM* pScopeDataItem
    )
{
    if (!pScopeDataItem)
    {
        return E_INVALIDARG;
    }

    try
    {
        //
        // IComponentData::GetDisplayInfo only deals with scope pane items.
        // Snapin's IComponent::GetDisplayInfo will deal with result pane items
        //
        CCookie* pCookie = (CCookie*) pScopeDataItem->lParam;
        ASSERT(pCookie);
        return pCookie->GetScopeItem()->GetDisplayInfo(pScopeDataItem);
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CComponentData::Destroy()
{
    if (m_pCookieRoot) 
    {
        delete m_pCookieRoot;
        m_pCookieRoot = NULL;
    }

    if (m_pScopeItemRoot) 
    {
        delete m_pScopeItemRoot;
    }

    if (m_pScope) 
    {
        m_pScope->Release();
        m_pScope = NULL;
    }
    
    if (m_pConsole)
    {
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    return S_OK;
}

STDMETHODIMP
CComponentData::QueryDataObject(
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    LPDATAOBJECT* ppDataObject
    )
{
    CDataObject* pDataObject;
    COOKIE_TYPE  ct;
    CCookie* pCookie;

    try
    {
        pCookie = GetActiveCookie(cookie);
        
        if (NULL == pCookie)
        {
            ct = m_ctRoot;
        }
        else
        {
            ct = pCookie->GetType();
        }
    
        pDataObject = new CDataObject;
        pDataObject->Initialize(type, ct, pCookie, m_strMachineName);
        pDataObject->AddRef();
        *ppDataObject = pDataObject;
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

STDMETHODIMP
CComponentData::CompareObjects(
    LPDATAOBJECT lpDataObjectA,
    LPDATAOBJECT lpDataObjectB
    )
{
    HRESULT hr;
    
    try
    {
        INTERNAL_DATA tID_A, tID_B;
        hr = ExtractData(lpDataObjectA, CDataObject::m_cfSnapinInternal,
                 (PBYTE)&tID_A, sizeof(tID_A));
        
        if (SUCCEEDED(hr))
        {
            hr = ExtractData(lpDataObjectB, CDataObject::m_cfSnapinInternal,
                     (PBYTE)&tID_B, sizeof(tID_B));
            
            if (SUCCEEDED(hr))
            {
                hr = (tID_A.ct == tID_B.ct && tID_A.cookie == tID_B.cookie &&
                       tID_A.dot == tID_B.dot) ? S_OK : S_FALSE;
            }
        }
    }
    
    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}



///////////////////////////////////////////////////////////////////
//// IExtendPropertySheet implementation
////
STDMETHODIMP
CComponentData::QueryPagesFor(
    LPDATAOBJECT lpDataObject
    )
{
    HRESULT hr;

    if (!lpDataObject)
    {
        return E_INVALIDARG;
    }

    try
    {
        INTERNAL_DATA tID;
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                 (PBYTE)&tID, sizeof(tID));
        
        if (SUCCEEDED(hr))
        {
            CScopeItem* pScopeItem;
            pScopeItem = FindScopeItem(tID.cookie);
            
            if (CCT_SNAPIN_MANAGER == tID.dot && COOKIE_TYPE_SCOPEITEM_DEVMGR == tID.ct)
            {
                hr = S_OK;
            }

            else if (pScopeItem)
            {
                hr = pScopeItem->QueryPagesFor();
            }
            
            else
            {
                hr = S_FALSE;
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT lpDataObject
    )
{
    if (!lpProvider || !lpDataObject)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    try
    {
        INTERNAL_DATA tID;
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                 reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                 );
        
        if (SUCCEEDED(hr))
        {
            CScopeItem* pScopeItem = FindScopeItem(tID.cookie);
            if (CCT_SNAPIN_MANAGER == tID.dot && COOKIE_TYPE_SCOPEITEM_DEVMGR == tID.ct)
            {
                hr = DoStartupProperties(lpProvider, handle, lpDataObject);
            }
            
            else if (pScopeItem)
            {
                hr = pScopeItem->CreatePropertyPages(lpProvider, handle);
            }

            else
            {
                hr = S_OK;
            }
        }
    }
    
    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}


////////////////////////////////////////////////////////////
//// IExtendContextMenu implemantation
////
STDMETHODIMP
CComponentData::AddMenuItems(
    LPDATAOBJECT lpDataObject,
    LPCONTEXTMENUCALLBACK pCallbackUnknown,
    long *pInsertionAllowed
    )
{
    if (!lpDataObject || !pCallbackUnknown || !pInsertionAllowed)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP
CComponentData::Command(
    long nCommandID,
    LPDATAOBJECT lpDataObject
    )
{
    UNREFERENCED_PARAMETER(nCommandID);

    if (!lpDataObject)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
CComponentData::CreateCookieSubtree(
    CScopeItem* pScopeItem,
    CCookie* pCookieParent
    )
{
    ASSERT(pScopeItem);

    CScopeItem* pChild;
    CCookie* pCookieSibling;
    pCookieSibling = NULL;
    int Index = 0;

    while (pScopeItem->EnumerateChildren(Index, &pChild))
    {
        CCookie* pCookie;
        
        pCookie =  new CCookie(pChild->GetType());
        
        if (pCookie) {
        
            pCookie->SetScopeItem(pChild);
            
            if (!pCookieSibling)
            {
                pCookieParent->SetChild(pCookie);
            }
            else
            {
                pCookieSibling->SetSibling(pCookie);
            }
            
            pCookie->SetParent(pCookieParent);
            
            if (pChild->GetChildCount())
            {
                CreateCookieSubtree(pChild, pCookie);
            }
            
            pCookieSibling = pCookie;
        }

        Index++;
    }

    return S_OK;
}
////////////////////////////////////////////////////////////
/// IPersistStream implementation
///
STDMETHODIMP
CComponentData::GetClassID(
    CLSID* pClassID
    )
{
    if(!pClassID)
    {
        return E_INVALIDARG;
    }

    *pClassID = GetCoClassID();
    return S_OK;
}

STDMETHODIMP
CComponentData::IsDirty()
{
    return m_IsDirty ? S_OK : S_FALSE;
}

STDMETHODIMP
CComponentData::Load(
    IStream* pStm
    )
{
    HRESULT hr;
    SafeInterfacePtr<IStream> StmPtr(pStm);

    //
    // Fix up the MachineName that we got from the command line if there was one.
    // We need to prepend "\\" to the MachineName if it does not start with two
    // backslashes, and then we will verify the machine name by calling CM_Connect_Machine
    // to verify that this user has access to that machine.  If they do not then we
    // will set the MachineName to NULL.
    //
    if (!g_strStartupMachineName.IsEmpty())
    {
        if (_T('\\') != g_strStartupMachineName[0])
        {
            g_strStartupMachineName = TEXT("\\\\") + g_strStartupMachineName;
        }
    }

    COMPDATA_PERSISTINFO Info;
    ULONG BytesRead;

    ASSERT(pStm);
    
    //
    // Read the persist data and verify that we have the right data
    //
    hr = pStm->Read(&Info, sizeof(Info), &BytesRead);

    if (SUCCEEDED(hr) && 
        (BytesRead >= sizeof(Info)) &&
        (Info.Size >= sizeof(Info)) &&
        (!wcscmp(Info.Signature, DM_COMPDATA_SIGNATURE)))
    {
        try
        {
            m_ctRoot = Info.RootCookie;
            m_strMachineName.Empty();

            if (UNICODE_NULL != Info.ComputerFullName[0])
            {
                m_strMachineName = Info.ComputerFullName;
            }
    
            if (COOKIE_TYPE_SCOPEITEM_DEVMGR == m_ctRoot)
            {
                //
                // Parameters from command line has the priority
                //
                if (!g_strStartupMachineName.IsEmpty())
                {
                    m_strMachineName = g_strStartupMachineName;
                }
                
                m_strStartupDeviceId = g_strStartupDeviceId;
                m_strStartupCommand = g_strStartupCommand;
            }
    
            hr = CreateScopeItems();
            if (SUCCEEDED(hr))
            {
                if (!m_pMachine)
                {
                    if (!g_MachineList.CreateMachine(m_strMachineName, &m_pMachine))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }

        catch(CMemoryException* e)
        {
            e->Delete();
            MsgBoxParam(m_hwndMain, 0, 0, 0);
            hr = E_OUTOFMEMORY;
        }
    } else {
        //
        // No persistant data, so use the command line parameters.
        //
        m_strMachineName = g_strStartupMachineName;
        m_strStartupDeviceId = g_strStartupDeviceId;
        m_strStartupCommand = g_strStartupCommand;
    }

    m_IsDirty = FALSE;

    return hr;
}

STDMETHODIMP
CComponentData::Save(
    IStream* pStm,
    BOOL fClearDirty
    )
{
    SafeInterfacePtr<IStream> StmPtr(pStm);

    HRESULT hr;

    try
    {
        COMPDATA_PERSISTINFO Info;
        Info.Size = sizeof(Info);
        Info.RootCookie = m_ctRoot;
        StringCchCopy(Info.Signature, ARRAYLEN(Info.Signature), DM_COMPDATA_SIGNATURE);
    
        //
        // Assuming it is on local machine. The machine name is saved
        // in UNICODE
        //
        Info.ComputerFullName[0] = UNICODE_NULL;
        if (m_strMachineName.GetLength())
            StringCchCopy(Info.ComputerFullName, ARRAYLEN(Info.ComputerFullName), m_strMachineName);
            hr = pStm->Write(&Info, sizeof(Info), NULL);
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }

    if (fClearDirty)
    {
        m_IsDirty = FALSE;
    }
    
    return hr;
}

STDMETHODIMP
CComponentData::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )
{
    if (!pcbSize)
    {
        return E_INVALIDARG;
    }

    int len;
    len = sizeof(m_ctRoot) + sizeof(len) +  (m_strMachineName.GetLength() + 1) * sizeof(TCHAR);
    ULISet32(*pcbSize, len);
    
    return S_OK;
}

//
// Method to support html help.
//
//
STDMETHODIMP
CComponentData::GetHelpTopic(
    LPOLESTR* lpCompileHelpFile
    )
{
    if (!lpCompileHelpFile)
    {
        return E_INVALIDARG;
    }

    *lpCompileHelpFile = NULL;
    String strHelpFile;
    
    if (strHelpFile.GetSystemWindowsDirectory()) {
        strHelpFile += (LPCTSTR)DEVMGR_HTML_HELP_FILE_NAME;
        *lpCompileHelpFile = AllocOleTaskString((LPCTSTR)strHelpFile);
    }

    return S_OK;
}

CScopeItem*
CComponentData::FindScopeItem(
    MMC_COOKIE cookie
    )
{
    CCookie* pCookie = GetActiveCookie(cookie);
    
    if (pCookie) {
        return pCookie->GetScopeItem();
    }

    return NULL;
}

//
// This function loads icons for the scope items
//
HRESULT
CComponentData::LoadScopeIconsForScopePane()
{
    ASSERT(m_pScope);
    ASSERT(m_pConsole);

    LPIMAGELIST lpScopeImage;
    HRESULT hr;
    
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    
    if (SUCCEEDED(hr))
    {
        HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR));
        
        if (hIcon)
        {
            hr = lpScopeImage->ImageListSetIcon((PLONG_PTR)hIcon, IMAGE_INDEX_DEVMGR);
            DestroyIcon(hIcon);
        }
        
        hr = lpScopeImage->Release();
    }

    return hr;
}

//
// This function create the startup wizard property sheet
//
// INPUT:
//  lpProvider -- Interface for us to add pages
//  handle     -- notify console handle
//  lpDataObject -- the data object
//
// OUTPUT:
//   standard OLE HRESULT

HRESULT
CComponentData::DoStartupProperties(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT lpDataObject
    )
{
    CGeneralPage* pGenPage;
    HPROPSHEETPAGE hPage;

    UNREFERENCED_PARAMETER(lpDataObject);

    pGenPage = new CGeneralPage();

    if (pGenPage) 
    {
        hPage = pGenPage->Create(handle);
        
        if (hPage)
        {
            lpProvider->AddPage(hPage);
            
            //
            // If no console handle is provided, we have to use
            // our call back function
            //
            if(!handle)
            {
                pGenPage->SetOutputBuffer(&m_strMachineName, &m_ctRoot);
            }
    
            return S_OK;
        }
    
        else
        {
            throw &g_MemoryException;
        }
    }

    else
    {
        throw &g_MemoryException;
    }
}

//
// This function creates all the necessary classes represent
// our scope items
//
HRESULT
CComponentData::CreateScopeItems()
{
    HRESULT hr = S_OK;

    //
    // All classes are linked by cookie with m_pCookieRoot
    // points to the "root" scope item
    //
    if (!m_pScopeItemRoot)
    {
        switch (m_ctRoot) {
        
        case COOKIE_TYPE_SCOPEITEM_DEVMGR:
            m_pScopeItemRoot = new CScopeItem(COOKIE_TYPE_SCOPEITEM_DEVMGR,
                                              IMAGE_INDEX_DEVMGR,
                                              OPEN_IMAGE_INDEX_DEVMGR,
                                              IDS_NAME_DEVMGR,
                                              IDS_DESC_DEVMGR,
                                              IDS_DISPLAYNAME_SCOPE_DEVMGR);
            break;
            
        default:
            ASSERT(FALSE);
            break;
        }
        
        if (m_pScopeItemRoot->Create()) {
            //
            // Bind scope items and cookies together.
            // Cookies know its scopeitem.
            // Scopeitems do not know cookies.
            //
            m_pCookieRoot = new CCookie(m_ctRoot);
            
            if (m_pCookieRoot) {

                ASSERT(m_pScopeItemRoot->GetType() == m_ctRoot);
                m_pCookieRoot->SetScopeItem(m_pScopeItemRoot);
                CreateCookieSubtree(m_pScopeItemRoot, m_pCookieRoot);
            
            } else {

                hr = E_OUTOFMEMORY;
            }
        }
    }
    
    return hr;
}


//
// This function resets the given scopeitem.
//
HRESULT
CComponentData::ResetScopeItem(
    CScopeItem* pScopeItem
    )
{
    HRESULT hr = S_OK;
    
    if (pScopeItem)
    {
        CScopeItem* pChild;
        int Index;
        Index = 0;
        
        while (SUCCEEDED(hr) && pScopeItem->EnumerateChildren(Index, &pChild))
        {
            hr = ResetScopeItem(pChild);
            Index++;
        }
        
        if (SUCCEEDED(hr))
        {
            return pScopeItem->Reset();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\dataobj.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    dataobj.cpp

Abstract:

    header file defines CDataObject class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "DataObj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfSnapinInternal = RegisterClipboardFormat(SNAPIN_INTERNAL);
unsigned int CDataObject::m_cfMachineName    = RegisterClipboardFormat(MMC_SNAPIN_MACHINE_NAME);
unsigned int CDataObject::m_cfClassGuid      = RegisterClipboardFormat(DEVMGR_SNAPIN_CLASS_GUID);
unsigned int CDataObject::m_cfDeviceID       = RegisterClipboardFormat(DEVMGR_SNAPIN_DEVICE_ID);

//
// IUnknown interface implementation
//

ULONG
CDataObject::AddRef()
{
    return ::InterlockedIncrement(&m_Ref);
}

ULONG
CDataObject::Release()
{
    ASSERT( 0 != m_Ref );
    ULONG cRef = ::InterlockedDecrement(&m_Ref);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP
CDataObject::QueryInterface(
                           REFIID riid,
                           void** ppv
                           )
{
    if (!ppv) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown)) {
        
        *ppv = (IUnknown*)this;
    
    } else if (IsEqualIID(riid, IID_IDataObject)) {
        
        *ppv = this;
    
    } else {
        
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr)) {
        AddRef();
    } else {
        *ppv = NULL;
    }

    return hr;
}

HRESULT
CDataObject::Initialize(
                       DATA_OBJECT_TYPES Type,
                       COOKIE_TYPE      ct,
                       CCookie* pCookie,
                       String& strMachineName
                       )
{
    try {
        m_strMachineName = strMachineName;
        m_pCookie = pCookie;
        m_Type = Type;
        m_ct = ct;
    
    } catch (CMemoryException* e) {
        e->Delete();
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


STDMETHODIMP
CDataObject::GetDataHere(
                        LPFORMATETC lpFormatetc,
                        LPSTGMEDIUM lpMedium
                        )
{
    HRESULT hr = S_OK;

    try {
        const CLIPFORMAT cf = lpFormatetc->cfFormat;
        hr = DV_E_FORMATETC;
        SafeInterfacePtr<IStream> StreamPtr;

        if (TYMED_HGLOBAL == lpMedium->tymed) {
            ULONG ulWritten;
            hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &StreamPtr);

            if (S_OK == hr) {
                const NODEINFO* pni = &NodeInfo[m_ct];
                ASSERT(pni->ct == m_ct);

                if (cf == m_cfNodeType) {
                    const GUID* pGuid = &pni->Guid;
                    hr = StreamPtr->Write(pGuid, sizeof(GUID), &ulWritten);
                } else if (cf == m_cfNodeTypeString) {
                    const TCHAR *pszGuid = pni->GuidString;
                    hr = StreamPtr->Write(pszGuid,
                                          (ULONG)(wcslen(pszGuid) + 1) * sizeof(TCHAR),
                                          &ulWritten
                                         );
                } else if (cf == m_cfDisplayName) {
                    if (pni->idsFormat) {
                        String strDisplayName;
                        TCHAR Format[LINE_LEN];
                        TCHAR LocalMachine[LINE_LEN];
                        ::LoadString(g_hInstance, pni->idsFormat, Format, ARRAYLEN(Format));
                        LPCTSTR MachineName = m_strMachineName;

                        if (m_strMachineName.IsEmpty()) {
                            ::LoadString(g_hInstance, IDS_LOCAL_MACHINE, LocalMachine,
                                         ARRAYLEN(LocalMachine));
                            MachineName = LocalMachine;
                        }

                        strDisplayName.Format(Format, MachineName);
                        hr = StreamPtr->Write(strDisplayName,
                                              (strDisplayName.GetLength() + 1) * sizeof(TCHAR),
                                              &ulWritten
                                             );
                    }
                } else if (cf == m_cfSnapinInternal) {
                    INTERNAL_DATA tID;
                    tID.ct = m_ct;
                    tID.dot = m_Type;
                    tID.cookie = (MMC_COOKIE)m_pCookie;
                    hr = StreamPtr->Write(&tID,
                                          sizeof(INTERNAL_DATA),
                                          &ulWritten
                                         );
                } else if (cf == m_cfCoClass) {
                    hr = StreamPtr->Write(&CLSID_DEVMGR,
                                          sizeof(CLSID),
                                          &ulWritten
                                         );
                } else if (cf == m_cfMachineName) {
                    if (!m_strMachineName.IsEmpty()) {
                        hr = StreamPtr->Write((LPCTSTR)m_strMachineName,
                                              (m_strMachineName.GetLength()+1) * sizeof(TCHAR),
                                              NULL);
                    } else {
                        TCHAR Nothing[1];
                        Nothing[0] = _T('\0');
                        hr = StreamPtr->Write(Nothing, sizeof(Nothing), NULL);
                    }
                } else if (cf == m_cfClassGuid) {
                    if (COOKIE_TYPE_RESULTITEM_CLASS == m_pCookie->GetType()) {
                        CClass* pClass = (CClass*)m_pCookie->GetResultItem();
                        ASSERT(pClass);
                        LPGUID pClassGuid = *pClass;
                        hr = StreamPtr->Write(pClassGuid, sizeof(GUID), NULL);
                    }
                } else if (cf == m_cfDeviceID) {
                    if (COOKIE_TYPE_RESULTITEM_DEVICE == m_pCookie->GetType()) {
                        CDevice* pDevice = (CDevice*)m_pCookie->GetResultItem();
                        ASSERT(pDevice);
                        LPCTSTR DeviceID = pDevice->GetDeviceID();

                        hr = StreamPtr->Write(DeviceID,
                                              (ULONG)(wcslen(DeviceID) + 1) * sizeof(TCHAR),
                                              NULL
                                             );
                    }
                } else {
                    hr = DV_E_FORMATETC;
                }
            }
        }
    } catch (CMemoryException* e) {
        e->Delete();
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP
CDataObject::GetData(
                    LPFORMATETC lpFormatetc,
                    LPSTGMEDIUM lpMedium
                    )
{
    UNREFERENCED_PARAMETER(lpFormatetc);
    UNREFERENCED_PARAMETER(lpMedium);

    return E_NOTIMPL;
}

STDMETHODIMP
CDataObject::EnumFormatEtc(
                          DWORD dwDirection,
                          LPENUMFORMATETC* ppEnumFormatEtc
                          )
{
    UNREFERENCED_PARAMETER(dwDirection);
    UNREFERENCED_PARAMETER(ppEnumFormatEtc);

    return E_NOTIMPL;
}

HRESULT ExtractData(
                   IDataObject* pIDataObject,
                   unsigned int cfClipFormat,
                   BYTE*    pBuffer,
                   DWORD    cbBuffer
                   )
{
    if ((NULL == pIDataObject) || (NULL == pBuffer)) {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    FORMATETC FormatEtc = {(CLIPFORMAT)cfClipFormat, NULL, DVASPECT_CONTENT, -1 , TYMED_HGLOBAL};
    STGMEDIUM StgMedium = {TYMED_HGLOBAL, NULL};

    StgMedium.hGlobal = ::GlobalAlloc(GMEM_SHARE, cbBuffer);
    if (NULL == StgMedium.hGlobal) {
        ASSERT(FALSE);
        hr = E_OUTOFMEMORY;
    } else {
        hr = pIDataObject->GetDataHere(&FormatEtc, &StgMedium);
        if (SUCCEEDED(hr)) {
            BYTE* pData = reinterpret_cast<BYTE*>(::GlobalLock(StgMedium.hGlobal));
            if (NULL == pData) {
                ASSERT(FALSE);
                hr = E_UNEXPECTED;
            } else {
                ::memcpy(pBuffer, pData, cbBuffer);
                ::GlobalUnlock(StgMedium.hGlobal);
            }
        }
        ::GlobalFree(StgMedium.hGlobal);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devdetpg.h ===
// devdetpg.h : header file
//

#ifndef __DEVDETPG_H__
#define __DEVDETPG_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    devdetpg.h

Abstract:

    header file for devdetpg.cpp

Author:

    Jason Cobb (JasonC) created

Revision History:


--*/

#include "proppage.h"
#include "wmium.h"
#include "wdmguid.h"


//
// help topic ids
//
#define IDH_DISABLEHELP (DWORD(-1))

#define NUM_DN_STATUS_FLAGS     32
#define NUM_CM_DEVCAP_FLAGS     10
#define NUM_CONFIGFLAGS         14
#define NUM_CSCONFIGFLAGS       3
#define NUM_POWERCAPABILITIES   9

typedef enum tagDetailsTypes {
 
    DETAILS_DEVICEINSTANCEID = 0,
    DETAILS_HARDWAREIDS,
    DETAILS_COMPATIDS,           
    DETAILS_MATCHINGID,          
    DETAILS_SERVICE,             
    DETAILS_ENUMERATOR,          
    DETAILS_CAPABILITIES,        
    DETAILS_DEVNODE_FLAGS,       
    DETAILS_CONFIGFLAGS,         
    DETAILS_CSCONFIGFLAGS,       
    DETAILS_EJECTIONRELATIONS,   
    DETAILS_REMOVALRELATIONS,    
    DETAILS_BUSRELATIONS,        
    DETAILS_DEVICEUPPERFILTERS,        
    DETAILS_DEVICELOWERFILTERS,
    DETAILS_CLASSUPPERFILTERS,        
    DETAILS_CLASSLOWERFILTERS,
    DETAILS_CLASSINSTALLER,
    DETAILS_CLASSCOINSTALLERS,
    DETAILS_DEVICECOINSTALLERS,
    DETAILS_FIRMWAREREVISION,
    DETAILS_CURRENTPOWERSTATE,
    DETAILS_POWERCAPABILITIES,
    DETAILS_POWERSTATEMAPPINGS,
    DETAILS_MAX,

} DETAILSTYPES, *PDETAILSTYPES;

class CDeviceDetailsPage : public CPropSheetPage
{
public:
    CDeviceDetailsPage() :
        m_pDevice(NULL),
        m_hwndDetailsList(NULL),
        CPropSheetPage(g_hInstance, IDD_DEVDETAILS_PAGE)
        {}
    ~CDeviceDetailsPage()
        {}
    HPROPSHEETPAGE Create(CDevice* pDevice)
    {
        ASSERT(pDevice);
        m_pDevice = pDevice;
        m_psp.lParam = (LPARAM)this;
        return CreatePage();
    }

protected:
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(LPNMHDR pnmhdr);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
private:
    void UpdateDetailsText();
    void DisplayMultiSzString(DWORD Property);
    void DisplayString(DWORD Property);
    void DisplayDevnodeFlags(DWORD StatusType);
    void DisplayRelations(DWORD RelationType);
    void DisplayMatchingId();
    void DisplayClassInstaller();
    void DisplayClassCoInstallers();
    void DisplayDeviceCoInstallers();
    void DisplayFirmwareRevision();
    void DisplayCurrentPowerState();
    void DisplayPowerStateMappings();
    void DisplayClassFilters(DWORD ClassFilter);
    void CopyToClipboard();
    CDevice*    m_pDevice;
    HWND        m_hwndDetailsList;
};

#endif // _DEVDETPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devdetpg.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    devdetpg.cpp

Abstract:

    This module implements CDeviceDetailsPage -- device details
    property page

Author:

    Jason Cobb (JasonC) created

Revision History:


--*/

#include "devmgr.h"
#include "devdetpg.h"
#include <wmidata.h>

extern "C" {
#include <initguid.h>
#include <wdmguid.h>
}


//
// help topic ids
//
const DWORD g_a15HelpIDs[]=
{
    IDC_DEVDETAILS_DESC,  IDH_DISABLEHELP,
    IDC_DEVDETAILS_ICON,  IDH_DISABLEHELP,
    0,0

};

BOOL
CDeviceDetailsPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    UNREFERENCED_PARAMETER(ppsp);

    try {

        m_hwndDetailsList = GetDlgItem(m_hDlg, IDC_DEVDETAILS_LIST);
        
        String DetailsType;
        for (int i = DETAILS_DEVICEINSTANCEID; i < DETAILS_MAX; i++) {
    
            DetailsType.LoadString(g_hInstance, IDS_DETAILS_DEVICEINSTANCEID + i);
            SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_COMBO, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)DetailsType);
        }

        SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_COMBO, CB_SETCURSEL, 0, 0);

        LV_COLUMN lvcCol;
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(m_hwndDetailsList, 0, &lvcCol);

        ListView_SetExtendedListViewStyle(m_hwndDetailsList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        UpdateDetailsText();
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }

    return TRUE;
}

BOOL
CDeviceDetailsPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    switch (LOWORD(wParam)) {
    
    case IDC_DEVDETAILS_COMBO:
        if (CBN_SELCHANGE == HIWORD(wParam)) {

            UpdateDetailsText();
        }
        break;
    }

    return FALSE;
}

BOOL 
CDeviceDetailsPage::OnNotify(
    LPNMHDR pnmhdr
    )
{
    if (pnmhdr->idFrom == IDC_DEVDETAILS_LIST) {

        if (pnmhdr->code == LVN_KEYDOWN) {

            LPNMLVKEYDOWN pnmlvKeyDown = (LPNMLVKEYDOWN)pnmhdr;

            if (::GetKeyState(VK_CONTROL)) {
                
                switch (pnmlvKeyDown->wVKey) {
                
                case 'C':
                case 'c':
                case VK_INSERT:
                    CopyToClipboard();
                    break;

                case 'A':
                case 'a':
                    ListView_SetSelectionMark(m_hwndDetailsList, 0);
                    ListView_SetItemState(m_hwndDetailsList, -1, LVIS_SELECTED, LVIS_SELECTED);
                    break;
                }
            }
        }
    }

    return FALSE;
}

//
// This function refreshes every control in the dialog. It may be called
// when the dialog is being initialized
//
void
CDeviceDetailsPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam) {

        m_pDevice = (CDevice*)lParam;
    }

    try {

        HICON hIconOld;
        m_IDCicon = IDC_DEVDETAILS_ICON;  // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_ICON, STM_SETICON,
                                      (WPARAM)(m_pDevice->LoadClassIcon()),
                                      0
                                      );
        if (hIconOld)
        {
            DestroyIcon(hIconOld);
        }

        SetDlgItemText(m_hDlg, IDC_DEVDETAILS_DESC, m_pDevice->GetDisplayName());

    }
    catch (CMemoryException* e)
    {
        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDeviceDetailsPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a15HelpIDs);
    return FALSE;
}


BOOL
CDeviceDetailsPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);
    
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a15HelpIDs);
    return FALSE;
}

void
CDeviceDetailsPage::UpdateDetailsText()
{
    int CurSel = (int)SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_COMBO, CB_GETCURSEL, 0, 0);

    if (CurSel != CB_ERR) {

        ListView_DeleteAllItems(m_hwndDetailsList);
        
        switch(CurSel) {
        case DETAILS_DEVICEINSTANCEID:
            LVITEM lv;
            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.pszText = (LPTSTR)m_pDevice->GetDeviceID();
            ListView_InsertItem(m_hwndDetailsList, &lv);
            ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
            break;

        case DETAILS_HARDWAREIDS:
            DisplayMultiSzString(SPDRP_HARDWAREID);
            break;

        case DETAILS_COMPATIDS:
            DisplayMultiSzString(SPDRP_COMPATIBLEIDS);
            break;

        case DETAILS_DEVICEUPPERFILTERS:
            DisplayMultiSzString(SPDRP_UPPERFILTERS);
            break;

        case DETAILS_DEVICELOWERFILTERS:
            DisplayMultiSzString(SPDRP_LOWERFILTERS);
            break;

        case DETAILS_CLASSUPPERFILTERS:
        case DETAILS_CLASSLOWERFILTERS:
            DisplayClassFilters(CurSel);
            break;

        case DETAILS_ENUMERATOR:
            DisplayString(SPDRP_ENUMERATOR_NAME);
            break;

        case DETAILS_SERVICE:
            DisplayString(SPDRP_SERVICE);
            break;

        case DETAILS_DEVNODE_FLAGS:
        case DETAILS_CAPABILITIES:
        case DETAILS_CONFIGFLAGS:
        case DETAILS_CSCONFIGFLAGS:
        case DETAILS_POWERCAPABILITIES:
            DisplayDevnodeFlags(CurSel);
            break;

        case DETAILS_EJECTIONRELATIONS:
        case DETAILS_REMOVALRELATIONS:
        case DETAILS_BUSRELATIONS:
            DisplayRelations(CurSel);
            break;

        case DETAILS_MATCHINGID:
            DisplayMatchingId();
            break;

        case DETAILS_CLASSINSTALLER:
            DisplayClassInstaller();
            break;
        
        case DETAILS_CLASSCOINSTALLERS:
            DisplayClassCoInstallers();
            break;

        case DETAILS_DEVICECOINSTALLERS:
            DisplayDeviceCoInstallers();
            break;

        case DETAILS_FIRMWAREREVISION:
            DisplayFirmwareRevision();
            break;

        case DETAILS_CURRENTPOWERSTATE:
            DisplayCurrentPowerState();
            break;

        case DETAILS_POWERSTATEMAPPINGS:
            DisplayPowerStateMappings();
            break;

        default:
            ASSERT(FALSE);
            break;
        }

        ListView_SetColumnWidth(m_hwndDetailsList, 0, LVSCW_AUTOSIZE_USEHEADER);
    }
}

void
CDeviceDetailsPage::DisplayMultiSzString(
    DWORD Property
    )
{
    TCHAR TempBuffer[REGSTR_VAL_MAX_HCID_LEN];
    ULONG TempBufferLen;
    LPTSTR SingleItem = NULL;
    LVITEM lv;

    TempBufferLen = sizeof(TempBuffer);

    if (m_pDevice->m_pMachine->DiGetDeviceRegistryProperty(
            *m_pDevice, 
            Property,
            NULL, 
            (PBYTE)TempBuffer,
            TempBufferLen, 
            &TempBufferLen
            ) &&
        (TempBufferLen > 2 * sizeof(TCHAR))) {

        ZeroMemory(&lv, sizeof(LVITEM));
        lv.mask = LVIF_TEXT;
        lv.iItem = 0;

        for (SingleItem = TempBuffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {

            lv.pszText = SingleItem;
            ListView_InsertItem(m_hwndDetailsList, &lv);

            lv.iItem++;
        }

        ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void
CDeviceDetailsPage::DisplayString(
    DWORD Property
    )
{
    TCHAR TempBuffer[MAX_PATH];
    ULONG TempBufferLen;
    LVITEM lv;

    TempBufferLen = sizeof(TempBuffer);

    if (m_pDevice->m_pMachine->DiGetDeviceRegistryProperty(
            *m_pDevice, 
            Property,
            NULL, 
            (PBYTE)TempBuffer,
            TempBufferLen, 
            &TempBufferLen
            ) &&
        (TempBufferLen > 2 * sizeof(TCHAR))) {

        ZeroMemory(&lv, sizeof(LVITEM));
        lv.mask = LVIF_TEXT;
        lv.iItem = 0;
        lv.pszText = TempBuffer;
        ListView_InsertItem(m_hwndDetailsList, &lv);
        ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void
CDeviceDetailsPage::DisplayDevnodeFlags(
    DWORD StatusType
    )
{
    DWORD Flags, Problem;
    LVITEM lv;
    UINT StatusStringId;
    int NumFlags;
    String stringDevnodeFlags;

    ZeroMemory(&lv, sizeof(LVITEM));
    lv.mask = LVIF_TEXT;
    lv.iItem = 0;

    Flags = NumFlags = 0;

    switch(StatusType) {
    case DETAILS_CAPABILITIES:
        m_pDevice->GetCapabilities(&Flags);
        StatusStringId = IDS_CM_DEVCAP_LOCKSUPPORTED;
        NumFlags = NUM_CM_DEVCAP_FLAGS;
        break;

    case DETAILS_DEVNODE_FLAGS:
        m_pDevice->GetStatus(&Flags, &Problem);
        StatusStringId = IDS_DN_ROOT_ENUMERATED;
        NumFlags = NUM_DN_STATUS_FLAGS;
        break;

    case DETAILS_CONFIGFLAGS:
        m_pDevice->GetConfigFlags(&Flags);
        StatusStringId = IDS_CONFIGFLAG_DISABLED;
        NumFlags = NUM_CONFIGFLAGS;
        break;

    case DETAILS_CSCONFIGFLAGS:
        m_pDevice->GetConfigSpecificConfigFlags(&Flags);
        StatusStringId = IDS_CSCONFIGFLAG_DISABLED;
        NumFlags = NUM_CSCONFIGFLAGS;
        break;

    case DETAILS_POWERCAPABILITIES:
        m_pDevice->GetPowerCapabilities(&Flags);
        StatusStringId = IDS_PDCAP_D0_SUPPORTED;
        NumFlags = NUM_POWERCAPABILITIES;
        break;

    default:
        StatusStringId = 0;
        ASSERT(StatusStringId == 0);
        break;
    }

    if (StatusStringId != 0) {
        for (int i = 0; i < NumFlags; i++) {
    
            if (Flags & 1<<i) {
    
                stringDevnodeFlags.LoadString(g_hInstance, StatusStringId + i);
                lv.pszText = (LPTSTR)stringDevnodeFlags;
                ListView_InsertItem(m_hwndDetailsList, &lv);
    
                lv.iItem++;
            }
        }

        ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void
CDeviceDetailsPage::DisplayRelations(
    DWORD RelationType
    )
{
    DWORD FilterFlags = 0;
    ULONG RelationsSize = 0;
    LVITEM lv;
    LPTSTR DeviceIdRelations, CurrDevId;

    switch(RelationType) {
    case DETAILS_EJECTIONRELATIONS:
        FilterFlags = CM_GETIDLIST_FILTER_EJECTRELATIONS;
        break;
    case DETAILS_REMOVALRELATIONS:
        FilterFlags = CM_GETIDLIST_FILTER_REMOVALRELATIONS;
        break;
    case DETAILS_BUSRELATIONS:
        FilterFlags = CM_GETIDLIST_FILTER_BUSRELATIONS;
        break;

    default:
        FilterFlags = 0;
        ASSERT(FilterFlags == 0);
        break;
    }
    
    if (FilterFlags != 0) {
        if ((CM_Get_Device_ID_List_Size_Ex(&RelationsSize,
                                           m_pDevice->GetDeviceID(),
                                           FilterFlags,
                                           m_pDevice->m_pMachine->GetHMachine()
                                           ) == CR_SUCCESS) && 
            (RelationsSize > 2 * sizeof(TCHAR))) {
    
            if ((DeviceIdRelations = (LPTSTR)LocalAlloc(LPTR, RelationsSize * sizeof(TCHAR))) != NULL) {
    
                
                if ((CM_Get_Device_ID_List_Ex(m_pDevice->GetDeviceID(),
                                              DeviceIdRelations,
                                              RelationsSize,
                                              FilterFlags,
                                              m_pDevice->m_pMachine->GetHMachine()
                                              ) == CR_SUCCESS) &&
                (*DeviceIdRelations)) {
    
                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;
    
                    for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {
                    
                        lv.pszText = CurrDevId;
                        ListView_InsertItem(m_hwndDetailsList, &lv);
    
                        lv.iItem++;
                    }

                    ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                }
    
                LocalFree(DeviceIdRelations);
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayMatchingId(
    VOID
    )
{
    HKEY hKey;    
    TCHAR TempBuffer[MAX_PATH];
    ULONG TempBufferLen;
    DWORD regType;
    LVITEM lv;

    //
    // Open drvice's driver registry key to get the MatchingDeviceId string
    //
    hKey = m_pDevice->m_pMachine->DiOpenDevRegKey(*m_pDevice, DICS_FLAG_GLOBAL,
                 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regDrv(hKey);
        TempBufferLen = sizeof(TempBuffer);

        //
        // Get the MatchingDeviceId from the driver key
        //
        if (regDrv.GetValue(REGSTR_VAL_MATCHINGDEVID, 
                            &regType,
                            (PBYTE)TempBuffer,
                            &TempBufferLen) &&
            (TempBufferLen > 2 * sizeof(TCHAR))) {

            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.iItem = 0;
            lv.pszText = TempBuffer;
            ListView_InsertItem(m_hwndDetailsList, &lv);
            ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        }
    }
}

void
CDeviceDetailsPage::CopyToClipboard(
    void
    )
{
    String stringClipboardData;
    TCHAR singleItem[REGSTR_VAL_MAX_HCID_LEN];

    stringClipboardData.Empty();

    //
    // Enumerate through all of the items and add the selected ones to the clipboard.
    //
    for (int index = 0;
         index != -1, index < ListView_GetItemCount(m_hwndDetailsList);
         index ++) {
    
        //
        // If this item is selected then add it to the clipboard.
        //
        if (ListView_GetItemState(m_hwndDetailsList, index, LVIS_SELECTED) & LVIS_SELECTED) {

            ListView_GetItemText(m_hwndDetailsList, index, 0, singleItem, sizeof(singleItem));
            
            if (stringClipboardData.IsEmpty()) {
                stringClipboardData = (LPCTSTR)singleItem;
            } else {
                stringClipboardData += (LPCTSTR)singleItem;
            }
    
            stringClipboardData += (LPCTSTR)TEXT("\r\n");
        }
    }

    if (!stringClipboardData.IsEmpty()) {

        HGLOBAL hMem = GlobalAlloc(GPTR, (stringClipboardData.GetLength() + 1) * sizeof(TCHAR));
        
        if (hMem) {
            
            memcpy(hMem, (LPTSTR)stringClipboardData, (stringClipboardData.GetLength() + 1) * sizeof(TCHAR));

            if (OpenClipboard(m_hDlg)) {
                
                EmptyClipboard();
                SetClipboardData(CF_UNICODETEXT, hMem);
                CloseClipboard();
            } else {
                
                GlobalFree(hMem);
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayClassInstaller(
    VOID
    )
{
    HKEY hKey;    
    TCHAR TempBuffer[MAX_PATH];
    ULONG TempBufferLen;
    DWORD regType;
    LVITEM lv;

    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);

    //
    // Open Classes registry key
    //
    hKey = m_pDevice->m_pMachine->DiOpenClassRegKey(&ClassGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regClass(hKey);
        TempBufferLen = sizeof(TempBuffer);

        //
        // Get the Installer32 from the driver key
        //
        if (regClass.GetValue(REGSTR_VAL_INSTALLER_32, 
                            &regType,
                            (PBYTE)TempBuffer,
                            &TempBufferLen) &&
            (TempBufferLen > 2 * sizeof(TCHAR))) {

            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.iItem = 0;
            lv.pszText = TempBuffer;
            ListView_InsertItem(m_hwndDetailsList, &lv);
            ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        }
    }
}

void
CDeviceDetailsPage::DisplayClassCoInstallers(
    VOID
    )
{
    TCHAR GuidString[MAX_GUID_STRING_LEN];
    DWORD regType, cbSize;
    LVITEM lv;
    CSafeRegistry regCoDeviceInstallers;
    PTSTR coinstallers;

    //
    // Get the string form of the class GUID, because that will be the name of
    // the multi-sz value entry under HKLM\System\CCS\Control\CoDeviceInstallers
    // where class-specific co-installers will be registered
    //
    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);
    if (GuidToString(&ClassGuid, GuidString, ARRAYLEN(GuidString))) {

        if (regCoDeviceInstallers.Open(HKEY_LOCAL_MACHINE, REGSTR_PATH_CODEVICEINSTALLERS)) {

            //
            // Get the size of the coinstaller value
            //
            cbSize = 0;
            if (regCoDeviceInstallers.GetValue(GuidString, &regType, NULL, &cbSize) &&
                (cbSize > (2 * sizeof(TCHAR))) &&
                (regType == REG_MULTI_SZ)) {

                //
                // Allocate memory to hold the coinstaller values.  First we will tack on some extra
                // space at the end of the buffer in case someone forgot to double NULL terminate
                // the multi_sz string.
                //
                coinstallers = (LPTSTR)LocalAlloc(LPTR, (cbSize + (2 * sizeof(TCHAR))));

                if (coinstallers) {

                    if (regCoDeviceInstallers.GetValue(GuidString, 
                                                       &regType,
                                                       (PBYTE)coinstallers, 
                                                       &cbSize
                                                       )) {

                        ZeroMemory(&lv, sizeof(LVITEM));
                        lv.mask = LVIF_TEXT;
                        lv.iItem = 0;

                        for (PTSTR p = coinstallers; *p; p += (lstrlen(p) + 1)) {

                            lv.pszText = p;
                            ListView_InsertItem(m_hwndDetailsList, &lv);

                            lv.iItem++;
                        }

                        ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                    }

                    LocalFree(coinstallers);
                }
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayDeviceCoInstallers(
    VOID
    )
{
    DWORD regType, cbSize;
    LVITEM lv;
    HKEY hKey;
    PTSTR coinstallers;

    //
    // Open drvice's driver registry key to get the Installer32 string
    //
    hKey = m_pDevice->m_pMachine->DiOpenDevRegKey(*m_pDevice, DICS_FLAG_GLOBAL,
                 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regCoDeviceInstallers(hKey);
    
        //
        // Get the size of the coinstaller value
        //
        cbSize = 0;
        if (regCoDeviceInstallers.GetValue(REGSTR_VAL_COINSTALLERS_32, &regType, NULL, &cbSize) &&
            (cbSize > (2 * sizeof(TCHAR))) &&
            (regType == REG_MULTI_SZ)) {

            //
            // Allocate memory to hold the coinstaller values.  First we will tack on some extra
            // space at the end of the buffer in case someone forgot to double NULL terminate
            // the multi_sz string.
            //
            coinstallers = (LPTSTR)LocalAlloc(LPTR, (cbSize + (2 * sizeof(TCHAR))));

            if (coinstallers) {

                if (regCoDeviceInstallers.GetValue(REGSTR_VAL_COINSTALLERS_32, 
                                                   &regType,
                                                   (PBYTE)coinstallers, 
                                                   &cbSize
                                                   )) {

                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;

                    for (PTSTR p = coinstallers; *p; p += (lstrlen(p) + 1)) {

                        lv.pszText = p;
                        ListView_InsertItem(m_hwndDetailsList, &lv);

                        lv.iItem++;
                    }

                    ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                }

                LocalFree(coinstallers);
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayFirmwareRevision(
    VOID
    )
{
    WMIHANDLE   hWmiBlock;
    TCHAR       DevInstId[MAX_DEVICE_ID_LEN + 2];
    LVITEM lv;

    WmiDevInstToInstanceName(DevInstId, ARRAYLEN(DevInstId), (PTCHAR)m_pDevice->GetDeviceID(), 0);

    ULONG Error;
    GUID Guid = DEVICE_UI_FIRMWARE_REVISION_GUID;
    Error = WmiOpenBlock(&Guid, 0, &hWmiBlock);
    
    if (ERROR_SUCCESS == Error) {

        ULONG BufferSize = 0;
        
        Error = WmiQuerySingleInstance(hWmiBlock,
                                       DevInstId,
                                       &BufferSize,
                                       NULL
                                       );

        if (BufferSize && (ERROR_INSUFFICIENT_BUFFER == Error)) {
            
            BYTE* pWmiInstData = new BYTE[BufferSize];

            if (pWmiInstData) {
            
                Error = WmiQuerySingleInstance(hWmiBlock, 
                                               DevInstId,
                                               &BufferSize, 
                                               pWmiInstData
                                               );

                if (ERROR_SUCCESS == Error &&
                    ((PWNODE_SINGLE_INSTANCE)pWmiInstData)->SizeDataBlock) {
    
                    //
                    // The buffer that is returned using the fine UNICODE_STRING format
                    // where the first ULONG is the length of the string and the string
                    // is NOT NULL terminated.
                    //
                    TCHAR FirmwareRevision[MAX_PATH];
                    PTCHAR WmiBuffer = ((LPTSTR)(pWmiInstData + ((PWNODE_SINGLE_INSTANCE)pWmiInstData)->DataBlockOffset));

                    ZeroMemory(FirmwareRevision, MAX_PATH);
                    ULONG Len = *WmiBuffer++;
                    memcpy(FirmwareRevision, WmiBuffer, Len);


                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;
                    lv.pszText = FirmwareRevision;
                    ListView_InsertItem(m_hwndDetailsList, &lv);
                    ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                }

                delete [] pWmiInstData;
            }
        }

        WmiCloseBlock(hWmiBlock);
    }
}

void
CDeviceDetailsPage::DisplayCurrentPowerState(
    VOID
    )
{
    CM_POWER_DATA   CmPowerData;
    ULONG ulSize;
    INT PowerStringId;
    LVITEM lv;
    String stringCurrentPowerState;

    ulSize = sizeof(CmPowerData);
    if (m_pDevice->m_pMachine->CmGetRegistryProperty(m_pDevice->GetDevNode(),
                                                     CM_DRP_DEVICE_POWER_DATA,
                                                     &CmPowerData,
                                                     &ulSize
                                                     ) == CR_SUCCESS) {

        PowerStringId = IDS_POWERSTATE_UNSPECIFIED + CmPowerData.PD_MostRecentPowerState;

        if (CmPowerData.PD_MostRecentPowerState > PowerDeviceD3) {
            PowerStringId = IDS_POWERSTATE_UNSPECIFIED;
        }

        stringCurrentPowerState.LoadString(g_hInstance, PowerStringId);

        ZeroMemory(&lv, sizeof(LVITEM));
        lv.mask = LVIF_TEXT;
        lv.iItem = 0;
        lv.pszText = (LPTSTR)stringCurrentPowerState;
        ListView_InsertItem(m_hwndDetailsList, &lv);
        ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void
CDeviceDetailsPage::DisplayPowerStateMappings(
    VOID
    )
{
    CM_POWER_DATA   CmPowerData;
    ULONG ulSize;
    LVITEM lv;
    INT PowerStringId;
    String stringPowerStateMapping;
    String stringPowerState;

    ulSize = sizeof(CmPowerData);
    if (m_pDevice->m_pMachine->CmGetRegistryProperty(m_pDevice->GetDevNode(),
                                                     CM_DRP_DEVICE_POWER_DATA,
                                                     &CmPowerData,
                                                     &ulSize
                                                     ) == CR_SUCCESS) {
        for (int i=PowerSystemWorking; i<=PowerSystemShutdown; i++) {
            stringPowerStateMapping.Format(TEXT("S%d -> "), (i-1));

            PowerStringId = IDS_POWERSTATE_UNSPECIFIED + CmPowerData.PD_PowerStateMapping[i];

            if (CmPowerData.PD_PowerStateMapping[i] > PowerDeviceD3) {
                PowerStringId = IDS_POWERSTATE_UNSPECIFIED;
            }

            stringPowerState.LoadString(g_hInstance, PowerStringId);

            stringPowerStateMapping+=stringPowerState;

            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.iItem = ListView_GetItemCount(m_hwndDetailsList);
            lv.pszText = (LPTSTR)stringPowerStateMapping;
            ListView_InsertItem(m_hwndDetailsList, &lv);
        }

        ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void
CDeviceDetailsPage::DisplayClassFilters(
    DWORD ClassFilter
    )
{
    HKEY hKey;    
    ULONG BufferLen;
    DWORD regType;
    LVITEM lv;

    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);

    //
    // Open Classes registry key
    //
    hKey = m_pDevice->m_pMachine->DiOpenClassRegKey(&ClassGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regClass(hKey);

        //
        // Determine how much space we need.
        //
        BufferLen = 0;
        regClass.GetValue((ClassFilter == DETAILS_CLASSLOWERFILTERS)
                            ? REGSTR_VAL_LOWERFILTERS
                            : REGSTR_VAL_UPPERFILTERS, 
                          &regType,
                          NULL,
                          &BufferLen);

        if (BufferLen != 0) {

            PBYTE Buffer = new BYTE[BufferLen + (2 * sizeof(TCHAR))];            

            if (Buffer) {
                ZeroMemory(Buffer, BufferLen + (2 * sizeof(TCHAR)));

                if (regClass.GetValue((ClassFilter == DETAILS_CLASSLOWERFILTERS)
                                        ? REGSTR_VAL_LOWERFILTERS
                                        : REGSTR_VAL_UPPERFILTERS,
                                      &regType,
                                      (PBYTE)Buffer,
                                      &BufferLen)) {

                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;

                    for (PTSTR SingleItem = (PTSTR)Buffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {

                        lv.pszText = SingleItem;
                        ListView_InsertItem(m_hwndDetailsList, &lv);

                        lv.iItem++;
                    }

                    ListView_SetItemState(m_hwndDetailsList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                }

                delete [] Buffer;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devdrvpg.h ===
// devdrvpg.h : header file
//

#ifndef __DEVDRVPG_H__
#define __DEVDRVPG_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    devdrvpg.h

Abstract:

    header file for devdrvpg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"

//
// help topic ids
//
#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_driver_copyright     106130  // Driver: "" (Static)
#define idh_devmgr_devdrv_details       400400  // Driver: "Driver Details..." (Button)
#define idh_devmgr_driver_change_driver 106140  // Driver: "&Change Driver..." (Button)
#define	idh_devmgr_rollback_button	    106129  // Driver: "Roll Back Driver..." (Button)
#define idh_devmgr_devdrv_uninstall     400500  // Driver: "&Uninstall" (Button)
#define idh_devmgr_driver_driver_files  106100  // Driver: "" (ListBox)
#define idh_devmgr_driver_provider      106110  // Driver: "" (Static)
#define idh_devmgr_driver_file_version  106120  // Driver: "" (Static)
#define idh_devmgr_driver_provider_main 106122  // Driver tab static
#define idh_devmgr_driver_date_main     106124  // Driver tab static
#define idh_devmgr_driver_version_main  106126  // Driver tab static
#define idh_devmgr_digital_signer       106127  // Driver tab static- digital signer



class CDeviceDriverPage : public CPropSheetPage
{
public:
    CDeviceDriverPage() :
        m_pDriver(NULL), m_pDevice(NULL), m_hwndDigitalSignerTip(NULL),
        CPropSheetPage(g_hInstance, IDD_DEVDRV_PAGE)
        {}

    ~CDeviceDriverPage();
    HPROPSHEETPAGE Create(CDevice* pDevice)
    {
        ASSERT(pDevice);
        m_pDevice = pDevice;
        
        // override PROPSHEETPAGE structure here...
        m_psp.lParam = (LPARAM)this;
        return CreatePage();
    }
    BOOL UpdateDriver(CDevice* pDevice, 
                      HWND hDlg,
                      BOOL *pfChanged = NULL,
                      DWORD *pdwReboot = NULL
                      );
    BOOL RollbackDriver(CDevice* pDevice, 
                        HWND hDlg,
                        BOOL *pfChanged = NULL,
                        DWORD *pdwReboot = NULL
                        );
    BOOL UninstallDrivers(CDevice* pDevice, 
                          HWND hDlg
                          );

protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    BOOL LaunchTroubleShooter(CDevice* pDevice, HWND hDlg, BOOL *pfChanged);

private:
    void InitializeDriver();
    CDriver*    m_pDriver;
    CDevice*    m_pDevice;
    HWND        m_hwndDigitalSignerTip;
};

/////////////////////////////////////////////////////////////////////////////
// CDriverFilesDlg dialog

class CDriverFilesDlg : public CDialog
{
public:
    CDriverFilesDlg(CDevice* pDevice, CDriver* pDriver)
        : CDialog(IDD_DRIVERFILES),
          m_pDriver(pDriver), 
          m_pDevice(pDevice),
          m_ImageList(NULL)
        {}
    virtual BOOL OnInitDialog();
    virtual void OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(LPNMHDR pnmhdr);
    virtual BOOL OnDestroy();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);

private:
    void ShowCurDriverFileDetail();
    void LaunchHelpForBlockedDriver();
    CDriver*    m_pDriver;
    CDevice*    m_pDevice;
    HIMAGELIST  m_ImageList;
};


#endif // _DEVDRVPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devdrvpg.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    devdrvpg.cpp

Abstract:

    This module implements CDeviceDriverPage -- device driver property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// devdrvpg.cpp : implementation file
//

#include "devmgr.h"
#include "devdrvpg.h"
#include "cdriver.h"
#include "tswizard.h"
#include "devrmdlg.h"

//
// help topic ids
//
const DWORD g_a106HelpIDs[]=
{
    IDC_DEVDRV_ICON,                    IDH_DISABLEHELP,                    // Driver: "" (Static)
    IDC_DEVDRV_DESC,                    IDH_DISABLEHELP,                    // Driver: "" (Static)
    IDC_DEVDRV_TITLE_DRIVERPROVIDER,    idh_devmgr_driver_provider_main,
    IDC_DEVDRV_DRIVERPROVIDER,          idh_devmgr_driver_provider_main,
    IDC_DEVDRV_TITLE_DRIVERDATE,        idh_devmgr_driver_date_main,
    IDC_DEVDRV_DRIVERDATE,              idh_devmgr_driver_date_main,
    IDC_DEVDRV_TITLE_DRIVERVERSION,     idh_devmgr_driver_version_main,
    IDC_DEVDRV_DRIVERVERSION,           idh_devmgr_driver_version_main,
    IDC_DEVDRV_TITLE_DRIVERSIGNER,      idh_devmgr_digital_signer,
    IDC_DEVDRV_DRIVERSIGNER,            idh_devmgr_digital_signer,
    IDC_DEVDRV_DETAILS,                 idh_devmgr_devdrv_details,          // Driver: "Driver Details" (Button)
    IDC_DEVDRV_DETAILS_TEXT,            idh_devmgr_devdrv_details,          // Driver: "Driver Details" (Button)
    IDC_DEVDRV_UNINSTALL,               idh_devmgr_devdrv_uninstall,        // Driver: "Uninstall" (Button)
    IDC_DEVDRV_UNINSTALL_TEXT,          idh_devmgr_devdrv_uninstall,        // Driver: "Uninstall" (Button)
    IDC_DEVDRV_CHANGEDRIVER,            idh_devmgr_driver_change_driver,    // Driver: "&Change Driver..." (Button)
    IDC_DEVDRV_CHANGEDRIVER_TEXT,       idh_devmgr_driver_change_driver,    // Driver: "&Change Driver..." (Button)
    IDC_DEVDRV_ROLLBACK,                idh_devmgr_rollback_button,         // Driver: "Roll Back Driver..." (Button)
    IDC_DEVDRV_ROLLBACK_TEXT,           idh_devmgr_rollback_button,         // Driver: "Roll Back Driver..." (Button)
    0, 0
};

CDeviceDriverPage::~CDeviceDriverPage()
{
    if (m_pDriver) {

        delete m_pDriver;
    }
}

BOOL
CDeviceDriverPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    if (BN_CLICKED == HIWORD(wParam)) {

        switch (LOWORD(wParam)) {

        case IDC_DEVDRV_DETAILS:
        {
            //
            // We first need to call CDriver::BuildDriverList to build up a list
            // of drivers for this device.  This can take some time so we will put
            // up the busy cursor.
            //
            HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

            CDriver* pDriver;
            pDriver = m_pDevice->CreateDriver();

            if (pDriver) {
            
                pDriver->BuildDriverList();

                SetCursor(hCursorOld);

                //
                // Show driver file details
                //
                if (pDriver->GetCount() > 0) {
                

                    if (pDriver) {
                    
                        CDriverFilesDlg DriverFilesDlg(m_pDevice, pDriver);
                        DriverFilesDlg.DoModal(m_hDlg, (LPARAM)&DriverFilesDlg);
                    }

                } else {

                    //
                    // No driver files are loaded for this device
                    //
                    String strNoDrivers;
                    strNoDrivers.LoadString(g_hInstance, IDS_DEVDRV_NODRIVERFILE);
                    MessageBox(m_hDlg, strNoDrivers, m_pDevice->GetDisplayName(), MB_OK);
                    return FALSE;
                }

                delete pDriver;
                pDriver = NULL;
            }

            break;
        }


        case IDC_DEVDRV_UNINSTALL:
        {
            BOOL Refresh = (m_pDevice->IsPhantom() || 
                            m_pDevice->HasProblem() ||
                            !m_pDevice->IsStarted());

            if (UninstallDrivers(m_pDevice, m_hDlg)) {

                //
                // Enable refresh since we disabled it in the beginning.
                //
                // We only need to force a refresh here if the device that
                // was removed was a Phantom device.  This is because Phantom
                // devices don't have kernel mode devnodes and so they won't
                // generate a WM_DEVICECHANGE like live devnodes will.
                //
                if (Refresh) {

                    m_pDevice->m_pMachine->ScheduleRefresh();
                }

                ::DestroyWindow(GetParent(m_hDlg));
            }

            break;
        }

        case IDC_DEVDRV_CHANGEDRIVER:
        {
            BOOL fChanged;
            DWORD Reboot = 0;

            if (UpdateDriver(m_pDevice, m_hDlg, &fChanged, &Reboot) && fChanged) {

                //
                // ISSUE: JasonC 2/7/00
                //
                // A refresh on m_pDevice->m_pMachine is necessary here.
                // Since we are running on a different thread and each
                // property page may have cached the HDEVINFO and the
                // SP_DEVINFO_DATA, refresh on the CMachine object can not
                // be done here. The problem is worsen by the fact that
                // user can go back to the device tree and work on the tree
                // while this property sheet is still up.
                // It would be nice if MMC would support modal dialog boxes! 
                //
                m_pDevice->PropertyChanged();
                m_pDevice->GetClass()->PropertyChanged();
                m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
                UpdateControls();
                PropSheet_SetTitle(GetParent(m_hDlg), PSH_PROPTITLE, m_pDevice->GetDisplayName());
                PropSheet_CancelToClose(GetParent(m_hDlg));

                if (Reboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
                
                    m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_NEEDREBOOT);
                }
            }

            break;
        }

        case IDC_DEVDRV_ROLLBACK:
        {
            BOOL fChanged;
            DWORD Reboot = 0;

            if (RollbackDriver(m_pDevice, m_hDlg, &fChanged, &Reboot) && fChanged) {

                //
                // ISSUE: JasonC 2/7/00
                //
                // A refresh on m_pDevice->m_pMachine is necessary here.
                // Since we are running on a different thread and each
                // property page may have cached the HDEVINFO and the
                // SP_DEVINFO_DATA, refresh on the CMachine object can not
                // be done here. The problem is worsen by the fact that
                // user can go back to the device tree and work on the tree
                // while this property sheet is still up.
                // It would be nice if MMC would support modal dialog boxes! 
                //
                m_pDevice->PropertyChanged();
                m_pDevice->GetClass()->PropertyChanged();
                m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
                UpdateControls();
                PropSheet_SetTitle(GetParent(m_hDlg), PSH_PROPTITLE, m_pDevice->GetDisplayName());
                PropSheet_CancelToClose(GetParent(m_hDlg));

                if (Reboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {

                    m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_NEEDREBOOT);
                }
            }

            break;
        }

        default:
            break;
        }
    }

    return FALSE;
}

//
// This function uninstalls the drivers for the given device
// INPUT:
//  pDevice -- the object represent the device
//  hDlg    -- the property page window handle
//
// OUTPUT:
//  TRUE    -- function succeeded.
//  FALSE   -- function failed.
//
BOOL
CDeviceDriverPage::UninstallDrivers(
    CDevice* pDevice,
    HWND hDlg
    )
{
    BOOL Return = FALSE;
    CMachine *pMachine;

    if (pDevice->m_pMachine->m_ParentMachine) {
        pMachine = pDevice->m_pMachine->m_ParentMachine;
    } else {
        pMachine = pDevice->m_pMachine;
    }

    if(!pDevice->m_pMachine->IsLocal() || !g_IsAdmin) {
        //
        // Must be an admin and on the local machine to remove a device.
        //
        return FALSE;
    }

    BOOL Refresh = (pDevice->IsPhantom() || 
                    pDevice->HasProblem() || 
                    !pDevice->IsStarted());

    pMachine->EnableRefresh(FALSE);
    
    CRemoveDevDlg   TheDlg(pDevice);

    if (IDOK == TheDlg.DoModal(hDlg, (LPARAM) &TheDlg)) {

        DWORD DiFlags;
        DiFlags = pDevice->m_pMachine->DiGetFlags(*pDevice);
        
        //
        // First try and send a MMCPropertyChangeNotify message to our
        // CComponent so that it can prompt for a reboot inside the 
        // device manager thread instead of our thread.  If this is not 
        // done then the property sheet will hang around after device
        // manager has gone away...which will cause a "hung app" dialog
        // to appear.
        //
        // Note: In this case we pass NULL as the Window handle since 
        // uninstalling will cause the property sheet to go away.
        //
        CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(NULL, DiFlags, IDS_REMOVEDEV_RESTART);

        if (pNRR) {
            if (!m_pDevice->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                //
                // There isn't a CComponent around, so this is just a property
                // sheet running outside of MMC.
                //
                pNRR->Release();
                PromptForRestart(hDlg, DiFlags, IDS_REMOVEDEV_RESTART);
            }
        } else {
            //
            // We couldn't allocate memory to create our CNotifyRebootRequest
            // instance, so just prompt for a reboot in this thread.
            //
            PromptForRestart(hDlg, DiFlags, IDS_REMOVEDEV_RESTART);
        }

        if (Refresh) {
            pMachine->ScheduleRefresh();
        }
        
        Return = TRUE;
    }

    pMachine->EnableRefresh(TRUE);

    return Return;
}

BOOL
CDeviceDriverPage::LaunchTroubleShooter(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfChanged
    )
{
    BOOL fChanged = FALSE;
    DWORD Status, Problem = 0;
    CProblemAgent*  ProblemAgent;
    
    if (pDevice->GetStatus(&Status, &Problem) || pDevice->IsPhantom())
    {
        //
        // if the device is a phantom device, use the CM_PROB_DEVICE_NOT_THERE
        //
        if (pDevice->IsPhantom())
        {
            Problem = CM_PROB_DEVICE_NOT_THERE;
            Status = DN_HAS_PROBLEM;
        }

        //
        // if the device is not started and no problem is assigned to it
        // fake the problem number to be failed start.
        //
        if (!(Status & DN_STARTED) && !Problem && pDevice->IsRAW())
        {
            Problem = CM_PROB_FAILED_START;
        }
    }

    ProblemAgent = new CProblemAgent(pDevice, Problem, FALSE);

    if (ProblemAgent) {
    
        fChanged = ProblemAgent->FixIt(GetParent(hDlg));

        delete ProblemAgent;
    }

    if (pfChanged) {

        *pfChanged = fChanged;
    }

    return TRUE;
}

//
// This function updates drivers for the given device
// INPUT:
//  pDevice -- the object represent the device
//  hDlg    -- the property page window handle
//  pfChanged   -- optional buffer to receive if driver changes
//                 have occured.
// OUTPUT:
//  TRUE    -- function succeeded.
//  FALSE   -- function failed.
//
BOOL
CDeviceDriverPage::RollbackDriver(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfChanged,
    DWORD *pdwReboot
    )
{
    HCURSOR hCursorOld;
    BOOL RollbackSuccessful = FALSE;
    DWORD RollbackError = ERROR_CANCELLED;
    DWORD Status = 0, Problem = 0;

    //
    // Verify that the process has Admin credentials and that we are running on the local
    // machine.
    //
    if (!pDevice || !pDevice->m_pMachine->IsLocal() || !g_IsAdmin) {

        ASSERT(FALSE);
        return FALSE;
    }

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    //
    // If the device has the DN_WILL_BE_REMOVED flag set and the user is
    // attempting to roll back the driver then we will prompt them for a 
    // reboot and include text in the prompt that explains this device
    // is in the process of being removed.
    //
    if (pDevice->GetStatus(&Status, &Problem) &&
        (Status & DN_WILL_BE_REMOVED)) {

        //
        // First try and send a MMCPropertyChangeNotify message to our
        // CComponent so that it can prompt for a reboot inside the 
        // device manager thread instead of our thread.  If this is not 
        // done then the property sheet will hang around after device
        // manager has gone away...which will cause a "hung app" dialog
        // to appear.
        //
        CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_ROLLBACK_DRIVER);

        if (pNRR) {
            if (!m_pDevice->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                //
                // There isn't a CComponent around, so this is just a property
                // sheet running outside of MMC.
                //
                pNRR->Release();
                PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_ROLLBACK_DRIVER);
            }
        } else {
            //
            // We couldn't allocate memory to create our CNotifyRebootRequest
            // instance, so just prompt for a reboot in this thread.
            //
            PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_ROLLBACK_DRIVER);
        }

        return FALSE;
    }

    //
    // First check to see if there are any drivers to Rollback
    //
    CSafeRegistry regRollback;
    TCHAR RollbackSubkeyName[MAX_PATH + 1];
    TCHAR ReinstallString[MAX_PATH];        
    BOOL bFoundMatch = FALSE;
    int index = 0;

    ReinstallString[0] = TEXT('\0');
    RollbackSubkeyName[0] = TEXT('\0');

    if (regRollback.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall"))) {

        DWORD SubkeySize = ARRAYLEN(RollbackSubkeyName);
        
        while (!bFoundMatch && regRollback.EnumerateSubkey(index, RollbackSubkeyName, &SubkeySize)) {

            CSafeRegistry regRollbackSubkey;

            if (regRollbackSubkey.Open(regRollback, RollbackSubkeyName)) {

                DWORD regType, cbSize;
                LPTSTR DeviceInstanceIds;

                cbSize = 0;

                if (regRollbackSubkey.GetValue(TEXT("DeviceInstanceIds"), &regType, NULL, &cbSize)) {

                    //
                    // Allocate memory to hold the DeviceInstanceIds
                    //
                    DeviceInstanceIds = (LPTSTR)LocalAlloc(LPTR, cbSize);

                    if (DeviceInstanceIds) {

                        ZeroMemory(DeviceInstanceIds, cbSize);

                        if (regRollbackSubkey.GetValue(TEXT("DeviceInstanceIds"), &regType,
                                                       (PBYTE)DeviceInstanceIds, &cbSize)) {
                    
                        
                            //
                            // Compare the list of DeviceInstanceIds in this registry key with this
                            // devices DeviceInstanceId
                            //
                            for (LPTSTR p = DeviceInstanceIds; *p; p += (lstrlen(p) + 1)) {
        
                                if (pDevice->GetDeviceID() && !lstrcmpi(p, pDevice->GetDeviceID())) {
        
                                    bFoundMatch = TRUE;

                                    cbSize = sizeof(ReinstallString);
                                    regRollbackSubkey.GetValue(TEXT("ReinstallString"), &regType, 
                                                               (PBYTE)ReinstallString, &cbSize);
                                    
                                    break;
                                }
                            }
                        }

                        LocalFree(DeviceInstanceIds);
                    }
                }
            }

            SubkeySize = ARRAYLEN(RollbackSubkeyName);
            index++;
        }
    }

    if (bFoundMatch) {

        //
        // Check the ReinstallString path to verify that a backup directory actually exists.
        // We first need to strip the INF name off of the end of the path.
        //
        PTSTR p;

        //
        // Assume that the directory does NOT exist
        //
        bFoundMatch = FALSE;

        if (ReinstallString[0] != TEXT('\0')) {
        
            p = StrRChr(ReinstallString, NULL, TEXT('\\'));
    
            if (p) {
    
                *p = 0;
            
                WIN32_FIND_DATA findData;
                HANDLE FindHandle;
                UINT OldMode;

                OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                FindHandle = FindFirstFile(ReinstallString, &findData);

                if(FindHandle != INVALID_HANDLE_VALUE) {

                    FindClose(FindHandle);
                    bFoundMatch = TRUE;
                
                } else {

                    //
                    // The directory does not exist.  Make sure we clean out the registry key
                    //
                    regRollback.DeleteSubkey(RollbackSubkeyName);
                }

                SetErrorMode(OldMode);
            }
        }
    }

    if (bFoundMatch) {

        //
        // We found a match, lets ask the user if they want to rollback the drivers
        //
        String strYesRollback;
        strYesRollback.LoadString(g_hInstance, IDS_DEVDRV_YESROLLBACK);
        
        if (MessageBox(hDlg, strYesRollback, pDevice->GetDisplayName(), MB_YESNO) == IDYES) {

            RollbackSuccessful = pDevice->m_pMachine->RollbackDriver(hDlg, RollbackSubkeyName, 0x3, pdwReboot);

            if (!RollbackSuccessful) {
            
                RollbackError = GetLastError();
            }
        }
    
    } else {

        //
        // We could not find a drivers backup for this device.  Lets ask the user if they want
        // to start the troubleshooter.
        //
        String strNoRollback;
        strNoRollback.LoadString(g_hInstance, IDS_DEVDRV_NOROLLBACK);
        
        if (MessageBox(hDlg, strNoRollback, pDevice->GetDisplayName(), MB_YESNO) == IDYES) {

            LaunchTroubleShooter(pDevice, hDlg, pfChanged);
        }
    }
    
    if (hCursorOld) {

        SetCursor(hCursorOld);
    }

    //
    // We will assume that something changed when we called InstallDevInst()
    // unless it returned FALSE and GetLastError() == ERROR_CANCELLED
    //
    if (pfChanged) {

        *pfChanged = TRUE;

        if (!bFoundMatch || (!RollbackSuccessful && (ERROR_CANCELLED == RollbackError))) {

            *pfChanged = FALSE;
        }
    }

    return TRUE;
}

//
// This function updates drivers for the given device
// INPUT:
//  pDevice -- the object represent the device
//  hDlg    -- the property page window handle
//  pfChanged   -- optional buffer to receive if driver changes
//                 have occured.
// OUTPUT:
//  TRUE    -- function succeeded.
//  FALSE   -- function failed.
//
BOOL
CDeviceDriverPage::UpdateDriver(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfChanged,
    DWORD *pdwReboot
    )
{
    BOOL Installed = FALSE;
    DWORD InstallError = ERROR_SUCCESS;
    DWORD Status = 0, Problem = 0;

    //
    // Must be an admin and on the local machine to update a device.
    //
    if (!pDevice || !pDevice->m_pMachine->IsLocal() || !g_IsAdmin) {

        ASSERT(FALSE);
        return FALSE;
    }

    //
    // If the device has the DN_WILL_BE_REMOVED flag set and the user is
    // attempting to update the driver then we will prompt them for a 
    // reboot and include text in the prompt that explains this device
    // is in the process of being removed.
    //
    if (pDevice->GetStatus(&Status, &Problem) &&
        (Status & DN_WILL_BE_REMOVED)) {

        //
        // First try and send a MMCPropertyChangeNotify message to our
        // CComponent so that it can prompt for a reboot inside the 
        // device manager thread instead of our thread.  If this is not 
        // done then the property sheet will hang around after device
        // manager has gone away...which will cause a "hung app" dialog
        // to appear.
        //
        CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);

        if (pNRR) {
            if (!m_pDevice->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                //
                // There isn't a CComponent around, so this is just a property
                // sheet running outside of MMC.
                //
                pNRR->Release();
                PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
            }
        } else {
            //
            // We couldn't allocate memory to create our CNotifyRebootRequest
            // instance, so just prompt for a reboot in this thread.
            //
            PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
        }

        return FALSE;
    }

    Installed = pDevice->m_pMachine->InstallDevInst(hDlg, pDevice->GetDeviceID(), TRUE, pdwReboot);

    if (!Installed) {

        InstallError = GetLastError();
    }

    //
    // We will assume that something changed when we called InstallDevInst()
    // unless it returned FALSE and GetLastError() == ERROR_CANCELLED
    //
    if (pfChanged) {

        *pfChanged = TRUE;

        if (!Installed && (ERROR_CANCELLED == InstallError)) {
            *pfChanged = FALSE;
        }
    }

    return TRUE;
}

void
CDeviceDriverPage::InitializeDriver()
{
    if (m_pDriver) {
        delete m_pDriver;
        m_pDriver = NULL;
    }

    m_pDriver = m_pDevice->CreateDriver();
}

void
CDeviceDriverPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam) {

        m_pDevice = (CDevice*) lParam;
    }

    try {
        //
        // Calling PropertyChanged() will update the display name for the device.  We need
        // to do this in case a 3rd party property sheet did something that could change
        // the device's display name.
        //
        m_pDevice->PropertyChanged();

        //
        // If we are not running locally then don't bother showing the driver
        // details since we can't get a list of the drivers and we can't get
        // any information about the driver.
        //
        if (!m_pDevice->m_pMachine->IsLocal()) {
            
            ::EnableWindow(GetControl(IDC_DEVDRV_DETAILS), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_DETAILS_TEXT), FALSE);
        }

        //
        // can not change driver on remote machine or the user
        // has no Administrator privilege.
        //
        if (!m_pDevice->m_pMachine->IsLocal() || !g_IsAdmin) {

            ::EnableWindow(GetControl(IDC_DEVDRV_CHANGEDRIVER), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_CHANGEDRIVER_TEXT), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_ROLLBACK), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_ROLLBACK_TEXT), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL_TEXT), FALSE);
        }

        //
        // Hide the uninstall button if the device cannot be uninstalled
        //
        else if (!m_pDevice->IsUninstallable()) {

            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL_TEXT), FALSE);
        }

        HICON hIconOld;
        m_IDCicon = IDC_DEVDRV_ICON;    // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVDRV_ICON, STM_SETICON,
                        (WPARAM)(m_pDevice->LoadClassIcon()),
                        0
                        );

        if (hIconOld) {
            DestroyIcon(hIconOld);
        }

        InitializeDriver();

        SetDlgItemText(m_hDlg, IDC_DEVDRV_DESC, m_pDevice->GetDisplayName());

        String strDriverProvider, strDriverDate, strDriverVersion, strDriverSigner;
        m_pDevice->GetProviderString(strDriverProvider);
        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERPROVIDER, strDriverProvider);
        m_pDevice->GetDriverDateString(strDriverDate);
        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERDATE, strDriverDate);
        m_pDevice->GetDriverVersionString(strDriverVersion);
        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERVERSION, strDriverVersion);
        
        if (m_pDriver) {
            m_pDriver->GetDriverSignerString(strDriverSigner);
        }
        
        //
        // If we could not get a digital signature string or then just display 
        // Unknown for the Digital Signer.
        //
        if (strDriverSigner.IsEmpty()) {
            strDriverSigner.LoadString(g_hInstance, IDS_UNKNOWN);
        }

        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERSIGNER, strDriverSigner);
        AddToolTips(m_hDlg, IDC_DEVDRV_DRIVERSIGNER, (LPTSTR)strDriverSigner, &m_hwndDigitalSignerTip);
    }

    catch (CMemoryException* e) {

        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDeviceDriverPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a106HelpIDs);

    return FALSE;
}


BOOL
CDeviceDriverPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
        (ULONG_PTR)g_a106HelpIDs);

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Driver Files
//
const DWORD g_a110HelpIDs[]=
{
    IDC_DRIVERFILES_ICON,           IDH_DISABLEHELP,                // Driver: "" (Icon)
    IDC_DRIVERFILES_DESC,           IDH_DISABLEHELP,                // Driver: "" (Static)
    IDC_DRIVERFILES_FILES,          IDH_DISABLEHELP,                // Driver: "Provider:" (Static)
    IDC_DRIVERFILES_FILELIST,       idh_devmgr_driver_driver_files, // Driver: "" (ListBox)
    IDC_DRIVERFILES_TITLE_PROVIDER, idh_devmgr_driver_provider,     // Driver: "Provider:" (Static)
    IDC_DRIVERFILES_PROVIDER,       idh_devmgr_driver_provider,     // Driver: "" (Static)
    IDC_DRIVERFILES_TITLE_COPYRIGHT,idh_devmgr_driver_copyright,    // Driver: "Copyright:" (Static)
    IDC_DRIVERFILES_COPYRIGHT,      idh_devmgr_driver_copyright,    // Driver: "" (Static)
    IDC_DRIVERFILES_TITLE_DIGITALSIGNER, IDH_DISABLEHELP,
    IDC_DRIVERFILES_DIGITALSIGNER,  IDH_DISABLEHELP,
    IDC_DRIVERFILES_TITLE_VERSION,  idh_devmgr_driver_file_version, // Driver: "Version:" (Static)
    IDC_DRIVERFILES_VERSION,        idh_devmgr_driver_file_version, // Driver: "File Version:" (Static)
    0, 0
};

BOOL CDriverFilesDlg::OnInitDialog()
{
    int SignedIndex = 0, BlankIndex = 0, DriverBlockIndex = 0, CertIndex = 0;

    try {

        HICON hIcon;
        hIcon = (HICON)SendDlgItemMessage(m_hDlg, IDC_DRIVERFILES_ICON, STM_SETICON,
                                             (WPARAM)(m_pDevice->LoadClassIcon()), 0);

        if (hIcon) {
        
            DestroyIcon(hIcon);
        }

        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DESC, m_pDevice->GetDisplayName());

        //
        // Create the ImageList that contains the signed and blank images.
        //
        // NOTE: On BiDi builds we need to set the ILC_MIRROR flag so that the
        // signed/unsigned icons are not mirrored.
        //
        m_ImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                       GetSystemMetrics(SM_CYSMICON),
                                       ILC_MASK |
                                       ((GetWindowLong(GetParent(m_hDlg), GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                                         ? ILC_MIRROR
                                         : 0),
                                       1,
                                       1
                                       );   

        if (m_ImageList) {
        
            ImageList_SetBkColor(m_ImageList, GetSysColor(COLOR_WINDOW));
            
            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {
            
                BlankIndex =  ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }
    
            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SIGNED))) != NULL) {
            
                SignedIndex = ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }

            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_CERT))) != NULL) {
            
                CertIndex = ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }

            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DRIVERBLOCK))) != NULL) {
            
                DriverBlockIndex = ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }
        }

        //
        //Initialize the list of drivers
        //
        LV_COLUMN lvcCol;
        LV_ITEM lviItem;
        CDriverFile* pDrvFile;
        PVOID Context;
        HWND hwndFileList = GetDlgItem(m_hDlg, IDC_DRIVERFILES_FILELIST);

        //
        // Insert a single column for this list.
        //
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(hwndFileList, 0, (LV_COLUMN FAR *)&lvcCol);

        ListView_SetExtendedListViewStyle(hwndFileList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        if (m_ImageList) {

            ListView_SetImageList(hwndFileList, m_ImageList, LVSIL_SMALL);
        }

        ListView_DeleteAllItems(hwndFileList);

        if (m_pDriver && m_pDriver->GetFirstDriverFile(&pDrvFile, Context)) {

            do {

                ASSERT(pDrvFile);
                LPCTSTR pFullPathName;
                pFullPathName = pDrvFile->GetFullPathName();
                if (pFullPathName) {

                    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                    lviItem.iSubItem = 0;
                    lviItem.lParam = (LPARAM)pDrvFile;
                    lviItem.iItem = ListView_GetItemCount(hwndFileList);
                    lviItem.pszText = (LPTSTR)pFullPathName;

                    if (m_ImageList) {

                        if (pDrvFile->IsDriverBlocked()) {
                            //
                            // The driver is blocked
                            //
                            lviItem.iImage = DriverBlockIndex;
                        } else if (pDrvFile->GetWin32Error() == NO_ERROR) {
                            //
                            // The driver is WHQL signed. 
                            //
                            lviItem.iImage = SignedIndex;
                        } else if ((pDrvFile->GetWin32Error() == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                                  (pDrvFile->GetWin32Error() == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                            //
                            // The driver is Authenticode signed.
                            //
                            lviItem.iImage = CertIndex;
                        } else {
                            //
                            // The driver is NOT blocked and NOT signed.
                            //
                            lviItem.iImage = BlankIndex;
                        }
                    }

                    ListView_InsertItem(hwndFileList, &lviItem);
                }

            } while (m_pDriver->GetNextDriverFile(&pDrvFile, Context));

            if (ListView_GetItemCount(hwndFileList) >= 1) {

                ListView_SetItemState(hwndFileList,
                                      0,
                                      LVIS_SELECTED | LVIS_FOCUSED,
                                      LVIS_SELECTED | LVIS_FOCUSED
                                      );
                ListView_EnsureVisible(hwndFileList, 0, FALSE);
                ListView_SetColumnWidth(hwndFileList, 0, LVSCW_AUTOSIZE_USEHEADER);

                ShowCurDriverFileDetail();

            } else {

                //
                // nothing on the driver file list, disable it
                //
                ::EnableWindow(GetControl(IDC_DRIVERFILES_FILELIST), FALSE);
            }
        }
    }

    catch (CMemoryException* e) {

        e->Delete();
        return FALSE;
    }

    return TRUE;
}

void
CDriverFilesDlg::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    if (BN_CLICKED == HIWORD(wParam)) {

        if (IDOK == LOWORD(wParam)) {

            EndDialog(m_hDlg, IDOK);

        } else if (IDCANCEL == LOWORD(wParam)) {

            EndDialog(m_hDlg, IDCANCEL);
        }
    }
}

BOOL 
CDriverFilesDlg::OnNotify(
    LPNMHDR pnmhdr
    )
{
    switch (pnmhdr->code) {
    case LVN_ITEMCHANGED:
        ShowCurDriverFileDetail();
        break;

    case NM_RETURN:
    case NM_CLICK:
        if (pnmhdr->idFrom == IDS_DRIVERFILES_BLOCKDRIVERLINK) {
            LaunchHelpForBlockedDriver();
        }
        break;
    }

    return FALSE;
}

BOOL
CDriverFilesDlg::OnDestroy()
{
    HICON hIcon;

    hIcon = (HICON)SendDlgItemMessage(m_hDlg, IDC_DRIVERFILES_ICON, STM_GETICON, 0, 0);

    if (hIcon) {
        DestroyIcon(hIcon);
    }

    if (m_ImageList) {
        ImageList_Destroy(m_ImageList);
    }
    return FALSE;
}

BOOL
CDriverFilesDlg::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a110HelpIDs);
    return FALSE;
}


BOOL
CDriverFilesDlg::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a110HelpIDs);

    return FALSE;
}

void
CDriverFilesDlg::ShowCurDriverFileDetail()
{
    HWND hwndFileList = GetDlgItem(m_hDlg, IDC_DRIVERFILES_FILELIST);
    LVITEM lvItem;
    LPCTSTR  pString;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem = ListView_GetNextItem(hwndFileList,
                                        -1,
                                        LVNI_SELECTED
                                        );

    if (lvItem.iItem != -1) {

        try {
        
            ListView_GetItem(hwndFileList, &lvItem);

            CDriverFile* pDrvFile = (CDriverFile*)lvItem.lParam;
    
            ASSERT(pDrvFile);
    
            TCHAR TempString[LINE_LEN];
            LPCTSTR pFullPathName;
            pFullPathName = pDrvFile->GetFullPathName();
    
            if (!pFullPathName || (pDrvFile->GetAttributes() == 0xFFFFFFFF)) {
    
                //
                // This is the case when the file is not present on the system
                //
                LoadResourceString(IDS_NOT_PRESENT, TempString, ARRAYLEN(TempString));
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, TempString);
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, TempString);
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, TempString);
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DIGITALSIGNER, TempString);
                ShowWindow(GetControl(IDS_DRIVERFILES_BLOCKDRIVERLINK), FALSE);

            } else { 
                if (!pDrvFile->HasVersionInfo()) {
                    //
                    // This is the case when the file is present but it does not have
                    // version information.
                    //
                    LoadResourceString(IDS_UNKNOWN, TempString, ARRAYLEN(TempString));
                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, TempString);
                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, TempString);
                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, TempString);
                } else {
                    //
                    // Show the file version information.
                    //
                    TempString[0] = _T('\0');

                    pString = pDrvFile->GetVersion();
                    if (!pString && _T('\0') == TempString[0]) {

                        LoadResourceString(IDS_NOT_AVAILABLE, TempString, ARRAYLEN(TempString));
                        pString = TempString;
                    }

                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, (LPTSTR)pString);

                    pString = pDrvFile->GetProvider();
                    if (!pString && _T('\0') == TempString[0]) {

                        LoadResourceString(IDS_NOT_AVAILABLE, TempString, ARRAYLEN(TempString));
                        pString = TempString;
                    }

                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, (LPTSTR)pString);

                    pString = pDrvFile->GetCopyright();
                    if (!pString && _T('\0') == TempString[0]) {

                        LoadResourceString(IDS_NOT_AVAILABLE, TempString, ARRAYLEN(TempString));
                        pString = TempString;
                    }

                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, (LPTSTR)pString);
                }
            
                //
                // Show the digital signer if the file is signed.
                //
                pString = pDrvFile->GetInfDigitalSigner();
                if (!pString) {
                    TempString[0] = _T('\0');

                    LoadResourceString(((pDrvFile->GetWin32Error() != 0) &&
                                        (pDrvFile->GetWin32Error() != 0xFFFFFFFF) &&
                                        (pDrvFile->GetWin32Error() != ERROR_DRIVER_BLOCKED))
                                           ?  IDS_NO_DIGITALSIGNATURE
                                           :  IDS_NOT_AVAILABLE, 
                                        TempString, 
                                        ARRAYLEN(TempString));
                    pString = TempString;
                }

                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DIGITALSIGNER, (LPTSTR)pString);

                //
                // Show the block driver link if this driver is blocked and it
                // has a block driver html help ID.
                //
                ShowWindow(GetControl(IDS_DRIVERFILES_BLOCKDRIVERLINK), 
                           pDrvFile->GetBlockedDriverHtmlHelpID()
                             ? TRUE
                             : FALSE);
            }
        }
        
        catch (CMemoryException* e) {

            e->Delete();
            // report memory error
            MsgBoxParam(m_hDlg, 0, 0, 0);
        }

    } else {

        // no selection
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, TEXT(""));
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, TEXT(""));
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, TEXT(""));
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DIGITALSIGNER, TEXT(""));
    }
}

void
CDriverFilesDlg::LaunchHelpForBlockedDriver()
{
    HWND hwndFileList = GetDlgItem(m_hDlg, IDC_DRIVERFILES_FILELIST);
    LVITEM lvItem;
    LPCTSTR pHtmlHelpID;
    String strHcpLink;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem = ListView_GetNextItem(hwndFileList,
                                        -1,
                                        LVNI_SELECTED
                                        );

    if (lvItem.iItem != -1) {

        try {
        
            ListView_GetItem(hwndFileList, &lvItem);

            CDriverFile* pDrvFile = (CDriverFile*)lvItem.lParam;
            ASSERT(pDrvFile);

            if ((pHtmlHelpID = pDrvFile->GetBlockedDriverHtmlHelpID()) != NULL) {
                strHcpLink.Format(TEXT("HELPCTR.EXE -url %s"), pHtmlHelpID);

                ShellExecute(m_hDlg,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             (LPTSTR)strHcpLink,
                             NULL,
                             SW_SHOWNORMAL);
            }
        }
        
        catch (CMemoryException* e) {

            e->Delete();
            // report memory error
            MsgBoxParam(m_hDlg, 0, 0, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devgenpg.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    devgenpg.cpp

Abstract:

    This module implements CDeviceGeneralPage -- device general property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// devgenpg.cpp : implementation file
//

#include "devmgr.h"
#include "hwprof.h"
#include "devgenpg.h"
#include "tswizard.h"
#include "utils.h"

//
// help topic ids
//

const DWORD g_a103HelpIDs[]=
{
    IDC_DEVGEN_TITLE_TYPE, idh_devmgr_general_devicetype,
    IDC_DEVGEN_TITLE_MFG, idh_devmgr_general_manufacturer,
    IDC_DEVGEN_STATUSGROUP, IDH_DISABLEHELP,
    IDC_DEVGEN_ICON, IDH_DISABLEHELP, // General: "" (Static)
    IDC_DEVGEN_DESC, IDH_DISABLEHELP,   // General: "" (Static)
    IDC_DEVGEN_USAGETEXT, IDH_DISABLEHELP,  // General: "Place a check mark next to the configuration(s) where this device should be used." (Static)
    IDC_DEVGEN_TYPE, idh_devmgr_general_devicetype, // General: "" (Static)
    IDC_DEVGEN_MFG, idh_devmgr_general_manufacturer,    // General: "" (Static)
    IDC_DEVGEN_STATUS, idh_devmgr_general_device_status,    // General: "" (Static)
    IDC_DEVGEN_PROFILELIST, idh_devmgr_general_device_usage,    // General: "Dropdown Combo" (SysListView32)
    IDC_DEVGEN_TITLE_LOCATION, idh_devmgr_general_location, // General:  location
    IDC_DEVGEN_LOCATION, idh_devmgr_general_location,     // General:  location
    IDC_DEVGEN_TROUBLESHOOTING, idh_devmgr_general_trouble, // General: troubleshooting
    0, 0
};

CDeviceGeneralPage::~CDeviceGeneralPage()
{
    if (m_pHwProfileList) {

        delete m_pHwProfileList;
    }

    if (m_pProblemAgent) {

        delete m_pProblemAgent;
    }
}

HPROPSHEETPAGE
CDeviceGeneralPage::Create(
    CDevice* pDevice
    )
{
    ASSERT(pDevice);

    if (pDevice)
    {
        m_pDevice = pDevice;
        
        // override PROPSHEETPAGE structure here...
        m_psp.lParam = (LPARAM)this;
        
        pDevice->m_pMachine->DiTurnOffDiExFlags(*pDevice, DI_FLAGSEX_PROPCHANGE_PENDING);
        return  CreatePage();
    }
    
    return NULL;
}

BOOL
CDeviceGeneralPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    m_pDevice->m_pMachine->AttachPropertySheet(m_hDlg);


    // notify property sheet data that the property sheet is up
    m_pDevice->m_psd.PageCreateNotify(m_hDlg);

    return CPropSheetPage::OnInitDialog(ppsp);
}

BOOL 
CDeviceGeneralPage::OnApply()
{
    try
    {
        HWND hwndCB = GetControl(IDC_DEVGEN_PROFILELIST);
        
        m_SelectedDeviceUsage = ComboBox_GetCurSel(hwndCB);

        if ((-1 != m_SelectedDeviceUsage) && 
            (m_SelectedDeviceUsage != m_CurrentDeviceUsage)) {

            //
            // User is changing the device usage
            //
            UpdateHwProfileStates();
            SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return FALSE;
}

void
CDeviceGeneralPage::UpdateHwProfileStates()
{
    // first decide what to do: enabling or disabling
    BOOL Canceled;
    Canceled = FALSE;

    if (m_SelectedDeviceUsage == m_CurrentDeviceUsage) {
    
        return;
    }

    m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_NODI_DEFAULTACTION);

    SP_PROPCHANGE_PARAMS pcp;
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    //
    // specific enabling/disabling
    //
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    CHwProfile* phwpf;

    if (m_pHwProfileList->GetCurrentHwProfile(&phwpf))
    {
        if (DEVICE_ENABLE == m_SelectedDeviceUsage) {
            pcp.StateChange = DICS_ENABLE;
        } else {
            pcp.StateChange = DICS_DISABLE;
        }

        pcp.HwProfile = phwpf->GetHwProfile();
        
        m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                    &pcp.ClassInstallHeader,
                    sizeof(pcp)
                    );
        
        m_pDevice->m_pMachine->DiCallClassInstaller(DIF_PROPERTYCHANGE, *m_pDevice);
        
        Canceled = (ERROR_CANCELLED == GetLastError());
    }

    //
    // class installer has not objection of our enabling/disabling,
    // do real enabling/disabling.
    //
    if (!Canceled)
    {
        if (m_pHwProfileList->GetCurrentHwProfile(&phwpf))
        {
            if (DEVICE_ENABLE == m_SelectedDeviceUsage) 
            {
                //
                // we are enabling the device,
                // do a specific enabling then a globally enabling.
                // the globally enabling will start the device
                // The implementation here is different from
                // Win9x which does a global enabling, a config
                // specific enabling and then a start.
                //
                pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
                pcp.HwProfile = phwpf->GetHwProfile();
                
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );
                
                m_pDevice->m_pMachine->DiChangeState(*m_pDevice);
                
                //
                // this call will start the device is it not started.
                //
                pcp.Scope = DICS_FLAG_GLOBAL;
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );
                
                m_pDevice->m_pMachine->DiChangeState(*m_pDevice);
            
            } else {
                //
                // Do either a global disable or a configspecific disable
                //
                if (DEVICE_DISABLE == m_SelectedDeviceUsage) {
                
                    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
                
                } else {

                    pcp.Scope = DICS_FLAG_GLOBAL;
                }

                pcp.StateChange = DICS_DISABLE;
                pcp.HwProfile = phwpf->GetHwProfile();
                
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );
                
                m_pDevice->m_pMachine->DiChangeState(*m_pDevice);
            }
        }

        // signal that the property of the device is changed.
        m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
        m_RestartFlags |= (m_pDevice->m_pMachine->DiGetFlags(*m_pDevice)) & (DI_NEEDRESTART | DI_NEEDREBOOT);
    }

    // remove class install parameters, this also reset
    // DI_CLASSINATLLPARAMS
    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice, NULL, 0);

    m_pDevice->m_pMachine->DiTurnOffDiFlags(*m_pDevice, DI_NODI_DEFAULTACTION);
}

BOOL 
CDeviceGeneralPage::OnLastChanceApply()
{
    //
    // The last chance apply message is sent in reverse order page n to page 0.
    //
    // Since we are the first page in the set of property sheets we can gaurentee 
    // that the last PSN_LASTCHANCEAPPLY message will be the last message for all 
    // the pages.
    //
    // The property sheet is going away, consolidate the changes on the device.  We
    // do this during the PSN_LASTCHANCEAPPLY message so that the property sheet is
    // still displayed while we do the DIF_PROPERTYCHANGE.  There are some cases where
    // the DIF_PROPERTYCHANGE can take quite a long time so we want the property sheet
    // to still be shown while this is happening.  If we do this during the DestroyCallback
    // the property sheet UI has already been torn down and so the user won't realize
    // we are still saving the changes.
    //
    try
    {
        ASSERT(m_pDevice);

        if (m_pDevice->m_pMachine->DiGetExFlags(*m_pDevice) & DI_FLAGSEX_PROPCHANGE_PENDING)
        {
            DWORD Status = 0, Problem = 0;

            //
            // If the device has the DN_WILL_BE_REMOVED flag set and the user is
            // attempting to change settings on the driver then we will prompt them for a 
            // reboot and include text in the prompt that explains this device
            // is in the process of being removed.
            //
            if (m_pDevice->GetStatus(&Status, &Problem) &&
                (Status & DN_WILL_BE_REMOVED)) {

                //
                // First try and send a MMCPropertyChangeNotify message to our
                // CComponent so that it can prompt for a reboot inside the 
                // device manager thread instead of our thread.  If this is not 
                // done then the property sheet will hang around after device
                // manager has gone away...which will cause a "hung app" dialog
                // to appear.
                //
                CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(NULL, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS);

                if (pNRR) {
                    if (!m_pDevice->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                        //
                        // There isn't a CComponent around, so this is just a property
                        // sheet running outside of MMC.
                        //
                        pNRR->Release();
                        PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS);
                    }
                } else {
                    //
                    // We couldn't allocate memory to create our CNotifyRebootRequest
                    // instance, so just prompt for a reboot in this thread.
                    //
                    PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS);
                }

            } else {
                //
                // property change pending, issue a DICS_PROPERTYCHANGE to the
                // class installer. A DICS_PROPCHANGE would basically stop the
                // device and restart it. If each property page issues
                // its own DICS_PROPCHANGE command, the device would
                // be stopped/started several times even though one is enough.
                // A property page sets DI_FLAGEX_PROPCHANGE_PENDING when it needs
                // a DICS_PROPCHANGE command to be issued.
                //
                SP_PROPCHANGE_PARAMS pcp;
                pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
                pcp.Scope = DICS_FLAG_GLOBAL;
                pcp.StateChange = DICS_PROPCHANGE;
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                                &pcp.ClassInstallHeader,
                                sizeof(pcp)
                                 );
                m_pDevice->m_pMachine->DiCallClassInstaller(DIF_PROPERTYCHANGE, *m_pDevice);
                m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
                m_pDevice->m_pMachine->DiTurnOffDiExFlags(*m_pDevice, DI_FLAGSEX_PROPCHANGE_PENDING);
    
                if (hCursorOld) {
    
                    SetCursor(hCursorOld);
                }
            }
        }
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return FALSE;
}

UINT
CDeviceGeneralPage::DestroyCallback()
{
    //
    // We do this because this is the page we are sure will be created --
    // this page is ALWAYS the first page.
    //
    ASSERT(m_pDevice);

    //
    // We don't want to prompt for a reboot if the device has the problem
    // DN_WILL_BE_REMOVED, because we have already prompted for a reboot
    // before we get to this destroy callback.
    //
    DWORD Status = 0, Problem = 0;
    if (m_pDevice->GetStatus(&Status, &Problem) &&
        !(Status & DN_WILL_BE_REMOVED)) {
        
        m_RestartFlags |= m_pDevice->m_pMachine->DiGetFlags(*m_pDevice);
        if (m_RestartFlags & (DI_NEEDRESTART | DI_NEEDREBOOT))
        {
            //
            // Do not use our window handle(or its parent) as the parent
            // to the newly create dialog because they are in "detroyed state".
            // WM_CLOSE does not help either.
            // NULL window handle(Desktop) should be okay here.
            //
            // We only want to prompt for a restart if device manager is connected
            // to the local machine.
            //
            if (m_pDevice->m_pMachine->IsLocal()) 
            {
                //
                // First try and send a MMCPropertyChangeNotify message to our
                // CComponent so that it can prompt for a reboot inside the 
                // device manager thread instead of our thread.  If this is not 
                // done then the property sheet will hang around after device
                // manager has gone away...which will cause a "hung app" dialog
                // to appear.
                //
                CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(NULL, m_RestartFlags, 0);
    
                if (pNRR) {
                    if (!m_pDevice->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                        //
                        // There isn't a CComponent around, so this is just a property
                        // sheet running outside of MMC.
                        //
                        pNRR->Release();
                        PromptForRestart(NULL, m_RestartFlags);
                    }
                } else {
                    //
                    // We couldn't allocate memory to create our CNotifyRebootRequest
                    // instance, so just prompt for a reboot in this thread.
                    //
                    PromptForRestart(NULL, m_RestartFlags);
                }
            }
        }
    }

    // notify CPropSheetData that the property sheet is going away
    m_pDevice->m_psd.PageDestroyNotify(m_hDlg);
    if (m_RestartFlags & DI_PROPERTIES_CHANGE)
    {
        // Device properties changed. We need to refresh the machine.
        // Since we are running in a separate thread, we can not
        // call the refresh function, instead, we schedule it.
        // This should be done before enabling the refresh
        if (m_pDevice->m_pMachine->m_ParentMachine) {

            m_pDevice->m_pMachine->m_ParentMachine->ScheduleRefresh();

        } else {

            m_pDevice->m_pMachine->ScheduleRefresh();
        }
    }

    //    
    // Detach this property page from the CMachine so that the CMachine can be
    // destroyed now if it needs to be.
    //
    m_pDevice->m_pMachine->DetachPropertySheet(m_hDlg);
    
    ASSERT(!::IsWindow(m_hwndLocationTip));

    //
    // Destory the CMachine.
    //
    CMachine* pMachine;
    pMachine = m_pDevice->m_pMachine;
    
    if (pMachine->ShouldPropertySheetDestroy()) {
    
        delete pMachine;
    }
    
    return CPropSheetPage::DestroyCallback();
}

void
CDeviceGeneralPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam)
        m_pDevice = (CDevice*)lParam;

    m_RestartFlags = 0;

    try
    {
        //
        // Calling PropertyChanged() will update the display name for the device.  We need
        // to do this in case a 3rd party property sheet did something that could change
        // the device's display name.
        //
        m_pDevice->PropertyChanged();

        SetDlgItemText(m_hDlg, IDC_DEVGEN_DESC, m_pDevice->GetDisplayName());
        TCHAR TempString[512];
        String str;
        m_pDevice->GetMFGString(str);
        SetDlgItemText(m_hDlg, IDC_DEVGEN_MFG, str);
        SetDlgItemText(m_hDlg, IDC_DEVGEN_TYPE, m_pDevice->GetClassDisplayName());

        HICON hIconNew;
        hIconNew = m_pDevice->LoadClassIcon();
        if (hIconNew)
        {
            HICON hIconOld;
            m_IDCicon = IDC_DEVGEN_ICON;    // Save for cleanup in OnDestroy.
            hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVGEN_ICON,
                                                 STM_SETICON, (WPARAM)hIconNew,
                                                 0);
            if (hIconOld)
                DestroyIcon(hIconOld);
        }

        //
        // get the device location information
        //
        if (::GetLocationInformation(m_pDevice->GetDevNode(),
                                      TempString, 
                                      ARRAYLEN(TempString),
                                      m_pDevice->m_pMachine->GetHMachine()) != CR_SUCCESS)
        {
            // if the devnode does not have location information,
            // use the word "unknown"
            LoadString(g_hInstance, IDS_UNKNOWN, TempString, ARRAYLEN(TempString));
        }

        SetDlgItemText(m_hDlg, IDC_DEVGEN_LOCATION, TempString);

        AddToolTips(m_hDlg, IDC_DEVGEN_LOCATION, TempString, &m_hwndLocationTip);

        ShowWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), SW_HIDE);

        DWORD Problem, Status;
        if (m_pDevice->GetStatus(&Status, &Problem) || m_pDevice->IsPhantom())
        {
            //
            // if the device is a phantom device, use the CM_PROB_PHANTOM
            //
            if (m_pDevice->IsPhantom())
            {
                Problem = CM_PROB_PHANTOM;
                Status = DN_HAS_PROBLEM;
            }

            //
            // if the device is not started and no problem is assigned to it
            // fake the problem number to be failed start.
            //
            if (!(Status & DN_STARTED) && !Problem && m_pDevice->IsRAW())
            {
                Problem = CM_PROB_FAILED_START;
            }



            //
            // if a device has a private problem then give it special text telling
            // the user to contact the manufacturer of this driver.
            //
            if (Status & DN_PRIVATE_PROBLEM) 
            {
                str.LoadString(g_hInstance, IDS_SPECIALPROB_PRIVATEPROB);
            }

            //
            // if a device is not started and still does not have a problem
            // then give it special problem text saying that this device
            // does not have a driver.
            //
            else if (!(Status & DN_STARTED) && !(Status & DN_HAS_PROBLEM))
            {
                if (::GetSystemMetrics(SM_CLEANBOOT) == 0) {
                
                    str.LoadString(g_hInstance, IDS_SPECIALPROB_NODRIVERS);

                } else {

                    str.LoadString(g_hInstance, IDS_SPECIALPROB_SAFEMODE);
                }
            }


            //
            // Display normal problem text
            //
            else
            {
                UINT len = GetDeviceProblemText(Problem, TempString, ARRAYLEN(TempString));
                if (len)
                {
                    if (len < ARRAYLEN(TempString))
                    {
                        SetDlgItemText(m_hDlg, IDC_DEVGEN_STATUS, TempString);
                        str = TempString;
                    }
                    else
                    {
                        BufferPtr<TCHAR> TextPtr(len + 1);
                        GetDeviceProblemText(Problem, TextPtr, len + 1);

                        str = (LPTSTR)TextPtr;
                    }
                }

                else
                {
                    str.LoadString(g_hInstance, IDS_PROB_UNKNOWN);
                }
            }

            // 
            // Add the 'related driver blocked' text if the device has the devnode
            // flag DN_DRIVER_BLOCKED set and it does not have the problem
            // CM_PROB_DRIVER_BLOCKED.
            //
            if ((Status & DN_DRIVER_BLOCKED) &&
                (Problem != CM_PROB_DRIVER_BLOCKED)) {
                LoadString(g_hInstance, IDS_DRIVER_BLOCKED, TempString, ARRAYLEN(TempString));
                str += TempString;
            }

            //
            // Add the 'child device with invalid Id' text if the device has 
            // the devnode flag DN_CHILD_WITH_INVALID_ID set.
            //
            if (Status & DN_CHILD_WITH_INVALID_ID) {
                LoadString(g_hInstance, IDS_CHILD_WITH_INVALID_ID, TempString, ARRAYLEN(TempString));
                str += TempString;
            }

            //
            // Add the 'will be removed' text if the device is going to be removed
            // on the next restart.
            //
            if (Status & DN_WILL_BE_REMOVED) {

                LoadString(g_hInstance, IDS_WILL_BE_REMOVED, TempString, ARRAYLEN(TempString));
                str += TempString;
            }

            //
            // Add the restart text if the device needs to be restarted
            //
            if (Status & DN_NEED_RESTART) {

                LoadString(g_hInstance, IDS_NEED_RESTART, TempString, ARRAYLEN(TempString));
                str += TempString;

                m_RestartFlags |= DI_NEEDRESTART;
            }

            //
            // Create the problem agent and update the control text
            //
            if (!(Status & DN_PRIVATE_PROBLEM)) 
            {
                if (m_pProblemAgent) {
    
                    delete m_pProblemAgent;
                }
    
                m_pProblemAgent = new CProblemAgent(m_pDevice, Problem, FALSE);
    
                DWORD Len;
                Len = m_pProblemAgent->InstructionText(TempString, ARRAYLEN(TempString));
                if (Len)
                {
                    str += TempString;
                }
    
                Len = m_pProblemAgent->FixitText(TempString, ARRAYLEN(TempString));
                if (Len)
                {
                    ::ShowWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), SW_SHOW);
                    SetDlgItemText(m_hDlg, IDC_DEVGEN_TROUBLESHOOTING, TempString);
                }
            }
        }

        else
        {
            TRACE((TEXT("%s has not status, devnode =%lx, cr = %lx\n"),
                m_pDevice->GetDisplayName(), m_pDevice->GetDevNode(),
                m_pDevice->m_pMachine->GetLastCR()));
            str.LoadString(g_hInstance, IDS_PROB_UNKNOWN);
            ::ShowWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), SW_HIDE);
        }

        SetDlgItemText(m_hDlg, IDC_DEVGEN_STATUS, str);

        if (m_pDevice->NoChangeUsage() ||
            !m_pDevice->IsDisableable() ||
            (CM_PROB_HARDWARE_DISABLED == Problem))
        {
            // the device disallows any changes on hw profile.
            // disable all profile related controls.
            ::EnableWindow(GetControl(IDC_DEVGEN_PROFILELIST), FALSE);
            ::EnableWindow(GetControl(IDC_DEVGEN_USAGETEXT), FALSE);
        }

        else
        {
            HWND hwndCB = GetControl(IDC_DEVGEN_PROFILELIST);

            DWORD ConfigFlags;
            
            if (!m_pDevice->GetConfigFlags(&ConfigFlags)) {
            
                ConfigFlags = 0;
            }

            //
            // only want the disabled bit
            //
            ConfigFlags &= CONFIGFLAG_DISABLED;

            //
            // rebuild the profile list.
            //
            if (m_pHwProfileList) {
            
                delete m_pHwProfileList;
            }

            m_pHwProfileList = new CHwProfileList();

            if (m_pHwProfileList->Create(m_pDevice, ConfigFlags))
            {
                ComboBox_ResetContent(hwndCB);

                //
                // Get the current device usage
                //
                if (m_pDevice->IsStateDisabled()) {

                    if ((m_pHwProfileList->GetCount() > 1) && ConfigFlags) {

                        m_CurrentDeviceUsage = DEVICE_DISABLE_GLOBAL;
                    
                    } else {

                        m_CurrentDeviceUsage = DEVICE_DISABLE;
                    }

                } else {

                    m_CurrentDeviceUsage = DEVICE_ENABLE;
                }


                //
                // Always add the Enable item
                //
                String Enable;
                
                Enable.LoadString(g_hInstance, IDS_ENABLE_CURRENT);
                ComboBox_AddString(hwndCB, Enable);

                //
                // Add the disable items. There will either be one disable
                // item if there is only one hardware profile or two if there
                // are more than one hardware profile.
                //
                if (m_pHwProfileList->GetCount() > 1) {

                    String DisableInCurrent;
                    DisableInCurrent.LoadString(g_hInstance, IDS_DISABLE_IN_PROFILE);
                    ComboBox_AddString(hwndCB, DisableInCurrent);

                    String DisableGlobal;
                    DisableGlobal.LoadString(g_hInstance, IDS_DISABLE_GLOBAL);
                    ComboBox_AddString(hwndCB, DisableGlobal);

                } else {

                    String Disable;
                    Disable.LoadString(g_hInstance, IDS_DISABLE_CURRENT);
                    ComboBox_AddString(hwndCB, Disable);
                }

                ComboBox_SetCurSel(hwndCB, m_CurrentDeviceUsage);
            }
        }

        //
        // If this is a remote computer or the user is not an administrator
        // then disable the enable/disable drop down list along with the
        // TroubleShooter button.
        //
        if (!m_pDevice->m_pMachine->IsLocal() || 
            !g_IsAdmin)
        {
            ::EnableWindow(GetControl(IDC_DEVGEN_PROFILELIST), FALSE);
            ::EnableWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), FALSE);
        }

        //
        // Check if we need to autolauch the troubleshooter
        //
        if (m_pDevice->m_pMachine->IsLocal() &&
            g_IsAdmin &&
            m_pDevice->m_bLaunchTroubleShooter) {

            m_pDevice->m_bLaunchTroubleShooter = FALSE;
            ::PostMessage(m_hDlg, WM_COMMAND, MAKELONG(IDC_DEVGEN_TROUBLESHOOTING, BN_CLICKED), 0);
        }

    }
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDeviceGeneralPage::OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam
    )
{
    DMQUERYSIBLINGCODE Code =  (DMQUERYSIBLINGCODE)wParam;
    
    if (QSC_TO_FOREGROUND == Code)
    {
        HWND hwndSheet;
        
        hwndSheet = m_pDevice->m_psd.GetWindowHandle();
        
        if (GetForegroundWindow() != hwndSheet)
        {
            SetForegroundWindow(hwndSheet);
        }
        
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 1);
        return TRUE;
    }

    return CPropSheetPage::OnQuerySiblings(wParam, lParam);
}

BOOL
CDeviceGeneralPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    if (BN_CLICKED == HIWORD(wParam) &&
        IDC_DEVGEN_TROUBLESHOOTING == LOWORD(wParam)) {

        BOOL fChanged = FALSE;
        
        if (m_pProblemAgent) {

            fChanged = m_pProblemAgent->FixIt(GetParent(m_hDlg));
        }
        
        if (fChanged) {

            m_pDevice->PropertyChanged();
            m_pDevice->GetClass()->PropertyChanged();
            m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
            UpdateControls();
            PropSheet_SetTitle(GetParent(m_hDlg), PSH_PROPTITLE, m_pDevice->GetDisplayName());
            PropSheet_CancelToClose(GetParent(m_hDlg));

            //
            // ISSUE: JasonC 2/7/2000
            //
            // A refresh on m_pDevice->m_pMachine is necessary here.
            // Since we are running on a different thread and each
            // property page may have cached the HDEVINFO and the
            // SP_DEVINFO_DATA, refresh on the CMachine object can not
            // be done here. The problem is worsen by the fact that
            // user can go back to the device tree and work on the tree
            // while this property sheet is still up.
            // It would be nice if MMC would support modal dialog boxes. 
            //
        }
    }

    return FALSE;
}

BOOL
CDeviceGeneralPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a103HelpIDs);
    return FALSE;
}


BOOL
CDeviceGeneralPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
        (ULONG_PTR)g_a103HelpIDs);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devpopg.h ===
// devpopg.h : header file
//

#ifndef __DEVPOPG_H__
#define __DEVPOPG_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    devpopg.h

Abstract:

    header file for devpopg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"
#include "wmium.h"
#include "wdmguid.h"
#include "ndisguid.h"

//
// help topic ids
//
#define IDH_DISABLEHELP                     (DWORD(-1))
#define IDH_DEVMGR_PWRMGR_WAKEENABLE        2003170
#define IDH_DEVMGR_PWRMGR_MGMT_WAKEENABLE   2003185
#define IDH_DEVMGR_PWRMGR_DEVICEENABLE      2003180


typedef struct tagPowerTimeouts {
    ULONG   ConservationIdleTime;
    ULONG   PerformanceIdleTime;
} DM_POWER_DEVICE_TIMEOUTS, *PDM_POWER_DEVICE_TIMEOUTS;

class CPowerEnable {

public:
    CPowerEnable(const GUID& wmiGuid, ULONG DataBlockSize)
    : m_hWmiBlock(INVALID_HANDLE_VALUE),
    m_WmiInstDataSize(0), m_pWmiInstData(NULL),
    m_DataBlockSize(DataBlockSize)
    {
        m_wmiGuid = wmiGuid;
        m_DevInstId[0] = _T('\0');
    }

    virtual ~CPowerEnable()
    {
        Close();
    }
    BOOL IsOpened()
    {
        return INVALID_HANDLE_VALUE != m_hWmiBlock;
    }
    BOOL Get(BOOLEAN& fEnabled);
    BOOL Set(BOOLEAN fEnable);
    BOOL Open(LPCTSTR DeviceId);
    BOOL Close()
    {
        if (INVALID_HANDLE_VALUE != m_hWmiBlock) {
            WmiCloseBlock(m_hWmiBlock);
        }

        m_hWmiBlock = INVALID_HANDLE_VALUE;
        m_DevInstId[0] = _T('\0');

        if (m_pWmiInstData) {

            delete [] m_pWmiInstData;
            m_pWmiInstData = NULL;
        }

        m_WmiInstDataSize = 0;

        return TRUE;
    }
    operator GUID&()
    {
        return m_wmiGuid;
    }

protected:
    WMIHANDLE   m_hWmiBlock;
    ULONG       m_Version;
    GUID        m_wmiGuid;
    ULONG       m_WmiInstDataSize;
    BYTE*       m_pWmiInstData;
    ULONG       m_DataBlockSize;
    TCHAR       m_DevInstId[MAX_DEVICE_ID_LEN + 2];
};

class CPowerShutdownEnable : public CPowerEnable {
public:
    CPowerShutdownEnable() : CPowerEnable(GUID_POWER_DEVICE_ENABLE, sizeof(BOOLEAN))
    {}
    // override dtor is not necessary
};

class CPowerWakeEnable : public CPowerEnable {
public:
    CPowerWakeEnable() : CPowerEnable(GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(BOOLEAN))
    {}
    // override dtor is not necessary
};

class CPowerWakeMgmtEnable : public CPowerEnable {
public:
    CPowerWakeMgmtEnable() : CPowerEnable(GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(BOOLEAN))
    {}
    // override dtor is not necessary
};

class CDevicePowerMgmtPage : public CPropSheetPage {
public:
    CDevicePowerMgmtPage() :
    m_pDevice(NULL),
    CPropSheetPage(g_hInstance, IDD_DEVPOWER_PAGE)
    {}
    ~CDevicePowerMgmtPage()
    {}
    HPROPSHEETPAGE Create(CDevice* pDevice)
    {
        ASSERT(pDevice);
        m_pDevice = pDevice;
        // override PROPSHEETPAGE structure here...
        m_psp.lParam = (LPARAM)this;
        return CreatePage();
    }

protected:
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnApply();
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
private:
    CDevice*    m_pDevice;
    CPowerShutdownEnable m_poShutdownEnable;
    CPowerWakeEnable m_poWakeEnable;
    CPowerWakeMgmtEnable m_poWakeMgmtEnable;
};

#endif // _DEVPOPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devgenpg.h ===
// devgenpg.h : header file
//

#ifndef __DEVGENPG_H__
#define __DEVGENPG_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    devgenpg.h

Abstract:

    header file for devgenpg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"
//#include "tshooter.h"

//
// help topic ids
//
#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_general_devicetype   103100  // General: "" (Static)
#define idh_devmgr_general_manufacturer 103110  // General: "" (Static)
#define idh_devmgr_general_hardware_revision    103120  // General: "Not Available" (Static)
#define idh_devmgr_general_device_status    103130  // General: "" (Static)
#define idh_devmgr_general_device_usage 103140  // General: "List1" (SysListView32)
#define idh_devmgr_general_location 103160
#define idh_devmgr_general_trouble  103150  // troubelshooting button

class CHwProfileList;
class CProblemAgent;

#define DI_NEEDPOWERCYCLE   0x400000L

#define DEVICE_ENABLE           0
#define DEVICE_DISABLE          1
#define DEVICE_DISABLE_GLOBAL   2

class CDeviceGeneralPage : public CPropSheetPage
{
public:
    CDeviceGeneralPage() :
    m_pDevice(NULL),
    m_pHwProfileList(NULL),
    m_RestartFlags(0),
    m_pProblemAgent(NULL),
    m_hwndLocationTip(NULL),
    CPropSheetPage(g_hInstance, IDD_DEVGEN_PAGE)
    {}
    ~CDeviceGeneralPage();
    HPROPSHEETPAGE Create(CDevice* pDevice);
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnApply(void);
    virtual BOOL OnLastChanceApply(void);
    virtual BOOL OnQuerySiblings(WPARAM wParam, LPARAM lParam);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    virtual UINT  DestroyCallback();

private:
    void UpdateHwProfileStates();
    CHwProfileList* m_pHwProfileList;
    DWORD   m_hwpfCur;
    CDevice* m_pDevice;
    int     m_CurrentDeviceUsage;
    int     m_SelectedDeviceUsage;
    DWORD   m_RestartFlags;
    CProblemAgent*  m_pProblemAgent;
    HWND    m_hwndLocationTip;
};


#endif // __DEVGENPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       devmgr.h
//
//--------------------------------------------------------------------------

#ifndef __DEVMGR_H_
#define __DEVMGR_H_

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <new.h>
#include <stdio.h>
#include <stdlib.h>
#include <prsht.h>
#include <prshtp.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shlapip.h>
#include <ole2.h>
#include <mmc.h>
#include <objsel.h>
#include <htmlhelp.h>
#include <winioctl.h>
#include <strsafe.h>

#include <shfusion.h>

extern "C" {
#include <commdlg.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <spapip.h>
#include <sputils.h>
#include <regstr.h>
#include <shimdb.h>
}

#pragma warning( default : 4201 )


#define ARRAYLEN(array)     (sizeof(array) / sizeof(array[0]))


typedef enum tagCookieType
{
    COOKIE_TYPE_SCOPEITEM_DEVMGR = 0,
    COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ,
    COOKIE_TYPE_RESULTITEM_RESOURCE_DMA,
    COOKIE_TYPE_RESULTITEM_RESOURCE_IO,
    COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY,
    COOKIE_TYPE_RESULTITEM_COMPUTER,
    COOKIE_TYPE_RESULTITEM_DEVICE,
    COOKIE_TYPE_RESULTITEM_CLASS,
    COOKIE_TYPE_RESULTITEM_RESTYPE,
    COOKIE_TYPE_UNKNOWN
} COOKIE_TYPE, *PCOOKIE_TYPE;


#define COOKIE_FLAGS_EXPANDED           0x00000001

const int TOTAL_COOKIE_TYPES = COOKIE_TYPE_RESULTITEM_RESTYPE - COOKIE_TYPE_SCOPEITEM_DEVMGR + 1;

const int NODETYPE_FIRST =      (int)COOKIE_TYPE_SCOPEITEM_DEVMGR;
const int NODETYPE_LAST  =      (int)COOKIE_TYPE_RESULTITEM_RESTYPE;


typedef struct tagNodeInfo {
    COOKIE_TYPE     ct;
    int             idsName;
    int             idsFormat;
    GUID            Guid;
    TCHAR*          GuidString;
} NODEINFO, *PNODEINFO;


//
// Device manager needs to keep track of the largest problem code that it 
// currently knows about.  Using the NUM_CM_PROB defined in cfg.h is a bad
// idea because if more problem codes are added that device manager doesn't
// know about it will cause us to overrun the end of the CMPROBLEM_INFO array.
//
// Note that the +2 are for
//  1) the working case (0 index in the array)
//  2) the unknown problem case (last problem + 1 index in the array)
//                                                                  

#define DEVMGR_NUM_CM_PROB      0x34

#if DEVMGR_NUM_CM_PROB != (NUM_CM_PROB + 1)
#error Update DEVMGR_NUM_CM_PROB and update tswizard.cpp and globals.cpp.
#endif

#define PIF_CODE_EMBEDDED       0x01

typedef struct tagProblemInfo {
    int     StringId;
    DWORD   Flags;
} PROBLEMINFO, *PPROBLEMINFO;

typedef struct tagInternalData {
    DATA_OBJECT_TYPES   dot;
    COOKIE_TYPE ct;
    MMC_COOKIE  cookie;
} INTERNAL_DATA, *PINTERNAL_DATA;

typedef enum tagPropertyChangeType
{
    PCT_STARTUP_INFODATA = 0,
    PCT_DEVICE,
    PCT_CLASS
} PROPERTY_CHANGE_TYPE, *PPROPERTY_CHANGE_TYPE;

typedef struct tagPropertyChangeInfo
{
    PROPERTY_CHANGE_TYPE Type;
    BYTE                 InfoData[1];
} PROPERTY_CHANGE_INFO, *PPROPERTY_CHANGE_INFO;

typedef struct tagStartupInfoData
{
    DWORD           Size;
    COOKIE_TYPE     ct;
    TCHAR           MachineName[MAX_PATH + 3];
} STARTUP_INFODATA, *PSTARTUP_INFODATA;

typedef enum tagdmQuerySiblingCode
{
    QSC_TO_FOREGROUND = 0,
    QSC_PROPERTY_CHANGED,
} DMQUERYSIBLINGCODE, *PDMQUERYSIBLINGCODE;

//
// private header files
//
#include "..\inc\tvintf.h"
#include "resource.h"
#include "prndlg.h"
#include "globals.h"
#include "utils.h"
#include "ccookie.h"
#include "machine.h"
#include "compdata.h"
#include "componet.h"
#include "cnode.h"
#include "cfolder.h"
#include "dataobj.h"

BOOL InitGlobals(HINSTANCE hInstance);

extern LPCTSTR DEVMGR_DEVICEID_SWITCH;
extern LPCTSTR DEVMGR_MACHINENAME_SWITCH;
extern LPCTSTR DEVMGR_COMMAND_SWITCH;

void * __cdecl operator new(size_t size);
void __cdecl operator delete(void *ptr);
__cdecl _purecall(void);


STDAPI
DllRegisterServer();

STDAPI
DllUnregisterServer();

STDAPI
DllCanUnloadNow();

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID iid, void** ppv);


//
// CDMCommandLine class defination
//
class CDMCommandLine : public CCommandLine
{
public:
    CDMCommandLine() : m_WaitForDeviceId(FALSE),
                       m_WaitForMachineName(FALSE),
                       m_WaitForCommand(FALSE)
    {}
    virtual void ParseParam(LPCTSTR lpszParam, BOOL bFlag)
    {
        if (bFlag)
        {
            if (!lstrcmpi(DEVMGR_DEVICEID_SWITCH, lpszParam)) {
                m_WaitForDeviceId = TRUE;
            
            } else if (!lstrcmpi(DEVMGR_MACHINENAME_SWITCH, lpszParam)) {
                m_WaitForMachineName = TRUE;
            
            } else if (!lstrcmpi(DEVMGR_COMMAND_SWITCH, lpszParam)) {
                m_WaitForCommand = TRUE;
            }
        } else {
            if (m_WaitForDeviceId) {
                m_strDeviceId = lpszParam;
                m_WaitForDeviceId = FALSE;
            
            } else if (m_WaitForMachineName) {
                m_strMachineName = lpszParam;
                m_WaitForMachineName = FALSE;
            
            } else if (m_WaitForCommand) {
                m_strCommand = lpszParam;
                m_WaitForCommand = FALSE;
            }
        }
    }
    LPCTSTR GetDeviceId()
    {
        return m_strDeviceId.IsEmpty() ? NULL : (LPCTSTR)m_strDeviceId;
    }
    LPCTSTR GetMachineName()
    {
        return m_strMachineName.IsEmpty() ? NULL : (LPCTSTR)m_strMachineName;
    }
    LPCTSTR GetCommand()
    {
        return m_strCommand.IsEmpty() ? NULL : (LPCTSTR)m_strCommand;
    }

private:
    String      m_strDeviceId;
    String      m_strMachineName;
    String      m_strCommand;
    BOOL        m_WaitForDeviceId;
    BOOL        m_WaitForMachineName;
    BOOL        m_WaitForCommand;
};

class CNotifyRebootRequest
{
public:
    CNotifyRebootRequest() : Ref(1), m_hWnd(NULL), m_RestartFlags(0), m_StringId(0)
    {}
    CNotifyRebootRequest(HWND hWnd, DWORD RestartFlags, UINT StringId) : Ref(1)
    {
        m_hWnd = hWnd;
        m_RestartFlags = RestartFlags;
        m_StringId = StringId;
    }
    ~CNotifyRebootRequest()
    {
    }
    long AddRef()
    {
        Ref++;
        return Ref;
    }
    long Release()
    {
        ASSERT(Ref);
        if (!(--Ref))
        {
            delete this;
            return 0;
        }
        return Ref;
    }

    HWND    m_hWnd;
    DWORD   m_RestartFlags;
    UINT    m_StringId;

private:
    long    Ref;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devpopg.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    devpopg.cpp

Abstract:

    This module implements CDevicePowerMgmtPage -- device power management
    property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// devdrvpg.cpp : implementation file
//

#include "devmgr.h"
#include "devpopg.h"

extern "C" {
#include <initguid.h>
#include <wdmguid.h>
#include <devguid.h>
}


//
// help topic ids
//
const DWORD g_a15HelpIDs[]=
{
    IDC_DEVPOWER_DESC,  IDH_DISABLEHELP,
    IDC_DEVPOWER_ICON,  IDH_DISABLEHELP,
    IDC_DEVPOWER_WAKEENABLE,    IDH_DEVMGR_PWRMGR_WAKEENABLE,
    IDC_DEVPOWER_MGMT_WAKEENABLE, IDH_DEVMGR_PWRMGR_MGMT_WAKEENABLE,
    IDC_DEVPOWER_DEVICEENABLE, IDH_DEVMGR_PWRMGR_DEVICEENABLE,
    IDC_DEVPOWER_MESSAGE, IDH_DISABLEHELP,
    0,0

};

BOOL
CDevicePowerMgmtPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    //
    // Notify CPropSheetData about the page creation
    // the controls will be initialize in UpdateControls virtual function.
    //
    m_pDevice->m_psd.PageCreateNotify(m_hDlg);

    BOOLEAN Enabled;

    //
    // First see if the device is able to wake the system
    //
    if (m_poWakeEnable.Open(m_pDevice->GetDeviceID())) {
        
        m_poWakeEnable.Get(Enabled);
        ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE), BM_SETCHECK,
                      Enabled ? BST_CHECKED : BST_UNCHECKED, 0);

        EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), Enabled);
    } else {
        
        EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), FALSE);
        ShowWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
    }

    //
    // See if the device can be turned off to save power
    //
    if (m_poShutdownEnable.Open(m_pDevice->GetDeviceID())) {
        
        m_poShutdownEnable.Get(Enabled);
        ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE), BM_SETCHECK,
                      Enabled ? BST_CHECKED : BST_UNCHECKED, 0);
    } else {
        
        EnableWindow(GetControl(IDC_DEVPOWER_DEVICEENABLE), FALSE);
    }

    //
    // Special network card code.
    //
    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);
    if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET)) {

        if (m_poWakeMgmtEnable.Open(m_pDevice->GetDeviceID())) {
            
            m_poWakeMgmtEnable.Get(Enabled);
            ::SendMessage(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), BM_SETCHECK,
                          Enabled ? BST_CHECKED : BST_UNCHECKED, 0);
        }

        //
        // This is a special case for network class devices.  Wake on Lan will
        // only work if the device is enabled for power management.  So, if the 
        // user unchecks the 'power manage this device' then we need to disable
        // the WOL and management stations controls.
        //
        if (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE),
                                               BM_GETCHECK, 0, 0) ) {

            if (m_poWakeEnable.IsOpened()) {
                ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), TRUE);
            }

            if (m_poWakeMgmtEnable.IsOpened()) {
                //
                // The 'allow management stations to bring the computer out of standby'
                // option is only allowed if the 'Allow this device to bring the computer 
                // out of standby' option is checked.
                //
                if (m_poWakeEnable.IsOpened() &&
                    (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                                  BM_GETCHECK, 0, 0))) {
                    ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), TRUE);
                } else {
                    ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
                }
            }
        
        } else {

            ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), FALSE);
            ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
        }
    } else {

        ShowWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
        EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
    }

    return CPropSheetPage::OnInitDialog(ppsp);
}

BOOL
CDevicePowerMgmtPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    switch (LOWORD(wParam)) {
    
    case IDC_DEVPOWER_WAKEENABLE:
        if (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                               BM_GETCHECK, 0, 0) ) {

            ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), TRUE);
        
        } else {

            ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
        }
        break;

    case IDC_DEVPOWER_DEVICEENABLE:
        //
        // This is a special case for network class devices.  Wake on Lan will
        // only work if the device is enabled for power management.  So, if the 
        // user unchecks the 'power manage this device' then we need to disable
        // the WOL and management stations controls.
        //
        GUID ClassGuid;
        m_pDevice->ClassGuid(ClassGuid);
        if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET)) {
        
            if (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE),
                                                   BM_GETCHECK, 0, 0) ) {
    
                if (m_poWakeEnable.IsOpened()) {
                    ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), TRUE);
                }

                if (m_poWakeMgmtEnable.IsOpened()) {
                    //
                    // The 'allow management stations to bring the computer out of standby'
                    // option is only allowed if the 'Allow this device to bring the computer 
                    // out of standby' option is checked.
                    //
                    if (m_poWakeEnable.IsOpened() &&
                        (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                                      BM_GETCHECK, 0, 0))) {
                        ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), TRUE);
                    } else {
                        ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
                    }
                }
            
            } else {
    
                ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), FALSE);
                ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
            }
        }
        break;
    }

    return FALSE;
}

//
// This function saves the settings(if any)
//
BOOL
CDevicePowerMgmtPage::OnApply()
{
    BOOLEAN Enabled;

    if (m_poWakeEnable.IsOpened() && IsWindowEnabled(GetControl(IDC_DEVPOWER_WAKEENABLE))) {
        
        Enabled = BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                               BM_GETCHECK, 0, 0);
        m_poWakeEnable.Set(Enabled);
    }

    if (m_poWakeMgmtEnable.IsOpened() && IsWindowEnabled(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE))) {
        
        Enabled = BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE),
                                               BM_GETCHECK, 0, 0);
        m_poWakeMgmtEnable.Set(Enabled);
    }

    if (m_poShutdownEnable.IsOpened() && IsWindowEnabled(GetControl(IDC_DEVPOWER_DEVICEENABLE))) {
        
        Enabled = BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE),
                                               BM_GETCHECK, 0, 0);
        m_poShutdownEnable.Set(Enabled);
    }
    return FALSE;
}

//
// This function refreshes every control in the dialog. It may be called
// when the dialog is being initialized
//
void
CDevicePowerMgmtPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam) {
        
        m_pDevice = (CDevice*) lParam;
    }

    try {
        
        //
        // Calling PropertyChanged() will update the display name for the device.  We need
        // to do this in case a 3rd party property sheet did something that could change
        // the device's display name.
        //
        m_pDevice->PropertyChanged();

        HICON hIconOld;
        m_IDCicon = IDC_DEVPOWER_ICON;  // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVPOWER_ICON, STM_SETICON,
                                             (WPARAM)(m_pDevice->LoadClassIcon()),
                                             0
                                            );
        if (hIconOld) {
            DestroyIcon(hIconOld);
        }

        SetDlgItemText(m_hDlg, IDC_DEVPOWER_DESC, m_pDevice->GetDisplayName());

        //
        // Get any power message that the class installer might want to display
        //
        SP_POWERMESSAGEWAKE_PARAMS pmp;
        DWORD RequiredSize;

        pmp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        pmp.ClassInstallHeader.InstallFunction = DIF_POWERMESSAGEWAKE;
        pmp.PowerMessageWake[0] = TEXT('\0');

        m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                                                       &pmp.ClassInstallHeader,
                                                       sizeof(pmp)
                                                       );

        //
        // If the class installer returns NO_ERROR and there is text to display in the 
        // PowerMessageWake field of the SP_POWERMESSAGEWAKE_PARAMS structure then display
        // the text.
        //
        if ((m_pDevice->m_pMachine->DiCallClassInstaller(DIF_POWERMESSAGEWAKE, *m_pDevice)) &&
            (m_pDevice->m_pMachine->DiGetClassInstallParams(*m_pDevice,
                                                            &pmp.ClassInstallHeader,
                                                            sizeof(pmp),
                                                            &RequiredSize)) &&
            (pmp.PowerMessageWake[0] != TEXT('\0'))) {

            SetDlgItemText(m_hDlg, IDC_DEVPOWER_MESSAGE, pmp.PowerMessageWake);
        }
    } catch (CMemoryException* e) {
        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDevicePowerMgmtPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a15HelpIDs);

    return FALSE;
}


BOOL
CDevicePowerMgmtPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);
    
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a15HelpIDs);

    return FALSE;
}

//
// This function enables/disables the device power capability
// INPUT:
//      fEnable -- TRUE  to enable
//              -- FALSE to disable
// OUTPUT:
//      TRUE if the state is set
//      FALSE if the state is not set.
BOOL
CPowerEnable::Set(
    BOOLEAN fEnable
    )
{
    if (IsOpened()) {
        
        DWORD Error;
        BOOLEAN fNewValue = fEnable;
        
        Error = WmiSetSingleInstance(m_hWmiBlock, m_DevInstId, m_Version,
                                     sizeof(fNewValue), &fNewValue);

        //
        // Get the value back to see if the change is really succeeded.
        //
        if (ERROR_SUCCESS == Error && Get(fNewValue) && fNewValue == fEnable) {
            
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
CPowerEnable::Get(
    BOOLEAN& fEnable
    )
{
    fEnable = FALSE;

    if (IsOpened()) {
        
        ULONG Size = m_WmiInstDataSize;
        DWORD Error;

        Error = WmiQuerySingleInstance(m_hWmiBlock, m_DevInstId, &Size, m_pWmiInstData);

        if (ERROR_SUCCESS == Error && Size == m_WmiInstDataSize &&
            m_DataBlockSize == ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->SizeDataBlock &&
            m_Version == ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->WnodeHeader.Version) {
            fEnable = *((BOOLEAN*)(m_pWmiInstData + ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->DataBlockOffset));
            
            return TRUE;
        }
    }

    return FALSE;
}

//
// Function to open the wmi block.
// INPUT:
//      DeviceId -- the device id
// OUTPUT:
//      TRUE  if the device can be turned off
//      FALSE if the device can not be turned off.
BOOL
CPowerEnable::Open(
    LPCTSTR DeviceId
    )
{
    if (!DeviceId) {
        
        return FALSE;
    }

    //
    // Do nothing if already opened
    //
    if (IsOpened()) {
        
        return TRUE;
    }

    if (lstrlen(DeviceId) >= ARRAYLEN(m_DevInstId) - 2) {
        return FALSE;
    }

    WmiDevInstToInstanceName(m_DevInstId, ARRAYLEN(m_DevInstId), (PTCHAR)DeviceId, 0);

    ULONG Error;
    Error = WmiOpenBlock(&m_wmiGuid, 0, &m_hWmiBlock);
    if (ERROR_SUCCESS == Error) {
        //
        // Get the required block size.
        //
        ULONG BufferSize = 0;
        Error = WmiQuerySingleInstance(m_hWmiBlock, m_DevInstId, &BufferSize, NULL);
        if (BufferSize && Error == ERROR_INSUFFICIENT_BUFFER) {
            //
            // The device does support the GUID, remember the size
            // and allocate a buffer to the data block.
            //
            m_WmiInstDataSize = BufferSize;
            m_pWmiInstData = new BYTE[BufferSize];

            if (m_pWmiInstData) {
                
                Error = WmiQuerySingleInstance(m_hWmiBlock, m_DevInstId, &BufferSize, m_pWmiInstData);
            
            } else {
                
                Error = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (ERROR_SUCCESS == Error &&
                m_DataBlockSize == ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->SizeDataBlock) {
                //
                // Remember the version
                //
                m_Version = ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->WnodeHeader.Version;
                return TRUE;
            }
        }

        Close();
    }

    SetLastError(Error);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devmgr.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    dllinit.cpp

Abstract:

    This module implements the dll related function

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"

LPCTSTR DEVMGR_DEVICEID_SWITCH      = TEXT("DMDeviceId");
LPCTSTR DEVMGR_MACHINENAME_SWITCH   = TEXT("DMMachineName");
LPCTSTR DEVMGR_COMMAND_SWITCH       = TEXT("DMCommand");

//
// DLL main entry point
// INPUT:
//  HINSTANCE hInstance -- module instance handle
//  DWORD     dwReason  -- the reason why we are called.
//  LPVOID    lpReserved -- no used here
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    UNREFERENCED_PARAMETER(lpReserved);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        // we do not need thread attach/detach calls
        DisableThreadLibraryCalls(hInstance);

        if (!SHFusionInitializeFromModule(hInstance)) {
            return FALSE;
        }

        // do must be done
        InitCommonControls();

        // initiailze our global stuff
        InitGlobals(hInstance);

        break;

    case DLL_PROCESS_DETACH:
        // do the clean up here.....
        SHFusionUninitialize();
        break;
    }
    return(TRUE);
}

BOOL InitGlobals(
    HINSTANCE hInstance
    )
{
    g_hInstance = hInstance;
    
    // preload memory allocation error message
    TCHAR tszTemp[256];
    ::LoadString(hInstance, IDS_ERROR_NOMEMORY, tszTemp, ARRAYLEN(tszTemp));
    g_MemoryException.SetMessage(tszTemp);
    ::LoadString(hInstance, IDS_NAME_DEVMGR, tszTemp, ARRAYLEN(tszTemp));
    g_MemoryException.SetCaption(tszTemp);
    
    try
    {
        //preload strings
        g_strDevMgr.LoadString(hInstance, IDS_NAME_DEVMGR);

        // parse the command line and establish machine name and etc
        CDMCommandLine CmdLine;
        CmdLine.ParseCommandLine(GetCommandLine());
        g_strStartupMachineName = CmdLine.GetMachineName();
        g_strStartupDeviceId = CmdLine.GetDeviceId();
        g_strStartupCommand = CmdLine.GetCommand();
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
        return FALSE;
    }

    return TRUE;
}

//
// Overloaded allocation operators
//
void * __cdecl operator new(
    size_t size)
{
    return ((void *)LocalAlloc(LPTR, size));
}

void __cdecl operator delete(
    void *ptr)
{
    LocalFree(ptr);
}

__cdecl _purecall(void)
{
    return (0);
}


//
// Standard APIs for a OLE server. They are all routed to CClassFactory
// support functions
//
//
STDAPI
DllRegisterServer()
{
    return CClassFactory::RegisterAll();
}

STDAPI
DllUnregisterServer()
{
    return CClassFactory::UnregisterAll();
}


STDAPI
DllCanUnloadNow()
{
    return CClassFactory::CanUnloadNow();
}


STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID   riid,
    void**   ppv
    )
{
    return CClassFactory::GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devrmdlg.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    devrmdlg.cpp

Abstract:

    This module implements CRemoveDevDlg -- device removing dialog box

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "hwprof.h"
#include "devrmdlg.h"

//
// help topic ids
//
const DWORD g_a210HelpIDs[]=
{
        IDC_REMOVEDEV_ICON,     IDH_DISABLEHELP,        // Confirm Device Removal: "" (Static)
        IDC_REMOVEDEV_DEVDESC,  IDH_DISABLEHELP,        // Confirm Device Removal: "" (Static)
        IDC_REMOVEDEV_WARNING,  IDH_DISABLEHELP,        // Confirm Device Removal: "" (Static)
        0, 0
};

//
// CRemoveDevDlg implementation
//
BOOL CRemoveDevDlg::OnInitDialog() 
{
    SetDlgItemText(m_hDlg, IDC_REMOVEDEV_DEVDESC, m_pDevice->GetDisplayName());
    HICON hIconOld;
    hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_REMOVEDEV_ICON,
                                         STM_SETICON,
                                         (WPARAM)(m_pDevice->LoadClassIcon()),
                                         0
                                         );
    if (hIconOld)
        DestroyIcon(hIconOld);

    try
    {
        String str;
        str.LoadString(g_hInstance, IDS_REMOVEDEV_WARN);
        SetDlgItemText(m_hDlg, IDC_REMOVEDEV_WARNING, str);
    }
    catch (CMemoryException* e)
    {
        e->Delete();
        return FALSE;
    }

    return TRUE;
}

void
CRemoveDevDlg::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    
    if (BN_CLICKED == HIWORD(wParam))
    {
        if (IDOK == LOWORD(wParam))
        {
            OnOk();
        }
        
        else if (IDCANCEL == LOWORD(wParam))
        {
            EndDialog(m_hDlg, IDCANCEL);
        }
    }
}

void CRemoveDevDlg::OnOk()
{
    SP_REMOVEDEVICE_PARAMS rmdParams;

    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;

    HCURSOR hCursorOld;
    hCursorOld = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    
    //
    // Uninstall does not apply to specific profiles -- it is global.
    //
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;
    
    //
    // walk down the tree and remove all of this device's children
    //
    if (m_pDevice->GetChild() &&
        !IsRemoveSubtreeOk(m_pDevice->GetChild(), &rmdParams))
    {
        //
        // Children refuse the removal. Cancel the removal.
        //
        MsgBoxParam(m_hDlg, IDS_DESCENDANTS_VETO, 0, MB_OK | MB_ICONINFORMATION);
        EndDialog(m_hDlg, IDCANCEL);
        return;
    }

    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);
    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                       &rmdParams.ClassInstallHeader,
                       sizeof(rmdParams));
    
    BOOL RemovalOK;
    
    //
    // Either this device has no children or the children has no
    // objection on removal. Remove it.
    //
    RemovalOK = m_pDevice->m_pMachine->DiCallClassInstaller(DIF_REMOVE, *m_pDevice);
    
    if (hCursorOld)
    {
        SetCursor(hCursorOld);
    }
    
    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice, NULL, 0);
    
    if (RemovalOK)
    {
        EndDialog(m_hDlg, IDOK);
    }
    
    else
    {
        //
        // Can not removed the device, return Cancel so that
        // the caller know what is going on.
        //
        MsgBoxParam(m_hDlg, IDS_UNINSTALL_FAILED, 0, MB_OK | MB_ICONINFORMATION);
        EndDialog(m_hDlg, IDCANCEL);
    }
}

//
// This function walks the substree started with the given CDevice to
// see if it is ok to removed the CDevice.
// INPUT:
//      pDevice  -- the device
//      prmdParams  -- parameter used to call the setupapi
// OUTPUT:
//      TRUE -- it is ok to remove
//      FALSE -- it is NOT ok to remove
BOOL
CRemoveDevDlg::IsRemoveSubtreeOk(
    CDevice* pDevice,
    PSP_REMOVEDEVICE_PARAMS prmdParams
    )
{
    BOOL Result = TRUE;


    HDEVINFO hDevInfo;
    while (Result && pDevice)
    {
        //
        // if the device has children, remove all of them.
        //
        if (Result && pDevice->GetChild())
        {
            Result = IsRemoveSubtreeOk(pDevice->GetChild(), prmdParams);
        }
        
        //
        // create a new HDEVINFO just for this device -- we do not want
        // to change anything in the main device tree maintained by CMachine
        //
        hDevInfo = pDevice->m_pMachine->DiCreateDeviceInfoList(NULL, m_hDlg);
        
        if (INVALID_HANDLE_VALUE == hDevInfo)
        {
            return FALSE;
        }
        
        SP_DEVINFO_DATA DevData;
        DevData.cbSize = sizeof(DevData);
        CDevInfoList DevInfoList(hDevInfo, m_hDlg);
        
        //
        // include the device in the newly created hdevinfo
        //
        DevInfoList.DiOpenDeviceInfo(pDevice->GetDeviceID(), m_hDlg, 0,
                                     &DevData);

        DevInfoList.DiSetClassInstallParams(&DevData,
                                            &prmdParams->ClassInstallHeader,
                                            sizeof(SP_REMOVEDEVICE_PARAMS)
                                            );
        
        //
        // remove this devnode.
        //
        Result = DevInfoList.DiCallClassInstaller(DIF_REMOVE, &DevData);
        DevInfoList.DiSetClassInstallParams(&DevData, NULL, 0);
        
        //
        // continue the query on all the siblings
        //
        pDevice = pDevice->GetSibling();
    }

    return Result;
}

BOOL
CRemoveDevDlg::OnDestroy()
{
    HICON hIcon;

    hIcon = (HICON)SendDlgItemMessage(m_hDlg, IDC_REMOVEDEV_ICON, STM_GETICON, 0, 0);

    if (hIcon) {
        DestroyIcon(hIcon);
    }
    
    return FALSE;
}

BOOL
CRemoveDevDlg::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a210HelpIDs);
    return FALSE;
}

BOOL
CRemoveDevDlg::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a210HelpIDs);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\devrmdlg.h ===
// devrmdlg.h : header file
//

/*++

Copyright (C) Microsoft Corporation

Module Name:

    devrmdlg.h

Abstract:

    header file for devrmdlg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// help topic ids
//

#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_confirmrremoval_listbox  210100  // Confirm Device Removal: "" (Static)
#define idh_devmgr_confirmremoval_all   210110  // Confirm Device Removal: "Remove from &all configurations." (Button)
#define idh_devmgr_confirmremoval_specific  210120  // Confirm Device Removal: "Remove from &specific configuration." (Button)
#define idh_devmgr_confirmremoval_configuration 210130  // Confirm Device Removal: "" (ComboBox)


/////////////////////////////////////////////////////////////////////////////
// CRemoveDevDlg dialog

class CRemoveDevDlg : public CDialog
{
public:
    CRemoveDevDlg(CDevice* pDevice)
    : CDialog(IDD_REMOVE_DEVICE),
      m_pDevice(pDevice)
    {}
    virtual BOOL OnInitDialog();
    virtual void OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnDestroy();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
private:
    void OnOk();
    CDevice*        m_pDevice;
    BOOL IsRemoveSubtreeOk(CDevice* pDevice, PSP_REMOVEDEVICE_PARAMS prmdParams);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\factory.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    cfactory.cpp

Abstract:

    Header file for CFactory.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __CFACTORY_H_
#define __CFACTORY_H_


typedef enum tagdDMClassType{
    DM_CLASS_TYPE_SNAPIN = 0,
    DM_CLASS_TYPE_SNAPIN_EXTENSION,
    DM_CLASS_TYPE_SNAPIN_ABOUT,
    DM_CLASS_TYPE_UNKNOWN
}DM_CLASS_TYPE, *PDM_CLASS_TYPE;

class CClassFactory : public IClassFactory
{
public:

    CClassFactory(DM_CLASS_TYPE ClassType)
    : m_Ref(1), m_ClassType(ClassType)
    {}

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef) ();

    STDMETHOD_(ULONG, Release) ();

    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);

    STDMETHOD(LockServer)(BOOL fLock);

    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
    static HRESULT RegisterAll();
    static HRESULT UnregisterAll();
    static HRESULT CanUnloadNow(void);
    static  LONG    s_Locks;
    static  LONG    s_Objects;

private:
    LONG    m_Ref;
    DM_CLASS_TYPE  m_ClassType;
};

#endif // __CFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\genpage.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    genpage.cpp

Abstract:

    This module implements CGeneralPage -- the snapin startup wizard page

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "genpage.h"

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

const DWORD g_a102HelpIDs[]=
{
    IDC_GENERAL_SELECT_TEXT, IDH_DISABLEHELP,
    IDC_GENERAL_SELECTGROUP, IDH_DISABLEHELP,
    IDC_GENERAL_OVERRIDE_MACHINENAME, idh_devmgr_manage_command_line,   // Device Manager: "Allo&w the selected computer to be changed when launching from the command line.  This only applies if you save the console." (Button)
    IDC_GENERAL_LOCALMACHINE, idh_devmgr_manage_local,                  // Device Manager: "&Local computer:  (the computer this console is running on)" (Button)
    IDC_GENERAL_OTHERMACHINE, idh_devmgr_manage_remote,                 // Device Manager: "&Another computer:" (Button)
    IDC_GENERAL_MACHINENAME, idh_devmgr_manage_remote_name,             // Device Manager: "" (Edit)
    IDC_GENERAL_BROWSE_MACHINENAMES, idh_devmgr_manage_remote_browse,   // Device Manager: "B&rowse..." (Button)
    0, 0
};

CGeneralPage::CGeneralPage() :  CPropSheetPage(g_hInstance, IDD_GENERAL_PAGE)

{
    m_lConsoleHandle = 0;
    m_pstrMachineName = NULL;
    m_pct = NULL;
    m_MachineName[0] = _T('\0');
    m_IsLocalMachine = TRUE;
    m_ct = COOKIE_TYPE_SCOPEITEM_DEVMGR;
}


HPROPSHEETPAGE
CGeneralPage::Create(
    LONG_PTR lConsoleHandle
    )
{
    m_lConsoleHandle = lConsoleHandle;
    // override PROPSHEETPAGE structure here...
    m_psp.lParam = (LPARAM)this;
    return CPropSheetPage::CreatePage();
}

BOOL
CGeneralPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    UNREFERENCED_PARAMETER(ppsp);
    
    ASSERT(m_hDlg);

    //
    // Intiallly, enable the local machine and disable the
    // "Another" machine.
    //
    ::CheckDlgButton(m_hDlg, IDC_GENERAL_LOCALMACHINE, BST_CHECKED);
    ::CheckDlgButton(m_hDlg, IDC_GENERAL_OTHERMACHINE, BST_UNCHECKED);
    ::EnableWindow(GetControl(IDC_GENERAL_MACHINENAME), FALSE);

    //
    // Default is local machine. Since everything is valid at the beginning, 
    // we have to enable the finish button.
    //
    ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
    ::ShowWindow(GetControl(IDC_GENERAL_OVERRIDE_MACHINENAME), SW_HIDE);
    ::EnableWindow(GetControl(IDC_GENERAL_BROWSE_MACHINENAMES), FALSE);

    return TRUE;
}

BOOL
CGeneralPage::OnReset(
    void
    )
{
    m_MachineName[0] = _T('\0');
    m_ct = COOKIE_TYPE_SCOPEITEM_DEVMGR;
    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
    return FALSE;
}

BOOL
CGeneralPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (LOWORD(wParam)) {
    case IDC_GENERAL_LOCALMACHINE:
        if (BN_CLICKED == HIWORD(wParam)) {

            ::EnableWindow(GetControl(IDC_GENERAL_BROWSE_MACHINENAMES), FALSE);
            ::EnableWindow(GetControl(IDC_GENERAL_MACHINENAME), FALSE);
            ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
            m_IsLocalMachine = TRUE;
            return TRUE;
        }
        break;

    case IDC_GENERAL_OTHERMACHINE:
        if (BN_CLICKED == HIWORD(wParam)) {

            ::EnableWindow(GetControl(IDC_GENERAL_BROWSE_MACHINENAMES), TRUE);
            ::EnableWindow(GetControl(IDC_GENERAL_MACHINENAME), TRUE);

            if (GetWindowTextLength(GetControl(IDC_GENERAL_MACHINENAME))) {
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
            } else {
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_DISABLEDFINISH);
            }
            m_IsLocalMachine = FALSE;
            return TRUE;
        }
        break;

    case IDC_GENERAL_MACHINENAME:
        if (EN_CHANGE == HIWORD(wParam)) {
            //
            // Edit control change, see if there is any text in the
            // control at all. It there is, enable the finish button,
            // otherwise, disable it.
            //
            if (GetWindowTextLength((HWND)lParam)) {
                //
                // There is some text in the edit control enable the finish 
                // button
                //
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
            
            } else {
                //
                // No text in the edit control disable the finish button
                //
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_DISABLEDFINISH);
            }
        }
        break;

    case IDC_GENERAL_BROWSE_MACHINENAMES:
        DoBrowse();
        return TRUE;
        break;
    }

    return FALSE;
}

BOOL
CGeneralPage::OnWizFinish(
    void
    )
{
    BOOL bSuccess = TRUE;    
    
    //
    // First figure out the machine name
    //
    m_MachineName[0] = _T('\0');
    if (!m_IsLocalMachine)
    {
        GetWindowText(GetControl(IDC_GENERAL_MACHINENAME), m_MachineName,
                      ARRAYLEN(m_MachineName));

        if (_T('\0') != m_MachineName[0])
        {
            if (_T('\\') != m_MachineName[0])
            {
                //
                // Insert machine name signature to the fron of the name
                //
                int len = lstrlen(m_MachineName);

                if (len + 2 < ARRAYLEN(m_MachineName))
                {
                    //
                    // Move the existing string so that we can insert
                    // the signature in the first two locations.
                    // the move includes the terminated null char.
                    // Note: when moving characters two places we need to make
                    // sure we don't blow out the buffer.
                    //
                    for (int i = len + 2; i >= 2; i--) {

                        m_MachineName[i] = m_MachineName[i - 2];
                    }

                    m_MachineName[0] = _T('\\');
                    m_MachineName[1] = _T('\\');
                }
            }

            //
            // Now verify the machine name. If the machine name is invalid
            // or can be reached, use the local computer;
            //
            if (!VerifyMachineName(m_MachineName))
            {
                String strWarningFormat;
                String strWarningMessage;
                LPVOID lpLastError = NULL;

                bSuccess = FALSE;

                if (strWarningFormat.LoadString(g_hInstance, IDS_INVALID_COMPUTER_NAME) &&
                    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_SYSTEM | 
                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                  NULL,
                                  HRESULT_FROM_SETUPAPI(GetLastError()),
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPTSTR)&lpLastError,
                                  0,
                                  NULL)) {

                    strWarningMessage.Format((LPTSTR)strWarningFormat,
                                             m_MachineName,
                                             lpLastError);

                    MessageBox(m_hDlg,
                               (LPTSTR)strWarningMessage,
                               (LPCTSTR)g_strDevMgr,
                               MB_ICONERROR | MB_OK
                               );
                }

                if (lpLastError) {
                    LocalFree(lpLastError);
                }
            }
        }
    }

    try
    {
        //
        // Only tell the console, or the caller, about the new machine name,
        // if we were able to successfully get one, it was valid, and we
        // have access to it.
        //
        if (bSuccess) {
            if (m_lConsoleHandle)
            {
                //
                // A console handle is created for the property sheet,
                // use the handle to notify the snapin about the new
                // startup information.
                //
                BufferPtr<BYTE> Buffer(sizeof(PROPERTY_CHANGE_INFO) + sizeof(STARTUP_INFODATA));
                PPROPERTY_CHANGE_INFO pPCI = (PPROPERTY_CHANGE_INFO)(BYTE*)Buffer;
                PSTARTUP_INFODATA pSI = (PSTARTUP_INFODATA)&pPCI->InfoData;
        
                if ((_T('\0') != m_MachineName[0]) &&
                    FAILED(StringCchCopy(pSI->MachineName, ARRAYLEN(pSI->MachineName), m_MachineName))) {
                    //
                    // This shouldn't happen, since everywhere else in this code
                    // machine names can't be larger than MAX_PATH, but we'll
                    // assert, and handle this case, just in case.
                    //
                    ASSERT(lstrlen(m_MachineName) < ARRAYLEN(pSI->MachineName));
                    bSuccess = FALSE;
                }
        
                if (bSuccess) {
                    pSI->ct = m_ct;
                    pSI->Size = sizeof(STARTUP_INFODATA);
                    pPCI->Type = PCT_STARTUP_INFODATA;
            
                    //
                    // Notify IComponentData about what we have here.
                    //
                    MMCPropertyChangeNotify(m_lConsoleHandle, reinterpret_cast<LONG_PTR>(&pPCI));
                }
            }
        
            else if (m_pstrMachineName && m_pct)
            {
                //
                // No console is provided for the property sheet.
                // send the new startup info in the given buffer if it is
                // provided.
                //
                *m_pstrMachineName = m_MachineName;
                *m_pct = m_ct;
            }
        
            else
            {
                //
                // Nobody is listening to what we have to say. Something must be
                // wrong!
                //
                ASSERT(FALSE);
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }

    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, bSuccess ? 0L : -1L);

    return TRUE;
}


BOOL
CGeneralPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a102HelpIDs);

    return FALSE;
}


BOOL
CGeneralPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
        (ULONG_PTR)g_a102HelpIDs);

    return FALSE;
}

void
CGeneralPage::DoBrowse(
    void
    )
{
    HRESULT hr;
    static const int SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //
    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //
    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //
    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;
    bool fGotStgMedium = false;
    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);

    hr = pDsObjectPicker->Initialize(&InitInfo);

    hr = pDsObjectPicker->InvokeDialog(m_hDlg, &pdo);

    if (hr != S_FALSE)
    {
        FORMATETC formatetc =
        {
            (CLIPFORMAT)g_cfDsObjectPicker,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };
    
        hr = pdo->GetData(&formatetc, &stgmedium);
    
        fGotStgMedium = true;
    
        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
    
        if (pDsSelList)
        {
            ASSERT(pDsSelList->cItems == 1);
        
            //
            // Put the machine name in the edit control
            //
            ::SetDlgItemText(m_hDlg, IDC_GENERAL_MACHINENAME, pDsSelList->aDsSelection[0].pwzName);
        
            GlobalUnlock(stgmedium.hGlobal);
        }
    }

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\genpage.h ===
// genpage.h : header file
//

#ifndef __GENPAGE_H__
#define __GENPAGE_H__
/*++

Copyright (C) Microsoft Corporation

Module Name:

    devgenpg.h

Abstract:

    header file for genpage.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"

//
// context help id
//
#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_manage_command_line  102170  // Device Manager: "Allo&w the selected computer to be changed when launching from the command line.  This only applies if you save the console." (Button)
#define idh_devmgr_view_devicetree  102110  // Device Manager: "&Device tree" (Button)
#define idh_devmgr_manage_local 102130  // Device Manager: "&Local computer:  (the computer this console is running on)" (Button)
#define idh_devmgr_manage_remote    102140  // Device Manager: "&Another computer:" (Button)
#define idh_devmgr_manage_remote_name   102150  // Device Manager: "" (Edit)
#define idh_devmgr_view_all 102100  // Device Manager: "&All" (Button)
#define idh_devmgr_manage_remote_browse 102160  // Device Manager: "B&rowse..." (Button)
#define idh_devmgr_view_resources   102120  // Device Manager: "&Resources" (Button)


class CGeneralPage : public CPropSheetPage
{
public:
    CGeneralPage();
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnReset();
    virtual BOOL OnWizFinish();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    HPROPSHEETPAGE Create(LONG_PTR lConsoleHandle);
    void SetOutputBuffer(String* pstrMachineName, COOKIE_TYPE* pct)
    {
        m_pstrMachineName = pstrMachineName;
        m_pct = pct;
    }
    void DoBrowse();
private:
    LONG_PTR m_lConsoleHandle;
    TCHAR   m_MachineName[MAX_PATH + 3];
    COOKIE_TYPE m_ct;
    String* m_pstrMachineName;
    COOKIE_TYPE* m_pct;
    BOOL    m_IsLocalMachine;
};

#endif  // __GENPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\events.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    events.cpp

Abstract:

    implementation of CComponent functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"



HRESULT CComponent::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    UNREFERENCED_PARAMETER(param);

    //
    // Note - arg is TRUE when it is time to enumerate
    //
    CFolder* pFolder = FindFolder(cookie);
    
    if (arg) {

        m_pCurFolder = pFolder;
    }

    if (pFolder) {
    
        return pFolder->OnShow((BOOL)arg);

    } else {
    
        return S_OK;
    }
}

HRESULT CComponent::OnMinimize(
    MMC_COOKIE cookie, 
    LPARAM arg, 
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}

HRESULT CComponent::OnViewChange(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}

HRESULT CComponent::OnProperties(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}

HRESULT CComponent::OnResultItemClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}

HRESULT CComponent::OnResultItemDblClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_FALSE;
}

HRESULT CComponent::OnActivate(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);

    return S_OK;
}

HRESULT CComponent::OnSelect(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(param);
    
    CFolder* pFolder;
    pFolder  = FindFolder(cookie);
    
    if (pFolder && LOWORD(arg)) {

        //
        // LOWORD(arg) being set indicated this is for the scope pane item.
        // Save the bSelect value for use by the MenuCommand.
        //
        pFolder->m_bSelect = (BOOL) HIWORD(arg);
    }

    if (!pFolder || S_FALSE == pFolder->OnSelect()) {

        //
        // either we can not find the responsible folder
        // or the responsible folder asks us to do it,
        // set the console verb to its defaults
        //
        m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }

    return S_OK;
}

HRESULT CComponent::OnOcxNotify(
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param
    )
{
    //TRACE1(TEXT("Componet:OnOcxNotify, event = %lx\n"), event);

    if (m_pCurFolder) {
    
        return m_pCurFolder->OnOcxNotify(event, arg, param);
    }

    return S_OK;
}

HRESULT CComponent::OnBtnClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);

    return S_OK;
}

HRESULT CComponent::OnAddImages(
    MMC_COOKIE  cookie,
    IImageList* pIImageList,
    HSCOPEITEM hScopeItem
    )
{
    UNREFERENCED_PARAMETER(hScopeItem);

    if (!cookie) {

        return LoadScopeIconsForResultPane(pIImageList);
    }

    return S_OK;
}

HRESULT CComponent::OnRestoreView(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(arg);

    if (!param) {

        return E_INVALIDARG;
    }

    CFolder* pFolder;
    pFolder = FindFolder(cookie);
    
    if (pFolder) {
    
        return pFolder->OnRestoreView((BOOL*)param);

    } else {
        
        *((BOOL *)param) = FALSE;
        return S_OK;
    }
}

HRESULT CComponent::OnContextHelp(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    String strHelpOverview;
    String strHelpTopic;

    //
    // Load help file and overview topic strings.
    //
    strHelpOverview.LoadString(g_hInstance, IDS_HTMLHELP_NAME);
    strHelpTopic.LoadString(g_hInstance, IDS_HTMLHELP_OVERVIEW_TOPIC);

    strHelpOverview += TEXT("::");
    strHelpOverview += strHelpTopic;
    return m_pDisplayHelp->ShowTopic(const_cast<BSTR>((LPCTSTR)strHelpOverview));
}

HRESULT CComponent::LoadScopeIconsForResultPane(
    IImageList* pIImageList
    )
{
    if (pIImageList) {

        HICON hIcon;
        HRESULT hr = S_OK;
        hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR));
        
        if (hIcon) {

            hr = pIImageList->ImageListSetIcon((PLONG_PTR)hIcon, IMAGE_INDEX_DEVMGR);
            DeleteObject(hIcon);
        }

        return hr;
    
    } else {

        return E_INVALIDARG;
    }
}

#if DBG
TCHAR *tvNotifyStr[] = {
    TEXT("CLICK"),
    TEXT("DBLCLK"),
    TEXT("RCLICK"),
    TEXT("RDBLCLK"),
    TEXT("KEYDOWN"),
    TEXT("CONTEXTMENU"),
    TEXT("EXPANDING"),
    TEXT("EXPANDED"),
    TEXT("SELCHANGING"),
    TEXT("SELCHANGED"),
    TEXT("GETDISPINFO"),
    TEXT("FOCUSCHANGED"),
    TEXT("UNKNOWN")
    };
#endif

HRESULT CComponent::tvNotify(
    HWND hwndTV,
    MMC_COOKIE cookie,
    TV_NOTIFY_CODE Code,
    LPARAM arg,
    LPARAM param
    )
{

#if DBG
    int i = Code;
    
    if (Code > TV_NOTIFY_CODE_UNKNOWN) {
        
        i = TV_NOTIFY_CODE_UNKNOWN;
    }

    //TRACE((TEXT("Componet:tvNotify, Code = %lx %s cookie = %lx\n"), Code, tvNotifyStr[i], cookie));
#endif

    CFolder* pFolder;

    pFolder = FindFolder(cookie);
    
    if (pFolder) {
        
        return pFolder->tvNotify(hwndTV, GetActiveCookie(cookie), Code, arg, param);
    }

    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////
//// IComponentData events handlers
////


HRESULT
CComponentData::OnProperties(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}

HRESULT
CComponentData::OnBtnClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}
HRESULT
CComponentData::OnDelete(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);
    
    return S_OK;
}
HRESULT
CComponentData::OnRename(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);

    return S_OK;
}

//
// This function handles the MMCN_EXPAND notification code
// Input: lpDataObject -- point to the target IDataObject
//        arg          -- TRUE if expanding, FALSE if collapsing.
//        param        -- not used.
//
// Output: HRESULT
HRESULT
CComponentData::OnExpand(
    LPDATAOBJECT lpDataObject,
    LPARAM arg,
    LPARAM param
    )
{
    INTERNAL_DATA tID;
    HRESULT hr;

    //
    // If we are not expanding, do nothing
    //
    if (!arg) {
    
        return S_OK;
    }

    hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         (PBYTE)&tID, sizeof(tID));
    
    if (SUCCEEDED(hr)) {
        
        hr = CreateScopeItems();
        
        if (SUCCEEDED(hr) && !m_pMachine) {
            
            if (!g_MachineList.CreateMachine(m_strMachineName, &m_pMachine)) {
                
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if (SUCCEEDED(hr)) {

            CCookie* pCookie = GetActiveCookie(tID.cookie);
            ASSERT(pCookie);
            HSCOPEITEM hScopeParent = (HSCOPEITEM)param;
            CScopeItem* pScopeItem = pCookie->GetScopeItem();
            ASSERT(pScopeItem);
            pScopeItem->SetHandle(hScopeParent);

            //
            // If we have children and this is the first time we
            // are expanding, insert all the children to scope pane.
            //
            if (pCookie->GetChild() && !pScopeItem->IsEnumerated()) {

                SCOPEDATAITEM ScopeDataItem;

                CCookie* pTheCookie = pCookie->GetChild();
                
                do {

                    CScopeItem* pTheItem = pTheCookie->GetScopeItem();
                    ASSERT(pTheItem);
                    ScopeDataItem.relativeID = hScopeParent;
                    ScopeDataItem.nState = 0;
                    ScopeDataItem.displayname = (LPOLESTR)(-1);
                    ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN |
                                         SDI_STR | SDI_PARAM | SDI_STATE;
                    ScopeDataItem.nImage = pTheItem->GetImageIndex();
                    ScopeDataItem.nOpenImage = pTheItem->GetOpenImageIndex();
                    ScopeDataItem.cChildren = pTheItem->GetChildCount();
                    ScopeDataItem.lParam = reinterpret_cast<LPARAM>(pTheCookie);
                    
                    hr = m_pScope->InsertItem(&ScopeDataItem);
                    
                    if (FAILED(hr)) {
                    
                        break;
                    }
                    
                    pTheItem->SetHandle(ScopeDataItem.ID);
                    pTheCookie = pTheCookie->GetSibling();

                } while (pTheCookie);
            }

            pScopeItem->Enumerated();
        }
    }

    else {

        //
        // The provided lpDataObject is not ours, we are being
        // expanded as an extension snapin. Find out what
        // node type the data object is. If it is "MyComputer"
        // system tools, attach our scope items to
        // it.
        //

        CLSID   CLSID_NodeType;
        hr = ExtractData(lpDataObject, CDataObject::m_cfNodeType,
                         (PBYTE)&CLSID_NodeType, sizeof(CLSID_NodeType));
        
        if (FAILED(hr)) {
        
            return hr;
        }

        if (CLSID_SYSTOOLS == CLSID_NodeType) {

            TCHAR MachineName[MAX_PATH + 1];
            MachineName[0] = _T('\0');
            hr = ExtractData(lpDataObject, CDataObject::m_cfMachineName,
                             (BYTE*)MachineName, sizeof(MachineName));
            
            if (SUCCEEDED(hr)) {

                m_ctRoot = COOKIE_TYPE_SCOPEITEM_DEVMGR;

                m_strMachineName.Empty();
                
                if (_T('\0') != MachineName[0]) {

                    if (_T('\\') != MachineName[0]) {

                        m_strMachineName = TEXT("\\\\");
                    }

                    m_strMachineName += MachineName;
                }

                hr = CreateScopeItems();
                
                if (SUCCEEDED(hr)) {

                    CMachine* pMachine;
                    pMachine = g_MachineList.FindMachine(m_strMachineName);
                    
                    if (!pMachine || pMachine != m_pMachine) {

                        if (!g_MachineList.CreateMachine(m_strMachineName, &m_pMachine)) {

                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }
                }
            }

            if (SUCCEEDED(hr)) {

                //
                // Always insert "Device Manager" node because
                // we are expanding as an extention to Computer Management
                //
                CCookie* pCookie = GetActiveCookie(0);
                ASSERT(pCookie);
                CScopeItem* pScopeItem = pCookie->GetScopeItem();
                ASSERT(pScopeItem);
                SCOPEDATAITEM ScopeDataItem;
                memset(&ScopeDataItem, 0, sizeof(ScopeDataItem));
                ScopeDataItem.relativeID = (HSCOPEITEM)(param);
                ScopeDataItem.nState = 0;
                ScopeDataItem.displayname = (LPOLESTR)(-1);
                ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN |
                                     SDI_STR | SDI_PARAM | SDI_STATE;
                ScopeDataItem.nImage = pScopeItem->GetImageIndex();
                ScopeDataItem.nOpenImage = pScopeItem->GetOpenImageIndex();
                ScopeDataItem.cChildren = pScopeItem->GetChildCount();
                ScopeDataItem.lParam = reinterpret_cast<LPARAM>(pCookie);
                hr = m_pScope->InsertItem(&ScopeDataItem);
                pScopeItem->SetHandle(ScopeDataItem.ID);
            }
        }
    }

    return hr;
}

HRESULT
CComponentData::OnContextMenu(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    UNREFERENCED_PARAMETER(cookie);
    UNREFERENCED_PARAMETER(arg);
    UNREFERENCED_PARAMETER(param);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\factory.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    factory.cpp

Abstract:

    This module implements CClassFactory class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"
#include "about.h"



const TCHAR* const REG_MMC_SNAPINS              = TEXT("Software\\Microsoft\\MMC\\Snapins");
const TCHAR* const REG_MMC_NODETYPE             = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR* const MMC_NAMESTRING               = TEXT("NameString");
const TCHAR* const MMC_NAMESTRINGINDIRECT       = TEXT("NameStringIndirect");
const TCHAR* const MMC_PROVIDER                 = TEXT("Provider");
const TCHAR* const MMC_VERSION                  = TEXT("Version");
const TCHAR* const MMC_NODETYPES                = TEXT("NodeTypes");
const TCHAR* const MMC_STANDALONE               = TEXT("StandAlone");
const TCHAR* const MMC_EXTENSIONS               = TEXT("Extensions");
const TCHAR* const MMC_NAMESPACE                = TEXT("NameSpace");
const TCHAR* const MMC_ABOUT                    = TEXT("About");
const TCHAR* const REG_INPROCSERVER32           = TEXT("InprocServer32");
const TCHAR* const REG_THREADINGMODEL           = TEXT("ThreadingModel");
const TCHAR* const REG_CLSID                    = TEXT("CLSID");
const TCHAR* const REG_PROGID                   = TEXT("ProgId");
const TCHAR* const REG_VERSIONINDEPENDENTPROGID = TEXT("VersionIndependentProgId");
const TCHAR* const APARTMENT                    = TEXT("Apartment");


//
// CClassFactory implmentation
//
LONG CClassFactory::s_Locks = 0;
LONG CClassFactory::s_Objects = 0;

ULONG
CClassFactory::AddRef()
{
    return ::InterlockedIncrement(&m_Ref);
}

ULONG
CClassFactory::Release()
{
    ASSERT( 0 != m_Ref );
    ULONG cRef = ::InterlockedDecrement(&m_Ref);    
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP
CClassFactory::QueryInterface(
    REFIID riid,
    LPVOID*  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IClassFactory *)this;
    }

    else if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IUnknown *)(IClassFactory *)this;
    }

    else
    {
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    else
    {
        *ppv = NULL;
    }

    return hr;
}


STDMETHODIMP
CClassFactory::CreateInstance(
    IUnknown    *pUnkOuter,
    REFIID      riid,
    LPVOID      *ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *ppv = NULL;

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }

    try
    {
        switch (m_ClassType)
        {
        case DM_CLASS_TYPE_SNAPIN:
            {
                // create the factory with the request class(class type).
                // When a new OLE object is created, it initializes its
                // ref count to 1. We do a release right after the QI
                // so that if the QI failed, the object will be self-destructed
                CComponentData* pCompData = new CComponentDataPrimary();
                hr = pCompData->QueryInterface(riid, ppv);
                pCompData->Release();
                break;
            }
            
        case DM_CLASS_TYPE_SNAPIN_EXTENSION:
            {
                // create the factory with the request class(class type).
                // When a new OLE object is created, it initializes its
                // ref count to 1. We do a release right after the QI
                // so that if the QI failed, the object will be self-destructed
                CComponentData* pCompData = new CComponentDataExtension();
                hr = pCompData->QueryInterface(riid, ppv);
                pCompData->Release();
                break;
            }
            
        case DM_CLASS_TYPE_SNAPIN_ABOUT:
            {
                // create the factory with the request class(class type).
                // When a new OLE object is created, it initializes its
                // ref count to 1. We do a release right after the QI
                // so that if the QI failed, the object will be self-destructed
                CDevMgrAbout* pAbout = new CDevMgrAbout;
                hr = pAbout->QueryInterface(riid, ppv);
                pAbout->Release();
                break;
            }
            
        default:
            {
                hr = E_NOINTERFACE;
            }
        }
    }

    catch (CMemoryException* e)
    {
        hr = E_OUTOFMEMORY;
        e->Delete();
    }

    return hr;
}



STDMETHODIMP
CClassFactory::LockServer(
    BOOL fLock
    )
{
    if (fLock)
    {
        ::InterlockedIncrement((LONG*)&s_Locks);
    }    
    else
    {
        ASSERT( 0 != s_Locks );
        ::InterlockedDecrement((LONG*)&s_Locks);
    }
    
    return S_OK;
}

HRESULT
CClassFactory::CanUnloadNow()
{
    return (s_Objects || s_Locks) ? S_FALSE : S_OK;
}


//
// This function create a CClassFactory. It is mainly called
// by DllGetClassObject API
// INPUT:
//  rclsid  -- reference to the CLSID
//  riid    -- reference to the interface IID
//  ppv -- interface pointer holder
//
// OUTPUT:
//  S_OK if succeeded else standard OLE error code
//
//
HRESULT
CClassFactory::GetClassObject(
    REFCLSID rclsid,
    REFIID   riid,
    void**   ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;
    HRESULT hr = S_OK;
    DM_CLASS_TYPE ClassType;
    
    //
    // determine the class type so that CreateInstance will be
    // creating the right object. We use a single class factory
    // to create all the object types.
    //
    if (IsEqualCLSID(rclsid, CLSID_DEVMGR))
    {
        ClassType = DM_CLASS_TYPE_SNAPIN;
    }

    else if (IsEqualCLSID(rclsid, CLSID_DEVMGR_EXTENSION))
    {
        ClassType = DM_CLASS_TYPE_SNAPIN_EXTENSION;
    }

    else if (IsEqualCLSID(rclsid, CLSID_DEVMGR_ABOUT))
    {
        ClassType = DM_CLASS_TYPE_SNAPIN_ABOUT;
    }

    else
    {
        ClassType = DM_CLASS_TYPE_UNKNOWN;
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        CClassFactory* pUnk;
        // guard memory allocation error because we do not want
        // to cause an execption here.
        
        try
        {
            // create the factory with the request class(class type).
            // When a new OLE object is created, it initializes its
            // ref count to 1. We do a release right after the QI
            // so that if the QI failed, the object will be self-destructed
    
            pUnk = new CClassFactory(ClassType);
            hr = pUnk->QueryInterface(riid, ppv);
            pUnk->Release();
        }
        
        catch (CMemoryException* e)
        {
            e->Delete();
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}

//
// This function registers the dll to MMC
//
HRESULT
CClassFactory::RegisterAll()
{
    BOOL Result;
    TCHAR szText[MAX_PATH];
    TCHAR ModuleName[MAX_PATH];
    GetModuleFileName(g_hInstance, ModuleName, ARRAYLEN(ModuleName));

    Result = FALSE;
    szText[0] = TEXT('\0');
    
    // first register standalone snapin CLSID
    CSafeRegistry regRootCLSID;
    
    if (regRootCLSID.Open(HKEY_CLASSES_ROOT, REG_CLSID))
    {
        CSafeRegistry regCLSID;
        
        // register our CLSID to HKEY_CLASS_ROOT\CLSID
        if (regCLSID.Create(regRootCLSID, CLSID_STRING_DEVMGR))
        {
            // write the description
            ::LoadString(g_hInstance, IDS_DESC_DEVMGR, szText, ARRAYLEN(szText));
            if (regCLSID.SetValue(NULL, szText))
            {
                CSafeRegistry regServer;
                
                if (regServer.Create(regCLSID, REG_INPROCSERVER32) &&
                    regServer.SetValue(NULL, ModuleName) &&
                    regServer.SetValue(REG_THREADINGMODEL, APARTMENT))
                {
                    CSafeRegistry regProgId;
                    
                    if (regProgId.Create(regCLSID, REG_PROGID) &&
                        regProgId.SetValue(NULL, PROGID_DEVMGR))
                    {
                        CSafeRegistry regVerIndProgId;
                        
                        if (regVerIndProgId.Create(regCLSID, REG_VERSIONINDEPENDENTPROGID))
                        {
                            Result = regVerIndProgId.SetValue(NULL, PROGID_DEVMGR);
                        }
                    }
                }
            }
        }
        
        if (Result)
        {
            regCLSID.Close();
            Result = FALSE;
            
            // register extension snapin CLSID
            if (regCLSID.Create(regRootCLSID, CLSID_STRING_DEVMGR_EXTENSION))
            {
                ::LoadString(g_hInstance, IDS_EXTENSION_DESC, szText, ARRAYLEN(szText));
                
                if (regCLSID.SetValue(NULL, szText))
                {
                    CSafeRegistry regServer;
                    
                    if (regServer.Create(regCLSID, REG_INPROCSERVER32)&&
                        regServer.SetValue(NULL, ModuleName) &&
                        regServer.SetValue(REG_THREADINGMODEL, APARTMENT))
                    {
                        CSafeRegistry regProgId;
                        
                        if (regProgId.Create(regCLSID, REG_PROGID) &&
                            regProgId.SetValue(NULL, PROGID_DEVMGREXT))
                        {
                            CSafeRegistry regVerIndProgId;
                            
                            if (regVerIndProgId.Create(regCLSID, REG_VERSIONINDEPENDENTPROGID))
                            {
                                Result = regVerIndProgId.SetValue(NULL, PROGID_DEVMGREXT);
                            }
                        }
                    }
                }
            }
        }

        if (Result)
        {
            regCLSID.Close();
            Result = FALSE;
            
            // register snapin about CLSID
            if (regCLSID.Create(regRootCLSID, CLSID_STRING_DEVMGR_ABOUT))
            {
                ::LoadString(g_hInstance, IDS_ABOUT_DEVMGR, szText, ARRAYLEN(szText));
                
                if (regCLSID.SetValue(NULL, szText))
                {
                    CSafeRegistry regServer;
                    
                    if (regServer.Create(regCLSID, REG_INPROCSERVER32)&&
                        regServer.SetValue(NULL, ModuleName) &&
                        regServer.SetValue(REG_THREADINGMODEL, APARTMENT))
                    {
                        CSafeRegistry regProgId;
                        
                        if (regProgId.Create(regCLSID, REG_PROGID) &&
                            regProgId.SetValue(NULL, PROGID_DEVMGR_ABOUT))
                        {
                            CSafeRegistry regVerIndProgId;
                            
                            if (regVerIndProgId.Create(regCLSID, REG_VERSIONINDEPENDENTPROGID))
                            {
                                Result = regVerIndProgId.SetValue(NULL, PROGID_DEVMGR_ABOUT);
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (Result)
    {
        Result = FALSE;
        CSafeRegistry regSnapins;
        
        //
        // open mmc snapin subkey
        //
        if (regSnapins.Open(HKEY_LOCAL_MACHINE, REG_MMC_SNAPINS))
        {
            PNODEINFO pniDevMgr = (PNODEINFO)&NodeInfo[COOKIE_TYPE_SCOPEITEM_DEVMGR];
            CSafeRegistry regDevMgr;
            
            if (regDevMgr.Create(regSnapins, CLSID_STRING_DEVMGR))
            {
                StringCchPrintf(szText, ARRAYLEN(szText), TEXT("@%s,-%d"), ModuleName, IDS_DESC_DEVMGR);
                if (regDevMgr.SetValue(MMC_NAMESTRINGINDIRECT, szText))
                {
                    ::LoadString(g_hInstance, pniDevMgr->idsName, szText, ARRAYLEN(szText));
                    
                    if (regDevMgr.SetValue(MMC_NAMESTRING, szText))
                    {
                        ::LoadString(g_hInstance, IDS_PROGRAM_PROVIDER, szText, ARRAYLEN(szText));
                        
                        if (regDevMgr.SetValue(MMC_PROVIDER, szText))
                        {
                            ::LoadString(g_hInstance, IDS_PROGRAM_VERSION, szText, ARRAYLEN(szText));
                            
                            if (regDevMgr.SetValue(MMC_VERSION, szText) &&
                                regDevMgr.SetValue(MMC_ABOUT, CLSID_STRING_DEVMGR_ABOUT))
                            {
                                //
                                // Let MMC knows that we are a standalone snapin --
                                // meaning we do not need any extension snapins for us
                                // to run.
                                //
                                CSafeRegistry regStandAlone;
                                Result = regStandAlone.Create(regDevMgr, MMC_STANDALONE);
                            }
                        }
                    }
                }
            }

            CSafeRegistry regMMCNodeTypes;
            
            if (Result)
            {
                // populate our nodes
                Result = regMMCNodeTypes.Open(HKEY_LOCAL_MACHINE, REG_MMC_NODETYPE);
                
                if (Result)
                {
                    CSafeRegistry regTheNode;
                    int i = NODETYPE_FIRST;
                    
                    do
                    {
                        PNODEINFO pni = (PNODEINFO) &NodeInfo[i];
                        Result = regTheNode.Create(regMMCNodeTypes, pni->GuidString);
                        regTheNode.Close();
                    } while (Result && ++i <= NODETYPE_LAST);
                }
            }
            
            if (Result)
            {
                // register as an extension to Computer management snapin
                CSafeRegistry regDevMgrExt;
                
                if (regDevMgrExt.Create(regSnapins, CLSID_STRING_DEVMGR_EXTENSION))
                {
                    ::LoadString(g_hInstance, IDS_EXTENSION_DESC, szText, ARRAYLEN(szText));
                    
                    if (regDevMgrExt.SetValue(MMC_NAMESTRING, szText))
                    {
                        ::LoadString(g_hInstance, IDS_PROGRAM_PROVIDER, szText, ARRAYLEN(szText));
                        
                        if (regDevMgrExt.SetValue(MMC_PROVIDER, szText))
                        {
                            ::LoadString(g_hInstance, IDS_PROGRAM_VERSION, szText, ARRAYLEN(szText));
                            
                            if (regDevMgrExt.SetValue(MMC_VERSION, szText) &&
                               regDevMgrExt.SetValue(MMC_ABOUT, CLSID_STRING_DEVMGR_ABOUT))
                            {
                                CSafeRegistry regSysTools;
                                
                                if (regSysTools.Open(regMMCNodeTypes, CLSID_STRING_SYSTOOLS))
                                {
                                    CSafeRegistry regExtensions;
                                    
                                    if (regExtensions.Open(regSysTools,MMC_EXTENSIONS))
                                    {
                                        CSafeRegistry regNameSpace;
                                        
                                        if (regNameSpace.Open(regExtensions, MMC_NAMESPACE))
                                        {
                                            // add our guid as a value of Name space
                                            Result = regNameSpace.SetValue(CLSID_STRING_DEVMGR_EXTENSION, szText);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (!Result)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        UnregisterAll();
        return hr;
    }
    
    return S_OK;
}

//
// This function unregisters the dll from MMC
//
HRESULT
CClassFactory::UnregisterAll()
{

    CSafeRegistry regSnapins;
    
    //
    // open mmc snapin subkey
    //
    if (regSnapins.Open(HKEY_LOCAL_MACHINE, REG_MMC_SNAPINS))
    {
        // remove devmgr subkey from MMC snapins main key
        // both primary and extension
        regSnapins.DeleteSubkey(CLSID_STRING_DEVMGR);
        regSnapins.DeleteSubkey(CLSID_STRING_DEVMGR_EXTENSION);
    
        // removed populated node types
        CSafeRegistry regMMCNodeTypes;
        
        if (regMMCNodeTypes.Open(HKEY_LOCAL_MACHINE, REG_MMC_NODETYPE))
        {
            for (int i = NODETYPE_FIRST; i <= NODETYPE_LAST; i++)
            {
                PNODEINFO pni = (PNODEINFO) &NodeInfo[i];
                regMMCNodeTypes.DeleteValue(pni->GuidString);
            }
            
            // remove from system tools
            CSafeRegistry regSysTools;
            
            if (regSysTools.Open(regMMCNodeTypes, CLSID_STRING_SYSTOOLS))
            {
                CSafeRegistry regExtensions;
                
                if (regExtensions.Open(regSysTools, MMC_EXTENSIONS))
                {
                    CSafeRegistry regNameSpace;
                    
                    if (regNameSpace.Open(regExtensions, MMC_NAMESPACE))
                    {
                        regNameSpace.DeleteValue(CLSID_STRING_DEVMGR_EXTENSION);
                    }
                }
            }
        }
    }

    // unregister from OLE
    CSafeRegistry regRootCLSID;
    
    if (regRootCLSID.Open(HKEY_CLASSES_ROOT, REG_CLSID))
    {
        regRootCLSID.DeleteSubkey(CLSID_STRING_DEVMGR);
        regRootCLSID.DeleteSubkey(CLSID_STRING_DEVMGR_EXTENSION);
        regRootCLSID.DeleteSubkey(CLSID_STRING_DEVMGR_ABOUT);
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\globals.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    globals.h

Abstract:

    header file for globals.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __GLOBALS_H_
#define __GLOBALS_H_


class CMachineList;
class String;
class CMemoryException;

extern CMachineList g_MachineList;
extern HINSTANCE    g_hInstance;
extern String       g_strStartupMachineName;
extern String       g_strStartupDeviceId;
extern String       g_strStartupCommand;
extern String       g_strDevMgr;
extern BOOL         g_IsAdmin;
extern CPrintDialog g_PrintDlg;

extern CMemoryException g_MemoryException;

extern const CLSID CLSID_DEVMGR;
extern const CLSID CLSID_DEVMGR_EXTENSION;
extern const CLSID CLSID_SYSTOOLS;
extern const CLSID CLSID_DEVMGR_ABOUT;

extern const IID IID_IDMTVOCX;
extern const IID IID_ISnapinCallback;

extern const TCHAR*  const CLSID_STRING_DEVMGR;
extern const TCHAR*  const CLSID_STRING_DEVMGR_EXTENSION;
extern const TCHAR*  const CLSID_STRING_SYSTOOLS;
extern const TCHAR*  const CLSID_STRING_DEVMGR_ABOUT;

extern const TCHAR*  const MMC_SNAPIN_MACHINE_NAME;
extern const TCHAR*  const SNAPIN_INTERNAL;
extern const TCHAR*  const DEVMGR_SNAPIN_CLASS_GUID;
extern const TCHAR*  const DEVMGR_SNAPIN_DEVICE_ID;
extern const TCHAR*  const REG_PATH_DEVICE_MANAGER;
extern const TCHAR*  const REG_STR_BUS_TYPES;
extern const TCHAR*  const REG_STR_TROUBLESHOOTERS;
extern const TCHAR*  const DEVMGR_COMMAND_PROPERTY;
extern const TCHAR*  const DEVMGR_HELP_FILE_NAME;

extern const TCHAR*  const PROGID_DEVMGR;
extern const TCHAR*  const PROGID_DEVMGREXT;
extern const TCHAR*  const PROGID_DEVMGR_ABOUT;
extern const TCHAR*  const DEVMGR_HTML_HELP_FILE_NAME;

const int MAX_PROP_PAGES = 64;

#define DI_NEEDPOWERCYCLE   0x400000L

// Sizes of various stringized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)



extern LPOLESTR AllocOleTaskString(LPCTSTR str);
extern void FreeOleTaskString(LPOLESTR str);

extern  const NODEINFO NodeInfo[];

//
// global functions declaration
//
extern HRESULT AddMenuItem(LPCONTEXTMENUCALLBACK pCallback, int iNameStringId,
                           int iStatusBarStringId, long lCommandId,
                           long InsertionPointId, long  Flags,
                           long SpecialFlags = 0);
extern BOOL VerifyMachineName(LPCTSTR MachineName);
extern UINT LoadResourceString(int StringId, LPTSTR Buffer, UINT BufferSize);
extern UINT GetDeviceProblemText(ULONG ProblemNumber,  LPTSTR Buffer, UINT BufferSize);
extern int MsgBoxParam(HWND hwnd, int MsgId, int CaptionId, DWORD Type, ...);
extern int MsgBoxWinError(HWND hwndParent, int CaptionId, DWORD Type, DWORD Error = ERROR_SUCCESS);
extern LRESULT dmNotifyWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT PromptForRestart(HWND hwndParent, DWORD RestartFlags, int ResId = 0);

extern BOOL LoadEnumPropPage32(LPCTSTR RegString, HMODULE* pdll, FARPROC* pProcAddress);
extern BOOL IsBlankChar(TCHAR ch);
extern LPTSTR SkipBlankChars(LPTSTR psz);
extern BOOL GuidFromString(LPCTSTR GuidString, LPGUID pGuid);
extern BOOL GuidToString(LPGUID pGuid, LPTSTR Buffer, DWORD BufferLen);
extern BOOL AddToolTips(HWND hDlg, UINT id, LPCTSTR pszText, HWND *phwnd);
extern BOOL AddPropPageCallback(HPROPSHEETPAGE hPage, LPARAM lParam);
STDAPI_(LPTSTR) 
AddCommas64(
    LONGLONG n, 
    LPTSTR pszResult, 
    UINT cchResult
    );

STDAPI_(CONFIGRET) GetLocationInformation(
    DEVNODE dn,
    LPTSTR Location,
    ULONG LocationLen,  // In characters
    HMACHINE hMachine
    );

#if DBG
extern void Trace(LPCTSTR format, ...);
#define TRACE(text)     Trace text
#else
#define TRACE(text)
#endif

#endif      // __GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\globals.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    This module implements global functions needed for the program.
    It also contain global variables/classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"
#include <shlobj.h>
#define NO_SHELL_TREE_TYPE
#include <shlobjp.h>


//
//  global classes and variables
//

// this, of course, our dll's instance handle.
HINSTANCE g_hInstance = NULL;

//
// A CMachineList is created for each instance of DLL. It is shared
// by all the CComponentData the instance might create. The class CMachine
// contains all the information about all the classes and devices on the
// machine. Each CComponent should register itself to CMachine. This way,
// A CComponent will get notification whenever there are changes in
// the CMachine(Refresh, Property changes on a device, for example).
// We do not rely on MMC's view notification(UpdatAllView) because
// it only reaches all the CComponents created by a CComponenetData.
//
CMachineList    g_MachineList;
CMemoryException g_MemoryException(TRUE);
String          g_strStartupMachineName;
String          g_strStartupDeviceId;
String          g_strStartupCommand;
String          g_strDevMgr;
BOOL            g_IsAdmin = FALSE;
CPrintDialog    g_PrintDlg;


//
// UUID consts
//
const CLSID CLSID_DEVMGR = {0x74246BFC,0x4C96,0x11D0,{0xAB,0xEF,0x00,0x20,0xAF,0x6B,0x0B,0x7A}};
const CLSID CLSID_DEVMGR_EXTENSION = {0x90087284,0xd6d6,0x11d0,{0x83,0x53,0x00,0xa0,0xc9,0x06,0x40,0xbf}};
const CLSID CLSID_SYSTOOLS = {0x476e6448,0xaaff,0x11d0,{0xb9,0x44,0x00,0xc0,0x4f,0xd8,0xd5,0xb0}};
const CLSID CLSID_DEVMGR_ABOUT = {0x94abaf2a,0x892a,0x11d1,{0xbb,0xc4,0x00,0xa0,0xc9,0x06,0x40,0xbf}};

const TCHAR* const CLSID_STRING_DEVMGR = TEXT("{74246bfc-4c96-11d0-abef-0020af6b0b7a}");
const TCHAR* const CLSID_STRING_DEVMGR_EXTENSION = TEXT("{90087284-d6d6-11d0-8353-00a0c90640bf}");
const TCHAR* const CLSID_STRING_SYSTOOLS = TEXT("{476e6448-aaff-11d0-b944-00c04fd8d5b0}");
const TCHAR* const CLSID_STRING_DEVMGR_ABOUT = TEXT("{94abaf2a-892a-11d1-bbc4-00a0c90640bf}");

//
// ProgID
//
const TCHAR* const PROGID_DEVMGR = TEXT("DevMgrSnapin.DevMgrSnapin.1");
const TCHAR* const PROGID_DEVMGREXT = TEXT("DevMgrExtension.DevMgrExtension.1");
const TCHAR* const PROGID_DEVMGR_ABOUT = TEXT("DevMgrAbout.DevMgrAbout.1");

//
// Node types const
//
const NODEINFO NodeInfo[TOTAL_COOKIE_TYPES] =
{

    { COOKIE_TYPE_SCOPEITEM_DEVMGR,
      IDS_NAME_DEVMGR,
      IDS_DISPLAYNAME_SCOPE_DEVMGR,
      {0xc41dfb2a,0x4d5b,0x11d0,{0xab,0xef,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{c41dfb2a-4d5b-11d0-abef-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ,
      IDS_NAME_IRQ,
      0,
      {0x494535fe,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{494535fe-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_DMA,
      IDS_NAME_DMA,
      0,
      {0x49f0df4e,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{49f0df4e-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_IO,
      IDS_NAME_IO,
      0,
      {0xa2958d7a,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7a-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY,
      IDS_NAME_MEMORY,
      0,
      {0xa2958d7b,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7b-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_COMPUTER,
      IDS_NAME_COMPUTER,
      0,
      {0xa2958d7c,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7c-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_DEVICE,
      IDS_NAME_DEVICE,
      0,
      {0xa2958d7d,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7d-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_CLASS,
      IDS_NAME_CLASS,
      0,
      {0xe677e204,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{e677e204-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESTYPE,
      IDS_NAME_RESOURCES,
      0,
      {0xa2958d7e,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7e-5aa2-11d0-abf0-0020af6b0b7a}")
    }
};

const IID IID_IDMTVOCX =    \
    {0x142525f2,0x59d8,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}};
const IID IID_ISnapinCallback = \
    {0x8e0ba98a,0xd161,0x11d0,{0x83,0x53,0x00,0xa0,0xc9,0x06,0x40,0xbf}};

//
// cliboard format strings
//
const TCHAR* const MMC_SNAPIN_MACHINE_NAME = TEXT("MMC_SNAPIN_MACHINE_NAME");
const TCHAR* const SNAPIN_INTERNAL = TEXT("SNAPIN_INTERNAL");
const TCHAR* const DEVMGR_SNAPIN_CLASS_GUID = TEXT("DEVMGR_SNAPIN_CLASS_GUID");
const TCHAR* const DEVMGR_SNAPIN_DEVICE_ID  = TEXT("DEVMGR_SNAPIN_DEVICE_ID");
const TCHAR* const DEVMGR_COMMAND_PROPERTY = TEXT("Property");
const TCHAR* const REG_PATH_DEVICE_MANAGER = TEXT("SOFTWARE\\Microsoft\\DeviceManager");
const TCHAR* const REG_STR_BUS_TYPES    = TEXT("BusTypes");
const TCHAR* const REG_STR_TROUBLESHOOTERS = TEXT("TroubleShooters");
const TCHAR* const DEVMGR_HELP_FILE_NAME = TEXT("devmgr.hlp");
const TCHAR* const DEVMGR_HTML_HELP_FILE_NAME = TEXT("\\help\\devmgr.chm");

// lookup table to translate problem number to its text resource id.
const PROBLEMINFO  g_ProblemInfo[] =
{
    {IDS_PROB_NOPROBLEM, 0},                                    // NO PROBLEM
    {IDS_PROB_NOT_CONFIGURED, PIF_CODE_EMBEDDED},               // CM_PROB_NOT_CONFIGURED
    {IDS_PROB_DEVLOADERFAILED, PIF_CODE_EMBEDDED},              // CM_PROB_DEVLOADER_FAILED
    {IDS_PROB_OUT_OF_MEMORY, PIF_CODE_EMBEDDED},                // CM_PROB_OUT_OF_MEMORY
    {IDS_PROB_WRONG_TYPE, PIF_CODE_EMBEDDED},                   // CM_PROB_ENTRY_IS_WRONG_TYPE
    {IDS_PROB_LACKEDARBITRATOR, PIF_CODE_EMBEDDED},             // CM_PROB_LACKED_ARBITRATOR
    {IDS_PROB_BOOT_CONFIG_CONFLICT, PIF_CODE_EMBEDDED},         // CM_PROB_BOOT_CONFIG_CONFLICT
    {IDS_PROB_FAILED_FILTER, PIF_CODE_EMBEDDED},                // CM_PROB_FAILED_FILTER
    {IDS_PROB_DEVLOADER_NOT_FOUND, PIF_CODE_EMBEDDED},          // CM_PROB_DEVLOADER_NOT_FOUND
    {IDS_PROB_INVALID_DATA, PIF_CODE_EMBEDDED},                 // CM_PROB_INVALID_DATA
    {IDS_PROB_FAILED_START, PIF_CODE_EMBEDDED},                 // CM_PROB_FAILED_START
    {IDS_PROB_LIAR, PIF_CODE_EMBEDDED},                         // CM_PROB_LIAR
    {IDS_PROB_NORMAL_CONFLICT, PIF_CODE_EMBEDDED},              // CM_PROB_NORMAL_CONFLICT
    {IDS_PROB_NOT_VERIFIED, PIF_CODE_EMBEDDED},                 // CM_PROB_NOT_VERIFIED
    {IDS_PROB_NEEDRESTART, PIF_CODE_EMBEDDED},                  // CM_PROB_NEED_RESTART
    {IDS_PROB_REENUMERATION, PIF_CODE_EMBEDDED},                // CM_PROB_REENUMERATION
    {IDS_PROB_PARTIALCONFIG, PIF_CODE_EMBEDDED},                // CM_PROB_PARTIAL_LOG_CONF
    {IDS_PROB_UNKNOWN_RESOURCE, PIF_CODE_EMBEDDED},             // CM_PROB_UNKNOWN_RESOURCE
    {IDS_PROB_REINSTALL, PIF_CODE_EMBEDDED},                    // CM_PROB_REINSTALL
    {IDS_PROB_REGISTRY, PIF_CODE_EMBEDDED},                     // CM_PROB_REGISTRY
    {IDS_PROB_SYSTEMFAILURE, PIF_CODE_EMBEDDED},                // CM_PROB_VXDLDR
    {IDS_PROB_WILL_BE_REMOVED, PIF_CODE_EMBEDDED},              // CM_PROB_WILL_BE_REMOVED
    {IDS_PROB_DISABLED, PIF_CODE_EMBEDDED},                     // CM_PROB_DISABLED
    {IDS_PROB_SYSTEMFAILURE, PIF_CODE_EMBEDDED},                // CM_PROB_DEVLOADER_NOT_READY
    {IDS_DEVICE_NOT_THERE, PIF_CODE_EMBEDDED},                  // CM_PROB_DEVICE_NOT_THERE
    {IDS_PROB_MOVED, PIF_CODE_EMBEDDED},                        // CM_PROB_MOVED
    {IDS_PROB_TOO_EARLY, PIF_CODE_EMBEDDED},                    // CM_PROB_TOO_EARLY
    {IDS_PROB_NO_VALID_LOG_CONF, PIF_CODE_EMBEDDED},            // CM_PROB_NO_VALID_LOG_CONF
    {IDS_PROB_FAILEDINSTALL, PIF_CODE_EMBEDDED},                // CM_PROB_FAILED_INSTALL
    {IDS_PROB_HARDWAREDISABLED, PIF_CODE_EMBEDDED},             // CM_PROB_HARDWARE_DISABLED
    {IDS_PROB_CANT_SHARE_IRQ, PIF_CODE_EMBEDDED},               // CM_PROB_CANT_SHARE_IRQ
    {IDS_PROB_FAILED_ADD, PIF_CODE_EMBEDDED},                   // CM_PROB_FAILED_ADD
    {IDS_PROB_DISABLED_SERVICE, PIF_CODE_EMBEDDED},             // CM_PROB_DISABLED_SERVICE
    {IDS_PROB_TRANSLATION_FAILED, PIF_CODE_EMBEDDED},           // CM_PROB_TRANSLATION_FAILED
    {IDS_PROB_NO_SOFTCONFIG, PIF_CODE_EMBEDDED},                // CM_PROB_NO_SOFTCONFIG
    {IDS_PROB_BIOS_TABLE, PIF_CODE_EMBEDDED},                   // CM_PROB_BIOS_TABLE
    {IDS_PROB_IRQ_TRANSLATION_FAILED, PIF_CODE_EMBEDDED},       // CM_PROB_IRQ_TRANSLATION_FAILED
    {IDS_PROB_FAILED_DRIVER_ENTRY, PIF_CODE_EMBEDDED},          // CM_PROB_FAILED_DRIVER_ENTRY
    {IDS_PROB_DRIVER_FAILED_PRIOR_UNLOAD, PIF_CODE_EMBEDDED},   // CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD
    {IDS_PROB_DRIVER_FAILED_LOAD, PIF_CODE_EMBEDDED},           // CM_PROB_DRIVER_FAILED_LOAD
    {IDS_PROB_DRIVER_SERVICE_KEY_INVALID, PIF_CODE_EMBEDDED},   // CM_PROB_DRIVER_SERVICE_KEY_INVALID
    {IDS_PROB_LEGACY_SERVICE_NO_DEVICES, PIF_CODE_EMBEDDED},    // CM_PROB_LEGACY_SERVICE_NO_DEVICES
    {IDS_PROB_DUPLICATE_DEVICE, PIF_CODE_EMBEDDED},             // CM_PROB_DUPLICATE_DEVICE
    {IDS_PROB_FAILED_POST_START, PIF_CODE_EMBEDDED},            // CM_PROB_FAILED_POST_START
    {IDS_PROB_HALTED, PIF_CODE_EMBEDDED},                       // CM_PROB_HALTED
    {IDS_PROB_PHANTOM, PIF_CODE_EMBEDDED},                      // CM_PROB_PHANTOM
    {IDS_PROB_SYSTEM_SHUTDOWN, PIF_CODE_EMBEDDED},              // CM_PROB_SYSTEM_SHUTDOWN
    {IDS_PROB_HELD_FOR_EJECT, PIF_CODE_EMBEDDED},               // CM_PROB_HELD_FOR_EJECT
    {IDS_PROB_DRIVER_BLOCKED, PIF_CODE_EMBEDDED},               // CM_PROB_DRIVER_BLOCKED
    {IDS_PROB_REGISTRY_TOO_LARGE, PIF_CODE_EMBEDDED},           // CM_PROB_REGISTRY_TOO_LARGE
    {IDS_PROB_SETPROPERTIES_FAILED, PIF_CODE_EMBEDDED},         // CM_PROB_SETPROPERTIES_FAILED
    {IDS_PROB_UNKNOWN_WITHCODE, PIF_CODE_EMBEDDED}              // UNKNOWN PROBLEM
};


//
// Global functions
//

#if DBG
//
// Debugging aids
//
void
Trace(
    LPCTSTR format,
    ...
    )
{
    // according to wsprintf specification, the max buffer size is
    // 1024
    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    StringCchVPrintf(Buffer, ARRAYLEN(Buffer), format, arglist);
    va_end(arglist);
    OutputDebugString(TEXT("DEVMGR: "));
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\r\n"));
}
#endif


inline
BOOL
IsBlankChar(TCHAR ch)
{
    return (_T(' ') == ch || _T('\t') == ch);
}

inline
LPTSTR
SkipBlankChars(
    LPTSTR psz
    )
{
    while (IsBlankChar(*psz))
    psz++;
    return psz;
}

//
// This function converts a given string to GUID
// INPUT:
//  GuidString   -- the null terminated guid string
//  LPGUID       -- buffer to receive the GUID
// OUTPUT:
//     TRUE if the conversion succeeded.
//     FALSE if failed.
//
inline
BOOL
GuidFromString(
    LPCTSTR GuidString,
    LPGUID  pGuid
    )
{
    return ERROR_SUCCESS == pSetupGuidFromString(GuidString, pGuid);
}

// This function converts the given GUID to a string
// INPUT:
//  pGuid    -- the guid
//  Buffer   -- the buffer to receive the string
//  BufferLen -- the buffer size in char unit
// OUTPUT:
//  TRUE  if the conversion succeeded.
//  FLASE if failed.
//
//
inline
BOOL
GuidToString(
    LPGUID pGuid,
    LPTSTR Buffer,
    DWORD  BufferLen
    )
{
    return ERROR_SUCCESS == pSetupStringFromGuid(pGuid, Buffer, BufferLen);
}

//
// This function allocates an OLE string from OLE task memory pool
// It does necessary char set conversion before copying the string.
//
// INPUT: LPCTSTR str  -- the initial string
// OUTPUT:  LPOLESTR   -- the result OLE string. NULL if the function fails.
//
LPOLESTR
AllocOleTaskString(
    LPCTSTR str
    )
{
    if (!str)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    size_t Len = lstrlen(str);
    
    // allocate the null terminate char also.
    LPOLESTR olestr = (LPOLESTR)::CoTaskMemAlloc((Len + 1) * sizeof(TCHAR));
    
    if (olestr)
    {
        StringCchCopy((LPTSTR)olestr, Len + 1, str);
        return olestr;
    }
    
    return NULL;
}

inline
void
FreeOleTaskString(
    LPOLESTR olestr
    )
{
    if (olestr)
    {
        ::CoTaskMemFree(olestr);
    }
}
//
// This function addes the given menu item to snapin
// INPUT:
//  iNameStringId    -- menu item text resource id
//  iStatusBarStringId -- status bar text resource id.
//  iCommandId     -- command id to be assigned to the menu item
//  InsertionPointId   -- Insertion point id
//  Flags          -- flags
//  SpecialFlags       -- special flags
// OUTPUT:
//  HRESULT
//
HRESULT
AddMenuItem(
    LPCONTEXTMENUCALLBACK pCallback,
    int   iNameStringId,
    int   iStatusBarStringId,
    long  lCommandId,
    long  InsertionPointId,
    long  Flags,
    long  SpecialFlags
    )
{
    ASSERT(pCallback);

    CONTEXTMENUITEM tCMI;
    memset(&tCMI, 0, sizeof(tCMI));
    tCMI.lCommandID = lCommandId;
    tCMI.lInsertionPointID = InsertionPointId;
    tCMI.fFlags = Flags;
    tCMI.fSpecialFlags = SpecialFlags;
    TCHAR Name[MAX_PATH];
    TCHAR Status[MAX_PATH];
    
    if (::LoadString(g_hInstance, iNameStringId, Name, ARRAYLEN(Name)) != 0) {
        tCMI.strName = Name;
    }
    
    if (iStatusBarStringId &&
       (::LoadString(g_hInstance, iStatusBarStringId, Status, ARRAYLEN(Status)) != 0)) {
    
       tCMI.strStatusBarText = Status;
    }
    
    return pCallback->AddItem(&tCMI);
}

//
// This function verifies the given machine name can be accessed remotely.
// INPUT:
//  MachineName -- the machine name. The machine name must be
//             led by "\\\\".
// OUTPUT:
//  BOOL TRUE for success and FALSE for failure.  Check GetLastError() for failure
//  reason.
//
BOOL
VerifyMachineName(
    LPCTSTR MachineName
    )
{
    CONFIGRET cr = CR_SUCCESS;
    HMACHINE hMachine = NULL;
    HKEY hRemoteKey = NULL;
    HKEY hClass = NULL;
    String m_strMachineFullName;

    if (MachineName && (_T('\0') != MachineName[0]))
    {
        if (_T('\\') == MachineName[0] && _T('\\') == MachineName[1]) {
            m_strMachineFullName = MachineName;
        } else {
            m_strMachineFullName = TEXT("\\\\");
            m_strMachineFullName+=MachineName;
        }
        
        //
        // make sure we can connect the machine using cfgmgr32.
        //
        cr = CM_Connect_Machine((LPTSTR)m_strMachineFullName, &hMachine);

        //
        // We could not connect to the machine using cfgmgr32
        //
        if (CR_SUCCESS != cr)
        {
            goto clean0;
        }

        //
        // make sure we can connect to the registry of the remote machine
        //
        if (RegConnectRegistry((LPTSTR)m_strMachineFullName, 
                               HKEY_LOCAL_MACHINE,
                               &hRemoteKey) != ERROR_SUCCESS) {

            cr = CR_REGISTRY_ERROR;
            goto clean0;
        }

        cr = CM_Open_Class_Key_Ex(NULL,
                                  NULL,
                                  KEY_READ,
                                  RegDisposition_OpenExisting,
                                  &hClass,
                                  CM_OPEN_CLASS_KEY_INSTALLER,
                                  hMachine
                                  );
    }
    
clean0:

    if (hMachine) {
        
        CM_Disconnect_Machine(hMachine);
    }

    if (hRemoteKey) {

        RegCloseKey(hRemoteKey);
    }

    if (hClass) {

        RegCloseKey(hClass);
    }

    //
    // We will basically set two different error codes for this API, since we need
    // to present this information to the user.
    // 1) ERROR_MACHINE_UNABAILABLE
    // 2) ERROR_ACCESS_DENIED.
    //
    if (CR_SUCCESS == cr) {

        SetLastError(NO_ERROR);
    
    } else if (CR_MACHINE_UNAVAILABLE == cr) {

        SetLastError(ERROR_MACHINE_UNAVAILABLE);
    
    } else {

        SetLastError(ERROR_ACCESS_DENIED);
    }
    
    return (CR_SUCCESS == cr);
}

// This function loads the string designated by the given
// string id(resource id) from the module's resource to the provided
// buffer. It returns the required buffer size(in chars) to hold the string,
// not including the terminated NULL chars. Last error will be set
// appropaitely.
//
// input: int StringId  -- the resource id of the string to be loaded.
//    LPTSTR Buffer -- provided buffer to receive the string
//    UINT   BufferSize -- the size of Buffer in chars
// output:
//    UINT the required buffer size to receive the string
//    if it returns 0, GetLastError() returns the error code.
//
UINT
LoadResourceString(
    int StringId,
    LPTSTR Buffer,
    UINT   BufferSize
    )
{
    // do some trivial tests.
    if (BufferSize && !Buffer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    // if caller provides buffer, try to load the string with the given buffer
    // and length.
    UINT FinalLen;

    if (Buffer)
    {
        FinalLen = ::LoadString(g_hInstance, StringId, Buffer, BufferSize);
        if (BufferSize > FinalLen)
        {
            return FinalLen;
        }
    }

    // Either the caller does not provide the buffer or the given buffer
    // is too small. Try to figure out the requried size.
    //

    // first use a stack-based buffer to get the string. If the buffer
    // is big enough, we are happy.
    TCHAR Temp[256];
    UINT ArrayLen = ARRAYLEN(Temp);
    FinalLen = ::LoadString(g_hInstance, StringId, Temp, ArrayLen);

    DWORD LastError = ERROR_SUCCESS;

    if (ArrayLen <= FinalLen)
    {   
        // the stack-based buffer is too small, use heap-based buffer.
        // we have not got all the chars. we increase the buffer size of 256
        // chars each time it fails. The initial size is 512(256+256)
        // the max size is 32K
        ArrayLen = 256;
        TCHAR* HeapBuffer;
        FinalLen = 0;
        
        while (ArrayLen < 0x8000)
        {
            ArrayLen += 256;
            HeapBuffer = new TCHAR[ArrayLen];
            if (HeapBuffer)
            {
                FinalLen = ::LoadString(g_hInstance, StringId, HeapBuffer, ArrayLen);
                delete [] HeapBuffer;
                
                if (FinalLen < ArrayLen)
                    break;
            }
            
            else
            {
                LastError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        if (ERROR_SUCCESS != LastError)
        {
            SetLastError(LastError);
            FinalLen = 0;
        }
    }

    return FinalLen;
}

// This function get the problem text designated by the given problem number
// for the given devnode on the given machine.
//
//
// input: 
//    ULONG ProblemNumber -- the problem number
//    LPTSTR Buffer -- provided buffer to receive the string
//    UINT   BufferSize -- the size of Buffer in chars
// output:
//    UINT the required buffer size to receive the string
//    if it returns 0, GetLastError() returns the error code.
//
UINT
GetDeviceProblemText(
    ULONG ProblemNumber,
    LPTSTR Buffer,
    UINT   BufferSize
    )
{
    //
    // first does a trivial test
    //
    if (!Buffer && BufferSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    String strMainText;
    UINT RequiredSize = 0;
    PROBLEMINFO pi;
    
    //
    // Get the PROBLEMINFO for the problem number
    //
    pi = g_ProblemInfo[min(ProblemNumber, DEVMGR_NUM_CM_PROB-1)];
    
    try
    {
        String strProblemDesc;
        strProblemDesc.LoadString(g_hInstance, pi.StringId);

        if (pi.Flags & PIF_CODE_EMBEDDED)
        {
            String strFormat;
            strFormat.LoadString(g_hInstance, IDS_PROB_CODE);

            String strCodeText;
            strCodeText.Format((LPTSTR)strFormat, ProblemNumber);

            strMainText.Format((LPTSTR)strProblemDesc, (LPTSTR)strCodeText);
        }
        
        else
        {
            strMainText = strProblemDesc;
        }

        RequiredSize = strMainText.GetLength() + 1;
        
        //
        // copy the main text
        //
        if (RequiredSize && (BufferSize > RequiredSize))
        {
            StringCchCopy(Buffer, BufferSize, (LPTSTR)strMainText);
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RequiredSize = 0;
    }

    return RequiredSize;
}

//
// This function creates and shows a message box
// INPUT:
//  hwndParent -- the window handle servers as the parent window to the
//        message box
//  MsgId      -- string id for message box body. The string can be
//        a format string.
//  CaptionId  -- string id for caption. if 0, default is device manager
//  Type       -- the standard message box flags(MB_xxxx)
//  ...        -- parameters to MsgId string if it contains any
//        format chars.
//OUTPUT:
//  return value from MessageBox(IDOK, IDYES...)

int MsgBoxParam(
    HWND hwndParent,
    int MsgId,
    int CaptionId,
    DWORD Type,
    ...
    )
{
    TCHAR szMsg[MAX_PATH * 4], szCaption[MAX_PATH];;
    LPCTSTR pCaption;

    va_list parg;
    int Result;
    
    // if no MsgId is given, it is for no memory error;
    if (MsgId)
    {
        va_start(parg, Type);
    
        // load the msg string to szCaption(temp). The text may contain
        // format information
        if (!::LoadString(g_hInstance, MsgId, szCaption, ARRAYLEN(szCaption)))
        {
            goto NoMemory;
        }
        
        //finish up format string
        StringCchVPrintf(szMsg, ARRAYLEN(szMsg), szCaption, parg);
        
        // if caption id is given, load it.
        if (CaptionId)
        {
            if (!::LoadString(g_hInstance, CaptionId, szCaption, ARRAYLEN(szCaption)))
            {
                goto NoMemory;
            }

            pCaption = szCaption;
        }
        
        else
        {
            pCaption = g_strDevMgr;
        }
    
        if ((Result = MessageBox(hwndParent, szMsg, pCaption, Type)) == 0)
        {
            goto NoMemory;
        }
        
        return Result;
    }

NoMemory:
    g_MemoryException.ReportError(hwndParent);
    return 0;
}

// This functin prompts for restart.
// INPUT:
//  hwndParent -- the window handle to be used as the parent window
//            to the restart dialog
//  RestartFlags -- flags(RESTART/REBOOT/POWERRECYCLE)
//  ResId        -- designated string resource id. If 0, default will
//          be used.
// OUTPUT:
//  ID returned from the MessageBox.  IDYES if the user said Yes to the restart
//  dialog and IDNO if they said NO.
INT
PromptForRestart(
    HWND hwndParent,
    DWORD RestartFlags,
    int   ResId
    )
{
    INT id = 0;    
    
    if (RestartFlags & (DI_NEEDRESTART | DI_NEEDREBOOT))
    {
        DWORD ExitWinCode = 0;

        try
        {
            String str;
    
            if (RestartFlags & DI_NEEDRESTART)
            {
                if (!ResId)
                {
                    ResId = IDS_DEVCHANGE_RESTART;
                }

                str.LoadString(g_hInstance, ResId);
                ExitWinCode = EWX_REBOOT;
            }
            
            else
            {
                if (!ResId && RestartFlags & DI_NEEDPOWERCYCLE)
                {
        
                    String str2;
                    str.LoadString(g_hInstance, IDS_POWERCYC1);
                    str2.LoadString(g_hInstance, IDS_POWERCYC2);
                    str += str2;
                    ExitWinCode = EWX_SHUTDOWN;
                }
                
                else
                {
                    if (!ResId)
                    {
                        ResId = IDS_DEVCHANGE_RESTART;
                    }

                    str.LoadString(g_hInstance, ResId);
                    ExitWinCode = EWX_REBOOT;
                }
            }
            
            if (ExitWinCode != 0) {
                id = RestartDialogEx(hwndParent, 
                                     str, 
                                     ExitWinCode, 
                                     REASON_PLANNED_FLAG | REASON_HWINSTALL
                                     );
            }
        }
        
        catch(CMemoryException* e)
        {
            e->Delete();
            MsgBoxParam(hwndParent, 0, 0, 0);
        }
    }

    return id;
}

BOOL
LoadEnumPropPage32(
    LPCTSTR RegString,
    HMODULE* pDll,
    FARPROC* pProcAddress
    )
{
    // verify parameters
    if (!RegString || _T('\0') == RegString[0] || !pDll || !pProcAddress)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // make a copy of the string because we have to party on it
    ULONG Len = lstrlen(RegString) + 1;
    TCHAR* psz = new TCHAR[Len];
    
    if (!psz) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    StringCchCopy(psz, Len, RegString);
    LPTSTR DllName = NULL;
    LPTSTR DllNameEnd = NULL;
    LPTSTR FunctionName = NULL;
    LPTSTR FunctionNameEnd = NULL;
    LPTSTR p;
    p = psz;
    SetLastError(ERROR_SUCCESS);
    
    // the format of the  string is "dllname, dllentryname"
    p = SkipBlankChars(p);
    if (_T('\0') != *p)
    {
        // looking for dllname which could be enclosed
        // inside double quote chars.
        // NOTE: not double quote chars inside double quoted string is allowed.
        if (_T('\"') == *p)
        {
            DllName = ++p;
            while (_T('\"') != *p && _T('\0') != *p)
                p++;
            DllNameEnd = p;
            if (_T('\"') == *p)
            p++;
        }
        else
        {
            DllName = p;
            while (!IsBlankChar(*p) && _T(',') != *p)
            p++;
            DllNameEnd = p;
        }
        
        // looking for ','
        p = SkipBlankChars(p);
        if (_T('\0') != *p && _T(',') == *p)
        {
            p = SkipBlankChars(p + 1);
            if (_T('\0') != *p)
            {
                FunctionName = p++;
                while (!IsBlankChar(*p) && _T('\0') != *p)
                    p++;
                FunctionNameEnd = p;
            }
        }
    }

    if (DllName && FunctionName)
    {
        if (DllNameEnd) {
            *DllNameEnd = _T('\0');
        }
        if (FunctionNameEnd) {
            *FunctionNameEnd = _T('\0');
        }
        *pDll = LoadLibrary(DllName);
        if (*pDll)
        {
            // convert Wide char to ANSI which is GetProcAddress expected.
            // We do not append a 'A" or a "W' here.
            CHAR FuncNameA[256];
            WideCharToMultiByte(CP_ACP, 0,
                           FunctionName,
                           (int)wcslen(FunctionName) + 1,
                           FuncNameA,
                           sizeof(FuncNameA),
                           NULL, NULL);
            *pProcAddress = GetProcAddress(*pDll, FuncNameA);
        }
    }
    
    delete [] psz;
    
    if (!*pProcAddress && *pDll)
        FreeLibrary(*pDll);
    
    return (*pDll && *pProcAddress);
}


BOOL
AddPropPageCallback(
    HPROPSHEETPAGE hPage,
    LPARAM lParam
    )
{
    CPropSheetData* ppsData = (CPropSheetData*)lParam;
    ASSERT(ppsData);
    return ppsData->InsertPage(hPage);
}

BOOL
AddToolTips(
    HWND hDlg,
    UINT id,
    LPCTSTR pszText,
    HWND *phwnd
    )
{
    if (*phwnd == NULL)
    {
        *phwnd = CreateWindow(TOOLTIPS_CLASS,
                              TEXT(""),
                              WS_POPUP | TTS_NOPREFIX,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              hDlg,
                              NULL,
                              g_hInstance,
                              NULL);
        if (*phwnd)
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
            ti.hwnd = hDlg;
            ti.uId = (UINT_PTR)GetDlgItem(hDlg, id);
            ti.lpszText = (LPTSTR)pszText;  // const -> non const
            ti.hinst = g_hInstance;
            SendMessage(*phwnd, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        }
    }

    return (*phwnd) ? TRUE : FALSE;
}

void Int64ToStr(LONGLONG n, LPTSTR lpBuffer)
{
    TCHAR szTemp[40];
    LONGLONG iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
UINT GetNLSGrouping(void)
{
    TCHAR szGrouping[32];
    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYLEN(szGrouping)))
        return 3;

    UINT grouping = 0;
    LPTSTR psz = szGrouping;
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }
    return grouping;
}

STDAPI_(LPTSTR) 
AddCommas64(
    LONGLONG n, 
    LPTSTR pszResult, 
    UINT cchResult
    )
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    nfmt.Grouping = GetNLSGrouping();
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYLEN(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, cchResult) == 0)
        StringCchCopy(pszResult, cchResult, szTemp);

    return pszResult;
}

LPTSTR
FormatString(
            LPCTSTR format,
            ...
            )
{
    LPTSTR str = NULL;
    va_list arglist;
    va_start(arglist, format);

    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      format,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      (LPTSTR)&str,
                      0,
                      &arglist
                     ) == 0) {
        str = NULL;
    }

    va_end(arglist);

    return str;
}

STDAPI_(CONFIGRET) GetLocationInformation(
                                         DEVNODE dn,
                                         LPTSTR Location,
                                         ULONG LocationLen,
                                         HMACHINE hMachine
                                         )
/*++

    Slot x (LocationInformation)
    Slot x
    LocationInformation
    on parent bus

--*/
{
    CONFIGRET LastCR;
    DEVNODE dnParent;
    ULONG ulSize;
    DWORD UINumber;
    TCHAR Buffer[MAX_PATH];
    TCHAR UINumberDescFormat[MAX_PATH];
    TCHAR Format[MAX_PATH];

    Buffer[0] = TEXT('\0');

    //
    // We will first get any LocationInformation for the device.  This will either
    // be in the LocationInformationOverride value in the devices driver (software) key
    // or if that is not present we will look for the LocationInformation value in
    // the devices device (hardware) key.
    //
    HKEY hKey;
    DWORD Type = REG_SZ;
    ulSize = sizeof(Buffer);
    if (CR_SUCCESS == CM_Open_DevNode_Key_Ex(dn,
                                             KEY_READ,
                                             0,
                                             RegDisposition_OpenExisting,
                                             &hKey,
                                             CM_REGISTRY_SOFTWARE,
                                             hMachine
                                            )) {

        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE,
                            NULL,
                            &Type,
                            (const PBYTE)Buffer,
                            &ulSize) != ERROR_SUCCESS) {
        
            Buffer[0] = TEXT('\0');
        }

        RegCloseKey(hKey);
    }

    //
    // If the buffer is empty then we didn't get the LocationInformationOverride
    // value in the device's software key.  So, we will see if their is a
    // LocationInformation value in the device's hardware key.
    //
    if (Buffer[0] == TEXT('\0')) {

        ulSize = sizeof(Buffer);
        if (CM_Get_DevNode_Registry_Property_Ex(dn,
                                                CM_DRP_LOCATION_INFORMATION,
                                                NULL,
                                                Buffer,
                                                &ulSize,
                                                0,
                                                hMachine) != CR_SUCCESS) {

            Buffer[0] = TEXT('\0');
        }
    }

    //
    // UINumber has precedence over all other location information so check if this
    // device has a UINumber.
    //
    ulSize = sizeof(UINumber);
    if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dn,
                                                       CM_DRP_UI_NUMBER,
                                                       NULL,
                                                       &UINumber,
                                                       &ulSize,
                                                       0,
                                                       hMachine
                                                      )) == CR_SUCCESS) &&
        (ulSize == sizeof(ULONG))) {


        UINumberDescFormat[0] = TEXT('\0');
        ulSize = sizeof(UINumberDescFormat);

        //
        // Get the UINumber description format string from the device's parent,
        // if there is one, otherwise default to 'Location %1'
        if ((CM_Get_Parent_Ex(&dnParent, dn, 0, hMachine) == CR_SUCCESS) &&
            (CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                 CM_DRP_UI_NUMBER_DESC_FORMAT,
                                                 NULL,
                                                 UINumberDescFormat,
                                                 &ulSize,
                                                 0,
                                                 hMachine) == CR_SUCCESS) &&
            *UINumberDescFormat) {

        } else {
            ::LoadString(g_hInstance, IDS_UI_NUMBER_DESC_FORMAT, UINumberDescFormat, ARRAYLEN(UINumberDescFormat));
        }

        LPTSTR UINumberBuffer = NULL;

        //
        // Fill in the UINumber string
        //
        UINumberBuffer = FormatString(UINumberDescFormat, UINumber);

        if (UINumberBuffer) {
            StringCchCopy((LPTSTR)Location, LocationLen, UINumberBuffer);
            LocalFree(UINumberBuffer);
        } else {
            Location[0] = TEXT('\0');
        }

        //
        // If we also have LocationInformation then tack that on the end of the string
        // as well.
        //
        if (*Buffer) {
            StringCchCat((LPTSTR)Location, LocationLen, TEXT(" ("));
            StringCchCat((LPTSTR)Location, LocationLen, Buffer);
            StringCchCat((LPTSTR)Location, LocationLen, TEXT(")"));
        }
    }

    //
    // We don't have a UINumber but we do have LocationInformation
    //
    else if (*Buffer &&
            (::LoadString(g_hInstance, IDS_LOCATION, Format, sizeof(Format)/sizeof(TCHAR)) != 0)) {
        
        StringCchPrintf((LPTSTR)Location, LocationLen, Format, Buffer);
    }

    //
    // We don't have a UINumber or LocationInformation so we need to get a description
    // of the parent of this device.
    //
    else {
        if ((LastCR = CM_Get_Parent_Ex(&dnParent, dn, 0, hMachine)) == CR_SUCCESS) {

            //
            // Try the registry for FRIENDLYNAME
            //
            Buffer[0] = TEXT('\0');
            ulSize = sizeof(Buffer);
            if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                               CM_DRP_FRIENDLYNAME,
                                                               NULL,
                                                               Buffer,
                                                               &ulSize,
                                                               0,
                                                               hMachine
                                                              )) != CR_SUCCESS) ||
                !*Buffer) {

                //
                // Try the registry for DEVICEDESC
                //
                ulSize = sizeof(Buffer);
                if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                                   CM_DRP_DEVICEDESC,
                                                                   NULL,
                                                                   Buffer,
                                                                   &ulSize,
                                                                   0,
                                                                   hMachine
                                                                  )) != CR_SUCCESS) ||
                    !*Buffer) {

                    ulSize = sizeof(Buffer);
                    if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                                       CM_DRP_CLASS,
                                                                       NULL,
                                                                       Buffer,
                                                                       &ulSize,
                                                                       0,
                                                                       hMachine
                                                                      )) != CR_SUCCESS) ||
                        !*Buffer) {

                        //
                        // no parent, or parent name.
                        //
                        Buffer[0] = TEXT('\0');
                    }
                }
            }
        }

        if (*Buffer &&
            (::LoadString(g_hInstance, IDS_LOCATION_NOUINUMBER, Format, sizeof(Format)/sizeof(TCHAR)) != 0)) {
            //
            // We have a description of the parent
            //
            StringCchPrintf((LPTSTR)Location, LocationLen, Format, Buffer);
        } else {
            //
            // We don't have any information so we will just say Unknown
            //
            ::LoadString(g_hInstance, IDS_UNKNOWN, Location, LocationLen);
        }
    }

    //
    // Make sure the Location string is NULL terminated.
    //
    Location[LocationLen - 1] = TEXT('\0');

    return CR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\hwprof.h ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    hwprof.h

Abstract:

    header file for hwprof.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/
class CHwProfile;
class CHwProfileList;

class CHwProfileList
{
public:
    CHwProfileList() : m_pDevice(NULL), m_CurHwProfile(0), m_CurHwProfileIndex(0) {}
    ~CHwProfileList();
    BOOL Create(CDevice* pDevice, DWORD ConfigFlags = 0);
    BOOL GetFirst(CHwProfile** pphwpf, PVOID& Context);
    BOOL GetNext(CHwProfile** pphwpf, PVOID& Context);
    BOOL GetCurrentHwProfile(CHwProfile** pphwpf);
    int GetCount()
    {
        return m_listProfile.GetCount();
    }

private:
    CList<CHwProfile*,CHwProfile* > m_listProfile;
    CDevice*    m_pDevice;
    ULONG       m_CurHwProfile;
    int         m_CurHwProfileIndex;
};

class CHwProfile
{
public:
    CHwProfile(int Index, PHWPROFILEINFO phwpfInfo, CDevice* pDevice, DWORD hwpfFlags);
    ULONG GetHwProfile()
    {
         return m_hwpfInfo.HWPI_ulHWProfile;
    }
    void SetEnablePending()
    {
        m_EnablePending = TRUE;
    }
    void ResetEnablePending()
    {
        m_EnablePending = FALSE;
    }
    void SetDisablePending()
    {
        m_DisablePending = TRUE;
    }
    void ResetDisablePending()
    {
        m_DisablePending = FALSE;
    }
    BOOL IsEnablePending()
    {
        return m_EnablePending;
    }
    BOOL IsDisablePending()
    {
        return m_DisablePending;
    }

private:
    DWORD           m_Index;
    HWPROFILEINFO   m_hwpfInfo;
    DWORD           m_Flags;
    CDevice*        m_pDevice;
    BOOL            m_EnablePending;
    BOOL            m_DisablePending;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\hwprof.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    hwprof.cpp

Abstract:

    This module implements CHwProfileList and CHwProfile classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "hwprof.h"


BOOL
CHwProfileList::Create(
    CDevice* pDevice,
    DWORD ConfigFlags
    )
{
    //
    // First get the current profile index.
    //
    HWPROFILEINFO   HwProfileInfo;
    ASSERT(pDevice);

    m_pDevice = pDevice;
    
    //
    // Get the current profile index.
    //
    if (!m_pDevice->m_pMachine->CmGetCurrentHwProfile(&m_CurHwProfile)) {
        return FALSE;
    }
    
    //
    // Go through each profile and create a CHwProfile for it
    //
    int Index = 0;
    CHwProfile* phwpf;
    while (m_pDevice->m_pMachine->CmGetHwProfileInfo(Index, &HwProfileInfo)) {

        DWORD hwpfFlags;
        
        //
        // Get the hwprofile flags for this device
        // if failed, use the given ConfigFlags
        //
        if (m_pDevice->m_pMachine->CmGetHwProfileFlags((
                    LPTSTR)m_pDevice->GetDeviceID(),
                    HwProfileInfo.HWPI_ulHWProfile,
                    &hwpfFlags)) {

            if (hwpfFlags & CSCONFIGFLAG_DO_NOT_CREATE) {
                //
                // Skip this profile
                //
                Index++;
                continue;
            }
        } else {
            //
            // Flags have not been set for this profile yet.
            //
            hwpfFlags = ConfigFlags;
        }
    
        ASSERT(CONFIGFLAG_DISABLED == CSCONFIGFLAG_DISABLED);
    
        hwpfFlags |= ConfigFlags;
        
        //
        // Rememeber current hw profile index
        //
        if (m_CurHwProfile == HwProfileInfo.HWPI_ulHWProfile) {
            m_CurHwProfileIndex = Index;
        }

        phwpf = new CHwProfile(Index, &HwProfileInfo, pDevice, hwpfFlags);
        m_listProfile.AddTail(phwpf);
        Index++;
    }
    
    return TRUE;
}

CHwProfileList::~CHwProfileList()
{
    if (!m_listProfile.IsEmpty()) {

        POSITION pos = m_listProfile.GetHeadPosition();
        
        while (NULL != pos) {
            CHwProfile* pProfile =  m_listProfile.GetNext(pos);
            delete pProfile;
        }

        m_listProfile.RemoveAll();
    }
}

BOOL
CHwProfileList::GetFirst(
    CHwProfile** pphwpf,
    PVOID&  Context
    )
{
    ASSERT(pphwpf);

    if (!m_listProfile.IsEmpty()) {

        POSITION pos = m_listProfile.GetHeadPosition();
        *pphwpf = m_listProfile.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    Context = NULL;
    *pphwpf = NULL;
    return FALSE;
}

BOOL
CHwProfileList::GetNext(
    CHwProfile** pphwpf,
    PVOID&  Context
    )
{
    ASSERT(pphwpf);
    POSITION pos = (POSITION)Context;

    if (NULL != pos) {

        *pphwpf = m_listProfile.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    *pphwpf = NULL;
    return FALSE;
}

BOOL 
CHwProfileList::GetCurrentHwProfile(
    CHwProfile** pphwpf
    )
{
    ASSERT(pphwpf);

    POSITION pos = m_listProfile.FindIndex(m_CurHwProfileIndex);
    *pphwpf = m_listProfile.GetAt(pos);

    return TRUE;
}

CHwProfile::CHwProfile(
    int Index,
    PHWPROFILEINFO phwpfInfo,
    CDevice* pDevice,
    DWORD Flags
    )
{
    m_Index = Index;
    m_hwpfInfo = *phwpfInfo;
    m_pDevice = pDevice;
    m_EnablePending = FALSE;
    m_DisablePending = FALSE;
    m_Flags = Flags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\machine.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This module implements CDevInfoList, CMachine and CMachineList

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"

extern "C" {
#include <initguid.h>
#include <dbt.h>
#include <devguid.h>
#include <wdmguid.h>
}


CONST TCHAR*    DEVMGR_NOTIFY_CLASS_NAME = TEXT("DevMgrNotifyClass");

CONST TCHAR*    DEVMGR_REFRESH_MSG = TEXT("DevMgrRefreshOn");

//
// The constant is the size we use to allocate GUID list from within
// stack when we have to build a GUID list. The aim of this is
// that buiding a guid list take time and in many case, a minimum
// buffer should retrive all of them. We do not want to get
// the size first, allocate buffer and get it again.
// 64 looks to be fair enough value because there are not
// many classes out there today (and maybe, in the future).
//
const int GUID_LIST_INIT_SIZE =     64;

//
// CDevInfoList implementation
//
BOOL
CDevInfoList::DiGetExtensionPropSheetPage(
                                         PSP_DEVINFO_DATA DevData,
                                         LPFNADDPROPSHEETPAGE pfnAddPropSheetPage,
                                         DWORD PageType,
                                         LPARAM lParam
                                         )
{
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    LPFNADDPROPSHEETPAGES AddPropPages;

    PropPageRequest.cbSize = sizeof(PropPageRequest);
    PropPageRequest.PageRequested = PageType;
    PropPageRequest.DeviceInfoSet = m_hDevInfo;
    PropPageRequest.DeviceInfoData = DevData;

    if (SPPSR_SELECT_DEVICE_RESOURCES == PageType) {
        HINSTANCE hModule = ::GetModuleHandle(TEXT("setupapi.dll"));

        if (hModule) {
            AddPropPages = (LPFNADDPROPSHEETPAGES)GetProcAddress(hModule, "ExtensionPropSheetPageProc");

            if (AddPropPages) {
                if (AddPropPages(&PropPageRequest, pfnAddPropSheetPage, lParam)) {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOL
CDevInfoList::InstallDevInst(
                            HWND hwndParent,
                            LPCTSTR DeviceId,
                            BOOL    UpdateDriver,
                            DWORD* pReboot
                            )
{
    BOOL Result = FALSE;
    HINSTANCE hLib = LoadLibrary(TEXT("newdev.dll"));
    LPFNINSTALLDEVINST InstallDevInst;
    DWORD Status = ERROR_SUCCESS;

    if (hLib) {
        InstallDevInst = (LPFNINSTALLDEVINST)GetProcAddress(hLib, "InstallDevInst");

        if (InstallDevInst) {
            Result = (*InstallDevInst)(hwndParent, DeviceId, UpdateDriver,
                                       pReboot);

            Status = GetLastError();
        }
    
        FreeLibrary(hLib);
    }

    //
    // We need to put back the error code that was set by newdev.dll's InstallDevInst
    // API.  This last error gets overwritten by FreeLibrary which we don't care about.
    //
    SetLastError(Status);

    return Result;
}

BOOL
CDevInfoList::RollbackDriver(
                            HWND hwndParent,
                            LPCTSTR RegistryKeyName,
                            DWORD Flags,
                            DWORD* pReboot
                            )
{
    BOOL Result = FALSE;
    HINSTANCE hLib = LoadLibrary(TEXT("newdev.dll"));
    LPFNROLLBACKDRIVER RollbackDriver;

    if (hLib) {
        RollbackDriver = (LPFNROLLBACKDRIVER)GetProcAddress(hLib, "RollbackDriver");

        if (RollbackDriver) {
            Result = (*RollbackDriver)(hwndParent, RegistryKeyName, Flags, pReboot);
        }
    
        FreeLibrary(hLib);
    }

    return Result;
}

DWORD
CDevInfoList::DiGetFlags(
                        PSP_DEVINFO_DATA DevData
                        )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        return dip.Flags;
    }

    return 0;
}

DWORD
CDevInfoList::DiGetExFlags(
                          PSP_DEVINFO_DATA DevData
                          )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        return dip.FlagsEx;
    }

    return 0;
}

BOOL
CDevInfoList::DiTurnOnDiFlags(
                             PSP_DEVINFO_DATA DevData,
                             DWORD FlagsMask
                             )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.Flags |= FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

BOOL
CDevInfoList::DiTurnOffDiFlags(
                              PSP_DEVINFO_DATA DevData,
                              DWORD FlagsMask
                              )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.Flags &= ~FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

BOOL
CDevInfoList::DiTurnOnDiExFlags(
                               PSP_DEVINFO_DATA DevData,
                               DWORD FlagsMask
                               )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.FlagsEx |= FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

BOOL
CDevInfoList::DiTurnOffDiExFlags(
                                PSP_DEVINFO_DATA DevData,
                                DWORD FlagsMask
                                )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.FlagsEx &= ~FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

void
CDevInfoList::DiDestroyDeviceInfoList()
{
    if (INVALID_HANDLE_VALUE != m_hDevInfo) {
        SetupDiDestroyDeviceInfoList(m_hDevInfo);
        m_hDevInfo = INVALID_HANDLE_VALUE;
    }
}

/////////////////////////////////////////////////////////////////////
////  CMachine implementation
////
//
// For every single instance of DevMgr.dll, we maintain a CMachine list
// from which different instances of IComponentData(and IComponent) will
// attach to. The objects created(CDevice, Class, HDEVINFO and etc) are
// shared by all the attached IComponentData and IComponent(the implementation
// use CFolder as the controlling identify).
// Everything changed to the CMachine or one of its object will inform
// all the attached CFolders which would pass the information down to their
// sub-objects(CResultView).
// Imaging that you have two Device Manager window in the same console
// and you do a refresh on one the window. The other window must also
// do a refresh after the first one is done. Since both windows shares
// the same machine(and will get the same notification when machine states
// changed), we can keep the two windows in sync.
/////////////////////////////////////////////////////////////////////
CMachine::CMachine(
                  LPCTSTR pMachineName
                  )
{
    InitializeCriticalSection(&m_CriticalSection);
    InitializeCriticalSection(&m_PropertySheetCriticalSection);
    InitializeCriticalSection(&m_ChildMachineCriticalSection);

    //
    // Get various privilege levels, like if the user is an administrator
    // or if the user is a Guest.
    //
    g_IsAdmin = pSetupIsUserAdmin();
    m_UserIsAGuest = SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS);

    m_RefreshDisableCounter = 0;
    m_RefreshPending = FALSE;
    m_pComputer = NULL;
    m_hMachine = NULL;
    m_ParentMachine = NULL;
    m_Initialized = FALSE;
    TCHAR LocalName[MAX_PATH + 1];
    DWORD dwSize = ARRAYLEN(LocalName);

    if (!GetComputerName(LocalName, &dwSize)) {
        LocalName[0] = _T('\0');
    }

    m_strMachineFullName.Empty();
    m_strMachineDisplayName.Empty();

    if (pMachineName && _T('\0') != *pMachineName) {
        
        if ((_T('\\') == pMachineName[0]) && (_T('\\') == pMachineName[1])) {
            
            m_strMachineDisplayName = &pMachineName[2];
            m_strMachineFullName = pMachineName;
        
        } else {

            m_strMachineDisplayName = pMachineName;
            m_strMachineFullName = TEXT("\\\\");
            m_strMachineFullName+=pMachineName;
        }


        m_IsLocal = (0 == m_strMachineDisplayName.CompareNoCase(LocalName));
    }

    else {
        //
        // Local machine
        //
        m_strMachineDisplayName = LocalName;
        m_strMachineFullName = TEXT("\\\\") + m_strMachineDisplayName;
        m_IsLocal = TRUE;
    }

    m_hwndNotify = NULL;
    m_msgRefresh = 0;
    m_ShowNonPresentDevices = FALSE;
    m_PropertySheetShoudDestroy = FALSE;

    TCHAR Buffer[MAX_PATH];
    DWORD BufferLen;

    //
    // If the environment variable DEVMGR_SHOW_NONPRESENT_DEVICES does exist and it
    // is not 0 then we will show Phantom devices.
    //
    if (((BufferLen = ::GetEnvironmentVariable(TEXT("DEVMGR_SHOW_NONPRESENT_DEVICES"),
                                               Buffer,
                                               ARRAYLEN(Buffer))) != 0) &&
        ((BufferLen > 1) ||
         (lstrcmp(Buffer, TEXT("0"))))) {

        m_ShowNonPresentDevices = TRUE;
    }
}

BOOL
CMachine::Initialize(
                    IN HWND hwndParent,
                    IN LPCTSTR DeviceId,    OPTIONAL
                    IN LPGUID ClassGuid     OPTIONAL
                    )
{
    BOOL Result = TRUE;
    m_hwndParent = hwndParent;

    if (DeviceId && _T('\0') == *DeviceId) {
        DeviceId = NULL;
    }

    HCURSOR hCursorOld;
    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (DeviceId || ClassGuid) {

        if (m_Initialized) {
            return TRUE;
        }

        if (CreateClassesAndDevices(DeviceId, ClassGuid)) {

            m_Initialized = TRUE;
        }

    } else {
        
        if (m_Initialized && m_hwndNotify && IsWindow(m_hwndNotify)) {
            return TRUE;
        }

        //
        // We are ready for device change notification, create the notify window
        //
        Result = CreateNotifyWindow();

        m_Initialized = TRUE;

        ScheduleRefresh();
    }

    if (hCursorOld) {
        SetCursor(hCursorOld);
    }

    return Result;
}

BOOL
CMachine::ScheduleRefresh()
{
    Lock();

    //
    // Only queue the the request if there is no requests outstanding
    // and we have a valid window handle/message to the notify window.
    //
    if (!m_RefreshPending && m_hwndNotify && m_msgRefresh) {
        //
        // Broadcast the message so that every instance runs on
        // the computer get the notification
        //
        ::PostMessage(HWND_BROADCAST, m_msgRefresh, 0, 0);
    }

    Unlock();
    return TRUE;
}

//
// This function creates a data window to receive WM_DEVICECHANGE notification
// so that we can refresh the device tree. It also registers a private
// message so that anybody can post a refresh request.
//
BOOL
CMachine::CreateNotifyWindow()
{
    WNDCLASS wndClass;

    //
    // Lets see if the class has been registered.
    //
    if (!GetClassInfo(g_hInstance, DEVMGR_NOTIFY_CLASS_NAME, &wndClass)) {
        //
        // Register the class
        //
        memset(&wndClass, 0, sizeof(wndClass));
        wndClass.lpfnWndProc = dmNotifyWndProc;
        wndClass.hInstance = g_hInstance;
        wndClass.lpszClassName = DEVMGR_NOTIFY_CLASS_NAME;

        if (!RegisterClass(&wndClass)) {
            return FALSE;
        }
    }

    //
    // Register a private message for refresh. The name must contain
    // the target machine name so that every machine has its own message.
    //
    String strMsg = DEVMGR_REFRESH_MSG;
    strMsg += m_strMachineDisplayName;
    m_msgRefresh = RegisterWindowMessage(strMsg);

    if (m_msgRefresh) {
        //
        // Create a data window.
        //
        m_hwndNotify = CreateWindowEx(WS_EX_TOOLWINDOW, DEVMGR_NOTIFY_CLASS_NAME,
                                      TEXT(""),
                                      WS_DLGFRAME|WS_BORDER|WS_DISABLED,
                                      CW_USEDEFAULT, CW_USEDEFAULT,
                                      0, 0, NULL, NULL, g_hInstance, (void*)this);
        return(NULL != m_hwndNotify);
    }

    return FALSE;
}

BOOL
CMachine::DestroyNotifyWindow()
{
    if (m_hwndNotify && IsWindow(m_hwndNotify)) {
        
        ::DestroyWindow(m_hwndNotify);
        m_hwndNotify = NULL;
        
        return TRUE;
    }

    //
    // The notify window does not exist.
    //
    return FALSE;
}


//
// This is the WM_DEVICECHANGE window procedure running in the main thread
// context. It listens to two messages:
// (1). WM_DEVICECHANGE  broadcasted by Configuration Manager on device
//      addition/removing.
// (2). Private refresh message broadcasted by different instance
//      of Device Manager targeting on the same machine.
// On WM_CREATE, we participate the WM_DEVICECHANGE notification chain
// while on WM_DESTROY, we detach oursleves from the chain.
// There are occasions that we have to detach and re-attach to the
// chain duing the window life time, for example, during device uninstallation
// or during re-enumeration. The EnableFresh function is the place
// that does the attach/detach.
//
LRESULT
dmNotifyWndProc(
               HWND hWnd,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    CMachine* pThis;
    pThis = (CMachine*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    //
    // Special case for private refresh message
    //
    if (pThis && uMsg == pThis->m_msgRefresh) {
        pThis->Refresh();
        return FALSE;
    }

    switch (uMsg) {
    case WM_CREATE:
        pThis =  (CMachine*)((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
        break;

    case WM_DEVICECHANGE:
        if (DBT_DEVNODES_CHANGED == wParam) {
            //
            // While we are in WM_DEVICECHANGE context,
            // no CM apis can be called because it would
            // deadlock. Here, we schedule a timer so that
            // we can handle the message later on.
            //
            SetTimer(hWnd, DM_NOTIFY_TIMERID, 1000, NULL);
        }
        break;

    case WM_TIMER:
        if (DM_NOTIFY_TIMERID == wParam) {
            KillTimer(hWnd, DM_NOTIFY_TIMERID);
            ASSERT(pThis);
            pThis->ScheduleRefresh();
        }
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//
// This function attaches the given CFolder to the class.
// An attached CFolder will get notified when there are state
// changes in the class(Refresh, property changes, for example).
//
BOOL
CMachine::AttachFolder(
                      CFolder* pFolder
                      )
{
    ASSERT(pFolder);

    if (!IsFolderAttached(pFolder)) {
        pFolder->MachinePropertyChanged(this);
        m_listFolders.AddTail(pFolder);
    }

    return TRUE;
}

BOOL
CMachine::IsFolderAttached(
                          CFolder* pFolder
                          )
{
    if (!m_listFolders.IsEmpty()) {
        POSITION pos = m_listFolders.GetHeadPosition();

        while (NULL != pos) {
            if (pFolder == m_listFolders.GetNext(pos)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

void
CMachine::DetachFolder(
                      CFolder* pFolder
                      )
{
    POSITION nextpos = m_listFolders.GetHeadPosition();

    while (nextpos) {
        POSITION pos = nextpos;

        CFolder* pFolderToTest = m_listFolders.GetNext(nextpos);

        if (pFolderToTest == pFolder) {
            m_listFolders.RemoveAt(pos);
            break;
        }
    }
}

BOOL
CMachine::AttachPropertySheet(
                             HWND hwndPropertySheet
                             )
{
    ASSERT(hwndPropertySheet);

    EnterCriticalSection(&m_PropertySheetCriticalSection);

    m_listPropertySheets.AddTail(hwndPropertySheet);

    LeaveCriticalSection(&m_PropertySheetCriticalSection);

    return TRUE;
}

void
CMachine::DetachPropertySheet(
                             HWND hwndPropertySheet
                             )
{
    EnterCriticalSection(&m_PropertySheetCriticalSection);

    POSITION nextpos = m_listPropertySheets.GetHeadPosition();

    while (nextpos) {
        POSITION pos = nextpos;

        HWND hwndPropertySheetToTest = m_listPropertySheets.GetNext(nextpos);

        if (hwndPropertySheetToTest == hwndPropertySheet) {
            m_listPropertySheets.RemoveAt(pos);
            break;
        }
    }

    LeaveCriticalSection(&m_PropertySheetCriticalSection);
}

HWND
CMachine::GetDeviceWindowHandle(
    LPCTSTR DeviceId
    )
{
    HWND hwnd = NULL;

    EnterCriticalSection(&m_ChildMachineCriticalSection);

    //
    // Enumerate the list of Child CMachines
    //
    if (!m_listChildMachines.IsEmpty()) {

        PVOID DeviceContext;
        CDevice* pDevice;

        POSITION nextpos = m_listChildMachines.GetHeadPosition();

        while (nextpos) {

            CMachine* pChildMachine = m_listChildMachines.GetNext(nextpos);

            //
            // Child machines will only have one device (if any at all)
            //
            if (pChildMachine->GetFirstDevice(&pDevice, DeviceContext) &&
                pDevice) {

                //
                // If the device Ids match then get the window handle
                //
                if (lstrcmpi(pDevice->GetDeviceID(), DeviceId) == 0) {

                    hwnd = pDevice->m_psd.GetWindowHandle();
                    break;
                }
            }
        }
    }

    LeaveCriticalSection(&m_ChildMachineCriticalSection);

    return hwnd;
}

HWND
CMachine::GetClassWindowHandle(
    LPGUID ClassGuid
    )
{
    HWND hwnd = NULL;

    EnterCriticalSection(&m_ChildMachineCriticalSection);

    //
    // Enumerate the list of Child CMachines
    //
    if (!m_listChildMachines.IsEmpty()) {

        PVOID ClassContext;
        CClass* pClass;

        POSITION nextpos = m_listChildMachines.GetHeadPosition();

        while (nextpos) {

            CMachine* pChildMachine = m_listChildMachines.GetNext(nextpos);

            //
            // Any child CMachine that has a device is a device property sheet.
            // We only want to look at the ones that have 0 devices since those
            // will be class property sheets.
            //
            if (pChildMachine->GetNumberOfDevices() == 0) {

                if (pChildMachine->GetFirstClass(&pClass, ClassContext) &&
                    pClass) {

                    //
                    // If the ClassGuids match then get the window handle
                    //
                    if (IsEqualGUID(*ClassGuid, *pClass)) {

                        hwnd = pClass->m_psd.GetWindowHandle();
                        break;
                    }
                }
            }
        }
    }

    LeaveCriticalSection(&m_ChildMachineCriticalSection);

    return hwnd;
}

BOOL
CMachine::AttachChildMachine(
                            CMachine* ChildMachine
                            )
{
    ASSERT(ChildMachine);

    EnterCriticalSection(&m_ChildMachineCriticalSection);

    m_listChildMachines.AddTail(ChildMachine);

    LeaveCriticalSection(&m_ChildMachineCriticalSection);

    return TRUE;
}

void
CMachine::DetachChildMachine(
                            CMachine* ChildMachine
                            )
{
    EnterCriticalSection(&m_ChildMachineCriticalSection);

    POSITION nextpos = m_listChildMachines.GetHeadPosition();

    while (nextpos) {
        POSITION pos = nextpos;

        CMachine* CMachineToTest = m_listChildMachines.GetNext(nextpos);

        if (CMachineToTest == ChildMachine) {
            m_listChildMachines.RemoveAt(pos);
            break;
        }
    }

    LeaveCriticalSection(&m_ChildMachineCriticalSection);
}

CMachine::~CMachine()
{
    //
    // Turn off refresh.  We need to do this in case there are any property
    // sheets that are still active.
    //
    EnableRefresh(FALSE);

    //
    // We first need to destroy all child CMachines
    //
    while (!m_listChildMachines.IsEmpty()) {

        //
        // Remove the first child machine from the list.  We need to
        // do this in the critical section.
        //
        EnterCriticalSection(&m_ChildMachineCriticalSection);

        CMachine* ChildMachine = m_listChildMachines.RemoveHead();

        //
        // Set the m_ParentMachine to NULL so we won't try to remove it from
        // the list again.
        //
        ChildMachine->m_ParentMachine = NULL;

        LeaveCriticalSection(&m_ChildMachineCriticalSection);

        delete ChildMachine;
    }

    //
    // We need to wait for all of the property sheets to be destroyed.
    //
    // We will check to see if there are any property pages still around, and
    // if there is we will wait for .5 seconds and then check again.  After 5
    // seconds we will give up and just destroy the CMachine anyway.
    //
    int iSecondsCount = 0;

    while (!m_listPropertySheets.IsEmpty() &&
           (iSecondsCount++ < 10)) {

        //
        // Enumerate through all of the property sheets left and if IsWindow fails
        // then pull them from the list, otherwise call DestroyWindow on them.
        //
        // Since property sheets each run in their own thread we need to do this
        // in a critical section.
        //
        EnterCriticalSection(&m_PropertySheetCriticalSection);

        POSITION nextpos = m_listPropertySheets.GetHeadPosition();

        while (nextpos) {
            POSITION pos = nextpos;

            HWND hwndPropertySheetToTest = m_listPropertySheets.GetNext(nextpos);

            if (IsWindow(hwndPropertySheetToTest)) {
                //
                // There is still a valid window for this property sheet so
                // call DestroyWindow on it.
                //
                ::DestroyWindow(hwndPropertySheetToTest);
            } else {
                //
                // There is no window for this property sheet so just remove
                // it from the list
                //
                m_listPropertySheets.RemoveAt(pos);
            }
        }

        LeaveCriticalSection(&m_PropertySheetCriticalSection);

        //
        // Sleep for .5 seconds and then try again.  This will give the property pages time to
        // finish up their work.
        //
        Sleep(500);
    }

    //
    // If we have created a device change data window for this machine,
    // destroy it.
    //
    DestroyNotifyWindow();

    DestroyClassesAndDevices();

    if (!m_listFolders.IsEmpty()) {
        m_listFolders.RemoveAll();
    }

    //
    // If we have a parent CMachine then we need to remove oursleves from
    // his list of Child CMachines.
    //
    if (m_ParentMachine) {

        m_ParentMachine->DetachChildMachine(this);
    }

    DeleteCriticalSection(&m_CriticalSection);
    DeleteCriticalSection(&m_PropertySheetCriticalSection);
    DeleteCriticalSection(&m_ChildMachineCriticalSection);
}

//
// This function destroys all the CClass and CDevice we ever created.
// No notification is sent for the attached folder
//
//
void
CMachine::DestroyClassesAndDevices()
{
    if (m_pComputer) {
        delete m_pComputer;
        m_pComputer = NULL;
    }

    if (!m_listDevice.IsEmpty()) {
        POSITION pos = m_listDevice.GetHeadPosition();

        while (NULL != pos) {
            CDevice* pDevice = m_listDevice.GetNext(pos);
            delete pDevice;
        }

        m_listDevice.RemoveAll();
    }

    if (!m_listClass.IsEmpty()) {
        POSITION pos = m_listClass.GetHeadPosition();

        while (NULL != pos) {
            CClass* pClass = m_listClass.GetNext(pos);
            delete pClass;
        }

        m_listClass.RemoveAll();
    }

    if (m_ImageListData.cbSize) {
        DiDestroyClassImageList(&m_ImageListData);
    }

    CDevInfoList::DiDestroyDeviceInfoList();

    m_hMachine = NULL;
}

BOOL
CMachine::BuildClassesFromGuidList(
                                  LPGUID  GuidList,
                                  DWORD   Guids
                                  )
{
    DWORD Index;
    CClass* pClass;

    //
    // Build a list of CClass for each GUID.
    //
    for (Index = 0; Index < Guids; Index++) {
        SafePtr<CClass> ClassPtr;

        pClass = new CClass(this, &GuidList[Index]);
        ClassPtr.Attach(pClass);
        m_listClass.AddTail(ClassPtr);
        ClassPtr.Detach();
    }

    return TRUE;
}

//
// Create CClass and CDevice for this machine.
// If DeviceId is valid, this function will create the machine
// with ONLY ONE device(and its CClass)
//
//  PERFBUG Optimize this function!!!!!!!
//      This function is slow because SetupDiGetClassDevs can take a long
//          time (over 1 sec of a 300Mhz machine).
//      The other slow part is the call to DoNotCreateDevice which needs to
//          go through the service manager for all legacy devnodes to see
//          if they are Win32 services (which we don't display). This takes
//          around 10ms to get this information from the service manager on
//          a 300Mhz machine and their are almost 100 of these legacy devices.
//          This means another second of time.
//
//
BOOL
CMachine::CreateClassesAndDevices(
                                 IN LPCTSTR DeviceId,           OPTIONAL
                                 IN LPGUID  ClassGuid           OPTIONAL
                                 )
{
    SC_HANDLE SCMHandle = NULL;

    //
    // Preventing memory leak
    //
    ASSERT(NULL == m_pComputer);
    ASSERT(INVALID_HANDLE_VALUE == m_hDevInfo);
    ASSERT(NULL == m_hMachine);

    if (DeviceId || ClassGuid) {
        //
        // If the object is being created for a single device,
        // create a empty device info list. We will add the
        // device to the info list later.
        //
        m_hDevInfo = DiCreateDeviceInfoList(ClassGuid, m_hwndParent);
    
    } else {
        //
        // We have to pull out the entire devices/classes set
        // so create a device info list that contains all of them.
        //
        m_hDevInfo = DiGetClassDevs(NULL, NULL, m_hwndParent, DIGCF_ALLCLASSES | DIGCF_PROFILE);
    }

    //
    // NULL != INVALID_HANDLE_VALUE. We checked both just be safe.
    //
    if (INVALID_HANDLE_VALUE == m_hDevInfo || NULL == m_hDevInfo) {

        return FALSE;
    }

    SP_DEVINFO_LIST_DETAIL_DATA DevInfoDetailData;
    DevInfoDetailData.cbSize = sizeof(DevInfoDetailData);

    //
    // Use the HMACHINE returned from Setupapi so that
    // every call we make to Cfgmgr32.dll will use the
    // same HMACHINE. Two call of CM_Connect_Machine will
    // return different hMachines even though they refer to
    // the same machine name(and thus, different set of DEVNODES!).
    // The catch is that we will be able to call Setuapi and cfgmgr32
    // API without worrying about which hMachine to use.
    //
    if (DiGetDeviceInfoListDetail(&DevInfoDetailData)) {
        m_hMachine = DevInfoDetailData.RemoteMachineHandle;
    } else {
        //
        // Unable to get the devinfo detail information.
        // In this case we will just default to the local machine.
        //
        return FALSE;
    }

    //
    // Get class image list data;
    //
    m_ImageListData.cbSize = sizeof(m_ImageListData);
    if (DiGetClassImageList(&m_ImageListData)) {
        //
        // Add extra icons
        //
        HICON hIcon;

        if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR))) != NULL) {
            m_ComputerIndex = ImageList_AddIcon(m_ImageListData.ImageList, hIcon);
            DestroyIcon(hIcon);
        }

        if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_RESOURCES))) != NULL) {
            m_ResourceIndex = ImageList_AddIcon(m_ImageListData.ImageList, hIcon);
            DestroyIcon(hIcon);
        }
    }

    //
    // If the object is created for a particular device,
    // do not create the entire device list because it is
    // a waste of time.
    //
    if (DeviceId) {
        SP_DEVINFO_DATA DevData;
        GUID DeviceClassGuid;
        DevData.cbSize = sizeof(DevData);
        if (DiOpenDeviceInfo(DeviceId, m_hwndParent, 0, &DevData) &&
            CmGetClassGuid(DevData.DevInst, DeviceClassGuid)) {
            //
            // Create a CClass for the device(without CClass, no
            // device can not be created).
            //
            CClass* pClass;
            SafePtr<CClass> ClassPtr;
            pClass = new CClass(this, &DeviceClassGuid);

            if (pClass) {
                ClassPtr.Attach(pClass);
                m_listClass.AddTail(ClassPtr);

                //
                // The class object has been inserted to the list
                // it is safe now to detach the object from the smart pointer
                // The class object will be deleted by the list
                //
                ClassPtr.Detach();

                //
                // Create the device
                //
                SafePtr<CDevice> DevicePtr;
                CDevice* pDevice;
                pDevice = new CDevice(this, pClass, &DevData);

                if (pDevice) {
                    //
                    // Guard the object
                    //
                    DevicePtr.Attach(pDevice);
                    m_listDevice.AddTail(DevicePtr);

                    //
                    // Object added..
                    //
                    DevicePtr.Detach();

                    pClass->AddDevice(pDevice);
                }
            }
        }

        //
        // We should have one class and one device object. no more no less.
        // we are done here.
        //
        return(1 == m_listClass.GetCount() && 1 == m_listDevice.GetCount());
    }

    //
    // If the object is for a specific class then just create the class and add
    // it to the CMachine.
    //
    else if (ClassGuid) {

        CClass* pClass;
        SafePtr<CClass> ClassPtr;
        pClass = new CClass(this, ClassGuid);

        if (pClass) {
            ClassPtr.Attach(pClass);
            m_listClass.AddTail(ClassPtr);

            //
            // The class object has been inserted to the list
            // it is safe now to detach the object from the smart pointer
            // The class object will be deleted by the list
            //
            ClassPtr.Detach();
        }

        //
        // We should have one class. no more no less.
        // we are done here.
        //
        return(1 == m_listClass.GetCount());
    }

    //
    // Build class guid list
    //
    DWORD ClassGuids, GuidsRequired;
    GuidsRequired = 0;

    //
    // We make a guess here to save us some time.
    //
    GUID LocalGuid[GUID_LIST_INIT_SIZE];
    ClassGuids = GUID_LIST_INIT_SIZE;

    if (DiBuildClassInfoList(0, LocalGuid, ClassGuids, &GuidsRequired)) {
        BuildClassesFromGuidList(LocalGuid, GuidsRequired);
    } else if (ERROR_INSUFFICIENT_BUFFER == GetLastError() && GuidsRequired) {
        //
        // The stack based buffer is too small, allocate buffer from
        // the heap.
        //
        BufferPtr<GUID> ClassGuidList(GuidsRequired);

        if (DiBuildClassInfoList(0, ClassGuidList, GuidsRequired, &ClassGuids)) {
            BuildClassesFromGuidList(ClassGuidList, ClassGuids);
        }
    }

    //
    // If we have any classes at all, create devices objects
    //
    if (!m_listClass.IsEmpty()) {
        DWORD Index = 0;
        SP_DEVINFO_DATA DevData;

        //
        // We need a handle to the service manager in the DoNotCreateDevice
        // function.  We will open it once and pass it to this function rather
        // than opening and closing it for every device.
        //
        SCMHandle = OpenSCManager(NULL, NULL, GENERIC_READ);

        //
        // Create every device in the devinfo list and
        // associate each device to its class.
        //
        DevData.cbSize = sizeof(DevData);
        while (DiEnumDeviceInfo(Index, &DevData)) {
            POSITION pos = m_listClass.GetHeadPosition();
            CClass* pClass;

            //
            // Find the class for this device
            //
            while (NULL != pos) {
                pClass = m_listClass.GetNext(pos);

                //
                // Match the ClassGuid for this device.
                // Note that if the device does not have a class guid (GUID_NULL)
                // then we will put it in class GUID_DEVCLASS_UNKNOWN)
                //
                if ((IsEqualGUID(DevData.ClassGuid, *pClass)) ||
                    (IsEqualGUID(GUID_DEVCLASS_UNKNOWN, *pClass) &&
                     IsEqualGUID(DevData.ClassGuid, GUID_NULL))) {
                    //
                    // Is this one of the special DevInst that we should
                    // not create a CDevice for?
                    //
                    if (DoNotCreateDevice(SCMHandle, *pClass, DevData.DevInst)) {

                        break;
                    }

                    //
                    // Create the device
                    //
                    SafePtr<CDevice> DevicePtr;
                    CDevice* pDevice;
                    pDevice = new CDevice(this, pClass, &DevData);

                    //
                    // Guard the object
                    //
                    DevicePtr.Attach(pDevice);
                    m_listDevice.AddTail(DevicePtr);

                    //
                    // Object added.
                    //
                    DevicePtr.Detach();

                    //
                    // Put the device under the class
                    //
                    pClass->AddDevice(pDevice);

                    break;
                }

                //
                // No class than, no device
                //
            }

            //
            // next device
            //
            Index++;
        }

        CloseServiceHandle(SCMHandle);

        //
        // Create a device tree under computer
        // the tree order comes from DEVNODE structure;
        //
        DEVNODE dnRoot = CmGetRootDevNode();
        m_pComputer = new CComputer(this, dnRoot);
        DEVNODE dnStart = CmGetChild(dnRoot);
        CreateDeviceTree(m_pComputer, NULL, dnStart);
    }

    return TRUE;
}

//
// This function builds a device tree based on the Devnode tree retreived
// from configuration manager. Note that ALL CDevice are created before
// this function is called. This function establishs each CDevice relationship.
//
void
CMachine::CreateDeviceTree(
                          CDevice* pParent,
                          CDevice* pSibling,
                          DEVNODE dn
                          )
{
    CDevice* pDevice;
    DEVNODE dnChild;

    while (dn) {
        pDevice = DevNodeToDevice(dn);

        if (pDevice) {
            //
            // No sibling ->this is the first child
            //
            if (!pSibling) {
                pParent->SetChild(pDevice);
            }

            else {
                pSibling->SetSibling(pDevice);
            }

            pDevice->SetParent(pParent);
            pSibling = pDevice;
            dnChild = CmGetChild(dn);

            if (dnChild) {
                CreateDeviceTree(pDevice, NULL, dnChild);
            }
        }

        dn = CmGetSibling(dn);
    }
}

//
// Find CDevice from the given devnode
//
CDevice*
CMachine::DevNodeToDevice(
                         DEVNODE dn
                         )
{
    POSITION pos = m_listDevice.GetHeadPosition();

    while (NULL != pos) {
        CDevice* pDevice = m_listDevice.GetNext(pos);

        if (pDevice->GetDevNode() == dn) {

            return pDevice;
        }
    }

    return NULL;
}

//
// This function reenumerates the devnode tree from the root, rebuilds the
// device tree and notifies every attached folder about the new device tree.
//
BOOL
CMachine::Reenumerate()
{
    if (m_pComputer) {
        //
        // Temporarily disable refresh while we are doing reenumeration
        // so that we will not keep refreshing the device tree.
        //
        EnableRefresh(FALSE);

        CDialog WaitDialog(IDD_SCAN_PNP_HARDWARES);

        WaitDialog.DoModaless(m_hwndParent, (LPARAM)&WaitDialog);

        if (!CmReenumerate(
            m_pComputer->GetDevNode(),
            CM_REENUMERATE_SYNCHRONOUS | CM_REENUMERATE_RETRY_INSTALLATION
            )) {

            //
            // Win2K doesn't support CM_REENUMERATE_RETRY_INSTALLATION, so we
            // retry without the reinstall flag.
            //
            CmReenumerate(m_pComputer->GetDevNode(), CM_REENUMERATE_SYNCHRONOUS);
        }

        DestroyWindow(WaitDialog);

        //
        // reenumeration is done, schedule a refresh and enable refresh now.
        //
        ScheduleRefresh();

        EnableRefresh(TRUE);

    }

    return TRUE;
}

//
// This function enable/disable refresh. A disble counter is kept to
// support multiple disabling/enabling. Only when the disable counter
// is zero, a refresh is possible.
// If a refresh is pending while we are enabling, we schedule a new
// request so that we will not lose any requests.
//
BOOL
CMachine::EnableRefresh(
                       BOOL fEnable
                       )
{
    BOOL Result = TRUE;
    Lock();

    if (fEnable) {
        if (m_RefreshDisableCounter < 0) {
            m_RefreshDisableCounter++;
        }
    }

    else {
        m_RefreshDisableCounter--;

    }

    //
    // If we are enabling refresh and there is one request pending,
    // schedule it again. This makes sure that we will not lose
    // any requests.
    // We schedule a new refresh request instead of calling Refresh
    // directly because we can be called by different threads while
    // we want the refresh to be done in the main thread. The data window
    // we created will receive the message and execute the refresh
    // in the main thread context.
    //
    if (fEnable && m_RefreshPending) {
        m_RefreshPending = FALSE;
        ScheduleRefresh();
    }

    Unlock();
    return Result;
}

//
//
// This function rebuilds the entire list of CClass and CDevice
// All attached CFolder are notified about the new machine.
//
// There are several occasions that we need to recreate the device tree:
// (1). On WM_DEVICECHANGE.
// (2). Device properties changed.
// (3). Device removal.
// (4). Device drivers updated and
// (5). Reenumeration requested by users.
// The requests may come from different threads and we must serialize
// the requests. A critical section and a new function(EnableRefresh) are added for
// for this purpose.
// Before doing anything on a device or class, one must call EnableRefesh(FALSE)
// to suspend Device change notification. When it is done with the change,
// one must call ScheduleRefesh function(if a refresh is necessary because of
// the changes) and then EnableRefresh(TRUE) to reenable the refresh.
//
BOOL
CMachine::Refresh()
{
    BOOL Result = TRUE;
    POSITION pos;
    Lock();

    if (0 == m_RefreshDisableCounter) {

        HCURSOR hCursorOld;
        hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

        //
        // Before we destroy all the classes and devices,
        // notify every attached folder so that they can dis-engaged
        // from us. After we created a new set of classes and devices,
        // the notification will be sent again to each folder
        // so that each folder can enagage to the machine again.
        //
        pos = m_listFolders.GetHeadPosition();

        while (NULL != pos) {
            ((CFolder*)m_listFolders.GetNext(pos))->MachinePropertyChanged(NULL);
        }

        //
        // we can destroy all the "old" classes and devices now.
        //
        DestroyClassesAndDevices();

        if (CreateClassesAndDevices()) {
            //
            // Notify every attach folder to recreate
            //
            if (!m_listFolders.IsEmpty()) {
                pos = m_listFolders.GetHeadPosition();

                while (NULL != pos) {
                    CFolder* pFolder = m_listFolders.GetNext(pos);
                    Result = SUCCEEDED(pFolder->MachinePropertyChanged(this));
                }
            }

            //
            // Notify every property page to refresh
            //
            if (!m_listChildMachines.IsEmpty()) {

                EnterCriticalSection(&m_ChildMachineCriticalSection);

                POSITION nextpos = m_listChildMachines.GetHeadPosition();

                while (nextpos) {
                    pos = nextpos;

                    CMachine* pMachineToNotify = m_listChildMachines.GetNext(nextpos);

                    pMachineToNotify->DoMiniRefresh();
                }

                LeaveCriticalSection(&m_ChildMachineCriticalSection);
            }
        }

        if (hCursorOld) {
            SetCursor(hCursorOld);
        }

        m_RefreshPending = FALSE;
    }

    else {
        //
        // We need to refresh while the refresh is disabled
        // Remember this so that when refresh is enabled, we
        // can launch a refresh.
        //
        m_RefreshPending = TRUE;
    }

    Unlock();

    return Result;
}

//
// A mini refresh is performed when the CMachine only has a single CClass or
// CDevice.  This is because this will be the property sheet case.  In this
// case we will see if the class or device represented by this property sheet
// still exists.
//
BOOL
CMachine::DoMiniRefresh()
{
    BOOL Result = TRUE;

    Lock();

    //
    // If the machine has one CDevice then we need to see if this device is
    // still around.
    //
    if (1 == m_listDevice.GetCount()) {

        PVOID Context;
        CDevice* pDevice;

        if (GetFirstDevice(&pDevice, Context)) {
            //
            // If the devnode did not go away we should tell it to refresh itself
            // in case something changed.
            //
            ::PostMessage(pDevice->m_psd.GetWindowHandle(), PSM_QUERYSIBLINGS, QSC_PROPERTY_CHANGED, 0L);
        }
    }

    //
    // Note that currently we don't do anything in the class property sheet case.
    // The reason for this is that classes can't really go away unless someone deletes
    // them from the registry, which probably wills mess up lots of other things. Also
    // all current class property sheets don't do anything anyway and so even if someone
    // does delete the class key nothing bad will happen to the property sheet.
    //

    Unlock();

    return Result;
}

BOOL
CMachine::GetFirstDevice(
                        CDevice** ppDevice,
                        PVOID&    Context
                        )
{
    ASSERT(ppDevice);

    if (!m_listDevice.IsEmpty()) {
        POSITION pos = m_listDevice.GetHeadPosition();
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppDevice = NULL;
    Context = NULL;
    return FALSE;
}

BOOL
CMachine::GetNextDevice(
                       CDevice** ppDevice,
                       PVOID& Context
                       )
{
    ASSERT(ppDevice);
    POSITION pos = (POSITION)Context;

    if (NULL != pos) {
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppDevice = NULL;
    return FALSE;
}

BOOL
CMachine::GetFirstClass(
                       CClass** ppClass,
                       PVOID& Context
                       )
{
    ASSERT(ppClass);

    if (!m_listClass.IsEmpty()) {
        POSITION pos = m_listClass.GetHeadPosition();
        *ppClass = m_listClass.GetNext(pos);
        Context = pos;

        return TRUE;
    }

    *ppClass = NULL;
    Context = NULL;
    return FALSE;
}

BOOL
CMachine::GetNextClass(
                      CClass** ppClass,
                      PVOID&   Context
                      )
{
    ASSERT(ppClass);
    POSITION pos = (POSITION)Context;

    if (NULL != pos) {
        *ppClass = m_listClass.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppClass = NULL;
    return FALSE;
}

BOOL
CMachine::GetInfDigitalSigner(
                          LPCTSTR FullInfPath,
                          String& DigitalSigner
                          )
/*++

    This function returns whether the specified INF file is digitally signed
    or not and returns the digital signer.
    
    NOTE that this function can return TRUE, meaning the file is digitally
    signed, but not fill in the DigitalSigner parameter if the catalog
    file associated with this INF didn't specify one.

--*/
{
    SP_INF_SIGNER_INFO InfSignerInfo;
    BOOL bRet = FALSE;

    if (m_UserIsAGuest || !IsLocal()) {
        //
        // If the user is loged in as a guest, or we are not on the local
        // machine, then make the digital signer string be 'Not available'
        //
        DigitalSigner.LoadString(g_hInstance, IDS_NOT_AVAILABLE);
    } else {
        InfSignerInfo.cbSize = sizeof(InfSignerInfo);
    
        bRet = SetupVerifyInfFile(FullInfPath,
                                  NULL,
                                  &InfSignerInfo
                                  );

        //
        // If SetupVerifyInfFile sets one of the following errors then the
        // INF file is Authenticode signed, and we will treat this as 
        // a success case.
        //
        if((GetLastError() == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
           (GetLastError() == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
        
            bRet = TRUE;
        }

    
        if (bRet && (InfSignerInfo.DigitalSigner[0] != TEXT('\0'))) {
            DigitalSigner = (LPTSTR)InfSignerInfo.DigitalSigner;
        }
    }

    return bRet;
}

BOOL
CMachine::DoNotCreateDevice(
                           SC_HANDLE SCMHandle,
                           LPGUID ClassGuid,
                           DEVINST DevInst
                           )
/*++

    This function returns whether a CDevice should be created for this DevInst
    or not. If a CDevice is not created for DevInst then it will never show up
    in the device manager UI, even when "Show hidden devices" is turned on.

    We don't create a CDevice in the following cases:

        - DevInst is HTREE\ROOT\0
        - DevInst is a Win32 Service.

--*/
{
    SC_HANDLE ServiceHandle;
    TCHAR ServiceName[MAX_PATH];
    LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
    DWORD ServiceConfigSize;
    ULONG Size;
    String strDeviceID;
    BOOL Return = FALSE;

    //
    // If the DEVMGR_SHOW_NONPRESENT_DEVICES environment variable is not set then
    // we do not want to show any Phantom devices.
    //
    if (!m_ShowNonPresentDevices) {

        ULONG Status, Problem;

        if ((!CmGetStatus(DevInst, &Status, &Problem)) &&
            ((m_LastCR == CR_NO_SUCH_VALUE) ||
             (m_LastCR == CR_NO_SUCH_DEVINST))) {

            return TRUE;
        }
    }

    //
    // Check to see if this device is a Win32 service. Only
    // legacy devices could be Win32 services.
    //
    if (IsEqualGUID(*ClassGuid, GUID_DEVCLASS_LEGACYDRIVER)) {

        Size = sizeof(ServiceName);
        if (CmGetRegistryProperty(DevInst,
                                  CM_DRP_SERVICE,
                                  (PVOID)ServiceName,
                                  &Size
                                 ) == CR_SUCCESS) {

            //
            // Open this particular service
            //
            if ((ServiceHandle = OpenService(SCMHandle, ServiceName, GENERIC_READ)) != NULL) {

                //
                // Get the service config
                //
                if ((!QueryServiceConfig(ServiceHandle, NULL, 0, &ServiceConfigSize)) &&
                    (ERROR_INSUFFICIENT_BUFFER == GetLastError())) {

                    if ((ServiceConfig = (LPQUERY_SERVICE_CONFIG)malloc(ServiceConfigSize)) != NULL) {

                        if (QueryServiceConfig(ServiceHandle, ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) {


                            if (ServiceConfig->dwServiceType & (SERVICE_WIN32 | SERVICE_FILE_SYSTEM_DRIVER)) {

                                Return = TRUE;
                            }

                        }

                        free(ServiceConfig);
                    }
                }

                CloseServiceHandle(ServiceHandle);
            }
        }
    }

    //
    // Check to see if this is the HTREE\ROOT\0 device. We don't
    // want to create a CDevice for this phantom devnode.
    //
    // This is an else statement because the HTREE\ROOT\0 device is
    // not in the legacy device class.
    //
    else {

        CmGetDeviceIDString(DevInst, strDeviceID);
        if (!_wcsicmp((LPTSTR)strDeviceID, TEXT("HTREE\\ROOT\\0"))) {

            Return = TRUE;
        }
    }

    return Return;
}

BOOL
CMachine::DiGetClassFriendlyNameString(
                                      LPGUID Guid,
                                      String& strClass
                                      )
{
    TCHAR DisplayName[LINE_LEN + 1];

    //
    // Try friendly name first. If it failed, try the class name
    //
    if (SetupDiGetClassDescriptionEx(Guid, DisplayName, ARRAYLEN(DisplayName),
                                     NULL, GetRemoteMachineFullName(), NULL) ||
        SetupDiClassNameFromGuidEx(Guid, DisplayName, ARRAYLEN(DisplayName),
                                   NULL, GetRemoteMachineFullName(), NULL)) {
        strClass = DisplayName;
        return TRUE;
    }

    return FALSE;
}

DEVNODE
CMachine::CmGetParent(
                     DEVNODE dn
                     )
{
    DEVNODE dnParent;

    m_LastCR = CM_Get_Parent_Ex(&dnParent, dn, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return dnParent;
    }

    return NULL;
}

DEVNODE
CMachine::CmGetChild(
                    DEVNODE dn
                    )
{
    DEVNODE dnChild;
    m_LastCR = CM_Get_Child_Ex(&dnChild, dn, 0, m_hMachine);

    if (CR_SUCCESS ==  m_LastCR) {
        return dnChild;
    }

    return NULL;
}

DEVNODE
CMachine::CmGetSibling(
                      DEVNODE dn
                      )
{
    DEVNODE dnSibling;

    m_LastCR = CM_Get_Sibling_Ex(&dnSibling, dn, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return dnSibling;
    }

    return NULL;
}

DEVNODE
CMachine::CmGetRootDevNode()
{
    DEVNODE dnRoot;

    m_LastCR =  CM_Locate_DevNode_Ex(&dnRoot, NULL, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return dnRoot;
    }

    return NULL;
}

BOOL
CMachine::CmGetDeviceIDString(
                             DEVNODE dn,
                             String& str
                             )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN + 1];

    m_LastCR = CM_Get_Device_ID_Ex(dn, DeviceID, ARRAYLEN(DeviceID), 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        str = DeviceID;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetConfigFlags(
                          DEVNODE dn,
                          DWORD* pFlags
                          )
{
    DWORD Size;

    Size = sizeof(DWORD);
    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_CONFIGFLAGS, pFlags, &Size);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetCapabilities(
                           DEVNODE dn,
                           DWORD* pCapabilities
                           )
{
    DWORD Size;

    Size = sizeof(DWORD);
    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_CAPABILITIES, pCapabilities, &Size);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetDescriptionString(
                                DEVNODE dn,
                                String& str
                                )
{
    TCHAR Description[LINE_LEN + 1];
    ULONG Size = sizeof(Description);

    Description[0] = TEXT('\0');

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_FRIENDLYNAME, Description, &Size);

    if ((CR_NO_SUCH_VALUE == m_LastCR) || (Description[0] == TEXT('\0'))) {

        Size = sizeof(Description);
        m_LastCR = CmGetRegistryProperty(dn, CM_DRP_DEVICEDESC, Description,
                                         &Size);
    }

    if ((CR_SUCCESS == m_LastCR) && (Description[0] != TEXT('\0'))) {

        str = Description;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetMFGString(
                        DEVNODE dn,
                        String& str
                        )
{
    TCHAR MFG[LINE_LEN + 1];
    ULONG Size = sizeof(MFG);

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_MFG, MFG, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = MFG;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetProviderString(
                             DEVNODE dn,
                             String& str
                             )
{
    TCHAR Provider[LINE_LEN + 1];
    ULONG Size = sizeof(Provider);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("ProviderName"),
                                             Provider, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = Provider;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetDriverDateString(
                               DEVNODE dn,
                               String& str
                               )
{
    TCHAR DriverDate[LINE_LEN + 1];
    ULONG Size = sizeof(DriverDate);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("DriverDate"),
                                             DriverDate, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = DriverDate;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetDriverDateData(
                             DEVNODE dn,
                             FILETIME *ft
                             )
{
    ULONG Size = sizeof(*ft);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("DriverDateData"),
                                             ft, &Size);

    return(m_LastCR == CR_SUCCESS);
}

BOOL
CMachine::CmGetDriverVersionString(
                                  DEVNODE dn,
                                  String& str
                                  )
{
    TCHAR DriverVersion[LINE_LEN + 1];
    ULONG Size = sizeof(DriverVersion);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("DriverVersion"),
                                             DriverVersion, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = DriverVersion;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetBusGuid(
                      DEVNODE dn,
                      LPGUID Guid
                      )
{

    ULONG Size = sizeof(*Guid);

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_BUSTYPEGUID, (LPVOID)Guid, &Size);

    if (CR_SUCCESS == m_LastCR) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetBusGuidString(
                            DEVNODE dn,
                            String& str
                            )
{
    GUID BusGuid;
    TCHAR BusGuidString[MAX_GUID_STRING_LEN];
    ULONG Size;

    while (dn) {
        //
        // We have to set the size on each loop
        //
        Size  = sizeof(BusGuid);
        m_LastCR = CmGetRegistryProperty(dn, CM_DRP_BUSTYPEGUID, &BusGuid, &Size);

        if (CR_SUCCESS == m_LastCR && GuidToString(&BusGuid, BusGuidString,
                                                   ARRAYLEN(BusGuidString))) {

            str = BusGuidString;
            return TRUE;
        }

        dn = CmGetParent(dn);
    }

    return FALSE;
}

BOOL
CMachine::CmGetClassGuid(
                        DEVNODE dn,
                        GUID& Guid
                        )
{
    TCHAR szGuidString[MAX_GUID_STRING_LEN + 1];
    ULONG Size = sizeof(szGuidString);

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_CLASSGUID, szGuidString, &Size);

    if (CR_SUCCESS == m_LastCR && GuidFromString(szGuidString, &Guid)) {
        return TRUE;
    }

    //
    // If we can't get the class GUID from the registry then most likely the device
    // does not have a class GUID.  If this is the case then we will return
    // GUID_DEVCLASS_UNKNOWN
    //
    else {
        memcpy(&Guid, &GUID_DEVCLASS_UNKNOWN, sizeof(GUID));
        return TRUE;
    }
}

BOOL
CMachine::CmGetStatus(
                     DEVNODE dn,
                     DWORD* pProblem,
                     DWORD* pStatus
                     )
{
    ASSERT(pProblem && pStatus);
    m_LastCR = CM_Get_DevNode_Status_Ex(pStatus, pProblem, dn, 0, m_hMachine);
    return(CR_SUCCESS == m_LastCR);
}

BOOL
CMachine::CmGetKnownLogConf(
                           DEVNODE dn,
                           LOG_CONF* plc,
                           DWORD*    plcType
                           )
{
    ASSERT(plc);

    *plc  = 0;

    if (plcType) {
        *plcType = LOG_CONF_BITS + 1;
    }

    ULONG lcTypeFirst = ALLOC_LOG_CONF;
    ULONG lcTypeLast = FORCED_LOG_CONF;
    ASSERT(ALLOC_LOG_CONF + 1 == BOOT_LOG_CONF &&
           BOOT_LOG_CONF + 1 == FORCED_LOG_CONF);

    for (ULONG lcType = lcTypeFirst; lcType <= lcTypeLast; lcType++) {
        m_LastCR = CM_Get_First_Log_Conf_Ex(plc, dn, lcType, m_hMachine);

        if (CR_SUCCESS == m_LastCR) {
            if (plcType) {
                *plcType = lcType;
            }

            break;
        }
    }

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmHasResources(
                        DEVNODE dn
                        )
{
    for (ULONG lcType = 0; lcType < NUM_LOG_CONF; lcType++) {
        m_LastCR = CM_Get_First_Log_Conf_Ex(NULL, dn, lcType, m_hMachine);

        if (CR_SUCCESS == m_LastCR) {
            break;
        }
    }

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmReenumerate(
                       DEVNODE dn,
                       ULONG Flags
                       )
{
    m_LastCR = CM_Reenumerate_DevNode_Ex(dn, Flags, m_hMachine);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetHwProfileFlags(
                             DEVNODE dn,
                             ULONG Profile,
                             ULONG* pFlags
                             )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN + 1];

    m_LastCR = CM_Get_Device_ID_Ex(dn, DeviceID, ARRAYLEN(DeviceID),
                                   0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return CmGetHwProfileFlags(DeviceID, Profile, pFlags);
    }

    return FALSE;
}

BOOL
CMachine::CmGetHwProfileFlags(
                             LPCTSTR DeviceID,
                             ULONG Profile,
                             ULONG* pFlags
                             )
{
    m_LastCR = CM_Get_HW_Prof_Flags_Ex((LPTSTR)DeviceID, Profile, pFlags, 0,
                                       m_hMachine);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmSetHwProfileFlags(
                             DEVNODE dn,
                             ULONG Profile,
                             ULONG Flags
                             )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN + 1];

    m_LastCR = CM_Get_Device_ID_Ex(dn, DeviceID, ARRAYLEN(DeviceID),
                                   0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return CmSetHwProfileFlags(DeviceID, Profile, Flags);
    }

    return FALSE;
}

BOOL
CMachine::CmSetHwProfileFlags(
                             LPCTSTR DeviceID,
                             ULONG Profile,
                             ULONG Flags
                             )
{
    m_LastCR = CM_Set_HW_Prof_Flags_Ex((LPTSTR)DeviceID, Profile, Flags, 0,
                                       m_hMachine);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetCurrentHwProfile(
                               ULONG* phwpf
                               )
{
    HWPROFILEINFO hwpfInfo;
    ASSERT(phwpf);

    if (CmGetHwProfileInfo(0xFFFFFFFF, &hwpfInfo)) {
        *phwpf = hwpfInfo.HWPI_ulHWProfile;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetHwProfileInfo(
                            int Index,
                            PHWPROFILEINFO pHwProfileInfo
                            )
{
    m_LastCR = CM_Get_Hardware_Profile_Info_Ex(Index, pHwProfileInfo, 0, m_hMachine);

    return(CR_SUCCESS == m_LastCR);
}

ULONG
CMachine::CmGetResDesDataSize(
                             RES_DES rd
                             )
{
    ULONG Size;

    m_LastCR = CM_Get_Res_Des_Data_Size_Ex(&Size, rd, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return Size;
    }

    return 0;
}

BOOL
CMachine::CmGetResDesData(
                         RES_DES rd,
                         PVOID Buffer,
                         ULONG BufferSize
                         )
{
    m_LastCR = CM_Get_Res_Des_Data_Ex(rd, Buffer, BufferSize, 0, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetNextResDes(
                         PRES_DES  prdNext,
                         RES_DES   rd,
                         RESOURCEID ForResource,
                         PRESOURCEID pTheResource
                         )
{
    m_LastCR = CM_Get_Next_Res_Des_Ex(prdNext, rd, ForResource, pTheResource,
                                      0, m_hMachine);
    return(CR_SUCCESS == m_LastCR);
}

void
CMachine::CmFreeResDesHandle(
                            RES_DES rd
                            )
{
    m_LastCR = CM_Free_Res_Des_Handle(rd);
}

void
CMachine::CmFreeResDes(
                      PRES_DES prdPrev,
                      RES_DES  rd
                      )
{
    m_LastCR = CM_Free_Res_Des_Ex(prdPrev, rd, 0, m_hMachine);
}

void
CMachine::CmFreeLogConfHandle(
                             LOG_CONF lc
                             )
{
    m_LastCR = CM_Free_Log_Conf_Handle(lc);
}

BOOL
CMachine::CmGetFirstLogConf(
                           DEVNODE dn,
                           LOG_CONF* plc,
                           ULONG Type
                           )
{
    m_LastCR = CM_Get_First_Log_Conf_Ex(plc, dn, Type, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

CONFIGRET
CMachine::CmGetRegistryProperty(
                               DEVNODE dn,
                               ULONG Property,
                               PVOID pBuffer,
                               ULONG* pBufferSize
                               )
{
    return CM_Get_DevNode_Registry_Property_Ex(dn, Property, NULL,
                                               pBuffer, pBufferSize,
                                               0, m_hMachine
                                              );
}

CONFIGRET
CMachine::CmGetRegistrySoftwareProperty(
                                       DEVNODE dn,
                                       LPCTSTR ValueName,
                                       PVOID pBuffer,
                                       ULONG* pBufferSize
                                       )
{
    HKEY hKey;
    DWORD Type = REG_SZ;
    CONFIGRET CR;

    if (CR_SUCCESS == (CR = CM_Open_DevNode_Key_Ex(dn, KEY_READ, 0, RegDisposition_OpenExisting,
                                                   &hKey, CM_REGISTRY_SOFTWARE, m_hMachine))) {

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, ValueName, NULL, &Type, (const PBYTE)pBuffer,
                                             pBufferSize)) {

            CR = CR_REGISTRY_ERROR;
        }

        RegCloseKey(hKey);
    }

    return CR;
}

CMachineList::~CMachineList()
{
    if (!m_listMachines.IsEmpty()) {
        POSITION pos = m_listMachines.GetHeadPosition();
        CMachine* pMachine;

        while (NULL != pos) {
            pMachine = m_listMachines.GetNext(pos);
            delete pMachine;
        }

        m_listMachines.RemoveAll();
    }
}

//
// This function creates a machine object on the given machine name
// INPUT:
//      MachineName -- the machine name. Must be in full qualified format
//                     NULL means the local machine
//      ppMachine  -- buffer to receive the newly create machine.
//
// OUTPUT:
//      TRUE  if the machine is created successfully. ppMachine
//            is filled with the newly created Machine.
//      FALSE if the function failed.
// NOTE:
//      The caller should NOT free any machine object retruned
//      from this function.
//
BOOL
CMachineList::CreateMachine(
                           LPCTSTR MachineName,
                           CMachine** ppMachine
                           )
{
    ASSERT(ppMachine);
    
    *ppMachine =  NULL;

    CMachine* pMachine = NULL;

    if (!MachineName || _T('\0') == MachineName[0]) {
        //
        // Local machine.
        //
        String strMachineName;
        strMachineName.GetComputerName();
        pMachine = FindMachine(strMachineName);
    }

    else {
        pMachine = FindMachine(MachineName);
    }

    if (NULL == pMachine) {
        pMachine = new CMachine(MachineName);
        m_listMachines.AddTail(pMachine);
    }

    *ppMachine = pMachine;

    return NULL != pMachine;
}

CMachine*
CMachineList::FindMachine(
                         LPCTSTR MachineName
                         )
{
    if (!m_listMachines.IsEmpty()) {
        POSITION pos = m_listMachines.GetHeadPosition();

        while (NULL != pos) {
            CMachine* pMachine;
            pMachine = m_listMachines.GetNext(pos);

            if (!lstrcmpi(MachineName, pMachine->GetMachineFullName())) {
                return pMachine;
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\machine.h ===
#ifndef __MACHINE_H_
#define __MACHINE_H_

/*++

Copyright (C) Microsoft Corporation

Module Name:

    machine.h

Abstract:

    header file that declares CMachine, CDevInfoist and CMachineList classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

LRESULT CALLBACK dmNotifyWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef BOOL (*LPFNINSTALLDEVINST)(HWND hwndParent, LPCTSTR DeviceId, BOOL UpdateDriver, DWORD* pReboot);
typedef BOOL (*LPFNROLLBACKDRIVER)(HWND hwndParent, LPCTSTR RegistryKey, DWORD Flags, DWORD* pReboot);

class CDevice;
class CClass;
class CComputer;
class CLogConf;
class CResDes;
class CMachineList;
class CFolder;

#define DM_NOTIFY_TIMERID           0x444d4d44

//This class represents SETUPAPI's <Device Information List>
//
// WARNING !!!
// no copy constructor and assignment operator are provided ---
// DO NOT ASSIGN A CDevInfoList from one to another!!!!!
class CDevInfoList
{
public:

    CDevInfoList(HDEVINFO hDevInfo = INVALID_HANDLE_VALUE, HWND hwndParent = NULL)
            :m_hDevInfo(hDevInfo), m_hwndParent(hwndParent)
        {
        }
    virtual ~CDevInfoList()
        {
            if (INVALID_HANDLE_VALUE != m_hDevInfo)
                DiDestroyDeviceInfoList();
        }

    operator HDEVINFO()
        {
            return m_hDevInfo;
        }
    BOOL DiGetDeviceInfoListDetail(PSP_DEVINFO_LIST_DETAIL_DATA DetailData)
        {
           return SetupDiGetDeviceInfoListDetail(m_hDevInfo, DetailData);
        }
    BOOL DiOpenDeviceInfo(LPCTSTR DeviceID, HWND hwndParent, DWORD OpenFlags,
                          PSP_DEVINFO_DATA DevData)
        {
           return SetupDiOpenDeviceInfo(m_hDevInfo, DeviceID, hwndParent, OpenFlags,
                                        DevData);
        }
    BOOL DiEnumDeviceInfo(DWORD Index, PSP_DEVINFO_DATA DevData)
        {
            return SetupDiEnumDeviceInfo(m_hDevInfo, Index, DevData);
        }
    BOOL DiBuildDriverInfoList(PSP_DEVINFO_DATA DevData, DWORD DriverType)
        {
            return SetupDiBuildDriverInfoList(m_hDevInfo, DevData, DriverType);
        }
    BOOL DiEnumDriverInfo(PSP_DEVINFO_DATA DevData, DWORD DriverType, DWORD Index,
                          PSP_DRVINFO_DATA DrvData)
        {
            return  SetupDiEnumDriverInfo(m_hDevInfo, DevData, DriverType, Index, DrvData);
        }
    BOOL DiDestroyDriverInfoList(PSP_DEVINFO_DATA DevData, DWORD DriverType)
        {
            return SetupDiDestroyDriverInfoList(m_hDevInfo, DevData, DriverType);
        }
    BOOL DiCallClassInstaller(DI_FUNCTION InstallFunction, PSP_DEVINFO_DATA DevData)
        {
            return SetupDiCallClassInstaller(InstallFunction, m_hDevInfo, DevData);
        }
    BOOL DiChangeState(PSP_DEVINFO_DATA DevData)
        {
            return SetupDiChangeState(m_hDevInfo, DevData);
        }
    HKEY DiOpenDevRegKey(PSP_DEVINFO_DATA DevData, DWORD Scope, DWORD HwProfile,
                         DWORD KeyType, REGSAM samDesired)
        {
            return  SetupDiOpenDevRegKey(m_hDevInfo, DevData, Scope, HwProfile,
                                  KeyType, samDesired);
        }
    BOOL DiGetDeviceRegistryProperty(PSP_DEVINFO_DATA DevData, DWORD Property,
                                     PDWORD PropertyDataType, PBYTE PropertyBuffer,
                                     DWORD PropertyBufferSize, PDWORD RequiredSize)
        {
            return SetupDiGetDeviceRegistryProperty(m_hDevInfo, DevData,
                                              Property, PropertyDataType,
                                              PropertyBuffer,
                                              PropertyBufferSize,
                                              RequiredSize
                                              );
        }
    BOOL DiGetDeviceInstallParams(PSP_DEVINFO_DATA DevData,
                                  PSP_DEVINSTALL_PARAMS DevInstParams)
        {
            return SetupDiGetDeviceInstallParams(m_hDevInfo, DevData, DevInstParams);
        }
    BOOL DiGetClassInstallParams(PSP_DEVINFO_DATA DevData,
                                 PSP_CLASSINSTALL_HEADER ClassInstallHeader,
                                 DWORD ClassInstallParamsSize,
                                 PDWORD RequiredSize)
        {
            return SetupDiGetClassInstallParams(m_hDevInfo, DevData,
                                          ClassInstallHeader,
                                          ClassInstallParamsSize,
                                          RequiredSize);
        }
    BOOL DiSetDeviceInstallParams(PSP_DEVINFO_DATA DevData,
                                PSP_DEVINSTALL_PARAMS DevInstParams)
        {
             return SetupDiSetDeviceInstallParams(m_hDevInfo, DevData, DevInstParams);
        }
    BOOL DiSetClassInstallParams(PSP_DEVINFO_DATA DevData,
                                 PSP_CLASSINSTALL_HEADER ClassInstallHeader,
                                 DWORD ClassInstallParamsSize)
        {
            return SetupDiSetClassInstallParams(m_hDevInfo, DevData,
                                     ClassInstallHeader,
                                     ClassInstallParamsSize);
        }
    BOOL DiGetClassDevPropertySheet(PSP_DEVINFO_DATA DevData,
                                    LPPROPSHEETHEADER PropertySheetHeader,
                                    DWORD PagesAllowed,
                                    DWORD Flags)
        {
            return  SetupDiGetClassDevPropertySheets(m_hDevInfo, DevData,
                                        PropertySheetHeader, PagesAllowed,
                                        NULL, Flags);
        }

    BOOL DiGetExtensionPropSheetPage(PSP_DEVINFO_DATA DevData,
                                     LPFNADDPROPSHEETPAGE pfnAddPropSheetPage,
                                     DWORD PageType,
                                     LPARAM lParam
                                     );

    BOOL DiGetSelectedDriver(PSP_DEVINFO_DATA DevData, PSP_DRVINFO_DATA DriverInfoData)
        {
            return SetupDiGetSelectedDriver(m_hDevInfo, DevData, DriverInfoData);
        }
    BOOL DiSetSelectedDriver(PSP_DEVINFO_DATA DevData, PSP_DRVINFO_DATA DriverInfoData)
        {
            return SetupDiSetSelectedDriver(m_hDevInfo, DevData, DriverInfoData);
        }
    BOOL DiTurnOnDiFlags(PSP_DEVINFO_DATA DevData, DWORD FlagMask );
    BOOL DiTurnOffDiFlags(PSP_DEVINFO_DATA DevData, DWORD FlagsMask);
    BOOL DiTurnOnDiExFlags(PSP_DEVINFO_DATA DevData, DWORD FlagMask );
    BOOL DiTurnOffDiExFlags(PSP_DEVINFO_DATA DevData, DWORD FlagsMask);
    BOOL InstallDevInst(HWND hwndParent, LPCTSTR DeviceID, BOOL UpdateDriver, DWORD* pReboot);
    BOOL RollbackDriver(HWND hwndParent, LPCTSTR RegistryKeyName, DWORD Flags, DWORD* pReboot);
    DWORD DiGetFlags(PSP_DEVINFO_DATA DevData = NULL);
    DWORD DiGetExFlags(PSP_DEVINFO_DATA DevData = NULL);
    void DiDestroyDeviceInfoList();
    HWND OwnerWindow()
        {
            return m_hwndParent;
        }
protected:
    HDEVINFO    m_hDevInfo;
    HWND        m_hwndParent;

private:
    CDevInfoList(const CDevInfoList&);
    CDevInfoList& operator=(const CDevInfoList&);
};

class CMachine : public CDevInfoList
{
public:
    CMachine(LPCTSTR MachineName = NULL);

    virtual ~CMachine();
    operator HMACHINE()
        {
            return m_hMachine;
        }
    LPCTSTR GetMachineDisplayName()
        {
            return (LPCTSTR)m_strMachineDisplayName;
        }
    LPCTSTR GetMachineFullName()
        {
            return (LPCTSTR)m_strMachineFullName;
        }
    LPCTSTR GetRemoteMachineFullName()
        {
            return m_IsLocal ? NULL : (LPCTSTR)m_strMachineFullName;
        }
    HMACHINE GetHMachine()
        {
            return m_hMachine;
        }
    BOOL IsLocal()
        {
            return m_IsLocal;
        }
    BOOL AttachFolder(CFolder* pFolder);
    void DetachFolder(CFolder* pFolder);
    BOOL IsFolderAttached(CFolder* pFolder);
    BOOL AttachPropertySheet(HWND hwndPropertySheet);
    void DetachPropertySheet(HWND hwndPropertySheet);
    HWND GetDeviceWindowHandle(LPCTSTR DeviceId);
    HWND GetClassWindowHandle(LPGUID ClassGuid);
    BOOL AttachChildMachine(CMachine* ChildMachine);
    void DetachChildMachine(CMachine* ChildMachine);

    BOOL Initialize(
        HWND hwndParent = NULL, 
        LPCTSTR DeviceId = NULL,
        LPGUID ClassGuid = NULL
        );

    DWORD GetNumberOfDevices() const
        {
            return (DWORD)m_listDevice.GetCount();
        }
    BOOL GetFirstClass(CClass** ppClass, PVOID& Context);
    BOOL GetNextClass(CClass** ppClass, PVOID&  Context);
    BOOL GetFirstDevice(CDevice** ppDevice,  PVOID&  Context);
    BOOL GetNextDevice(CDevice** ppDevice, PVOID&  Context);
    CDevice* DevNodeToDevice(DEVNODE dn);
    BOOL Reenumerate();
    BOOL DoMiniRefresh();
    BOOL Refresh();
    BOOL DestroyNotifyWindow();
    int GetComputerIconIndex()
    {
        return m_ComputerIndex;
    }
    int GetResourceIconIndex()
    {
        return m_ResourceIndex;
    }
    BOOL ShouldPropertySheetDestroy()
    {
        return m_PropertySheetShoudDestroy;
    }
    void SetPropertySheetShouldDestroy()
    {
        m_PropertySheetShoudDestroy = TRUE;
    }
    BOOL GetInfDigitalSigner(LPCTSTR FullInfPath, String& DigitalSigner);
    BOOL DoNotCreateDevice(SC_HANDLE SCMHandle, LPGUID ClassGuid, DEVINST DevInst);
    BOOL IsUserAGuest()
        {
            return m_UserIsAGuest;
        }
    HDEVINFO DiCreateDeviceInfoList(LPGUID ClassGuid, HWND hwndParent)
        {
            return SetupDiCreateDeviceInfoListEx(ClassGuid, hwndParent,
                                GetRemoteMachineFullName(), NULL);
        }
    HDEVINFO DiGetClassDevs(LPGUID ClassGuid, LPCTSTR Enumerator, HWND hwndParent, DWORD Flags)
        {
            return SetupDiGetClassDevsEx(ClassGuid, Enumerator, hwndParent,
                                     Flags, NULL, GetRemoteMachineFullName(), NULL
                                     );
        }
    HIMAGELIST DiGetClassImageList()
        {
            return m_ImageListData.ImageList;
        }
    BOOL DiBuildClassInfoList(DWORD Flags, LPGUID ClassGuid,
                              DWORD ClassGuidListSize, PDWORD RequiredSize)
        {
            return SetupDiBuildClassInfoListEx(Flags, ClassGuid,
                                     ClassGuidListSize, RequiredSize,
                                     GetRemoteMachineFullName(), NULL);
        }
    HKEY DiOpenClassRegKey(LPGUID ClassGuid, REGSAM samDesired, DWORD Flags)
        {
            return SetupDiOpenClassRegKeyEx(ClassGuid, samDesired, Flags,
                                    GetRemoteMachineFullName(), NULL);
        }
    BOOL DiLoadClassIcon(LPGUID ClassGuid, HICON* LargeIcon, PINT MiniIconIndex)
        {
            return SetupDiLoadClassIcon(ClassGuid, LargeIcon, MiniIconIndex);
        }
    BOOL DiGetClassImageList(PSP_CLASSIMAGELIST_DATA pImageListData)
        {
            return SetupDiGetClassImageListEx(pImageListData,
                                   GetRemoteMachineFullName(), NULL);
        }
    BOOL DiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA pImageListData)
        {
            return SetupDiDestroyClassImageList(pImageListData);
        }

    BOOL DiGetClassImageIndex(LPGUID ClassGuid, PINT ImageIndex)
        {
            return SetupDiGetClassImageIndex(&m_ImageListData, ClassGuid, ImageIndex);
        }
    BOOL DiClassNameFromGuid(LPGUID ClassGuid, LPTSTR ClassName,
                             DWORD ClassNameSize, PDWORD RequiredSize)
        {
            return SetupDiClassNameFromGuidEx(ClassGuid, ClassName,
                                      ClassNameSize, RequiredSize,
                                      GetRemoteMachineFullName(), NULL);
        }
    BOOL DiGetClassFriendlyNameString(LPGUID Guid, String& strClass);
    BOOL DiDestroyDeviceInfoList(HDEVINFO hDevInfo)
        {
            return SetupDiDestroyDeviceInfoList(hDevInfo);
        }

///////////////////////////////////////////////////////////////////////////
//// Configuration Manager APIs
////
    CONFIGRET GetLastCR()
        {
            return m_LastCR;
        }
    BOOL CmGetConfigFlags(DEVNODE dn, DWORD* pFlags);
    BOOL CmGetCapabilities(DEVNODE dn, DWORD* pCapabilities);
    BOOL CmGetDeviceIDString(DEVNODE dn, String& str);
    BOOL CmGetDescriptionString(DEVNODE dn, String& str);
    BOOL CmGetMFGString(DEVNODE dn, String& str);
    BOOL CmGetProviderString(DEVNODE dn, String& str);
    BOOL CmGetDriverDateString(DEVNODE dn, String& str);
    BOOL CmGetDriverDateData(DEVNODE dn, FILETIME *ft);
    BOOL CmGetDriverVersionString(DEVNODE dn, String& str);
    BOOL CmGetClassGuid(DEVNODE dn, GUID& Guid);
    BOOL CmGetStatus(DEVNODE dn, DWORD* pProblem, DWORD* pStatus);
    BOOL CmGetKnownLogConf(DEVNODE dn, LOG_CONF* plc, DWORD* plcType);
    BOOL CmReenumerate(DEVNODE dn, ULONG Flags);
    BOOL CmGetHwProfileFlags(DEVNODE dn, ULONG Profile, ULONG* pFlags);
    BOOL CmGetHwProfileFlags(LPCTSTR DeviceID, ULONG Profile, ULONG* pFlags);
    BOOL CmSetHwProfileFlags(DEVNODE dn, ULONG Profile, ULONG Flags);
    BOOL CmSetHwProfileFlags(LPCTSTR DeviceID, ULONG Profile, ULONG Flags);
    BOOL CmGetCurrentHwProfile(ULONG* phwpf);
    BOOL CmGetHwProfileInfo(int Index, PHWPROFILEINFO pHwProfileInfo);
    BOOL CmGetBusGuid(DEVNODE dn, LPGUID Guid);
    BOOL CmGetBusGuidString(DEVNODE dn, String& str);
    DEVNODE CmGetParent(DEVNODE dn);
    DEVNODE CmGetChild(DEVNODE dn);
    DEVNODE CmGetSibling(DEVNODE dn);
    DEVNODE CmGetRootDevNode();
    BOOL CmHasResources(DEVNODE dn);
    DWORD CmGetResDesDataSize(RES_DES rd);
    BOOL CmGetResDesData(RES_DES rd, PVOID pData, ULONG DataSize);

    BOOL CmGetNextResDes(PRES_DES prdNext, RES_DES rd, RESOURCEID ForResource,
                          PRESOURCEID pTheResource);
    void CmFreeResDesHandle(RES_DES rd);
    void CmFreeResDes(PRES_DES prdPrev, RES_DES rd);
    void CmFreeLogConfHandle(LOG_CONF lc);
    BOOL CmGetFirstLogConf(DEVNODE dn, LOG_CONF* plc, ULONG Type);
    CONFIGRET CmGetRegistryProperty(DEVNODE dn, ULONG Property,
                                    PVOID pBuffer,
                                    ULONG* BufferSize);

    BOOL EnableRefresh(BOOL fEnable);
    BOOL ScheduleRefresh();
    void Lock()
        {
            EnterCriticalSection(&m_CriticalSection);
        }
    void Unlock()
        {
            LeaveCriticalSection(&m_CriticalSection);
        }
    CComputer*  m_pComputer;
    CMachine*   m_ParentMachine;
    UINT        m_msgRefresh;

private:

        // no copy constructor and no assigment operator
        CMachine(const CMachine& MachineSrc);
        CMachine& operator=(const CMachine& MachineSrc);

        BOOL BuildClassesFromGuidList(LPGUID GuidList, DWORD Guids);
        CONFIGRET CmGetRegistrySoftwareProperty(DEVNODE dn, LPCTSTR ValueName,
                                        PVOID pBuffer, ULONG* pBufferSize);
        void CreateDeviceTree(CDevice* pParent, CDevice* pSibling, DEVNODE dn);
        BOOL CreateClassesAndDevices(LPCTSTR DeviceId = NULL, LPGUID ClassGuid = NULL);
        void DestroyClassesAndDevices();
        BOOL CreateNotifyWindow();
        String          m_strMachineDisplayName;
        String          m_strMachineFullName;
        HMACHINE        m_hMachine;
        CONFIGRET       m_LastCR;
        CList<CClass*, CClass*> m_listClass;
        SP_CLASSIMAGELIST_DATA  m_ImageListData;
        int             m_ComputerIndex;
        int             m_ResourceIndex;
        CList<CDevice*, CDevice*> m_listDevice;
        DWORD           m_Flags;
        BOOL            m_Initialized;
        BOOL            m_IsLocal;
        BOOL            m_PropertySheetShoudDestroy;
        BOOL            m_UserIsAGuest;
        HWND            m_hwndNotify;
        CList<CFolder*, CFolder*> m_listFolders;
        int             m_RefreshDisableCounter;
        BOOL            m_RefreshPending;
        BOOL            m_ShowNonPresentDevices;
        CRITICAL_SECTION m_CriticalSection;
        CRITICAL_SECTION m_PropertySheetCriticalSection;
        CRITICAL_SECTION m_ChildMachineCriticalSection;
        CList<HWND, HWND> m_listPropertySheets;
        CList<CMachine*, CMachine*> m_listChildMachines;
};


class CMachineList
{
public:
    CMachineList() {};
    ~CMachineList();
    BOOL CreateMachine(LPCTSTR MachineName, CMachine** ppMachine);
    CMachine* FindMachine(LPCTSTR MachineName);
private:
    CMachineList(const CMachineList& MachineListSrc);
    CMachineList& operator=(const CMachineList& MachineListSrc);
    CList<CMachine*, CMachine*> m_listMachines;
};
#endif  //__MACHINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\hwtab.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    hwtab.cpp

Abstract:

    implement the hardware tab functions and UI.

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include <commctrl.h>
#include <comctrlp.h>
#include <windowsx.h>
#include <hwtab.h>

#define THIS_DLL g_hInstance

/*****************************************************************************
 *
 *  Exported stuff
 *
 *****************************************************************************/

// Stuff in api.h that we can't #include because api.h can't be #include'd
// by anyone other than api.cpp.

STDAPI_(int)
DevicePropertiesExA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesExW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DeviceProblemWizardA(
    HWND      hwndParent,
    LPCSTR    MachineName,
    LPCSTR    DeviceId
    );

STDAPI_(int)
DeviceProblemWizardW(
    HWND    hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    );

STDAPI_(UINT)
DeviceProblemTextA(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPSTR Buffer,
    UINT   BufferSize
    );

STDAPI_(UINT)
DeviceProblemTextW(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPWSTR Buffer,
    UINT   BufferSize
    );



#define DevicePropertiesEx  DevicePropertiesExW
#define DeviceProblemWizard DeviceProblemWizardW
#define DeviceProblemText   DeviceProblemTextW

/*****************************************************************************
 *
 *  General remark about SetupDi functions
 *
 *      Windows NT and Windows 98 implement many of the SetupDi query
 *      functions differently if you are querying for the buffer size.
 *
 *      Windows 98 returns FALSE, and GetLastError() returns
 *      ERROR_INSUFFICIENT_BUFFER.
 *
 *      Windows NT returns TRUE.
 *
 *      So all calls to SetupDi functions that do querying for the buffer
 *      size should be wrapped with BUFFERQUERY_SUCCEEDED.
 *
 *****************************************************************************/

#define BUFFERQUERY_SUCCEEDED(f)    \
            ((f) || GetLastError() == ERROR_INSUFFICIENT_BUFFER)

/*****************************************************************************
 *
 *  Context help
 *
 *****************************************************************************/

#include "devgenpg.h"

#define idh_devmgr_hardware_trblsht     400100
#define idh_devmgr_hardware_properties  400200
#define idh_devmgr_hardware_listview    400300

const DWORD c_HWTabHelpIDs[] =
{
    IDC_HWTAB_LVSTATIC,     idh_devmgr_hardware_listview,
    IDC_HWTAB_LISTVIEW,     idh_devmgr_hardware_listview,
    IDC_HWTAB_GROUPBOX,     IDH_DISABLEHELP,
    IDC_HWTAB_MFG,          idh_devmgr_general_manufacturer,
    IDC_HWTAB_LOC,          idh_devmgr_general_location,
    IDC_HWTAB_STATUS,       idh_devmgr_general_device_status,
    IDC_HWTAB_TSHOOT,       idh_devmgr_hardware_trblsht,
    IDC_HWTAB_PROP,         idh_devmgr_hardware_properties,
        0, 0
};

typedef TCHAR TLINE[LINE_LEN];

typedef struct
{
    int devClass;
    int dsaItem;

} LISTITEM, *LPLISTITEM;


typedef struct
{
    GUID                    devGuid;            // device class guid we are managing
    TLINE                   tszClass;           // Array of friendly name of class
    HDSA                    hdsaDinf;           // array of SP_DEVINFO_DATA structures
    HDEVINFO                hdev;               // hdsaDinfo refers to this
    int                     iImage;             // image index within master imagelist

} CLASSDATA, *LPCLASSDATA;

/*****************************************************************************
 *
 *  CHWTab
 *
 *      The Hardware Tab page.
 *
 *****************************************************************************/

class CHWTab {

private:
    CHWTab(const GUID *pguid, int iNumClass, DWORD dwViewMode);
    ~CHWTab();

    void *operator new(size_t cb) { return LocalAlloc(LPTR, cb); }
    void operator delete(void *p) { LocalFree(p); }

    void RebuildDeviceList();
    void Reset();
    BOOL GetDeviceRegistryProperty(HDEVINFO hDev, DWORD dwProp, PSP_DEVINFO_DATA pdinf,
                                  LPTSTR ptsz, DWORD ctch);
    void SprintfItem(UINT ids, UINT idc, LPCTSTR ptszText);

    static INT_PTR CALLBACK DialogProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ParentSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uidSubclass, DWORD_PTR dwRefData);
    friend HWND DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);
    friend HWND DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode);

    BOOL OnInitDialog(HWND hdlg);
    void RemoveListItems(HWND hwndList);
    void OnItemChanged(LPNMLISTVIEW pnmlv);
    void OnProperties(void);
    void OnTshoot(void);
    void OnSetText(LPCTSTR ptszText);
    void OnHelp(LPHELPINFO phi);
    void OnContextMenu(HWND hwnd);

    void SetControlPositions(int idcFirst, int idcLast, int dx, int dy, UINT flags);

    //
    //  Helpers for SetWindowPositions.
    //
    void GrowControls(int idcFirst, int idcLast, int dx, int dy) {
        SetControlPositions(idcFirst, idcLast, dx, dy, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
    }
    void ShiftControls(int idcFirst, int idcLast, int dx, int dy) {
        SetControlPositions(idcFirst, idcLast, dx, dy, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    void RepositionControls();

    inline PSP_DEVINFO_DATA GetPdinf(LPLISTITEM pListItem) {
        return (PSP_DEVINFO_DATA)DSA_GetItemPtr(_pCD[pListItem->devClass].hdsaDinf, pListItem->dsaItem);
    }

private:
    HWND        _hdlg;                          // the dialog box itself
    HWND        _hwndList;                      // The listview
    int         _iNumClass;                     // Number of class guids
    DWORD       _dwViewMode;                    // Dictates size of list box
    LPCLASSDATA _pCD;                           // Class data for each devClass to represent
    SP_CLASSIMAGELIST_DATA _imageListData;      // Class image list data
};


//
//  Constructor.
//
CHWTab::CHWTab(const GUID *pguid, int iNumClass, DWORD dwViewMode) :
                    _pCD(NULL)
{
    // Since the _dwViewMode is a devisor, we need to make sure it's valid
    _imageListData.ImageList = NULL;
    _dwViewMode     = dwViewMode;
    if (_dwViewMode < HWTAB_LARGELIST)
    {
        _dwViewMode = HWTAB_LARGELIST;
    }
    if (_dwViewMode > HWTAB_SMALLLIST)
    {
        _dwViewMode = HWTAB_SMALLLIST;
    }

    _iNumClass = iNumClass;
    _pCD = new CLASSDATA[_iNumClass];

    if (_pCD && pguid)
    {
        DWORD cbRequired;

        memset(_pCD, 0, sizeof(CLASSDATA) * _iNumClass);

        int devClass;
        for (devClass = 0; devClass < _iNumClass; devClass++)
        {
            _pCD[devClass].hdev        = INVALID_HANDLE_VALUE;
            _pCD[devClass].devGuid     = (GUID) pguid[devClass];
        }
        
        //get the driver class image list
        _imageListData.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
        if (!SetupDiGetClassImageList(&_imageListData)) {
            _imageListData.ImageList = NULL;
        }

        for (devClass = 0; devClass < _iNumClass; devClass++)
        {
            _pCD[devClass].iImage = -1;

            SetupDiGetClassDescription(&_pCD[devClass].devGuid, _pCD[devClass].tszClass, sizeof(TLINE), &cbRequired);

            if (_imageListData.ImageList)
            {
                // Get the image index for our little guy
                int iImageIndex;

                if (SetupDiGetClassImageIndex(&_imageListData, &_pCD[devClass].devGuid, &iImageIndex)) {
                    _pCD[devClass].iImage = iImageIndex;
                }
            }
        }
    }
}

CHWTab::~CHWTab()
{
    Reset();
    
    if (_imageListData.ImageList) {
        SetupDiDestroyClassImageList(&_imageListData);
    }

    if (_pCD)
    {
        delete _pCD;
        _pCD = NULL;
    }
}

//
//  Return to normal, ready for the next go-round.  This also frees all
//  dynamically allocated stuff.
//
void
CHWTab::Reset()
{
    int devClass;

    for (devClass = 0; devClass < _iNumClass; devClass++)
    {
        if (_pCD[devClass].hdsaDinf) {
            DSA_Destroy(_pCD[devClass].hdsaDinf);
            _pCD[devClass].hdsaDinf = NULL;
        }

        if (_pCD[devClass].hdev != INVALID_HANDLE_VALUE) {
            SetupDiDestroyDeviceInfoList(_pCD[devClass].hdev);
            _pCD[devClass].hdev = INVALID_HANDLE_VALUE;
        }
    }

}

//
//  Helper function that calls SetupDiGetDeviceRegistryProperty
//  and copes with things like detecting the various error modes
//  properly.
//

BOOL
CHWTab::GetDeviceRegistryProperty(HDEVINFO hDev, DWORD dwProp, PSP_DEVINFO_DATA pdinf,
                                  LPTSTR ptsz, DWORD ctch)
{
    DWORD cbRequired;
    ptsz[0] = TEXT('\0');
    SetupDiGetDeviceRegistryProperty(hDev, pdinf, dwProp, 0,
                                     (LPBYTE)ptsz, ctch * sizeof(TCHAR),
                                     &cbRequired);
    return ptsz[0];
}

//
//  Change the size/position of controls idcFirst through idcLast.
//  Change the size/position by (dx, dy).
//  flags specifies what exactly is changing.
//
void
CHWTab::SetControlPositions(int idcFirst, int idcLast, int dx, int dy, UINT flags)
{
    HDWP hdwp = BeginDeferWindowPos(idcLast - idcFirst + 1);
    for (int idc = idcFirst; idc <= idcLast; idc++) {
        if (hdwp) {
            RECT rc;
            HWND hwnd = GetDlgItem(_hdlg, idc);
            GetWindowRect(hwnd, &rc);
            MapWindowRect(HWND_DESKTOP, _hdlg, &rc);
            hdwp = DeferWindowPos(hdwp, hwnd, NULL,
                        rc.left + dx, rc.top + dy,
                        rc.right - rc.left + dx, rc.bottom - rc.top + dy,
                        flags);
        }
    }
    if (hdwp) {
        EndDeferWindowPos(hdwp);
    }
}

//
//  Reposition and resize our controls based on the size we need to be.
//
void
CHWTab::RepositionControls()
{
    //
    //  First, see how much slack space we have.
    //
    RECT rcDlg, rcParent;
    GetClientRect(_hdlg, &rcDlg);
    GetClientRect(GetParent(_hdlg), &rcParent);

    //
    //  Make ourselves as big as our parent.
    //
    SetWindowPos(_hdlg, NULL, 0, 0, rcParent.right, rcParent.bottom,
                 SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

    //
    //  Now do a little more math...
    //
    int cyExtra = rcParent.bottom - rcDlg.bottom;
    int cxExtra = rcParent.right  - rcDlg.right;

    //
    //  The extra vertical space is split between the listview and
    //  the groupbox.  The amount of split is determined by _dwViewMode.
    //  Larger modes give more and more space to the listview.
    //
    int cyTop = cyExtra / _dwViewMode;
    int cyBottom = cyExtra - cyTop;

    //
    //  Horizontally grow the controls that reach the full width of the
    //  dialog box.
    //
    GrowControls(IDC_HWTAB_HSIZEFIRST, IDC_HWTAB_HSIZELAST, cxExtra, 0);

    //
    //  Grow the top half.
    //
    GrowControls(IDC_HWTAB_LISTVIEW, IDC_HWTAB_LISTVIEW, 0, cyTop);

    //
    //  Move all the bottom things down.
    //
    ShiftControls(IDC_HWTAB_VMOVEFIRST, IDC_HWTAB_VMOVELAST, 0, cyTop);

    //
    //  Grow the groupbox by the pixels we are granting it.
    //
    GrowControls(IDC_HWTAB_VSIZEFIRST, IDC_HWTAB_VSIZELAST, 0, cyBottom);

    //
    //  And the buttons move with the bottom right corner.
    //
    ShiftControls(IDC_HWTAB_VDOWNFIRST, IDC_HWTAB_VDOWNLAST, cxExtra, cyBottom);

}

LRESULT
CHWTab::ParentSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uidSubclass, DWORD_PTR dwRefData)
{
    CHWTab *self = (CHWTab *)dwRefData;
    LRESULT lres = 0;

    UNREFERENCED_PARAMETER(uidSubclass);

    switch (wm)
    {
    case WM_SIZE:
        self->RepositionControls();
        break;

    case WM_NOTIFY:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        if (lres) break;            // Parent already handled
        lres = SendMessage(self->_hdlg, wm, wp, lp);
        break;

    // Work around a bug in USER where if you press Enter, the WM_COMMAND
    // gets sent to the wrong window if it belongs to a nested dialog.
    case WM_COMMAND:
        if (GET_WM_COMMAND_HWND(wp, lp) &&
            GetParent(GET_WM_COMMAND_HWND(wp, lp)) == self->_hdlg) {
            lres = SendMessage(self->_hdlg, wm, wp, lp);
        } else {
            lres = DefSubclassProc(hwnd, wm, wp, lp);
        }
        break;

    case WM_DISPLAYCHANGE:
    case WM_SETTINGCHANGE:
    case WM_SYSCOLORCHANGE:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        lres = SendMessage(self->_hdlg, wm, wp, lp);
        break;

    default:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;
    }
    return lres;
}

//
//  One-time dialog initialization.
//
BOOL
CHWTab::OnInitDialog(HWND hdlg)
{
    _hdlg = hdlg;
    _hwndList = GetDlgItem(_hdlg, IDC_HWTAB_LISTVIEW);

    SetWindowLongPtr(_hdlg, DWLP_USER, (LONG_PTR)this);

    RepositionControls();

    //
    //  The "Name" column gets 75% and the "Type" column gets 25%.
    //  Subtract out the size of a vertical scrollbar in case we
    //  get one.
    //
    RECT rc;
    GetClientRect(_hwndList, &rc);
    rc.right -= GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN col;
    TCHAR szTitle[64];

    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = rc.right * 3 / 4;
    col.pszText = szTitle;

    LoadString(THIS_DLL, IDS_HWTAB_LV_NAME, szTitle, ARRAYLEN(szTitle));
    ListView_InsertColumn(_hwndList, 0, &col);

    col.cx = rc.right - col.cx;
    LoadString(THIS_DLL, IDS_HWTAB_LV_TYPE, szTitle, ARRAYLEN(szTitle));
    ListView_InsertColumn(_hwndList, 1, &col);

    if (_imageListData.ImageList)
    {
        ListView_SetImageList(_hwndList, _imageListData.ImageList, LVSIL_SMALL);
    }

    ListView_SetExtendedListViewStyle(_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    // Need to subclass parent to take over all parent functionality
    if (!SetWindowSubclass(GetParent(hdlg), ParentSubclassProc, 0,
                           (DWORD_PTR)this)) 
    {
        DestroyWindow(hdlg);
    }

    return TRUE;
}

void
CHWTab::RemoveListItems(HWND hwndList)
{
    LVITEM lviName;
    LPLISTITEM plistItem;

    int cItems = ListView_GetItemCount(hwndList);
    int iItem;

    for (iItem = 0; iItem < cItems; iItem++)
    {
        lviName.mask = LVIF_PARAM;
        lviName.iSubItem = 0;                   // column 0
        lviName.iItem = iItem;

        ListView_GetItem(hwndList,&lviName);

        plistItem = (LPLISTITEM) lviName.lParam;

        if (plistItem)
        {
            delete plistItem;
        }
    }

    ListView_DeleteAllItems(_hwndList);
}


//
//  Rebuild the list of devices.
//
//  This is done whenever we get focus.  We cache the results from last time
//  and invalidate the cache when we are told that hardware has changed.

void
CHWTab::RebuildDeviceList()
{
    HCURSOR hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
    int devClass;

    // First clear out the existing listview
    RemoveListItems(_hwndList);
    Reset();


    // Get all the devices of our class

    for (devClass = 0; devClass < _iNumClass; devClass++)
    {
        _pCD[devClass].hdsaDinf = DSA_Create(sizeof(SP_DEVINFO_DATA), 4);

        if (!_pCD[devClass].hdsaDinf) goto done;

        _pCD[devClass].hdev = SetupDiGetClassDevs(&_pCD[devClass].devGuid, 0, 0,
                                    DIGCF_PROFILE | DIGCF_PRESENT);
        if (_pCD[devClass].hdev == INVALID_HANDLE_VALUE) goto done;


        // Study the class in preparation for adding it to our listview
        int idev;
        LVITEM lviName, lviType;
        TCHAR tszName[LINE_LEN];

        lviName.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lviName.iSubItem = 0;                       // column 0
        lviName.iImage = _pCD[devClass].iImage;    // image (or -1 if no image)
        lviName.pszText = tszName;                  // name goes here
        lviName.iItem = DA_LAST;                    // Always append

        // The second column contains the class description, which is the same
        // for all items.
        lviType.mask = LVIF_TEXT;
        lviType.iSubItem = 1;
        lviType.pszText = _pCD[devClass].tszClass;

        for (idev = 0; ; idev++)
        {
            SP_DEVINFO_DATA dinf;
            BOOL            fHidden = FALSE;

            dinf.cbSize = sizeof(dinf);


            if (SetupDiEnumDeviceInfo(_pCD[devClass].hdev, idev, &dinf)) {

                // Device status - Don't want to show devices with DN_NO_SHOW_IN_DM set, as a rule.
                ULONG Status, Problem;

                if (CM_Get_DevNode_Status_Ex(&Status, &Problem, dinf.DevInst, 0, NULL) == CR_SUCCESS)
                {
                    if (Status & DN_NO_SHOW_IN_DM)      // No, UI, mark this device as hidden.
                    {
                        fHidden = TRUE;
                    }
                }

                LPLISTITEM pListItem = new LISTITEM;

                if (!pListItem) break;

                pListItem->devClass = devClass;
                pListItem->dsaItem = DSA_AppendItem(_pCD[devClass].hdsaDinf, &dinf);
                lviName.lParam = (LPARAM) pListItem;

                if (lviName.lParam < 0)
                {
                    delete pListItem;
                    break;          // Out of memory
                }

                // Try the friendly name.  If that doesn't work, then try
                // the device name.  If that doesn't work, then say "Unknown".
                if (!GetDeviceRegistryProperty(_pCD[devClass].hdev, SPDRP_FRIENDLYNAME, &dinf, tszName, ARRAYLEN(tszName)) &&
                    !GetDeviceRegistryProperty(_pCD[devClass].hdev, SPDRP_DEVICEDESC  , &dinf, tszName, ARRAYLEN(tszName))) {
                    LoadString(THIS_DLL, IDS_HWTAB_UNKNOWN, tszName, ARRAYLEN(tszName));
                }

                // Give our parent a chance to filter the item before we insert it
                // Return TRUE to reject the item from the list.
                NMHWTAB nmht;
                nmht.nm.hwndFrom = _hdlg;
                nmht.nm.idFrom = 0;
                nmht.nm.code = HWN_FILTERITEM;
                nmht.hdev = _pCD[devClass].hdev;
                nmht.pdinf = &dinf;
                nmht.fHidden = fHidden;

                SendMessage(GetParent(_hdlg), WM_NOTIFY, nmht.nm.idFrom, (LPARAM)&nmht);

                if (!nmht.fHidden)
                {
                    // Add the Item
                    lviType.iItem = ListView_InsertItem(_hwndList, &lviName);
                    if (lviType.iItem >= 0)
                    {
                        ListView_SetItem(_hwndList, &lviType);
                    }
                    else
                    {
                        delete pListItem;
                    }
                }
                else
                {
                    // clean up the item; it got filtered away
                    delete pListItem;
                }
            }

            // Stop on any error after the 100'th device to keep us from going
            // berzerk if we start getting strange errors like ERROR_GENERAL_FAILURE.
            else if (GetLastError() == ERROR_NO_MORE_ITEMS || idev > 100) {
                break;
            }
        }

        // Select the first item so the info pane contains stuff
        ListView_SetItemState(_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED,
                                            LVIS_SELECTED | LVIS_FOCUSED);
    }

done:
    SetCursor(hcurPrev);
}

void
CHWTab::SprintfItem(UINT ids, UINT idc, LPCTSTR ptszText)
{
    TCHAR tszMsg[MAX_PATH];
    TCHAR tszOut[MAX_PATH + LINE_LEN];
    LoadString(THIS_DLL, ids, tszMsg, ARRAYLEN(tszMsg));
    StringCchPrintf(tszOut, ARRAYLEN(tszOut), tszMsg, ptszText);
    SetDlgItemText(_hdlg, idc, tszOut);
}

void
CHWTab::OnItemChanged(LPNMLISTVIEW pnmlv)
{
    PSP_DEVINFO_DATA pdinf;
    LPLISTITEM pListItem = (LPLISTITEM) pnmlv->lParam;

    if ((pnmlv->uChanged & LVIF_STATE)  &&
        (pnmlv->uNewState & LVIS_FOCUSED) &&
        (pdinf = GetPdinf(pListItem)) != NULL) {

        TCHAR tsz[LINE_LEN];

        // Manufacturer
        GetDeviceRegistryProperty(_pCD[pListItem->devClass].hdev, SPDRP_MFG, pdinf, tsz, ARRAYLEN(tsz));
        SprintfItem(IDS_HWTAB_MFG, IDC_HWTAB_MFG, tsz);

        // Location
        if (GetLocationInformation(pdinf->DevInst, tsz, ARRAYLEN(tsz), NULL) != CR_SUCCESS) {
            LoadString(g_hInstance, IDS_UNKNOWN, tsz, ARRAYLEN(tsz));
        }
        SprintfItem(IDS_HWTAB_LOC, IDC_HWTAB_LOC, tsz);

        // Device status - have to go to CM for this one
        ULONG Status, Problem;
        if (CM_Get_DevNode_Status_Ex(&Status, &Problem,
                                     pdinf->DevInst, 0, NULL) == CR_SUCCESS &&
            DeviceProblemText(NULL, pdinf->DevInst, Problem, tsz, ARRAYLEN(tsz))) {
            // Yippee
        } else {
            tsz[0] = TEXT('\0');        // Darn
        }
        SprintfItem(IDS_HWTAB_STATUS, IDC_HWTAB_STATUS, tsz);

        //let our parent know that something changed
        NMHWTAB nmht;
        nmht.nm.hwndFrom = _hdlg;
        nmht.nm.idFrom = 0;
        nmht.nm.code = HWN_SELECTIONCHANGED;
        nmht.hdev = _pCD[pListItem->devClass].hdev;
        nmht.pdinf = pdinf;

        SendMessage(GetParent(_hdlg), WM_NOTIFY, nmht.nm.idFrom, (LPARAM)&nmht);
    }
}

void
CHWTab::OnProperties(void)
{
    LVITEM lvi;
    PSP_DEVINFO_DATA pdinf;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;                   // column 0
    lvi.iItem = ListView_GetNextItem(_hwndList, -1, LVNI_FOCUSED);


    if (lvi.iItem >= 0 && ListView_GetItem(_hwndList, &lvi) &&
        (pdinf = GetPdinf((LPLISTITEM) lvi.lParam)) != NULL)
    {
        DWORD cchRequired;
        LPLISTITEM pListItem;
        LPTSTR ptszDevid;

        pListItem = (LPLISTITEM) lvi.lParam;
        if (BUFFERQUERY_SUCCEEDED(
                SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, NULL, 0, &cchRequired)) &&
            ((ptszDevid = (LPTSTR)LocalAlloc(LPTR, cchRequired * sizeof(TCHAR))) != NULL)) {
            if (SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, ptszDevid, cchRequired, NULL)) {
                DevicePropertiesEx(GetParent(_hdlg), NULL, ptszDevid, 0, FALSE);
            }
            LocalFree(ptszDevid);
        }
    }
}

void
CHWTab::OnTshoot(void)
{
    LVITEM lvi;
    PSP_DEVINFO_DATA pdinf;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;                   // column 0
    lvi.iItem = ListView_GetNextItem(_hwndList, -1, LVNI_FOCUSED);


    if (lvi.iItem >= 0 && ListView_GetItem(_hwndList, &lvi) &&
        (pdinf = GetPdinf((LPLISTITEM) lvi.lParam)) != NULL)
    {
        DWORD cchRequired;
        LPLISTITEM pListItem;
        LPTSTR ptszDevid;

        pListItem = (LPLISTITEM) lvi.lParam;
        if (BUFFERQUERY_SUCCEEDED(
                SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, NULL, 0, &cchRequired)) &&
            ((ptszDevid = (LPTSTR)LocalAlloc(LPTR, cchRequired * sizeof(TCHAR))) != NULL)) {
            if (SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, ptszDevid, cchRequired, NULL)) {
                DeviceProblemWizard(GetParent(_hdlg), NULL, ptszDevid);
            }
            LocalFree(ptszDevid);
        }
    }
}

//
//  SetText is how the caller tells us what our troubleshooter
//  command line is.
//
void
CHWTab::OnSetText(LPCTSTR ptszText)
{
    BOOL fEnable = ptszText && ptszText[0];
    HWND hwndTS = GetDlgItem(_hdlg, IDC_HWTAB_TSHOOT);
    EnableWindow(hwndTS, fEnable);
    ShowWindow(hwndTS, fEnable ? SW_SHOW : SW_HIDE);
}

void
CHWTab::OnHelp(LPHELPINFO phi)
{
    WinHelp((HWND)phi->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)c_HWTabHelpIDs);
}

void
CHWTab::OnContextMenu(HWND hwnd)
{
    WinHelp(hwnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)c_HWTabHelpIDs);
}

//
//  Dialog procedure (yay).
//
INT_PTR CALLBACK
CHWTab::DialogProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    CHWTab *self = (CHWTab *)GetWindowLongPtr(hdlg, DWLP_USER);

    if (wm == WM_INITDIALOG) {
        self = (CHWTab *)lp;
        return self->OnInitDialog(hdlg);
    }

    // Ignores messages that arrive before WM_INITDIALOG
    if (!self) return FALSE;

    switch (wm) {
    case WM_DISPLAYCHANGE:
    case WM_SETTINGCHANGE:
    case WM_SYSCOLORCHANGE:
        SendMessage(self->_hwndList, wm, wp, lp);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lp;
            switch (pnm->code) {
            case PSN_SETACTIVE:
                self->RebuildDeviceList();
                break;

            case LVN_ITEMCHANGED:
                if (pnm->hwndFrom == self->_hwndList) {
                    self->OnItemChanged((LPNMLISTVIEW)pnm);
                }
                break;

            case NM_DBLCLK:
                if (pnm->hwndFrom == self->_hwndList) {
                    DWORD dwPos = GetMessagePos();
                    LVHITTESTINFO hti;
                    hti.pt.x = GET_X_LPARAM(dwPos);
                    hti.pt.y = GET_Y_LPARAM(dwPos);
                    ScreenToClient(self->_hwndList, &hti.pt);
                    ListView_HitTest(self->_hwndList, &hti);
                    if (hti.iItem >= 0) {
                        self->OnProperties();
                    }
                }
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp)) {
        case IDC_HWTAB_PROP:
            self->OnProperties();
            break;

        case IDC_HWTAB_TSHOOT:
            self->OnTshoot();
            break;
        }
        break;

    case WM_SETTEXT:
        self->OnSetText((LPCTSTR)lp);
        break;

    case WM_NCDESTROY:
        if (self && self->_hwndList)
        {
            self->RemoveListItems(self->_hwndList);
        }
        RemoveWindowSubclass(GetParent(hdlg), ParentSubclassProc, 0);
        delete self;
        break;

    case WM_HELP:
        self->OnHelp((LPHELPINFO)lp);
        break;

    case WM_CONTEXTMENU:
        self->OnContextMenu((HWND)wp);
        break;
    }


    return FALSE;
}

//
//  Create a Hardware page for the specified GUID.
//
//  Parameters:
//
//      hwndParent - The dummy frame window created by the caller
//      pguid      - The setup device class GUID we will manage
//
//  Returns:
//
//      HWND of the created subdialog.
//
//  Usage:
//
//      When your control panel applet needs a Hardware page, create
//      a blank dialog template titled "Hardware" and add it to your
//      control panel.  Set the size of the blank to be the size you
//      want the final Hardware Tab page to be.
//
//      Your dialog box procedure should go like this:
//
//      BOOL HardwareDlgProc(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp) {
//          switch (uMsg) {
//
//          case WM_INITDIALOG:
//              // GUID_DEVCLASS_MOUSE is in devguid.h
//              hwndHW = DeviceCreateHardwarePage(hdlg, &GUID_DEVCLASS_MOUSE);
//              if (hwndHW) {
//                  // Optional - Set the troubleshooter command line.
//                  // Do this if you want a Troubleshoot button.
//                  SetWindowText(hwndHW,
//                      TEXT("hh.exe mk:@MSITStore:tshoot.chm::/hdw_drives.htm"));
//              } else {
//                  DestroyWindow(hdlg); // catastrophic failure
//              }
//              return TRUE;
//          }
//          return FALSE;
//      }
//

STDAPI_(HWND) DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode)
{
    if (!hwndParent || !pguid) {
        return NULL;
    }

    HCURSOR hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
    CHWTab *self = new CHWTab(pguid, iNumClass, dwViewMode);

    HWND hwnd;

    if (self) {
        hwnd = CreateDialogParam(THIS_DLL, MAKEINTRESOURCE(IDD_HWTAB),
                            hwndParent, CHWTab::DialogProc, (LPARAM)self);
        if (!hwnd) {
            delete self;
            hwnd = NULL;
        }
    } else {
        hwnd = NULL;
    }

    SetCursor(hcurPrev);
    return hwnd;
}

STDAPI_(HWND) DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid)
{
    return DeviceCreateHardwarePageEx(hwndParent, pguid, 1, HWTAB_SMALLLIST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\printer.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    printer.cpp

Abstract:

    This module implements CPrinter -- class that support printing

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "printer.h"
#include "cdriver.h"
#include "sysinfo.h"

const TCHAR* const g_BlankLine = TEXT("");
//
// CPrinter Class implementation
//

BOOL CPrinter::s_UserAborted = FALSE;
HWND CPrinter::s_hCancelDlg = NULL;


void
CPrintCancelDialog::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);

    if (BN_CLICKED == HIWORD(wParam) && IDCANCEL == LOWORD(wParam)) {
    
        CPrinter::s_UserAborted = TRUE;
    }
}

CPrinter::CPrinter(
    HWND hwndOwner,
    HDC hDC
    )
{
    m_hwndOwner = hwndOwner;
    s_UserAborted = FALSE;
    m_hDC = hDC;
    ASSERT(hDC);
    m_CurLine = 0;
    m_CurPage = 0;
    m_Indent = 0;
    m_Status = 1;
    TEXTMETRIC tm;
    GetTextMetrics(m_hDC, &tm);
    m_yChar = tm.tmHeight + tm.tmExternalLeading;
    m_xChar = tm.tmAveCharWidth;

    //
    // Give a little room for dot matrix printers.
    //
    m_xMargin = GetDeviceCaps(m_hDC, LOGPIXELSX) * 3 / 4;
    DWORD LinesPerPage;

    LinesPerPage = GetDeviceCaps(m_hDC, VERTRES) / m_yChar;
    m_yBottomMargin = LinesPerPage - 3; // Bottom Margin 3 lines from bottom of page.
    m_CancelDlg.DoModaless(hwndOwner, (LPARAM)&m_CancelDlg);
    s_hCancelDlg = m_CancelDlg.m_hDlg;

    //
    // Set the abort proc to allow cancel
    //
    SetAbortProc(m_hDC, AbortPrintProc);
    
    //
    // Four lines for top margin
    //
    m_yTopMargin = 4;
}

int
CPrinter::StartDoc(
    LPCTSTR DocTitle
    )
{
    m_Status = 0;

    if (m_hDC) {

        if (m_hwndOwner) {
        
            ::EnableWindow(m_hwndOwner, FALSE);
        }

        //
        // Initialize DOCINFO
        //
        DOCINFO DocInfo;
        DocInfo.cbSize = sizeof(DocInfo);
        DocInfo.lpszDocName = DocTitle;
        DocInfo.lpszOutput = NULL;
        DocInfo.lpszDatatype = NULL;
        DocInfo.fwType = 0;
        m_CurPage = 1;
        m_CurLine = 0;
        m_Status = ::StartDoc(m_hDC, &DocInfo);
    }

    return m_Status;
}

int
CPrinter::EndDoc()
{
    m_Status = 0;

    if (m_hDC) {

        if (m_hwndOwner) {
        
            ::EnableWindow(m_hwndOwner, TRUE);
        }
        
        if (s_hCancelDlg) {

            DestroyWindow(s_hCancelDlg);
            s_hCancelDlg = NULL;
        }
        
        if (!s_UserAborted) {

            m_Status = ::EndDoc(m_hDC);
        }
    }

    return m_Status;
}

int
CPrinter::AbortDoc()
{
    m_Status = 0;

    if (m_hDC) {

        if (m_hwndOwner) {
        
            ::EnableWindow(m_hwndOwner, TRUE);
        }
        
        if (s_hCancelDlg) {

            DestroyWindow(s_hCancelDlg);
            s_hCancelDlg = NULL;
        }
        
        m_Status = ::AbortDoc(m_hDC);
    }

    return m_Status;
}

int
CPrinter::FlushPage()
{
    return PrintLine(NULL);
}

int
CPrinter::PrintLine(
    LPCTSTR LineText
    )
{
    //
    //  NULL LineText means flush the page
    //
    if ((!LineText && m_CurLine) || (m_CurLine > m_yBottomMargin)) {

        m_CurLine = 0;
        
        if (m_Status) {
        
            m_Status = ::EndPage(m_hDC);
        }
    }
    
    if (LineText) {
        //
        // If this is the first line and we are still in good shape,
        // start a new page
        //
        if (!m_CurLine && m_Status) {

            m_Status = ::StartPage(m_hDC);
            
            if (m_Status) {

                String strPageTitle;
                strPageTitle.Format((LPCTSTR)m_strPageTitle, m_CurPage);
                m_CurLine = m_yTopMargin;
                TextOut(m_hDC, m_xMargin, m_yChar*m_CurLine, (LPTSTR)strPageTitle, strPageTitle.GetLength());
                
                //
                // Have one blank line right after page title
                //
                LineFeed();
                m_CurLine++;
                m_CurPage++;
            }
        }
        
        if (m_Status) {
        
            TextOut(m_hDC, m_xMargin + m_xChar*m_Indent*2, m_yChar*m_CurLine, LineText, lstrlen(LineText));
        }
        
        m_CurLine++;
    }

    return m_Status;
}

inline
void
CPrinter::LineFeed()
{
    PrintLine(g_BlankLine);
}

// the abort procedure
BOOL CALLBACK
AbortPrintProc(
    HDC hDC,
    int nCode
    )
{
    MSG msg;

    UNREFERENCED_PARAMETER(hDC);
    UNREFERENCED_PARAMETER(nCode);

    while (!CPrinter::s_UserAborted && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

        if (!IsDialogMessage(CPrinter::s_hCancelDlg, &msg)) {

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    return !CPrinter::s_UserAborted;
}

//
// This function prints system summary.
// INPUT:
//      Machine -- the machine
// OUTPUT:
//      0 -- failed else succeeded.
//
//
int
CPrinter::PrintSystemSummary(
    void
    )
{
    CSystemInfo SysInfo;
    String strLine;
    String strFormat;
    String strBuffer;
    String strUnknown;
    TCHAR Buffer[MAX_PATH];
    TCHAR szTemp[30];
    DWORD Size, BufferSize;
    BufferSize = ARRAYLEN(Buffer);
    
    //
    // Preload the "Unknown" string which will be used as default when
    // the corresponding value can not found
    //
    strUnknown.LoadString(g_hInstance, IDS_PRINT_UNKNOWN);

    //
    // Print System summary heading
    //
    LoadString(g_hInstance, IDS_PRINT_HEADING_SYSSUMMARY, Buffer, ARRAYLEN(Buffer));
    strFormat.LoadString(g_hInstance, IDS_PRINT_BANNER);
    strLine.Format((LPCTSTR)strFormat, Buffer);
    PrintLine((LPCTSTR)strLine);
    LineFeed();

    //
    // Windows version
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_WINVER);
    Size = SysInfo.WindowsVersion(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);
    
    //
    // Registered Owner
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_OWNER);
    Size = SysInfo.RegisteredOwner(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);
    
    //
    // Registered Organization
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_ORGANIZATION);
    Size = SysInfo.RegisteredOrganization(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);
    
    //
    // Computer name
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_COMPUTERNAME);
    strLine += (LPCTSTR)SysInfo.ComputerName();
    PrintLine((LPCTSTR)strLine);
    
    //
    // Machine Type
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_MACHINE_TYPE);
    Size = SysInfo.MachineType(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);
    
    //
    // System BIOS Version
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_SYSBIOS_VERSION);
    Size = SysInfo.SystemBiosVersion(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);

    //
    // System BIOS Date
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_SYSBIOS_DATE);
    Size = SysInfo.SystemBiosDate(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);
    
    //
    // Processor type
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_PROCESSOR_TYPE);
    Size = SysInfo.ProcessorType(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);

    //
    // Processor vendor
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_PROCESSOR_VENDOR);
    Size = SysInfo.ProcessorVendor(Buffer, BufferSize);
    strLine += Size ? (LPCTSTR)Buffer : strUnknown;
    PrintLine((LPCTSTR)strLine);

    //
    // Number of processors
    //
    strLine.LoadString(g_hInstance, IDS_PRINT_PROCESSORS);
    DWORD NumProcessors = SysInfo.NumberOfProcessors();
    
    if (NumProcessors) {
        strFormat.Format(TEXT("%u"), NumProcessors);
        strLine += strFormat;
    } else {
        strLine += strUnknown;
    }
    PrintLine((LPCTSTR)strLine);
    
    //
    // Total physical memory
    //
    ULARGE_INTEGER MemorySize;
    SysInfo.TotalPhysicalMemory(MemorySize);
    strLine.LoadString(g_hInstance, IDS_PRINT_PHY_MEMORY);
    
    if (MemorySize.QuadPart) {
        strFormat.LoadString(g_hInstance, IDS_PRINT_MEMORY_UNIT);
        MemorySize.QuadPart += 1024*1024 - 1;
        strBuffer.Format((LPCTSTR)strFormat, Int64ShrlMod32(MemorySize.QuadPart, 20));
        strLine += strBuffer;
    
    } else {
        strLine += strUnknown;
    }
    PrintLine((LPCTSTR)strLine);
    LineFeed();
    
    //
    //  Local disk drive information
    //
    // Print Disk info summary heading
    //
    strBuffer.LoadString(g_hInstance, IDS_PRINT_HEADING_DISKINFO);
    strFormat.LoadString(g_hInstance, IDS_PRINT_BANNER);
    strLine.Format((LPCTSTR)strFormat, (LPCTSTR)strBuffer);
    PrintLine((LPCTSTR)strLine);
    LineFeed();

    DISK_INFO DiskInfo;
    DiskInfo.cbSize = sizeof(DiskInfo);
    
    for(int Drive = 0; Drive < 25; Drive++) {

        // information we want to report on the drive:
        // (1). drive letter and type
        // (2). Total space
        // (3). Free space(if available)
        // (4). Cylinders
        // (5). Heads
        // (6). Sectors per track
        // (7). Bytes per sector
        
        Indent();
        
        if(SysInfo.GetDiskInfo(Drive, DiskInfo)) {

            TCHAR DriveLetter;
            DriveLetter = (TCHAR)(Drive + _T('A'));
            strFormat.LoadString(g_hInstance, IDS_PRINT_DRIVE_LETTER);
            strLine.Format((LPCTSTR)strFormat, DriveLetter);
            PrintLine((LPCTSTR)strLine);
            Indent();
            
            //
            // Drive type
            //
            strFormat.LoadString(g_hInstance, IDS_PRINT_DRIVE_TYPE);
            strBuffer.LoadString(g_hInstance, IDS_MEDIA_BASE + (int)DiskInfo.MediaType);
            strLine.Format((LPCTSTR)strFormat, (LPCTSTR)strBuffer);
            PrintLine((LPCTSTR)strLine);
            
            //
            //Total and free space
            //
            strFormat.LoadString(g_hInstance, IDS_PRINT_TOTAL_SPACE);
            strLine.Format((LPCTSTR)strFormat, AddCommas64(DiskInfo.TotalSpace.QuadPart, szTemp, ARRAYLEN(szTemp)));
            PrintLine((LPCTSTR)strLine);

            if (-1 != DiskInfo.FreeSpace.QuadPart) {
                strFormat.LoadString(g_hInstance, IDS_PRINT_FREE_SPACE);
                strLine.Format((LPCTSTR)strFormat, AddCommas64(DiskInfo.FreeSpace.QuadPart, szTemp, ARRAYLEN(szTemp)));
                PrintLine((LPCTSTR)strLine);
            }
            
            //
            // Disk physical dimension
            // skip CD-ROM because the dimension it reports is bogus
            //
            if (DRIVE_CDROM != DiskInfo.DriveType) {

                //
                // Heads
                //
                strFormat.LoadString(g_hInstance, IDS_PRINT_HEADS);
                strLine.Format((LPCTSTR)strFormat, DiskInfo.Heads);
                PrintLine((LPCTSTR)strLine);
                
                //
                // Cylinders
                //
                if (DiskInfo.Cylinders.HighPart) {
                    strFormat.LoadString(g_hInstance, IDS_PRINT_CYLINDERS_XL);
                    strLine.Format((LPCTSTR)strFormat, DiskInfo.Cylinders.HighPart,
                             DiskInfo.Cylinders.LowPart);
                    PrintLine((LPCTSTR)strLine);
                
                } else {
                    strFormat.LoadString(g_hInstance, IDS_PRINT_CYLINDERS);
                    strLine.Format((LPCTSTR)strFormat, DiskInfo.Cylinders.LowPart);
                    PrintLine((LPCTSTR)strLine);
                }
                
                //
                // Sectors per track
                //
                strFormat.LoadString(g_hInstance, IDS_PRINT_TRACKSIZE);
                strLine.Format((LPCTSTR)strFormat, DiskInfo.SectorsPerTrack);
                PrintLine((LPCTSTR)strLine);
                
                //
                // Bytes per sector
                //
                strFormat.LoadString(g_hInstance, IDS_PRINT_SECTORSIZE);
                strLine.Format((LPCTSTR)strFormat, DiskInfo.BytesPerSector);
                PrintLine((LPCTSTR)strLine);
            }

            UnIndent();
            LineFeed();
        }

        UnIndent();
    }

    return 1;
}

int
CPrinter::PrintResourceSummary(
    CMachine& Machine
    )
{
    String strLine;
    String str;
    String strBanner;

    if (Machine.IsLocal()) {
        PrintSystemSummary();
    }

    //
    // print IRQ summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_IRQSUMMARY);
    strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
    strLine.Format((LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine((LPCTSTR)strLine);
    LineFeed();
    CResourceList IrqSummary(&Machine, ResType_IRQ);
    
    if (IrqSummary.GetCount()) {

        CResource* pResRoot;
        IrqSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_IRQSUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    //
    // print DMA summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_DMASUMMARY);
    strLine.Format((LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine((LPCTSTR)strLine);
    LineFeed();
    CResourceList DmaSummary(&Machine, ResType_DMA);
    
    if (DmaSummary.GetCount()) {

        CResource* pResRoot;
        DmaSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_DMASUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    //
    // print MEM summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_MEMSUMMARY);
    strLine.Format((LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine((LPCTSTR)strLine);
    LineFeed();
    CResourceList MemSummary(&Machine, ResType_Mem);
    
    if (MemSummary.GetCount()) {

        CResource* pResRoot;
        MemSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_MEMSUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    //
    // print IO summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_IOSUMMARY);
    strLine.Format((LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine((LPCTSTR)strLine);
    LineFeed();
    CResourceList IoSummary(&Machine, ResType_IO);
    
    if (IoSummary.GetCount()) {

        CResource* pResRoot;
        IoSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_IOSUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    return 1;
}

int
CPrinter::PrintResourceSubtree(
    CResource* pResRoot
    )
{
    while (pResRoot)
    {
        DWORD Status, Problem;
        
        if (pResRoot->m_pDevice->GetStatus(&Status, &Problem) && Problem ||
            pResRoot->m_pDevice->IsDisabled()) {

            TCHAR Temp[MAX_PATH];
            Temp[0] = _T('*');
            StringCchCopy(&Temp[1], (ARRAYLEN(Temp) - 1), pResRoot->GetViewName());
            PrintLine(Temp);
        
        } else {

            PrintLine(pResRoot->GetViewName());
        }

        if (pResRoot->GetChild()) {

            if ((ResType_IO == pResRoot->ResType()) ||
                (ResType_Mem == pResRoot->ResType())) {
            
                Indent();
            }

            PrintResourceSubtree(pResRoot->GetChild());
            
            if ((ResType_IO == pResRoot->ResType()) ||
                (ResType_Mem == pResRoot->ResType())) {
            
                UnIndent();
            }
        }

        pResRoot = pResRoot->GetSibling();
    }

    return 1;
}

int
CPrinter::PrintAllClassAndDevice(
    CMachine* pMachine
    )
{
    if (!pMachine) {
    
        return 0;
    }
    
    String strHeading;
    String strBanner;
    String strLine;

    strHeading.LoadString(g_hInstance, IDS_PRINT_HEADING_SYSDEVINFO);
    strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
    strLine.Format((LPCTSTR)strBanner, (LPCTSTR)strHeading);
    PrintLine((LPCTSTR)strLine);
    LineFeed();

    CClass* pClass;
    PVOID Context;
    
    if (pMachine->GetFirstClass(&pClass, Context)) {

        do {

            PrintClass(pClass, FALSE);

        } while (pMachine->GetNextClass(&pClass, Context));
    }

    return 1;
}

int
CPrinter::PrintClass(
    CClass* pClass,
    BOOL PrintBanner
    )
{
    PVOID Context;
    CDevice* pDevice;

    if (!pClass) {
    
        return 0;
    }

    if (PrintBanner) {

        String strHeading;
        String strBanner;
        String strLine;

        strHeading.LoadString(g_hInstance, IDS_PRINT_HEADING_SYSDEVCLASS);
        strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
        strLine.Format((LPCTSTR)strBanner, (LPCTSTR)strHeading);
        PrintLine((LPCTSTR)strLine);
        LineFeed();
    }
    
    if (pClass && pClass->GetFirstDevice(&pDevice, Context)) {

        do {
            //
            // Do print banner on the device
            //
            PrintDevice(pDevice, FALSE);

        } while (pClass->GetNextDevice(&pDevice, Context));
    }
    
    return 1;
}

int
CPrinter::PrintDevice(
    CDevice* pDevice,
    BOOL PrintBanner
    )
{
    if (!pDevice) {
    
        return 0;
    }
    
    String str;
    String strLine;

    if (PrintBanner) {

        String strBanner;
        str.LoadString(g_hInstance, IDS_PRINT_HEADING_SYSDEVICE);
        strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
        strLine.Format((LPCTSTR)strBanner, (LPCTSTR)str);
        PrintLine((LPCTSTR)strLine);
        LineFeed();
    }
    
    DWORD Status, Problem;
    
    if (pDevice->GetStatus(&Status, &Problem) && Problem ||
        pDevice->IsDisabled()) {

        strLine.LoadString(g_hInstance, IDS_PRINT_DEVICE_DISABLED);
        PrintLine((LPCTSTR)strLine);
    }
    
    str.LoadString(g_hInstance, IDS_PRINT_CLASS);
    strLine.Format((LPCTSTR)str, pDevice->GetClassDisplayName());
    PrintLine((LPCTSTR)strLine);
    str.LoadString(g_hInstance, IDS_PRINT_DEVICE);
    strLine.Format((LPCTSTR)str, pDevice->GetDisplayName());
    PrintLine((LPCTSTR)strLine);
    PrintDeviceResource(pDevice);
    PrintDeviceDriver(pDevice);
    
    return 1;
}

int
CPrinter::PrintAll(
    CMachine& Machine
    )
{
    PrintResourceSummary(Machine);
    PrintAllClassAndDevice(&Machine);
    return 1;
}

//
// This function prints the given device's resource summary
//
int
CPrinter::PrintDeviceResource(
    CDevice* pDevice
    )
{
    if (!pDevice) {
    
        return 0;
    }

    CResourceList IrqSummary(pDevice, ResType_IRQ);
    CResourceList DmaSummary(pDevice, ResType_DMA);
    CResourceList MemSummary(pDevice, ResType_Mem);
    CResourceList IoSummary(pDevice, ResType_IO);

    String str;
    TCHAR Temp[MAX_PATH];

    //
    // If the device has any kind of resources, print it
    //
    if (IrqSummary.GetCount() || DmaSummary.GetCount() ||
        MemSummary.GetCount() || IoSummary.GetCount()) {

        str.LoadString(g_hInstance, IDS_PRINT_RESOURCE);
        PrintLine(str);
        
        //
        // Start printing individual resources
        //
        Indent();
        PVOID Context;
        CResource* pResource;
        DWORDLONG dlBase, dlLen;
        
        if (IrqSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_IRQ_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase);
                PrintLine((LPCTSTR)str);

            } while (IrqSummary.GetNext(&pResource, Context));
        }

        if (DmaSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_DMA_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase);
                PrintLine((LPCTSTR)str);

            } while (DmaSummary.GetNext(&pResource, Context));
        }

        if (MemSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_MEM_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase, (ULONG)(dlBase + dlLen - 1));
                PrintLine((LPCTSTR)str);

            } while (MemSummary.GetNext(&pResource, Context));
        }

        if (IoSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_IO_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase, (ULONG)(dlBase + dlLen -1));
                PrintLine((LPCTSTR)str);

            } while (IoSummary.GetNext(&pResource, Context));
        }

        UnIndent();
    
    } else {
        str.LoadString(g_hInstance, IDS_PRINT_NORES);
        PrintLine(str);
    }

    return 1;
}


//
// This function prints the given device's driver information
// INPUT:
//      pDevice  -- the device
// OUTPUT:
//      >0 if the function succeeded.
//      0 if the function failed.
//
int
CPrinter::PrintDeviceDriver(
    CDevice* pDevice
    )
{
    if (!pDevice) {
    
        return 0;
    }

    String str;
    TCHAR Temp[MAX_PATH];

    CDriver* pDriver;
    pDriver = pDevice->CreateDriver();
    SafePtr<CDriver> DrvPtr;
    
    if (pDriver) {

        DrvPtr.Attach(pDriver);
        str.LoadString(g_hInstance, IDS_PRINT_DRVINFO);
        PrintLine(str);
        PVOID Context;
        CDriverFile* pDrvFile;
        Indent();

        //
        // Build up a list of function and filter drivers for this device.
        //
        pDriver->BuildDriverList();
        
        if (pDriver->GetFirstDriverFile(&pDrvFile, Context)) {

            do {

                PrintLine(pDrvFile->GetFullPathName());
                HANDLE hFile;
                Indent();
                hFile = CreateFile(pDrvFile->GetFullPathName(),
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL |
                                   FILE_ATTRIBUTE_READONLY |
                                   FILE_ATTRIBUTE_SYSTEM |
                                   FILE_ATTRIBUTE_HIDDEN,
                                   NULL
                                   );
                
                if (INVALID_HANDLE_VALUE != hFile) {

                    DWORD FileSize;
                    FileSize = ::GetFileSize(hFile, NULL);
                    CloseHandle(hFile);
                    LoadString(g_hInstance, IDS_PRINT_FILESIZE, Temp, ARRAYLEN(Temp));
                    str.Format(Temp, FileSize);
                    PrintLine(str);
                    // print the driver version infomation
                    TCHAR Unknown[MAX_PATH];
                    LoadString(g_hInstance, IDS_PRINT_UNKNOWN, Unknown, ARRAYLEN(Unknown));
                    
                    if (pDrvFile->HasVersionInfo()) {

                        LoadString(g_hInstance, IDS_PRINT_FILEVERSION, Temp, ARRAYLEN(Temp));
                        
                        if (pDrvFile->GetVersion()) {

                            str.Format(Temp, pDrvFile->GetVersion());
                        
                        } else {

                            str.Format(Temp, Unknown);
                        }
                        
                        PrintLine(str);

                        LoadString(g_hInstance, IDS_PRINT_FILEMFG, Temp, ARRAYLEN(Temp));
                        
                        if (pDrvFile->GetProvider()) {

                            str.Format(Temp, pDrvFile->GetProvider());
                        
                        } else {

                            str.Format(Temp, Unknown);
                        }
                        
                        PrintLine(str);

                        LoadString(g_hInstance, IDS_PRINT_FILECOPYRIGHT, Temp, ARRAYLEN(Temp));
                        
                        if (pDrvFile->GetCopyright()) {

                            str.Format(Temp, pDrvFile->GetCopyright());
                        
                        } else {

                            str.Format(Temp, Unknown);
                        }
                        
                        PrintLine(str);
                    
                    } else {

                        str.LoadString(g_hInstance, IDS_PRINT_NOVERSION);
                        PrintLine(str);
                    }
                
                } else {

                    str.LoadString(g_hInstance, IDS_PRINT_DRVMISSING);
                    PrintLine(str);
                }
                
                UnIndent();

            } while (pDriver->GetNextDriverFile(&pDrvFile, Context));
        }

        UnIndent();
    }

    LineFeed();
    
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\prndlg.h ===
#ifndef __PRNDLG_H_
#define __PRNDLG_H_

/*++

Copyright (C) Microsoft Corporation

Module Name:

    prndlg.h

Abstract:

    header file for prndlg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// help topic ids
//
#define idh_devmgr_print_system         207325
#define idh_devmgr_print_device         207326
#define idh_devmgr_print_both           207265
#define idh_devmgr_print_report         207324

//
// Report type mask
//
#define REPORT_TYPE_MASK_NONE                           0x00
#define REPORT_TYPE_MASK_SUMMARY                        0x01
#define REPORT_TYPE_MASK_CLASSDEVICE                    0x02
#define REPORT_TYPE_MASK_SUMMARY_CLASSDEVICE            0x04
#define REPORT_TYPE_MASK_ALL                            0x07

typedef enum tagReportType
{
    REPORT_TYPE_SUMMARY = 0,
    REPORT_TYPE_CLASSDEVICE,
    REPORT_TYPE_SUMMARY_CLASSDEVICE,
    REPORT_TYPE_UNKNOWN
} REPORT_TYPE, *PREPORT_TYPE;

class CPrintDialog
{
public:
    CPrintDialog()
        : m_hDlg(NULL), m_ReportType(REPORT_TYPE_UNKNOWN)
        {
            memset(&m_PrintDlg, 0, sizeof(m_PrintDlg));
        }
    ~CPrintDialog()
        {
            if (m_PrintDlg.hDevNames)
                GlobalFree(m_PrintDlg.hDevNames);
            if (m_PrintDlg.hDevMode)
                GlobalFree(m_PrintDlg.hDevMode);
        }
    BOOL PrintDlg(HWND hwndOwner, DWORD TypeEnableMask);

    HDC HDC()
        {
            return m_PrintDlg.hDC;
        }
    REPORT_TYPE ReportType()
        {
            return m_ReportType;
        }
    void SetReportType(REPORT_TYPE ReportType)
        {
            m_ReportType = ReportType;
        }
    DWORD GetTypeEnableMask()
        {
            return m_TypeEnableMask;
        }
    
    HWND    m_hDlg;
    PRINTDLGEX  m_PrintDlg;

private:
    DWORD       m_TypeEnableMask;
    REPORT_TYPE m_ReportType;
};


class CDevMgrPrintDialogCallback : public IPrintDialogCallback
{
public:
    CDevMgrPrintDialogCallback() :m_Ref(0), m_pPrintDialog(NULL)
    {}

    // IUNKNOWN interface
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    
    // IPrintDialogCallback interface
    STDMETHOD(InitDone) (THIS);
    STDMETHOD(SelectionChange) (THIS);
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, 
        LPARAM lParam, LRESULT *pResult);

    CPrintDialog *m_pPrintDialog;

private:
    BOOL OnInitDialog(HWND hWnd);
    UINT_PTR OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
    BOOL OnHelp(LPHELPINFO pHelpInfo);
    BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos, WPARAM wParam);
    
    LONG m_Ref;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\printer.h ===
#ifndef __PRINTER_H_
#define __PRINTER_H_

/*++

Copyright (C) Microsoft Corporation

Module Name:

    printer.h

Abstract:

    header file for printer.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

class CPrintCancelDialog : public CDialog
{
public:
    CPrintCancelDialog() : CDialog(IDD_PRINT_CANCEL)
    {}
    virtual void OnCommand(WPARAM wParam, LPARAM lParam);
};


static BOOL CALLBACK AbortPrintProc(HDC hDC, int Code);

class CPrinter
{
public:
    CPrinter(HWND hwndOwner, HDC hDC);
    CPrinter() : m_hDC(NULL), m_hwndOwner(NULL)
    {}
    ~CPrinter()
    {
        if (m_hDC) {
            DeleteDC(m_hDC);
        }
    }
    int StartDoc(LPCTSTR DocTitle);
    int EndDoc();
    int AbortDoc();
    int PrintLine(LPCTSTR Text);
    int FlushPage();
    void Indent()
    {
        m_Indent++;
    }
    void UnIndent()
    {
        if (m_Indent) {
            m_Indent--;
        }
    }
    void SetPageTitle(int TitleId)
    {
        m_strPageTitle.LoadString(g_hInstance, TitleId);
    }
    void LineFeed();
    int PrintAll(CMachine& Machine);
    int PrintSystemSummary();
    int PrintResourceSummary(CMachine& Machine);
    int PrintAllClassAndDevice(CMachine* pMachine);
    int PrintClass(CClass* pClass, BOOL PrintBanner = TRUE);
    int PrintDevice(CDevice* pDevice, BOOL PrintBanner = TRUE);
    int PrintDeviceDriver(CDevice* pDevice);
    int PrintDeviceResource(CDevice* pDevice);
    int PrintResourceSubtree(CResource* pRes);
    static BOOL s_UserAborted;
    static HWND s_hCancelDlg;

private:
    HDC     m_hDC;
    HWND    m_hwndOwner;
    DWORD   m_xChar;
    DWORD   m_yChar;
    DWORD   m_xMargin;
    DWORD   m_yTopMargin;
    DWORD   m_yBottomMargin;
    DWORD   m_CurLine;
    DWORD   m_CurPage;
    int     m_Indent;
    String  m_strPageTitle;
    int     m_Status;
    CPrintCancelDialog  m_CancelDlg;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\sysinfo.h ===
#ifndef __SYSINFO_H_
#define __SYSINFO_H_

/*++

Copyright (C) Microsoft Corporation

Module Name:

    sysinfo.h

Abstract:

    header file for sysinfo.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/


typedef struct tagDiskInfo
{
    DWORD       cbSize;
    UINT        DriveType;
    STORAGE_MEDIA_TYPE  MediaType;
    ULARGE_INTEGER   TotalSpace;
    ULARGE_INTEGER   FreeSpace;
    LARGE_INTEGER   Cylinders;
    ULONG       Heads;
    ULONG       BytesPerSector;
    ULONG       SectorsPerTrack;
}DISK_INFO, *PDISK_INFO;

class CSystemInfo
{
public:
    CSystemInfo(CMachine* pMachine = NULL);
    ~CSystemInfo();
    BOOL GetDiskInfo(int Drive, DISK_INFO& DiskInfo);
    LPCTSTR ComputerName()
    {
        return m_strComputerName;
    }
    DWORD MachineType(TCHAR* Buffer, DWORD BufferSize);
    DWORD WindowsVersion(TCHAR* Buffer, DWORD BufferSize);
    DWORD SystemBiosDate(TCHAR* Buffer, DWORD BufferSize);
    DWORD SystemBiosVersion(TCHAR* Buffer, DWORD BufferSize);
    DWORD ProcessorType(TCHAR* Buffer, DWORD BufferSize);
    DWORD RegisteredOwner(TCHAR* Buffer, DWORD BufferSize);
    DWORD RegisteredOrganization(TCHAR* Buffer, DWORD BufferSize);
    DWORD ProcessorVendor(TCHAR* Buffer, DWORD BufferSize);
    DWORD NumberOfProcessors();
    DWORD ProcessorInfo(LPCTSTR ValueName, TCHAR* Buffer, DWORD BufferSize);
    void TotalPhysicalMemory(ULARGE_INTEGER& Size);

private:
    DWORD InfoFromRegistry(LPCTSTR SubkeyName, 
                           LPCTSTR ValueName,
                           TCHAR* Buffer, 
                           DWORD BufferSize,
                           HKEY hKeyAncestor = NULL
                           );
    String  m_strComputerName;
    BOOL    m_fLocalMachine;
    HKEY    m_hKeyMachine;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\prndlg.cpp ===
#include "devmgr.h"


/*++

Copyright (C) Microsoft Corporation

Module Name:

    prndlg.cpp

Abstract:

    This module implements CPrintDialog, the class that processes
    printer dialog

Author:

    William Hsieh (williamh) created

Revision History:


--*/


//
// CPrintDialog implementation
//


//
// help topic ids
//

const DWORD g_a207HelpIDs[]=
{
    IDC_PRINT_SYSTEM_SUMMARY,   idh_devmgr_print_system,
    IDC_PRINT_SELECT_CLASSDEVICE,   idh_devmgr_print_device,
    IDC_PRINT_ALL,          idh_devmgr_print_both,
    IDC_PRINT_REPORT_TYPE_TEXT, idh_devmgr_print_report,
    0, 0
};

HRESULT
CDevMgrPrintDialogCallback::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv) {
    
        return E_INVALIDARG;
    }
    
    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)this;
    }
    
    else if (IsEqualIID(riid, IID_IPrintDialogCallback))
    {
        *ppv = (IPrintDialogCallback*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    return hr;
}

ULONG
CDevMgrPrintDialogCallback::AddRef()
{
    return ::InterlockedIncrement(&m_Ref);
}

ULONG
CDevMgrPrintDialogCallback::Release()
{
    ASSERT( 0 != m_Ref );
    ULONG cRef = ::InterlockedDecrement(&m_Ref);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT
CDevMgrPrintDialogCallback::InitDone()
{
    return S_OK;
}

HRESULT
CDevMgrPrintDialogCallback::SelectionChange()
{
    return S_OK;
}

HRESULT
CDevMgrPrintDialogCallback::HandleMessage(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *pResult
    )
{
    *pResult = FALSE;
    
    switch (uMsg) {
    
    case WM_INITDIALOG:
        *pResult = OnInitDialog(hDlg);
        break;

    case WM_COMMAND:
        *pResult = OnCommand(hDlg, wParam, lParam);
        break;

    case WM_HELP:
        *pResult = OnHelp((LPHELPINFO)lParam);
        break;

    case WM_CONTEXTMENU:
        *pResult = OnContextMenu(hDlg, LOWORD(lParam), HIWORD(lParam), wParam);
        break;

    default:
        break;
    }
    
    return S_OK;
}

BOOL
CDevMgrPrintDialogCallback::OnInitDialog(
    HWND hWnd
    )
{
    
    int DefaultId = IDC_PRINT_SELECT_CLASSDEVICE;
    
    m_pPrintDialog->SetReportType(REPORT_TYPE_CLASSDEVICE);

    if (!(m_pPrintDialog->GetTypeEnableMask() & REPORT_TYPE_MASK_CLASSDEVICE))
    {
        EnableWindow(GetDlgItem(hWnd, IDC_PRINT_SELECT_CLASSDEVICE), FALSE);
        DefaultId =  IDC_PRINT_SYSTEM_SUMMARY;
        m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY);
    }
    
    if (!(m_pPrintDialog->GetTypeEnableMask() & REPORT_TYPE_MASK_SUMMARY))
    {
        EnableWindow(GetDlgItem(hWnd, IDC_PRINT_SYSTEM_SUMMARY), FALSE);
        
        if (IDC_PRINT_SYSTEM_SUMMARY == DefaultId)
        {
            DefaultId = IDC_PRINT_ALL;
            m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY_CLASSDEVICE);
        }
    }

    if (!(m_pPrintDialog->GetTypeEnableMask() & REPORT_TYPE_MASK_SUMMARY_CLASSDEVICE))
    {
        EnableWindow(GetDlgItem(hWnd, IDC_PRINT_ALL), FALSE);
    }

    CheckDlgButton(hWnd, DefaultId, BST_CHECKED);
    
    return TRUE;
}

UINT_PTR
CDevMgrPrintDialogCallback::OnCommand(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    if (BST_CHECKED == IsDlgButtonChecked(hWnd, IDC_PRINT_SELECT_CLASSDEVICE))
    {
        m_pPrintDialog->SetReportType(REPORT_TYPE_CLASSDEVICE);
    }

    else if (BST_CHECKED == IsDlgButtonChecked(hWnd, IDC_PRINT_SYSTEM_SUMMARY))
    {
        m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY);
    }
    
    else if (BST_CHECKED == IsDlgButtonChecked(hWnd, IDC_PRINT_ALL))
    {
        m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY_CLASSDEVICE);
    }

    return FALSE;
}

BOOL
CDevMgrPrintDialogCallback::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    int id = GetDlgCtrlID((HWND)pHelpInfo->hItemHandle);

    //
    // We only want to intercept help messages for controls that we are
    // responsible for.
    //
    if ((IDC_PRINT_SYSTEM_SUMMARY == id) ||
        (IDC_PRINT_SELECT_CLASSDEVICE == id) ||
        (IDC_PRINT_ALL == id) ||
        (IDC_PRINT_REPORT_TYPE_TEXT == id)) {

        WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
                (ULONG_PTR)g_a207HelpIDs);

        return TRUE;
    }

    //
    // If it is not one of the above controls then just let the normal help handle
    // the message.  We do this by returning FALSE
    //
    return FALSE;
}

BOOL
CDevMgrPrintDialogCallback::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos,
    WPARAM wParam
    )
{
    POINT pt;

    UNREFERENCED_PARAMETER(xPos);
    UNREFERENCED_PARAMETER(yPos);

    if (hWnd == (HWND)wParam) {
    
        GetCursorPos(&pt);
        ScreenToClient(hWnd, &pt);
        wParam = (WPARAM)ChildWindowFromPoint(hWnd, pt);
    }

    int id = GetDlgCtrlID((HWND)wParam);

    //
    // We only want to intercept help messages for controls that we are
    // responsible for.
    //
    if ((IDC_PRINT_SYSTEM_SUMMARY == id) ||
        (IDC_PRINT_SELECT_CLASSDEVICE == id) ||
        (IDC_PRINT_ALL == id) ||
        (IDC_PRINT_REPORT_TYPE_TEXT == id)) {
    
        WinHelp((HWND)wParam, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
                (ULONG_PTR)g_a207HelpIDs);

        return TRUE;
    }

    return FALSE;
}

BOOL
CPrintDialog::PrintDlg(
    HWND hwndOwner,
    DWORD TypeEnableMask
    )
{
    ASSERT(REPORT_TYPE_MASK_NONE != TypeEnableMask);

    memset(&m_PrintDlg, 0, sizeof(m_PrintDlg));

    CDevMgrPrintDialogCallback* pPrintDialogCallback = new CDevMgrPrintDialogCallback;

    if (!pPrintDialogCallback) {

        return FALSE;
    }

    pPrintDialogCallback->m_pPrintDialog = this;
    
    m_TypeEnableMask = TypeEnableMask;

    m_PrintDlg.lStructSize = sizeof(m_PrintDlg);
    m_PrintDlg.hwndOwner = hwndOwner;
    m_PrintDlg.hDC = NULL;
    m_PrintDlg.Flags = PD_ENABLEPRINTTEMPLATE | PD_RETURNDC | PD_NOPAGENUMS;
    m_PrintDlg.Flags2 = 0;
    m_PrintDlg.ExclusionFlags = 0;
    m_PrintDlg.hInstance = g_hInstance;
    m_PrintDlg.nCopies = 1;
    m_PrintDlg.nStartPage = START_PAGE_GENERAL;
    m_PrintDlg.lpCallback = (IUnknown*)pPrintDialogCallback;
    m_PrintDlg.lpPrintTemplateName = MAKEINTRESOURCE(IDD_PRINT);
    
    if (FAILED(PrintDlgEx(&m_PrintDlg))) {
        
        return FALSE;
    }

    //
    // If the user did not want to print then return FALSE.
    // This can happen if the user hits Cancel on the print dialog.
    //
    if (m_PrintDlg.dwResultAction != PD_RESULT_PRINT) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\proppage.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    proppage.cpp

Abstract:

    This module implements CPropSheetPage class, the base class of
    CDeviceGeneralPage, CClassGeneralPage and CDeviceDriverPage.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "proppage.h"

//
// CPropSheetPage implementation
//


CPropSheetPage::CPropSheetPage(
    HINSTANCE hInst,
    UINT idTemplate
    )
{
    memset(&m_psp, 0, sizeof(m_psp));
    m_psp.dwSize = sizeof(m_psp);
    m_psp.dwFlags = PSP_USECALLBACK;
    m_psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
    m_psp.lParam = 0;
    m_psp.pfnCallback = CPropSheetPage::PageCallback;
    m_psp.pfnDlgProc = PageDlgProc;
    m_psp.hInstance = hInst;
    m_Active = FALSE;
    //
    // By default, we want every derived page to update its contents
    // on each PSN_SETACTIVE so that it has up-to-date information
    // presented since any page in the same property sheet may
    // change the target object and there are not reliable ways
    // to synchronize changes among pages.
    //
    m_AlwaysUpdateOnActive = TRUE;
    // Right after WM_INITDIALOG, we will receive a
    // PSN_SETACTIVE and by setting m_UpdateControlsPending
    // to TRUE, the PSN_SETACTIVE handler will call UpdateControls
    // to refresh the page.
    // derived classes can turn this off if they wish to
    // update the dialog box only once in OnInitDialog.
    // Also, since m_AlwaysUpdateOnActive is TRUE by-default,
    // m_UpdateControlPending is FALSE by-default.
    m_UpdateControlsPending = FALSE;

    m_IDCicon = 0;
}

INT_PTR
CPropSheetPage::PageDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CPropSheetPage* pThis = (CPropSheetPage *) GetWindowLongPtr(hDlg, DWLP_USER);
    LPNMHDR pnmhdr;
    BOOL Result;

    switch (uMsg) {
     
    case WM_INITDIALOG: {
        
        PROPSHEETPAGE* ppsp = (PROPSHEETPAGE *)lParam;
        pThis = (CPropSheetPage *) ppsp->lParam;
        ASSERT(pThis);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
        pThis->m_hDlg = hDlg;
        Result = pThis->OnInitDialog(ppsp);
        break;
    }
    
    case WM_COMMAND:
        if (pThis)
            Result = pThis->OnCommand(wParam, lParam);
        else
            Result = FALSE;
        break;
    
    case WM_NOTIFY: {
        
        pnmhdr = (LPNMHDR)lParam;
        
        switch (pnmhdr->code) {
            
        case PSN_SETACTIVE:
            ASSERT(pThis);
            Result = pThis->OnSetActive();
            break;
        
        case PSN_KILLACTIVE:
            ASSERT(pThis);
            Result = pThis->OnKillActive();
            break;
            
        case PSN_APPLY:
            ASSERT(pThis);
            Result = pThis->OnApply();
            break;

        case PSN_LASTCHANCEAPPLY:
            ASSERT(pThis);
            Result = pThis->OnLastChanceApply();
            break;
            
        case PSN_RESET:
            ASSERT(pThis);
            Result = pThis->OnReset();
            break;
            
        case PSN_WIZFINISH:
            ASSERT(pThis);
            Result = pThis->OnWizFinish();
            break;
            
        case PSN_WIZNEXT:
            ASSERT(pThis);
            Result = pThis->OnWizNext();
            break;
            
        case PSN_WIZBACK:
            ASSERT(pThis);
            Result = pThis->OnWizBack();
            break;
            
        default:
            ASSERT(pThis);
            pThis->OnNotify(pnmhdr);
            Result = FALSE;
            break;
        }
        
        break;
    }
    
    case WM_DESTROY:
        if (pThis)
            Result = pThis->OnDestroy();
        else
            Result = FALSE;
        break;
    
    case PSM_QUERYSIBLINGS:
        ASSERT(pThis);
        Result = pThis->OnQuerySiblings(wParam, lParam);
        break;
    
    case WM_HELP:
        ASSERT(pThis);
        Result = pThis->OnHelp((LPHELPINFO)lParam);
        break;
    
    case WM_CONTEXTMENU:
        ASSERT(pThis);
        Result = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
        break;
    
    default:
        Result = FALSE;
        break;
    }
    
    return Result;
}

UINT
CPropSheetPage::DestroyCallback()
{
    delete this;
    return TRUE;
}

//
// This function is the property page create/desrtroy callback.
// It monitors the PSPSCB_RELEASE to delete this object.
// This is the most reliable way to free objects associated with
// a property page. A property page which is never activated
// will not receive a WM_DESTROY message because its window is not
// created.
//
UINT
CPropSheetPage::PageCallback(
    HWND hDlg,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    UNREFERENCED_PARAMETER(hDlg);

    ASSERT(ppsp);
    CPropSheetPage* pThis = (CPropSheetPage*)ppsp->lParam;
    
    if (PSPCB_CREATE == uMsg && pThis)
    {
        pThis->CreateCallback();
    }
    
    else if (PSPCB_RELEASE == uMsg && pThis)
    {
        return pThis->DestroyCallback();
    }

    return TRUE;
}


BOOL
CPropSheetPage::OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam
    )
{
    ASSERT(m_hDlg);
    DMQUERYSIBLINGCODE Code = (DMQUERYSIBLINGCODE)wParam;
    
    //
    // Properties of the device attached to this page have
    // changed. Try to update the controls if we are currently
    // active. If we are active at this time, signal a flag
    // so that on PSN_SETACTIVE will do the update.
    //
    switch (Code) {
    
    case QSC_PROPERTY_CHANGED:
        if (m_Active)
        {
            UpdateControls(lParam);
            m_UpdateControlsPending = FALSE;
        }
        
        else
        {
            // wait for SetActive to update the controls
            m_UpdateControlsPending = TRUE;
        }
        break;
    }
    
    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
    return FALSE;
}


BOOL
CPropSheetPage::OnDestroy()
{
    HICON hIcon;

    if (m_IDCicon)
    {
        hIcon = (HICON)SendDlgItemMessage(m_hDlg, m_IDCicon, STM_GETICON, 0, 0);

        if (hIcon) {
            DestroyIcon(hIcon);
        }
        m_IDCicon = 0;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\tsmain.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    tsmain.cpp

Abstract:

    This module implements Device Manager troubleshooting supporting classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "proppage.h"
#include "tsmain.h"
#include "tswizard.h"

const TCHAR*    REG_PATH_TROUBLESHOOTERS = TEXT("Troubleshooters");
const TCHAR*    REG_VALUE_WIZARD32 = TEXT("Wizard32");

//
// class CWizard implementation
//

BOOL
CWizard::Query(
              CDevice* pDevice,
              ULONG Problem
              )
{
    if (!m_WizardEntry)
        return FALSE;
    TSHOOTER_QUERYPARAM QueryParam;
    TCHAR Description[MAX_PATH];
    m_pDevice = pDevice;
    QueryParam.Header.cbSize = sizeof(QueryParam);
    QueryParam.Header.Command = TSHOOTER_QUERY;
    QueryParam.DeviceId = pDevice->GetDeviceID();
    QueryParam.Problem = Problem;
    QueryParam.DescBuffer = Description;
    QueryParam.DescBufferSize = ARRAYLEN(Description);
    if ((*m_WizardEntry)((PTSHOOTER_PARAMHEADER) &QueryParam)) {
        m_DeviceRank = QueryParam.DeviceRank;
        m_ProblemRank = QueryParam.ProblemRank;
        m_strDescription = Description;
        return TRUE;
    }
    return FALSE;
}
BOOL
CWizard::About(HWND hwndOwner)
{
    if (!m_WizardEntry)
        return FALSE;
    TSHOOTER_ABOUTPARAM AboutParam;
    AboutParam.Header.cbSize = sizeof(AboutParam);
    AboutParam.Header.Command = TSHOOTER_ABOUT;
    AboutParam.hwndOwner = hwndOwner;
    return(*m_WizardEntry)((PTSHOOTER_PARAMHEADER)&AboutParam);
}
BOOL
CWizard::AddPages(
                 LPPROPSHEETHEADER ppsh,
                 DWORD MaxPages
                 )
{
    if (!m_WizardEntry)
        return FALSE;
    if (!m_pDevice) {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    TSHOOTER_ADDPAGESPARAM AddPagesParam;
    AddPagesParam.Header.cbSize = sizeof(AddPagesParam);
    AddPagesParam.Header.Command = TSHOOTER_ADDPAGES;
    AddPagesParam.Problem = m_Problem;
    AddPagesParam.DeviceId = m_pDevice->GetDeviceID();
    AddPagesParam.PropSheetHeader = ppsh;
    AddPagesParam.MaxPages = MaxPages;
    return(*m_WizardEntry)((PTSHOOTER_PARAMHEADER)&AddPagesParam);
}

//
// class CWizardList implementation
//

BOOL
CWizardList::Create(
                   CDevice* pDevice,
                   ULONG   Problem
                   )
{
    CSafeRegistry regDevMgr;
    CSafeRegistry regTShooters;
    DWORD RegType, Size, Type;
    if (regDevMgr.Open(HKEY_LOCAL_MACHINE, REG_PATH_DEVICE_MANAGER) &&
        regTShooters.Open(regDevMgr, REG_PATH_TROUBLESHOOTERS)) {

        if (TWT_ANY == m_Type || TWT_PROBLEM_SPECIFIC == m_Type) {
            // create problem specific wizards list first
            // convert problem number to subkey name
            String strProblemSubkey;
            strProblemSubkey.Format(TEXT("%08X"), Problem);
            // see if there are registered for the problem.
            CSafeRegistry regProblem;
            if (regProblem.Open(regTShooters, (LPTSTR)strProblemSubkey)) {
                Size = 0;
                if (regProblem.GetValue(REG_VALUE_WIZARD32, &Type, NULL, &Size) &&
                    REG_MULTI_SZ == Type && Size) {
                    BufferPtr<BYTE> WizardPtr(Size);
                    regProblem.GetValue(REG_VALUE_WIZARD32, &Type, WizardPtr, &Size);
                    CreateWizardsFromStrings((LPTSTR)(BYTE*)WizardPtr, pDevice, Problem);
                }
            }
        }
        if (TWT_ANY == m_Type || TWT_CLASS_SPECIFIC == m_Type) {
            TCHAR GuidSubkey[MAX_GUID_STRING_LEN];
            GUID ClassGuid;
            pDevice->ClassGuid(ClassGuid);
            ULONG Size;
            if (GuidToString(&ClassGuid, GuidSubkey, ARRAYLEN(GuidSubkey))) {
                CSafeRegistry regGuid;
                if (regGuid.Open(regTShooters, GuidSubkey)) {
                    Size = 0;
                    if (regGuid.GetValue(REG_VALUE_WIZARD32, &Type, NULL, &Size) &&
                        REG_MULTI_SZ == Type && Size) {
                        BufferPtr<BYTE> WizardPtr(Size);
                        regGuid.GetValue(REG_VALUE_WIZARD32, &Type, WizardPtr, &Size);
                        CreateWizardsFromStrings((LPTSTR)(BYTE*)WizardPtr, pDevice, Problem);
                    }
                }
            }
        }
        if (TWT_ANY == m_Type || TWT_GENERAL_PURPOSE == m_Type) {
            if (regTShooters.GetValue(REG_VALUE_WIZARD32, &Type, NULL, &Size) &&
                REG_MULTI_SZ == Type && Size) {
                BufferPtr<BYTE> WizardPtr(Size);
                regTShooters.GetValue(REG_VALUE_WIZARD32, &Type, WizardPtr, &Size);
                CreateWizardsFromStrings((LPTSTR)(BYTE*)WizardPtr, pDevice, Problem);
            }
        }
    }
    if (TWT_ANY == m_Type || TWT_DEVMGR_DEFAULT == m_Type) {
        SafePtr<CDefaultWizard> WizardPtr;
        CDefaultWizard* pWizard = new CDefaultWizard;
        WizardPtr.Attach(pWizard);
        if (pWizard->Query(pDevice, Problem)) {
            m_listWizards.AddTail(pWizard);
            WizardPtr.Detach();
        }
    }
    return !m_listWizards.IsEmpty();
}

CWizardList::~CWizardList()
{
    if (!m_listWizards.IsEmpty()) {
        POSITION pos = m_listWizards.GetHeadPosition();
        while (NULL != pos) {
            delete (CWizard*)m_listWizards.GetNext(pos);
        }
        m_listWizards.RemoveAll();
    }
}


BOOL
CWizardList::CreateWizardsFromStrings(
                                     LPTSTR msz,
                                     CDevice* pDevice,
                                     ULONG   Problem
                                     )
{
    LPTSTR p;
    p = msz;
    SetLastError(ERROR_SUCCESS);
    BOOL Result = TRUE;
    // the format of each string is "dllname, dllentryname"
    while (Result && _T('\0') != *p) {
        HMODULE hDll;
        FARPROC ProcAddress;
        Result =  LoadEnumPropPage32(p, &hDll, &ProcAddress);
        if (Result) {
            SafePtr<CWizard> WizardPtr;
            CWizard* pWizard = new CWizard(hDll, ProcAddress);
            WizardPtr.Attach(pWizard);
            if (pWizard->Query(pDevice, Problem)) {
                m_listWizards.AddTail(pWizard);
                WizardPtr.Detach();
            }
        }
        p += lstrlen(p) + 1;
    }
    return Result;
}

BOOL
CWizardList::GetFirstWizard(
                           CWizard** ppWizard,
                           PVOID*    pContext
                           )
{
    if (!ppWizard || !pContext) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (!m_listWizards.IsEmpty()) {
        POSITION pos = m_listWizards.GetHeadPosition();
        if (NULL != pos) {
            *ppWizard = m_listWizards.GetNext(pos);
            *pContext = (PVOID)pos;
            return TRUE;
        }
    }
    SetLastError(ERROR_NO_MORE_ITEMS);
    *ppWizard = NULL;
    *pContext   = NULL;
    return FALSE;
}

BOOL
CWizardList::GetNextWizard(
                          CWizard** ppWizard,
                          PVOID&    Context
                          )
{
    if (!ppWizard) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    POSITION pos = (POSITION)Context;
    if (NULL != pos) {
        *ppWizard = m_listWizards.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    *ppWizard = NULL;
    Context = NULL;
    SetLastError(ERROR_NO_MORE_ITEMS);
    return FALSE;
}

CWizard98::CWizard98(
                    HWND hwndParent,
                    UINT MaxPages
                    )
{
    m_MaxPages = 0;
    if (MaxPages && MaxPages <= 32) {
        m_MaxPages = MaxPages;
        memset(&m_psh, 0, sizeof(m_psh));
        m_psh.hInstance = g_hInstance;
        m_psh.hwndParent = hwndParent;
        m_psh.phpage = new HPROPSHEETPAGE[MaxPages];
        m_psh.dwSize = sizeof(m_psh);
        m_psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_HEADER |
                        PSH_WATERMARK | PSH_STRETCHWATERMARK;
        m_psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
        m_psh.pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
        PSH_STRETCHWATERMARK;
        m_psh.pszCaption = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
    }

}

BOOL
CWizard98::CreateIntroPage(
                          CDevice* pDevice
                          )
{


    CWizardIntro* pIntroPage = new CWizardIntro;
    HPROPSHEETPAGE hPage = pIntroPage->Create(pDevice);
    if (hPage) {
        m_psh.phpage[m_psh.nPages++] = hPage;
        return TRUE;
    }
    return FALSE;
}

HPROPSHEETPAGE
CWizardIntro::Create(
                    CDevice* pDevice
                    )
{
    if (!m_pDevice) {
        ASSERT(m_pDevice);
        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        m_pSelectedWizard = NULL;
        DWORD Problem, Status;
        if (pDevice->GetStatus(&Status, &Problem) &&
            m_Wizards.Create(pDevice, Problem)) {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    return NULL;
}

BOOL
CWizardIntro::OnInitDialog(
                          LPPROPSHEETPAGE ppsp
                          )
{
    try {
        ASSERT(!m_hFontBold && !m_hFontBigBold);
        HFONT hFont = (HFONT)SendMessage(GetDlgItem(m_hDlg, IDC_WIZINTRO_WELCOME),
                                         WM_GETFONT, 0, 0);
        LOGFONT LogFont;
        GetObject(hFont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        m_hFontBold = CreateFontIndirect(&LogFont);
        int PtsPixels = GetDeviceCaps(GetDC(m_hDlg), LOGPIXELSY);
        int FontSize = (LogFont.lfHeight * 72 / PtsPixels) * 2;
        LogFont.lfHeight = PtsPixels * FontSize / 72;
        m_hFontBigBold = CreateFontIndirect(&LogFont);

        if (m_hFontBigBold && m_hFontBold) {
            SendMessage(GetDlgItem(m_hDlg, IDC_WIZINTRO_WELCOME),
                        WM_SETFONT, (WPARAM)m_hFontBold, (LPARAM)TRUE);
            SendMessage(GetDlgItem(m_hDlg, IDC_WIZINTRO_NAME),
                        WM_SETFONT, (WPARAM)m_hFontBigBold, (LPARAM)TRUE);
        }
        int Count = 0;
        CWizard* pWizard;
        PVOID    Context;
        Count = m_Wizards.NumberOfWizards();
        if (Count > 1) {
            //
            // enumerate all registered wizard32 based troubleshooters
            //
            if (m_Wizards.GetFirstWizard(&pWizard, &Context)) {
                do {
                    int iItem;
                    iItem = SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                               LB_ADDSTRING, Count,
                                               (LPARAM)(LPCTSTR)pWizard->GetDescription()
                                              );
                    if (LB_ERR != iItem) {
                        SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                           LB_SETITEMDATA, iItem, (LPARAM)pWizard);
                        Count++;
                    }
                } while (m_Wizards.GetNextWizard(&pWizard, Context));
            }
        }
        // if we have any troubleshooters listed at all,
        // display the list and change the instruction text
        //
        if (Count > 1) {
            // make the default selection to the first one
            SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                               LB_SETCURSEL, 0, 0);
        } else {
            // we have only one wizard in the list,
            // hide the wizard list box and necessary text and
            // select the only wizard as the selected wizard
            ShowWindow(GetControl(IDC_WIZINTRO_WIZARDS_GROUP), SW_HIDE);
            ShowWindow(GetControl(IDC_WIZINTRO_WIZARDS_TEXT), SW_HIDE);
            ShowWindow(GetControl(IDC_WIZINTRO_WIZARDLIST), SW_HIDE);
            m_Wizards.GetFirstWizard(&m_pSelectedWizard, &Context);
            ASSERT(m_pSelectedWizard);
        }
    } catch (CMemoryException* e) {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    return TRUE;

}

BOOL
CWizardIntro::OnWizNext()
{
    try {
        CWizard* pNewSelectedWizard = NULL;
        // get the current selected wizard from the list box
        // The list box is hidden when there is only one wizard
        // available.
        if (IsWindowVisible(GetControl(IDC_WIZINTRO_WIZARDLIST))) {
            int iItem = SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                           LB_GETCURSEL, 0, 0);
            if (LB_ERR != iItem) {
                pNewSelectedWizard = (CWizard*) SendDlgItemMessage(m_hDlg,
                                                                   IDC_WIZINTRO_WIZARDLIST,
                                                                   LB_GETITEMDATA, iItem, 0);
            }
        }
        if (m_pSelectedWizard != pNewSelectedWizard) {
            if (m_pSelectedWizard) {
                // user has changed the wizard selection
                // remove all the pages added by the previous wizard
                UINT TotalPages = m_pSelectedWizard->m_AddedPages;

                // do not remove page 0 which is our introduction page
                for (UINT PageIndex = 1; TotalPages; TotalPages--, PageIndex++) {
                    // PSM_REMOVEPAGE should also destroy the page, therefore,
                    // we do not call DestroyPropertySheetPage on that page
                    // here.
                    ::SendMessage(GetParent(m_hDlg), PSM_REMOVEPAGE, PageIndex, 0);
                }
            }
            m_pSelectedWizard = NULL;

            // Let the newly selected wizard to create pages
            // We need a local copy of PROPERSHEETHEADER here
            // because we have to add each page to the active property
            // sheet(already displayed).
            CWizard98   theSheet(GetParent(GetParent(m_hDlg)));
            LONG Error;
            if (pNewSelectedWizard->AddPages(&theSheet.m_psh,
                                             theSheet.GetMaxPages()
                                            )) {
                // Remember how many pages the wizard added to the sheet.
                // It is used to removed page when we switch troubleshooters
                pNewSelectedWizard->m_AddedPages = theSheet.m_psh.nPages;

                // Add new pages to the property sheet
                for (UINT i = 0; i < theSheet.m_psh.nPages; i++) {
                    SendMessage(GetParent(m_hDlg), PSM_ADDPAGE, 0,
                                (LPARAM)theSheet.m_psh.phpage[i]);
                }
                m_pSelectedWizard = pNewSelectedWizard;
            } else {
                SetWindowLong(m_hDlg, DWL_MSGRESULT, -1);
            }
        }
    } catch (CMemoryException* e) {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    return CPropSheetPage::OnWizNext();
}

BOOL
CWizardIntro::OnSetActive()
{
    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_NEXT);
    return CPropSheetPage::OnSetActive();
}

BOOL
CWizardIntro::OnCommand(
                       WPARAM wParam,
                       LPARAM lParam
                       )
{
    if (LBN_DBLCLK == HIWORD(wParam) && IDC_WIZINTRO_WIZARDLIST == LOWORD(wParam)) {
        int iItem = SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                       LB_GETCURSEL, 0, 0);
        if (LB_ERR != iItem && m_pSelectedWizard) {

            m_pSelectedWizard->About(m_hDlg);
        }
    }
    return CPropSheetPage::OnCommand(wParam, lParam);
}




INT_PTR
StartTroubleshootingWizard(
                          HWND hwndParent,
                          CDevice* pDevice
                          )
{
    try {
        CWizard98 theSheet(hwndParent);
        if (theSheet.CreateIntroPage(pDevice))
            return theSheet.DoSheet();
    } catch (CMemoryException* e) {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\proppage.h ===
#ifndef _PROPPAGE_H_
#define _PROPPAGE_H_
/*++

Copyright (C) Microsoft Corporation

Module Name:

    proppage.h

Abstract:

    header file for proppage.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/


class CPropSheetPage
{
public:
    CPropSheetPage(HINSTANCE hInst, UINT idTemplate);
    virtual ~CPropSheetPage()
    {}
    static INT_PTR CALLBACK PageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp);
protected:
    HWND    GetControl(int ControlId)
    {
        ASSERT(m_hDlg);
        return GetDlgItem(m_hDlg, ControlId);
    }

    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp)
    {
        UNREFERENCED_PARAMETER(ppsp);
        return TRUE;
    }

    virtual void UpdateControls(LPARAM lParam = 0)
    {
        UNREFERENCED_PARAMETER(lParam);
    }
    virtual BOOL OnApply()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnLastChanceApply()
    {
        ASSERT(m_hDlg);
        return FALSE;
    }
    virtual BOOL OnWizFinish()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnWizNext()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, -1L);
        return FALSE;
    }
    virtual BOOL OnWizBack()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, -1L);
        return FALSE;
    }
    virtual BOOL OnSetActive()
    {
        ASSERT(m_hDlg);
        m_Active = TRUE;
        if (m_AlwaysUpdateOnActive || m_UpdateControlsPending)
        {
            UpdateControls();
            m_UpdateControlsPending = FALSE;
        }
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnKillActive()
    {
        ASSERT(m_hDlg);
        m_Active = FALSE;
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnReset()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam)
    {
        UNREFERENCED_PARAMETER(wParam);
        UNREFERENCED_PARAMETER(lParam);
        return FALSE;
    }
    virtual BOOL OnQuerySiblings(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(LPNMHDR pnmhdr)
    {
        UNREFERENCED_PARAMETER(pnmhdr);
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnDestroy();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo)
    {
        UNREFERENCED_PARAMETER(pHelpInfo);
        return FALSE;
    }

    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos)
    {
        UNREFERENCED_PARAMETER(hWnd);
        UNREFERENCED_PARAMETER(xPos);
        UNREFERENCED_PARAMETER(yPos);
        return FALSE;
    }

    virtual UINT CreateCallback()
    {
        return TRUE;
    }
    virtual UINT DestroyCallback();

    HPROPSHEETPAGE CreatePage()
    {
        return ::CreatePropertySheetPage(&m_psp);
    }

    HWND        m_hDlg;
    PROPSHEETPAGE   m_psp;
    BOOL        m_Active;
    BOOL        m_AlwaysUpdateOnActive;
    BOOL        m_UpdateControlsPending;
    int             m_IDCicon;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devmgr.rc
//


#include <dlgs.h>

#define IDC_STATIC                     -1


#define IDS_NAME_DEVMGR                 4
#define IDS_DESC_DEVMGR                 5
#define IDS_NAME_CLASS                  6
#define IDS_NAME_DEVICE                 8
#define IDS_NAME_COMPUTER               10
#define IDS_INVALID_COMPUTER_NAME       12
#define IDS_NAME_RESOURCES              13
#define IDS_NAME_IRQ                    15
#define IDS_NAME_IO                     17
#define IDS_NAME_DMA                    19
#define IDS_NAME_MEMORY                 21
#define IDS_NO_DEVICEID                 29
#define IDS_UNKNOWN_DEVICE              38
#define IDI_SIGNED                      40
#define IDI_BLANK                       41
#define IDI_DRIVERBLOCK                 42
#define IDI_CERT                        43
#define IDD_GENERAL_PAGE                102
#define IDS_REMOVE                      103
#define IDM_REMOVE                      103
#define IDD_DEVGEN_PAGE                 103
#define IDS_REFRESH                     104
#define IDM_REFRESH                     104
#define IDD_DEVDRV_PAGE                 106
#define IDS_PROPERTIES                  107
#define IDM_PROPERTIES                  107
#define IDD_FIRST_PAGE                  107
#define IDD_CLSGEN_PAGE                 108
#define IDD_DEVMGR                      109
#define IDD_DRIVERFILES                 110
#define IDS_ENABLE                      111
#define IDM_ENABLE                      111
#define IDS_DISABLE                     112
#define IDM_DISABLE                     112
#define IDS_UPDATEDRIVER                113
#define IDM_UPDATEDRIVER                113
#define IDC_REMOVEDEV_ICON              115
#define IDC_REMOVEDEV_DEVDESC           116
#define IDC_REMOVEDEV_WARNING           117
#define IDM_VIEW_DEVICESBYTYPE          158
#define IDM_VIEW_DEVICESBYCONNECTION    159
#define IDM_VIEW_RESOURCESBYTYPE        160
#define IDM_VIEW_RESOURCESBYCONNECTION  161
#define IDM_VIEW_RESOURCES              162
#define IDM_VIEW_RESOURCE_IRQ           163
#define IDM_VIEW_RESOURCE_DMA           164
#define IDM_VIEW_RESOURCE_IO            165
#define IDM_VIEW_RESOURCE_MEM           166
#define IDM_SHOW_ALL                    176
#define IDI_DEVMGR                      201
#define IDC_GENERAL_LOCALMACHINE        201
#define IDI_RESOURCES                   202
#define IDC_GENERAL_OTHERMACHINE        202
#define IDC_GENERAL_MACHINENAME         203
#define IDC_GENERAL_BROWSE_MACHINENAMES 205
#define IDD_PRINT                       207
#define IDC_GENERAL_OVERRIDE_MACHINENAME 208
#define IDD_REMOVE_DEVICE               210
#define IDB_WATERMARK                   214
#define IDB_BANNER                      215
#define IDC_DEVGEN_ICON                 218
#define IDC_DEVGEN_DESC                 219
#define IDC_DEVGEN_TYPE                 220
#define IDC_DEVGEN_MFG                  221
#define IDC_DEVGEN_STATUS               223
#define IDC_DEVGEN_DISABLE              224
#define IDC_DEVGEN_PROFILELIST          225
#define IDC_DEVDRV_ICON                 226
#define IDC_DEVDRV_DESC                 227
#define IDC_DRIVERFILES_FILELIST        228
#define IDC_DRIVERFILES_PROVIDER        229
#define IDC_DRIVERFILES_VERSION         230
#define IDC_DRIVERFILES_COPYRIGHT       231
#define IDC_DRIVERFILES_DIGITALSIGNER   232
#define IDC_CLSGEN_ICON                 243
#define IDC_CLSGEN_NAME                 244
#define IDC_CLSGEN_DESC                 245
#define IDC_DEVGEN_USAGETEXT            246
#define IDS_DRIVERFILES_BLOCKDRIVERLINK 247
#define IDC_PRINT_ALL                   265
#define IDC_DRIVERFILES_ICON            303
#define IDC_DRIVERFILES_DESC            304
#define IDC_DRIVERFILES_FILES           305
#define IDC_DRIVERFILES_TITLE_PROVIDER  306
#define IDC_DRIVERFILES_TITLE_VERSION   307
#define IDC_DRIVERFILES_TITLE_COPYRIGHT 308
#define IDC_DEVGEN_TROUBLESHOOTING      309
#define IDC_DRIVERFILES_TITLE_DIGITALSIGNER 310
#define IDC_PRINT_REPORT_TYPE_TEXT      324
#define IDC_PRINT_SYSTEM_SUMMARY        325
#define IDC_PRINT_SELECT_CLASSDEVICE    326
#define IDD_PRINT_CANCEL                327
#define IDD_SCAN_PNP_HARDWARES          328
#define IDD_DEVPOWER_PAGE               330
#define IDC_DEVPOWER_ICON               331
#define IDC_DEVPOWER_DESC               332
#define IDC_DEVPOWER_WAKEENABLE         333
#define IDC_DEVPOWER_CON_EDIT           334
#define IDC_DEVPOWER_CON_SPIN           335
#define IDC_DEVPOWER_PER_EDIT           336
#define IDC_DEVPOWER_PER_SPIN           337
#define IDC_DEVPOWER_DEVICEENABLE       338
#define IDC_DEVPOWER_CON_TEXT           339
#define IDC_DEVPOWER_PER_TEXT           340
#define IDC_DEVPOWER_IDLE_TEXT          341
#define IDC_DEVPOWER_IDLE_GROUP         342
#define IDC_DEVPOWER_MESSAGE            343
#define IDB_SYSDM16                     347
#define IDB_SYSDM32                     348
#define IDC_DEVGEN_TITLE_TYPE           349
#define IDC_DEVGEN_TITLE_MFG            350
#define IDC_DEVGEN_STATUSGROUP          352
#define IDC_GENERAL_SELECT_TEXT         353
#define IDC_GENERAL_SELECTGROUP         354
#define IDC_DEVGEN_TITLE_LOCATION       356
#define IDC_DEVGEN_LOCATION             357
#define IDB_TOOLBAR                     358
#define IDS_BUTTON_REFRESH              359
#define IDS_TOOLTIP_REFRESH             360
#define IDS_BUTTON_ENABLE               361
#define IDS_TOOLTIP_ENABLE              362
#define IDS_BUTTON_DISABLE              363
#define IDS_TOOLTIP_DISABLE             364
#define IDS_BUTTON_REMOVE               365
#define IDS_TOOLTIP_REMOVE              366
#define IDS_BUTTON_UPDATEDRIVER         367
#define IDS_TOOLTIP_UPDATEDRIVER        368
#define IDS_HTMLHELP_NAME               370
#define IDS_HTMLHELP_OVERVIEW_TOPIC     371
#define IDD_DEVDETAILS_PAGE             372
#define IDC_DEVDETAILS_ICON             373
#define IDC_DEVDETAILS_DESC             374
#define IDC_DEVDETAILS_COMBO            375
#define IDC_DEVDETAILS_LIST             376
#define IDC_DEVDETAILS_COPY             377
#define IDC_DEVDRV_CHANGEDRIVER         380
#define IDC_DEVDRV_CHANGEDRIVER_TEXT    381
#define IDC_DEVDRV_UNINSTALL            382
#define IDC_DEVDRV_UNINSTALL_TEXT       383
#define IDC_DEVDRV_TITLE_DRIVERPROVIDER 384
#define IDC_DEVDRV_DRIVERPROVIDER       385
#define IDC_DEVDRV_TITLE_DRIVERDATE     386
#define IDC_DEVDRV_DRIVERDATE           387
#define IDC_DEVDRV_TITLE_DRIVERVERSION  388
#define IDC_DEVDRV_DRIVERVERSION        389
#define IDC_DEVDRV_DETAILS              390
#define IDC_DEVDRV_DETAILS_TEXT         391
#define IDC_DEVDRV_TITLE_DRIVERSIGNER   392
#define IDC_DEVDRV_DRIVERSIGNER         393
#define IDC_DEVDRV_ROLLBACK             394
#define IDC_DEVDRV_ROLLBACK_TEXT        395
#define IDC_DEVPOWER_MGMT_WAKEENABLE    396

#define IDS_DN_ROOT_ENUMERATED          400
#define IDS_DN_DRIVER_LOADED            401
#define IDS_DN_ENUM_LOADED              402
#define IDS_DN_STARTED                  403
#define IDS_DN_MANUAL                   404
#define IDS_DN_NEED_TO_ENUM             405
#define IDS_DN_DRIVER_BLOCKED           406
#define IDS_DN_HARDWARE_ENUM            407
#define IDS_DN_NEED_RESTART             408
#define IDS_DN_HAS_MARK                 409
#define IDS_DN_HAS_PROBLEM              410
#define IDS_DN_FILTERED                 411
#define IDS_DN_MOVED                    412
#define IDS_DN_DISABLEABLE              413
#define IDS_DN_REMOVABLE                414
#define IDS_DN_PRIVATE_PROBLEM          415
#define IDS_DN_MF_PARENT                416
#define IDS_DN_MF_CHILD                 417
#define IDS_DN_WILL_BE_REMOVED          418
#define IDS_DN_NOT_FIRST_TIMEE          419
#define IDS_DN_STOP_FREE_RES            420
#define IDS_DN_REBAL_CANDIDATE          421
#define IDS_DN_BAD_PARTIAL              422
#define IDS_DN_NT_ENUMERATOR            423
#define IDS_DN_NT_DRIVER                424
#define IDS_DN_NEEDS_LOCKING            425
#define IDS_DN_ARM_WAKEUP               426
#define IDS_DN_APM_ENUMERATOR           427
#define IDS_DN_APM_DRIVER               428
#define IDS_DN_SILTEN_INSTALL           429
#define IDS_DN_NO_SHOW_IN_DM            430
#define IDS_DN_BOOT_LOG_PROB            431

#define IDS_CM_DEVCAP_LOCKSUPPORTED     440
#define IDS_CM_DEVCAP_EJECTSUPPORTED    441
#define IDS_CM_DEVCAP_REMOVALBE         442
#define IDS_CM_DEVCAP_DOCKDEVICE        443
#define IDS_CM_DEVCAP_UNIQUEID          444
#define IDS_CM_DEVCAP_SILENTINSTALL     445
#define IDS_CM_DEVCAP_RAWDEVICEOK       446
#define IDS_CM_DEVCAP_SURPRISEREMOVEALOK 447
#define IDS_CM_DEVCAP_HARDWAREDISABLED  448
#define IDS_CM_DEVCAP_NONDYNAMIC        449

#define IDS_CONFIGFLAG_DISABLED         460
#define IDS_CONFIGFLAG_REMOVED          461
#define IDS_CONFIGFLAG_MANUAL_INSTALL   462
#define IDS_CONFIGFLAG_IGNORE_BOOT_LC   463
#define IDS_CONFIGFLAG_NET_BOOT         464
#define IDS_CONFIGFLAG_REINSTALL        465
#define IDS_CONFIGFLAG_FAILEDINSTALL    466
#define IDS_CONFIGFLAG_CANTSTOPACHILD   467
#define IDS_CONFIGFLAG_OKREMOVEROM      468
#define IDS_CONFIGFLAG_NOREMOVEEXIT     469
#define IDS_CONFIGFLAG_FINISH_INSTALL   470
#define IDS_CONFIGFLAG_NEEDS_FORCED_CONFIG 471
#define IDS_CONFIGFLAG_NETBOOT_CARD     472
#define IDS_CONFIGFLAG_PARTIAL_LOG_CONF 473
    
#define IDS_CSCONFIGFLAG_DISABLED       474
#define IDS_CSCONFIGFLAG_DO_NOT_CREATE  475
#define IDS_CSCONFIGFLAG_DO_NOT_START   476

#define IDS_POWERSTATE_UNSPECIFIED      480
#define IDS_POWERSTATE_D0               481
#define IDS_POWERSTATE_D1               482
#define IDS_POWERSTATE_D2               483
#define IDS_POWERSTATE_D3               484

#define IDS_PDCAP_D0_SUPPORTED           490
#define IDS_PDCAP_D1_SUPPORTED           491
#define IDS_PDCAP_D2_SUPPORTED           492
#define IDS_PDCAP_D3_SUPPORTED           493
#define IDS_PDCAP_WAKE_FROM_D0_SUPPORTED 494
#define IDS_PDCAP_WAKE_FROM_D1_SUPPORTED 495
#define IDS_PDCAP_WAKE_FROM_D2_SUPPORTED 496
#define IDS_PDCAP_WAKE_FROM_D3_SUPPORTED 497
#define IDS_PDCAP_WARM_EJECT_SUPPORTED   498
        
#define IDS_DETAILS_DEVICEINSTANCEID    500
#define IDS_DETAILS_HARDWAREIDS         501
#define IDS_DETAILS_COMPATIDS           502
#define IDS_DETAILS_MATCHINGID          503
#define IDS_DETAILS_SERVICE             504
#define IDS_DETAILS_ENUMERATOR          505
#define IDS_DETAILS_CAPABILITIES        506
#define IDS_DETAILS_DEVNODE_FLAGS       507
#define IDS_DETAILS_CONFIGFLAGS         508
#define IDS_DETAILS_CSCONFIGFLAGS       509
#define IDS_DETAILS_EJECTIONRELATIONS   510
#define IDS_DETAILS_REMOVALRELATIONS    511
#define IDS_DETAILS_BUSRELATIONS        512
#define IDS_DETAILS_DEVICEUPPERFILTERS  513
#define IDS_DETAILS_DEVICELOWERFILTERS  514
#define IDS_DETAILS_CLASSUPPERFILTERS   515
#define IDS_DETAILS_CLASSLOWERFILTERS   516
#define IDS_DETAILS_CLASSINSTALLER      517
#define IDS_DETAILS_CLASSCOINSTALLERS   518
#define IDS_DETAILS_DEVICECOINSTALLERS  519
#define IDS_DETAILS_FIRMWAREREVISION    520
#define IDS_DETAILS_CURRENTPOWERSTATE   521
#define IDS_DETAILS_POWERCAPABILITIES   522
#define IDS_DETAILS_POWERSTATEMAPPINGS  523

#define IDS_UNKNOWN                     941
#define IDS_NOT_PRESENT                 945
#define IDS_NOT_AVAILABLE               946
#define IDS_REMOVEDEV_WARN              952
#define IDS_VIEW_DEVICESBYTYPE          959
#define IDS_VIEW_DEVICESBYCONNECTION    960
#define IDS_VIEW_RESOURCESBYTYPE        961
#define IDS_VIEW_RESOURCESBYCONNECTION  962
#define IDS_VIEW_RESOURCE_IRQ           969
#define IDS_VIEW_RESOURCE_DMA           970
#define IDS_VIEW_RESOURCE_IO            971
#define IDS_VIEW_RESOURCE_MEM           972
#define IDS_EXTENSION_DESC              981
#define IDS_REMOVEDEV_RESTART           982
#define IDS_DEVCHANGE_RESTART           983
#define IDS_POWERCYC1                   984
#define IDS_POWERCYC2                   985
#define IDS_DISPLAYNAME_SCOPE_DEVMGR    986
#define IDS_LOCAL_MACHINE               989
#define IDS_SHOW_ALL                    990
#define IDS_ERROR_NOMEMORY              991
#define IDS_NO_DIGITALSIGNATURE         992
#define IDS_PROB_NOT_CONFIGURED         1000
#define IDS_PROB_DEVLOADERFAILED        1001
#define IDS_PROB_OUT_OF_MEMORY          1002
#define IDS_PROB_WRONG_TYPE             1003
#define IDS_PROB_LACKEDARBITRATOR       1004
#define IDS_PROB_BOOT_CONFIG_CONFLICT   1005
#define IDS_PROB_FAILED_FILTER          1006
#define IDS_PROB_DEVLOADER_NOT_FOUND    1007
#define IDS_PROB_INVALID_DATA           1008
#define IDS_PROB_FAILED_START           1009
#define IDS_PROB_LIAR                   1010
#define IDS_PROB_NORMAL_CONFLICT        1011
#define IDS_PROB_NOT_VERIFIED           1012
#define IDS_PROB_NEEDRESTART            1013
#define IDS_PROB_REENUMERATION          1014
#define IDS_PROB_PARTIALCONFIG          1015
#define IDS_PROB_UNKNOWN_RESOURCE       1016
#define IDS_PROB_REINSTALL              1017
#define IDS_PROB_REGISTRY               1018
#define IDS_PROB_WILL_BE_REMOVED        1019
#define IDS_PROB_DISABLED               1020
#define IDS_DEVICE_NOT_THERE            1021
#define IDS_PROB_MOVED                  1022
#define IDS_PROB_TOO_EARLY              1023
#define IDS_PROB_NO_VALID_LOG_CONF      1024
#define IDS_PROB_FAILEDINSTALL          1025
#define IDS_PROB_HARDWAREDISABLED       1026
#define IDS_PROB_CANT_SHARE_IRQ         1027
#define IDS_PROB_SYSTEMFAILURE          1028
#define IDS_PROB_NOPROBLEM              1030
#define IDS_PROB_UNKNOWN                1031
#define IDS_PROB_UNKNOWN_WITHCODE       1032
#define IDS_PROB_CODE                   1035
#define IDS_SPECIALPROB_NODRIVERS       1037
#define IDS_SPECIALPROB_PRIVATEPROB     1038
#define IDS_SPECIALPROB_SAFEMODE        1039
#define IDS_PROPSHEET_WARNING           1040
#define IDS_GENERAL_PAGE_WARNING        1042
#define IDS_TROUBLESHOOTING_NAME        1044
#define IDS_PROB_DISABLED_SERVICE       1052
#define IDS_PROB_TRANSLATION_FAILED     1053
#define IDS_PROB_NO_SOFTCONFIG          1054
#define IDS_PROB_BIOS_TABLE             1055
#define IDS_PROB_IRQ_TRANSLATION_FAILED 1056
#define IDS_DESCENDANTS_VETO            1061
#define IDS_UNINSTALL_FAILED            1062
#define IDS_PRINT_DOC_TITLE             1063
#define IDS_PRINT_SUMMARY_PAGE_TITLE    1064
#define IDS_PRINT_CLASSDEVICE_PAGE_TITLE 1065
#define IDS_PRINT_SUMMARY_CLASSDEVICE_PAGE_TITLE 1066
#define IDS_PRINT_BANNER                1067
#define IDS_PRINT_HEADING_IRQSUMMARY    1068
#define IDS_PRINT_HEADING_IOSUMMARY     1069
#define IDS_PRINT_HEADING_DMASUMMARY    1070
#define IDS_PRINT_HEADING_MEMSUMMARY    1071
#define IDS_PRINT_HEADING_SYSDEVINFO    1072
#define IDS_PRINT_HEADING_SYSDEVCLASS   1073
#define IDS_PRINT_HEADING_SYSDEVICE     1074
#define IDS_PRINT_DEVICE_DISABLED       1075
#define IDS_PRINT_IRQ_FORMAT            1076
#define IDS_PRINT_DMA_FORMAT            1077
#define IDS_PRINT_MEM_FORMAT            1078
#define IDS_PRINT_IO_FORMAT             1079
#define IDS_PRINT_DRVINFO               1080
#define IDS_PRINT_FILESIZE              1081
#define IDS_PRINT_FILEVERSION           1082
#define IDS_PRINT_FILEMFG               1083
#define IDS_PRINT_FILECOPYRIGHT         1084
#define IDS_PRINT_DRVMISSING            1085
#define IDS_PRINT_NOVERSION             1086
#define IDS_PRINT_RESOURCE              1087
#define IDS_PRINT_NORES                 1088
#define IDS_PRINT_UNKNOWN               1089
#define IDS_PRINT_CLASS                 1090
#define IDS_PRINT_DEVICE                1091
#define IDS_PRINT_IRQSUM                1092
#define IDS_PRINT_DMASUM                1093
#define IDS_PRINT_MEMSUM                1094
#define IDS_PRINT_IOSUM                 1095
#define IDS_CPU_INTEL_386               1098
#define IDS_CPU_INTEL_486               1099
#define IDS_CPU_INTEL_PENTIUM           1100
#define IDS_CPU_ALPHA                   1101
#define IDS_CPU_REVISION_MODEL_STEPPING 1102
#define IDS_CPU_REVISION_STEPPING       1103
#define IDS_CPU_REVISION_ALPHA          1104
#define IDS_PRINT_HEADING_SYSSUMMARY    1105
#define IDS_PRINT_HEADING_DISKINFO      1106
#define IDS_PRINT_WINVER                1107
#define IDS_PRINT_COMPUTERNAME          1108
#define IDS_PRINT_PROCESSOR_TYPE        1109
#define IDS_PRINT_SYSBIOS_DATE          1111
#define IDS_PRINT_SYSBIOS_VERSION       1112
#define IDS_PRINT_MACHINE_TYPE          1113
#define IDS_PRINT_OWNER                 1114
#define IDS_PRINT_ORGANIZATION          1115
#define IDS_PRINT_PROCESSORS            1116
#define IDS_PRINT_PHY_MEMORY            1117
#define IDS_WINDOWS_NT                  1118
#define IDS_BUILD_NUMBER                1119
#define IDS_PRINT_DRIVE_LETTER          1120
#define IDS_PRINT_DRIVE_TYPE            1121
#define IDS_PRINT_TOTAL_SPACE           1122
#define IDS_PRINT_FREE_SPACE            1124
#define IDS_PRINT_CYLINDERS             1126
#define IDS_PRINT_CYLINDERS_XL          1127
#define IDS_PRINT_HEADS                 1128
#define IDS_PRINT_TRACKSIZE             1129
#define IDS_PRINT_SECTORSIZE            1130

// IDS_MEDIA_BASE - IDS_MEDIA_BASE + 200 are reserved for disk media type
//
#define IDS_MEDIA_BASE                  1131
#define IDS_MEDIA_MAX                   1330
//
// start next one with 1331
//
#define IDS_PRINT_PROCESSOR_VENDOR      1331
#define IDS_PRINT_MEMORY_UNIT           1332
#define IDS_INST_ENABLEDEVICE           1333
#define IDS_INST_RESTARTCOMPUTER        1335
#define IDS_INST_REINSTALL              1336
#define IDS_INST_TROUBLESHOOTER         1339
#define IDS_INST_WORKING_TROUBLESHOOTER 1340
#define IDS_FIXIT_ENABLEDEVICE          1342
#define IDS_FIXIT_RESTARTCOMPUTER       1344
#define IDS_FIXIT_REINSTALL             1345
#define IDS_FIXIT_TROUBLESHOOTER        1347
#define IDS_PROGRAM_PROVIDER            1353
#define IDS_PROGRAM_VERSION             1354
#define IDS_PROGRAM_ABOUT               1355
#define IDS_ABOUT_DEVMGR                1356
#define IDS_NOADMIN_WARNING             1357
#define IDS_REMOTE_WARNING1             1358
#define IDS_PROB_FAILED_ADD             1359
#define IDS_STATUS_DEVICES_BYTYPE       1362
#define IDS_STATUS_DEVICES_BYCONN       1363
#define IDS_STATUS_RESOURCES_BYTYPE     1364
#define IDS_STATUS_RESOURCES_BYCONN     1365
#define IDS_REMOTE_WARNING2             1375

#define IDS_MENU_STATUS_DEVBYTYPE       1385
#define IDS_MENU_STATUS_DEVBYCONNECTION 1386
#define IDS_MENU_STATUS_RESBYTYPE       1387
#define IDS_MENU_STATUS_RESBYCONNECTION 1388
#define IDS_MENU_STATUS_HIDDEN_DEVICES  1389
#define IDS_MENU_STATUS_SCAN_CHANGES    1390
#define IDS_MENU_STATUS_PRINT           1391
#define IDS_MENU_STATUS_REMOVE          1392
#define IDS_MENU_STATUS_PROPERTIES      1393
#define IDS_MENU_STATUS_ENABLE          1394
#define IDS_MENU_STATUS_DISABLE         1395
#define IDS_MENU_STATUS_UPDATEDRIVER    1396

#define IDS_WARN_NORMAL_DISABLE         1397
#define IDS_LOCATION                    1400
#define IDS_LOCATION_NOUINUMBER         1402
#define IDS_UI_NUMBER_DESC_FORMAT       1405
#define IDS_DEVDRV_NODRIVERFILE         1407
#define IDS_DEVDRV_NOROLLBACK           1408
#define IDS_DEVDRV_YESROLLBACK          1409
#define IDD_TS_ENABLEDEVICE_INTRO       1500
#define IDD_TS_ENABLEDEVICE_FINISH      1501
#define IDD_TS_RESTARTCOMPUTER_FINISH   1502
#define IDC_RESTART                     1503
#define IDC_CLASSICON                   1504
#define IDC_TS_DRVDESC                  1505
#define IDC_TS_ENABLEDEVICE_FINISH_MSG  1506
#define IDS_TS_ENABLE                   1507
#define IDS_TS_ENABLE_INFO              1508
#define IDS_TS_ENABLE_FINISH            1509
#define IDS_TS_ENABLE_FINISH_INFO       1510
#define IDS_TS_ENABLEDEVICE_SUCCESS     1511
#define IDS_TS_ENABLEDEVICE_FAIL        1512
#define IDS_TS_ENABLEDEVICE_RESTART     1513
#define IDS_TS_ENABLEDEVICE_PROBLEM     1514
#define IDS_TS_RESTART_FINISH           1515
#define IDS_TS_RESTART_FINISH_INFO      1516
#define IDS_NEED_RESTART                1517
#define IDS_WILL_BE_REMOVED             1518
#define IDS_PCI                         1519
#define IDS_ISA                         1520
#define IDS_ENABLE_CURRENT              1521
#define IDS_DISABLE_CURRENT             1522
#define IDS_DISABLE_IN_PROFILE          1523
#define IDS_DISABLE_GLOBAL              1524
#define IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER    1525
#define IDS_WILL_BE_REMOVED_NO_ROLLBACK_DRIVER  1526
#define IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS  1527
#define IDS_DRIVER_BLOCKED                      1528
#define IDS_CHILD_WITH_INVALID_ID               1529
#define IDS_PROB_FAILED_DRIVER_ENTRY            1600
#define IDS_PROB_DRIVER_FAILED_PRIOR_UNLOAD     1601
#define IDS_PROB_DRIVER_FAILED_LOAD             1602
#define IDS_PROB_DRIVER_SERVICE_KEY_INVALID     1603
#define IDS_PROB_LEGACY_SERVICE_NO_DEVICES      1604
#define IDS_PROB_DUPLICATE_DEVICE               1605
#define IDS_PROB_FAILED_POST_START              1606
#define IDS_PROB_HALTED                         1607
#define IDS_PROB_PHANTOM                        1608
#define IDS_PROB_SYSTEM_SHUTDOWN                1609
#define IDS_PROB_HELD_FOR_EJECT                 1610
#define IDS_PROB_DRIVER_BLOCKED                 1611
#define IDS_PROB_REGISTRY_TOO_LARGE             1612
#define IDS_PROB_SETPROPERTIES_FAILED           1613
#define IDS_ANNOTATION_WORKING                  1700
#define IDS_ANNOTATION_PROBLEM                  1701
#define IDS_ANNOTATION_DISABLED                 1702
#define IDS_ANNOTATION_FORCED                   1703


// Hardware tab definitions

#define IDD_HWTAB                       1410

#define IDC_HWTAB_HSIZEFIRST            1411
#define IDC_HWTAB_LVSTATIC              1411
#define IDC_HWTAB_LISTVIEW              1412
#define IDC_HWTAB_VMOVEFIRST            1413
#define IDC_HWTAB_VSIZEFIRST            1413
#define IDC_HWTAB_GROUPBOX              1413

#define IDC_HWTAB_STATUS                1414
#define IDC_HWTAB_VSIZELAST             1414
#define IDC_HWTAB_MFG                   1415
#define IDC_HWTAB_LOC                   1416
#define IDC_HWTAB_HSIZELAST             1416

#define IDC_HWTAB_VDOWNFIRST            1417

#define IDC_HWTAB_TSHOOT                1417
#define IDC_HWTAB_PROP                  1418

#define IDC_HWTAB_VMOVELAST             1418
#define IDC_HWTAB_VDOWNLAST             1418

#define IDS_HWTAB_UNKNOWN   IDS_UNKNOWN
#define IDS_HWTAB_UNAVAIL   IDS_NOT_AVAILABLE
#define IDS_HWTAB_MFG       0x0601
#define IDS_HWTAB_LOC       0x0602
#define IDS_HWTAB_STATUS    0x0603

#define IDS_HWTAB_LV_NAME   0x0604
#define IDS_HWTAB_LV_TYPE   0x0605

// End of hardware tab definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\sysinfo.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    sysinfo.cpp

Abstract:

    This module implements CSystemInfo, the class that returns various
    system information

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"
#include "sysinfo.h"

// disk drive root template name. Used to retreive the disk's media
// information or geometry
const TCHAR* const DRIVE_ROOT = TEXT("\\\\.\\?:");
const int DRIVE_LETTER_IN_DRIVE_ROOT = 4;

// disk drive root directory template name. Used to retreive the disk's
// total and free space
const TCHAR* const DRIVE_ROOT_DIR = TEXT("?:\\");
const int DRIVE_LETTER_IN_DRIVE_ROOT_DIR = 0;

//
// Registry various subkey and value names used to retreive
// system information
//
const TCHAR* const REG_PATH_HARDWARE_SYSTEM = TEXT("HARDWARE\\DESCRIPTION\\System");
const TCHAR* const REG_VALUE_SYSTEMBIOSDATE = TEXT("SystemBiosDate");
const TCHAR* const REG_VALUE_SYSTEMBIOSVERSION = TEXT("SystemBiosVersion");
const TCHAR* const REG_VALUE_MACHINETYPE  = TEXT("Identifier");

const TCHAR* const REG_PATH_WINDOWS_NT = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
const TCHAR* const REG_VALUE_REGISTERED_OWNER = TEXT("RegisteredOwner");
const TCHAR* const REG_VALUE_REGISTERED_ORGANIZATION = TEXT("RegisteredOrganization");
const TCHAR* const REG_VALUE_CURRENTBUILDNUMBER = TEXT("CurrentBuildNumber");
const TCHAR* const REG_VALUE_CURRENTVERSION = TEXT("CurrentVersion");
const TCHAR* const REG_VALUE_CSDVERSION = TEXT("CSDVersion");
const TCHAR* const REG_PATH_CPU = TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor");
const TCHAR* const REG_VALUE_CPU_TYPE = TEXT("Identifier");
const TCHAR* const REG_VALUE_CPU_VENDOR = TEXT("VendorIdentifier");

CSystemInfo::CSystemInfo(
                        CMachine* pMachine
                        )
{
    // assuming the machine is a local machine and initialize
    // the registry root key as well.
    m_hKeyMachine = HKEY_LOCAL_MACHINE;

    if (pMachine) {
        m_fLocalMachine = pMachine->IsLocal();
        m_strComputerName += pMachine->GetMachineDisplayName();
    } else {
        TCHAR LocalName[MAX_PATH + 1];
        DWORD dwSize = ARRAYLEN(LocalName);

        if (!GetComputerName(LocalName, &dwSize)) {

            LocalName[0] = _T('\0');
        }


        // local machine
        m_fLocalMachine = TRUE;
        m_strComputerName = LocalName;
    }

    if (!m_fLocalMachine) {
        // The machine is not local, connect to the registry
        String strFullComputerName;

        strFullComputerName = (LPCTSTR)TEXT("\\\\");
        strFullComputerName += m_strComputerName;
        m_hKeyMachine = NULL;
        RegConnectRegistry((LPCTSTR)strFullComputerName, HKEY_LOCAL_MACHINE, &m_hKeyMachine);
    }
}

CSystemInfo::~CSystemInfo()
{
    if (!m_fLocalMachine && NULL != m_hKeyMachine) {
        RegCloseKey(m_hKeyMachine);

        // disconnect the machine
        WNetCancelConnection2(TEXT("\\server\\ipc$"), 0, TRUE);
    }
}

//
// This function gets the disk information about the given disk drive
// INPUT:
//  Drive -- the drive number. 0 for A, 1 for B and etc.
//  DiskInfo -- the DISK_INFO to be filled with the information about
//          the drive. DiskInfo.cbSize must be initialized before
//          the call.
// OUTPUT:
//  TRUE  -- if succeeded, DiskInfo is filled with information
//  FALSE -- if the drive information can not be retreived.
//       No appropriate error code is returned;
BOOL
CSystemInfo::GetDiskInfo(
                        int  Drive,
                        DISK_INFO& DiskInfo
                        )
{
    // diskinfo only valid on local computer
    if (!m_fLocalMachine) {
        return FALSE;
    }

    TCHAR DriveLetter;
    TCHAR Root[MAX_PATH];
    DriveLetter = (TCHAR)(_T('A') + Drive);
    StringCchCopy(Root, ARRAYLEN(Root), DRIVE_ROOT_DIR);
    Root[DRIVE_LETTER_IN_DRIVE_ROOT_DIR] = DriveLetter;
    UINT DriveType;
    DriveType = GetDriveType(Root);

    //
    // only valid for local drives
    //
    if (DRIVE_UNKNOWN == DriveType || DRIVE_REMOTE == DriveType ||
        DRIVE_NO_ROOT_DIR == DriveType) {
        return FALSE;
    }

    if (DiskInfo.cbSize < sizeof(DISK_INFO)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // form the disk root name from template
    //
    StringCchCopy(Root, ARRAYLEN(Root), DRIVE_ROOT);
    Root[DRIVE_LETTER_IN_DRIVE_ROOT] = DriveLetter;
    HANDLE hDisk;

    // FILE_READ_ATTRIBUTES is used here so that we will not get nasty
    // error or prompt if the disk is a removable drive and there is no
    // media available.
    hDisk = CreateFile(Root,
                       FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (INVALID_HANDLE_VALUE != hDisk) {
        // form the disk root directory name from template
        StringCchCopy(Root, ARRAYLEN(Root), DRIVE_ROOT_DIR);
        Root[DRIVE_LETTER_IN_DRIVE_ROOT_DIR] = DriveLetter;
        BYTE Buffer[512];
        DWORD BytesRequired = 0;

        if (DeviceIoControl(hDisk, IOCTL_STORAGE_GET_MEDIA_TYPES_EX, NULL, 0,
                            Buffer, sizeof(Buffer), &BytesRequired, NULL)) {
            GET_MEDIA_TYPES* pMediaList;
            DEVICE_MEDIA_INFO*  pMediaInfo;
            pMediaList = (GET_MEDIA_TYPES*)Buffer;
            pMediaInfo = pMediaList->MediaInfo;
            DWORD MediaCount = pMediaList->MediaInfoCount;
            ULARGE_INTEGER MaxSpace, NewSpace;
            DEVICE_MEDIA_INFO* pMaxMediaInfo;
            MaxSpace.QuadPart = 0;
            pMaxMediaInfo = NULL;

            for (DWORD i = 0; i < MediaCount; i++, pMediaInfo++) {
                //
                // find the mediainfo which has max space
                // A disk drive may support multiple media types and the
                // one with maximum capacity is what we want to report.
                //
                if (DRIVE_REMOVABLE == DriveType || DRIVE_CDROM == DriveType) {
                    NewSpace.QuadPart =
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector *
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack *
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder *
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart;

                } else {
                    NewSpace.QuadPart =
                    pMediaInfo->DeviceSpecific.DiskInfo.BytesPerSector *
                    pMediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack *
                    pMediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder *
                    pMediaInfo->DeviceSpecific.DiskInfo.Cylinders.QuadPart;
                }

                if (NewSpace.QuadPart > MaxSpace.QuadPart) {
                    MaxSpace.QuadPart = NewSpace.QuadPart;
                    pMaxMediaInfo = pMediaInfo;
                }
            }

            if (pMaxMediaInfo) {
                //
                // a valid media information is found, compose  DISK_INFO
                // from the media information
                //
                DiskInfo.DriveType = DriveType;
                if (DRIVE_REMOVABLE == DriveType || DRIVE_CDROM == DriveType) {
                    DiskInfo.MediaType = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType;
                    DiskInfo.Cylinders = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders;
                    DiskInfo.Heads = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder;
                    DiskInfo.BytesPerSector = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector;
                    DiskInfo.SectorsPerTrack = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack;

                    //
                    // Do not call GetDiskFreeSpaceEx on removable disk
                    // or CD-ROM
                    //
                    DiskInfo.TotalSpace = MaxSpace;
                    DiskInfo.FreeSpace.QuadPart = (ULONGLONG)-1;

                } else {
                    DiskInfo.MediaType = pMaxMediaInfo->DeviceSpecific.DiskInfo.MediaType;
                    DiskInfo.Cylinders = pMaxMediaInfo->DeviceSpecific.DiskInfo.Cylinders;
                    DiskInfo.Heads = pMaxMediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder;
                    DiskInfo.BytesPerSector = pMaxMediaInfo->DeviceSpecific.DiskInfo.BytesPerSector;
                    DiskInfo.SectorsPerTrack = pMaxMediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack;
                    StringCchCopy(Root, ARRAYLEN(Root), DRIVE_ROOT_DIR);
                    Root[DRIVE_LETTER_IN_DRIVE_ROOT_DIR] = DriveLetter;
                    ULARGE_INTEGER FreeSpaceForCaller;

                    if (!GetDiskFreeSpaceEx(Root, &FreeSpaceForCaller, &DiskInfo.TotalSpace, &DiskInfo.FreeSpace)) {
                        DiskInfo.TotalSpace = MaxSpace;

                        // unknown
                        DiskInfo.FreeSpace.QuadPart = (ULONGLONG)-1;
                    }
                }

                CloseHandle(hDisk);
                return TRUE;
            }
        }

        //
        // we wouldn't go here if the drive is not  removable.
        // Basically, this is for floppy drives only.
        //
        if (DRIVE_REMOVABLE == DriveType &&
            DeviceIoControl(hDisk, IOCTL_DISK_GET_MEDIA_TYPES, NULL, 0,
                            Buffer, sizeof(Buffer), &BytesRequired, NULL)) {
            int TotalMediaTypes = BytesRequired / sizeof(DISK_GEOMETRY);
            DISK_GEOMETRY* pGeometry;
            pGeometry = (DISK_GEOMETRY*)Buffer;
            ULARGE_INTEGER MaxSpace;
            ULARGE_INTEGER NewSpace;
            MaxSpace.QuadPart = 0;
            DISK_GEOMETRY* pMaxGeometry = NULL;

            for (int i = 0; i < TotalMediaTypes; i++, pGeometry++) {
                //
                // find the geometry with maximum capacity
                //
                NewSpace.QuadPart = pGeometry->BytesPerSector *
                                    pGeometry->SectorsPerTrack *
                                    pGeometry->TracksPerCylinder *
                                    pGeometry->Cylinders.QuadPart;

                if (NewSpace.QuadPart > MaxSpace.QuadPart) {
                    pMaxGeometry = pGeometry;
                    MaxSpace = NewSpace;
                }
            }

            if (pMaxGeometry) {
                DiskInfo.DriveType = DriveType;
                DiskInfo.MediaType = (STORAGE_MEDIA_TYPE)pMaxGeometry->MediaType;
                DiskInfo.Cylinders = pMaxGeometry->Cylinders;
                DiskInfo.Heads = pMaxGeometry->TracksPerCylinder;
                DiskInfo.BytesPerSector = pMaxGeometry->BytesPerSector;
                DiskInfo.SectorsPerTrack = pMaxGeometry->SectorsPerTrack;
                DiskInfo.TotalSpace = MaxSpace;
                DiskInfo.FreeSpace.QuadPart = (ULONGLONG)-1;
                CloseHandle(hDisk);
                return TRUE;
            }
        }

        CloseHandle(hDisk);
    }

    return FALSE;
}

//
// This functions retreive the Window version information in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::WindowsVersion(
                           TCHAR* Buffer,
                           DWORD  BufferSize
                           )
{
    if (!Buffer && BufferSize) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    String strFinalText;
    TCHAR Temp[LINE_LEN];

    strFinalText.Empty();

    strFinalText.LoadString(g_hInstance, IDS_WINDOWS_NT);

    CSafeRegistry regWindowsNT;
    if (regWindowsNT.Open(m_hKeyMachine, REG_PATH_WINDOWS_NT, KEY_READ)) {
        DWORD Type, Size;
        Size = sizeof(Temp);

        if (regWindowsNT.GetValue(REG_VALUE_CURRENTVERSION, &Type,
                                  (PBYTE)Temp, &Size)) {
            strFinalText += (LPCTSTR)Temp;
        }

        Size = sizeof(Temp);

        if (regWindowsNT.GetValue(REG_VALUE_CSDVERSION, &Type,
                                  (PBYTE)Temp, &Size) && Size) {
            strFinalText += (LPCTSTR)TEXT(" ");
            strFinalText += (LPCTSTR)Temp;
        }

        Size = sizeof(Temp);

        if (regWindowsNT.GetValue(REG_VALUE_CURRENTBUILDNUMBER, &Type,
                                  (PBYTE)Temp, &Size) && Size) {
            String strBuildFormat;
            strBuildFormat.LoadString(g_hInstance, IDS_BUILD_NUMBER);

            String strBuild;
            strBuild.Format((LPCTSTR)strBuildFormat, Temp);

            strFinalText += strBuild;
        }
    }

    if (BufferSize > (DWORD)strFinalText.GetLength()) {
        StringCchCopy(Buffer, BufferSize, (LPCTSTR)strFinalText);
        SetLastError(ERROR_SUCCESS);
    }

    else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return strFinalText.GetLength();
}

//
// This functions retreive a REG_SZ from the registry
// INPUT:
//  SubkeyName -- registry subkey name.
//  ValueName  -- registry value name;
//  Buffer      -- buffer to receive the string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
//  hKeyAncestory -- the key under which Subkeyname should be opened.
//
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::InfoFromRegistry(
                             LPCTSTR SubkeyName,
                             LPCTSTR ValueName,
                             TCHAR* Buffer,
                             DWORD BufferSize,
                             HKEY hKeyAncestor
                             )
{
    // validate parameters
    if (!SubkeyName || !ValueName || _T('\0') == *SubkeyName ||
        _T('\0') == *SubkeyName || (!Buffer && BufferSize)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!hKeyAncestor) {
        hKeyAncestor = m_hKeyMachine;
    }

    CSafeRegistry regSubkey;

    if (regSubkey.Open(hKeyAncestor, SubkeyName, KEY_READ)) {
        TCHAR Temp[MAX_PATH];
        DWORD Type;
        DWORD Size;
        Size = sizeof(Temp);

        if (regSubkey.GetValue(ValueName, &Type, (PBYTE)Temp, &Size) && Size) {
            Size /= sizeof(TCHAR);

            if (BufferSize > Size) {
                StringCchCopy(Buffer, BufferSize, Temp);
            }

            return Size;
        }
    }

    SetLastError(ERROR_SUCCESS);

    return 0;
}

//
// This functions retreive the system BIOS date information in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::SystemBiosDate(
                           TCHAR* Buffer,
                           DWORD BufferSize
                           )
{
    return InfoFromRegistry(REG_PATH_HARDWARE_SYSTEM,
                            REG_VALUE_SYSTEMBIOSDATE,
                            Buffer, BufferSize);
}


//
// This functions retreive the system BIOS version information in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::SystemBiosVersion(
                              TCHAR* Buffer,
                              DWORD BufferSize
                              )
{
    return InfoFromRegistry(REG_PATH_HARDWARE_SYSTEM,
                            REG_VALUE_SYSTEMBIOSVERSION,
                            Buffer, BufferSize);

}

//
// This functions retreive the machine type  in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::MachineType(
                        TCHAR* Buffer,
                        DWORD BufferSize
                        )
{
    return InfoFromRegistry(REG_PATH_HARDWARE_SYSTEM,
                            REG_VALUE_MACHINETYPE,
                            Buffer, BufferSize);
}

//
// This functions retreive the registered owner name
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::RegisteredOwner(
                            TCHAR* Buffer,
                            DWORD  BufferSize
                            )
{
    return InfoFromRegistry(REG_PATH_WINDOWS_NT,
                            REG_VALUE_REGISTERED_OWNER,
                            Buffer,
                            BufferSize
                           );
}

//
// This functions retreive the registered organization name
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::RegisteredOrganization(
                                   TCHAR* Buffer,
                                   DWORD  BufferSize
                                   )
{
    return InfoFromRegistry(REG_PATH_WINDOWS_NT,
                            REG_VALUE_REGISTERED_ORGANIZATION,
                            Buffer,
                            BufferSize
                           );
}

// This function resturns the number of processors on the computer
// INPUT:
//  NONE
// OUTPUT:
//  Number of processor.
//
DWORD
CSystemInfo::NumberOfProcessors()
{
    CSafeRegistry regCPU;
    DWORD CPUs = 0;

    if (regCPU.Open(m_hKeyMachine, REG_PATH_CPU, KEY_READ)) {
        TCHAR SubkeyName[MAX_PATH + 1];
        DWORD SubkeySize = ARRAYLEN(SubkeyName);

        while (regCPU.EnumerateSubkey(CPUs, SubkeyName, &SubkeySize)) {
            SubkeySize = ARRAYLEN(SubkeyName);
            CPUs++;
        }
    }

    return CPUs;
}

// This function returns the processor vendor in text string
// INPUT:
//  Buffer -- buffer to receive the string
//  BufferSize -- size of the buffer in char(bytes in ANSI)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
//  The system assumes that all processor in the machine must
//  have the same type, therefore, this function does not take
//  processor number as a parameter.
DWORD
CSystemInfo::ProcessorVendor(
                            TCHAR* Buffer,
                            DWORD BufferSize
                            )
{
    return ProcessorInfo(REG_VALUE_CPU_VENDOR, Buffer, BufferSize);
}

// This function returns the processor type in text string
// INPUT:
//  Buffer -- buffer to receive the string
//  BufferSize -- size of the buffer in char(bytes in ANSI)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
//  The system assumes that all processor in the machine must
//  have the same type, therefore, this function does not take
//  processor number as a parameter.
DWORD
CSystemInfo::ProcessorType(
                          TCHAR* Buffer,
                          DWORD BufferSize
                          )
{
    return ProcessorInfo(REG_VALUE_CPU_TYPE, Buffer, BufferSize);
}

DWORD
CSystemInfo::ProcessorInfo(
                          LPCTSTR ValueName,
                          TCHAR* Buffer,
                          DWORD  BufferSize
                          )
{
    if (!ValueName || (!Buffer && BufferSize)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    CSafeRegistry regCPU;
    DWORD CPUIndex = 0;
    TCHAR CPUInfo[MAX_PATH];
    DWORD CPUInfoSize = 0;
    DWORD Type;

    if (regCPU.Open(m_hKeyMachine, REG_PATH_CPU, KEY_READ)) {
        TCHAR CPUKey[MAX_PATH + 1];
        DWORD Size;
        Size = ARRAYLEN(CPUKey);

        // loop through all cpus until we find something interesting
        while (CPUInfoSize <= sizeof(TCHAR) &&
               regCPU.EnumerateSubkey(CPUIndex, CPUKey, &Size)) {
            CSafeRegistry regTheCPU;

            if (regTheCPU.Open(regCPU, CPUKey, KEY_READ)) {
                CPUInfoSize = sizeof(CPUInfo);
                regTheCPU.GetValue(ValueName, &Type, (PBYTE)CPUInfo, &CPUInfoSize);
            }

            CPUIndex++;
        }

        // CPUInfoSize != 0 means we find something
        if (CPUInfoSize > sizeof(TCHAR)) {
            CPUInfoSize = CPUInfoSize / sizeof(TCHAR) - 1;
            if (BufferSize > CPUInfoSize) {
                StringCchCopy(Buffer, BufferSize, CPUInfo);
            }

            return CPUInfoSize;
        }
    }

    return 0;
}

//
// This function returns the total physical memeory in KB
// INPUT:
//  NONE
// OUTPUT:
//  Total Memory in KB
//
void
CSystemInfo::TotalPhysicalMemory(
                                ULARGE_INTEGER& Size
                                )
{
    if (m_fLocalMachine) {
        SYSTEM_BASIC_INFORMATION SysBasicInfo;
        NTSTATUS Status;
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          (PVOID)&SysBasicInfo,
                                          sizeof(SysBasicInfo),
                                          NULL);

        if (NT_SUCCESS(Status)) {
            Size.QuadPart = Int32x32To64(SysBasicInfo.PageSize,
                                         SysBasicInfo.NumberOfPhysicalPages
                                        );
        }

        else {
            MEMORYSTATUS MemoryStatus;
            GlobalMemoryStatus(&MemoryStatus);
            Size.LowPart = (ULONG)MemoryStatus.dwTotalPhys;
            Size.HighPart = 0;
        }
    }

    else {
        Size.QuadPart = 0;
        SetLastError(ERROR_SUCCESS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\tsmain.h ===
#ifndef __TSMAIN_H__
#define __TSMAIN_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    tsmain.h

Abstract:

    header file for tsmain.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// Wizard32 command and parameter definitions
//

//
//
// INPUT:
//  pParam  -- troubleshooter parameter. The contents vary depends on
//          the command specified in the block. See below
//          for detail.
//
//
// OUTPUT:
//  TRUE -- if the function succeeded.
//  FALSE -- if the function failed. GetLastError() should be able
//        to retreive the error code


typedef enum tagTShooterCommand
{
    TSHOOTER_QUERY = 0,
    TSHOOTER_ABOUT,
    TSHOOTER_ADDPAGES
}TSHOOTER_COMMAND, *PTSHOOTER_COMMAND;

// parameter header.
typedef struct tagTShooterParamHeader
{
    DWORD cbSize;           // size of the entire structure
    TSHOOTER_COMMAND Command;       // command
}TSHOOTER_PARAMHEADER, *PTSHOOTER_PARAMHEADER;

//
// QUERY command asks the troubleshooter the following questions:
// (1). if the troubleshooter supports the given DeviceId/Problem combination.
// (2). the brief description about the troubleshooter
// (3). the ranking on the DeviceId and the problem.
// If the troubleshooter does not support the device id and problem
// combination, it should resturn FALSE and set the error code
// to ERROR_INVALID_FUNCTION. The DescBuffer and DescBufferSize
// can be ignored. If the provided DescBuffer is too small, it should
// fill DescBufferSize with the required size, set the error code
// to ERROR_INSUFFICIENT_BUFFER and return FALSE.
//
// parameter definition for TSHOOTER_QUERY command
//
// The Header.Command  must be TSHOOTER_QUERY;
// The header.cbSize must be sizeof(TSHOOTER_QUERY_PARAM);
//
// IN DeviceId  -- device instance id
// IN Problem   -- Configuration manager defined problem number
// IN OUT DescBuffer -- buffer to receive the troubleshooter description text
// IN OUT DescBufferSize -- Description buffer size in char(byte for ANSI)
//              Troubleshooter should fill this field with required
//              size on return.
// OUT DeviceRank   -- to receive the device ranking
// OUT ProblemRank -- to receive the problem ranking
//
//
typedef struct tagTShooterQueryParam
{
    TSHOOTER_PARAMHEADER    Header;
    LPCTSTR         DeviceId;
    ULONG           Problem;
    LPTSTR          DescBuffer;
    DWORD           DescBufferSize;
    DWORD           DeviceRank;
    DWORD           ProblemRank;
}TSHOOTER_QUERYPARAM, *PTSHOOTER_QUERYPARAM;

// The TSHOOTER_ABOUT asks the troubleshooter to display its about dialog box.
// The about dialog box should tell user what the troubleshooter is all about.
//
// The about dialog box is supposed to be Modal. If the troubleshooter
// implements a modaless about dialog box, it should disable
// the given hwndOwner after the dialog box is created and reenable
// it after the dialog box is destroyed.
//
// parameter definition for ABOUT troubleshooter command
//
// Header.Command must be TSHOOTER_ABOUT;
// Header.cbSize must be sizeof(TSHOOTER_ABOUT_PARAM);
//
// IN hwndOwner -- the window handle to serve as the owner window
//         of the troubleshooter about dialog box
//
//
typedef struct tagTShooterAboutParam
{
    TSHOOTER_PARAMHEADER    Header;
    HWND            hwndOwner;
}TSHOOTER_ABOUTPARAM, *PTSHOOTER_ABOUTPARAM;

//
// The TSHOOTER_ADDPAGES asks the troubleshooter to add its wizard
// pages to the provided property sheet header.
//
//
// parameter definition for ADDPAGES troubleshooter command
//
// Header.Command must be TSHOOTER_ADDPAGRES;
// Header.cbSize must be sizeof(TSHOOTER_ADDPAGES_PARAM);
//
// IN DeviceId  -- the hardware id of the device
// IN Problem   -- Configuration Manager defined problem number
// IN OUT ppsh  -- property sheet header to which the troubleshooter
//         add its pages
// IN MaxPages  -- total pages alloated for the ppsh.
//         The troubleshooter should not add more than
//         (MaxPages - ppsh.nPages) pages
//

typedef struct tagTShooterAddPagesParam
{
    TSHOOTER_PARAMHEADER    Header;
    LPCTSTR         DeviceId;
    ULONG           Problem;
    LPPROPSHEETHEADER       PropSheetHeader;
    DWORD           MaxPages;
}TSHOOTER_ADDPAGESPARAM, *PTSHOOTER_ADDPAGESPARAM;

// Each Troubleshooting wizard must provide an entry point for Device Manager
// to call:

typedef BOOL (APIENTRY *WIZARDENTRY)(PTSHOOTER_PARAMHEADER pParam);



typedef enum tagTShooterWizadType
{
    TWT_ANY = 0,                // any type of troubleshooter wizard
    TWT_PROBLEM_SPECIFIC,           // problem specific wizards
    TWT_CLASS_SPECIFIC,             // class specific wizards
    TWT_GENERAL_PURPOSE,            // general purpose
    TWT_DEVMGR_DEFAULT              // device manager default
}TSHOOTERWIZARDTYPE, *PTSHOOTERWIZARTYPE;


//
// class that represent a wizard32 troubleshooter
//
class CWizard
{
public:
    CWizard(HMODULE hWizardDll, FARPROC WizardEntry)
    : m_WizardEntry((WIZARDENTRY)WizardEntry),
      m_hWizardDll(hWizardDll),
      m_Problem(0),
      m_DeviceRank(0),
      m_ProblemRank(0),
      m_AddedPages(0),
      m_pDevice(NULL)
    {}
    ~CWizard()
    {
        if (m_hWizardDll)
        FreeLibrary(m_hWizardDll);
    }
    LPCTSTR GetDescription()
    {
        return m_strDescription.IsEmpty() ? NULL : (LPCTSTR)m_strDescription;
    }
    virtual BOOL Query(CDevice* pDevice, ULONG Problem);
    virtual BOOL About(HWND hwndOwner);
    virtual BOOL AddPages(LPPROPSHEETHEADER ppsh, DWORD MaxPages);
    ULONG   DeviceRank()
    {
        return m_DeviceRank;
    }
    ULONG   ProblemRank()
    {
        return m_ProblemRank;
    }
    UINT    m_AddedPages;
protected:
    WIZARDENTRY m_WizardEntry;
    HINSTANCE   m_hWizardDll;
    String  m_strDescription;
    ULONG   m_Problem;
    ULONG   m_DeviceRank;
    ULONG   m_ProblemRank;
    CDevice*    m_pDevice;
};


//
// Class that collects all available troubleshooter
//
class CWizardList
{
public:
    CWizardList(TSHOOTERWIZARDTYPE Type = TWT_ANY) : m_Type(Type)
    {}
    ~CWizardList();
    BOOL Create(CDevice* pDevice, ULONG Problem);
    int NumberOfWizards()
    {
    return m_listWizards.GetCount();
    }
    BOOL GetFirstWizard(CWizard** ppWizard, PVOID* pContext);
    BOOL GetNextWizard(CWizard** ppWizard, PVOID& Context);
private:
    BOOL CreateWizardsFromStrings(LPTSTR msz, CDevice* pDevice, ULONG Problem);
    CList<CWizard*, CWizard*> m_listWizards;
    TSHOOTERWIZARDTYPE      m_Type;
};

//
// class that represents the troubleshooter wizard introduction page
//
class CWizardIntro : public CPropSheetPage
{
public:
    CWizardIntro() : m_pDevice(NULL), m_hFontBold(NULL),
             m_hFontBigBold(NULL),
             m_pSelectedWizard(NULL), m_Problem(0),
             CPropSheetPage(g_hInstance, IDD_WIZINTRO)
    {
    }
    virtual ~CWizardIntro()
    {
        if (m_hFontBold)
        DeleteObject(m_hFontBold);
        if (m_hFontBigBold)
        DeleteObject(m_hFontBigBold);
    }
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnWizNext();
    virtual BOOL OnSetActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    HPROPSHEETPAGE Create(CDevice* pDevice);
private:
    CDevice*    m_pDevice;
    HFONT   m_hFontBold;
    HFONT   m_hFontBigBold;
    CWizardList m_Wizards;
    ULONG   m_Problem;
    CWizard*    m_pSelectedWizard;
};


//
// class that represents the troubleshooter property sheet
//
class CWizard98
{
public:
    CWizard98(HWND hwndParent, UINT MaxPages = 32);

    BOOL CreateIntroPage(CDevice* pDevice);
    UINT GetMaxPages()
    {
        return m_MaxPages;
    }
    INT_PTR DoSheet()
    {
        return ::PropertySheet(&m_psh);
    }
    PROPSHEETHEADER m_psh;
private:
    CDevice* m_pDevice;
    UINT    m_MaxPages;
};



class CTSLauncher
{
public:
    CTSLauncher() : m_hTSL(NULL)
    {}
    ~CTSLauncher()
    {
        Close();
    }
    BOOL Open(LPCTSTR DeviceId, const GUID& ClassGuid, ULONG Problem)
    {
        return FALSE;
    }
    BOOL Close()
    {
        m_hTSL = NULL;
        return TRUE;
    }
    BOOL Go()
    {
        return FALSE;
    }
    BOOL EnumerateStatus(int Index, DWORD& Status)
    {
        return FALSE;
    }
private:
    HANDLE   m_hTSL;
};

#if 0

typedef enum tagFixItCommand
{
    FIXIT_COMMAND_DONOTHING = 0,
    FIXIT_COMMAND_UPGRADEDRIVERS,
    FIXIT_COMMAND_REINSTALL,
    FIXIT_COMMAND_ENABLEDEVICE
    FIXIT_COMMAND_RESTARTCOMPUTER
} FIXIT_COMMAND, *PFIXIT_COMMAND;

class CProblemAgent
{
public:
    CProblemAgent(CDevice* pDevice, ULONG Problem, ULONG Status);
    ~CProblemAgent();
    // retreive the problem description text
    LPCTSTR ProblemText()
    {
        return m_strDescription.IsEmpty() ? NULL : (LPCTSTR)m_strDescription;
    }
    LPCTSTR InstructionText()
    {
        return m_strInstruction.IsEmpty() ? NULL : (LPCTSTR)m_strInstruction;
    }
    // fix the problem
    virtual BOOL FixIt(HWND hwndOwner)
    {
        return TRUE;
    }
protected:
    BOOL UpdateDriver(HWND hwndOwner, m_pDevice);
    BOOL Reinstall(HWND hwndOwner);
    BOOL RestartComputer(HWND hwndOwner);
    BOOL EnableDevice()
    CDevice*    m_pDevice;
    ULONG   m_Problem;
    ULONG   m_Status;
    String  m_strDescription;
    String  m_strInstruction;
    FIXITCOMMAND m_Command;
};

#endif



INT_PTR
StartTroubleshootingWizard(
    HWND hWndParent,
    CDevice* pDevice
    );
#endif // __PROBLEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\tsmisc.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    tsmisc.cpp

Abstract:

    This module implements Device Manager troubleshooting supporting classes

Author:

    Jason Cobb (jasonc) created

Revision History:


--*/

#include "devmgr.h"
#include "proppage.h"
#include "tsmisc.h"
#include "tswizard.h"

HPROPSHEETPAGE
CTSEnableDeviceIntroPage::Create(
    CDevice* pDevice
    )
{
    if (!m_pDevice)
    {
        ASSERT(pDevice);

        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_TS_ENABLE);
        m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_TS_ENABLE_INFO);
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        
        DWORD Problem, Status;
        
        if (pDevice->GetStatus(&Status, &Problem))
        {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    
    return NULL;
}

BOOL
CTSEnableDeviceIntroPage::OnWizNext()
{
    try
    {
        m_pDevice->EnableDisableDevice(m_hDlg, TRUE);
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return CPropSheetPage::OnWizNext();
}

BOOL
CTSEnableDeviceIntroPage::OnSetActive()
{
    SetDlgItemText(m_hDlg, IDC_TS_DRVDESC, m_pDevice->GetDisplayName());

    HICON hIconNew;
    hIconNew = m_pDevice->LoadClassIcon();

    if (hIconNew) {
        HICON hIconOld;
        m_IDCicon = IDC_CLASSICON;      // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLASSICON,
                                             STM_SETICON, (WPARAM)hIconNew,
                                             0);
        if (hIconOld) {
        
            DestroyIcon(hIconOld);
        }
    }

    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_NEXT);
    return CPropSheetPage::OnSetActive();
}


HPROPSHEETPAGE
CTSEnableDeviceFinishPage::Create(
    CDevice* pDevice
    )
{
    if (!m_pDevice)
    {
        ASSERT(pDevice);

        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_TS_ENABLE_FINISH);
        m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_TS_ENABLE_FINISH_INFO);
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        
        DWORD Problem, Status;
        
        if (pDevice->GetStatus(&Status, &Problem))
        {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    
    return NULL;
}

BOOL
CTSEnableDeviceFinishPage::OnWizFinish()
{
    if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_RESTART)) {
        //
        // Restart the computer
        //
        if (pSetupEnablePrivilege(SE_SHUTDOWN_NAME, TRUE)) {
        
            ExitWindowsEx(EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }
    
    return CPropSheetPage::OnWizFinish();
}

BOOL
CTSEnableDeviceFinishPage::OnSetActive()
{
    DWORD RestartFlags = m_pDevice->m_pMachine->DiGetFlags(*m_pDevice);

    SetDlgItemText(m_hDlg, IDC_TS_DRVDESC, m_pDevice->GetDisplayName());

    HICON hIconNew;
    hIconNew = m_pDevice->LoadClassIcon();

    if (hIconNew) {
        HICON hIconOld;
        m_IDCicon = IDC_CLASSICON;      // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLASSICON,
                                             STM_SETICON, (WPARAM)hIconNew,
                                             0);
        if (hIconOld) {
        
            DestroyIcon(hIconOld);
        }
    }

    //
    // We need to restart the machine for the enable to take affect
    //
    if (RestartFlags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {

        String strAltText_1;
        strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_RESTART);
        SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);

        ::SendMessage(GetControl(IDC_RESTART), BM_SETCHECK, BST_CHECKED, 0);

    //
    // We don't need to restart
    //
    } else {

        DWORD Problem, Status;
        
        Problem = Status = 0;

        m_pDevice->GetStatus(&Status, &Problem);

        //
        // The device is still disabled
        //
        if (CM_PROB_DISABLED == Problem) {

            String strAltText_1;
            strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_FAIL);
            SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);

        //
        // The device has some other problem
        //
        } else if (Problem) {

            String strAltText_1;
            strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_PROBLEM);
            SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);
            
        //
        // The device is now working
        //
        } else {

            String strAltText_1;
            strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_SUCCESS);
            SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);
        }

        ::ShowWindow(GetControl(IDC_RESTART), SW_HIDE);
    }

    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_FINISH);
    ::EnableWindow(GetDlgItem(GetParent(m_hDlg), IDCANCEL), FALSE);
    return CPropSheetPage::OnSetActive();
}


HPROPSHEETPAGE
CTSRestartComputerFinishPage::Create(
    CDevice* pDevice
    )
{
    if (!m_pDevice)
    {
        ASSERT(pDevice);

        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_TS_RESTART_FINISH);
        m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_TS_RESTART_FINISH_INFO);
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        
        DWORD Problem, Status;
        
        if (pDevice->GetStatus(&Status, &Problem))
        {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    
    return NULL;
}

BOOL
CTSRestartComputerFinishPage::OnWizFinish()
{
    if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_RESTART)) {
        //
        // Restart the computer
        //
        if (pSetupEnablePrivilege(SE_SHUTDOWN_NAME, TRUE)) {
        
            ExitWindowsEx(EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }
    
    return CPropSheetPage::OnWizFinish();
}

BOOL
CTSRestartComputerFinishPage::OnSetActive()
{
    SetDlgItemText(m_hDlg, IDC_TS_DRVDESC, m_pDevice->GetDisplayName());

    HICON hIconNew;
    hIconNew = m_pDevice->LoadClassIcon();

    if (hIconNew) {
        HICON hIconOld;
        m_IDCicon = IDC_CLASSICON;      // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLASSICON,
                                             STM_SETICON, (WPARAM)hIconNew,
                                             0);
        if (hIconOld) {
        
            DestroyIcon(hIconOld);
        }
    }

    ::SendMessage(GetControl(IDC_RESTART), BM_SETCHECK, BST_CHECKED, 0);

    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_FINISH);
    return CPropSheetPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\tswizard.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    tsmain.cpp

Abstract:

    This module implements Device Manager troubleshooting supporting classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/
//


#include "devmgr.h"
#include "proppage.h"
#include "devdrvpg.h"
#include "tsmisc.h"
#include "tswizard.h"
#include "cdriver.h"

const CMPROBLEM_INFO ProblemInfo[DEVMGR_NUM_CM_PROB] =
{
    // no problem
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_WORKING_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NOT_CONFIGURED
    {
        TRUE,
        FIX_COMMAND_REINSTALL,
        IDS_INST_REINSTALL,
        1,
        IDS_FIXIT_REINSTALL
    },
    // CM_PROB_DEVLOADER_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_OUT_OF_MEMORY
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_IS_WRONG_TYPE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_LACKED_ARBITRATOR
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_BOOT_CONFIG_CONFLICT
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_FILTER (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DEVLOADER_NOT_FOUND (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_INVALID_DATA
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_START
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_LIAR (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NORMAL_CONFLICT
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NOT_VERIFIED (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NEED_RESTART
    {
        TRUE,
        FIX_COMMAND_RESTARTCOMPUTER,
        IDS_INST_RESTARTCOMPUTER,
        1,
        IDS_FIXIT_RESTARTCOMPUTER
    },
    // CM_PROB_REENUMERATION
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_PARTIAL_LOG_CONF
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_UNKNOWN_RESOURCE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_REINSTALL
    {
        TRUE,
        FIX_COMMAND_REINSTALL,
        IDS_INST_REINSTALL,
        1,
        IDS_FIXIT_REINSTALL
    },
    // CM_PROB_REGISTRY (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_VXDLDR (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_WILL_BE_REMOVED (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DISABLED
    {
        TRUE,
        FIX_COMMAND_ENABLEDEVICE,
        IDS_INST_ENABLEDEVICE,
        1,
        IDS_FIXIT_ENABLEDEVICE
    },
     // CM_PROB_DEVLOADER_NOT_READY (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_DEVICE_NOT_THERE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_MOVED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_TOO_EARLY
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_NO_VALID_LOG_CONF
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_FAILED_INSTALL
    {
        TRUE,
        FIX_COMMAND_REINSTALL,
        IDS_INST_REINSTALL,
        1,
        IDS_FIXIT_REINSTALL
    },
     // CM_PROB_HARDWARE_DISABLED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_CANT_SHARE_IRQ
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_ADD
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DISABLED_SERVICE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_TRANSLATION_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NO_SOFTCONFIG
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_BIOS_TABLE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_IRQ_TRANSLATION_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_DRIVER_ENTRY
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD 
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_FAILED_LOAD
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_SERVICE_KEY_INVALID
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_LEGACY_SERVICE_NO_DEVICES
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DUPLICATE_DEVICE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_POST_START
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_HALTED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_PHANTOM
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_SYSTEM_SHUTDOWN
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_HELD_FOR_EJECT
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_BLOCKED
    {
        TRUE,
        FIX_COMMAND_DRIVERBLOCKED,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_REGISTRY_TOO_LARGE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_SETPROPERTIES_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // UNKNOWN PROBLEM
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
};

//
// CProblemAgent implementation
//
CProblemAgent::CProblemAgent(
    CDevice* pDevice,
    ULONG Problem,
    BOOL SeparateProcess
    )
{
    m_pDevice = pDevice;
    m_Problem = Problem;

    ASSERT(pDevice);

    m_idInstFirst = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].idInstFirst;
    m_idInstCount = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].idInstCount;
    m_idFixit = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].idFixit;
    m_FixCommand = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].FixCommand;
    m_SeparateProcess = SeparateProcess;
}

DWORD
CProblemAgent::InstructionText(
    LPTSTR Buffer,
    DWORD  BufferSize
    )
{
    String strLocalBuffer;
    SetLastError(ERROR_SUCCESS);

    if (m_idInstFirst) {
        strLocalBuffer.LoadString(g_hInstance, m_idInstFirst);

        String strTemp;
        for (int i = 1; i < m_idInstCount; i++) {
            strTemp.LoadString(g_hInstance, m_idInstFirst + i);
            strLocalBuffer += strTemp;
        }

        if (BufferSize > (DWORD)strLocalBuffer.GetLength()) {
            StringCchCopy(Buffer, BufferSize, (LPCTSTR)strLocalBuffer);
        }
    
        else if (strLocalBuffer.GetLength()) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    
        return strLocalBuffer.GetLength();
    }
    
    return 0;
}

DWORD
CProblemAgent::FixitText(
    LPTSTR Buffer,
    DWORD BufferSize
    )
{
    if (!Buffer && BufferSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    SetLastError(ERROR_SUCCESS);

    if (m_idFixit)
    {
        return LoadResourceString(m_idFixit, Buffer, BufferSize);
    }

    return 0;
}

BOOL
CProblemAgent::FixIt(
    HWND hwndOwner
    )
/*++

    Lanuches a troubleshooter based on the m_FixCommand.
    
Arguments:

    hwndOwner - Parent window handle
    
Return Value:
    TRUE if launching the troubleshooter changed the device in some way
    so that the UI on the general tab needs to be refreshed.
        
    FALSE if launching the troubleshooter did not change the device in
    any way.

--*/
{
    BOOL Result = FALSE;
    SP_TROUBLESHOOTER_PARAMS tsp;
    DWORD RequiredSize;

    tsp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    tsp.ClassInstallHeader.InstallFunction = DIF_TROUBLESHOOTER;
    tsp.ChmFile[0] = TEXT('\0');
    tsp.HtmlTroubleShooter[0] = TEXT('\0');

    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
            &tsp.ClassInstallHeader,
            sizeof(tsp)
            );

    //
    // If the class installer retuns NO_ERROR (SetupDiCallClassInstaller returns TRUE)
    // then don't launch the default troubleshooters because the class installer has
    // launched it's own troubleshooter
    //
    if (m_pDevice->m_pMachine->DiCallClassInstaller(DIF_TROUBLESHOOTER, *m_pDevice)) {

        return TRUE;
    
    } else if (ERROR_DI_DO_DEFAULT == GetLastError()) {

        m_pDevice->m_pMachine->DiGetClassInstallParams(*m_pDevice,
                                                       &tsp.ClassInstallHeader,
                                                       sizeof(tsp),
                                                       &RequiredSize
                                                       );
    }

    switch (m_FixCommand)
    {
    case FIX_COMMAND_UPGRADEDRIVERS:
        Result = UpgradeDriver(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_REINSTALL:
        Result = Reinstall(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_ENABLEDEVICE:
        Result = EnableDevice(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_STARTDEVICE:
        Result = EnableDevice(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_RESTARTCOMPUTER:
        Result = RestartComputer(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_DRIVERBLOCKED:
        Result = FixDriverBlocked(hwndOwner, m_pDevice, tsp.ChmFile, ARRAYLEN(tsp.ChmFile), tsp.HtmlTroubleShooter, ARRAYLEN(tsp.HtmlTroubleShooter));
        break;

    case FIX_COMMAND_TROUBLESHOOTER:
        Result = StartTroubleShooter(hwndOwner, m_pDevice, tsp.ChmFile, tsp.HtmlTroubleShooter);
        break;

    case FIX_COMMAND_DONOTHING:
        Result = TRUE;
        break;

    default:
        Result = FALSE;
    }

    return Result;
}


BOOL
CProblemAgent::UpgradeDriver(
    HWND hwndOwner,
    CDevice* pDevice
    )
{
    DWORD Status = 0, Problem = 0;

    if (!pDevice || !pDevice->m_pMachine->IsLocal() || !g_IsAdmin) {
        //
        // Must be an admin and on the local machine to update a device.
        //
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // If the device has the DN_WILL_BE_REMOVED flag set and the user is
    // attempting to update the driver then we will prompt them for a 
    // reboot and include text in the prompt that explains this device
    // is in the process of being removed.
    //
    if (pDevice->GetStatus(&Status, &Problem) &&
        (Status & DN_WILL_BE_REMOVED)) {

        //
        // First try and send a MMCPropertyChangeNotify message to our
        // CComponent so that it can prompt for a reboot inside the 
        // device manager thread instead of our thread.  If this is not 
        // done then the property sheet will hang around after device
        // manager has gone away...which will cause a "hung app" dialog
        // to appear.
        //
        CNotifyRebootRequest* pNRR = new CNotifyRebootRequest(hwndOwner, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);

        if (pNRR) {
            if (!pDevice->m_psd.PropertyChangeNotify(reinterpret_cast<LONG_PTR>(pNRR))) {
                //
                // There isn't a CComponent around, so this is just a property
                // sheet running outside of MMC.
                //
                pNRR->Release();
                PromptForRestart(hwndOwner, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
            }
        } else {
            //
            // We couldn't allocate memory to create our CNotifyRebootRequest
            // instance, so just prompt for a reboot in this thread.
            //
            PromptForRestart(hwndOwner, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
        }

        return FALSE;
    }

    pDevice->m_pMachine->InstallDevInst(hwndOwner, pDevice->GetDeviceID(), TRUE, NULL);

    return TRUE;
}

BOOL
CProblemAgent::Reinstall(
    HWND hwndOwner,
    CDevice* pDevice
    )
{

    return UpgradeDriver(hwndOwner, pDevice);
}

BOOL
CProblemAgent::EnableDevice(
    HWND hwndOwner,
    CDevice* pDevice
    )
{
    CWizard98 theSheet(hwndOwner);

    CTSEnableDeviceIntroPage* pEnableDeviceIntroPage = new CTSEnableDeviceIntroPage;

    if (!pEnableDeviceIntroPage) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    HPROPSHEETPAGE hIntroPage = pEnableDeviceIntroPage->Create(pDevice);
    theSheet.InsertPage(hIntroPage);

    CTSEnableDeviceFinishPage* pEnableDeviceFinishPage = new CTSEnableDeviceFinishPage;

    if (!pEnableDeviceFinishPage) {

        if (pEnableDeviceIntroPage) {
            delete pEnableDeviceIntroPage;
        }
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    HPROPSHEETPAGE hFinishPage = pEnableDeviceFinishPage->Create(pDevice);
    theSheet.InsertPage(hFinishPage);

    return (BOOL)theSheet.DoSheet();
}

BOOL
CProblemAgent::RestartComputer(
    HWND hwndOwner,
    CDevice* pDevice
    )
{
    HWND hwndFocus;

    if (!pDevice || !pDevice->m_pMachine)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hwndFocus = GetFocus();

    CWizard98 theSheet(hwndOwner);

    CTSRestartComputerFinishPage* pRestartComputerFinishPage = new CTSRestartComputerFinishPage;

    if (!pRestartComputerFinishPage) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    HPROPSHEETPAGE hPage = pRestartComputerFinishPage->Create(pDevice);
    theSheet.InsertPage(hPage);

    theSheet.DoSheet();

    // restore focus
    if (hwndFocus) {

        SetFocus(hwndFocus);
    }

    return TRUE;
}

BOOL
CProblemAgent::FixDriverBlocked(
    HWND hwndOwner,
    CDevice* pDevice,
    LPTSTR ChmFile,
    ULONG ChmFileSize,
    LPTSTR HtmlTroubleShooter,
    ULONG HtmlTroubleShooterSize
    )
{
    CDriver *pDriver = NULL;
    CDriverFile* pDrvFile = NULL;
    PVOID Context;
    LPCTSTR pBlockDriverHtmlHelpID = NULL;

    *ChmFile = TEXT('\0');

    pDriver = pDevice->CreateDriver();

    if (pDriver) {
        //
        // Build up a list of function and filter drivers for this device.
        //
        pDriver->BuildDriverList(TRUE);

        //
        // Enumerate through the list of drivers for this device until we find
        // one that has a blocked driver html help ID.
        //
        pDriver->GetFirstDriverFile(&pDrvFile, Context);

	    if (pDrvFile) {
            do {
                if (pDrvFile && 
                    ((pBlockDriverHtmlHelpID = pDrvFile->GetBlockedDriverHtmlHelpID()) != NULL) &&
                    (*pBlockDriverHtmlHelpID != TEXT('\0')) &&
                    (lstrlen(pBlockDriverHtmlHelpID) < (int)ChmFileSize)) {
                    //
                    // Found a Blocked Driver html help ID, assuming we can
                    // copy it into our local ChmFile buffer, then break
                    // out of the loop.  If we can't then just continue, since
                    // we can't launch a truncated help center page!
                    //
                    if (SUCCEEDED(StringCchCopy(ChmFile, 
                                                ChmFileSize, 
                                                pBlockDriverHtmlHelpID))) {
                        break;
                    }
                }

            } while (pDriver->GetNextDriverFile(&pDrvFile, Context));
        }
    }

    //
    // If we have a ChmFile then launch that troubleshooter, otherwise 
    // Get the troubleshooter and launch it.
    //
    if (*ChmFile ||
        GetTroubleShooter(pDevice, ChmFile, ChmFileSize, HtmlTroubleShooter, HtmlTroubleShooterSize)) {
    
        LaunchHtlmTroubleShooter(hwndOwner, ChmFile, HtmlTroubleShooter);
    }

    if (pDriver) {
        delete pDriver;
    }

    return TRUE;
}

BOOL
ParseTroubleShooter(
    LPCTSTR TSString,
    LPTSTR ChmFile,
    ULONG ChmFileSize,
    LPTSTR HtmlTroubleShooter,
    ULONG HtmlTroubleShooterSize
    )
{
    //
    // Berify parameters
    //
    if (!TSString || TEXT('\0') == TSString[0] || !ChmFile || !HtmlTroubleShooter)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make a copy of the string because we have to party on it
    //
    ULONG Len = lstrlen(TSString) + 1;
    TCHAR* psz = new TCHAR[Len];

    if (!psz) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    StringCchCopy(psz, Len, TSString);

    LPTSTR ChmName = NULL;
    LPTSTR ChmNameEnd = NULL;
    LPTSTR HtmName = NULL;
    LPTSTR HtmNameEnd = NULL;
    LPTSTR p;

    p = psz;

    SetLastError(ERROR_SUCCESS);

    //
    // the format of the  string is "chmfile, htmlfile"
    //
    p = SkipBlankChars(p);

    if (TEXT('\0') != *p) {
        //
        // looking for CHM file which could be enclosed
        // inside double quote chars.
        // NOTE: not double quote chars inside double quoted string is allowed.
        //
        if (TEXT('\"') == *p) {

            ChmName = ++p;
        
            while (TEXT('\"') != *p && TEXT('\0') != *p) {
                
                p++;
            }

            ChmNameEnd = p;
        
            if (TEXT('\"') == *p) {

                p++;
            }
        
        } else {

            ChmName = p;
        
            while ((TEXT('\0') != *p) && 
                   !IsBlankChar(*p) && 
                   (TEXT(',') != *p)
                   ) {

                p++;
            }

            ChmNameEnd = p;
        }

        //
        // looking for ','
        //
        if (TEXT('\0') != *p) {
        
            p = SkipBlankChars(p);
    
            if (TEXT('\0') != *p && TEXT(',') == *p) {
    
                p = SkipBlankChars(p + 1);
    
                if (TEXT('\0') != *p) {
    
                    HtmName = p++;
    
                    while (!IsBlankChar(*p) && TEXT('\0') != *p) {
    
                        p++;
                    }
    
                    HtmNameEnd = p;
                }
            }
        }
    }

    if (HtmName && HtmNameEnd) {
        
        *HtmNameEnd = TEXT('\0');
        if (FAILED(StringCchCopy(HtmlTroubleShooter, HtmlTroubleShooterSize, HtmName))) {
            //
            // We could not copy all of the troubleshooter name into the buffer
            // so set HtmName and ChmName to NULL, so that we will FAIL the call.
            //
            HtmName = NULL;
            ChmName = NULL;
        }
    }

    if (ChmName && ChmNameEnd){
        
        *ChmNameEnd = TEXT('\0');
        if (FAILED(StringCchCopy(ChmFile, ChmFileSize, ChmName))) {
            //
            // We could not copy all of the Chm file name into the buffer
            // so set the HtmName and ChmName to NULL, so that we will FAIL this 
            // call.
            //
            HtmName = NULL;
            ChmName = NULL;
        }
    }

    if (HtmName || ChmName) {

        return TRUE;
    }

    return FALSE;
}

//
// This function looks for CHM and HTM troubleshooter files for this device.
//
// The troubleshoooter string value has the following form:
//  "TroubleShooter-xx" = "foo.chm, bar.htm"
// where xx is the problem code for the device
//
// It first looks under the devices driver key.
// If nothing is found there it looks under the class key.
// If nothing is there it looks in the default troubleshooter location
// If nothing is there it just displays the hard-coded generic troubleshooter.
//
BOOL
CProblemAgent::GetTroubleShooter(
    CDevice* pDevice,
    LPTSTR ChmFile,
    ULONG ChmFileSize,
    LPTSTR HtmlTroubleShooter,
    ULONG HtmlTroubleShooterSize
    )
{
    BOOL Result = FALSE;
    DWORD Status, Problem = 0;
    String strTroubleShooterKey;
    String strTroubleShooterValue;
    HKEY hKey;

    strTroubleShooterKey.Empty();
    strTroubleShooterValue.Empty();

    try {

        if (pDevice->GetStatus(&Status, &Problem)) {

            //
            // If the device is a phantom device, use the CM_PROB_DEVICE_NOT_THERE
            //
            if (pDevice->IsPhantom()) {

                Problem = CM_PROB_PHANTOM;
            }

            //
            // If the device is not started and no problem is assigned to it
            // fake the problem number to be failed start.
            //
            if (!(Status & DN_STARTED) && !Problem && pDevice->IsRAW()) {

                Problem = CM_PROB_FAILED_START;
            }
        }

        strTroubleShooterKey.Format(TEXT("TroubleShooter-%d"), Problem);

        //
        // First check the devices driver key
        //
        hKey = pDevice->m_pMachine->DiOpenDevRegKey(*pDevice, DICS_FLAG_GLOBAL,
                     0, DIREG_DRV, KEY_READ);

        if (INVALID_HANDLE_VALUE != hKey)
        {
            CSafeRegistry regDrv(hKey);

            //
            // Get the TroubleShooter value from the driver key
            //
            if (regDrv.GetValue((LPTSTR)strTroubleShooterKey, strTroubleShooterValue))
            {
                if (ParseTroubleShooter((LPTSTR)strTroubleShooterValue, ChmFile, ChmFileSize, HtmlTroubleShooter, HtmlTroubleShooterSize)) {

                    Result = TRUE;
                }
            }
        }

        //
        // If we don't have a TroubleShooter yet then try the class key
        //
        if (!Result) {

            CClass* pClass = pDevice->GetClass();
            ASSERT(pClass);
            LPGUID pClassGuid = *pClass;

            hKey = pDevice->m_pMachine->DiOpenClassRegKey(pClassGuid, KEY_READ, DIOCR_INSTALLER);

            if (INVALID_HANDLE_VALUE != hKey)
            {
                CSafeRegistry regClass(hKey);

                // get the TroubleShooter value from the class key
                if (regClass.GetValue((LPTSTR)strTroubleShooterKey, strTroubleShooterValue))
                {
                    if (ParseTroubleShooter((LPTSTR)strTroubleShooterValue, ChmFile, ChmFileSize, HtmlTroubleShooter, HtmlTroubleShooterSize)) {

                        Result = TRUE;
                    }
                }
            }
        }

        //
        // If we still don't have a TroubleShooter then try the default TroubleShooters
        // key.
        //
        if (!Result) {

            CSafeRegistry regDevMgr;
            CSafeRegistry regTroubleShooters;

            if (regDevMgr.Open(HKEY_LOCAL_MACHINE, REG_PATH_DEVICE_MANAGER) &&
                regTroubleShooters.Open(regDevMgr, REG_STR_TROUBLESHOOTERS)) {

                //
                // Get the TroubleShooter value from the default TroubleShooters key
                //
                if (regTroubleShooters.GetValue((LPTSTR)strTroubleShooterKey, strTroubleShooterValue))
                {
                    if (ParseTroubleShooter((LPTSTR)strTroubleShooterValue, ChmFile, ChmFileSize, HtmlTroubleShooter, HtmlTroubleShooterSize)) {

                        Result = TRUE;
                    }
                }
            }
        }

        //
        // And finally, if still not TroubleShooter we will just use the default one
        //
        if (!Result) {

            if (SUCCEEDED(StringCchCopy(ChmFile, ChmFileSize, TEXT("hcp://help/tshoot/hdw_generic.htm")))) {
                HtmlTroubleShooter[0] = TEXT('\0');
                Result = TRUE;
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();

        Result = FALSE;
    }

    return Result;
}

void
CProblemAgent::LaunchHtlmTroubleShooter(
    HWND hwndOwner,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    String strFormat, strCommand;

    if ((!ChmFile || !*ChmFile) &&
        (!HtmlTroubleShooter || !*HtmlTroubleShooter)) {
        //
        // If both ChmFile and HtmlTroubleShooter are NULL then
        // bail out.
        //
        return;
    }

    //
    // There are two different types of troubleshooters that can be launched.  
    // HelpCenter troubleshooters and HtmlHelp troubleshooters. This API tells
    // the difference by checking if a HtmlTroubleShooter was specified or not.
    // If only a ChmFile was specified and it starts with hcp:// then this API
    // will send the entire string to help center. Otherwise we send the string
    // to HtmlHelp (or hh.exe if it is launched as a separate process).
    //
    if ((!HtmlTroubleShooter || (HtmlTroubleShooter[0] == TEXT('\0'))) &&
        (StrCmpNI(ChmFile, TEXT("hcp://"), lstrlen(TEXT("hcp://"))) == 0)) {
        //
        // This is a new HelpCenter troubleshooter
        //
        strCommand.Format(TEXT(" -url %s"), ChmFile);

        ShellExecute(hwndOwner, 
                     TEXT("open"),
                     TEXT("HELPCTR.EXE"),
                     (LPTSTR)strCommand, 
                     NULL, 
                     SW_SHOWNORMAL
                     );

    } else {
        //
        // This is an old HtlmHelp troubleshooter
        //
        if (m_SeparateProcess) {
    
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            if (strFormat.GetSystemWindowsDirectory()) {
                //
                // Tack on an extra back slash if one is needed
                //
                if (_T('\\') != strFormat[strFormat.GetLength() - 1]) {
                    strFormat += (LPCTSTR)TEXT("\\");
                }

                strFormat += (LPCTSTR)TEXT("hh.exe ms-its:%s::/%s");
    
                strCommand.Format((LPCTSTR)strFormat, ChmFile, HtmlTroubleShooter);

                ZeroMemory(&si, sizeof(si));
                si.cb = sizeof(si);
                si.dwFlags = STARTF_USESHOWWINDOW;
                si.wShowWindow = SW_NORMAL;
        
                if (CreateProcess(NULL, (LPTSTR)strCommand, NULL, NULL, FALSE, 0, 0, NULL, &si, &pi)) {
        
                    CloseHandle(pi.hThread);
                    CloseHandle(pi.hProcess);
                }
            }
        } else {
    
            HtmlHelp(hwndOwner, ChmFile, HH_DISPLAY_TOPIC, (LPARAM)HtmlTroubleShooter);
        }
    }
}


BOOL
CProblemAgent::StartTroubleShooter(
    HWND hwndOwner,
    CDevice* pDevice,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    //
    // If the class installers or one of the co-installers returned
    // ERROR_DI_DO_DEFAULT then verify that they filled in either the ChmFile
    // or the HtmlTroubleShooter, or both.
    //
    if ((ERROR_DI_DO_DEFAULT == GetLastError()) &&
        (((ChmFile[0] != TEXT('\0')) ||
         (HtmlTroubleShooter[0] != TEXT('\0'))))) {

        LaunchHtlmTroubleShooter(hwndOwner, ChmFile, HtmlTroubleShooter);

    } else {

        SP_TROUBLESHOOTER_PARAMS tsp;
        tsp.ChmFile[0] = TEXT('\0');
        tsp.HtmlTroubleShooter[0] = TEXT('\0');

        //
        // Get CHM file and TroubleShooter file from the registry
        //
        if (GetTroubleShooter(pDevice, tsp.ChmFile, ARRAYLEN(tsp.ChmFile), tsp.HtmlTroubleShooter, ARRAYLEN(tsp.HtmlTroubleShooter))) {

            LaunchHtlmTroubleShooter(hwndOwner, tsp.ChmFile, tsp.HtmlTroubleShooter);
        }
    }

    //
    // Return FALSE since launching the troubleshooter does not change the device
    // in any way.
    //
    return FALSE;
}

CWizard98::CWizard98(
    HWND hwndParent,
    UINT MaxPages
    )
{
    m_MaxPages = 0;

    if (MaxPages && MaxPages <= 32) {

        m_MaxPages = MaxPages;
        memset(&m_psh, 0, sizeof(m_psh));
        m_psh.hInstance = g_hInstance;
        m_psh.hwndParent = hwndParent;
        m_psh.phpage = new HPROPSHEETPAGE[MaxPages];
        m_psh.dwSize = sizeof(m_psh);
        m_psh.dwFlags = PSH_WIZARD | PSH_USEICONID | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
        m_psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
        m_psh.pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
        m_psh.pszIcon = MAKEINTRESOURCE(IDI_DEVMGR);
        m_psh.pszCaption = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psh.pfnCallback = CWizard98::WizardCallback;
    }
}

INT
CWizard98::WizardCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{
    UNREFERENCED_PARAMETER(hwndDlg);

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        break;

    case PSCB_PRECREATE:
        if( lParam ){

            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~(DS_CONTEXTHELP | WS_SYSMENU);
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\tsmisc.h ===
#ifndef __TSMISC_H__
#define __TSMISC_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    tsmisc.h

Abstract:

    header file for tsmain.cpp

Author:

    Jason Cobb (jasonc) created

Revision History:


--*/


//
// Class that represents a single wizard page for the following problems:
//
//  Enable device
//  Restart
//
class CTSEnableDeviceIntroPage : public CPropSheetPage
{
public:
    CTSEnableDeviceIntroPage() : 
            m_pDevice(NULL), 
            m_Problem(0),
            CPropSheetPage(g_hInstance, IDD_TS_ENABLEDEVICE_INTRO)
    {
    }

    virtual BOOL OnWizNext();
    virtual BOOL OnSetActive();
    HPROPSHEETPAGE Create(CDevice* pDevice);

private:
    CDevice* m_pDevice;
    ULONG m_Problem;
};

class CTSEnableDeviceFinishPage : public CPropSheetPage
{
public:
    CTSEnableDeviceFinishPage() : 
            m_pDevice(NULL), 
            m_Problem(0),
            CPropSheetPage(g_hInstance, IDD_TS_ENABLEDEVICE_FINISH)
    {
    }

    virtual BOOL OnWizFinish();
    virtual BOOL OnSetActive();
    HPROPSHEETPAGE Create(CDevice* pDevice);

private:
    CDevice* m_pDevice;
    ULONG m_Problem;
};


class CTSRestartComputerFinishPage : public CPropSheetPage
{
public:
    CTSRestartComputerFinishPage() : 
            m_pDevice(NULL), 
            m_Problem(0),
            CPropSheetPage(g_hInstance, IDD_TS_RESTARTCOMPUTER_FINISH)
    {
    }

    virtual BOOL OnWizFinish();
    virtual BOOL OnSetActive();
    HPROPSHEETPAGE Create(CDevice* pDevice);

private:
    CDevice* m_pDevice;
    ULONG m_Problem;
};

    
#endif // __TSMISC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\ansi.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "verpriv.h"

#define DWORDUP(x) (((x)+3) & ~3)
DWORD
APIENTRY
VerFindFileA(
        DWORD wFlags,
        LPSTR lpszFileName,
        LPSTR lpszWinDir,
        LPSTR lpszAppDir,
        LPSTR lpszCurDir,
        PUINT puCurDirLen,
        LPSTR lpszDestDir,
        PUINT puDestDirLen
        )
{
    UNICODE_STRING FileName;
    UNICODE_STRING WinDir;
    UNICODE_STRING AppDir;
    UNICODE_STRING CurDir;
    UNICODE_STRING DestDir;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD       CurDirLen = (*puCurDirLen) ? (*puCurDirLen) : 1;
    DWORD       DestDirLen = (*puDestDirLen) ? (*puDestDirLen) : 1;

    CurDirLen = min(MAX_PATH, CurDirLen);
    DestDirLen = min(MAX_PATH, DestDirLen);

    RtlInitAnsiString(&AnsiString, lpszFileName);
    Status = RtlAnsiStringToUnicodeString(&FileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return VFF_BUFFTOOSMALL;
    }
    RtlInitAnsiString(&AnsiString, lpszWinDir);
    Status = RtlAnsiStringToUnicodeString(&WinDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&FileName);
        SetLastError(Status);
        return VFF_BUFFTOOSMALL;
    }
    RtlInitAnsiString(&AnsiString, lpszAppDir);
    Status = RtlAnsiStringToUnicodeString(&AppDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&FileName);
        RtlFreeUnicodeString(&WinDir);
        SetLastError(Status);
        return VFF_BUFFTOOSMALL;
    }
    CurDir.MaximumLength = (USHORT)CurDirLen * sizeof(WCHAR);
    CurDir.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, CurDir.MaximumLength);
    if (CurDir.Buffer == NULL) {
        RtlFreeUnicodeString(&FileName);
        RtlFreeUnicodeString(&WinDir);
        RtlFreeUnicodeString(&AppDir);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return VFF_BUFFTOOSMALL;
    }
    DestDir.MaximumLength = (USHORT)DestDirLen * sizeof(WCHAR);
    DestDir.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, DestDir.MaximumLength);
    if (DestDir.Buffer == NULL) {
        RtlFreeUnicodeString(&FileName);
        RtlFreeUnicodeString(&WinDir);
        RtlFreeUnicodeString(&AppDir);
        RtlFreeUnicodeString(&CurDir);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return VFF_BUFFTOOSMALL;
    }
    Status = VerFindFileW(wFlags,
                        FileName.Buffer,
                        WinDir.Buffer,
                        AppDir.Buffer,
                        CurDir.Buffer, &CurDirLen,
                        DestDir.Buffer, &DestDirLen);

    if (Status & VFF_BUFFTOOSMALL) {
        *lpszCurDir = 0;
        *puCurDirLen = CurDirLen;
        *lpszDestDir = 0;
        *puDestDirLen = DestDirLen;
    } else {

        CurDir.Length = (USHORT)(sizeof(WCHAR)*CurDirLen);
        DestDir.Length = (USHORT)(sizeof(WCHAR)*DestDirLen);

        AnsiString.Buffer = lpszCurDir;
        AnsiString.MaximumLength = (USHORT)*puCurDirLen;
        RtlUnicodeStringToAnsiString(&AnsiString, &CurDir, FALSE);
        *puCurDirLen = AnsiString.Length;

        AnsiString.Buffer = lpszDestDir;
        AnsiString.MaximumLength = (USHORT)*puDestDirLen;
        RtlUnicodeStringToAnsiString(&AnsiString, &DestDir, FALSE);
        *puDestDirLen = AnsiString.Length;
    }

    RtlFreeUnicodeString(&FileName);
    RtlFreeUnicodeString(&WinDir);
    RtlFreeUnicodeString(&AppDir);
    RtlFreeUnicodeString(&CurDir);
    RtlFreeUnicodeString(&DestDir);
    return Status;

}

DWORD
APIENTRY
VerInstallFileA(
        DWORD wFlags,
        LPSTR lpszSrcFileName,
        LPSTR lpszDstFileName,
        LPSTR lpszSrcDir,
        LPSTR lpszDstDir,
        LPSTR lpszCurDir,
        LPSTR lpszTmpFile,
        PUINT puTmpFileLen
        )
{
    UNICODE_STRING SrcFileName;
    UNICODE_STRING DstFileName;
    UNICODE_STRING SrcDir;
    UNICODE_STRING CurDir;
    UNICODE_STRING DstDir;
    UNICODE_STRING TmpFile;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD    TmpFileLen = (*puTmpFileLen) ? (*puTmpFileLen) : 1;

    TmpFileLen = min(MAX_PATH, TmpFileLen);

    RtlInitAnsiString(&AnsiString, lpszSrcFileName);
    Status = RtlAnsiStringToUnicodeString(&SrcFileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszDstFileName);
    Status = RtlAnsiStringToUnicodeString(&DstFileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszSrcDir);
    Status = RtlAnsiStringToUnicodeString(&SrcDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszCurDir);
    Status = RtlAnsiStringToUnicodeString(&CurDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszDstDir);
    Status = RtlAnsiStringToUnicodeString(&DstDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        RtlFreeUnicodeString(&CurDir);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }

    RtlInitAnsiString(&AnsiString, lpszTmpFile);

    TmpFile.MaximumLength = (USHORT)(TmpFileLen * sizeof(WCHAR));
    TmpFile.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, TmpFile.MaximumLength);
    if (TmpFile.Buffer == NULL) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        RtlFreeUnicodeString(&CurDir);
        RtlFreeUnicodeString(&DstDir);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return VIF_OUTOFMEMORY;
    }

    Status = RtlAnsiStringToUnicodeString(&TmpFile, &AnsiString, FALSE);

    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        RtlFreeUnicodeString(&CurDir);
        RtlFreeUnicodeString(&DstDir);
        RtlFreeUnicodeString(&TmpFile);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }

    Status = VerInstallFileW(wFlags,
                        SrcFileName.Buffer,
                        DstFileName.Buffer,
                        SrcDir.Buffer,
                        DstDir.Buffer,
                        CurDir.Buffer,
                        TmpFile.Buffer, &TmpFileLen);

    if (Status & VIF_BUFFTOOSMALL) {
        //
        // The lpszTmpFile buffer was too small,
        // the TmpFileLen field contains the size necessary.
        //
        *lpszTmpFile = 0;
        *puTmpFileLen = TmpFileLen;

    } else {

        TmpFile.Length = TmpFile.MaximumLength = (USHORT)(TmpFileLen * sizeof(WCHAR));

        AnsiString.Buffer = lpszTmpFile;
        AnsiString.MaximumLength = (USHORT)*puTmpFileLen;
        RtlUnicodeStringToAnsiString(&AnsiString, &TmpFile, FALSE);
        *puTmpFileLen = AnsiString.Length;
    }

    RtlFreeUnicodeString(&SrcFileName);
    RtlFreeUnicodeString(&DstFileName);
    RtlFreeUnicodeString(&SrcDir);
    RtlFreeUnicodeString(&DstDir);
    RtlFreeUnicodeString(&CurDir);
    RtlFreeUnicodeString(&TmpFile);
    return Status;
}

DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPCSTR lpstrFilename,
        LPDWORD lpdwHandle
        )
{
    UNICODE_STRING FileName;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD dwStatus;

    RtlInitAnsiString(&AnsiString, lpstrFilename);
    Status = RtlAnsiStringToUnicodeString(&FileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return FALSE;
    }

    dwStatus = GetFileVersionInfoSizeW(FileName.Buffer, lpdwHandle);
    RtlFreeUnicodeString(&FileName);
    return dwStatus;
}

BOOL
APIENTRY
GetFileVersionInfoA(
        LPCSTR lpstrFilename,
        DWORD dwHandle,
        DWORD dwLen,
        LPVOID lpData
        )
{
    UNICODE_STRING FileName;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL bStatus;

    RtlInitAnsiString(&AnsiString, lpstrFilename);
    Status = RtlAnsiStringToUnicodeString(&FileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return FALSE;
    }

    bStatus = GetFileVersionInfoW(FileName.Buffer, dwHandle, dwLen, lpData);
    RtlFreeUnicodeString(&FileName);
    return bStatus;
}


/*
 *  DWORD
 *  APIENTRY
 *  VerLanguageNameA(
 *      DWORD wLang,
 *      LPSTR szLang,
 *      DWORD wSize)
 *
 *  This routine was moved to NLSLIB.LIB so that it uses the WINNLS.RC file.
 *  NLSLIB.LIB is part of KERNEL32.DLL.
 */


BOOL
APIENTRY
VerQueryValueIndexA(
        const LPVOID pb,
        LPSTR lpSubBlock,
        INT    nIndex,
        LPVOID *lplpKey,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
   return VerpQueryValue(pb,
                         lpSubBlock,
                         nIndex,
                         lplpKey,
                         lplpBuffer,
                         puLen,
                         FALSE);
}

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pb,
        LPSTR lpSubBlock,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
    return VerpQueryValue(pb,
                          lpSubBlock,
                          -1,
                          NULL,
                          lplpBuffer,
                          puLen,
                          FALSE);
}


BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pb,
        LPWSTR lpSubBlock,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
    return VerpQueryValue(pb,
                          lpSubBlock,
                          -1,
                          NULL,
                          lplpBuffer,
                          puLen,
                          TRUE);
}


BOOL
APIENTRY
VerQueryValueIndexW(
        const LPVOID pb,
        LPWSTR lpSubBlock,
        INT    nIndex,
        LPVOID *lplpKey,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
    return VerpQueryValue(pb,
                          lpSubBlock,
                          nIndex,
                          lplpKey,
                          lplpBuffer,
                          puLen,
                          TRUE);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\utils.h ===
#ifndef __UTILS__H
#define __UTILS__H
/*++

Copyright (C) Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module declares utilities classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// Memory allocation exception class
//
class CMemoryException
{
public:
    CMemoryException(BOOL Global)
    {
        m_Global = Global;
        m_Message[0] = _T('\0');
        m_Caption[0] = _T('\0');
        m_Options = MB_OK | MB_ICONHAND;
    }
    BOOL SetMessage(LPCTSTR Message)
    {
        if (!Message || lstrlen(Message) >= ARRAYLEN(m_Message))
        {
            return FALSE;
        }

        StringCchCopy(m_Message, ARRAYLEN(m_Message), Message);
        return TRUE;

    }
    BOOL SetCaption(LPCTSTR Caption)
    {
        if (!Caption || lstrlen(Caption) >= ARRAYLEN(m_Caption))
        {
            return FALSE;
        }

        StringCchCopy(m_Caption, ARRAYLEN(m_Caption), Caption);
        return TRUE;
    }
    void ReportError(HWND hwndParent = NULL)
    {
        MessageBox(hwndParent, m_Message, m_Caption, m_Options);
    }
    void Delete()
    {
        if (!m_Global)
        {
            delete this;
        }
    }

private:
    TCHAR m_Message[128];
    TCHAR m_Caption[128];
    DWORD m_Options;
    BOOL  m_Global;
};

//
// data buffer control class for String class
//
class StringData
{
public:
    StringData() : Ref(1), ptsz(NULL), Len(0)
    {}
    ~StringData()
    {
        delete [] ptsz;
    }
    long AddRef()
    {
        Ref++;
        return Ref;
    }
    long Release()
    {
        ASSERT(Ref);
        if (!(--Ref))
        {
        delete this;
        return 0;
        }
        return Ref;
    }
    TCHAR*  ptsz;
    long    Len;

private:
    long    Ref;
};

class CBlock
{
public:
    CBlock(CBlock* BlockHead, UINT unitCount, UINT unitSize)
    {
        data = new BYTE[unitCount * unitSize];
        if (data)
        {
            if (BlockHead)
            {
                m_Next = BlockHead->m_Next;
                BlockHead->m_Next = this;
            }
            else
            {
                m_Next = NULL;
            }
        }
        else
        {
            throw &g_MemoryException;
        }
    }
    ~CBlock()
    {
        if (data)
            delete [] data;
        if (m_Next)
            delete m_Next;
    }
    void*   data;

private:
    CBlock* m_Next;
};


//
// Text string class
//
class String
{
public:
// constructors
    String();
    String(LPCTSTR lptsz);
    String(const String& strSrc);
    ~String()
    {
        m_pData->Release();
    }
//operators

    TCHAR& operator[](int Index);
    operator LPTSTR();

    const TCHAR& operator[](int Index) const
    {
        ASSERT(Index < m_pData->Len && m_pData->ptsz);
        return m_pData->ptsz[Index];
    }

    operator LPCTSTR () const
    {
        return m_pData->ptsz;
    }
    String& operator=(const String& strSrc);
    String& operator=(LPCTSTR ptsz);
    String& operator+=(const String& strSrc);
    String& operator+=(LPCTSTR prsz);
    friend String operator+(const String& str1, const String& str2);

    int GetLength() const
    {
        return m_pData->Len;
    }
    BOOL IsEmpty() const
    {
        return (0 == m_pData->Len);
    }
    int Compare(const String& strSrc) const
    {
        return lstrcmp(m_pData->ptsz, strSrc.m_pData->ptsz);
    }
    int CompareNoCase(const String& strSrc) const
    {
        return lstrcmpi(m_pData->ptsz, strSrc.m_pData->ptsz);
    }
    void Empty();
    BOOL LoadString(HINSTANCE hInstance, int ResourceId);
    BOOL GetComputerName();
    BOOL GetSystemWindowsDirectory();
    BOOL GetSystemDirectory();
    void Format(LPCTSTR FormatString, ...);
    StringData* m_pData;

protected:
    String(int Len);
};

//
// Command line parsing class
//
class CCommandLine
{
public:
    void ParseCommandLine(LPCTSTR cmdline);
    virtual void ParseParam(LPCTSTR Param, BOOL bFlag) = 0;
};




//
// Safe registry class
//
class CSafeRegistry
{
public:
    CSafeRegistry(HKEY hKey = NULL) : m_hKey(hKey)
    {}
    ~CSafeRegistry()
    {
        if (m_hKey)
        {
            RegCloseKey(m_hKey);
        }
    }
    operator HKEY()
    {
        return m_hKey;
    }
    BOOL Open(HKEY hKeyAncestor, LPCTSTR KeyName, REGSAM Access = KEY_ALL_ACCESS);
    void Close()
    {
        if (m_hKey)
        {
            RegCloseKey(m_hKey);
        }

        m_hKey = NULL;
    }
    BOOL Create(HKEY hKeyAncestor, LPCTSTR KeyName,
             REGSAM Access = KEY_ALL_ACCESS,
             DWORD * pDisposition = NULL, DWORD  Options = 0,
             LPSECURITY_ATTRIBUTES pSecurity = NULL);
    BOOL SetValue(LPCTSTR ValueName, DWORD Type, PBYTE pData, DWORD DataLen);
    BOOL SetValue(LPCTSTR ValueName, LPCTSTR Value);
    BOOL GetValue(LPCTSTR ValueName, DWORD* pType, PBYTE Buffer, DWORD* BufferLen);
    BOOL GetValue(LPCTSTR ValueName, String& str);
    BOOL DeleteValue(LPCTSTR ValueName);
    BOOL DeleteSubkey(LPCTSTR SubkeyName);
    BOOL EnumerateSubkey(DWORD Index, LPTSTR Buffer, DWORD* BufferSize);

private:
    HKEY    m_hKey;
};

// define iteration context. To be used by CLIST
struct tagPosition{ };
typedef tagPosition* POSITION;

template<class TYPE>
inline void ConstructElements(TYPE* pElements, int Count)
{
    memset((void*)&pElements, 0, Count * sizeof(TYPE));
    
    for (; Count; Count--, pElements++)
    {
        // call the contructor -- note the placement
        ::new((void*)pElements) TYPE;
    }
}

template<class TYPE>
inline void DestructElements(TYPE* pElements, int Count)
{
    for (; Count; Count--, pElements++)
    {
        pElements->~TYPE();
    }
}
//
// TEMPLATEs
//


//
// CList template, adapted from MFC
//
template<class TYPE, class ARG_TYPE>
class CList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };

public:
// Construction
    CList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    POSITION AddHead(ARG_TYPE newElement);
    POSITION AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CList* pNewList);
    void AddTail(CList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    TYPE& GetNext(POSITION& rPosition); // return *Position++
    TYPE GetNext(POSITION& rPosition) const; // return *Position++
    TYPE& GetPrev(POSITION& rPosition); // return *Position--
    TYPE GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(POSITION position);
    TYPE GetAt(POSITION position) const;
    void SetAt(POSITION pos, ARG_TYPE newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
    POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

    POSITION FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    CBlock* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CList();
};


/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
    { CNode* pNode = (CNode*) pos;
        pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
    ASSERT(nBlockSize > 0);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
    {
        DestructElements<TYPE>(&pNode->data, 1);
    }

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    delete m_pBlocks;
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
    RemoveAll();
    ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CBlock* pNewBlock = new CBlock(m_pBlocks, m_nBlockSize, sizeof(CNode));
        
        if (!pNewBlock) {

            throw &g_MemoryException;
        }

        if (m_pBlocks == NULL)
        {
            m_pBlocks = pNewBlock;
        }

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data;
        
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    
    ASSERT(m_pNodeFree != NULL);  // we must have something

    CList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);  // make sure we don't overflow

    ConstructElements<TYPE>(&pNode->data, 1);
    
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DestructElements<TYPE>(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    ASSERT(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    
    if (m_pNodeHead != NULL)
    {
        m_pNodeHead->pPrev = pNewNode;
    }
    else
    {
        m_pNodeTail = pNewNode;
    }

    m_pNodeHead = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
    {
        m_pNodeTail->pNext = pNewNode;
    }
    else
    {
        m_pNodeHead = pNewNode;
    }

    m_pNodeTail = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
    ASSERT(pNewList != NULL);

    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    
    while (pos != NULL)
    {
        AddHead(pNewList->GetPrev(pos));
    }
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
    ASSERT(pNewList != NULL);

    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    
    while (pos != NULL)
    {
        AddTail(pNewList->GetNext(pos));
    }
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
    ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    
    if (m_pNodeHead != NULL)
    {
        m_pNodeHead->pPrev = NULL;
    }
    else
    {
        m_pNodeTail = NULL;
    }
    
    FreeNode(pOldNode);
    
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
    ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    
    if (m_pNodeTail != NULL)
    {
        m_pNodeTail->pNext = NULL;
    }
    else
    {
        m_pNodeHead = NULL;
    }
    
    FreeNode(pOldNode);
    
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{

    if (position == NULL)
    {
        return AddHead(newElement); // insert before nothing -> head of the list
    }

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeHead);
        m_pNodeHead = pNewNode;
    }
    
    pOldNode->pPrev = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{

    if (position == NULL)
    {
        return AddTail(newElement); // insert after nothing -> tail of the list
    }

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeTail);
        m_pNodeTail = pNewNode;
    }
    
    pOldNode->pNext = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{

    CNode* pOldNode = (CNode*) position;

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    
    FreeNode(pOldNode);
}


template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nCount)
    {
        return NULL;  // went too far
    }

    CNode* pNode = m_pNodeHead;
    
    while (nIndex--)
    {
        pNode = pNode->pNext;
    }
    
    return (POSITION) pNode;
}



// NOTE:
// dereferencing operator -> is not supported in this template
// because this is designed to allocate intrinsic data types only
//
template<class T>
class BufferPtr
{
public:
    BufferPtr(UINT Size) : m_pBase(NULL), m_Size(Size)
    {
        ASSERT(Size);
        m_pBase = new T[Size];
        m_pCur = m_pBase;
        
        if (!m_pBase)
        {
            throw &g_MemoryException;
        }
    }
    BufferPtr()
    {
        m_pBase = NULL;
        m_pCur = NULL;
        m_Size = 0;
    }
    ~BufferPtr()
    {
        if (m_pBase)
        {
            delete [] m_pBase;
        }
    }
    // casting operator
    operator T*()
    {
        return m_pCur;
    }
    operator T&()
    {
        ASSERT(m_pCur < m_pBase + m_Size);
        return *m_pCur;
    }
    operator void*()
    {
        return m_pCur;
    }
    T& operator*()
    {
        ASSERT(m_pCur < m_pBase + m_Size);
        return *m_pCur;
    }
    // increment/decrement
    T* operator+(UINT Inc)
    {
        ASSERT(m_pBase + m_Size > m_pCur + Inc);
        return (m_pBase + Inc);
    }
    T* operator-(UINT Dec)
    {
        ASSERT(m_pBase >= m_pCur - Dec);
        m_pCur -= Dec;
        return m_pCur;
    }
    //prefix
    T* operator++()
    {
        ASSERT(m_pBase + m_Size > m_pCur - 1);
        return ++m_pCur;
    }
    //postfix
    T* operator++(int inc)
    {
        pCur
        ASSERT(m_pBase + m_Size > m_pCur);
        return m_pCur++;
    }
    //prefix
    T* operator--()
    {
        ASSERT(m_pCur > m_pBase);
        return --m_pCur;
    }
    //postfix
    T* operator--(int inc)
    {
        ASSERT(m_pCur > m_pBase);
        return m_pCur--;
    }
    T** operator&()
    {
        return &m_pBase;
    }
    // subscripting
    T& operator[](UINT Index)
    {
        ASSERT(Index < m_Size);
        return m_pBase[Index];
    }
    void Attach(T* pT, UINT Size = 1)
    {
        ASSERT(!m_pBase);
        m_pBase = pT;
        m_pCur = m_pBase;
        m_Size = Size;
    }
    void Detach()
    {
        m_pBase = NULL;
    }
    UINT GetSize()
    {
        return m_Size;
    }

private:
    T*   m_pBase;
    T*   m_pCur;
    UINT    m_Size;
};

template<class T>
class SafePtr
{
public:
    SafePtr(T* p)
    {
        __p = p;
    }
    SafePtr()
    {
        __p = NULL;
    }
    ~SafePtr()
    {
        if (__p)
        {
            delete __p;
        }
    }
    void Attach(T* p)
    {
        ASSERT(NULL == __p);
        __p = p;
    }
    void Detach()
    {
        __p = NULL;
    }
    T* operator->()
    {
        ASSERT(__p);

        return __p;
    }
    T& operator*()
    {
        ASSERT(__p);

        return *__p;
    }
    operator T*()
    {
        return __p;
    }
    operator T&()
    {
        ASSERT(__p);
        return *__p;
    }

private:
    T*  __p;

};



class CPropPageProvider;

class CPropSheetData
{
public:
    CPropSheetData();
    ~CPropSheetData();
    virtual BOOL Create(HINSTANCE hInst, HWND hwndParent, UINT MaxPages, LONG_PTR lConsoleHandle = 0);
    BOOL InsertPage(HPROPSHEETPAGE hPage, int Index = -1);
    INT_PTR DoSheet()
    {
        return ::PropertySheet(&m_psh);
    }
    HWND GetWindowHandle()
    {
        return m_hWnd;
    }
    void PageCreateNotify(HWND hWnd);
    void PageDestroyNotify(HWND hWnd);
    PROPSHEETHEADER m_psh;
    BOOL PropertyChangeNotify(LPARAM lParam);
    void AddProvider(CPropPageProvider* pProvider)
    {
        m_listProvider.AddTail(pProvider);
    }

protected:
    UINT    m_MaxPages;
    LONG_PTR m_lConsoleHandle;
    HWND    m_hWnd;

private:
    CList<CPropPageProvider*, CPropPageProvider*> m_listProvider;
};


class CDialog
{
public:
    CDialog(int TemplateId) : m_hDlg(NULL), m_TemplateId(TemplateId)
    {}
    virtual ~CDialog()
    {}
    static INT_PTR CALLBACK DialogWndProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR DoModal(HWND hwndParent, LPARAM lParam )
    {
        return DialogBoxParam(g_hInstance, MAKEINTRESOURCE(m_TemplateId), hwndParent, DialogWndProc, lParam);
    }
    void DoModaless(HWND hwndParent, LPARAM lParam)
    {
        m_hDlg = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(m_TemplateId), hwndParent, DialogWndProc, lParam);
    }
    virtual BOOL OnInitDialog()
    {
        return TRUE;
    }
    virtual void OnCommand(WPARAM wParam, LPARAM lParam)
    {
        UNREFERENCED_PARAMETER(wParam);
        UNREFERENCED_PARAMETER(lParam);
    }
    virtual BOOL OnNotify(LPNMHDR pnmhdr)
    {
        UNREFERENCED_PARAMETER(pnmhdr);

        return FALSE;
    }
    virtual BOOL OnDestroy()
    {
        return FALSE;
    }
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo)
    {
        UNREFERENCED_PARAMETER(pHelpInfo);

        return FALSE;
    }
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos)
    {
        UNREFERENCED_PARAMETER(hWnd);
        UNREFERENCED_PARAMETER(xPos);
        UNREFERENCED_PARAMETER(yPos);

        return FALSE;
    }

    HWND GetControl(int idControl)
    {
        return GetDlgItem(m_hDlg, idControl);
    }
    operator HWND()
    {
        return m_hDlg;
    }
    HWND    m_hDlg;

private:
    int     m_TemplateId;
};

#endif  // __UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\diamond.c ===
#include <windows.h>
#include <lzexpand.h>
#include <fcntl.h>

/************************************************************************\
*
* NOTE!!!!
*
* While the 'Diamond' interfaced functions defined in this file are
* multi thread safe, EACH THREAD MUST ONLY HAVE ONE DIAMOND FILE
* OPEN AT A TIME!  (ie. You can not nest InitDiamond()/TermDiamond()
* pairs in one thread of execution.)
*
\************************************************************************/

//
// diamond headers
//
#include <diamondd.h>
#include "mydiam.h"

HINSTANCE hCabinet;
DWORD cCabinetLoad;
typedef HFDI (DIAMONDAPI * tFDICreate) (PFNALLOC pfnalloc,
                                        PFNFREE  pfnfree,
                                        PFNOPEN  pfnopen,
                                        PFNREAD  pfnread,
                                        PFNWRITE pfnwrite,
                                        PFNCLOSE pfnclose,
                                        PFNSEEK  pfnseek,
                                        int      cpuType,
                                        PERF     perf);

typedef BOOL (DIAMONDAPI * tFDIIsCabinet)(HFDI            hfdi,
                                          INT_PTR         hf,
                                          PFDICABINETINFO pfdici);

typedef BOOL (DIAMONDAPI * tFDICopy)(HFDI          hfdi,
                                     char FAR     *pszCabinet,
                                     char FAR     *pszCabPath,
                                     int           flags,
                                     PFNFDINOTIFY  pfnfdin,
                                     PFNFDIDECRYPT pfnfdid,
                                     void FAR     *pvUser);

typedef BOOL (DIAMONDAPI * tFDIDestroy)(HFDI hfdi);

tFDICreate    pFDICreate;
tFDIIsCabinet pFDIIsCabinet;
tFDICopy      pFDICopy;
tFDIDestroy   pFDIDestroy;

// this function is the same as CharNextA, available locally
extern LPSTR WINAPI VerCharNextA(LPCSTR lpCurrentChar);

INT CopyDateTimeStamp(INT_PTR doshFrom, INT_PTR doshTo)
{
    FILETIME lpCreationTime, lpLastAccessTime, lpLastWriteTime;

    if (!GetFileTime((HANDLE) doshFrom, &lpCreationTime, &lpLastAccessTime,
                     &lpLastWriteTime)) {
        return ((INT)LZERROR_BADINHANDLE);
    }
    if (!SetFileTime((HANDLE) doshTo, &lpCreationTime, &lpLastAccessTime,
                     &lpLastWriteTime)) {
        return ((INT)LZERROR_BADINHANDLE);
    }

    return (TRUE);
}

INT_PTR
DIAMONDAPI
SpdFdiOpen(
          IN PSTR FileName,
          IN int  oflag,
          IN int  pmode
          );

int
DIAMONDAPI
SpdFdiClose(
           IN INT_PTR Handle
           );

typedef struct _DIAMOND_INFO {

    //
    // A read handle to the source file.
    //
    INT_PTR SourceFileHandle;

    //
    // File names.
    //
    PSTR SourceFileName;
    PSTR TargetFileName;

    //
    // Flag indicating whether to rename the target file.
    //
    BOOL RenameTargetFile;

    //
    // Pointer to LZ information structure.
    // We'll fill in some of the fields to fool expand.
    //
    PLZINFO pLZI;

} DIAMOND_INFO, *PDIAMOND_INFO;


PSTR
StringRevChar(
             IN PSTR String,
             IN CHAR Char
             )
{
    //
    // Although not the most efficient possible algoeithm in each case,
    // this algorithm is correct for unicode, sbcs, or dbcs.
    //
    PCHAR Occurrence,Next;

    //
    // Check each character in the string and remember
    // the most recently encountered occurrence of the desired char.
    //
    for (Occurrence=NULL,Next=VerCharNextA(String); *String; ) {

        if (!memcmp(String,&Char,(int)((PUCHAR)Next-(PUCHAR)String))) {
            Occurrence = String;
        }

        String = Next;
        Next = VerCharNextA(Next);
    }

    //
    // Return address of final occurrence of the character
    // (will be NULL if not found at all).
    //
    return (Occurrence);
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
                     IN FDINOTIFICATIONTYPE Operation,
                     IN PFDINOTIFICATION    Parameters
                     )
{
    switch (Operation) {

        case fdintCABINET_INFO:
        case fdintNEXT_CABINET:
        case fdintPARTIAL_FILE:
        case fdintENUMERATE:

            //
            // Cabinet management functions which we don't use.
            // Return success.
            //
            return (0);

        case fdintCOPY_FILE:

            //
            // Diamond is asking us whether we want to copy the file.
            //
            {
                PDIAMOND_INFO Info = (PDIAMOND_INFO)Parameters->pv;
                HFILE h;

                //
                // If we need to rename the target file, do that here.
                // The name stored in the cabinet file will be used as
                // the uncompressed name.
                //
                if (Info->RenameTargetFile) {

                    PSTR p,q;

                    //
                    // Find the start of the filename part of the target.
                    //
                    if (p = StringRevChar(Info->TargetFileName,'\\')) {
                        p++;
                    } else {
                        p = Info->TargetFileName;
                    }

                    //
                    // Find the start of the filename part of the name in the cabinet.
                    //
                    if (q = StringRevChar(Parameters->psz1,'\\')) {
                        q++;
                    } else {
                        q = Parameters->psz1;
                    }

                    //
                    // Copy the filename part of the name in the cabinet over
                    // the filename part of the name in the target spec.
                    //
                    lstrcpyA(p,q);
                }

                {
                    // Check they're not the same file

                    CHAR Source[MAX_PATH];
                    CHAR Target[MAX_PATH];
                    PSTR FileName;
                    DWORD PathLenSource;
                    DWORD PathLenTarget;

                    PathLenSource = GetFullPathNameA(Info->SourceFileName,
                                                     MAX_PATH,
                                                     Source,
                                                     &FileName);
                    PathLenTarget = GetFullPathNameA(Info->TargetFileName,
                                                     MAX_PATH,
                                                     Target,
                                                     &FileName);

                    if (PathLenSource == 0 || PathLenSource >= MAX_PATH ||
                        PathLenTarget == 0 || PathLenTarget >= MAX_PATH ||
                        lstrcmpiA(Source, Target) == 0) {
                        return 0;
                    }
                }

                //
                // Remember the uncompressed size and open the file.
                // Returns -1 if an error occurs opening the file.
                //
                Info->pLZI->cblOutSize = Parameters->cb;
                h = _lcreat(Info->TargetFileName,0);
                if (h == HFILE_ERROR) {
                    DiamondLastIoError = LZERROR_BADOUTHANDLE;
                    return (-1);
                }
                return (h);
            }

        case fdintCLOSE_FILE_INFO:

            //
            // Diamond is done with the target file and wants us to close it.
            // (ie, this is the counterpart to fdint_COPY_FILE).
            //
            {
                PDIAMOND_INFO Info = (PDIAMOND_INFO)Parameters->pv;

                CopyDateTimeStamp(Info->SourceFileHandle,Parameters->hf);
                _lclose((HFILE)Parameters->hf);
            }
            return (TRUE);

         default:

            //
            // invalid operation
            //
            return(-1);
    }
}



PVOID
DIAMONDAPI
SpdFdiAlloc(
           IN ULONG NumberOfBytes
           )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return ((PVOID)LocalAlloc(LMEM_FIXED,NumberOfBytes));
}


VOID
DIAMONDAPI
SpdFdiFree(
          IN PVOID Block
          )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
          IN PSTR FileName,
          IN int  oflag,
          IN int  pmode
          )

/*++

Routine Description:

    Callback used by FDICopy to open files.

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HFILE h;
    int OpenMode;

    if (oflag & _O_WRONLY) {
        OpenMode = OF_WRITE;
    } else {
        if (oflag & _O_RDWR) {
            OpenMode = OF_READWRITE;
        } else {
            OpenMode = OF_READ;
        }
    }

    h = _lopen(FileName,OpenMode | OF_SHARE_DENY_WRITE);

    if (h == HFILE_ERROR) {
        DiamondLastIoError = LZERROR_BADINHANDLE;
        return (-1);
    }

    return ((INT_PTR)h);
}


UINT
DIAMONDAPI
SpdFdiRead(
          IN  INT_PTR Handle,
          OUT PVOID pv,
          IN  UINT  ByteCount
          )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    rc = _lread((HFILE)Handle,pv,ByteCount);

    if (rc == HFILE_ERROR) {
        rc = (UINT)(-1);
        DiamondLastIoError = LZERROR_READ;
    }

    return (rc);
}


UINT
DIAMONDAPI
SpdFdiWrite(
           IN INT_PTR Handle,
           IN PVOID pv,
           IN UINT  ByteCount
           )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    rc = _lwrite((HFILE)Handle,pv,ByteCount);

    if (rc == HFILE_ERROR) {

        DiamondLastIoError = (GetLastError() == ERROR_DISK_FULL) ? LZERROR_WRITE : LZERROR_BADOUTHANDLE;

    } else {

        if (rc != ByteCount) {
            //
            // let caller interpret return value but record last error just in case
            //
            DiamondLastIoError = LZERROR_WRITE;
        }
    }

    return (rc);
}


int
DIAMONDAPI
SpdFdiClose(
           IN INT_PTR Handle
           )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    _lclose((HFILE)Handle);
    return (0);
}


LONG
DIAMONDAPI
SpdFdiSeek(
          IN INT_PTR Handle,
          IN long Distance,
          IN int  SeekType
          )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;

    rc = _llseek((HFILE)Handle,Distance,SeekType);

    if (rc == HFILE_ERROR) {
        DiamondLastIoError = LZERROR_BADINHANDLE;
        rc = -1L;
    }

    return (rc);
}

//
// this function is linked in from ntdll
//
extern int sprintf(LPSTR, LPCSTR, ...);

INT
ExpandDiamondFile(
                 IN  PSTR       SourceFileName,      // Note ASCII
                 IN  PTSTR      TargetFileNameT,
                 IN  BOOL       RenameTarget,
                 OUT PLZINFO    pLZI
                 )
{
    BOOL b;
    INT rc;
    INT_PTR h;
    DIAMOND_INFO DiamondInfo;
    CHAR TargetFileName[MAX_PATH];

    sprintf(TargetFileName, "%ls", TargetFileNameT);

    if (!FdiContext) {
        return (LZERROR_BADVALUE);
    }

    DiamondLastIoError = TRUE;

    //
    // Get a handle to the source to use to
    // copy the date and time stamp.
    //
    h = SpdFdiOpen(SourceFileName,_O_RDONLY,0);
    if (h == -1) {
        return (LZERROR_BADINHANDLE);
    }

    pLZI->cblInSize = GetFileSize((HANDLE)h,NULL);
    if (pLZI->cblInSize == -1) {
        SpdFdiClose(h);
        return (LZERROR_BADINHANDLE);
    }

    DiamondInfo.SourceFileHandle = h;
    DiamondInfo.SourceFileName = SourceFileName;
    DiamondInfo.TargetFileName = TargetFileName;
    DiamondInfo.RenameTargetFile = RenameTarget;
    DiamondInfo.pLZI = pLZI;

    b = pFDICopy(
                FdiContext,
                SourceFileName,             // pass the whole path as the name
                "",                         // don't bother with the path part
                0,                          // flags
                DiamondNotifyFunction,
                NULL,                       // no decryption
                &DiamondInfo
                );

    if (b) {

        rc = TRUE;

    } else {

        switch (FdiError.erfOper) {

            case FDIERROR_CORRUPT_CABINET:
            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_BAD_COMPR_TYPE:
                rc = LZERROR_READ;              // causes SID_FORMAT_ERROR message
                break;

            case FDIERROR_ALLOC_FAIL:
                rc = LZERROR_GLOBALLOC;
                break;

            case FDIERROR_TARGET_FILE:
            case FDIERROR_USER_ABORT:
                rc = DiamondLastIoError;
                break;

            default:
                //
                // The rest of the errors are not handled specially.
                //
                rc = LZERROR_BADVALUE;
                break;
        }

        //
        // Remove the partial target file.
        //
        DeleteFileA(TargetFileName);
    }

    SpdFdiClose(h);

    return (rc);
}


BOOL
IsDiamondFile(
             IN PSTR FileName
             )
{
    FDICABINETINFO CabinetInfo;
    BOOL b;
    INT_PTR h;

    if (!FdiContext) {
        return (FALSE);
    }

    //
    // Open the file such that the handle is valid for use
    // in the diamond context (ie, seek, read routines above).
    //
    h = SpdFdiOpen(FileName,_O_RDONLY,0);
    if (h == -1) {
        return (FALSE);
    }

    b = pFDIIsCabinet(FdiContext,h,&CabinetInfo);

    SpdFdiClose(h);

    return (b);
}


DWORD
InitDiamond(
           VOID
           )
{
    PDIAMOND_CONTEXT pdcx;

    if (!GotDmdTlsSlot())
        return VIF_OUTOFMEMORY;

    if (GotDmdContext())
        return VIF_OUTOFMEMORY;

    pdcx = LocalAlloc(LPTR, sizeof(DIAMOND_CONTEXT));

    if (pdcx == NULL || !TlsSetValue(itlsDiamondContext, pdcx)) {
        /*
         * For some unknown reason, we can't associate
         * our thread storage with the slot, so free
         * it and say we never got one.
         */

        if (pdcx) {
            LocalFree(pdcx);
        }
        return VIF_OUTOFMEMORY;
    }

    if (!cCabinetLoad) {
        hCabinet = LoadLibraryW(L"CABINET.DLL");
        if (!hCabinet) {
            return (VIF_CANNOTLOADCABINET);
        }
        pFDICreate    = (tFDICreate)    GetProcAddress(hCabinet, "FDICreate");
        pFDIDestroy   = (tFDIDestroy)   GetProcAddress(hCabinet, "FDIDestroy");
        pFDIIsCabinet = (tFDIIsCabinet) GetProcAddress(hCabinet, "FDIIsCabinet");
        pFDICopy      = (tFDICopy)      GetProcAddress(hCabinet, "FDICopy");

        if (!(pFDICreate && pFDIDestroy && pFDIIsCabinet && pFDICopy)) {
            FreeLibrary(hCabinet);
            return (VIF_CANNOTLOADCABINET);
        }

        if (InterlockedExchangeAdd(&cCabinetLoad, 1) != 0) {
            // Multiple threads are attempting to LoadLib
            // Free one here.
            FreeLibrary(hCabinet);
        }
    }

    SetFdiContext( pFDICreate(
                             SpdFdiAlloc,
                             SpdFdiFree,
                             SpdFdiOpen,
                             SpdFdiRead,
                             SpdFdiWrite,
                             SpdFdiClose,
                             SpdFdiSeek,
                             cpuUNKNOWN,
                             &FdiError
                             ));

    return ((FdiContext == NULL) ? VIF_CANNOTLOADCABINET : 0);
}


VOID
TermDiamond(
           VOID
           )
{
    if (!GotDmdTlsSlot() || !GotDmdContext())
        return;

    if (FdiContext) {
        pFDIDestroy(FdiContext);
        SetFdiContext( NULL );
    }

    LocalFree( TlsGetValue(itlsDiamondContext) );
    TlsSetValue(itlsDiamondContext, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\tswizard.h ===
#ifndef __TSWIZARD_H__
#define __TSWIZARD_H__

/*++

Copyright (C) Microsoft Corporation

Module Name:

    tswizard.h

Abstract:

    header file for tswizard.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

typedef enum tagFixCommand
{
    FIX_COMMAND_DONOTHING = 0,
    FIX_COMMAND_UPGRADEDRIVERS,
    FIX_COMMAND_REINSTALL,
    FIX_COMMAND_ENABLEDEVICE,
    FIX_COMMAND_STARTDEVICE,
    FIX_COMMAND_RESTARTCOMPUTER,
    FIX_COMMAND_DRIVERBLOCKED,
    FIX_COMMAND_TROUBLESHOOTER
} FIX_COMMAND, *PFIX_COMMAND;

typedef struct tagCMProblemInfo
{
    BOOL    Query;      // true if we have something to fix the problem
    FIX_COMMAND FixCommand; // command to fix the problem
    int     idInstFirst;    // instruction text string id
    int     idInstCount;    // how many instruction string id
    int     idFixit;        // fix it string id
}CMPROBLEM_INFO, *PCMPROBLEM_INFO;

class CProblemAgent
{
public:
    CProblemAgent(CDevice* pDevice, ULONG Problem, BOOL SeparateProcess);
    ~CProblemAgent()
    {}
    DWORD InstructionText(LPTSTR Buffer, DWORD BufferSize);
    DWORD FixitText(LPTSTR Buffer, DWORD BufferSize);
    BOOL FixIt(HWND hwndOwner);
    BOOL UpgradeDriver(HWND hwndOwner, CDevice* pDevice);
    BOOL Reinstall(HWND hwndOwner, CDevice* pDevice);
    BOOL RestartComputer(HWND hwndOwner, CDevice* pDevice);
    BOOL EnableDevice(HWND hwndOwner, CDevice* pDevice);
    BOOL FixDriverBlocked(HWND hwndOwner, CDevice* pDevice, LPTSTR ChmFile, ULONG ChmFileSize, LPTSTR HtmlTroubleShooter, ULONG HtmlTroubleShooterSize);
    BOOL StartTroubleShooter(HWND hwndOwner, CDevice *pDevice, LPTSTR ChmFile, LPTSTR HtmlTroubleShooter);
    BOOL GetTroubleShooter(CDevice* pDevice, LPTSTR ChmFile, ULONG ChmFileSize, LPTSTR HtmlTroubleShooter, ULONG HtmlTroubleShooterSize);
    void LaunchHtlmTroubleShooter(HWND hwndOwner, LPTSTR ChmFile, LPTSTR HtmlTroubleShooter);

protected:
    CDevice*    m_pDevice;
    ULONG       m_Problem;
    int         m_idInstFirst;
    int         m_idInstCount;
    int         m_idFixit;
    BOOL        m_SeparateProcess;
    FIX_COMMAND m_FixCommand;
};

class CWizard98
{
public:
    CWizard98(HWND hwndParent, UINT MaxPages = 32);
    ~CWizard98()
    {}
    INT_PTR DoSheet() {

        return ::PropertySheet(&m_psh);
    }

    void InsertPage(HPROPSHEETPAGE hPage) {

        if (hPage && (m_psh.nPages < m_MaxPages)) {

            m_psh.phpage[m_psh.nPages++] = hPage;
        }
    }

    static INT CALLBACK WizardCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);

    PROPSHEETHEADER m_psh;

private:
    UINT m_MaxPages;
};

#endif  // #ifndef  __TSWIZARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\filever.c ===
/***************************************************************************
 *  FILERES.C
 *
 *              File resource extraction routines.
 *
 ***************************************************************************/
//
//  REARCHITECT - GetVerInfoSize plays tricks and tells the caller to allocate
//  some extra slop at the end of the buffer in case we need to thunk all
//  the strings to ANSI.  The bug is that it only tells it to allocate
//  one extra ANSI char (== BYTE) for each Unicode char.  This is not correct
//  in the DBCS case (since one Unicode char can equal a two byte DBCS char)
//
//  We should change GetVerInfoSize return the Unicode size * 2 (instead
//  of (Unicode size * 1.5) and then change VerQueryInfoA to also use the
//  * 2 computation instead of * 1.5 (== x + x/2)
//
//  23-May-1996 JonPa
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "verpriv.h"
#include <memory.h>

#define DWORDUP(x) (((x)+3)&~03)

typedef struct tagVERBLOCK {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    WCHAR szKey[1];
} VERBLOCK ;

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


typedef struct tagVERBLOCK16 {
    WORD wTotLen;
    WORD wValLen;
    CHAR szKey[1];
} VERBLOCK16 ;

typedef struct tagVERHEAD16 {
    WORD wTotLen;
    WORD wValLen;
    CHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;      // same as win31
} VERHEAD16 ;

DWORD VER2_SIG='X2EF';


extern WCHAR szTrans[];

// function resides in this file
extern LPSTR WINAPI VerCharNextA(LPCSTR lpCurrentChar);

/* ----- Functions ----- */
DWORD
MyExtractVersionResource16W (
    LPCWSTR  lpwstrFilename,
    LPHANDLE hVerRes
    )
{
    DWORD dwTemp = 0;
    DWORD (__stdcall *pExtractVersionResource16W)(LPCWSTR, LPHANDLE);
    HINSTANCE hShell32 = LoadLibraryW(L"shell32.dll");

    if (hShell32) {
        pExtractVersionResource16W = (DWORD(__stdcall *)(LPCWSTR, LPHANDLE))
                                     GetProcAddress(hShell32, "ExtractVersionResource16W");
        if (pExtractVersionResource16W) {
            dwTemp = pExtractVersionResource16W( lpwstrFilename, hVerRes );
        } else {
            dwTemp = 0;
        }
        FreeLibrary(hShell32);
    }
    return dwTemp;
}


/* GetFileVersionInfoSize
 * Gets the size of the version information; notice this is quick
 * and dirty, and the handle is just the offset
 *
 * Returns size of version info in bytes
 * lpwstrFilename is the name of the file to get version information from
 * lpdwHandle is outdated for the Win32 api and is set to zero.
 */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
                       LPCWSTR lpwstrFilename,
                       LPDWORD lpdwHandle
                       )
{
    DWORD dwTemp;
    VERHEAD *pVerHead;
    HANDLE hMod;
    HANDLE hVerRes;
    HANDLE h;
    DWORD dwError;

    if (lpdwHandle != NULL)
        *lpdwHandle = 0;

    dwTemp = SetErrorMode(SEM_FAILCRITICALERRORS);
    hMod = LoadLibraryEx(lpwstrFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);
    SetErrorMode(dwTemp);

    if (!hMod && GetLastError() == ERROR_FILE_NOT_FOUND)
        return FALSE;

    pVerHead = NULL;
    if (!hMod) {
        hVerRes = NULL;
        __try
        {
            dwTemp = MyExtractVersionResource16W( lpwstrFilename, &hVerRes );

            if (!dwTemp) {
                dwError = ERROR_RESOURCE_DATA_NOT_FOUND;
                __leave;
            }

            if (!(pVerHead = GlobalLock(hVerRes)) || (pVerHead->wTotLen > dwTemp)) {
                dwError = ERROR_INVALID_DATA;
                dwTemp = 0;
                __leave;
            }

            dwError = ERROR_SUCCESS;

        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0 ;
        }

        if (pVerHead)
            GlobalUnlock(hVerRes);

        if (hVerRes)
            GlobalFree(hVerRes);

        SetLastError(dwError);

        return dwTemp ? dwTemp * 3 : 0;     // 3x == 1x for ansi input, 2x for unicode convert space
    }

    __try {
        dwError = ERROR_SUCCESS;
        if ((hVerRes = FindResource(hMod, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO)) == NULL) {
            dwError = ERROR_RESOURCE_TYPE_NOT_FOUND;
            dwTemp = 0;
            __leave;
        }

        if ((dwTemp=SizeofResource(hMod, hVerRes)) == 0) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        if ((h = LoadResource(hMod, hVerRes)) == NULL) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        if ((pVerHead = (VERHEAD*)LockResource(h)) == NULL) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        if ((DWORD)pVerHead->wTotLen > dwTemp) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        dwTemp = (DWORD)pVerHead->wTotLen;

        dwTemp = DWORDUP(dwTemp);

        if (pVerHead->vsf.dwSignature != VS_FFI_SIGNATURE) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
        dwTemp = 0;
    }

    if (pVerHead)
        UnlockResource(h);

    FreeLibrary(hMod);

    SetLastError(dwError);

    //
    // dwTemp should be evenly divisible by two since not single
    // byte components at all (also DWORDUP for safety above):
    // alloc space for ansi components
    //

    //
    // Keep space for DBCS chars.
    //
    return dwTemp ? (dwTemp * 2) + sizeof(VER2_SIG) : 0;
}


/* GetFileVersionInfo
 * Gets the version information; fills in the structure up to
 * the size specified by the dwLen parameter (since Control Panel
 * only cares about the version numbers, it won't even call
 * GetFileVersionInfoSize).  Notice this is quick and dirty
 * version, and dwHandle is just the offset (or NULL).
 *
 * lpwstrFilename is the name of the file to get version information from.
 * dwHandle is the handle filled in from the GetFileVersionInfoSize call.
 * dwLen is the length of the buffer to fill.
 * lpData is the buffer to fill.
 */
BOOL
APIENTRY
GetFileVersionInfoW(
                   LPCWSTR lpwstrFilename,
                   DWORD dwHandle,
                   DWORD dwLen,
                   LPVOID lpData
                   )
{
    VERHEAD *pVerHead;
    VERHEAD16 *pVerHead16;
    HANDLE hMod;
    HANDLE hVerRes;
    HANDLE h;
    UINT   dwTemp;
    BOOL bTruncate, rc;
    DWORD dwError;

    UNREFERENCED_PARAMETER(dwHandle);

    // Check minimum size to prevent access violations

    // WORD for the VERHEAD wTotLen field
    if (dwLen < sizeof(WORD)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }

    dwTemp = SetErrorMode(SEM_FAILCRITICALERRORS);
    hMod = LoadLibraryEx(lpwstrFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);
    SetErrorMode(dwTemp);

    if (!hMod && GetLastError() == ERROR_FILE_NOT_FOUND)
        return FALSE;

    if (hMod == NULL) {

        // Allow 16bit stuff

        __try {
            dwTemp = MyExtractVersionResource16W( lpwstrFilename, &hVerRes );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            dwTemp = 0 ;
        }

        if (!dwTemp) {
            SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
            return (FALSE);
        }

        if (!(pVerHead16 = GlobalLock(hVerRes))) {

            SetLastError(ERROR_INVALID_DATA);
            GlobalFree(hVerRes);
            return (FALSE);
        }

        __try {
            dwTemp = (DWORD)pVerHead16->wTotLen;

            if (dwTemp > dwLen / 3) {

                //
                // We are forced to truncate.
                //
                dwTemp = dwLen/3;

                bTruncate = TRUE;

            } else {

                bTruncate = FALSE;
            }

            // Now mem copy only the real size of the resource.  (We alloced
            // extra space for unicode)

            memcpy((PVOID)lpData, (PVOID)pVerHead16, dwTemp);
            if (bTruncate) {

                // If we truncated above, then we must set the new
                // size of the block so that we don't overtraverse.

                ((VERHEAD16*)lpData)->wTotLen = (WORD)dwTemp;
            }
            rc = TRUE;
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            rc = FALSE;
        }

        GlobalUnlock(hVerRes);
        GlobalFree(hVerRes);
        
        SetLastError(rc ? ERROR_INVALID_DATA : ERROR_SUCCESS);

        return rc;
    }

    rc = TRUE;
    dwError = ERROR_SUCCESS;
    if (((hVerRes = FindResource(hMod, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO)) == NULL) ||
        ((pVerHead = LoadResource(hMod, hVerRes)) == NULL)) 
    {
        dwError = ERROR_RESOURCE_TYPE_NOT_FOUND;
        rc = FALSE;
    } else {
        __try {
            dwTemp = (DWORD)pVerHead->wTotLen;

            if (dwTemp > (dwLen - sizeof(VER2_SIG)) / 2) {

                // We are forced to truncate.

                //
                // dwLen = UnicodeBuffer + AnsiBuffer.
                //
                // if we try to "memcpy" with "(dwLen/3) * 2" size, pVerHead
                // might not have such a big data...
                //
                dwTemp = (dwLen - sizeof(VER2_SIG)) / 2;

                bTruncate = TRUE;
            } else {
                bTruncate = FALSE;
            }

            // Now mem copy only the real size of the resource.  (We alloced
            // extra space for ansi)

            memcpy((PVOID)lpData, (PVOID)pVerHead, dwTemp);

            // Store a sig between the raw data and the ANSI translation area so we know
            // how much space we have available in VerQuery for ANSI translation.
            *((DWORD UNALIGNED *)((ULONG_PTR)lpData + dwTemp)) = VER2_SIG;
            if (bTruncate) {
                // If we truncated above, then we must set the new
                // size of the block so that we don't overtraverse.

                ((VERHEAD*)lpData)->wTotLen = (WORD)dwTemp;
            }

            rc = TRUE;
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            dwError = ERROR_INVALID_DATA;
            rc = FALSE;
        }
    }

    FreeLibrary(hMod);

    SetLastError(dwError);

    return (rc);
}


BOOL
VerpQueryValue16(
                const LPVOID pb,
                LPVOID lpSubBlockX,
                INT    nIndex,
                LPVOID *lplpKey,
                LPVOID *lplpBuffer,
                PUINT puLen,
                BOOL    bUnicodeNeeded
                )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    LPSTR lpSubBlock;
    LPSTR lpSubBlockOrg;
    NTSTATUS Status;
    UINT uLen;

    VERBLOCK16 *pBlock = (VERBLOCK16*)pb;
    LPSTR lpStart, lpEndBlock, lpEndSubBlock;
    CHAR cTemp, cEndBlock;
    BOOL bLastSpec;
    DWORD dwHeadLen, dwTotBlockLen;
    INT  nCmp;
    DWORD LastError = ERROR_SUCCESS;

    BOOL bThunkNeeded;

    /*
     * If needs unicode, then we must thunk the input parameter
     * to ansi.  If it's ansi already, we make a copy so we can
     * modify it.
     */

    if (bUnicodeNeeded) {

        //
        // Thunk is not needed if lpSubBlockX == \VarFileInfo\Translation
        // or if lpSubBlockX == \
        //
        bThunkNeeded = (BOOL)((*(LPTSTR)lpSubBlockX != 0) &&
                              (lstrcmp(lpSubBlockX, TEXT("\\")) != 0) &&
                              (lstrcmpi(lpSubBlockX, szTrans) != 0));

        RtlInitUnicodeString(&UnicodeString, lpSubBlockX);
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        if (!NT_SUCCESS(Status)) {
            SetLastError(Status);
            return FALSE;
        }
        lpSubBlock = AnsiString.Buffer;

    } else {
        lpSubBlockOrg = (LPSTR)LocalAlloc(LPTR,(lstrlenA(lpSubBlockX)+1)*sizeof(CHAR));
        if (lpSubBlockOrg == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        lstrcpyA(lpSubBlockOrg,lpSubBlockX);
        lpSubBlock = lpSubBlockOrg;
    }

    if (!puLen)
        puLen = &uLen;

    *puLen = 0;

    /* Ensure that the total length is less than 32K but greater than the
     * size of a block header; we will assume that the size of pBlock is at
     * least the value of this first INT.
     */
    if ((INT)pBlock->wTotLen < sizeof(VERBLOCK16)) {
        LastError = ERROR_INVALID_DATA;
        goto Fail;
    }

    /*
     * Put a '\0' at the end of the block so that none of the lstrlen's will
     * go past then end of the block.  We will replace it before returning.
     */
    lpEndBlock = ((LPSTR)pBlock) + pBlock->wTotLen - 1;
    cEndBlock = *lpEndBlock;
    *lpEndBlock = '\0';

    bLastSpec = FALSE;

    while ((*lpSubBlock || nIndex != -1)) {
        //
        // Ignore leading '\\'s
        //
        while (*lpSubBlock == '\\')
            ++lpSubBlock;

        if ((*lpSubBlock || nIndex != -1)) {
            /* Make sure we still have some of the block left to play with
             */
            dwTotBlockLen = (DWORD)(lpEndBlock - ((LPSTR)pBlock) + 1);
            if ((INT)dwTotBlockLen<sizeof(VERBLOCK16) ||
                pBlock->wTotLen>dwTotBlockLen)

                goto NotFound;

            /* Calculate the length of the "header" (the two length WORDs plus
             * the identifying string) and skip past the value
             */

            dwHeadLen = sizeof(WORD)*2 + DWORDUP(lstrlenA(pBlock->szKey)+1)
                        + DWORDUP(pBlock->wValLen);

            if (dwHeadLen > pBlock->wTotLen)
                goto NotFound;
            lpEndSubBlock = ((LPSTR)pBlock) + pBlock->wTotLen;
            pBlock = (VERBLOCK16 FAR *)((LPSTR)pBlock+dwHeadLen);

            /* Look for the first sub-block name and terminate it
             */
            for (lpStart=lpSubBlock; *lpSubBlock && *lpSubBlock!='\\';
                lpSubBlock=VerCharNextA(lpSubBlock))
                /* find next '\\' */ ;
            cTemp = *lpSubBlock;
            *lpSubBlock = '\0';

            /* Continue while there are sub-blocks left
             * pBlock->wTotLen should always be a valid pointer here because
             * we have validated dwHeadLen above, and we validated the previous
             * value of pBlock->wTotLen before using it
             */

            nCmp = 1;
            while ((INT)pBlock->wTotLen>sizeof(VERBLOCK16) &&
                   (INT)(lpEndSubBlock-((LPSTR)pBlock))>=(INT)pBlock->wTotLen) {

                //
                // Index functionality: if we are at the end of the path
                // (cTemp == 0 set below) and nIndex is NOT -1 (index search)
                // then break on nIndex zero.  Else do normal wscicmp.
                //
                if (bLastSpec && nIndex != -1) {

                    if (!nIndex) {

                        if (lplpKey) {
                            *lplpKey = pBlock->szKey;
                        }
                        nCmp=0;

                        //
                        // Index found, set nInde to -1
                        // so that we exit this loop
                        //
                        nIndex = -1;
                        break;
                    }

                    nIndex--;

                } else {

                    //
                    // Check if the sub-block name is what we are looking for
                    //

                    if (!(nCmp=lstrcmpiA(lpStart, pBlock->szKey)))
                        break;
                }

                /* Skip to the next sub-block
                 */
                pBlock=(VERBLOCK16 FAR *)((LPSTR)pBlock+DWORDUP(pBlock->wTotLen));
            }

            /* Restore the char NULLed above and return failure if the sub-block
             * was not found
             */
            *lpSubBlock = cTemp;
            if (nCmp)
                goto NotFound;
        }
        bLastSpec = !cTemp;
    }

    /* Fill in the appropriate buffers and return success
     */
    *puLen = pBlock->wValLen;

    *lplpBuffer = (LPSTR)pBlock + 4 + DWORDUP(lstrlenA(pBlock->szKey) + 1);

    //
    // Shouldn't need zero-length value check since win31 compatible.
    //

    *lpEndBlock = cEndBlock;

    /*
     * Must free string we allocated above
     */

    if (bUnicodeNeeded) {
        RtlFreeAnsiString(&AnsiString);
    } else {
        LocalFree(lpSubBlockOrg);
    }


    /*----------------------------------------------------------------------
     * thunk the results
     *
     * Must always thunk key, always ??? value
     *
     * We have no way of knowing if the resource info is binary or strings
     * Version stuff is usually string info, so thunk.
     *
     * The best we can do is assume that everything is a string UNLESS
     * we are looking at \VarFileInfo\Translation or at \.
     *
     * This is acceptable because the documenation of VerQueryValue
     * indicates that this is used only for strings (except these cases.)
     *----------------------------------------------------------------------*/

    if (bUnicodeNeeded) {

        //
        // Do thunk only if we aren't looking for \VarFileInfo\Translation or \
        //
        if (bThunkNeeded) {

            // subtract 1 since puLen includes null
            AnsiString.Length = AnsiString.MaximumLength = (SHORT)*puLen - 1;
            AnsiString.Buffer = *lplpBuffer;

            //
            // Do the string conversion in the second half of the buffer
            // Assumes wTotLen is first filed in VERHEAD
            //
            UnicodeString.Buffer = (LPWSTR)((PBYTE)pb + DWORDUP(*((WORD*)pb)) +
                                            (DWORD)((PBYTE)*lplpBuffer - (PBYTE)pb)*2);

            UnicodeString.MaximumLength = (SHORT)(*puLen * sizeof(WCHAR));
            RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, FALSE);

            *lplpBuffer = UnicodeString.Buffer;
        }

        if (lplpKey) {

            //
            // Thunk the key
            //

            dwHeadLen = lstrlenA(*lplpKey);
            AnsiString.Length = AnsiString.MaximumLength = (SHORT)dwHeadLen;
            AnsiString.Buffer = *lplpKey;

            UnicodeString.Buffer = (LPWSTR) ((PBYTE)pb + DWORDUP(*((WORD*)pb)) +
                                             (DWORD)((PBYTE)*lplpKey - (PBYTE)pb)*2);

            UnicodeString.MaximumLength = (SHORT)((dwHeadLen+1) * sizeof(WCHAR));
            RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, FALSE);

            *lplpKey = UnicodeString.Buffer;
        }
    }

    SetLastError(LastError);

    return (TRUE);



NotFound:

    /* Restore the char we NULLed above
     */
    *lpEndBlock = cEndBlock;
    LastError = ERROR_RESOURCE_TYPE_NOT_FOUND;

Fail:

    if (bUnicodeNeeded) {
        RtlFreeAnsiString(&AnsiString);
    } else {
        LocalFree(lpSubBlockOrg);
    }

    SetLastError(LastError);

    return (FALSE);
}



/* VerpQueryValue
 * Given a pointer to a branch of a version info tree and the name of a
 * sub-branch (as in "sub\subsub\subsubsub\..."), this fills in a pointer
 * to the specified value and a word for its length.  Returns TRUE on success,
 * FALSE on failure.
 *
 * Note that a subblock name may start with a '\\', but it will be ignored.
 * To get the value of the current block, use lpSubBlock=""
 */
BOOL
APIENTRY
VerpQueryValue(
              const LPVOID pb,
              LPVOID lpSubBlockX,    // can be ansi or unicode
              INT    nIndex,
              LPVOID *lplpKey,
              LPVOID *lplpBuffer,
              PUINT puLen,
              BOOL    bUnicodeNeeded
              )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    LPWSTR lpSubBlockOrg;
    LPWSTR lpSubBlock;
    NTSTATUS Status;

    VERBLOCK *pBlock = (PVOID)pb;
    LPWSTR lpStart, lpEndBlock, lpEndSubBlock;
    WCHAR cTemp, cEndBlock;
    DWORD dwHeadLen, dwTotBlockLen;
    BOOL bLastSpec;
    INT nCmp;
    BOOL bString;
    UINT uLen;
    DWORD LastError = ERROR_SUCCESS;

    if (!puLen) {
        puLen = &uLen;
    }

    *puLen = 0;

    /*
     * Major hack: wType is 0 for win32 versions, but holds 56 ('V')
     * for win16.
     */

    if (((VERHEAD*)pb)->wType)
        return VerpQueryValue16(pb,
                                lpSubBlockX,
                                nIndex,
                                lplpKey,
                                lplpBuffer,
                                puLen,
                                bUnicodeNeeded);

    /*
     * If doesnt need unicode, then we must thunk the input parameter
     * to unicode.
     */

    if (!bUnicodeNeeded) {

        RtlInitAnsiString(&AnsiString, (LPSTR)lpSubBlockX);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

        if (!NT_SUCCESS(Status)) {
            SetLastError(Status);
            return FALSE;
        }
        lpSubBlock = UnicodeString.Buffer;

    } else {
        lpSubBlockOrg = (LPWSTR)LocalAlloc(LPTR,(lstrlen(lpSubBlockX)+1)*sizeof(WCHAR));
        if (lpSubBlockOrg == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        lstrcpy(lpSubBlockOrg,lpSubBlockX);
        lpSubBlock = lpSubBlockOrg;
    }



    /* Ensure that the total length is less than 32K but greater than the
     * size of a block header; we will assume that the size of pBlock is at
     * least the value of this first int.
     * Put a '\0' at the end of the block so that none of the wcslen's will
     * go past then end of the block.  We will replace it before returning.
     */
    if ((int)pBlock->wTotLen < sizeof(VERBLOCK)) {
        LastError = ERROR_INVALID_DATA;
        goto Fail;
    }

    lpEndBlock = (LPWSTR)((LPSTR)pBlock + pBlock->wTotLen - sizeof(WCHAR));
    cEndBlock = *lpEndBlock;
    *lpEndBlock = 0;
    bString = FALSE;
    bLastSpec = FALSE;

    while ((*lpSubBlock || nIndex != -1)) {
        //
        // Ignore leading '\\'s
        //
        while (*lpSubBlock == TEXT('\\'))
            ++lpSubBlock;

        if ((*lpSubBlock || nIndex != -1)) {
            /* Make sure we still have some of the block left to play with
             */
            dwTotBlockLen = (DWORD)((LPSTR)lpEndBlock - (LPSTR)pBlock + sizeof(WCHAR));
            if ((int)dwTotBlockLen < sizeof(VERBLOCK) ||
                pBlock->wTotLen > (WORD)dwTotBlockLen)
                goto NotFound;

            /* Calculate the length of the "header" (the two length WORDs plus
             * the data type flag plus the identifying string) and skip
             * past the value.
             */
            dwHeadLen = (DWORD)(DWORDUP(sizeof(VERBLOCK) - sizeof(WCHAR) +
                                (wcslen(pBlock->szKey) + 1) * sizeof(WCHAR)) +
                        DWORDUP(pBlock->wValLen));
            if (dwHeadLen > pBlock->wTotLen)
                goto NotFound;
            lpEndSubBlock = (LPWSTR)((LPSTR)pBlock + pBlock->wTotLen);
            pBlock = (VERBLOCK*)((LPSTR)pBlock+dwHeadLen);

            /* Look for the first sub-block name and terminate it
             */
            for (lpStart=lpSubBlock; *lpSubBlock && *lpSubBlock!=TEXT('\\');
                lpSubBlock++)
                /* find next '\\' */ ;
            cTemp = *lpSubBlock;
            *lpSubBlock = 0;

            /* Continue while there are sub-blocks left
             * pBlock->wTotLen should always be a valid pointer here because
             * we have validated dwHeadLen above, and we validated the previous
             * value of pBlock->wTotLen before using it
             */
            nCmp = 1;
            while ((int)pBlock->wTotLen > sizeof(VERBLOCK) &&
                   (int)pBlock->wTotLen <= (LPSTR)lpEndSubBlock-(LPSTR)pBlock) {

                //
                // Index functionality: if we are at the end of the path
                // (cTemp == 0 set below) and nIndex is NOT -1 (index search)
                // then break on nIndex zero.  Else do normal wscicmp.
                //
                if (bLastSpec && nIndex != -1) {

                    if (!nIndex) {

                        if (lplpKey) {
                            *lplpKey = pBlock->szKey;
                        }
                        nCmp=0;

                        //
                        // Index found, set nInde to -1
                        // so that we exit this loop
                        //
                        nIndex = -1;
                        break;
                    }

                    nIndex--;

                } else {

                    //
                    // Check if the sub-block name is what we are looking for
                    //

                    if (!(nCmp=_wcsicmp(lpStart, pBlock->szKey)))
                        break;
                }

                /* Skip to the next sub-block
                 */
                pBlock=(VERBLOCK*)((LPSTR)pBlock+DWORDUP(pBlock->wTotLen));
            }

            /* Restore the char NULLed above and return failure if the sub-block
             * was not found
             */
            *lpSubBlock = cTemp;
            if (nCmp)
                goto NotFound;
        }
        bLastSpec = !cTemp;
    }

    /* Fill in the appropriate buffers and return success
     */

    *puLen = pBlock->wValLen;

    /* Add code to handle the case of a null value.
     *
     * If zero-len, then return the pointer to the null terminator
     * of the key.  Remember that this is thunked in the ansi case.
     *
     * We can't just look at pBlock->wValLen.  Check if it really is
     * zero-len by seeing if the end of the key string is the end of the
     * block (i.e., the val string is outside of the current block).
     */

    lpStart = (LPWSTR)((LPSTR)pBlock+DWORDUP((sizeof(VERBLOCK)-sizeof(WCHAR))+
                                             (wcslen(pBlock->szKey)+1)*sizeof(WCHAR)));

    *lplpBuffer = lpStart < (LPWSTR)((LPBYTE)pBlock+pBlock->wTotLen) ?
                  lpStart :
                  (LPWSTR)(pBlock->szKey+wcslen(pBlock->szKey));

    bString = pBlock->wType;

    *lpEndBlock = cEndBlock;

    /*
     * Must free string we allocated above
     */

    if (!bUnicodeNeeded) {
        RtlFreeUnicodeString(&UnicodeString);
    } else {
        LocalFree(lpSubBlockOrg);
    }

    /*----------------------------------------------------------------------
     * thunk the results
     *
     * Must always thunk key, sometimes (if bString true) value
     *----------------------------------------------------------------------*/

    if (!bUnicodeNeeded) {

        // See if we're looking at a V1 or a V2 input block so we know how much space we
        // have for decoding the strings.
        BOOL fV2 = *(PDWORD)((PBYTE)pb + DWORDUP(*((WORD*)pb))) == VER2_SIG ? TRUE : FALSE;

        DWORD cbAnsiTranslateBuffer;
        if (fV2) {
            cbAnsiTranslateBuffer = DWORDUP(*((WORD *)pb));
        } else {
            cbAnsiTranslateBuffer = DWORDUP(*((WORD *)pb)) / 2;
        }

        if (bString && *puLen != 0) {
            DWORD cb, cb2;

            //
            // Must multiply length by two (first subtract 1 since puLen includes the null terminator)
            //
            UnicodeString.Length = UnicodeString.MaximumLength = (SHORT)((*puLen - 1) * 2);
            UnicodeString.Buffer = *lplpBuffer;

            //
            // Do the string conversion in the second half of the buffer
            // Assumes wTotLen is first filed in VERHEAD
            //

            // cb = offset in buffer to beginning of string
            cb = (DWORD)((PBYTE)*lplpBuffer - (PBYTE)pb);

            // cb2 = offset in translation area for this string
            if (fV2) {
                cb2 = cb + sizeof(VER2_SIG);
            } else {
                cb2 = cb / 2;
            }

            AnsiString.Buffer = (PBYTE)pb + DWORDUP(*((WORD*)pb)) + cb2;

            AnsiString.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&UnicodeString);
            if ( AnsiString.MaximumLength > MAXUSHORT ) {
                LastError = ERROR_INVALID_DATA;
                goto Fail;
            }

            AnsiString.MaximumLength = (USHORT)(__min((DWORD)AnsiString.MaximumLength,
                                                      (DWORD)(cbAnsiTranslateBuffer-cb2)));

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

            *lplpBuffer = AnsiString.Buffer;
            *puLen = AnsiString.Length + 1;

        }

        if (lplpKey) {

            DWORD cb, cb2;

            //
            // Thunk the key
            //
            dwHeadLen = wcslen(*lplpKey);
            UnicodeString.Length = UnicodeString.MaximumLength = (SHORT)(dwHeadLen * sizeof(WCHAR));
            UnicodeString.Buffer = *lplpKey;

            // cb2 = offset in translation area for this string

            cb = (DWORD)((PBYTE)*lplpKey - (PBYTE)pb);
            if (fV2) {
                cb2 = cb + sizeof(VER2_SIG);
            } else {
                cb2 = cb / 2;
            }

            AnsiString.Buffer = (PBYTE)pb + DWORDUP(*((WORD*)pb)) + cb2;

            AnsiString.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&UnicodeString);
            if ( AnsiString.MaximumLength > MAXUSHORT ) {
                LastError = ERROR_INVALID_DATA;
                goto Fail;
            }

            AnsiString.MaximumLength = (USHORT)(__min((DWORD)AnsiString.MaximumLength,
                                                      (DWORD)(cbAnsiTranslateBuffer-cb2)));
            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

            *lplpKey = AnsiString.Buffer;
            *puLen = AnsiString.Length+1;
        }
    }

    SetLastError(LastError);

    return (TRUE);


NotFound:
    /* Restore the char we NULLed above
     */
    *lpEndBlock = cEndBlock;
    LastError = ERROR_RESOURCE_TYPE_NOT_FOUND;

Fail:

    if (!bUnicodeNeeded) {
        RtlFreeUnicodeString(&UnicodeString);
    } else {
        LocalFree(lpSubBlockOrg);
    }

    SetLastError(LastError);

    return (FALSE);
}

//////////////////////////////////////////////////////////
//
// This is an EXACT replica of CharNextA api found in user
// it is here so that we won't have to link to user32

LPSTR WINAPI VerCharNextA(
    LPCSTR lpCurrentChar)
{
    if ((!!NLS_MB_CODE_PAGE_TAG) && IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point to string-terminator
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\snapins\devmgr\snapin\utils.cpp ===
/*++

Copyright (C) Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module implements some utilities classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"


//
// CPropSheetData implementation
//
// Every device or class has a CPropSheetData as a member.
// When m_hWnd contains a valid window handle, it indicates the device/class
// has a active property sheet. This helps us to do this:
// (1). We are sure that there is only one property sheet can be created
//  for the device/class at time in a single console no matter how many
//  IComponents(snapins, windows) are running in the same console.
//  For example, when users asks for the properties for the device/class
//  we can bring the active one to the foreground without creating a
//  new one.
// (2). We can warn the user that a removal of the device is not allowed
//  when the device has an active property sheet.
// (3). We can warn the user that there are property sheets active
//  when a "refresh" is requsted.
CPropSheetData::CPropSheetData()
{
    memset(&m_psh, 0, sizeof(m_psh));
    m_MaxPages = 0;
    m_lConsoleHandle = 0;
    m_hWnd = NULL;
}

// This function creates(or initialize) the propery sheet data header.
//
// INPUT: hInst -- the module instance handle
//    hwndParent -- parent window handle
//    MaxPages -- max pages allowed for this property sheet.
//    lConsoleHandle -- MMC property change notify handle.
//
// OUTPUT:  TRUE if succeeded.
//      FALSE if failed(mostly, memory allocation error). GetLastError
//      will report the error code.
//
BOOL
CPropSheetData::Create(
    HINSTANCE hInst,
    HWND hwndParent,
    UINT MaxPages,
    LONG_PTR lConsoleHandle
    )
{

    // nobody should try to create the property sheet while it is
    // still alive.
    ASSERT (NULL == m_hWnd);

    if (MaxPages > 64 || NULL == hInst)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // if not page array is allocated or the existing
    // array is too small, allocate a new array.
    if (!m_psh.phpage || m_MaxPages < MaxPages)
    {
        if (m_MaxPages)
        {
            ASSERT(m_psh.phpage);
            delete [] m_psh.phpage;
            m_psh.phpage = NULL;
        }
        
        m_psh.phpage = new HPROPSHEETPAGE[MaxPages];
        m_MaxPages = MaxPages;
    }
    
    // initialize the header
    m_psh.nPages = 0;
    m_psh.dwSize = sizeof(m_psh);
    m_psh.dwFlags = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    m_psh.hwndParent = hwndParent;
    m_psh.hInstance = hInst;
    m_psh.pszCaption = NULL;
    m_lConsoleHandle = lConsoleHandle;
    
    return TRUE;
}

// This function inserts the given HPROPSHEETPAGE to the
// specific location.
//
// INPUT: hPage  -- the page to be inserted.
//    Position -- the location to be inserted.
//            Position < 0, then append the page
//
// OUTPUT:  TRUE if the page is inserted successfully.
//      FALSE if the page is not inserted. GetLastError will
//      return the error code.
//
BOOL
CPropSheetData::InsertPage(
    HPROPSHEETPAGE hPage,
    int Position
    )
{
    if (NULL == hPage || (Position > 0 && (UINT)Position >= m_MaxPages))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // make sure we have space for a new page.
    if (m_psh.nPages >= m_MaxPages)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }
    
    if (Position < 0 || (UINT)Position >= m_psh.nPages)
    {
        // append the page.  This also include the very first page.
        // Most pages are appened.
        m_psh.phpage[m_psh.nPages++] = hPage;
    }
    
    else
    {
    
        ASSERT(m_psh.nPages);
    
        // move the page around so that we
        // can insert the new page to the
        // specific location.
        // At this moment, we know we have space to accomodate the
        // new page(so we can assume that &m_psh.phpage[m_psh.nPage]
        // is valid. Also, we are here because there is at least one
        // pages in the array.
        for (int i = m_psh.nPages; i > Position; i--)
            m_psh.phpage[i] = m_psh.phpage[i - 1];
        
        m_psh.phpage[Position] = hPage;
        m_psh.nPages++;
    }
    
    return TRUE;
}

//
// This function receives notification from its attached
// property pages about their window(dialog) creation
// It takes a chance to record the property sheet window handle
// which we can use to dismiss the property sheet or bring it
// to the foreground.
// INPUT:
//  hWnd -- the property page's window handle
//
// OUTPUT:
//  NONE
//
void
CPropSheetData::PageCreateNotify(HWND hWnd)
{
    ASSERT(hWnd);
    hWnd = ::GetParent(hWnd);
    
    if (!m_hWnd)
        m_hWnd = hWnd;
}

//
// This function receives notification from its attached
// property pages about their window(dialog) destroy.
// When all attached pages are gone, this function
// reset its internal states and free memory allocation
// WARNING!!!! Do not delete the object when the attached
// window handle counts reaches 0 because we can be reused --
// the reason we have a separate Create functions.
//
// INPUT:
//  hWnd -- the property page's window handle
//
// OUTPUT:
//  NONE
//
void
CPropSheetData::PageDestroyNotify(HWND hWnd)
{
    UNREFERENCED_PARAMETER(hWnd);
    
    m_hWnd = NULL;
    delete [] m_psh.phpage;
    m_psh.phpage = NULL;
    m_MaxPages = 0;
    memset(&m_psh, 0, sizeof(m_psh));
    
    if (m_lConsoleHandle)
        MMCFreeNotifyHandle(m_lConsoleHandle);

    m_lConsoleHandle = 0;
    
    if (!m_listProvider.IsEmpty())
    {
        POSITION pos = m_listProvider.GetHeadPosition();
        
        while (NULL != pos)
        {
            delete m_listProvider.GetNext(pos);
        }
        
        m_listProvider.RemoveAll();
    }
}

CPropSheetData::~CPropSheetData()
{
    if (m_lConsoleHandle)
        MMCFreeNotifyHandle(m_lConsoleHandle);

    if (!m_listProvider.IsEmpty())
    {
        POSITION pos = m_listProvider.GetHeadPosition();
        
        while (NULL != pos)
        {
            delete m_listProvider.GetNext(pos);
        }
        
        m_listProvider.RemoveAll();
    }
    
    if (m_psh.phpage)
        delete [] m_psh.phpage;
}

BOOL
CPropSheetData::PropertyChangeNotify(
    LPARAM lParam
    )
{
    if (m_lConsoleHandle)
    {
        MMCPropertyChangeNotify(m_lConsoleHandle, lParam);
        return TRUE;
    }
    
    return FALSE;
}

//
// CDialog implementation
//

INT_PTR CALLBACK
CDialog::DialogWndProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CDialog* pThis = (CDialog *) GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL Result;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pThis = (CDialog *)lParam;
        ASSERT(pThis);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
        pThis->m_hDlg = hDlg;
        Result = pThis->OnInitDialog();
        break;

    case WM_COMMAND:
        if (pThis) {
            pThis->OnCommand(wParam, lParam);
        }
        Result = FALSE;
        break;
    
    case WM_NOTIFY:
        if (pThis) {
            Result = pThis->OnNotify((LPNMHDR)lParam);
        } else {
            Result = FALSE;
        }
        break;

    case WM_DESTROY:
        if (pThis) {
            Result = pThis->OnDestroy();
        } else {
            Result = FALSE;
        }
        break;
    
    case WM_HELP:
        if (pThis) {
            pThis->OnHelp((LPHELPINFO)lParam);
        }
        Result = FALSE;
        break;
    
    case WM_CONTEXTMENU:
        if (pThis) {
            pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
        }
        Result = FALSE;
        break;

    default:
        Result = FALSE;
        break;
    }

    return Result;
}


//
// class String implementation
//
String::String()
{
    m_pData = new StringData;
    if (!m_pData)
        throw &g_MemoryException;
}

String::String(
    const String& strSrc
    )
{
    m_pData = strSrc.m_pData;
    m_pData->AddRef();
}

String::String(
    int Len
    )
{
    StringData* pNewData = new StringData;
    TCHAR* ptszNew = new TCHAR[Len + 1];
    
    if (pNewData && ptszNew)
    {
        pNewData->Len = 0;
        pNewData->ptsz = ptszNew;
        m_pData = pNewData;
    }
    
    else
    {
        delete pNewData;
        delete [] ptszNew;
        throw &g_MemoryException;
    }
}

String::String(
    LPCTSTR lptsz
    )
{
    int Len = lstrlen(lptsz);
    StringData* pNewData = new StringData;
    TCHAR* ptszNew = new TCHAR[Len + 1];
    
    if (pNewData && ptszNew)
    {
        StringCchCopy(ptszNew, Len+1, lptsz);
        pNewData->Len = Len;
        pNewData->ptsz = ptszNew;
        m_pData = pNewData;
    }
    
    else
    {
        delete pNewData;
        delete [] ptszNew;
        throw &g_MemoryException;
    }
}

void
String::Empty()
{
    if (m_pData->Len)
    {
        StringData* pNewData = new StringData;
        
        if (pNewData)
        {
            m_pData->Release();
            m_pData = pNewData;
        }
        
        else
        {
            throw &g_MemoryException;
        }
    }
}
String&
String::operator=(
    const String&  strSrc
    )
{
    // look out for aliasings !!!!
    if (this != &strSrc)
    {
        // add the reference count first before release the old one
        // in case our string data is the same as strSrc's.
        strSrc.m_pData->AddRef();
        m_pData->Release();
        m_pData = strSrc.m_pData;
    }
    
    return *this;
}

String&
String::operator=(
    LPCTSTR ptsz
    )
{
    // if we are pointing to the same string,
    // do nothing
    if (ptsz == m_pData->ptsz)
        return *this;
    
    //
    // str = NULL --> empty the string
    //
    if (!ptsz)
    {
        Empty();
        return *this;
    }
    
    // a new assignment, allocate a new string data
    StringData* pNewData = new StringData;
    int len = lstrlen(ptsz);
    TCHAR* ptszNew = new TCHAR[len + 1];
    
    if (pNewData && ptszNew)
    {
        StringCchCopy(ptszNew, len+1, ptsz);
        pNewData->Len = len;
        pNewData->ptsz = ptszNew;
        m_pData->Release();
        m_pData = pNewData;
    }
    
    else
    {
        //memory allocation failure
        delete pNewData;
        delete [] ptszNew;
        throw g_MemoryException;
    }
    
    return *this;
}

String&
String::operator+=(
    const String& strSrc
    )
{
    if (strSrc.GetLength())
    {
        int TotalLen = m_pData->Len + strSrc.GetLength();
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[TotalLen + 1];
        
        if (pNewData && ptszNew)
        {
            StringCchCopy(ptszNew, TotalLen+1, m_pData->ptsz);
            StringCchCat(ptszNew, TotalLen+1, (LPCTSTR)strSrc);
            ptszNew[TotalLen] = TEXT('\0');
            pNewData->Len = TotalLen;
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
        }
        
        else
        {
            delete pNewData;
            delete [] ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return *this;
}
String&
String::operator+=(
    LPCTSTR ptsz
    )
{
    if (ptsz)
    {
        int len = lstrlen(ptsz);
        if (len)
        {
            StringData* pNewData = new StringData;
            TCHAR* ptszNew = new TCHAR[len + m_pData->Len + 1];
            
            if (ptszNew && pNewData)
            {
                StringCchCopy(ptszNew, len + m_pData->Len + 1, m_pData->ptsz);
                StringCchCat(ptszNew, len + m_pData->Len + 1, ptsz);
                ptszNew[len + m_pData->Len] = TEXT('\0');
                pNewData->Len = len + m_pData->Len;
                pNewData->ptsz = ptszNew;
                m_pData->Release();
                m_pData = pNewData;
            }
            
            else
            {
                delete pNewData;
                delete [] ptszNew;
                throw &g_MemoryException;
            }
        }
    }
    
    return *this;
}

TCHAR&
String::operator[](
    int Index
    )
{
    ASSERT(Index < m_pData->Len);
    // make a separate copy of the string data
    TCHAR* ptszNew = new TCHAR[m_pData->Len + 1];
    StringData* pNewData = new StringData;
    
    if (ptszNew && pNewData)
    {
        StringCchCopy(ptszNew, m_pData->Len + 1, m_pData->ptsz);
        pNewData->ptsz = ptszNew;
        pNewData->Len = m_pData->Len;
        m_pData->Release();
        m_pData = pNewData;
        return ptszNew[Index];
    }
    
    else
    {
        delete pNewData;
        delete [] ptszNew;
        throw &g_MemoryException;
    }
}

String::operator LPTSTR()
{
    StringData* pNewData = new StringData;
    if (pNewData)
    {
        if (m_pData->Len)
        {
            TCHAR* ptszNew = new TCHAR[m_pData->Len + 1];
            
            if (ptszNew)
            {
                StringCchCopy(ptszNew, m_pData->Len + 1, m_pData->ptsz);
                pNewData->ptsz = ptszNew;
            }
            
            else
            {
                delete pNewData;
                throw &g_MemoryException;
            }
        }
        
        pNewData->Len = m_pData->Len;
        m_pData->Release();
        m_pData = pNewData;
        return  m_pData->ptsz;
    }
    
    else
    {
        throw &g_MemoryException ;
    }
}

//
// This is a friend function to String
// Remember that we can NOT return a reference or a pointer.
// This function must return "by-value"
String
operator+(
    const String& str1,
    const String& str2
    )
{
    int TotalLen = str1.GetLength() + str2.GetLength();
    String strThis(TotalLen);
    StringCchCopy(strThis.m_pData->ptsz, TotalLen+1, str1);
    StringCchCat(strThis.m_pData->ptsz, TotalLen+1, str2);
    strThis.m_pData->Len = TotalLen;
    return strThis;
}

BOOL
String::LoadString(
    HINSTANCE hInstance,
    int ResourceId
    )
{
    // we have no idea how long the string will be.
    // The strategy here is to allocate a stack-based buffer which
    // is large enough for most cases. If the buffer is too small,
    // we then use heap-based buffer and increment the buffer size
    // on each try.
    TCHAR tszTemp[256];
    long FinalSize, BufferSize;
    BufferSize = ARRAYLEN(tszTemp);
    TCHAR* HeapBuffer = NULL;
    
    // first try
    FinalSize = ::LoadString(hInstance, ResourceId, tszTemp, BufferSize);

    //
    // LoadString returns the size of the string it loaded, not including the
    // NULL termiated char. So if the returned len is one less then the
    // provided buffer size, our buffer is too small.
    //
    if (FinalSize < (BufferSize - 1))
    {
        // we got what we want
        HeapBuffer = tszTemp;
    }
    
    else
    {
        // the stack based buffer is too small, we have to switch to heap
        // based.
        BufferSize = ARRAYLEN(tszTemp);
    
        // should 32k chars big enough????
        while (BufferSize < 0x8000)
        {
            BufferSize += 256;
    
            // make sure there is no memory leak
            ASSERT(NULL == HeapBuffer);
    
            // allocate a new buffer
            HeapBuffer = new TCHAR[BufferSize];
            
            if (HeapBuffer)
            {
                // got a new buffer, another try...
                FinalSize = ::LoadString(hInstance, ResourceId, HeapBuffer,
                              BufferSize);

                if (FinalSize < (BufferSize - 1))
                {
                    //got it!
                    break;
                }
            }

            else
            {
                throw &g_MemoryException;
            }

            // discard the buffer
            delete [] HeapBuffer;
            HeapBuffer = NULL;
        }
    }

    if (HeapBuffer)
    {
        TCHAR* ptszNew = new TCHAR[FinalSize + 1];
        StringData* pNewData = new StringData;
        
        if (pNewData && ptszNew)
        {
            StringCchCopy(ptszNew, FinalSize + 1, HeapBuffer);
            
            // release the old string data because we will have a new one
            m_pData->Release();
            m_pData = pNewData;
            m_pData->ptsz = ptszNew;
            m_pData->Len = FinalSize;
            
            if (HeapBuffer != tszTemp) {
            
                delete [] HeapBuffer;
            }

            return TRUE;
        }
        
        else
        {
            delete [] ptszNew;
            delete pNewData;

            if (HeapBuffer != tszTemp) {
            
                delete [] HeapBuffer;
            }

            throw &g_MemoryException;
        }
    }

    return FALSE;
}

//
// This function creates an full-qualified machine name for the
// local computer.
//
BOOL
String::GetComputerName()
{
    TCHAR tszTemp[MAX_PATH];
    // the GetComputerName api only return the name only.
    // we must prepend the UNC signature.
    tszTemp[0] = _T('\\');
    tszTemp[1] = _T('\\');
    ULONG NameLength = ARRAYLEN(tszTemp) - 2;
    
    if (::GetComputerName(tszTemp + 2, &NameLength))
    {
        int Len = lstrlen(tszTemp);
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[Len + 1];
        
        if (pNewData && ptszNew)
        {
            pNewData->Len = Len;
            StringCchCopy(ptszNew, Len + 1, tszTemp);
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
            return TRUE;
        }
        
        else
        {
            delete pNewData;
            delete []ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return FALSE;
}

BOOL
String::GetSystemWindowsDirectory()
{
    TCHAR tszTemp[MAX_PATH];
    
    if (::GetSystemWindowsDirectory(tszTemp, ARRAYLEN(tszTemp))) {
        int Len = lstrlen(tszTemp);
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[Len + 1];
        
        if (pNewData && ptszNew) {

            pNewData->Len = Len;
            StringCchCopy(ptszNew, Len + 1, tszTemp);
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
            return TRUE;
        
        } else {

            delete pNewData;
            delete []ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return FALSE;
}

BOOL
String::GetSystemDirectory()
{
    TCHAR tszTemp[MAX_PATH];
    
    if (::GetSystemDirectory(tszTemp, ARRAYLEN(tszTemp))) {
        int Len = lstrlen(tszTemp);
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[Len + 1];
        
        if (pNewData && ptszNew) {

            pNewData->Len = Len;
            StringCchCopy(ptszNew, Len + 1, tszTemp);
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
            return TRUE;
        
        } else {

            delete pNewData;
            delete []ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return FALSE;
}

void
String::Format(
    LPCTSTR FormatString,
    ...
    )
{
    // according to wsprintf specification, the max buffer size is
    // 1024
    TCHAR* pBuffer = new TCHAR[1024];
    if (pBuffer)
    {
        va_list arglist;
        va_start(arglist, FormatString);
        StringCchVPrintf(pBuffer, 1024, FormatString, arglist);
        va_end(arglist);
    
        int len = lstrlen(pBuffer);

        if (len)
        {
            TCHAR* ptszNew = new TCHAR[len + 1];
            StringData* pNewData = new StringData;
            
            if (pNewData && ptszNew)
            {
                pNewData->Len = len;
                StringCchCopy(ptszNew, len + 1, pBuffer);
                pNewData->ptsz = ptszNew;
                m_pData->Release();
                m_pData = pNewData;
                delete [] pBuffer;
                return;
            }
            
            else
            {
                delete [] pBuffer;
                delete [] ptszNew;
                delete pNewData;
                throw &g_MemoryException;
            }
        }
    }

    throw &g_MemoryException;
}


//
// templates
//

template <class T>
inline void ContructElements(T* pElements, int Count)
{
    ASSERT(Count > 0);
    memset((void*)pElements, Count * sizeof(T));
    for (; Count; pElments++, Count--)
    {
        // call the class's ctor
        // note the placement.
        new((void*)pElements) T;
    }
}


//
// CCommandLine implementation
//

// code adapted from C startup code -- see stdargv.c
// It walks through the given CmdLine and calls ParseParam
// when an argument is encountered.
// An argument must in this format:
// </command arg_to_command>  or <-command arg_to_command>
void
CCommandLine::ParseCommandLine(
    LPCTSTR CmdLine
    )
{
    LPCTSTR p;
    LPTSTR args, pDst;
    BOOL bInQuote;
    BOOL bCopyTheChar;
    int  nSlash;
    p = CmdLine;
    args = new TCHAR[lstrlen(CmdLine) + 1];
    
    if (!args)
        return;
    
    for (;;)
    {
        // skip blanks
        while (_T(' ') == *p || _T('\t') == *p)
            p++;
        
        // nothing left, bail
        if (_T('\0') == *p)
            break;
        
        // 2N backslashes + '\"' ->N backslashes plus string delimiter
        // 2N + 1 baclslashes + '\"' ->N backslashes plus literal '\"'
        // N backslashes -> N backslashes
        nSlash = 0;
        bInQuote = FALSE;
        pDst = args;
        
        for (;;)
        {
            bCopyTheChar = TRUE;
            //count how may backslashes
            while(_T('\\') == *p)
            {
                p++;
                nSlash++;
            }
            
            if (_T('\"') == *p)
            {
                if (0 == (nSlash % 2))
                {
                    // 2N backslashes plus '\"' ->N baskslashes plus
                    // delimiter
                    if (bInQuote)
                    // double quote inside quoted string
                    // skip the first and copy the second.
                    if (_T('\"') == p[1])
                        p++;
                    else
                        bCopyTheChar = FALSE;
                    else
                    bCopyTheChar = FALSE;
                    // toggle quoted status
                    bInQuote = !bInQuote;
                }
            
                nSlash /= 2;
            }
            
            while (nSlash)
            {
                *pDst++ = _T('\\');
                nSlash--;
            }
    
            if (_T('\0') == *p || (!bInQuote && (_T(' ') == *p || _T('\t') == *p)))
            {
               break;
            }

            // copy char to args
            if (bCopyTheChar)
            {
                *pDst++ = *p;
            }
            p++;
        }

        // we have a complete argument now. Null terminates it and
        // let the derived class parse the argument.
        *pDst = _T('\0');
        
        // skip blanks to see if this is the last argument
        while (_T(' ') == *p || _T('\t') == *p)
            p++;
        
        BOOL bFlag;
        bFlag = (_T('/') == *args || _T('-') == *args);
        pDst = (bFlag) ? args + 1 : args;
        ParseParam(pDst, bFlag);
    }
    
    delete [] args;
}


//
// CSafeRegistry implementation
//

BOOL
CSafeRegistry::Open(
    HKEY hKeyAncestor,
    LPCTSTR KeyName,
    REGSAM Access
    )
{
    DWORD LastError;
    // we shouldn't have a valid key -- or memory leak
    // Also, a key name must be provided -- or open nothing
    ASSERT(!m_hKey && KeyName);
    LastError =  ::RegOpenKeyEx(hKeyAncestor, KeyName, 0, Access, &m_hKey);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}


BOOL
CSafeRegistry::Create(
    HKEY hKeyAncestor,
    LPCTSTR KeyName,
    REGSAM Access,
    DWORD* pDisposition,
    DWORD Options,
    LPSECURITY_ATTRIBUTES pSecurity
    )
{
    ASSERT(KeyName && !m_hKey);
    DWORD Disposition;
    DWORD LastError;
    LastError = ::RegCreateKeyEx(hKeyAncestor, KeyName, 0, TEXT(""),
                   Options, Access, pSecurity,
                   &m_hKey, &Disposition
                   );
    SetLastError(LastError);
    
    if (ERROR_SUCCESS == LastError && pDisposition)
    {
        *pDisposition = Disposition;
    }
    
    if (ERROR_SUCCESS != LastError)
        m_hKey = NULL;
    
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::SetValue(
    LPCTSTR ValueName,
    DWORD Type,
    const PBYTE pData,
    DWORD DataLen
    )
{
    ASSERT(m_hKey);
    DWORD LastError;
    LastError = ::RegSetValueEx(m_hKey, ValueName, 0, Type, pData, DataLen);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::SetValue(
    LPCTSTR ValueName,
    LPCTSTR Value
    )
{
    return  SetValue(ValueName,
             REG_SZ,
             (PBYTE)Value,
             (lstrlen(Value) + 1) * sizeof(TCHAR)
            );
}
BOOL
CSafeRegistry::GetValue(
    LPCTSTR ValueName,
    DWORD* pType,
    const PBYTE pData,
    DWORD* pDataLen
    )
{
    ASSERT(m_hKey);
    DWORD LastError;
    LastError = ::RegQueryValueEx(m_hKey, ValueName, NULL, pType, pData,
                    pDataLen);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::GetValue(
    LPCTSTR ValueName,
    String& str
    )
{
    DWORD Type, Size;
    Size = 0;
    BOOL Result = FALSE;

    // check size before Type because when the size is zero, type contains
    // undefined data.
    if (GetValue(ValueName, &Type, NULL, &Size) && Size && REG_SZ == Type)
    {
        // we do not want to throw an exception here.
        // so guard it
        try
        {
            BufferPtr<BYTE> BufferPtr(Size);
            Result = GetValue(ValueName, &Type, BufferPtr, &Size);
            if (Result)
                str = (LPCTSTR)(BYTE*)BufferPtr;
        }
        
        catch(CMemoryException* e)
        {
            e->Delete();
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            Result = FALSE;
        }
    }
    
    return Result;
}

BOOL
CSafeRegistry::EnumerateSubkey(
    DWORD Index,
    LPTSTR Buffer,
    DWORD* BufferSize
    )
{
    DWORD LastError;
    FILETIME LastWrite;
    LastError = ::RegEnumKeyEx(m_hKey, Index, Buffer, BufferSize,
                   NULL, NULL, NULL, &LastWrite);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::DeleteValue(
    LPCTSTR ValueName
    )
{
    ASSERT(m_hKey);
    DWORD LastError = ::RegDeleteValue(m_hKey, ValueName);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::DeleteSubkey(
    LPCTSTR SubkeyName
    )
{
    ASSERT(m_hKey);
    CSafeRegistry regSubkey;
    TCHAR KeyName[MAX_PATH];
    FILETIME LastWrite;
    DWORD KeyNameLen;
    
    for (;;)
    {
        KeyNameLen = ARRAYLEN(KeyName);
        // always uses index 0(the first subkey)
        if (!regSubkey.Open(m_hKey, SubkeyName, KEY_WRITE | KEY_ENUMERATE_SUB_KEYS) ||
            ERROR_SUCCESS != ::RegEnumKeyEx(regSubkey, 0, KeyName,
                        &KeyNameLen, NULL, NULL, NULL,
                        &LastWrite) ||
            !regSubkey.DeleteSubkey(KeyName))
        {
            break;
        }
        
        // close the key so that we will re-open it on each loop
        // -- we have deleted one subkey and without closing
        // the key, the index to RegEnumKeyEx will be confusing
        regSubkey.Close();
    }
    
    // now delete the subkey
    ::RegDeleteKey(m_hKey, SubkeyName);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\ifhelp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "verpriv.h"
#include "wchar.h"

/* Determine if a file is in use by Windows
 */
BOOL FileInUse(LPWSTR lpszFilePath, LPWSTR lpszFileName)
{
    HANDLE hFile;
    BOOL bResult = FALSE;

    //
    // Attempt to open the file exclusively.
    //

    hFile = CreateFile(lpszFilePath,
                       GENERIC_WRITE | GENERIC_READ,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        //
        // If the last error is access denied,
        // then the file is in use by someone
        // else.  Return TRUE in this case.
        //

        if (GetLastError() == ERROR_SHARING_VIOLATION)
            bResult = TRUE;

    } else {

        //
        // CreateFile successfully opened the file.
        // Close the handle and return FALSE.
        //

        CloseHandle(hFile);
    }

    return bResult;
}


/* Take a Dir and Filename and make a full path from them
 */
DWORD MakeFileName(LPWSTR lpDst, LPWSTR lpDir, LPWSTR lpFile, int cchDst)
{
  DWORD wDirLen;
  WCHAR cTemp;

  wcsncpy(lpDst, lpDir, cchDst);
  lpDst[cchDst-1] = TEXT('\0');
  wDirLen=wcslen(lpDst);

  if ( wDirLen && (cTemp=*(lpDst+wDirLen-1))!=TEXT('\\') && cTemp!=TEXT(':'))
      lpDst[wDirLen++] = TEXT('\\');

  wcsncpy(lpDst+wDirLen, lpFile, cchDst - wDirLen);
  lpDst[cchDst-1] = TEXT('\0');

  return(wDirLen);
}


/* Given a filename and a list of directories, find the first directory
 * that contains the file, and copy it into the buffer.  Note that in the
 * library version, you can give an environment style path, but not in the
 * DLL version.
 */
INT
GetDirOfFile(LPWSTR lpszFileName,
    LPWSTR lpszPathName,
    DWORD wSize,
    LPWSTR *lplpszDirs)
{
  WCHAR szFileName[_MAX_PATH+1];
  HANDLE hfRes;
  INT nFileLen = 0;
  INT nPathLen = 0;
  BOOL bDoDefaultOpen = TRUE;
  LPWSTR *lplpFirstDir;
  LPWSTR lpszDir;

  nFileLen = wcslen(lpszFileName);

  for (lplpFirstDir=lplpszDirs; *lplpFirstDir && bDoDefaultOpen;
        ++lplpFirstDir)
    {
      lpszDir = *lplpFirstDir;

      if (nFileLen+wcslen(lpszDir) >= _MAX_PATH-1)
          continue;
      MakeFileName(szFileName, lpszDir, lpszFileName, ARRAYSIZE(szFileName));

TryOpen:
    nPathLen = 0;  // Re-init for this path.

    if ((hfRes = CreateFile(szFileName, GENERIC_READ,
            FILE_SHARE_READ, NULL, OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN, NULL)) != (HANDLE)-1)
        {
          CloseHandle(hfRes);
          for (lpszDir=szFileName; *lpszDir; lpszDir++)
              if (*lpszDir == TEXT('\\'))
                  nPathLen = (INT)(lpszDir - (LPWSTR)szFileName);

          /* This gets rid of the '\' if this is not the root of a drive
           */
          if (nPathLen <= 3)
              ++nPathLen;

          /* Account for the terminating NULL, and make sure wSize is in bounds
           * then NULL terminate the string in the appropriate place so that
           * we can just do an wcscpy.
           */
          --wSize;
          szFileName[(int)wSize<nPathLen ? wSize : nPathLen] = 0;
          wcscpy(lpszPathName, szFileName);

          return(nPathLen);
        }
    }

  if (bDoDefaultOpen)
    {
      bDoDefaultOpen = FALSE;
      wcscpy(szFileName, lpszFileName);
      goto TryOpen;
    }

  return(0);
}


#define GetWindowsDir(x,y,z) GetWindowsDirectory(y,z)
#define GetSystemDir(x,y,z) GetSystemDirectory(y,z)


DWORD
APIENTRY
VerFindFileW(
        DWORD wFlags,
        LPWSTR lpszFileName,
        LPWSTR lpszWinDir,
        LPWSTR lpszAppDir,
        LPWSTR lpszCurDir,
        PUINT puCurDirLen,
        LPWSTR lpszDestDir,
        PUINT puDestDirLen
        )
{
  static WORD wSharedDirLen = 0;
  static WCHAR gszSharedDir[_MAX_PATH+1];

  WCHAR szSysDir[_MAX_PATH+1], cTemp;
  WCHAR szWinDir[_MAX_PATH+1];
  WCHAR szCurDir[_MAX_PATH+1];
  LPWSTR lpszDir, lpszDirs[4];
  WORD wDestLen, wWinLen, wRetVal = 0, wTemp;
  int nRet;

#ifdef WX86
  //  Save a copy of the 'from Wx86' flag and clear it.
  BOOLEAN UseKnownWx86Dll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
  NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
#endif

  /* We want to really look in the Windows directory; we don't trust the app
   */
  GetWindowsDir(lpszWinDir ? lpszWinDir : "", szWinDir, _MAX_PATH);
  lpszWinDir = szWinDir;

#ifdef WX86
  NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = UseKnownWx86Dll;
#endif

  if(!GetSystemDir( lpszWinDir, szSysDir, _MAX_PATH))
      wcscpy(szSysDir, lpszWinDir);

#ifdef WX86
  NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
#endif

  if (wFlags & VFFF_ISSHAREDFILE) {
     lpszDirs[0] = lpszWinDir;
     lpszDirs[1] = szSysDir;
     lpszDirs[2] = lpszAppDir;
  } else {
     lpszDirs[0] = lpszAppDir;
     lpszDirs[1] = lpszWinDir;
     lpszDirs[2] = szSysDir;
  }

  lpszDirs[3] = NULL;

  if (!(wTemp=(WORD)GetDirOfFile(lpszFileName, szCurDir, _MAX_PATH, lpszDirs)))
      *szCurDir = 0;
  if (*puCurDirLen > wTemp)
      wcscpy(lpszCurDir, szCurDir);
  else
      wRetVal |= VFF_BUFFTOOSMALL;
  *puCurDirLen = wTemp + 1;

  if (lpszDestDir)
    {
      if (wFlags & VFFF_ISSHAREDFILE)
        {
          if (!wSharedDirLen)
            {
              if ((wWinLen = (WORD)wcslen(lpszWinDir)) &&
                    *(lpszWinDir-1)==TEXT('\\'))
                {
                  if (szSysDir[wWinLen-1] == TEXT('\\'))
                      goto doCompare;
                }
              else if (szSysDir[wWinLen] == TEXT('\\'))
                {
doCompare:
                  cTemp = szSysDir[wWinLen];
                  szSysDir[wWinLen] = 0;
                  nRet = _wcsicmp(lpszWinDir, szSysDir);
                  szSysDir[wWinLen] = cTemp;
                  if(nRet)
                      goto doCopyWinDir;
                  wcscpy(gszSharedDir, szSysDir);
                }
              else
                {
doCopyWinDir:
                  wcscpy(gszSharedDir, lpszWinDir);
                }
              wSharedDirLen = (WORD)wcslen(gszSharedDir);
            }

          wDestLen = wSharedDirLen;
          lpszDir = gszSharedDir;
        }
      else
        {
          wDestLen = (WORD)wcslen(lpszAppDir);
          lpszDir = lpszAppDir;
        }

      if (*puDestDirLen > wDestLen)
        {
          wcscpy(lpszDestDir, lpszDir);

          if ((wWinLen = (WORD)wcslen(lpszDestDir)) &&
                *(lpszDestDir-1)==TEXT('\\'))
              lpszDestDir[wWinLen-1] = 0;

          if (_wcsicmp(lpszCurDir, lpszDestDir))
              wRetVal |= VFF_CURNEDEST;
        }
      else
          wRetVal |= VFF_BUFFTOOSMALL;
      *puDestDirLen = wDestLen + 1;
    }

  if (*szCurDir)
    {
      MakeFileName(szSysDir, szCurDir, lpszFileName, ARRAYSIZE(szSysDir));
      if (FileInUse(szSysDir, lpszFileName))
          wRetVal |= VFF_FILEINUSE;
    }

  return(wRetVal);
}


/*
 *  DWORD
 *  APIENTRY
 *  VerLanguageNameW(
 *      DWORD wLang,
 *      LPWSTR szLang,
 *      DWORD wSize)
 *
 *  This routine was moved to NLSLIB.LIB so that it uses the WINNLS.RC file.
 *  NLSLIB.LIB is part of KERNEL32.DLL.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\instfile.c ===
#include "verpriv.h"
#include <lzexpand.h>
#include "diamondd.h"
#include "mydiam.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
** Prototypes
*/

// For the time being, private APIS exported
INT
LZCreateFileW(
    LPWSTR,
    DWORD,
    DWORD,
    DWORD,
    LPWSTR);

VOID
LZCloseFile(
    INT);


#ifdef __cplusplus
}
#endif


BOOL    FileInUse(LPWSTR lpszFilePath, LPWSTR lpszFileName);
DWORD   MakeFileName(LPWSTR lpDst, LPWSTR lpDir, LPWSTR lpFile, int cchDst);

typedef struct tagVS_VERSION {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    WCHAR szSig[16];
    VS_FIXEDFILEINFO vInfo;
} VS_VERSION;

typedef struct tagLANGANDCP {
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCP;

WCHAR szTrans[] = TEXT("\\VarFileInfo\\Translation");
WCHAR szTempHdr[] = TEXT("temp.");


/* The routines in here will find a file on a path, and an environment
 * variable.  The constants _MAX_PATH and need to be defined
 * by the including module, plus the constant WINDOWS should
 * be defined if this is to be used in Windows, so that lstrcmpi
 * and lstrlen will not be compiled
 */


VOID Ver3IToA(LPWSTR lpwStr, int n)
{
    int nShift;
    WCHAR cTemp;

    for (nShift=8; nShift>=0; nShift-=4, ++lpwStr) {
        if ((cTemp = (WCHAR)((n>>nShift)&0x000f)) >= 10)
            *lpwStr = (WCHAR)('A' + cTemp - 10);
        else
            *lpwStr = (WCHAR)('0' + cTemp     );
    }
    *lpwStr = 0;
}


/* Convert a DOS error into an error flag
 */
DWORD FileErrFlag(int err)
{
    switch (err) {
        case 0x05:
            return (VIF_ACCESSVIOLATION);

        case 0x20:
            return (VIF_SHARINGVIOLATION);

        default:
            return (0);
    }
}


/* Create the given file with default flags; global nFileErr will
 * receive any DOS error; returns -1 on error, otherwise the DOS
 * file handle.
 */
HANDLE VerCreateFile(LPWSTR lpszFile)
{
    HANDLE hFile;

    hFile = CreateFile(lpszFile, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ, NULL, CREATE_NEW,
                       FILE_ATTRIBUTE_NORMAL, NULL);

    return (hFile);
}


VOID VerClose(HANDLE hW32File)
{
    CloseHandle(hW32File);
}


#define MyAlloc(x) ((WCHAR *)LocalAlloc(LMEM_FIXED, x))
#define MyFree(x) LocalFree((HANDLE)(x))

LPVOID MyGetFileVersionInfo(LPWSTR lpFileName)
{
    WCHAR *pInfo;
    WORD wLen = 2048;

TryAgain:
    if (!(pInfo=MyAlloc(wLen)))
        goto Error1;
    if (!GetFileVersionInfo(lpFileName, 0L, wLen, pInfo))
        goto Error2;
    if (wLen < *(WORD *)pInfo) {
        wLen = *(WORD *)pInfo;
        MyFree(pInfo);
        goto TryAgain;
    }
    return (pInfo);

Error2:
    MyFree(pInfo);
Error1:
    return (NULL);
}

HINSTANCE hLz32;
DWORD cLz32Load;
typedef INT  (APIENTRY *tLZInit)( INT );
typedef INT  (APIENTRY *tLZOpenFileW)(LPWSTR, LPOFSTRUCT, WORD );
typedef INT  (APIENTRY *tLZCreateFileW)(LPWSTR, DWORD, DWORD, DWORD, LPWSTR);
typedef VOID (APIENTRY *tLZClose)( INT );
typedef VOID (APIENTRY *tLZCloseFile)( INT );
typedef LONG (APIENTRY *tLZCopy)( INT, INT );

tLZInit      pLZInit;
tLZOpenFileW pLZOpenFileW;
tLZCreateFileW pLZCreateFileW;
tLZClose     pLZClose;
tLZCloseFile     pLZCloseFile;
tLZCopy      pLZCopy;

DWORD
APIENTRY
VerInstallFileW(
               DWORD wFlags,
               LPWSTR lpszSrcFileName,
               LPWSTR lpszDstFileName,
               LPWSTR lpszSrcDir,
               LPWSTR lpszDstDir,
               LPWSTR lpszCurDir,
               LPWSTR lpszTmpFile,
               PUINT puTmpFileLen
               )
{
    WCHAR szSrcFile[_MAX_PATH];
    WCHAR szDstFile[_MAX_PATH];
    WCHAR szCurFile[_MAX_PATH];
    DWORD dwRetVal = 0L, dwSrcAttr;
    WORD wDirLen;
    LONG lCopy;
    HANDLE hW32Out;
    int i, fIn, fDosOut;
    WCHAR szCompFile[_MAX_PATH];
    CHAR  szOemFile[_MAX_PATH];
    int   iOemString;
    BOOL  bDefaultCharUsed;
    BOOL DiamondFile;

    if (!cLz32Load) {
        hLz32 = LoadLibraryW(L"LZ32.DLL");
        if (!hLz32) {
            return (VIF_CANNOTLOADLZ32);
        }
        pLZOpenFileW   = (tLZOpenFileW)   GetProcAddress(hLz32, "LZOpenFileW");
        pLZCreateFileW = (tLZCreateFileW) GetProcAddress(hLz32, "LZCreateFileW");
        pLZInit        = (tLZInit)        GetProcAddress(hLz32, "LZInit");
        pLZCopy        = (tLZCopy)        GetProcAddress(hLz32, "LZCopy");
        pLZClose       = (tLZClose)       GetProcAddress(hLz32, "LZClose");
        pLZCloseFile   = (tLZCloseFile)   GetProcAddress(hLz32, "LZCloseFile");
        if (!(pLZOpenFileW && pLZInit && pLZCopy && pLZClose && pLZCreateFileW && pLZCloseFile)) {
            FreeLibrary(hLz32);
            return (VIF_CANNOTLOADLZ32);
        }

        if (InterlockedExchangeAdd(&cLz32Load, 1) != 0) {
            // Multiple threads are attempting to LoadLib
            // Free one here.
            FreeLibrary(hLz32);
        }
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    /* LZ Open the source for reading
     */
    MakeFileName(szSrcFile, lpszSrcDir, lpszSrcFileName, ARRAYSIZE(szSrcFile));
    dwRetVal = InitDiamond();
    if (dwRetVal) {
        return (dwRetVal);
    }
    if((fIn=pLZCreateFileW(szSrcFile, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, szCompFile)) < 0) {
        dwRetVal |= VIF_CANNOTREADSRC;
        goto doReturn;
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

  /*
   * now we don't have any unicode interface for Diamond API. we need to convert
   * it to OEM charset string. we will use the converted string instead of of.szPathName.
   */

   DiamondFile = FALSE;

   iOemString = WideCharToMultiByte( CP_OEMCP,            // Oem Codepage
                                     0,                   // no option flag
                                     szCompFile,          // Unicode string
                                     -1,                  // should be NULL terminated
                                     szOemFile,           // Oem string
                                     ARRAYSIZE(szOemFile),// Oem string buffer size
                                     NULL,                // use nls default char 
                                     &bDefaultCharUsed 
                                   );

   if( ( iOemString != 0               ) && // should succeed conversion.
       ( iOemString <= OFS_MAXPATHNAME ) && // should be <= 128 for OpenFile() API.
       ( bDefaultCharUsed == FALSE     )    // the def. char should not be contain.
     )
   {
      DiamondFile = IsDiamondFile(szOemFile);
   }

    if (DiamondFile) {
        pLZCloseFile(fIn);
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    /* If the dest file exists and is read only, return immediately;
     * the calling app must change the attributes before continuing
     * In the library version, we assume the file is in use if it exists
     * and we are in a VM; check all other possible errors and then return,
     * so the calling app can override our determination of "in use"
     * on a second call, along with all other problems
     */
    wDirLen = (WORD)MakeFileName(szDstFile, lpszDstDir, lpszDstFileName, ARRAYSIZE(szDstFile));
    lstrcpyn(szSrcFile, szDstFile, ARRAYSIZE(szSrcFile));
    if (!HIWORD(dwSrcAttr=GetFileAttributes(szSrcFile))) {
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (LOWORD(dwSrcAttr)&0x01) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            dwRetVal |= VIF_WRITEPROT;
            goto doCloseSrc;
        }
    }

    /* If this is a force install and there is a temp file name from a
     * previous call to this function, use that as the temp file name
     */
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    if ((wFlags&VIFF_FORCEINSTALL) && *lpszTmpFile) {
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        LogData("fnam", (DWORD)lpszDstDir, (DWORD)lpszTmpFile);
        MakeFileName(szSrcFile, lpszDstDir, lpszTmpFile, ARRAYSIZE(szSrcFile));
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        LogData("srcf", (DWORD)szSrcFile, *(LPDWORD)szSrcFile);
        if (!HIWORD(GetFileAttributes(szSrcFile))) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            goto doCheckDstFile;
        }
    }

    /* Determine a file name that is not in use; try names of the form:
     * temp.nnn where nnn is a three digit hex number.  If we get to
     * 0xfff, we have a serious file system problem.  Create the file.
     */
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    lstrcpy(szSrcFile+wDirLen, szTempHdr);
    for (i=0; ; ++i) {
        Ver3IToA(szSrcFile+wDirLen+lstrlen(szTempHdr), i);
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (HIWORD(GetFileAttributes(szSrcFile)))
            break;
        if (i > 0xfff) {
            dwRetVal |= VIF_CANNOTCREATE;
            goto doCloseSrc;
        }
    }
    /* Copy the file, and fill in appropriate errors
     */

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    if (DiamondFile) {
        LZINFO lzi;
        lCopy = ExpandDiamondFile(szOemFile,
                                  szSrcFile,
                                  FALSE,
                                  &lzi);
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    } else {
        if ((hW32Out=VerCreateFile(szSrcFile)) == INVALID_HANDLE_VALUE) {
            dwRetVal |= VIF_CANNOTCREATE | FileErrFlag(GetLastError());
            goto doCloseSrc;
        }

        LogData("inst", __LINE__, (DWORD)puTmpFileLen);

        fDosOut = pLZInit((INT)((DWORD_PTR)hW32Out));
        lCopy = pLZCopy(fIn, fDosOut);
        pLZClose(fDosOut);
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    switch (lCopy) {
        case LZERROR_BADINHANDLE:
        case LZERROR_READ:
        case LZERROR_BADVALUE:
        case LZERROR_UNKNOWNALG:
            dwRetVal |= VIF_CANNOTREADSRC;
            goto doDelTempFile;

        case LZERROR_BADOUTHANDLE:
        case LZERROR_WRITE:
            dwRetVal |= VIF_OUTOFSPACE;
            goto doDelTempFile;

        case LZERROR_GLOBALLOC:
        case LZERROR_GLOBLOCK:
            dwRetVal |= VIF_OUTOFMEMORY;
            goto doDelTempFile;

        default:
            break;
    }

    /* If the destination exists, check the versions of the two files,
     * and only copy if the src file is at least as new as the dst, and
     * they are the same type and in the same language and codepage
     */
doCheckDstFile:
    if (!HIWORD(dwSrcAttr)) {
        VS_VERSION *pSrcVer, *pDstVer;
        LANGANDCP *lpSrcTrans, *lpDstTrans;
        DWORD   dwSrcNum, dwDstNum;
        DWORD   dwSrcTrans, dwDstTrans;

        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (!(wFlags & VIFF_FORCEINSTALL) &&
            (pDstVer=MyGetFileVersionInfo(szDstFile))) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            if (!(pSrcVer=MyGetFileVersionInfo(szSrcFile))) {
                dwRetVal |= VIF_MISMATCH | VIF_SRCOLD;
            } else {
                LogData("inst", __LINE__, (DWORD)puTmpFileLen);
                if (pDstVer->vInfo.dwFileVersionMS>pSrcVer->vInfo.dwFileVersionMS
                    || (pDstVer->vInfo.dwFileVersionMS==pSrcVer->vInfo.dwFileVersionMS &&
                        pDstVer->vInfo.dwFileVersionLS>pSrcVer->vInfo.dwFileVersionLS))
                    dwRetVal |= VIF_MISMATCH | VIF_SRCOLD;

                if (pDstVer->vInfo.dwFileType!=pSrcVer->vInfo.dwFileType ||
                    pDstVer->vInfo.dwFileSubtype!=pSrcVer->vInfo.dwFileSubtype)
                    dwRetVal |= VIF_MISMATCH | VIF_DIFFTYPE;

                if (VerQueryValueW(pDstVer, szTrans, (LPVOID)&lpDstTrans, &dwDstNum) &&
                    VerQueryValueW(pSrcVer, szTrans, (LPVOID)&lpSrcTrans, &dwSrcNum)) {
                    dwDstNum /= sizeof(DWORD);
                    dwSrcNum /= sizeof(DWORD);

                    for (dwDstTrans=0; dwDstTrans<dwDstNum; ++dwDstTrans) {
                        for (dwSrcTrans=0; ; ++dwSrcTrans) {
                            if (dwSrcTrans >= dwSrcNum) {
                                dwRetVal |= VIF_MISMATCH | VIF_DIFFLANG;
                                break;
                            }

                            if (lpDstTrans[dwDstTrans].wLanguage
                                == lpSrcTrans[dwSrcTrans].wLanguage) {
                                /* OK if dst is CP0 and src is not UNICODE
                                 */
                                if (lpDstTrans[dwDstTrans].wCodePage==0 &&
                                    lpSrcTrans[dwSrcTrans].wCodePage!=1200)
                                    break;
                                if (lpDstTrans[dwDstTrans].wCodePage
                                    == lpSrcTrans[dwSrcTrans].wCodePage)
                                    break;
                            }
                        }
                    }
                }

                LogData("inst", __LINE__, (DWORD)puTmpFileLen);
                MyFree(pSrcVer);
            }
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            MyFree(pDstVer);
        }

        /* If there were no errors, delete the currently existing file
         */
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (FileInUse(szDstFile, lpszDstFileName)) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            dwRetVal |= VIF_FILEINUSE;
        }
    
        if (!dwRetVal && !DeleteFile(szDstFile)) {
            dwRetVal |= VIF_CANNOTDELETE | FileErrFlag(GetLastError());
            goto doDelTempFile;
        }
    }

    /* If there were no errors, rename the temp file (any existing file
     * should have been deleted by now).  Otherwise, if we created a valid
     * temp file, then pass along the temp file name.
     */
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    if (dwRetVal) {
        DWORD wTemp;

        if (*puTmpFileLen > (wTemp=lstrlen(szSrcFile+wDirLen))) {
            lstrcpy(lpszTmpFile, szSrcFile+wDirLen);
            dwRetVal |= VIF_TEMPFILE;
        } else {
            dwRetVal |= VIF_BUFFTOOSMALL;
            DeleteFile(szSrcFile);
        }
        *puTmpFileLen = wTemp + 1;
    } else {
        /* Delete the currently existing file; this gets done before renaming
         * the temp file in case someone has tried to mess us up with a weird
         * directory name that would allow us to delete the newly installed
         * file.
         */
        if (!(wFlags&VIFF_DONTDELETEOLD) &&
            lpszCurDir && *lpszCurDir && lstrcmpi(lpszCurDir, lpszDstDir)) {
            MakeFileName(szCurFile, lpszCurDir, lpszDstFileName, ARRAYSIZE(szCurFile));
            if (!HIWORD(GetFileAttributes(szCurFile)) &&
                (FileInUse(szCurFile, lpszDstFileName) ||
                 !DeleteFile(szCurFile)))
                dwRetVal |= VIF_CANNOTDELETECUR | FileErrFlag(GetLastError());
        }

        if (!MoveFile(szSrcFile, szDstFile)) {
            dwRetVal |= VIF_CANNOTRENAME | FileErrFlag(GetLastError());
doDelTempFile:
            DeleteFile(szSrcFile);
        }
    }

doCloseSrc:
    if (!DiamondFile) {
        pLZCloseFile(fIn);
    }
doReturn:
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    TermDiamond();
    return (dwRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\verpriv.h ===
/***************************************************************************
 *  VERPRIV.H
 *
 *    Private include file for the version stamping API.  Includes
 *    WINDOWS.H if this is being made to be a DLL.
 *
 ***************************************************************************/

#ifndef VERPRIV_H
#define VERPRIV_H
#undef DBCS

#include <stdlib.h>
#include <windows.h>

#define SEEK_START      0
#define SEEK_CURRENT 1
#define SEEK_END     2

/* ----- Function prototypes ----- */
#define FileClose(a)       LZClose(a)
#define FileRead(a, b, c)  LZRead((a), (b), (c))
#define FileSeek(a, b, c)  LZSeek((a), (b), (c))


BOOL
APIENTRY
VerpQueryValue(
   const LPVOID pb,
   LPVOID lpSubBlockX,
   INT    nIndex,
   LPVOID *lplpKey,
   LPVOID *lplpBuffer,
   PUINT  puLen,
   BOOL  bUnicodeNeeded
   );

#endif /* VERPRIV_H */


#if 0
#define LOG_DATA 1
#endif


#ifdef LOG_DATA
#   pragma message(__FILE__"(43) : warning !!!! : remove debug code before checking in" )
extern void LogThisData( DWORD id, char *szMsg, DWORD dwLine, DWORD dwData );

#   define LogData( sz, dw1, dw2 )   LogThisData(GetCurrentThreadId(), sz "            ", dw1, dw2 )
#else
#   define LogData( sz, dw1, dw2 )
#endif



#ifndef ARRAYSIZE
#   define ARRAYSIZE(sz)   (sizeof(sz) / sizeof((sz)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\aclui.c ===
#include "shellpch.h"
#pragma hdrstop

#define _ACLUI_
#include <aclui.h>

static
HPROPSHEETPAGE
ACLUIAPI
CreateSecurityPage(
    LPSECURITYINFO psi
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_ORDINAL_ENTRIES(aclui)
{
    DLOENTRY(1, CreateSecurityPage)
};

DEFINE_ORDINAL_MAP(aclui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\winver\winverp.h ===
/*----------------------------------------------------------------------------*\
|   WINVER.H - Windows Version program                                         |
|                                                                              |
|   History:                                                                   |
|       03/08/89 Toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/


#define IDS_APPTITLE   101
#define IDS_EVALUATION 102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\mydiam.h ===
typedef struct tagLZI {
    BYTE *rgbyteRingBuf;    // ring buffer for expansion
    BYTE *rgbyteInBuf;      // input buffer for reads
    BYTE *pbyteInBufEnd;    // pointer past end of rgbyteInBuf[]
    BYTE *pbyteInBuf;       // pointer to next byte to read from
    BYTE *rgbyteOutBuf;     // output buffer for writes
    BYTE *pbyteOutBufEnd;   // pointer past end of rgbyteOutBuf[]
    BYTE *pbyteOutBuf;      // pointer to last byte to write from
    // Flag indicating whether or not rgbyteInBuf[0], which holds the last byte
    // from the previous input buffer, should be read as the next input byte.
    // (Only used so that at least one unReadUChar() can be done at all input
    // buffer positions.)
    BOOL bLastUsed;
    // Actually, rgbyteInBuf[] has length (ucbInBufLen + 1) since rgbyteInBuf[0]
    // is used when bLastUsed is TRUE.
    INT cbMaxMatchLen;      // longest match length for current algorithm
    LONG cblInSize,         // size in bytes of input file
         cblOutSize;        // size in bytes of output file
    DWORD ucbInBufLen,      // length of input buffer
          ucbOutBufLen;     // length of output buffer
    DWORD uFlags;           // LZ decoding description byte
    INT iCurRingBufPos;     // ring buffer offset
    INT *leftChild;         // parents and left and right
    INT *rightChild;        // children that make up the
    INT *parent;            // binary search trees

    INT iCurMatch,          // index of longest match (set by LZInsertNode())
        cbCurMatch;         // length of longest match (set by LZInsertNode())

} LZINFO;

typedef LZINFO *PLZINFO;

typedef struct _dcx {
    INT dcxDiamondLastIoError;
    HFDI dcxFdiContext;
    ERF dcxFdiError;
} DIAMOND_CONTEXT;

typedef DIAMOND_CONTEXT *PDIAMOND_CONTEXT;


extern DWORD itlsDiamondContext;

#define ITLS_ERROR          (0xFFFFFFFF)

#define GotDmdTlsSlot()     (itlsDiamondContext != ITLS_ERROR)
#define GotDmdContext()     (TlsGetValue(itlsDiamondContext) != NULL)

#define FdiContext          (((GotDmdTlsSlot() && GotDmdContext()) ? ((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxFdiContext : NULL))
#define SetFdiContext(v)    (((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxFdiContext = (v))
#define FdiError            (((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxFdiError)
#define DiamondLastIoError  (((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxDiamondLastIoError)

DWORD
InitDiamond(
    VOID
    );

VOID
TermDiamond(
    VOID
    );

BOOL
IsDiamondFile(
    IN PSTR FileName
    );

INT
ExpandDiamondFile(
    IN  PSTR       SourceFileName,  // Because LZOpen ... returns ASCII!
    IN  PTSTR      TargetFileName,
    IN  BOOL       RenameTarget,
    OUT PLZINFO    pLZI
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\version\version.c ===
/***************************************************************************
 *  VER.C
 *
 *	Code specific to the DLL version of VER which contains the Windows
 *	procedures necessary to make it work
 *
 ***************************************************************************/

#include "verpriv.h"
#include <diamondd.h>
#include "mydiam.h"

/*  LibMain
 *		Called by DLL startup code.
 *		Initializes VER.DLL.
 */

#ifdef LOG_DATA
typedef struct {
    DWORD idThd;
    char  szMsg[4];
    DWORD dwLine;
    DWORD dwData;
} LOGLINE;

typedef LOGLINE *PLOGLINE;

#define CLOG_MAX    16384

LOGLINE llLogBuff[CLOG_MAX];
int illLogPtr = 0;
CRITICAL_SECTION csLog;

void LogThisData( DWORD id, char *szMsg, DWORD dwLine, DWORD dwData ) {
    PLOGLINE pll;

    EnterCriticalSection(&csLog);
    pll = &llLogBuff[illLogPtr++];
    if (illLogPtr >= CLOG_MAX)
        illLogPtr = 0;
    LeaveCriticalSection(&csLog);


    pll->idThd = id;
    pll->dwData = dwData;
    pll->dwLine = dwLine;
    CopyMemory( pll->szMsg, szMsg, sizeof(pll->szMsg) );
}
#endif





HANDLE  hInst;
extern HINSTANCE hLz32;
extern HINSTANCE hCabinet;

DWORD itlsDiamondContext = ITLS_ERROR;  // Init to Error Condition

INT
APIENTRY
LibMain(
       HANDLE  hInstance,
       DWORD   dwReason,
       LPVOID  lp
       )
{
    PDIAMOND_CONTEXT pdcx;

    UNREFERENCED_PARAMETER(lp);

    hInst = hInstance;

#ifdef LOG_DATA
    {
        TCHAR szBuffer[80];
        swprintf( szBuffer, TEXT("thd[0x%08ld]: Attached to version.dll for %ld\n"), GetCurrentThreadId(), dwReason );
        OutputDebugString(szBuffer);
    }
#endif

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:

#ifdef LOG_DATA
            InitializeCriticalSection(&csLog);
#endif

#ifdef LOG_DATA

            {
                TCHAR szBuffer[MAX_PATH];
                OutputDebugString(TEXT(">>>version.c: compiled ") TEXT(__DATE__) TEXT(" ") TEXT(__TIME__) TEXT("\n"));
                OutputDebugString(TEXT("\tProcess "));
                GetModuleFileName(NULL, szBuffer, sizeof(szBuffer) / sizeof(TCHAR));
                OutputDebugString(szBuffer);
                OutputDebugString(TEXT(" attached\n"));
            }
#endif
            itlsDiamondContext = TlsAlloc();

            // Fall through to Thread Attach, since for some reason
            // the DLL_PROCESS_ATTACH thread does not call DLL_THREAD_ATTACH

        case DLL_THREAD_ATTACH:
            if (GotDmdTlsSlot())
                TlsSetValue(itlsDiamondContext, NULL);

            break;

        case DLL_PROCESS_DETACH:

            if (GotDmdTlsSlot()) {
                TlsFree(itlsDiamondContext);
            }
            if (hLz32) {
                FreeLibrary(hLz32);
            }

            if (hCabinet) {
                FreeLibrary(hCabinet);
            }
            break;
    }

    /* Return success */
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\browseui.c ===
#include "shellpch.h"
#pragma hdrstop

#define _BROWSEUI_
#include <shlobj.h>
#include <shlobjp.h>
#include <objidl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <browseui.h>

#undef BROWSEUIAPI
#define BROWSEUIAPI             HRESULT STDAPICALLTYPE
#undef BROWSEUIAPI_
#define BROWSEUIAPI_(type)      type STDAPICALLTYPE


static
BROWSEUIAPI_(HRESULT)
Channel_QuickLaunch()
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(void)
SHCreateSavedWindows()
{
}

static 
BROWSEUIAPI_(BOOL)
SHParseIECommandLine(
    LPCWSTR * ppszCmdLine,
    IETHREADPARAM * piei
    )
{
    return FALSE;
}

static
BROWSEUIAPI
SHCreateBandForPidl(
    LPCITEMIDLIST pidl,
    IUnknown** ppunk,
    BOOL fAllowBrowserBand
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(DWORD)
IDataObject_GetDeskBandState(
    IDataObject *pdtobj
    )
{
    return 0;
}

static
BROWSEUIAPI_(BOOL)
SHOpenFolderWindow(
    IETHREADPARAM* pieiIn
    )
{
    // we leak some memebers, but we at least free piei
    LocalFree(pieiIn);
    return FALSE;
}

static
BROWSEUIAPI_(IETHREADPARAM*)
SHCreateIETHREADPARAM(
    LPCWSTR pszCmdLineIn,
    int nCmdShowIn,
    ITravelLog *ptlIn,
    IEFreeThreadedHandShake* piehsIn
    )
{
    return NULL;
}

static
BROWSEUIAPI_(void)
SHDestroyIETHREADPARAM(
    IETHREADPARAM* piei
    )
{
    // we leak som memebers, but we at least free piei
    LocalFree(piei);
}

static
BROWSEUIAPI_(BOOL)
SHOnCWMCommandLine(
    LPARAM lParam
    )
{
    return FALSE;
}

static
BROWSEUIAPI_(LPITEMIDLIST)
Channel_GetFolderPidl()
{
    return NULL;
}

static
BROWSEUIAPI
IUnknown_SetBandInfoSFB(
    IUnknown *punkBand,
    BANDINFOSFB *pbi
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(void)
Channels_SetBandInfoSFB(
    IUnknown* punkBand
    )
{
}

static
BROWSEUIAPI_(IDeskBand *)
ChannelBand_Create(
    LPCITEMIDLIST pidlDefault
    )
{
    return NULL;
}

static
BROWSEUIAPI_(HRESULT)
SHGetNavigateTarget(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    LPITEMIDLIST *ppidl,
    DWORD *pdwAttribs
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(BOOL)
GetInfoTip(
    IShellFolder* psf,
    LPCITEMIDLIST pidl,
    LPTSTR pszText,
    int cchTextMax
    )
{
    *pszText = 0;
    return FALSE;
}

static
BROWSEUIAPI_(BOOL)
SHCreateFromDesktop(
    PNEWFOLDERINFO pfi
    )
{
    return TRUE;
}

static
BROWSEUIAPI
SHOpenNewFrame(
    LPITEMIDLIST pidlNew,
    ITravelLog *ptl,
    DWORD dwBrowserIndex,
    UINT uFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}



//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(browseui)
{
    DLOENTRY(102, SHOpenFolderWindow)
    DLOENTRY(103, SHOpenNewFrame)
    DLOENTRY(105, SHCreateSavedWindows)
    DLOENTRY(106, SHCreateFromDesktop)
    DLOENTRY(120, SHCreateBandForPidl)
    DLOENTRY(122, IDataObject_GetDeskBandState)
    DLOENTRY(123, SHCreateIETHREADPARAM)
    DLOENTRY(125, SHParseIECommandLine)
    DLOENTRY(126, SHDestroyIETHREADPARAM)
    DLOENTRY(127, SHOnCWMCommandLine)
    DLOENTRY(128, Channel_GetFolderPidl)
    DLOENTRY(129, ChannelBand_Create)
    DLOENTRY(130, Channels_SetBandInfoSFB)
    DLOENTRY(131, IUnknown_SetBandInfoSFB)
    DLOENTRY(133, Channel_QuickLaunch)
    DLOENTRY(134, SHGetNavigateTarget)
    DLOENTRY(135, GetInfoTip)
};

DEFINE_ORDINAL_MAP(browseui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\cabinet.c ===
#include "shellpch.h"
#pragma hdrstop

#include <fci.h>
#include <fdi.h>

static
HFCI
DIAMONDAPI
FCICreate(
    PERF              perf,
    PFNFCIFILEPLACED  pfnfcifp,
    PFNFCIALLOC       pfna,
    PFNFCIFREE        pfnf,
    PFNFCIOPEN        pfnopen,
    PFNFCIREAD        pfnread,
    PFNFCIWRITE       pfnwrite,
    PFNFCICLOSE       pfnclose,
    PFNFCISEEK        pfnseek,
    PFNFCIDELETE      pfndelete,
    PFNFCIGETTEMPFILE pfnfcigtf,
    PCCAB             pccab,
    void FAR *        pv
    )
{
    return NULL;
}

static
BOOL
DIAMONDAPI
FCIAddFile(
    HFCI                  hfci,
    char                 *pszSourceFile,
    char                 *pszFileName,
    BOOL                  fExecute,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis,
    PFNFCIGETOPENINFO     pfnfcigoi,
    TCOMP                 typeCompress
    )
{
    return FALSE;
}

static
BOOL
DIAMONDAPI
FCIFlushCabinet(
    HFCI                  hfci,
    BOOL                  fGetNextCab,
    PFNFCIGETNEXTCABINET  pfnfcignc,
    PFNFCISTATUS          pfnfcis
    )
{
    return FALSE;
}

static
BOOL
DIAMONDAPI
FCIDestroy (HFCI hfci)
{
    return FALSE;
}

static
BOOL
FAR DIAMONDAPI
FDICopy (
    HFDI          hfdi,
    char FAR     *pszCabinet,
    char FAR     *pszCabPath,
    int           flags,
    PFNFDINOTIFY  pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void FAR     *pvUser
    )
{
    return FALSE;
}

static
HFDI
FAR DIAMONDAPI
FDICreate (
    PFNALLOC pfnalloc,
    PFNFREE  pfnfree,
    PFNOPEN  pfnopen,
    PFNREAD  pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK  pfnseek,
    int      cpuType,
    PERF     perf
    )
{
    return NULL;
}

static
BOOL
FAR DIAMONDAPI
FDIDestroy (
    HFDI hfdi
    )
{
    return FALSE;
}

static
BOOL
FAR DIAMONDAPI
FDIIsCabinet (
    HFDI            hfdi,
    INT_PTR         hf,
    PFDICABINETINFO pfdici
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(cabinet)
{
    DLOENTRY(10, FCICreate)
    DLOENTRY(11, FCIAddFile)
    DLOENTRY(13, FCIFlushCabinet)
    DLOENTRY(14, FCIDestroy)
    DLOENTRY(20, FDICreate)
    DLOENTRY(21, FDIIsCabinet)
    DLOENTRY(22, FDICopy)
    DLOENTRY(23, FDIDestroy)
};

DEFINE_ORDINAL_MAP(cabinet)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\winver\winver.c ===
/*---------------------------------------------------------------------------
 |   WINVER.C - Windows Version program
 |
 |   History:
 |  03/08/89 Toddla     Created
 |
 *--------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <port1632.h>
#include <stdio.h>
#include "winverp.h"
#include <shellapi.h>
#include <strsafe.h>
#ifndef ARRAYSIZE
    #define ARRAYSIZE(x)                    (sizeof(x) / sizeof(x[0]))
#endif

BOOL FileTimeToDateTimeString(
    LPFILETIME pft,
    LPTSTR     pszBuf,
    UINT       cchBuf)
{
    SYSTEMTIME st;
    int cch;

    FileTimeToLocalFileTime(pft, pft);
    if (FileTimeToSystemTime(pft, &st))
    {
        cch = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf);
        if (cch > 0)
        {
            cchBuf -= cch;
            pszBuf += cch - 1;

            *pszBuf++ = TEXT(' ');
            *pszBuf = 0;          // (in case GetTimeFormat doesn't add anything)
            cchBuf--;

            GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf);
            return TRUE;
        }
    }    
    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the App.  After initializing, it just goes      |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|   hInst       instance handle of this instance of the app                    |
|   hPrev       instance handle of previous instance, NULL if first            |
|       lpszCmdLine     ->null-terminated command line                         |
|       cmdShow         specifies how the window is initially displayed        |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
INT
__cdecl
ModuleEntry()
{
    TCHAR szTitle[32];
    LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

    if (LoadString(GetModuleHandle(NULL), IDS_APPTITLE, szTitle, ARRAYSIZE(szTitle)))
    {
        if (Time.QuadPart) 
        {
            TCHAR szExtra[128];
            TCHAR szTime[128];

            if (FileTimeToDateTimeString((PFILETIME)&Time, szTime, ARRAYSIZE(szTime))
                    && LoadString(GetModuleHandle(NULL), IDS_EVALUATION, szExtra, ARRAYSIZE(szExtra)))
            {
                StringCchCat(szExtra, ARRAYSIZE(szExtra), szTime);
                ShellAbout(NULL, szTitle, szExtra, NULL);
            }
        } else 
        {
            ShellAbout(NULL, szTitle, NULL, NULL);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\cdfview.c ===
#include "shellpch.h"
#pragma hdrstop

static
HRESULT WINAPI
SubscribeToCDF(
    HWND hwndOwner,
    LPWSTR wszURL,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT WINAPI
ParseDesktopComponent(
    HWND hwndOwner,
    LPWSTR wszURL,
    void* pInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(cdfview)
{
    DLPENTRY(ParseDesktopComponent)
    DLPENTRY(SubscribeToCDF)
};

DEFINE_PROCNAME_MAP(cdfview)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\devmgr.c ===
#include "shellpch.h"
#pragma hdrstop

#include <hwtab.h>

static
HWND
WINAPI
DeviceCreateHardwarePageEx(HWND hwndParent,
                           const GUID *pguid,
                           int iNumClass,
                           DWORD dwViewMode)
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(devmgr)
{
    DLOENTRY(20, DeviceCreateHardwarePageEx)
};

DEFINE_ORDINAL_MAP(devmgr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\comdlg32.c ===
#include "shellpch.h"
#pragma hdrstop

#define _COMDLG32_
#include <commdlg.h>

static
DWORD
APIENTRY
CommDlgExtendedError(VOID)
{
    return 0;
}

static
SHORT
APIENTRY
GetFileTitleW (
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
GetOpenFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
GetOpenFileNameA (
    LPOPENFILENAMEA pofn
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetSaveFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetSaveFileNameA (
    LPOPENFILENAMEA pofn
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
ChooseColorW(
    LPCHOOSECOLORW pccw
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PageSetupDlgW(
    LPPAGESETUPDLGW pPSDA
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PageSetupDlgA(
    LPPAGESETUPDLGA pPSDA
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PrintDlgA(
    LPPRINTDLGA pPDA
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PrintDlgW(
    LPPRINTDLGW pPDA
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comdlg32)
{
    DLPENTRY(ChooseColorW)
    DLPENTRY(CommDlgExtendedError)
    DLPENTRY(GetFileTitleW)
    DLPENTRY(GetOpenFileNameA)
    DLPENTRY(GetOpenFileNameW)
    DLPENTRY(GetSaveFileNameA)
    DLPENTRY(GetSaveFileNameW)
    DLPENTRY(PageSetupDlgA)
    DLPENTRY(PageSetupDlgW)
    DLPENTRY(PrintDlgA)
    DLPENTRY(PrintDlgW)
};

DEFINE_PROCNAME_MAP(comdlg32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\efsadu.c ===
#include "shellpch.h"
#pragma hdrstop

#include <efsui.h>

static
void
WINAPI
EfsDetail(
    HWND hwndParent,
    LPCWSTR FileName
    )
{
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(efsadu)
{
    DLPENTRY(EfsDetail)
};

DEFINE_PROCNAME_MAP(efsadu)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\comctl32.c ===
#include "shellpch.h"
#pragma hdrstop

#define _COMCTL32_
#include <commctrl.h>
#include <comctrlp.h>


static
WINCOMMCTRLAPI
HPROPSHEETPAGE
WINAPI
CreatePropertySheetPageW (
    LPCPROPSHEETPAGEW psp
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HWND
WINAPI
CreateUpDownControl (
    DWORD dwStyle, int x, int y, int cx, int cy,
    HWND hParent, int nID, HINSTANCE hInst,
    HWND hBuddy,
    int nUpper, int nLower, int nPos
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
DestroyPropertySheetPage (
    HPROPSHEETPAGE hpage
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_Add (
    HIMAGELIST himl,
    HBITMAP hbmImage,
    HBITMAP hbmMask
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Create (
    int cx, int cy, UINT flags, int cInitial, int cGrow
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Destroy (
    HIMAGELIST himl
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Draw (
    HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Duplicate (
    HIMAGELIST himl
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HICON
WINAPI
ImageList_GetIcon (
    HIMAGELIST himl, int i, UINT flags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_GetIconSize (
    HIMAGELIST himl, int FAR *cx, int FAR *cy
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_LoadImageA (
    HINSTANCE hi,
    LPCSTR lpbmp,
    int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_LoadImageW (
    HINSTANCE hi,
    LPCWSTR lpbmp,
    int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI ImageList_Remove(
    HIMAGELIST himl, 
    int i
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_ReplaceIcon (
    HIMAGELIST himl, int i, HICON hicon
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
COLORREF
WINAPI
ImageList_SetBkColor (
    HIMAGELIST himl,
    COLORREF clrBk
    )
{
    return CLR_NONE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_SetOverlayImage (
    HIMAGELIST himl,
    int iImage,
    int iOverlay
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI InitCommonControls (
    void
    )
{
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
InitCommonControlsEx (
    LPINITCOMMONCONTROLSEX icce
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
INT_PTR
WINAPI
PropertySheetW (
    LPCPROPSHEETHEADERW psh
    )
{
    return -1;
}

static
LRESULT
WINAPI
DefSubclassProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return 0;
}

static
WINCOMMCTRLAPI
int
WINAPI
DSA_InsertItem(
    HDSA hdsa,
    int i,
    void *pitem
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
void
WINAPI
DSA_DestroyCallback(
    HDSA hdsa,
    PFNDSAENUMCALLBACK pfnCB,
    void *pData
    )
{
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
Str_SetPtrW(
    LPWSTR * ppsz,
    LPCWSTR psz
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void*
WINAPI
DPA_DeletePtr(
    HDPA hdpa,
    int i
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
int
WINAPI
DPA_InsertPtr(
    HDPA hdpa,
    int i,
    void *p)
{
    return -1;
}

static
WINCOMMCTRLAPI
BOOL  
WINAPI
DPA_DeleteAllPtrs(
    HDPA hdpa
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
INT_PTR
WINAPI
PropertySheetA(
    LPCPROPSHEETHEADERA psh
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
void*
WINAPI
DSA_GetItemPtr(
    HDSA hdsa,
    int i
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
DPA_Destroy(
    HDPA hdpa
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HDPA
WINAPI
DPA_Create(
    int cItemGrow
    )
{
    return NULL;
}

static
BOOL
WINAPI
SetWindowSubclass(
    HWND hWnd,
    SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData
    )
{
    return FALSE;
}

static
BOOL
WINAPI
RemoveWindowSubclass(
    HWND hWnd,
    SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HDSA
WINAPI
DSA_Create(
    int cbItem,
    int cItemGrow
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_DrawIndirect(
    IMAGELISTDRAWPARAMS* pimldp
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI
DoReaderMode(
    PREADERMODEINFO prmi
    )
{
    return;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(comctl32)
{
    DLOENTRY(16, CreateUpDownControl)
    DLOENTRY(17, InitCommonControls)
    DLOENTRY(236, Str_SetPtrW)
    DLOENTRY(320, DSA_Create)
    DLOENTRY(323, DSA_GetItemPtr)
    DLOENTRY(324, DSA_InsertItem)
    DLOENTRY(328, DPA_Create)
    DLOENTRY(329, DPA_Destroy)
    DLOENTRY(334, DPA_InsertPtr)
    DLOENTRY(336, DPA_DeletePtr)
    DLOENTRY(337, DPA_DeleteAllPtrs)
    DLOENTRY(383, DoReaderMode)
    DLOENTRY(388, DSA_DestroyCallback)
    DLOENTRY(410, SetWindowSubclass)
    DLOENTRY(412, RemoveWindowSubclass)
    DLOENTRY(413, DefSubclassProc)
};

DEFINE_ORDINAL_MAP(comctl32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comctl32)
{
    DLPENTRY(CreatePropertySheetPageW)
    DLPENTRY(DestroyPropertySheetPage)
    DLPENTRY(ImageList_Add)
    DLPENTRY(ImageList_Create)
    DLPENTRY(ImageList_Destroy)
    DLPENTRY(ImageList_Draw)
    DLPENTRY(ImageList_DrawIndirect)
    DLPENTRY(ImageList_Duplicate)
    DLPENTRY(ImageList_GetIcon)
    DLPENTRY(ImageList_GetIconSize)
    DLPENTRY(ImageList_LoadImageA)
    DLPENTRY(ImageList_LoadImageW)
    DLPENTRY(ImageList_Remove)
    DLPENTRY(ImageList_ReplaceIcon)
    DLPENTRY(ImageList_SetBkColor)
    DLPENTRY(ImageList_SetOverlayImage)
    DLPENTRY(InitCommonControlsEx)
    DLPENTRY(PropertySheetA)
    DLPENTRY(PropertySheetW)
};

DEFINE_PROCNAME_MAP(comctl32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\lz32.c ===
#include "shellpch.h"
#pragma hdrstop

#include <lzexpand.h>

static
VOID
APIENTRY
LZClose (
    INT oLZFile
    )
{
}

static
LONG
APIENTRY
LZCopy (
    INT doshSource,
    INT doshDest
    )
{
    return LZERROR_BADINHANDLE;
}

static
INT
APIENTRY
LZOpenFileW (
    LPWSTR lpFileName,
    LPOFSTRUCT lpReOpenBuf,
    WORD wStyle
    )
{
    return LZERROR_BADINHANDLE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(lz32)
{
    DLPENTRY(LZClose)
    DLPENTRY(LZCopy)
    DLPENTRY(LZOpenFileW)
};

DEFINE_PROCNAME_MAP(lz32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\mlang.c ===
#include "shellpch.h"
#pragma hdrstop

#include <objbase.h>
#include <mlang.h>

#undef STDAPI
#define STDAPI          HRESULT STDAPICALLTYPE


static
STDAPI
ConvertINetUnicodeToMultiByte(
    LPDWORD lpdwMode,
    DWORD dwEncoding,
    LPCWSTR lpSrcStr,
    LPINT lpnWideCharCount,
    LPSTR lpDstStr,
    LPINT lpnMultiCharCount
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ConvertINetMultiByteToUnicode(
    LPDWORD lpdwMode,
    DWORD dwEncoding,
    LPCSTR lpSrcStr,
    LPINT lpnMultiCharCount,
    LPWSTR lpDstStr,
    LPINT lpnWideCharCount)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
LcidToRfc1766A(
    LCID Locale,
    LPSTR pszRfc1766,
    int iMaxLength)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
} 

static
STDAPI
Rfc1766ToLcidW(
    LCID *pLocale,
    LPCWSTR pszRfc1766
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
} 

static
STDAPI
LcidToRfc1766W(
    LCID Locale,
    LPWSTR pszRfc1766,
    int nChar
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(mlang)
{
    DLOENTRY(112, ConvertINetUnicodeToMultiByte)
    DLOENTRY(113, ConvertINetMultiByteToUnicode)
    DLOENTRY(120, LcidToRfc1766A)
    DLOENTRY(121, LcidToRfc1766W)
    DLOENTRY(123, Rfc1766ToLcidW)
};

DEFINE_ORDINAL_MAP(mlang)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\linkinfo.c ===
#include "shellpch.h"
#pragma hdrstop

#define _LINKINFO_
#include <linkinfo.h>

static
LINKINFOAPI
BOOL
WINAPI
CreateLinkInfoW(
                LPCWSTR psz,
                PLINKINFO* pli
                )
{
    return FALSE;
}

static
LINKINFOAPI
BOOL
WINAPI
GetLinkInfoData(
    PCLINKINFO pcli,
    LINKINFODATATYPE lidt,
    const VOID** ppv
    )
{
    return FALSE;
}

static
LINKINFOAPI
BOOL
WINAPI
IsValidLinkInfo(
    PCLINKINFO pcli
    )
{
    // If you can't load LinkInfo then just declare all linkinfo structures
    // invalid because you can't use them anyway
    return FALSE;
}

static
LINKINFOAPI
BOOL
WINAPI
ResolveLinkInfoW(
    PCLINKINFO pcli,
    LPWSTR pszResolvedPathBuf,
    DWORD dwInFlags,
    HWND hwndOwner,
    PDWORD pdwOutFlags,
    PLINKINFO *ppliUpdated
    )
{
    return FALSE;
}

static
LINKINFOAPI
void
WINAPI
DestroyLinkInfo(
    PLINKINFO pli
    )
{
    // leak it since it comes from a private heap
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(linkinfo)
{
    DLPENTRY(CreateLinkInfoW)
    DLPENTRY(DestroyLinkInfo)
    DLPENTRY(GetLinkInfoData)
    DLPENTRY(IsValidLinkInfo)
    DLPENTRY(ResolveLinkInfoW)
};

DEFINE_PROCNAME_MAP(linkinfo)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\ntshrui.c ===
#include "shellpch.h"
#pragma hdrstop

#include <msshrui.h>


static
BOOL
WINAPI
IsFolderPrivateForUser(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    )
{
    if (ppszInheritanceSource)
    {
        *ppszInheritanceSource = NULL;
    }

    return FALSE;
}

static
BOOL
WINAPI
SetFolderPermissionsForSharing(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntshrui)
{
    DLPENTRY(IsFolderPrivateForUser)
    DLPENTRY(SetFolderPermissionsForSharing)
};

DEFINE_PROCNAME_MAP(ntshrui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\powrprof.c ===
#include "shellpch.h"
#pragma hdrstop

#include <powrprof.h>

BOOLEAN WINAPI SetSuspendState(
    BOOLEAN bHibernate,
    BOOLEAN bForce,
    BOOLEAN bWakeupEventsDisabled
    )
{
    return FALSE;
}

BOOLEAN WINAPI IsPwrHibernateAllowed()
{
    return FALSE;
}

BOOLEAN WINAPI IsPwrSuspendAllowed()
{
    return FALSE;
}

BOOLEAN WINAPI IsPwrShutdownAllowed()
{
    return FALSE;
}

BOOLEAN WINAPI GetActivePwrScheme(
    PUINT puiID
    )
{
    return FALSE;
}

BOOLEAN WINAPI SetActivePwrScheme(
    UINT uiID,
    PGLOBAL_POWER_POLICY pgpp,
    PPOWER_POLICY ppp
    )
{
    return FALSE;
}

BOOLEAN WINAPI ReadPwrScheme(
    UINT uiID,
    PPOWER_POLICY ppp
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(powrprof)
{
    DLPENTRY(GetActivePwrScheme)
    DLPENTRY(IsPwrHibernateAllowed)
    DLPENTRY(IsPwrShutdownAllowed)
    DLPENTRY(IsPwrSuspendAllowed)
    DLPENTRY(ReadPwrScheme)
    DLPENTRY(SetActivePwrScheme)
    DLPENTRY(SetSuspendState)
};

DEFINE_PROCNAME_MAP(powrprof)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\shellpch.h ===
#pragma once

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4211) // nonstandard extension used : redefined extern to static


#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\shdocvw.c ===
#include "shellpch.h"
#pragma hdrstop

#define _SHDOCVW_
#include <shlobj.h>
#include <shlobjp.h>
#include <objidl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <shdocvw.h>
#include <subsmgr.h>
#include <mshtml.h>

#undef SHDOCAPI
#define SHDOCAPI            HRESULT STDAPICALLTYPE
#undef SHDOCAPI_
#define SHDOCAPI_(type)     type STDAPICALLTYPE
#undef SHSTDDOCAPI_
#define SHSTDDOCAPI_(type)  type STDAPICALLTYPE


static
SHDOCAPI_(IStream *)
OpenPidlOrderStream(
    LPCITEMIDLIST pidlRoot,
    LPCITEMIDLIST pidl,
    LPCSTR pszKey,
    DWORD grfMode
    )
{
    return NULL;
}

static
SHDOCAPI_(BOOL)
IEIsLinkSafe(
    HWND hwnd,
    LPCITEMIDLIST pidl,
    ILS_ACTION ilsFlag
    )
{
    return FALSE;
}

static
SHDOCAPI
DragDrop(
    HWND hwnd,
    IShellFolder * psfParent,
    LPCITEMIDLIST pidl,
    DWORD dwPrefEffect,
    DWORD *pdwEffect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IECreateFromPathCPWithBCW(
    UINT uiCP,
    LPCWSTR pszPath,
    IBindCtx * pbc,
    LPITEMIDLIST *ppidlOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
ILIsWeb(
    LPCITEMIDLIST pidl
    )
{
    return FALSE;
}

static
SHDOCAPI
IECreateFromPathCPWithBCA(
    UINT uiCP,
    LPCSTR pszPath,
    IBindCtx * pbc,
    LPITEMIDLIST *ppidlOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
SHGetIDispatchForFolder(
    LPCITEMIDLIST pidl,
    IWebBrowserApp **ppauto
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
ParseURLFromOutsideSourceW(
    LPCWSTR psz,
    LPWSTR pszOut,
    LPDWORD pcchOut,
    LPBOOL pbWasSearchURL
    )
{
    return FALSE;
}

static
SHDOCAPI_(IShellWindows *)
WinList_GetShellWindows(
    BOOL fForceMarshalled
    )
{
    return NULL;
}

static
SHDOCAPI_(IStream*)
SHGetViewStream(
    LPCITEMIDLIST pidl,
    DWORD grfMode,
    LPCWSTR pszName,
    LPCWSTR pszStreamMRU,
    LPCWSTR pszStreams
    )
{
    return NULL;
}

static
SHDOCAPI_(void)
IEOnFirstBrowserCreation(
    IUnknown* punkAuto
    )
{
}

static
SHDOCAPI_(DWORD)
SHRestricted2W(
    BROWSER_RESTRICTIONS rest,
    LPCWSTR pwzUrl,
    DWORD dwReserved
    )
{
    return 0;
}

static
SHDOCAPI
IEBindToObject(
    LPCITEMIDLIST pidl,
    IShellFolder **ppsfOut
    )
{
    *ppsfOut = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IEGetAttributesOf(
    LPCITEMIDLIST pidl,
    DWORD* pdwAttribs
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
NavToUrlUsingIEW(
    LPCWSTR wszUrl,
    BOOL fNewWindow
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
URLSubLoadString(
    HINSTANCE hInst,
    UINT idRes,
    LPWSTR pszUrlOut, 
    DWORD cchSizeOut,
    DWORD dwSubstitutions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IEParseDisplayNameWithBCW(
    UINT uiCP,
    LPCWSTR pwszPath,
    IBindCtx * pbc,
    LPITEMIDLIST * ppidlOut
    )
{
    *ppidlOut = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(DWORD)
SoftwareUpdateMessageBox(
    HWND hWnd,
    LPCWSTR szDistUnit,
    DWORD dwFlags,
    LPSOFTDISTINFO psdi
    )
{
    return IDABORT;
}

static
SHDOCAPI_(BOOL)
IsURLChild(
    LPCITEMIDLIST pidl,
    BOOL fIncludeHome
    )
{
    return FALSE;
}

static
SHDOCAPI_(void)
IEInvalidateImageList()
{
}

static
SHDOCAPI_(BOOL)
DoOrganizeFavDlgW(
    HWND hwnd,
    LPWSTR pszInitDir
    )
{
    return FALSE;
}

static
SHDOCAPI
URLSubstitution(
    LPCWSTR pszUrlIn,
    LPWSTR pszUrlOut,
    DWORD cchSize,
    DWORD dwSubstitutions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
SHDGetPageLocation(
    HWND hwndOwner,
    UINT idp,
    LPWSTR pszPath,
    UINT cchMax,
    LPITEMIDLIST *ppidlOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
ResetWebSettings(
    HWND hwnd,
    BOOL *pfChangedHomePage
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
SHIsRestricted2W(
    HWND hwnd,
    BROWSER_RESTRICTIONS rest,
    LPCWSTR pwzUrl,
    DWORD dwReserved
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
SHIsRegisteredClient(
    LPCWSTR pszClient
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
IsResetWebSettingsRequired()
{
    return FALSE;
}

static
SHSTDDOCAPI_(LPNMVIEWFOLDER)
DDECreatePostNotify(
    LPNMVIEWFOLDER lpnm
    )
{
    return NULL;
}

static
SHDOCAPI
IEGetDisplayName(
    LPCITEMIDLIST pidl,
    LPWSTR pszName,
    UINT uFlags
    )
{
    if (pszName)
    {
        *pszName = L'0';
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
WinList_FindFolderWindow(
    LPCITEMIDLIST pidl,
    LPCITEMIDLIST pidlRoot,
    HWND *phwnd,
    IWebBrowserApp **ppauto
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(void)
FireEvent_Quit(
    IExpDispSupport *peds
    )
{
}

static
SHSTDDOCAPI_(BOOL)
DDEHandleViewFolderNotify(
    IShellBrowser* psb,
    HWND hwnd,
    LPNMVIEWFOLDER lpnm
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
IEDDE_WindowDestroyed(
    HWND hwnd
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
IEDDE_NewWindow(
    HWND hwnd
    )
{
    return FALSE;
}

static
SHDOCAPI_(void)
EnsureWebViewRegSettings()
{
}

static
SHDOCAPI
WinList_RegisterPending(
    DWORD dwThread,
    LPCITEMIDLIST pidl,
    LPCITEMIDLIST pidlRoot,
    long *pdwRegister
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
WinList_NotifyNewLocation(
    IShellWindows* psw,
    long dwRegister,
    LPCITEMIDLIST pidl
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(void)
_DeletePidlDPA(
    HDPA hdpa
    )
{
}

static
SHDOCAPI_(BOOL)
IsIEDefaultBrowser()
{
    return TRUE;
}

static
SHDOCAPI_(BOOL)
PathIsFilePath(
    LPCWSTR lpszPath
    )
{
    return TRUE;
}

static
SHDOCAPI_(BOOL)
SHUseClassicToolbarGlyphs()
{
    return FALSE;
}

static
HRESULT
PrepareURLForDisplayUTF8W(
    LPCWSTR pwz,
    LPWSTR pwzOut,
    LPDWORD pcbOut,
    BOOL fUTF8Enabled
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
IsErrorUrl(
    LPCWSTR pwszDisplayName
    )
{
    return FALSE;
}

static
SHDOCAPI
CShellUIHelper_CreateInstance2(
    IUnknown** ppunk,
    REFIID riid, 
    IUnknown *pSite,
    IDispatch *pExternalDisp
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
GetLinkInfo(
    IShellFolder* psf,
    LPCITEMIDLIST pidlItem,
    BOOL* pfAvailable,
    BOOL* pfSticky
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(int)
IEMapPIDLToSystemImageListIndex(
    IShellFolder *psfParent,
    LPCITEMIDLIST pidlChild,
    int *piSelectedImage
    )
{
    return -1;
}

static
SHDOCAPI
CreateShortcutInDirW(
    IN LPCITEMIDLIST pidlTarget,
    IN LPWSTR pwzTitle,
    IN LPCWSTR pwzDir, 
    OUT LPWSTR pwzOut,
    IN BOOL bUpdateProperties)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
_GetStdLocation(
    LPWSTR pszPath,
    DWORD cchPathSize,
    UINT id
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
long
SetQueryNetSessionCount(
    enum SessionOp Op
    )
{
    return 0;
}

static
SHDOCAPI_(void)
IECleanUpAutomationObject()
{
}

static
SHDOCAPI_(BOOL)
IEILIsEqual(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2,
    BOOL fIgnoreHidden
    )
{
    return (pidl1 == pidl2);
}

static
SHDOCAPI_(BOOL)
GetDefaultInternetSearchUrlW(
    LPWSTR pwszUrl,
    int cchUrl,
    BOOL bSubstitute
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
GetSearchAssistantUrlW(
    LPWSTR pwszUrl,
    int cchUrl,
    BOOL bSubstitute,
    BOOL bCustomize
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
DllRegisterWindowClasses(
    const SHDRC * pshdrc
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
SHIsGlobalOffline()
{
    return FALSE;
}

static
SHDOCAPI
WinList_Revoke(
    long dwRegister
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
UrlHitsNetW(
    LPCWSTR pszURL
            )
{
    return TRUE;
}

static
SHDOCAPI
IURLQualify(
    LPCWSTR pcszURL,
    DWORD dwFlags,
    LPWSTR pszTranslatedURL,
    LPBOOL pbWasSearchURL,
    LPBOOL pbWasCorrected
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IEBindToObjectEx(
    LPCITEMIDLIST pidl,
    IBindCtx *pbc,
    REFIID riid,
    void **ppv
    )
{
    *ppv = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
IsFileUrl(
    LPCSTR psz
    )
{
    return FALSE;
}

static
SHDOCAPI
IEGetNameAndFlags(
    LPCITEMIDLIST pidl,
    UINT uFlags,
    LPWSTR pszName,
    DWORD cchName,
    DWORD *prgfInOutAttrs
    )
{
    if (pszName)
    {
        *pszName = 0;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(void)
IEWriteErrorLog(
    const EXCEPTION_RECORD* pexr
    )
{
}

static
SHDOCAPI
ResetProfileSharing(HWND hwin)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT ClearAutoSuggestForForms(DWORD dwClear)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static 
SHDOCAPI_(BOOL) 
ImportPrivacySettings(
       IN LPCWSTR szFilename,
       IN OUT BOOL* pfParsePrivacyPreferences,
       IN OUT BOOL* pfParsePerSiteRules)
{
    return FALSE;
}

static
SHDOCAPI SHAddSubscribeFavorite (
         HWND hwnd, 
         LPCWSTR pwszURL, 
         LPCWSTR pwszName, 
         DWORD dwFlags,
         SUBSCRIPTIONTYPE subsType, 
         SUBSCRIPTIONINFO* pInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT SearchForElementInHead(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired)   // [out] returned interface
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
DoFileDownload(
    LPCWSTR pwszURL
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
SafeOpenPromptForShellExec(
    HWND hwnd,
    PCWSTR pszFile
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
SafeOpenPromptForPackager(
    HWND hwnd,
    PCWSTR pszFile,
    BOOL bFromCommandLine
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shdocvw)
{
    DLOENTRY(103, CreateShortcutInDirW)
    DLOENTRY(116, DDECreatePostNotify)
    DLOENTRY(117, DDEHandleViewFolderNotify)
    DLOENTRY(135, IsFileUrl)
    DLOENTRY(137, PathIsFilePath)
    DLOENTRY(138, URLSubLoadString)
    DLOENTRY(139, OpenPidlOrderStream)
    DLOENTRY(140, DragDrop)
    DLOENTRY(141, IEInvalidateImageList)
    DLOENTRY(142, IEMapPIDLToSystemImageListIndex)
    DLOENTRY(143, ILIsWeb)
    DLOENTRY(145, IEGetAttributesOf)
    DLOENTRY(146, IEBindToObject)
    DLOENTRY(147, IEGetNameAndFlags)
    DLOENTRY(148, IEGetDisplayName)
    DLOENTRY(149, IEBindToObjectEx)
    DLOENTRY(150, _GetStdLocation)
    DLOENTRY(152, CShellUIHelper_CreateInstance2)
    DLOENTRY(153, IsURLChild)
    DLOENTRY(159, SHRestricted2W)
    DLOENTRY(160, SHIsRestricted2W)
    DLOENTRY(163, SHAddSubscribeFavorite)
    DLOENTRY(164, ResetProfileSharing)
    DLOENTRY(165, URLSubstitution)
    DLOENTRY(167, IsIEDefaultBrowser)
    DLOENTRY(170, ParseURLFromOutsideSourceW)
    DLOENTRY(171, _DeletePidlDPA)
    DLOENTRY(172, IURLQualify)
    DLOENTRY(174, SHIsGlobalOffline)
    DLOENTRY(176, EnsureWebViewRegSettings)
    DLOENTRY(177, WinList_NotifyNewLocation)
    DLOENTRY(178, WinList_FindFolderWindow)
    DLOENTRY(179, WinList_GetShellWindows)
    DLOENTRY(180, WinList_RegisterPending)
    DLOENTRY(181, WinList_Revoke)
    DLOENTRY(185, FireEvent_Quit)
    DLOENTRY(187, SHDGetPageLocation)
    DLOENTRY(191, SHIsRegisteredClient)
    DLOENTRY(194, IECleanUpAutomationObject)
    DLOENTRY(195, IEOnFirstBrowserCreation)
    DLOENTRY(196, IEDDE_WindowDestroyed)
    DLOENTRY(197, IEDDE_NewWindow)
    DLOENTRY(198, IsErrorUrl)
    DLOENTRY(200, SHGetViewStream)
    DLOENTRY(204, NavToUrlUsingIEW)
    DLOENTRY(208, SearchForElementInHead)
    DLOENTRY(210, UrlHitsNetW)
    DLOENTRY(211, ClearAutoSuggestForForms)
    DLOENTRY(212, GetLinkInfo)
    DLOENTRY(214, GetSearchAssistantUrlW)
    DLOENTRY(216, GetDefaultInternetSearchUrlW)
    DLOENTRY(218, IEParseDisplayNameWithBCW)
    DLOENTRY(219, IEILIsEqual)
    DLOENTRY(221, IECreateFromPathCPWithBCA)
    DLOENTRY(222, IECreateFromPathCPWithBCW)
    DLOENTRY(223, ResetWebSettings)
    DLOENTRY(224, IsResetWebSettingsRequired)
    DLOENTRY(225, PrepareURLForDisplayUTF8W)
    DLOENTRY(226, IEIsLinkSafe)
    DLOENTRY(227, SHUseClassicToolbarGlyphs)
    DLOENTRY(228, SafeOpenPromptForShellExec)
    DLOENTRY(229, SafeOpenPromptForPackager)
};

DEFINE_ORDINAL_MAP(shdocvw)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shdocvw)
{
    DLPENTRY(DllRegisterWindowClasses)
    DLPENTRY(DoFileDownload)
    DLPENTRY(DoOrganizeFavDlgW)
    DLPENTRY(IEWriteErrorLog)
    DLPENTRY(ImportPrivacySettings)
    DLPENTRY(SHGetIDispatchForFolder)
    DLPENTRY(SetQueryNetSessionCount)
    DLPENTRY(SoftwareUpdateMessageBox)
};

DEFINE_PROCNAME_MAP(shdocvw)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\msrating.c ===
#include "shellpch.h"
#pragma hdrstop

#include <ratings.h>

#undef STDAPI
#define STDAPI          HRESULT STDAPICALLTYPE


static
STDAPI
RatingObtainQuery(LPCSTR pszTargetUrl,
                  DWORD dwUserData,
                  void (*fCallback)(DWORD dwUserData,
                  HRESULT hr,
                  LPCSTR pszRating,
                  void *lpvRatingDetails),
                  HANDLE *phRatingObtainQuery)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingEnabledQuery()
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingFreeDetails(void *pRatingDetails)
{
    return NOERROR;
}

static
STDAPI
RatingAccessDeniedDialog2(HWND hDlg,
                          LPCSTR pszUsername,
                          void *pRatingDetails)
{
    return S_FALSE;
}

static
STDAPI
RatingCustomDeleteCrackedData(struct RATINGBLOCKINGINFO* prblInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingCustomCrackData(LPCSTR pszUsername,
                      void* pvRatingDetails,
                      struct RATINGBLOCKINGINFO** pprbInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingCheckUserAccess(LPCSTR pszUsername,
                      LPCSTR pszURL,
                      LPCSTR pszRatingInfo,
                      LPBYTE pData,
                      DWORD cbData,
                      void **ppRatingDetails)
{
    if (ppRatingDetails)
    {
        *ppRatingDetails = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingObtainCancel(HANDLE hRatingObtainQuery)
{
    return E_HANDLE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msrating)
{
    DLPENTRY(RatingAccessDeniedDialog2)
    DLPENTRY(RatingCheckUserAccess)
    DLPENTRY(RatingCustomCrackData)
    DLPENTRY(RatingCustomDeleteCrackedData)
    DLPENTRY(RatingEnabledQuery)
    DLPENTRY(RatingFreeDetails)
    DLPENTRY(RatingObtainCancel)
    DLPENTRY(RatingObtainQuery)
};

DEFINE_PROCNAME_MAP(msrating)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\netplwiz.c ===
#include "shellpch.h"
#pragma hdrstop

#undef STDAPI_
#define STDAPI_(type)           type STDAPICALLTYPE

static
STDAPI_(DWORD)
NetPlacesWizardDoModal(
    LPCONNECTDLGSTRUCTW  lpConnDlgStruct,
    DWORD                npwt,
    BOOL                 fIsROPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
STDAPI_(DWORD)
SHDisconnectNetDrives(
    HWND hwndParent
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netplwiz)
{
    DLPENTRY(NetPlacesWizardDoModal)
    DLPENTRY(SHDisconnectNetDrives)
};

DEFINE_PROCNAME_MAP(netplwiz)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\shell32.c ===
#include "shellpch.h"
#pragma hdrstop

#define _SHELL32_
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

#undef SHSTDAPI
#define SHSTDAPI        HRESULT STDAPICALLTYPE
#undef SHSTDAPI_
#define SHSTDAPI_(type) type STDAPICALLTYPE

static
WINSHELLAPI
UINT
WINAPI
ExtractIconExW (
    LPCWSTR lpszFile,
    int nIconIndex,
    HICON FAR *phiconLarge,
    HICON FAR *phiconSmall,
    UINT nIcons)
{
    return 0;
}

static
WINSHELLAPI
UINT
WINAPI
ExtractIconExA (
    LPCSTR lpszFile,
    int nIconIndex,
    HICON FAR *phiconLarge,
    HICON FAR *phiconSmall,
    UINT nIcons)
{
    return 0;
}

static
HINSTANCE
WINAPI
FindExecutableA (
    LPCSTR lpFile, 
    LPCSTR lpDirectory, 
    LPSTR lpResult
    )
{
    return 0;
}

static
HINSTANCE 
WINAPI
FindExecutableW (
    LPCWSTR lpFile, 
    LPCWSTR lpDirectory, 
    LPWSTR lpResult
    )
{
    return 0;
}

static
int
WINAPI
RestartDialog (
    HWND hParent,
    LPCTSTR lpPrompt,
    DWORD dwReturn
    )
{
    return IDNO;
}

static
int
WINAPI
RestartDialogEx (
    HWND hParent,
    LPCTSTR lpPrompt,
    DWORD dwReturn,
    DWORD ReasonCode
    )
{
    return IDNO;
}

static
LPITEMIDLIST
WINAPI
SHBrowseForFolderW (
    LPBROWSEINFOW lpbi
    )
{
    return NULL;
}

static
LPITEMIDLIST
WINAPI
SHBrowseForFolderA (
    LPBROWSEINFOA lpbi
    )
{
    return NULL;
}

static
void
STDAPICALLTYPE
SHChangeNotify(
    LONG wEventId,
    UINT uFlags,
    LPCVOID dwItem1,
    LPCVOID dwItem2)
{
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathA (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathW (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetMalloc (
    LPMALLOC * ppMalloc
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetPathFromIDListW (
    LPCITEMIDLIST   pidl,
    LPWSTR          pszPath
    )
{
    return FALSE;
}

static
BOOL
STDAPICALLTYPE
SHGetPathFromIDListA (
    LPCITEMIDLIST   pidl,
    LPSTR           pszPath
    )
{
    return FALSE;
}

static
HRESULT
STDAPICALLTYPE
SHGetSpecialFolderLocation (
    HWND hwnd,
    int csidl,
    LPITEMIDLIST *ppidl
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetSpecialFolderPathW(
    HWND hwnd,
    LPWSTR pszPath,
    int csidl,
    BOOL fCreate)
{
    return FALSE;
}

static
WINSHELLAPI
INT
WINAPI
ShellAboutW(
    HWND hwnd,
    LPCWSTR szApp,
    LPCWSTR szOtherStuff,
    HICON hIcon
    )
{
    return FALSE;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteA (
    HWND hwnd,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}

static
WINSHELLAPI
BOOL
WINAPI
ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo)
{
    return FALSE;
}

static
WINSHELLAPI
BOOL
WINAPI
ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo)
{
    return FALSE;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteW (
    HWND hwnd,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}

static
int 
ShellMessageBoxW(
    HINSTANCE hInst, 
    HWND hWnd, 
    LPCWSTR pszMsg, 
    LPCWSTR pszTitle, 
    UINT fuStyle, 
    ...
    )
{
    return -1;
}

static
BOOL
WINAPI
LinkWindow_RegisterClass()
{
    return FALSE;
}

static
BOOL 
WINAPI 
LinkWindow_UnregisterClass(
    HINSTANCE hInst
    )
{
    return FALSE;
}

static
UINT
WINAPI
DragQueryFileA(
    HDROP hDrop,
    UINT wFile,
    LPSTR lpFile,
    UINT cb
    )
{
    return wFile;
}

static
UINT
WINAPI
DragQueryFileW(
    HDROP hDrop,
    UINT wFile,
    LPWSTR lpFile,
    UINT cb
    )
{
    return wFile;
}

static
HRESULT
WINAPI
SHDefExtractIconA(
    LPCSTR pszIconFile,
    int iIndex,
    UINT uFlags,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
SHDefExtractIconW(
    LPCWSTR pszIconFile,
    int iIndex,
    UINT uFlags,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
SHGetNewLinkInfoA(
    LPCSTR pszLinkTo,
    LPCSTR pszDir,
    LPSTR pszName,
    BOOL* pfMustCopy,
    UINT uFlags
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SHGetNewLinkInfoW(
    LPCWSTR pszLinkTo,
    LPCWSTR pszDir,
    LPWSTR pszName,
    BOOL* pfMustCopy,
    UINT uFlags
    )
{
    return FALSE;
}

static
HICON
WINAPI
ExtractIconA(
    HINSTANCE hInst,
    LPCSTR lpszExeFileName,
    UINT nIconIndex
    )
{
    return NULL;
}

static
HICON
WINAPI
ExtractIconW(
    HINSTANCE hInst,
    LPCWSTR lpszExeFileName,
    UINT nIconIndex
    )
{
    return NULL;
}

static
DWORD_PTR
WINAPI
SHGetFileInfoA(
    LPCSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOA *psfi,
    UINT cbFileInfo,
    UINT uFlags
    )
{
    return 0;
}

static
DWORD_PTR
WINAPI
SHGetFileInfoW(
    LPCWSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOW *psfi,
    UINT cbFileInfo,
    UINT uFlags
    )
{
    return 0;
}

static
DWORD
WINAPI
SHFormatDrive(
    HWND hwnd,
    UINT drive,
    UINT fmtID,
    UINT options
    )
{
    return SHFMT_ERROR;
}

static
int
WINAPI
DriveType(
    int iDrive
    )
{
    return DRIVE_UNKNOWN;
}

static
int
WINAPI
RealDriveType(
    int iDrive,
    BOOL fOKToHitNet
    )
{
    return DRIVE_UNKNOWN;
}

static
void
WINAPI
ILFree(
    LPITEMIDLIST pidl
    )
{
}

static
LPITEMIDLIST
WINAPI
ILClone(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
BOOL
WINAPI
ILIsEqual(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
{
    return (pidl1 == pidl2);
}

static
HRESULT
WINAPI
SHGetDesktopFolder(
    IShellFolder** ppshf
    )
{
    *ppshf = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
int
WINAPI
Shell_GetCachedImageIndex(
    LPCTSTR pszIconPath,
    int iIconIndex,
    UINT uIconFlags
    )
{
    return -1;
}

static
int
WINAPI
SHFileOperationA(
    LPSHFILEOPSTRUCTA lpFileOp
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
int
WINAPI
SHFileOperationW(
    LPSHFILEOPSTRUCTW lpFileOp
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
int
WINAPI
IsNetDrive(
    int iDrive
    )
{
    return 0;
}

static
UINT
WINAPI
ILGetSize(
    LPCITEMIDLIST pidl
    )
{
    return 0;
}

static
void
WINAPI
SHFlushSFCache()
{
}

static
HRESULT
WINAPI
SHCoCreateInstance(
    LPCTSTR pszCLSID,
    const CLSID *pclsid,
    IUnknown *pUnkOuter,
    REFIID riid,
    void** ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}

static
HRESULT
WINAPI
SHGetInstanceExplorer(
    IUnknown** ppunk
    )
{
    *ppunk = NULL;
    return E_FAIL;
}

static
HRESULT
WINAPI
SHGetDataFromIDListW(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    int nFormat,
    void* pv,
    int cb
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
SHBindToParent(
    LPCITEMIDLIST pidl,
    REFIID riid,
    void** ppv,
    LPCITEMIDLIST* ppidlLast
    )
{
    *ppv = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(void)
SHFree(
    void* pv
    )
{
}

static
SHSTDAPI_(void)
SHGetSetSettings(
    LPSHELLSTATE lpss,
    DWORD dwMask,
    BOOL bSet
    )
{
    ZeroMemory(lpss, sizeof(SHELLSTATE));
}

static
SHSTDAPI_(BOOL)
Shell_GetImageLists(
    HIMAGELIST *phiml,
    HIMAGELIST *phimlSmall
    )
{
    if (phiml)
    {
        *phiml = NULL;
    }

    if (phimlSmall)
    {
        *phimlSmall = NULL;
    }

    return FALSE;
}

static
SHSTDAPI_(BOOL) 
Shell_NotifyIconW(
    DWORD dwMessage, 
    NOTIFYICONDATAW *pnid
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragEnterEx2(
    HWND hwndTarget,
    const POINT ptStart,
    IDataObject *pdtObject
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragMove(
    POINT pt
    )
{
    return FALSE;
}

static
SHSTDAPI
SHGetDataFromIDListA(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    int nFormat,
    void* pv,
    int cb
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LPITEMIDLIST)
ILCombine(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
{
    return NULL;
}

static
SHSTDAPI
SHDoDragDrop(
    HWND hwnd,
    IDataObject *pdata,
    IDropSource *pdsrc,
    DWORD dwEffect,
    DWORD *pdwEffect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHLoadOLE(
    LPARAM lParam
    )
{
    return S_OK;
}

static
SHSTDAPI_(void)
SHSetInstanceExplorer(
    IUnknown *punk
    )
{
}

static
SHSTDAPI
SHCreateStdEnumFmtEtc(
    UINT cfmt,
    const FORMATETC afmt[],
    IEnumFORMATETC **ppenumFormatEtc
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
ILLoadFromStream(
    IStream *pstm,
    LPITEMIDLIST *pidl
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(UINT)
Shell_MergeMenus(
    HMENU hmDst,
    HMENU hmSrc,
    UINT uInsert,
    UINT uIDAdjust,
    UINT uIDAdjustMax,
    ULONG uFlags
    )
{
    return uIDAdjust;
}

static 
SHSTDAPI_(LPITEMIDLIST)
ILCloneFirst(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
SHSTDAPI_(DWORD)
SHRestricted(
    RESTRICTIONS rest
    )
{
    return 0;
}

static
SHSTDAPI
SHStartNetConnectionDialogW(
    HWND hwnd,
    LPCWSTR pszRemoteName,
    DWORD dwType
    )
{
    return S_OK;
}

static
SHSTDAPI_(BOOL)
SHChangeNotifyDeregister(
    unsigned long ulID
    )
{
    return FALSE;
}

static
SHSTDAPI
SHFlushClipboard()
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LPITEMIDLIST)
ILFindChild(
    LPCITEMIDLIST pidlParent, 
    LPCITEMIDLIST pidlChild
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
ILIsParent(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2,
    BOOL fImmediate
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
ILRemoveLastID(
    LPITEMIDLIST pidl
    )
{
    return FALSE;
}

static
SHSTDAPI_(IContextMenu*)
SHFind_InitMenuPopup(
    HMENU hmenu,
    HWND hwndOwner,
    UINT idCmdFirst,
    UINT idCmdLast
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
SHChangeNotification_Unlock(
    HANDLE hLock
    )
{
    return FALSE;
}

static
SHSTDAPI_(HANDLE)
SHChangeNotification_Lock(
    HANDLE hChangeNotification,
    DWORD dwProcessId,
    LPITEMIDLIST **pppidl,
    LONG *plEvent
    )
{
    return NULL;
}

static
SHSTDAPI
SHGetRealIDL(
    IShellFolder *psf,
    LPCITEMIDLIST pidlSimple,
    LPITEMIDLIST * ppidlReal
    )
{
    *ppidlReal = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
ILSaveToStream(
    IStream *pstm,
    LPCITEMIDLIST pidl
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(BOOL)
DAD_ShowDragImage(
    BOOL fShow
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
SignalFileOpen(
    LPCITEMIDLIST pidl
    )
{
    return FALSE;
}

static
SHSTDAPI_(int)
SHMapPIDLToSystemImageListIndex(
    IShellFolder *pshf,
    LPCITEMIDLIST pidl,
    int *piIndexSel
    )
{
    return -1;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILGetNext(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
PathIsExe(
    LPCTSTR pszPath
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragLeave()
{
    return FALSE;
}

static
SHSTDAPI_(UINT_PTR)
SHAppBarMessage(
    DWORD dwMessage,
    PAPPBARDATA pData
    )
{
    return FALSE;
}

static
SHSTDAPI_(HICON)
ExtractAssociatedIconW(
     HINSTANCE hInst,
     LPWSTR lpIconPath,
     LPWORD lpiIconIndex
     )
{
    return NULL;
}

static
SHSTDAPI_(HICON)
ExtractAssociatedIconExW(
     HINSTANCE hInst,
     LPWSTR lpIconPath,
     LPWORD lpiIconIndex,
     LPWORD lpiIconId
     )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
DAD_AutoScroll(
    HWND hwnd,
    AUTO_SCROLL_DATA *pad,
    const POINT *pptNow
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_SetDragImage(
    HIMAGELIST him,
    POINT * pptOffset
    )
{
    return TRUE;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILAppendID(
    LPITEMIDLIST pidl,
    LPCSHITEMID pmkid,
    BOOL fAppend
    )
{
    return NULL;
}

static
SHSTDAPI_(int)
SHHandleUpdateImage(
    LPCITEMIDLIST pidlExtra
    )
{
    return -1;
}

static
SHSTDAPI_(LPITEMIDLIST)
SHCloneSpecialIDList(
    HWND hwnd,
    int csidl,
    BOOL fCreate
    )
{
    return NULL;
}

static
SHSTDAPI_(INT)
ShellAboutA(
    HWND hWnd,
    LPCSTR szApp,
    LPCSTR szOtherStuff,
    HICON hIcon
    )
{
    return 0;
}

static
SHSTDAPI_(int)
SHCreateDirectory(
    HWND hwnd,
    LPCTSTR pszPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
SHSTDAPI_(int)
PathCleanupSpec(
    LPCTSTR pszDir,
    LPTSTR pszSpec
    )
{
    return 0;
}

static
SHSTDAPI_(void *)
SHAlloc(
    SIZE_T cb
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
ReadCabinetState(
    LPCABINETSTATE lpState,
    int iSize
    )
{
    return FALSE;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILCreateFromPathA(
    LPCSTR pszPath
    )
{
    return NULL;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILCreateFromPathW(
    LPCWSTR pszPath
    )
{
    return NULL;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILFindLastID(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
WriteCabinetState(
    LPCABINETSTATE lpState
    )
{
    return FALSE;
}

static
SHSTDAPI_(void)
SHUpdateImageW(
    LPCWSTR pszHashItem,
    int iIndex,
    UINT uFlags,
    int iImageIndex
    )
{
}

static
SHSTDAPI
SHLimitInputEdit(
    HWND hwndEdit,
    IShellFolder *psf
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHPathPrepareForWriteW(
    HWND hwnd,
    IUnknown *punkEnableModless,
    LPCWSTR pszPath,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHSetLocalizedName(
    LPWSTR pszPath,
    LPCWSTR pszResModule,
    int idsRes
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHLoadInProc(
    REFCLSID rclsid
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LONG)
PathProcessCommand(
    LPCTSTR lpSrc,
    LPTSTR lpDest,
    int iMax,
    DWORD dwFlags
    )
{
    return -1;
}

static
WINSHELLAPI
HRESULT
STDAPICALLTYPE
SHCLSIDFromString(
    LPCTSTR lpsz,
    LPCLSID lpclsid
    )
{
    ZeroMemory(lpclsid, sizeof(CLSID));
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHILCreateFromPath(
    LPCTSTR szPath,
    LPITEMIDLIST *ppidl,
    DWORD *rgfInOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LPITEMIDLIST)
SHSimpleIDListFromPath(
    LPCTSTR pszPath
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
GetFileNameFromBrowse(
    HWND hwnd,
    LPTSTR pszFilePath,
    UINT cbFilePath,
    LPCTSTR pszWorkingDir,
    LPCTSTR pszDefExt,
    LPCTSTR pszFilters,
    LPCTSTR pszTitle
    )
{
    return FALSE;
}

static
SHSTDAPI_(IStream*)
OpenRegStream(
    HKEY hkey,
    LPCTSTR pszSubkey,
    LPCTSTR pszValue,
    DWORD grfMode
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
PathYetAnotherMakeUniqueName(
    LPTSTR pszUniqueName,
    LPCTSTR pszPath,
    LPCTSTR pszShort,
    LPCTSTR pszFileSpec
    )
{
    return FALSE;
}

static
WINSHELLAPI
int
WINAPI
PickIconDlg(
    HWND hwnd,
    LPTSTR pszIconPath,
    UINT cbIconPath,
    int *piIconIndex
    )
{
    return 0;
}

static
SHSTDAPI_(LRESULT)
SHShellFolderView_Message(
    HWND hwndMain,
    UINT uMsg,
    LPARAM lParam
    )
{
    return 0;
}

static
SHSTDAPI
SHCreateShellFolderViewEx(
    LPCSFV pcsfv,
    IShellView** ppsv
    )
{
    *ppsv = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(BOOL)
SHFindFiles(
    LPCITEMIDLIST pidlFolder,
    LPCITEMIDLIST pidlSaveFile
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragEnterEx(
    HWND hwndTarget,
    const POINT ptStart
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shell32)
{
    DLOENTRY(3, SHDefExtractIconA)
    DLOENTRY(4, SHChangeNotifyDeregister)
    DLOENTRY(6, SHDefExtractIconW)
    DLOENTRY(14, SHStartNetConnectionDialogW)
    DLOENTRY(16, ILFindLastID)
    DLOENTRY(17, ILRemoveLastID)
    DLOENTRY(18, ILClone)
    DLOENTRY(19, ILCloneFirst)
    DLOENTRY(21, ILIsEqual)
    DLOENTRY(22, DAD_DragEnterEx2)
    DLOENTRY(23, ILIsParent)
    DLOENTRY(24, ILFindChild)
    DLOENTRY(25, ILCombine)
    DLOENTRY(26, ILLoadFromStream)
    DLOENTRY(27, ILSaveToStream)
    DLOENTRY(28, SHILCreateFromPath)
    DLOENTRY(43, PathIsExe)
    DLOENTRY(59, RestartDialog)
    DLOENTRY(62, PickIconDlg)
    DLOENTRY(63, GetFileNameFromBrowse)
    DLOENTRY(64, DriveType)
    DLOENTRY(66, IsNetDrive)
    DLOENTRY(67, Shell_MergeMenus)
    DLOENTRY(68, SHGetSetSettings)
    DLOENTRY(71, Shell_GetImageLists)
    DLOENTRY(72, Shell_GetCachedImageIndex)
    DLOENTRY(73, SHShellFolderView_Message)
    DLOENTRY(74, SHCreateStdEnumFmtEtc)
    DLOENTRY(75, PathYetAnotherMakeUniqueName)
    DLOENTRY(77, SHMapPIDLToSystemImageListIndex)
    DLOENTRY(85, OpenRegStream)
    DLOENTRY(88, SHDoDragDrop)
    DLOENTRY(89, SHCloneSpecialIDList)
    DLOENTRY(90, SHFindFiles)
    DLOENTRY(98, SHGetRealIDL)
    DLOENTRY(100, SHRestricted)
    DLOENTRY(102, SHCoCreateInstance)
    DLOENTRY(103, SignalFileOpen)
    DLOENTRY(121, SHFlushClipboard)
    DLOENTRY(129, DAD_AutoScroll)
    DLOENTRY(131, DAD_DragEnterEx)
    DLOENTRY(132, DAD_DragLeave)
    DLOENTRY(134, DAD_DragMove)
    DLOENTRY(136, DAD_SetDragImage)
    DLOENTRY(137, DAD_ShowDragImage)
    DLOENTRY(147, SHCLSIDFromString)
    DLOENTRY(149, SHFind_InitMenuPopup)
    DLOENTRY(151, SHLoadOLE)
    DLOENTRY(152, ILGetSize)
    DLOENTRY(153, ILGetNext)
    DLOENTRY(154, ILAppendID)
    DLOENTRY(155, ILFree)
    DLOENTRY(157, ILCreateFromPathW)
    DLOENTRY(162, SHSimpleIDListFromPath)
    DLOENTRY(165, SHCreateDirectory)
    DLOENTRY(171, PathCleanupSpec)
    DLOENTRY(174, SHCreateShellFolderViewEx)
    DLOENTRY(175, SHGetSpecialFolderPathW)
    DLOENTRY(176, SHSetInstanceExplorer)
    DLOENTRY(179, SHGetNewLinkInfoA)
    DLOENTRY(180, SHGetNewLinkInfoW)
    DLOENTRY(182, ShellMessageBoxW)
    DLOENTRY(189, ILCreateFromPathA)
    DLOENTRY(190, ILCreateFromPathW)
    DLOENTRY(192, SHUpdateImageW)
    DLOENTRY(193, SHHandleUpdateImage)
    DLOENTRY(195, SHFree)
    DLOENTRY(196, SHAlloc)
    DLOENTRY(258, LinkWindow_RegisterClass)
    DLOENTRY(259, LinkWindow_UnregisterClass)
    DLOENTRY(524, RealDriveType)
    DLOENTRY(526, SHFlushSFCache)
    DLOENTRY(644, SHChangeNotification_Lock)
    DLOENTRY(645, SHChangeNotification_Unlock)
    DLOENTRY(652, WriteCabinetState)
    DLOENTRY(653, PathProcessCommand)
    DLOENTRY(654, ReadCabinetState)
    DLOENTRY(730, RestartDialogEx)
    DLOENTRY(747, SHLimitInputEdit)
};

DEFINE_ORDINAL_MAP(shell32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shell32)
{
    DLPENTRY(DragQueryFileA)
    DLPENTRY(DragQueryFileW)
    DLPENTRY(ExtractAssociatedIconExW)
    DLPENTRY(ExtractAssociatedIconW)
    DLPENTRY(ExtractIconA)
    DLPENTRY(ExtractIconExA)
    DLPENTRY(ExtractIconExW)
    DLPENTRY(ExtractIconW)
    DLPENTRY(FindExecutableA)
    DLPENTRY(FindExecutableW)
    DLPENTRY(SHAppBarMessage)
    DLPENTRY(SHBindToParent)
    DLPENTRY(SHBrowseForFolderA)
    DLPENTRY(SHBrowseForFolderW)
    DLPENTRY(SHChangeNotify)
    DLPENTRY(SHFileOperationA)
    DLPENTRY(SHFileOperationW)
    DLPENTRY(SHFormatDrive)
    DLPENTRY(SHGetDataFromIDListA)
    DLPENTRY(SHGetDataFromIDListW)
    DLPENTRY(SHGetDesktopFolder)
    DLPENTRY(SHGetFileInfoA)
    DLPENTRY(SHGetFileInfoW)
    DLPENTRY(SHGetFolderPathA)
    DLPENTRY(SHGetFolderPathW)
    DLPENTRY(SHGetInstanceExplorer)
    DLPENTRY(SHGetMalloc)
    DLPENTRY(SHGetPathFromIDListA)
    DLPENTRY(SHGetPathFromIDListW)
    DLPENTRY(SHGetSpecialFolderLocation)
    DLPENTRY(SHGetSpecialFolderPathW)
    DLPENTRY(SHLoadInProc)
    DLPENTRY(SHPathPrepareForWriteW)
    DLPENTRY(SHSetLocalizedName)
    DLPENTRY(ShellAboutA)
    DLPENTRY(ShellAboutW)
    DLPENTRY(ShellExecuteA)
    DLPENTRY(ShellExecuteExA)
    DLPENTRY(ShellExecuteExW)
    DLPENTRY(ShellExecuteW)
    DLPENTRY(Shell_NotifyIconW)
};

DEFINE_PROCNAME_MAP(shell32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\shlwapi.c ===
#include "shellpch.h"
#pragma hdrstop

static
LPTSTR
STDAPICALLTYPE
PathAddBackslashW(
    LPTSTR lpszPath
    )
{
    return NULL;
}

static
BOOL
STDAPICALLTYPE
PathAppendW(
    LPTSTR pszPath,
    LPCTSTR pszMore
    )
{
    return FALSE;
}

static
LPTSTR
STDAPICALLTYPE
PathCombineW(
    LPTSTR lpszDest,
    LPCTSTR lpszDir,
    LPCTSTR lpszFile)
{
    return NULL;
}

static
HRESULT
STDAPICALLTYPE
PathCreateFromUrlW(
  LPCTSTR pszUrl, 
  LPTSTR pszPath, 
  LPDWORD pcchPath, 
  DWORD dwReserved
)
{
    return E_FAIL;
}

static
LPTSTR
STDAPICALLTYPE
PathFindFileNameW(
    LPCTSTR pPath
    )
{
    return (LPTSTR)pPath;
}

static
BOOL
STDAPICALLTYPE
PathIsRootW(
    LPCWSTR pszPath
    )
{
    return FALSE;
}

static
BOOL
STDAPICALLTYPE
PathIsUNCW(
    LPCTSTR pszPath
    )
{
    return FALSE;
}


static
LPTSTR
STDAPICALLTYPE
PathRemoveBackslashW(
    LPTSTR lpszPath
    )
{
    return NULL;
}

static
BOOL
STDAPICALLTYPE
PathRemoveFileSpecW(
    LPTSTR pFile
    )
{
    return FALSE;
}

static
void
STDAPICALLTYPE
PathSetDlgItemPathW(
    HWND hDlg,
    int id,
    LPCTSTR pszPath
    )
{
    return;
}

static
HRESULT STDAPICALLTYPE
SHAutoComplete(HWND hwndEdit, DWORD dfwFlags)
{
    return E_FAIL;
}

static
BOOL
WINAPI
SHGetFileDescriptionW(
    LPCWSTR pszPath,
    LPCWSTR pszVersionKeyIn,
    LPCWSTR pszCutListIn,
    LPWSTR pszDesc,
    UINT *pcchDesc
    )
{
    return FALSE;
}

static
LPWSTR
StrCatW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return pszDst;
}

static
HRESULT STDAPICALLTYPE
UrlCanonicalizeW(
    LPCWSTR pszUrl,
    LPWSTR pszCanonicalized,
    LPDWORD pcchCanonicalized,
    DWORD dwFlags
    )
{
    return E_FAIL;
}

static
BOOL
WINAPI
IsOS(
    DWORD dwOS
    )
{
    return FALSE;
}

static
LPWSTR
WINAPI
StrStrIW(
    LPCWSTR lpFirst,
    LPCWSTR lpSrch
    )
{
    return NULL;
}

static
BOOL 
WINAPI
StrTrimW(
    IN OUT LPWSTR  pszTrimMe, 
    LPCWSTR pszTrimChars
    )
{
    return FALSE;
}

static
HPALETTE
WINAPI
SHCreateShellPalette(
    HDC hdc
    )
{
    return NULL;
}

static
DWORD
WINAPI
SHDeleteKeyW(
    IN HKEY    hkey, 
    IN LPCWSTR pwszSubKey
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
int
wnsprintfA(
    LPSTR lpOut, 
    int cchLimitIn, 
    LPCSTR lpFmt, 
    ...
    )
{
    *lpOut = 0;
    return 0;
}

static
int
wnsprintfW(
    LPWSTR lpOut, 
    int cchLimitIn, 
    LPCWSTR lpFmt, 
    ...
    )
{
    *lpOut = 0;
    return 0;
}

static
int 
WINAPI
wvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist
    )
{
    *lpOut = 0;
    return 0;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shlwapi)
{
    DLOENTRY(348, SHGetFileDescriptionW)
    DLOENTRY(437, IsOS)
};

DEFINE_ORDINAL_MAP(shlwapi)

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shlwapi)
{
    DLPENTRY(PathAddBackslashW)
    DLPENTRY(PathAppendW)
    DLPENTRY(PathCombineW)
    DLPENTRY(PathCreateFromUrlW)
    DLPENTRY(PathFindFileNameW)
    DLPENTRY(PathIsRootW)
    DLPENTRY(PathIsUNCW)
    DLPENTRY(PathRemoveBackslashW)
    DLPENTRY(PathRemoveFileSpecW)
    DLPENTRY(PathSetDlgItemPathW)
    DLPENTRY(SHAutoComplete)
    DLPENTRY(SHCreateShellPalette)
    DLPENTRY(SHDeleteKeyW)
    DLPENTRY(StrCatW)
    DLPENTRY(StrStrIW)
    DLPENTRY(StrTrimW)
    DLPENTRY(UrlCanonicalizeW)
    DLPENTRY(wnsprintfA)
    DLPENTRY(wnsprintfW)
    DLPENTRY(wvnsprintfW)
};

DEFINE_PROCNAME_MAP(shlwapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\badapps.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    badapp.h

Abstract:

    Declares the structures used for CheckBadApps data.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006

#define APPTYPE_FLAG_MASK     0xFFFFFF00

#define APPTYPE_FLAG_NONET    0x00000100
#define APPTYPE_FLAG_FAT32    0x00000200
#define APPTYPE_FLAG_NTFS     0x00000400

typedef struct {
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} BADAPP_PROP, *PBADAPP_PROP;

typedef struct {
    DWORD Size;
    PCTSTR FilePath;
    PBYTE Blob;
    DWORD BlobSize;
} BADAPP_DATA, *PBADAPP_DATA;

BOOL
SHIsBadApp (
    IN      PBADAPP_DATA Data,
    OUT     PBADAPP_PROP Prop
    );

#define EDIT    TRUE
#define NOEDIT  FALSE

// version allowances
#define VA_ALLOWMAINFILE     0x01
#define VA_ALLOWADDNLFILES   0x02

#define VA_ALLOWALLFILES     0x03

//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,
    VTID_PREVOSMAJORVERSION = VTID_REQFILE +21,
    VTID_PREVOSMINORVERSION = VTID_REQFILE +22,
    VTID_PREVOSPLATFORMID   = VTID_REQFILE +23,
    VTID_PREVOSBUILDNO      = VTID_REQFILE +24,

    // add new versions here

    VTID_LASTID
};

#define VERSION_STAMPS \
    LIBARGS(VTID_FILESIZE, ShCheckFileSize) \
    TOOLARGS(TEXT("FILESIZE"), TEXT("File Size:"), VA_ALLOWALLFILES, NOEDIT, QueryFileSize, OutputHexValue)\
    \
    LIBARGS(VTID_EXETYPE, ShCheckModuleType) \
    TOOLARGS(TEXT("EXETYPE"), TEXT("Module Type:"), VA_ALLOWADDNLFILES, NOEDIT, QueryModuleType, OutputModuleTypeValue)\
    \
    LIBARGS(VTID_BINFILEVER, ShCheckBinFileVer) \
    TOOLARGS(TEXT("BINFILEVER"), TEXT("Binary File Version:"), VA_ALLOWALLFILES, EDIT, QueryBinFileVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_BINPRODUCTVER, ShCheckBinProductVer) \
    TOOLARGS(TEXT("BINPRODUCTVER"), TEXT("Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_FILEDATEHI, ShCheckFileDateHi) \
    TOOLARGS(TEXT("FILEDATEHI"), TEXT("File Date (HI):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateHi, OutputHexValue)\
    \
    LIBARGS(VTID_FILEDATELO, ShCheckFileDateLo) \
    TOOLARGS(TEXT("FILEDATELO"), TEXT("File Date (LO):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateLo, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVEROS, ShCheckFileVerOs) \
    TOOLARGS(TEXT("FILEVEROS"), TEXT("File OS Version:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerOs, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVERTYPE, ShCheckFileVerType) \
    TOOLARGS(TEXT("FILEVERTYPE"), TEXT("File Type:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerType, OutputHexValue)\
    \
    LIBARGS(VTID_CHECKSUM, ShCheckFileCheckSum) \
    TOOLARGS(TEXT("CHECKSUM"), TEXT("File CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFileCheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_PECHECKSUM, ShCheckFilePECheckSum) \
    TOOLARGS(TEXT("PECHECKSUM"), TEXT("File Header CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFilePECheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_COMPANYNAME, ShCheckCompanyName) \
    TOOLARGS(TEXT("COMPANYNAME"), TEXT("Company Name:"), VA_ALLOWALLFILES, EDIT, QueryCompanyName, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTVERSION, ShCheckProductVersion) \
    TOOLARGS(TEXT("PRODUCTVERSION"), TEXT("Product Version:"), VA_ALLOWALLFILES, EDIT, QueryProductVersion, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTNAME, ShCheckProductName) \
    TOOLARGS(TEXT("PRODUCTNAME"), TEXT("Product Name:"), VA_ALLOWALLFILES, EDIT, QueryProductName, OutputStrValue)\
    \
    LIBARGS(VTID_FILEDESCRIPTION, ShCheckFileDescription) \
    TOOLARGS(TEXT("FILEDESCRIPTION"), TEXT("File Description:"), VA_ALLOWALLFILES, EDIT, QueryFileDescription, OutputStrValue)\
    \
    LIBARGS(VTID_FILEVERSION, ShCheckFileVersion) \
    TOOLARGS(TEXT("FILEVERSION"), TEXT("File Version:"), VA_ALLOWALLFILES, EDIT, QueryFileVersion, OutputStrValue)\
    \
    LIBARGS(VTID_ORIGINALFILENAME, ShCheckOriginalFileName) \
    TOOLARGS(TEXT("ORIGINALFILENAME"), TEXT("Original File Name:"), VA_ALLOWALLFILES, EDIT, QueryOriginalFileName, OutputStrValue)\
    \
    LIBARGS(VTID_INTERNALNAME, ShCheckInternalName) \
    TOOLARGS(TEXT("INTERNALNAME"), TEXT("Internal Name:"), VA_ALLOWALLFILES, EDIT, QueryInternalName, OutputStrValue)\
    \
    LIBARGS(VTID_LEGALCOPYRIGHT, ShCheckLegalCopyright) \
    TOOLARGS(TEXT("LEGALCOPYRIGHT"), TEXT("Legal Copyright:"), VA_ALLOWALLFILES, EDIT, QueryLegalCopyright, OutputStrValue)\
    \
    LIBARGS(VTID_16BITDESCRIPTION, ShCheck16BitDescription) \
    TOOLARGS(TEXT("DESCRIPTION"), TEXT("16 Bit Description:"), VA_ALLOWALLFILES, EDIT, Query16BitDescription, OutputStrValue)\
    \
    LIBARGS(VTID_UPTOBINPRODUCTVER, ShCheckUpToBinProductVer) \
    TOOLARGS(TEXT("UPTOBINPRODUCTVER"), TEXT("Up To Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputUpToBinVerValue)\
    \
    LIBARGS(VTID_PREVOSMAJORVERSION, ShCheckPrevOsMajorVersion) \
    TOOLARGS(TEXT("PREVOSMAJORVERSION"), TEXT("Previous OS Major Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMajorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSMINORVERSION, ShCheckPrevOsMinorVersion) \
    TOOLARGS(TEXT("PREVOSMINORVERSION"), TEXT("Previous OS Minor Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMinorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSPLATFORMID, ShCheckPrevOsPlatformId) \
    TOOLARGS(TEXT("PREVOSPLATFORMID"), TEXT("Previous OS Platform Id:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsPlatformId, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSBUILDNO, ShCheckPrevOsBuildNo) \
    TOOLARGS(TEXT("PREVOSBUILDNR"), TEXT("Previous OS Build No:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsBuildNo, OutputDecValue)\
    \

#define S_KEY_PREVOSVERSION     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PrevOsVersion")
#define S_VAL_BUILDNO           TEXT("BuildNumber")
#define S_VAL_MAJORVERSION      TEXT("MajorVersion")
#define S_VAL_MINORVERSION      TEXT("MinorVersion")
#define S_VAL_PLATFORMID        TEXT("PlatformId")

#define S_VER_COMPANYNAME       TEXT("CompanyName")
#define S_VER_PRODUCTVERSION    TEXT("ProductVersion")
#define S_VER_PRODUCTNAME       TEXT("ProductName")
#define S_VER_FILEDESCRIPTION   TEXT("FileDescription")
#define S_VER_FILEVERSION       TEXT("FileVersion")
#define S_VER_ORIGINALFILENAME  TEXT("OriginalFileName")
#define S_VER_INTERNALNAME      TEXT("InternalName")
#define S_VER_LEGALCOPYRIGHT    TEXT("LegalCopyright")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\cplext.h ===
///////////////////////////////////////////////////////////////////////////////
//
// CPLEXT.H  --  defines for property sheet extensions to system control panels
//
// Version 4.00
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_CPLEXT
#define _INC_CPLEXT


///////////////////////////////////////////////////////////////////////////////
//  Below are constants for pages which can be replaced in the standard control
// panel applets.  To extend an applet, you must define an object which
// supports the IShellPropSheetExt interface and register it's in-process
// server in a subkey under the applet's registry key.  Registry paths for the
// applets are defined in the header file REGSTR.H
//  Generally, when an IShellPropSheetExt is loaded, it's AddPages method
// will be called once, while it's ReplacePage method may be called zero or
// more times.  ReplacePage is only called in context.
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Mouse Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Mouse" )
//-----------------------------------------------------------------------------

#define CPLPAGE_MOUSE_BUTTONS       1
#define CPLPAGE_MOUSE_PTRMOTION     2
#define CPLPAGE_MOUSE_WHEEL         3


//-----------------------------------------------------------------------------
// Keyboard Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Keyboard" )
//-----------------------------------------------------------------------------

#define CPLPAGE_KEYBOARD_SPEED      1


//-----------------------------------------------------------------------------
// Display Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Display" )
//-----------------------------------------------------------------------------

#define CPLPAGE_DISPLAY_BACKGROUND  1


///////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\shsvcs.c ===
#include "shellpch.h"
#pragma hdrstop

static
BOOL
WINAPI
ThemeWatchForStart (
    void
    )

{
    return FALSE;
}

static
DWORD
WINAPI
ThemeWaitForServiceReady (
    DWORD dwTimeout
    )

{
    return WAIT_TIMEOUT;
}

static
BOOL
WINAPI
ThemeUserLogoff (
    void
    )

{
    return FALSE;
}

static
BOOL
WINAPI
ThemeUserLogon (
    HANDLE hToken
    )

{
    return FALSE;
}

static
BOOL
WINAPI
ThemeUserStartShell (
    void
    )

{
    return FALSE;
}

static
BOOL
WINAPI
ThemeUserTSReconnect (
    void
    )

{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shsvcs)
{
    DLOENTRY(1,ThemeWatchForStart)
    DLOENTRY(2,ThemeWaitForServiceReady)
    DLOENTRY(3,ThemeUserLogoff)
    DLOENTRY(4,ThemeUserLogon)
    DLOENTRY(5,ThemeUserStartShell)
    DLOENTRY(6,ThemeUserTSReconnect)
};

DEFINE_ORDINAL_MAP(shsvcs)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\accoreid.h ===
// Events IDs for FS Notify Control
#define DISPID_ONFSNOTIFYCHANGED        400

#define DISPID_PROP_SPFSNOTIFY_RECURSIVE    10
#define DISPID_PROP_SPFSNOTIFY_FOLDERITEM   11
// Property/method/event IDs for
// IStartPageSectionManager/DStartPageSectionManagerEvents
#define DISPID_SPSM_METHOD_RECALC                    1
#define DISPID_SPSM_PROP_MAXITEMS                    2
#define DISPID_SPSM_EVENT_ONRECALCDONE             100

// Property/method/event IDs for
// IActivityCenterHelp/DActivityCenterHelpEvents
#define DISPID_ACH_EVENT_ONDESKTOPSETTINGSCHANGED  100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\version.c ===
#include "shellpch.h"
#pragma hdrstop

#include <winver.h>

static
BOOL
APIENTRY
GetFileVersionInfoA(
    LPCSTR lptstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData
    )
{
    return FALSE;
}

static
DWORD
APIENTRY
GetFileVersionInfoSizeA(
    LPCSTR lptstrFilename,
    LPDWORD lpdwHandle
    )
{
    return 0;
}

static
DWORD
APIENTRY
GetFileVersionInfoSizeW(
    LPCWSTR lptstrFilename,
    LPDWORD lpdwHandle
    )
{
    return 0;
}

static
BOOL
APIENTRY
GetFileVersionInfoW(
    LPCWSTR lptstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
VerQueryValueA(
    const LPVOID pBlock,
    LPSTR lpSubBlock,
    LPVOID * lplpBuffer,
    PUINT puLen
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
VerQueryValueW(
    const LPVOID pBlock,
    LPWSTR lpSubBlock,
    LPVOID * lplpBuffer,
    PUINT puLen
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
VerQueryValueIndexW(
    const void *pBlock,
    LPTSTR lpSubBlock,
    DWORD dwIndex,
    void **ppBuffer,
    void **ppValue,
    PUINT puLen
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(version)
{
    DLPENTRY(GetFileVersionInfoA)
    DLPENTRY(GetFileVersionInfoSizeA)
    DLPENTRY(GetFileVersionInfoSizeW)
    DLPENTRY(GetFileVersionInfoW)
    DLPENTRY(VerQueryValueA)
    DLPENTRY(VerQueryValueIndexW)
    DLPENTRY(VerQueryValueW)
};

DEFINE_PROCNAME_MAP(version)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\aclui.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       aclui.h
//
//  Contents:   Definitions and prototypes for the ACLUI.DLL
//
//---------------------------------------------------------------------------

#ifndef _ACLUI_H_
#define _ACLUI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <objbase.h>
#include <commctrl.h>   // for HPROPSHEETPAGE
#include <accctrl.h>    // for SE_OBJECT_TYPE

#if !defined(_ACLUI_)
#define ACLUIAPI    DECLSPEC_IMPORT WINAPI
#else
#define ACLUIAPI    WINAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// ISecurityInformation interface
//
//  Methods:
//
//     GetObjectInformation - Allows UI to determine type of object being
//       edited.  Also allows determining if object is a container.
//
//     GetSecurity - Allows retrieving of ACLs from the original object
//                       NOTE: ACLUI will LocalFree the security descriptor
//                       returned by GetSecurity.
//     SetSecurity - Allows setting of the ACLs on the original object
//
//     GetAccessRights - For retrieving the list of rights allowed
//              on this object.
//
//     MapGeneric - For mapping generic rights to standard & specific rights
//
//     GetInheritTypes - For retrieving the list of possible sub-object types
//              for a container.
//
//     PropertySheetCallback - A method which is called back during the various
//              security UI property pages so that specialized work can be
//              done.  Similar to PropSheetPageProc.  If uMsg == PSPCB_CREATE,
//              then any error return value other than E_NOTIMPL will abort
//              the creation of that page.  The type of page being created or
//              destroyed is indicated by the uPage parameter.
//

typedef struct _SI_OBJECT_INFO
{
    DWORD       dwFlags;
    HINSTANCE   hInstance;          // resources (e.g. strings) reside here
    LPWSTR      pszServerName;      // must be present
    LPWSTR      pszObjectName;      // must be present
    LPWSTR      pszPageTitle;       // only valid if SI_PAGE_TITLE is set
    GUID        guidObjectType;     // only valid if SI_OBJECT_GUID is set
} SI_OBJECT_INFO, *PSI_OBJECT_INFO;

// SI_OBJECT_INFO flags
#define SI_EDIT_PERMS               0x00000000L // always implied
#define SI_EDIT_OWNER               0x00000001L
#define SI_EDIT_AUDITS              0x00000002L
#define SI_CONTAINER                0x00000004L
#define SI_READONLY                 0x00000008L
#define SI_ADVANCED                 0x00000010L
#define SI_RESET                    0x00000020L //equals to SI_RESET_DACL|SI_RESET_SACL|SI_RESET_OWNER
#define SI_OWNER_READONLY           0x00000040L
#define SI_EDIT_PROPERTIES          0x00000080L
#define SI_OWNER_RECURSE            0x00000100L
#define SI_NO_ACL_PROTECT           0x00000200L
#define SI_NO_TREE_APPLY            0x00000400L
#define SI_PAGE_TITLE               0x00000800L
#define SI_SERVER_IS_DC             0x00001000L
#define SI_RESET_DACL_TREE          0x00004000L
#define SI_RESET_SACL_TREE          0x00008000L
#define SI_OBJECT_GUID              0x00010000L
#define SI_EDIT_EFFECTIVE           0x00020000L
#define SI_RESET_DACL               0x00040000L
#define SI_RESET_SACL               0x00080000L
#define SI_RESET_OWNER              0x00100000L
#define SI_NO_ADDITIONAL_PERMISSION 0x00200000L
#define SI_MAY_WRITE                0x10000000L //not sure if user can write permission

#define SI_EDIT_ALL     (SI_EDIT_PERMS | SI_EDIT_OWNER | SI_EDIT_AUDITS)


typedef struct _SI_ACCESS
{
    const GUID *pguid;
    ACCESS_MASK mask;
    LPCWSTR     pszName;            // may be resource ID
    DWORD       dwFlags;
} SI_ACCESS, *PSI_ACCESS;

// SI_ACCESS flags
#define SI_ACCESS_SPECIFIC  0x00010000L
#define SI_ACCESS_GENERAL   0x00020000L
#define SI_ACCESS_CONTAINER 0x00040000L // general access, container-only
#define SI_ACCESS_PROPERTY  0x00080000L
// ACE inheritance flags (CONTAINER_INHERIT_ACE, etc.) may also be set.
// They will be used as the inheritance when an access is turned on.

typedef struct _SI_INHERIT_TYPE
{
    const GUID *pguid;
    ULONG       dwFlags;
    LPCWSTR     pszName;            // may be resource ID
} SI_INHERIT_TYPE, *PSI_INHERIT_TYPE;

// SI_INHERIT_TYPE flags are a combination of INHERIT_ONLY_ACE,
// CONTAINER_INHERIT_ACE, and OBJECT_INHERIT_ACE.

typedef enum _SI_PAGE_TYPE
{
    SI_PAGE_PERM=0,
    SI_PAGE_ADVPERM,
    SI_PAGE_AUDIT,
    SI_PAGE_OWNER,
    SI_PAGE_EFFECTIVE,
} SI_PAGE_TYPE;

// Message to PropertySheetPageCallback (in addition to
// PSPCB_CREATE and PSPCB_RELEASE)
#define PSPCB_SI_INITDIALOG	(WM_USER + 1)


#undef INTERFACE
#define INTERFACE   ISecurityInformation
DECLARE_INTERFACE_(ISecurityInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (THIS_ PSI_OBJECT_INFO pObjectInfo ) PURE;
    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) PURE;
    STDMETHOD(SetSecurity) (THIS_ SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) PURE;
    STDMETHOD(GetAccessRights) (THIS_ const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess ) PURE;
    STDMETHOD(MapGeneric) (THIS_ const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask) PURE;
    STDMETHOD(GetInheritTypes) (THIS_ PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes ) PURE;
    STDMETHOD(PropertySheetPageCallback)(THIS_ HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage ) PURE;
};
typedef ISecurityInformation *LPSECURITYINFO;

#undef INTERFACE
#define INTERFACE   ISecurityInformation2
DECLARE_INTERFACE_(ISecurityInformation2, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation2 methods ***
    STDMETHOD_(BOOL,IsDaclCanonical) (THIS_ IN PACL pDacl) PURE;
    STDMETHOD(LookupSids) (THIS_ IN ULONG cSids, IN PSID *rgpSids, OUT LPDATAOBJECT *ppdo) PURE;
};
typedef ISecurityInformation2 *LPSECURITYINFO2;

// HGLOBAL containing SID_INFO_LIST returned by ISecurityInformation2::LookupSids
#define CFSTR_ACLUI_SID_INFO_LIST   TEXT("CFSTR_ACLUI_SID_INFO_LIST")

// Data structures corresponding to CFSTR_ACLUI_SID_INFO_LIST
typedef struct _SID_INFO
{
    PSID    pSid;
    PWSTR   pwzCommonName;
    PWSTR   pwzClass;       // Used for selecting icon, e.g. "User" or "Group"
    PWSTR   pwzUPN;         // Optional, may be NULL
} SID_INFO, *PSID_INFO;
typedef struct _SID_INFO_LIST
{
    ULONG       cItems;
    SID_INFO    aSidInfo[ANYSIZE_ARRAY];
} SID_INFO_LIST, *PSID_INFO_LIST;


#undef INTERFACE
#define INTERFACE   IEffectivePermission
DECLARE_INTERFACE_(IEffectivePermission, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetEffectivePermission) (  THIS_ const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) PURE;
};
typedef IEffectivePermission *LPEFFECTIVEPERMISSION;

#undef INTERFACE
#define INTERFACE   ISecurityObjectTypeInfo
DECLARE_INTERFACE_(ISecurityObjectTypeInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray) PURE;
};
typedef ISecurityObjectTypeInfo *LPSecurityObjectTypeInfo;


// {965FC360-16FF-11d0-91CB-00AA00BBB723}
EXTERN_GUID(IID_ISecurityInformation, 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23);
// {c3ccfdb4-6f88-11d2-a3ce-00c04fb1782a}
EXTERN_GUID(IID_ISecurityInformation2, 0xc3ccfdb4, 0x6f88, 0x11d2, 0xa3, 0xce, 0x0, 0xc0, 0x4f, 0xb1, 0x78, 0x2a);
// {3853DC76-9F35-407c-88A1-D19344365FBC}
EXTERN_GUID(IID_IEffectivePermission, 0x3853dc76, 0x9f35, 0x407c, 0x88, 0xa1, 0xd1, 0x93, 0x44, 0x36, 0x5f, 0xbc);
// {FC3066EB-79EF-444b-9111-D18A75EBF2FA}
EXTERN_GUID(IID_ISecurityObjectTypeInfo, 0xfc3066eb, 0x79ef, 0x444b, 0x91, 0x11, 0xd1, 0x8a, 0x75, 0xeb, 0xf2, 0xfa);


HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
BOOL ACLUIAPI EditSecurity( HWND hwndOwner, LPSECURITYINFO psi );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _ACLUI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\dlgs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/


#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

//
//  These dialog resource ordinals really start at 0x0600, but the
//  RC Compiler can't handle hex for resource IDs, hence the decimal.
//
#ifdef UNIX

#define MW_BIG_FILEOPENORD      10000
#define MW_BIG_MULTIFILEOPENORD 10001

#define FILEOPENORDMOTIF        10003
#define PRINTDLGORDMOTIF        10004
#define FINDDLGORDMOTIF         10005
#endif

#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544
#define RUNDLGORD        1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */






//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\brdispid.h ===
#ifndef _BRDISPID_H_
#define _BRDISPID_H_

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: brdispid.h
//
//--------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////
//  IMediaBehavior
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBBEHAVIOR_BASE                      0

#define DISPID_MBBEHAVIOR_PLAYURL                   (DISPID_MBBEHAVIOR_BASE + 1)
#define DISPID_MBBEHAVIOR_STOP                      (DISPID_MBBEHAVIOR_BASE + 2)
#define DISPID_MBBEHAVIOR_PLAYNEXT                  (DISPID_MBBEHAVIOR_BASE + 3)
#define DISPID_MBBEHAVIOR_CURRENTITEM               (DISPID_MBBEHAVIOR_BASE + 4)
#define DISPID_MBBEHAVIOR_NEXTITEM                  (DISPID_MBBEHAVIOR_BASE + 5)
#define DISPID_MBBEHAVIOR_PLAYLISTINFO              (DISPID_MBBEHAVIOR_BASE + 6)
#define DISPID_MBBEHAVIOR_HASNEXTITEM               (DISPID_MBBEHAVIOR_BASE + 7)
#define DISPID_MBBEHAVIOR_PLAYSTATE                 (DISPID_MBBEHAVIOR_BASE + 8)
#define DISPID_MBBEHAVIOR_OPENSTATE                 (DISPID_MBBEHAVIOR_BASE + 9)
#define DISPID_MBBEHAVIOR_ENABLED                   (DISPID_MBBEHAVIOR_BASE + 10)
#define DISPID_MBBEHAVIOR_DISABLEDUI                (DISPID_MBBEHAVIOR_BASE + 11)

#define DISPID_MBBEHAVIOR_LAST                      DISPID_MBBEHAVIOR_DISABLEDUI



////////////////////////////////////////////////////////////////////////////
//  IMediaItem
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBMEDIAITEM_BASE                     DISPID_MBBEHAVIOR_LAST

#define DISPID_MBMEDIAITEM_SOURCEURL                (DISPID_MBMEDIAITEM_BASE + 1)
#define DISPID_MBMEDIAITEM_NAME                     (DISPID_MBMEDIAITEM_BASE + 2)
#define DISPID_MBMEDIAITEM_DURATION                 (DISPID_MBMEDIAITEM_BASE + 3)
#define DISPID_MBMEDIAITEM_ATTRIBUTECOUNT           (DISPID_MBMEDIAITEM_BASE + 4)
#define DISPID_MBMEDIAITEM_GETATTRIBUTENAME         (DISPID_MBMEDIAITEM_BASE + 5)
#define DISPID_MBMEDIAITEM_GETITEMINFO              (DISPID_MBMEDIAITEM_BASE + 6)

#define DISPID_MBMEDIAITEM_LAST                     DISPID_MBMEDIAITEM_GETITEMINFO


////////////////////////////////////////////////////////////////////////////
//  IPlaylistInfo
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBPLAYLISTINFO_BASE                  DISPID_MBMEDIAITEM_LAST

#define DISPID_MBPLAYLISTINFO_NAME                  (DISPID_MBPLAYLISTINFO_BASE + 1)
#define DISPID_MBPLAYLISTINFO_ATTRIBUTECOUNT        (DISPID_MBPLAYLISTINFO_BASE + 2)
#define DISPID_MBPLAYLISTINFO_GETATTRIBUTENAME      (DISPID_MBPLAYLISTINFO_BASE + 3)
#define DISPID_MBPLAYLISTINFO_GETITEMINFO           (DISPID_MBPLAYLISTINFO_BASE + 4)

#define DISPID_MBPLAYLISTINFO_LAST                  DISPID_MBPLAYLISTINFO_GETITEMINFO

////////////////////////////////////////////////////////////////////////////
// DIID_mbEvents
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBBEHAVIOREVENT_BASE                 4000

#define DISPID_MBBEHAVIOREVENT_ONOPENSTATECHANGE    (DISPID_MBBEHAVIOREVENT_BASE + 1)
#define DISPID_MBBEHAVIOREVENT_ONPLAYSTATECHANGE    (DISPID_MBBEHAVIOREVENT_BASE + 2)
#define DISPID_MBBEHAVIOREVENT_ONSHOW               (DISPID_MBBEHAVIOREVENT_BASE + 3)
#define DISPID_MBBEHAVIOREVENT_ONHIDE               (DISPID_MBBEHAVIOREVENT_BASE + 4)

#endif // _BRDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\dload\uxtheme.c ===
#include "shellpch.h"
#pragma hdrstop

#define _UXTHEME_
#include <uxtheme.h>
#include <uxthemep.h>

#undef THEMEAPI_
#define THEMEAPI_(type)     type STDAPICALLTYPE

#undef THEMEAPI
#define THEMEAPI            HRESULT STDAPICALLTYPE

static
HRESULT
WINAPI
ApplyTheme(
    HTHEMEFILE hThemeFile, 
    DWORD dwApplyFlags,
    HWND hwndTarget
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CloseThemeData(
    HTHEME hTheme
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CloseThemeFile(
    HTHEMEFILE hThemeFile
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
DrawNCPreview(
    HDC hdc,
    DWORD dwFlags,
    LPRECT prc,
    LPCWSTR pszVSPath,
    LPCWSTR pszVSColor,
    LPCWSTR pszVSSize,
    NONCLIENTMETRICS* pncm,
    COLORREF* prgb
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnumThemes(
    LPCWSTR pszThemeRoot,
    THEMEENUMPROC lpEnumFunc,
    LPARAM lParam
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnumThemeColors(
    LPCWSTR pszThemeName,
    LPCWSTR pszSizeName,
    DWORD dwColorIndex,
    THEMENAMEINFO *ptn
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnumThemeSizes(
    LPCWSTR pszThemeName,
    LPCWSTR pszColorScheme,
    DWORD dwSizeIndex,
    THEMENAMEINFO *ptn
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
GetCurrentThemeName(
    LPWSTR pszNameBuff,
    int cchMaxNameChars,
    LPWSTR pszColorBuff,
    int cchMaxColorChars,
    LPWSTR pszSizeBuff,
    int cchMaxSizeChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnableTheming(
    BOOL fEnable
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeDefaults(
    LPCWSTR pszThemeName,
    LPWSTR pszDefaultColor,
    int cchMaxColorChars,
    LPWSTR pszDefaultSize,
    int cchMaxSizeChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeDocumentationProperty(
    LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName,
    LPWSTR pszValueBuff,
    int cchMaxValChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
GetThemeSysString(
    HTHEME hTheme,
    int iStringId,
    LPWSTR pszStringBuff,
    int cchMaxStringChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
COLORREF
WINAPI
GetThemeSysColor(
    HTHEME hTheme,
    int iColorId
    )
{
    return 0x000000;
}


static
HBRUSH
WINAPI
GetThemeSysColorBrush(
    HTHEME hTheme,
    int iColorId
    )
{
    return NULL;
}

static
HRESULT
WINAPI
GetThemeSysInt(
    HTHEME hTheme,
    int iIntId,
    int *piValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
GetThemeSysBool(
    HTHEME hTheme,
    int iBoolId
    )
{
    return FALSE;
}

static
int
WINAPI
GetThemeSysSize(
    HTHEME hTheme,
    int iSizeId
    )
{
    return 0;
}

static
int
WINAPI
GetThemeSysSize96(
    HTHEME hTheme,
    int iSizeId
    )
{
    return 0;
}

static
HRESULT
WINAPI
GetThemeSysFont(
    HTHEME hTheme,
    int iFontId,
    OUT LOGFONT *plf
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeSysFont96(
    HTHEME hTheme,
    int iFontId,
    OUT LOGFONT *plf
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
OpenThemeFile(
    LPCWSTR pszThemePath,
    OPTIONAL LPCWSTR pszColorParam,
    OPTIONAL LPCWSTR pszSizeParam,
    OUT HTHEMEFILE *phThemeFile,
    BOOL fGlobalTheme
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeParseErrorInfo(
    PARSE_ERROR_INFO *pInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
OpenThemeFileFromData(
    HTHEME hTheme,
    HTHEMEFILE *phThemeFile
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HTHEME
WINAPI
OpenThemeDataFromFile(
    HTHEMEFILE hLoadedThemeFile,
    HWND hwnd,
    LPCWSTR pszClassList,
    BOOL fClient
    )
{
    return NULL;
}

static
DWORD
WINAPI
QueryThemeServices(
    void
    )
{
    return 0;
}

static
HRESULT
WINAPI
RegisterDefaultTheme(
    LPCWSTR pszFileName,
    BOOL fOverride
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
SetWindowTheme(
    HWND hwnd,
    LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
IsThemeActive(
    void
    )
{
    return FALSE;
}

//  These functions are exported for the use of the server. When the server
//  is collapsed in themesrv.dll these should be removed because they will
//  not be used and should not be exposed.

static
void*
WINAPI
SessionAllocate(
    HANDLE hProcess,
    DWORD dwServerChangeNumber,
    void *pfnRegister,
    void *pfnUnregister,
    void *pfnClearStockObject,
    DWORD dwStackSizeReserve, 
    DWORD dwStackSizeCommit
    )
{
    return NULL;
}

static
void
WINAPI
SessionFree(
    void *pvContext
    )
{
}

static
HRESULT
WINAPI
ThemeHooksOn(
    void *pvContext
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
ThemeHooksOff(
    void *pvContext
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
AreThemeHooksActive(
    void *pvContext
    )
{
    return FALSE;
}

static
int
WINAPI
GetCurrentChangeNumber(
    void *pvContext
    )
{
    return -1;
}

static
int
WINAPI
GetNewChangeNumber(
    void *pvContext
    )
{
    return -1;
}

static
HRESULT
WINAPI
SetGlobalTheme(
    void *pvContext,
    HANDLE hSection
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
void
WINAPI
MarkSection(
    HANDLE hSection,
    DWORD dwAdd,
    DWORD dwRemove
    )
{
}

static
HRESULT
WINAPI
SetSystemVisualStyle(
    LPCWSTR pszVisualStylesFile, 
    LPCWSTR pszColorScheme,
    LPCWSTR pszSize, 
    DWORD dwApplyFlags )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static 
HRESULT
WINAPI 
ServiceClearStockObjects(
    PVOID pvContext,
    HANDLE hSection )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetGlobalTheme(
    void *pvContext,
    HANDLE *phSection
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CheckThemeSignature(
    LPCWSTR pszName
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
LoadTheme(
    void *pvContext,
    HANDLE hSection,
    HANDLE *phSection,
    LPCWSTR pszName,
    LPCWSTR pszColor,
    LPCWSTR pszSize,
    DWORD   dwLoadFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
InitUserTheme(
    BOOL fPolicyCheckOnly
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
InitUserRegistry(
    void
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
ReestablishServerConnection(
    void
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
void
WINAPI
ThemeHooksInstall(
    void *pvContext
    )
{
}

static
void
WINAPI
ThemeHooksRemove(
    void *pvContext
    )
{
}

static
void
WINAPI
ServerClearStockObjects(
    void *pvContext
    )
{
}

static
int
WINAPI
ClassicGetSystemMetrics(
    int iMetric
    )
{
    return 0;
}

static
BOOL
WINAPI
ClassicSystemParametersInfoA(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ClassicSystemParametersInfoW(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni
    )
{
    return FALSE;
}

static
HRESULT
WINAPI
GetThemeInt(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    OUT int *piVal
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeTextMetrics(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    OUT TEXTMETRIC* ptm
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeFont(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId, 
    int iPropId,
    OUT LOGFONT *pFont
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeMetric(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId, 
    int iPropId,
    OUT int *piVal
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
IsThemeBackgroundPartiallyTransparent(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    )
{
    return FALSE;
}

static
BOOL
WINAPI
IsThemePartDefined(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    )
{
    return FALSE;
}

static
HRESULT
WINAPI
GetThemeMargins(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    OPTIONAL RECT *prc,
    OUT MARGINS *pMargins
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemePartSize(
    HTHEME hTheme,
    HDC hdc, 
    int iPartId,
    int iStateId,
    OPTIONAL RECT *prc,
    enum THEMESIZE eSize,
    OUT SIZE *psz
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
DrawThemeEdge(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pDestRect,
    UINT uEdge,
    UINT uFlags,
    OPTIONAL OUT RECT *pContentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
HitTestThemeBackground(
    HTHEME hTheme, 
    OPTIONAL HDC hdc, 
    int iPartId, 
    int iStateId, 
    DWORD dwOptions, 
    const RECT *pRect, 
    OPTIONAL HRGN hrgn,
    POINT ptTest, 
    OUT WORD *pwHitTestCode
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeBackgroundExtent(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pContentRect,
    OUT RECT *pExtentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeBackgroundRegion(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pRect,
    OUT HRGN *pRegion
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeTextExtent(
    HTHEME hTheme,
    HDC hdc, 
    int iPartId,
    int iStateId,
    LPCWSTR pszText,
    int iCharCount, 
    DWORD dwTextFlags,
    OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HTHEME
WINAPI
OpenThemeData(
    HWND hwnd,
    LPCWSTR pszClassIdList
    )
{
    return NULL;
}

static 
HRESULT
WINAPI
DrawThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId, 
    int iStateId,
    const RECT *pRect,
    OPTIONAL const RECT *pClipRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static 
HRESULT
WINAPI
DrawThemeParentBackground(
    HWND hwnd, 
    HDC hdc, 
    RECT* prc
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
RefreshThemeForTS(
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static HRESULT WINAPI DrawThemeIcon(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme,
    OPTIONAL HDC hdc, 
    int iPartId,
    int iStateId,
    const RECT *pBoundingRect, 
    OUT RECT *pContentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeColor(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    OUT COLORREF *pColor
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
DrawThemeText(
    HTHEME hTheme,
    HDC hdc,
    int iPartId, 
    int iStateId,
    LPCWSTR pszText,
    int iCharCount,
    DWORD dwTextFlags, 
    DWORD dwTextFlags2,
    const RECT *pRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnableThemeDialogTexture(
    HWND hwnd,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
THEMEAPI_(BOOL)
IsAppThemed()
{
    return FALSE;
}

static THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags)
{
}

static THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd)
{
    return NULL;
}

static THEMEAPI_(BOOL) IsThemeDialogTextureEnabled(HWND hwnd)
{
    return FALSE;
}

static THEMEAPI_(DWORD) GetThemeAppProperties()
{
    return 0;
}

static THEMEAPI GetThemeFilename(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszThemeFileName, int cchMaxBuffChars)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeString(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeBool(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT BOOL *pfVal)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeIntList(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT INTLIST *pIntList)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeEnumValue(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemePosition(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT POINT *pPoint)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeRect(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT RECT *pRect)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemePropertyOrigin(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT enum PROPERTYORIGIN *pOrigin)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, 
    BOOL fMenu, DWORD dwExStyle )
{
    return FALSE;
}


static THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, 
    LPCWSTR pszTextFile, BOOL fPacked, BOOL fFullInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//---- fake some structs for these c++ classes ----
typedef struct _CDrawBase {int dummy;} CDrawBase;
typedef struct _CTextDraw {int dummy;} CTextDraw;

static THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags)
{
    return NULL;
}

static THEMEAPI_(HTHEME) OpenThemeDataEx(HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags)
{
    return NULL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(uxtheme)         // PRIVATE functions
{
    DLOENTRY(1,QueryThemeServices)
    DLOENTRY(2,OpenThemeFile)
    DLOENTRY(3,CloseThemeFile)
    DLOENTRY(4,ApplyTheme)
    DLOENTRY(7,GetThemeDefaults)
    DLOENTRY(8,EnumThemes)
    DLOENTRY(9,EnumThemeColors)
    DLOENTRY(10,EnumThemeSizes)
    DLOENTRY(13,DrawNCPreview)
    DLOENTRY(14,RegisterDefaultTheme)
    DLOENTRY(15,DumpLoadedThemeToTextFile)
    DLOENTRY(16,OpenThemeDataFromFile)
    DLOENTRY(17,OpenThemeFileFromData)
    DLOENTRY(18,GetThemeSysSize96)
    DLOENTRY(19,GetThemeSysFont96)
    DLOENTRY(20,SessionAllocate)
    DLOENTRY(21,SessionFree)
    DLOENTRY(22,ThemeHooksOn)
    DLOENTRY(23,ThemeHooksOff)
    DLOENTRY(24,AreThemeHooksActive)
    DLOENTRY(25,GetCurrentChangeNumber)
    DLOENTRY(26,GetNewChangeNumber)
    DLOENTRY(27,SetGlobalTheme)
    DLOENTRY(28,GetGlobalTheme)
    DLOENTRY(29,CheckThemeSignature)
    DLOENTRY(30,LoadTheme)
    DLOENTRY(31,InitUserTheme)
    DLOENTRY(32,InitUserRegistry)
    DLOENTRY(33,ReestablishServerConnection)
    DLOENTRY(34,ThemeHooksInstall)
    DLOENTRY(35,ThemeHooksRemove)
    DLOENTRY(36,RefreshThemeForTS)
    DLOENTRY(43,ClassicGetSystemMetrics)
    DLOENTRY(44,ClassicSystemParametersInfoA)
    DLOENTRY(45,ClassicSystemParametersInfoW)
    DLOENTRY(46,ClassicAdjustWindowRectEx)
    DLOENTRY(47,DrawThemeBackgroundEx)
    DLOENTRY(48,GetThemeParseErrorInfo)
    DLOENTRY(60,CreateThemeDataFromObjects)
    DLOENTRY(61,OpenThemeDataEx)
    DLOENTRY(62,ServerClearStockObjects)
    DLOENTRY(63,MarkSection)
    // note: 64,ProcessLoadTheme_RunDLLW, doesn't need a d-load entry; it's strictly a GetProcAddress entrypoint.
    DLOENTRY(65,SetSystemVisualStyle)
    DLOENTRY(66,ServiceClearStockObjects)
};

DEFINE_ORDINAL_MAP(uxtheme)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(uxtheme)        // PUBLIC functions
{
    DLPENTRY(CloseThemeData)
    DLPENTRY(DrawThemeBackground)
    DLPENTRY(DrawThemeEdge)
    DLPENTRY(DrawThemeIcon)
    DLPENTRY(DrawThemeParentBackground)
    DLPENTRY(DrawThemeText)
    DLPENTRY(EnableThemeDialogTexture)
    DLPENTRY(EnableTheming)
    DLPENTRY(GetCurrentThemeName)
    DLPENTRY(GetThemeAppProperties)
    DLPENTRY(GetThemeBackgroundContentRect)
    DLPENTRY(GetThemeBackgroundExtent)
    DLPENTRY(GetThemeBackgroundRegion)
    DLPENTRY(GetThemeBool)
    DLPENTRY(GetThemeColor)
    DLPENTRY(GetThemeDocumentationProperty)
    DLPENTRY(GetThemeEnumValue)
    DLPENTRY(GetThemeFilename)
    DLPENTRY(GetThemeFont)
    DLPENTRY(GetThemeInt)
    DLPENTRY(GetThemeIntList)
    DLPENTRY(GetThemeMargins)
    DLPENTRY(GetThemeMetric)
    DLPENTRY(GetThemePartSize)
    DLPENTRY(GetThemePosition)
    DLPENTRY(GetThemePropertyOrigin)
    DLPENTRY(GetThemeRect)
    DLPENTRY(GetThemeString)
    DLPENTRY(GetThemeSysBool)
    DLPENTRY(GetThemeSysColor)
    DLPENTRY(GetThemeSysColorBrush)
    DLPENTRY(GetThemeSysFont)
    DLPENTRY(GetThemeSysInt)
    DLPENTRY(GetThemeSysSize)
    DLPENTRY(GetThemeSysString)
    DLPENTRY(GetThemeTextExtent)
    DLPENTRY(GetThemeTextMetrics)
    DLPENTRY(GetWindowTheme)
    DLPENTRY(HitTestThemeBackground)
    DLPENTRY(IsAppThemed)
    DLPENTRY(IsThemeActive)
    DLPENTRY(IsThemeBackgroundPartiallyTransparent)
    DLPENTRY(IsThemeDialogTextureEnabled)
    DLPENTRY(IsThemePartDefined)
    DLPENTRY(OpenThemeData)
    DLPENTRY(ServiceClearStockObjects)
    DLPENTRY(SetSystemVisualStyle)
    DLPENTRY(SetThemeAppProperties)
    DLPENTRY(SetWindowTheme)
};

DEFINE_PROCNAME_MAP(uxtheme)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\isguids.h ===
/*
 * isguids.h - Internet Shortcut GUID definitions.
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */


/* GUIDs
 ********/

#ifndef _ISGUIDS_H_
#define _ISGUIDS_H_

DEFINE_GUID(CLSID_InternetShortcut,       0xFBF23B40L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

DEFINE_GUID(IID_IUniformResourceLocatorA, 0xFBF23B80L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
DEFINE_GUID(IID_IUniformResourceLocatorW, 0xCABB0DA0L, 0xDA57, 0x11CF, 0x99, 0x74, 0x00, 0x20, 0xAF, 0xD7, 0x97, 0x62);

#ifdef UNICODE
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorW
#else
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\ginarcid.h ===
//  Don't use numbers lower than 20000. These are used by the DS component
//  of msgina.

// UI host failure
#define IDS_UIHOST_FAILURE                          20000
#define IDS_GENERIC_CAPTION                         20001
#define IDS_RECONNECT_FAILURE                       20005

#define IDD_GINA_TURNOFFCOMPUTER                    20050
#define IDD_GINA_RETURNTOWELCOME                    20051

#define IDD_TURNOFFCOMPUTER                         20100
#define IDC_TITLE_FLAG                              20101
#define IDC_TITLE_TURNOFF                           20102
#define IDC_BUTTON_TURNOFF                          20103
#define IDC_BUTTON_STANDBY                          20104
#define IDC_BUTTON_RESTART                          20105
#define IDC_BUTTON_HIBERNATE                        20106
#define IDC_TEXT_TURNOFF                            20107
#define IDC_TEXT_STANDBY                            20108
#define IDC_TEXT_RESTART                            20109
#define IDC_TEXT_HIBERNATE                          20110

#define IDS_TURNOFF_TITLE_FACENAME                  20125
#define IDS_TURNOFF_TITLE_FACESIZE                  20126
#define IDS_TURNOFF_BUTTON_FACENAME                 20127
#define IDS_TURNOFF_BUTTON_FACESIZE                 20128
#define IDS_TURNOFF_TOOLTIP_TEXT_TURNOFF            20129
#define IDS_TURNOFF_TOOLTIP_TEXT_STANDBY            20130
#define IDS_TURNOFF_TOOLTIP_TEXT_STANDBY_HIBERNATE  20131
#define IDS_TURNOFF_TOOLTIP_TEXT_RESTART            20132
#define IDS_TURNOFF_TOOLTIP_TEXT_HIBERNATE          20133

#define IDB_BACKGROUND_8                            20140
#define IDB_FLAG_8                                  20141
#define IDB_BACKGROUND_24                           20142
#define IDB_FLAG_24                                 20143

#define IDB_BUTTONS                                 20150
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\cleanoc.h ===
#ifndef __CLEANOC_API__
#define __CLEANOC_API__

// Flags used in GetControlInfo()
#define GCI_NAME         1
#define GCI_FILE         2
#define GCI_CLSID        3
#define GCI_TYPELIBID    4
#define GCI_TOTALSIZE    5
#define GCI_SIZESAVED    6
#define GCI_TOTALFILES   7
#define GCI_CODEBASE     8
#define GCI_ISDISTUNIT   9
#define GCI_DIST_UNIT_VERSION 10
#define GCI_STATUS       11
#define GCI_HAS_ACTIVEX  12
#define GCI_HAS_JAVA     13

// control status flags
#define STATUS_CTRL_UNKNOWN             0   // Errors prevent determining the actual control state
#define STATUS_CTRL_INSTALLED           1   // Control is properly installed and ready for use
#define STATUS_CTRL_SHARED              2   // One or more components are shared by more than one control
#define STATUS_CTRL_DAMAGED             3   // The control file or some part of the installation is damaged or missing
#define STATUS_CTRL_UNPLUGGED           4   // The control has been re-registered in another location, the cache's
                                            // instance of the control is no longer being used.

// RemoveExpiredControls flags
#define REC_SILENT     1    // If set, controls whose deletion would require confirmation are not removed.

///////////////////////////////////////////////////////////////////////////////
// FindFirstControl
//
// Purpose:
//     Initiate a search on the registry for an installed ActiveX control.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h
//
// Parameters:
//     hFindHandle    -- a handle needed for resuming the search.  Caller must
//                       pass this handle to FindNextControl to retrieve the
//                       the next installed ActiveX control.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//     lpCachePath    -- points to a string buffer that has the path where
//                       all controls to be retrieved are located.  If it
//                       is NULL, the internet cache path will be read
//                       from the registry.  If a path is to be supplied,
//                       the path must be a full pathname without any ~'s
//                       in order for the enumeration to work correctly.
//
#define axcFINDFIRSTCONTROL "FindFirstControl"

LONG WINAPI FindFirstControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath = NULL
                     );

typedef LONG (WINAPI *FINDFIRSTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath /*= NULL*/
                     );


///////////////////////////////////////////////////////////////////////////////
// FindNextControl
//
// Purpose:
//     Resume a previously started search for installed ActiveX controls. The
//     search must have been initiated by a call to FirstFirstControl.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.  In this situation, the caller can choose to continue
//       the search with another call to FindNextControl, or simply abort.
//
// Parameters:
//     hFindHandle    -- a handle received from a call to FindFirstControl.
//                       Pass this handle to subsequent calls to
//                       FindNextControl to retrieve controls one at a time.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//
#define axcFINDNEXTCONTROL "FindNextControl"

LONG WINAPI FindNextControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

typedef LONG (WINAPI *FINDNEXTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

///////////////////////////////////////////////////////////////////////////////
// FindControlClose
//
// Purpose:
//     Called when search is over.  Missing a call to this function after a
//     search might contribute memory leak.  This function can be called
//     regardless of what FindFirstControl and/or FindNextControl return.
//
// Return Value:
//     None.
//
// Parameters:
//     hFindHandle -- a handle obtained from calls to FindFirstControl and
//                    FindNextControl in the current search.
//
#define axcFINDCONTROLCLOSE "FindControlClose"

void WINAPI FindControlClose(
                     HANDLE hFindHandle
                     );

typedef void (WINAPI *FINDCONTROLCLOSE)(
                     HANDLE hFindHandle
                     );


///////////////////////////////////////////////////////////////////////////////
// ReleaseControlHandle
//
// Purpose:
//     When a handle of a control is retrieved via FindFirstControl or
//     FindNextControl, the caller is responsible to release that handle
//     by call this function.
//
// Return Value:
//     None.
//
// Parameters:
//     hControlHandle -- a handle to a control obtained from FindFirstControl
//                       or FindNextControl.
//
#define axcRELEASECONTROLHANDLE "ReleaseControlHandle"

void WINAPI ReleaseControlHandle(
                          HANDLE hControlHandle
                          );

typedef void (WINAPI *RELEASECONTROLHANDLE)(
                          HANDLE hControlHandle
                          );


///////////////////////////////////////////////////////////////////////////////
// GetControlInfo
//
// Purpose:
//     Once a handle to a control is obtained via FindFirstControl or
//     FindNextControl, the caller may retrieve information about the control
//     by call this function with a flag (nFlag) indicating what info to
//     retrieve.  The supported flags are:
//     GCI_NAME       -- friendly name of control
//     GCI_FILE       -- main full path & file name of control
//     GCI_CLSID      -- clsid of control, in a NULL-terminated string
//     GCI_TYPELIBID  -- typelib guid of control, in a NULL-terminated string
//     GCI_TOTALSIZE  -- total size in bytes of all control's dependent files
//     GCI_SIZESAVED  -- total size in bytes restored if control is removed
//                       It can be different from GCI_TOTALSIZE since some
//                       of the control's dependent files might be shared dlls
//     GCI_TOTALFILES -- total number of control dependent files, including
//                       shared dlls if there are any
//     GCI_STATUS     -- the controls status value from STATUS_CTRL_* <above>
//     GCI_HAS_ACTIVEX -- non-zero if control includes ActiveX contols(s)
//     GCI_HAS_JAVA   -- non-zero if control includes Java packages
//
// Return Value:
//     TRUE if succeeded, FALSE otherwise.
//
// Parameters:
//     hControlHandle -- handle to a control for which information is to be
//                       retrieved.
//     nFlag          -- indicate which information to retrieve. Please refer
//                       to Purpose section above for a list of supported 
//                       flags.  nFlag can only equal to one of them so do
//                       not pass in multiple flags OR'ed together.
//     lpdwData       -- address of a buffer for storing a numerical value.
//                       (ie. GCI_TOTALSIZE, GCI_SIZESAVED & GCI_TOTALFILES)
//                       This parameter is ignored for other flags.
//     lpszData       -- address of a buffer for storing a NULL-terminated
//                       string value (ie. GCI_NAME, GCI_FILE, GCI_CLSID &
//                       GCI_TYPELIBID)  This paramter is ignored if other
//                       flags are specified.
//     nBufLen        -- length of string buffer pointed to by lpszData.
//                       This parameter is ignored if a numerical value is
//                       being retrieved.
//
#define axcGETCONTROLINFO "GetControlInfo"

BOOL WINAPI GetControlInfo(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );

typedef BOOL (WINAPI *GETCONTROLINFO)(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );


///////////////////////////////////////////////////////////////////////////////
// GetControlDependentFile
//
// Purpose:
//     A given control might depend on other files.  For instance, FOO.OCX
//     might need FOO.INF and MFCXX.DLL in order to work.  This function
//     retrieves one file at a time from a list of files depended upon by a
//     given ActiveX control.  The list of files is NOT sorted.
//
// Return Value:
//     - ERROR_SUCCESS if a file is found at position iFile in the list.
//     - ERROR_NO_MORE_FILES if no file is found at position iFile in the list.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.
//     
// Parameters:
//     iFile          -- a zero-based index indicating which file in the list
//                       to retrieve.
//     hControlHandle -- handle to a control obtained via FindFirstControl
//                       or FindNextControl.
//     lpszFile       -- points to a buffer used to store the retrieved name.
//     lpszSize       -- points to a DWORD variable that is to store the size
//                       in bytes of the file retrieved.  If it is 0, the file
//                       does not exist.
//     bToUpper       -- TRUE if the filename returned is to be converted to
//                       uppercase.  No conversion takes place if FALSE
//          
#define axcGETCONTROLDEPENDENTFILE "GetControlDependentFile"
         
LONG WINAPI GetControlDependentFile(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper = FALSE
             );

typedef LONG (WINAPI *GETCONTROLDEPENDENTFILE)(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper /*= FALSE*/
             );


///////////////////////////////////////////////////////////////////////////////
// IsModuleRemovable
//
// Purpose:
//     Checks whether a file can be removed by looking into the registry.
//     This function is called "IsModuleRemovable" instead of
//     "IsFileRemovable" because this routine does not check the actual file
//     for its status.  For instance, a file can be deemed removable even if
//     is being exclusively opened by someone.  This routine only tells from
//     the registry's point of view if a file can be safely removed or not.
//
// Return Value:
//     - FALSE if there is any indication that the given file is being shared
//       by other applications.
//     - TRUE otherwise.
//
// Parameter: 
//     lpszFile -- points to a buffer that has the name (with full path) of
//                 the file whose removal status is to be verified.
//
#define axcISMODULEREMOVABLE "IsModuleRemovable"

BOOL WINAPI IsModuleRemovable(
             LPCTSTR lpszFile
             );

typedef BOOL (WINAPI *ISMODULEREMOVABLE)(
             LPCTSTR lpszFile
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByHandle
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpControlData -- points to an instance of CONTROL_DATA representing the
//                      control to be removed.  The struct must have been
//                      initialized by a call to FindFirstControl or
//                      FindNextControl.  Be sure to call ReleaseControlData
//                      on this struct after successful removal, for the data
//                      in this struct is no longer useful.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//
#define axcREMOVECONTROLBYHANDLE "RemoveControlByHandle"

HRESULT WINAPI RemoveControlByHandle(
             HANDLE hControlHandle,
             BOOL bForceRemove = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYHANDLE)(
             HANDLE hControlHandle,
             BOOL bForceRemove /*= FALSE*/
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByName
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  It is an overloaded version.
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpszFile      -- Address of a null-terminated string which is the main
//                      file for the control (ie "FOO.OCX" for FOO control).
//     lpszCLSID     -- Address of a null-terminated string which is the CLSID
//                      of the control.
//     lpszTypeLibID -- Address of a null-terminated string which is the TypeLib
//                      clsid of the control.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//     dwIsDistUnit  -- boolean value to tell if this is really a dist unit
//
#define axcREMOVECONTROLBYNAME "RemoveControlByName"

HRESULT WINAPI RemoveControlByName(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove = FALSE,
             DWORD dwIsDistUnit = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYNAME)(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove /*= FALSE*/,
             DWORD dwIsDistUnit /*= FALSE*/
             );


///////////////////////////////////////////////////////////////////////////////
// type PFNDOBEFOREREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right before removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the control will be removed.
//     If a fail code (E_XXX) is returned, the control will be skipped.
//
// Parameters:
//     HANDLE -- handle to the control to be removed.  One can get information
//               about the control using the GetControlInfo function.  Do NOT
//               call ReleaseControlHandle on the handle.
//     UINT   -- number of remaining controls including this one.
//
typedef HRESULT (CALLBACK *PFNDOBEFOREREMOVAL)(HANDLE, UINT);


///////////////////////////////////////////////////////////////////////////////
// type PFNDOAFTERREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right after removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the removal operation proceeds.
//     If a fail code (E_XXX) is returned, the removal operation is aborted.
//
// Parameters:
//     HRESULT -- result of removing the control.  The handle to this control
//                was passed to the callback of type PFNDOBEFOREREMOVAL before
//                the control was removed.  The possible values for this
//                HRESULT parameter are:
//                - S_OK (succeeded)
//                - S_FALSE (control had been removed with possibly some very
//                  minor errors)
//                - E_ACCESSDENIED (control not safe for removal)
//                - STG_E_SHAREVIOLATION (control being used by others)
//                - Other errors returned by registry functions
//                It is up to the implementator of this function to decide
//                what to do given the result of removing the last control.
//     UINT    -- number of remaining controls, NOT including the one just
//                removed.
//
typedef HRESULT (CALLBACK *PFNDOAFTERREMOVAL)(HRESULT, UINT);


///////////////////////////////////////////////////////////////////////////////
// SweepControlsByLastAccessDate
//
// Purpose:
//     Remove all controls whose last access date is before and on a given
//     date.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     pLastAccessTime -- specify a last access date.  All controls accessed
//                        before and on this date are to be removed.  Note
//                        that all fields except wYear, wMonth and wDay are
//                        ignored.  If NULL, all control will be removed.
//     pfnDoBefore     -- callback function called just before a control is
//                        removed.  Please read the description for type
//                        PFNDOBEFOREREMOVAL for details.  If NULL, nothing
//                        is to be done prior to removing a control.
//     pfnDoAfter      -- callback function called right after a control is
//                        removed.  Please read the description for type
//                        PFNDOAFTERREMOVAL for details.  If NULL, nothing
//                        is to be done after a control is removed.
//     dwSizeLimit     -- controls will be removed only if the total size
//                        (in bytes) of all controls exceeds the size
//                        specified by this paramter.  This parameter is
//                        ignored if 0 is specified.
//
#define axcSWEEPCONTROLSBYLASTACCESSDATE "SweepControlsByLastAccessDate"

HRESULT WINAPI SweepControlsByLastAccessDate(
                              SYSTEMTIME *pLastAccessTime = NULL,
                              PFNDOBEFOREREMOVAL pfnDoBefore = NULL,
                              PFNDOAFTERREMOVAL pfnDoAfter = NULL,
                              DWORD dwSizeLimit = 0
                              );

typedef HRESULT (WINAPI *SWEEPCONTROLSBYLASTACCESSDATE)(
                              SYSTEMTIME *pLastAccessTime /*= NULL*/,
                              PFNDOBEFOREREMOVAL pfnDoBefore /*= NULL*/,
                              PFNDOAFTERREMOVAL pfnDoAfter /*= NULL*/,
                              DWORD dwSizeLimit /*= 0*/
                              );


///////////////////////////////////////////////////////////////////////////////
// RemoveExpiredControls
//
// Purpose:
//     Similar to IEmptyVolumeCache. Removes all controls with a last
//     access date in the distant past and all controls flagged for more
//     rapid auto-expire.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     dwFlags         -- Currently, only REC_SILENT is defined.
//     dwReserved      -- Must be 0.
//
#define axcREMOVEEXPIREDCONTROLS "RemoveExpiredControls"

HRESULT WINAPI RemoveExpiredControls(DWORD dwFlags, DWORD dwReserved);

typedef HRESULT (WINAPI *REMOVEEXPIREDCONTROLS)(DWORD dwFlags, DWORD dwReserved);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\ieguidp.h ===
#ifndef _IEGUIDP_H_
#define _IEGUIDP_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif


//
// from shlguidp.h
//

#if (_WIN32_IE >= 0x0400)

// favorites band
// {EFA24E61-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_FavBand,              0xefa24e61, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// history band
// {EFA24E62-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_HistBand,              0xefa24e62, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// channels band
// {EFA24E63-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ChannelBand,          0xefa24e63, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

#endif  // (_WIN32_IE >= 0x0400)



#if (_WIN32_IE >= 0x0400)

DEFINE_GUID(IID_IWinEventHandler,       0xEA5F2D61L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

// IQueryCodePage {C7B236CE-EE80-11D0-985F-006008059382}
DEFINE_GUID(IID_IQueryCodePage, 0xC7B236CEL, 0xEE80, 0x11D0, 0x98, 0x5F, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

DEFINE_GUID(CGID_AddressEditBox, 0x72730b70, 0xe8f7, 0x11d0, 0xbc, 0x44, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

/// AddressEditBox stuff
// {A08C11D1-A228-11d0-825B-00AA005B4383}
DEFINE_GUID(IID_IAddressEditBox, 0xa08c11d1, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
DEFINE_GUID(CLSID_AddressEditBox,0xa08c11d2, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {????} - For JITting in HTML Help Feature
DEFINE_GUID(CLSID_IEHelp, 0x45ea75a0L, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

// {603D3800-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ShellTaskScheduler,        0x603d3800, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {6CCB7BE0-6807-11d0-B810-00C04FD706EC}
DEFINE_GUID(IID_IShellTaskScheduler,         0x6ccb7be0, 0x6807, 0x11d0, 0xb8, 0x10, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {04B3813B-0A23-11d2-B5AC-006097DF5BD4} - For JITting in FTP Shell Extension.
DEFINE_GUID(CLSID_FTPShellExtension, 0x4b3813b, 0xa23, 0x11d2, 0xb5, 0xac, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

// {6B707A1C-744F-11d2-86B9-00C04F8EEA99}
DEFINE_GUID(IID_IBrowserBand, 0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

DEFINE_GUID(VID_WebView, 0x5984FFE0L, 0x28D4, 0x11CF, 0xAE, 0x66, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {BE098140-A513-11d0-A3A4-00C04FD706EC}

// {603D3801-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_SharedTaskScheduler,       0x603d3801, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

DEFINE_GUID(CLSID_ImageListCache,            0x3f4eef80, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

DEFINE_GUID(IID_IAddressBand,           0x106E86E1, 0x52B5, 0x11D0, 0xBF, 0xED, 0x0, 0xAA, 0x0, 0x5B, 0x43, 0x83);

// used by shell32 and ie components.
// same interface as IID_IExtractImage
// {D4029EC0-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractLogo,                0xd4029ec0, 0x920, 0x11d1, 0x9a, 0xb, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {0D14E31C-D8C0-11d0-9816-00C04FD91972}
DEFINE_GUID(SID_SMenuBandHandler,           0xd14e31c, 0xd8c0, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {3F4EEF80-BFE8-11d0-A3A5-00C04FD706EC}
// {4FCE9180-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IImageCache,                 0x4fce9180, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {8A4D3EDC-13A4-11d1-9A22-00C04FC2D6C1}
DEFINE_GUID(CLSID_ThumbnailScaler, 0x8a4d3edc, 0x13a4, 0x11d1, 0x9a, 0x22, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {45B324CE-B8A1-11d1-98D3-00C04FB687DA}
DEFINE_GUID(IID_IScaleAndSharpenImage2, 0x45b324ce, 0xb8a1, 0x11d1, 0x98, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

DEFINE_GUID(IID_IDeskBarClient,         0xEB0FE175L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);

DEFINE_GUID(IID_IMultiMonitorDockingSite, 0x03879DE0L, 0xA205, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1); 

// {D12F26B1-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(IID_IRestrict, 0xd12f26b1, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B2-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(SID_SRestrictionHandler, 0xd12f26b2, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B3-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(RID_RDeskBars, 0xd12f26b3, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {4622AD16-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_IInitializeObject,0x4622ad16, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);



#endif  // (_WIN32_IE >= 0x0400)


#if _WIN32_IE >= 0x0500

DEFINE_GUID(IID_IPersistString, 0xD5E37E20L, 0x0257, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {8210BAC0-C6D2-11cf-89AA-00A0C9054129}

// {AC3E9E59-96D7-11d1-98A4-00C04FB687DA}
DEFINE_GUID(IID_IImageCache2,                0xac3e9e59, 0x96d7, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

#endif  // _WIN32_IE >= 0x0500

#if (_WIN32_IE >= 0x0501)
// {58C73AE8-6AFE-4784-96FC-F97F65773B64}
DEFINE_GUID(IID_IShellTaskScheduler2,        0x58c73ae8, 0x6afe, 0x4784, 0x96, 0xfc, 0xf9, 0x7f, 0x65, 0x77, 0x3b, 0x64);

// {B61D9AB3-F120-4a5c-83A0-542923985BF7}
DEFINE_GUID(IID_IImageCache3,                0xb61d9ab3, 0xf120, 0x4a5c, 0x83, 0xa0, 0x54, 0x29, 0x23, 0x98, 0x5b, 0xf7);
#endif


#if _WIN32_IE >= 0x0600

#ifndef DEFINE_SHLGUID
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#endif

// SID_SBrandBand: the spinning globe {82A62DE8-32AC-4e4a-9935-9046C378CF90}
DEFINE_GUID(SID_SBrandBand, 0x82a62de8, 0x32ac, 0x4e4a, 0x99, 0x35, 0x90, 0x46, 0xc3, 0x78, 0xcf, 0x90);

// Command group for the BrandBand {25019D8C-9EE0-45c0-883B-972D48325E18}
DEFINE_GUID(CGID_BrandCmdGroup, 0x25019d8c, 0x9ee0, 0x45c0, 0x88, 0x3b, 0x97, 0x2d, 0x48, 0x32, 0x5e, 0x18);

// Command IDs for the BrandBand's CGID_BrandCmdGroup (to be called in Exec)
#define CBRANDIDM_STARTGLOBEANIMATION   1
#define CBRANDIDM_STOPGLOBEANIMATION    2


// {31D44C2F-6C6A-45fc-B8C7-946BA8EDB8B4}
DEFINE_GUID(CGID_MediaBar, 0x31d44c2f, 0x6c6a, 0x45fc, 0xb8, 0xc7, 0x94, 0x6b, 0xa8, 0xed, 0xb8, 0xb4);

#endif // _WIN32_IE >= 0x0600


// Private Dochost Commands
//
DEFINE_SHLGUID(CGID_DocHostCmdPriv,         0x000214D4L, 0, 0);



//
//  from shguidp.h
//

// explorer band
// {EFA24E64-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ExplorerBand,         0xefa24e64, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

/// INSCTree
// {43A8F463-4222-11d2-B641-006097DF5BD4}
DEFINE_GUID(CLSID_NSCTree,              0x43a8f463, 0x4222, 0x11d2, 0xb6, 0x41, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {1FBA04EE-3024-11d2-8F1F-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtExec, 0x1fba04ee, 0x3024, 0x11d2, 0x8f, 0x1f, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {E0DD6CAB-2D10-11d2-8F1A-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtBand, 0xe0dd6cab, 0x2d10, 0x11d2, 0x8f, 0x1a, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {83799FE0-1F5A-11d1-95C7-00609797EA4F}
DEFINE_GUID(CLSID_DocFileInfoTip,   0x83799fe0, 0x1f5a, 0x11d1, 0x95, 0xc7, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);

// {8E6E6079-0CB7-11d2-8F10-0000F87ABD16}
DEFINE_GUID(CLSID_OfflinePagesCacheCleaner, 0x8e6e6079, 0xcb7, 0x11d2, 0x8f, 0x10, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// Internet Cache Cleaner
// {9B0EFD60-F7B0-11D0-BAEF-00C04FC308C9}
DEFINE_GUID(CLSID_InternetCacheCleaner,     0x9b0efd60, 0xf7b0, 0x11d0, 0xba, 0xef, 0x0, 0xc0, 0x4f, 0xc3, 0x08, 0xc9);

// {67EA19A0-CCEF-11d0-8024-00C04FD75D13}
DEFINE_GUID(CLSID_CDFCopyHook, 0x67ea19a0, 0xccef, 0x11d0, 0x80, 0x24, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

//ffdc1a80-d527-11d0-a32c-34af06c10000
DEFINE_GUID (CLSID_WinListShellProc, 0xffdc1a80, 0xd527, 0x11d0, 0xa3, 0x2c, 0x34, 0xaf, 0x06, 0xc1, 0x00, 0x00);

DEFINE_GUID(CLSID_ChannelOC,            0x131A6951L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

DEFINE_GUID(CLSID_CStubBindStatusCallback, 
                                        0x2B4F54B1, 0x3D6D, 0x11d0, 0x82, 0x58, 0x00, 0xC0, 0x4F, 0xD5, 0xAE, 0x38);// 2B4F54B1-3D6D-11d0-8258-00C04FD5AE38

// History Shell Folder
DEFINE_GUID(CLSID_HistFolder,           0xFF393560L, 0xC2A7, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

// Cache Shell Folder UICLSID
DEFINE_GUID(CLSID_CacheFolder,          0x7BD29E00L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);
// Cache Shell Folder full implementation
DEFINE_GUID(CLSID_CacheFolder2,         0x7BD29E01L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);

DEFINE_GUID(CLSID_CDocObjectFolder,     0xE7E4BC40, 0xE76A, 0x11CE, 0xA9,0xBB,0x00,0xAA,0x00,0x4A,0xE8,0x37);//E7E4BC40-E76A-11CE-A9BB-00AA004AE837

// {BB90CD8B-4F08-11d0-B497-00C04FD90119}
DEFINE_GUID(IID_IShellHTMLWindowSupport,0xbb90cd8bL, 0x4f08, 0x11d0, 0xb4, 0x97, 0x00, 0xc0, 0x4f, 0xd9, 0x01, 0x19);

DEFINE_GUID(IID_IExpDispSupport,        0x0D7D1D00, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D00-6FC0-11D0-A974-00C04FD705A2

DEFINE_GUID(IID_IDocNavigate,           0x131A6950L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

//***   SID_STopFrameBrowser -- like SID_STopLevelBrowser, but blocked by BrowserBand
// currently used to make BrowserBand get its own global history, but could
// be more generally useful than that, hence the more generic name.
// {A9227C3C-7F8E-11d0-8CB0-00A0C92DBFE8}
DEFINE_GUID(SID_STopFrameBrowser,       0xa9227c3c, 0x7f8e, 0x11d0, 0x8c, 0xb0, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {C7A30296-907E-11d2-B02F-00C04FA35D89}
DEFINE_GUID(IID_IUrlHistoryPriv,        0xc7a30296, 0x907e, 0x11d2, 0xb0, 0x2f, 0x0, 0xc0, 0x4f, 0xa3, 0x5d, 0x89);

// 20C46561-8491-11CF-960C-0080C7F4EE85 
// this is who should navigate instead
DEFINE_GUID(SID_SProxyBrowser,          0x20C46561L, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);

//1E79697E-9CC5-11D1-A83F-00C04FC99D61
DEFINE_GUID(CLSID_CommonButtons, 0x1E79697EL, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

DEFINE_GUID(SID_PendingBindStatusCallback, 0xfe390c68, 0xe2bc, 0x11d0, 0x88, 0x8c, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);

// {32bb8320-b41b-11cf-a6bb-0080c7b2d682}
DEFINE_GUID(IID_IBrowserExtension, 0x32bb8320, 0xb41b, 0x11cf, 0xa6, 0xbb, 0x0, 0x80, 0xc7, 0xb2, 0xd6, 0x82);

DEFINE_GUID(SID_ITopViewHost,           0xd1e7afec, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

DEFINE_GUID(IID_IEFrameAuto,            0x131A6953L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

DEFINE_GUID(IID_IExpDispSupportOC,      0x0D7D1D01, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D01-6FC0-11D0-A974-00C04FD705A2

// {48123bc4-99d9-11d1-a6b3-00c04fd91555}
DEFINE_GUID(CLSID_XMLViewerDocObj, 0x48123bc4, 0x99d9, 0x11d1, 0xa6, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x55);

DEFINE_GUID(IID_IOrderList,             0x8bfcb27d, 0xcf1a, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
DEFINE_GUID(CLSID_OrderListExport,      0xf3368374, 0xcf19, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// Interface used to keep channel cache in sync.
DEFINE_GUID(IID_IChannelMgrPriv, 0xc9ace0f0, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);
DEFINE_GUID(IID_IChannelMgrPriv2, 0xc9ace0f1, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);

// {1ABCFC13-2340-11d2-B601-006097DF5BD4}
DEFINE_GUID(CLSID_FtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(IID_IFtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// this is used in shdocvw's CConnectionPoint implementation
// to let CShellOcx type OCs get advised of Advise/Unadvise
// calls to the connection point. CShellFolderViewOC uses it.
//
DEFINE_GUID(IID_IConnectionPointCB,     0xAAAC9640L, 0x1252, 0x11D0, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);

// {4ec5337e-4554-4705-81fd-06a3e1b0430a}
DEFINE_GUID(IID_IShellHTMLWindowSupport2,0x4ec5337e, 0x4554, 0x4705, 0x81, 0xfd, 0x06, 0xa3, 0xe1, 0xb0, 0x43, 0x0a);

// {DD313E04-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(CLSID_UserAssist, 0xdd313e04, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// {DD313E05-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(IID_IUserAssist, 0xdd313e05, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// navigate band UI from pidl
DEFINE_GUID(IID_IBandNavigate,          0x3697c30b, 0xcd88, 0x11d0, 0x8a, 0x3e, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {3050f803-98b5-11cf-bb82-00aa00bdce0b} SID_QIClientSite
DEFINE_GUID(SID_QIClientSite, 0x3050f803, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {996E1EB1-B524-11d1-9120-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindComputer,   0x996e1eb1, 0xb524, 0x11d1, 0x91, 0x20, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {D515F311-B78B-11d1-9123-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindPrinter,    0xd515f311, 0xb78b, 0x11d1, 0x91, 0x23, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {169A0691-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(CLSID_ShellSearchExt,       0x169a0691, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {23d9b0f1-40fc-11d2-bf8c-00c04fb93661}
DEFINE_GUID(IID_IFolderSearches, 0x23d9b0f1, 0x40fc, 0x11d2, 0xbf, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

// 830abff0-afd9-11d1-b9f1-00a0c98bc547
DEFINE_GUID(IID_ISearchItems,      0x830abff0L, 0xafd9, 0x11d1, 0xb9, 0xf1, 0x00, 0xa0, 0xc9, 0x8b, 0xc5, 0x47);

// New MSIE FTP UI from msieftp.dll
DEFINE_GUID(CLSID_FtpFolder,            0x63da6ec0, 0x2e98, 0x11cf, 0x8d,0x82,0x44,0x45,0x53,0x54,0,0);

//A48F1A32-A340-11D1-BC6B-00A0C90312E1
DEFINE_GUID(GUID_Restrictions, 0xA48F1A32L, 0xA340, 0x11D1, 0xBC, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

DEFINE_GUID (IID_IHist,                 0x06faeb04L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
DEFINE_GUID (IID_ICache,                0x06faeb05L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// {B1E437E0-047A-11D1-B833-00C04FC9B31F}
DEFINE_GUID(IID_IDwnCodePage, 0xb1e437e0, 0x047a, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// {AFD971E0-C870-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IPrivateOleObject, 0xafd971e0, 0xc870, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {a28a872c-1bce-11d4-a114-00c04f8ef9b9}
DEFINE_GUID(IID_ISearchBandTBHelper, 0xa28a872c, 0x1bce, 0x11d4, 0xa1, 0x14, 0x0, 0xc0, 0x4f, 0x8e, 0xf9, 0xb9);

// used when communicating with the Internet Toolbar. 
DEFINE_GUID(CGID_ShellBrowser, 0x3531F060L, 0x22B3, 0x11D0, 0x96, 0x9E, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 );

/// IAddressList
// {D7E67AA1-AA76-11d0-8282-00AA005B4383}
DEFINE_GUID(IID_IAddressList,           0xd7e67aa1, 0xaa76, 0x11d0, 0x82, 0x82, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

/// IBandProxy
// {208CE801-754B-11d0-80CA-00AA005B4383}
DEFINE_GUID(IID_IBandProxy,             0x208ce801, 0x754b, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {1011fa30-69da-11d2-8599-006097df8c11}
DEFINE_GUID(IID_IMRU,                   0x1011fa30, 0x69da, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

//0F12079C-C193-11D0-8D49-00C04FC99D61
DEFINE_GUID(CGID_Theater, 0x0F12079CL, 0xC193, 0x11D0, 0x8D, 0x49, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// {9581015C-D08E-11d0-8D36-00A0C92DBFE8}
DEFINE_GUID(CLSID_BrowserBar,           0x9581015c, 0xd08e, 0x11d0, 0x8d, 0x36, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {2D3DDFC0-09E1-11d1-BC59-00AA006CE2F5}
DEFINE_GUID(CGID_MenuBandHandler, 0x2d3ddfc0, 0x9e1, 0x11d1, 0xbc, 0x59, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// this defines the deskbar and also id's for each of the toolbands that we implement
//ECD4FC4C-521C-11D0-B792-00A0C90312E1
DEFINE_GUID(CLSID_DeskBar,              0xECD4FC4CL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_RebarBandSite,        0xECD4FC4DL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_BandSiteMenu,         0xECD4FC4EL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_MenuDeskBar,          0xECD4FC4FL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {8C7461EF-2B13-11d2-BE35-3078302C2030}
DEFINE_GUID(CLSID_ComCatCacheTask,  0x8c7461ef, 0x2b13, 0x11d2, 0xbe, 0x35, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {3CCF8A41-5C85-11d0-9796-00AA00B90ADF}
DEFINE_GUID(CLSID_DeskBarApp,           0x3ccf8a41, 0x5c85, 0x11d0, 0x97, 0x96, 0x0, 0xaa, 0x0, 0xb9, 0xa, 0xdf);

// 4AF4A5FA-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(IID_IDockingBarPropertyBagInit, 0x4AF4A5FAL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// ef8ad2d3-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(IID_IGlobalFolderSettings, 0xef8ad2d3L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {37e856d7-3dfd-11d2-bf8b-00c04fb93661}
DEFINE_GUID(IID_IEnumUrlSearch,   0x37e856d7, 0x3dfd, 0x11d2, 0xbf, 0x8b, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

DEFINE_GUID(SID_IBandProxy,             0x80243ac1, 0x569, 0x11d1, 0xa7, 0xae, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {AF4F6511-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(IID_IRegTreeOptions, 0xaf4f6511, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {07798131-AF23-11d1-9111-00A0C98BA67D}
DEFINE_GUID(CLSID_WebSearchExt,         0x7798131, 0xaf23, 0x11d1, 0x91, 0x11, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// NOTE!  Different from the IID_ITranslateShellChangeNotify in IE4x and IE5.0
// {B4DF2675-BA23-11d2-B5EE-006097C686F6}
DEFINE_GUID(IID_ITranslateShellChangeNotify, 0xb4df2675, 0xba23, 0x11d2, 0xb5, 0xee, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

//Pidl Filtering for Menu Bands.
// {B16C55D1-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(CGID_FilterObject,0xb16c55d1, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {B16C55D3-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(SID_SHostProxyFilter,0xb16c55d3, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// Also used by SHCreateGlobalCounter to count changes to global folder settings
#define GUID_FolderSettingsChange       CLSID_ShellFldSetExt

// {7376D660-C583-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ImgCtxThumbnailExtractor, 0x7376d660, 0xc583, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// 438755C2-A8BA-11D1-B96B-00A0C90312E1
DEFINE_GUID(CLSID_BrowseuiPreloader, 0x438755C2L, 0xA8BA, 0x11D1, 0xB9, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// ef8ad2d1-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_GlobalFolderSettings, 0xef8ad2d1L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {D1E7AFEA-6A2E-11d0-8C78-00C04FD918B4}
DEFINE_GUID(IID_IBandSiteHelper,        0xd1e7afea, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

//AF604EFE-8897-11D1-B944-00A0C90312E1
DEFINE_GUID(CLSID_CCommonBrowser, 0xAF604EFEL, 0x8897, 0x11D1, 0xB9, 0x44, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// Currently not used -- will be used when dbapp moves to shell32
// 4AF4A5FC-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(CLSID_CDockingBarPropertyBag, 0x4AF4A5FCL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {AF4F6510-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(CLSID_CRegTreeOptions, 0xaf4f6510, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {E56829C9-2D59-11d2-BE38-3078302C2030}
DEFINE_GUID(CLSID_ComCatConditionalCacheTask, 0xe56829c9, 0x2d59, 0x11d2, 0xbe, 0x38, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// URL Shell Execute Hook for IE4
// {AEB6717E-7E19-11d0-97EE-00C04FD91972}
DEFINE_GUID(CLSID_URLExecHook,          0xaeb6717e, 0x7e19, 0x11d0, 0x97, 0xee, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);



//
// From shdguid.h
//

// 3DC7A020-0ACD-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CURLFolder,       0x3DC7A020L, 0x0ACD, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

//A5E46E3A-8849-11D1-9D8C-00C04FC99D61
DEFINE_GUID(CLSID_CBaseBrowser, 0xA5E46E3AL, 0x8849, 0x11D1, 0x9D, 0x8C, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// IID_IShellService is used in shdocvw and shell32.  Put it here so shdocvw builds.
DEFINE_GUID(IID_IShellService, 0x5836FB00L, 0x8187, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// f62d9369-75ef-4578-8856-232802c76468
DEFINE_GUID(IID_ITridentService2, 0xf62d9369, 0x75ef, 0x4578, 0x88, 0x56, 0x23, 0x28, 0x02, 0xc7, 0x64, 0x68);

// 3050f801-98b5-11cf-bb82-00aa00bdce0b
DEFINE_GUID(IID_ITridentService, 0x3050f801, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEFINE_GUID(IID_IBrowserService, 0x02ba3b52, 0x0547, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// (old: E4A141D2-70C7-11D1-8DD7-00C04FC99D61 until 980512)
// (old: C3F16B61-E91A-11d1-BCD9-00A0C92DBFE8 until 980903)
// {68BD21CC-438B-11d2-A560-00A0C92DBFE8}
DEFINE_GUID(IID_IBrowserService2, 0x68bd21cc, 0x438b, 0x11d2, 0xa5, 0x60, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IBrowserService3, 0x27D7CE21L, 0x762D, 0x48F3, 0x86, 0xF3, 0x40, 0xE2, 0xFD, 0x37, 0x49, 0xC4);

// C2EA74E0-0ED2-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjectView,   0xC2EA74E0L, 0x0ED2, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 3050f804-98b5-11cf-bb82-00aa00bdce0b
DEFINE_GUID(IID_IWebBrowserPriv,  0x3050f804, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);

// Remove this after Beta 2.
DEFINE_GUID(CLSID_QuickLinksOld, 0x7BA4C741L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 01E04581-4EEE-11d0-BFE9-00AA005B4383
DEFINE_GUID(CLSID_AddressBand, 0x1e04581, 0x4eee, 0x11d0, 0xbf, 0xe9, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {30D02401-6A81-11d0-8274-00C04FD5AE38}
DEFINE_GUID(CLSID_SearchBand, 0x30d02401, 0x6a81, 0x11d0, 0x82, 0x74, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);
#define CGID_SearchBand CLSID_SearchBand

// {32683183-48a0-441b-a342-7c2a440a9478}
DEFINE_GUID(CLSID_MediaBand, 0x32683183, 0x48a0, 0x441b, 0xa3, 0x42, 0x7c, 0x2a, 0x44, 0x0a, 0x94, 0x78);

// {B6E3D794-F864-42a4-8F7B-1779A4DEAC83}
DEFINE_GUID(SID_SMediaBar, 0xb6e3d794, 0xf864, 0x42a4, 0x8f, 0x7b, 0x17, 0x79, 0xa4, 0xde, 0xac, 0x83);

// 5E6AB780-7743-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_InternetToolbar, 0x5E6AB780L, 0x7743, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

/// {AFA7AD8A-51A7-11d2-83A1-00C04FD918D0}
DEFINE_GUID(IID_IOrderList2,    0xafa7ad8a, 0x51a7, 0x11d2, 0x83, 0xa1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {F98D8294-2BBC-11d2-8DBD-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchableCallback, 0xf98d8294, 0x2bbc, 0x11d2, 0x8d, 0xbd, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {4E1AE66C-204B-11d2-8DB3-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchable, 0x4e1ae66c, 0x204b, 0x11d2, 0x8d, 0xb3, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {49422C1E-1C03-11d2-8DAB-0000F87A556C}
DEFINE_GUID(IID_IShellFolderViewType, 0x49422c1e, 0x1c03, 0x11d2, 0x8d, 0xab, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {94FD6891-92CD-11d1-A1C6-00C04FD75D13}
DEFINE_GUID(SRCID_SWebSearch,      0x94fd6891, 0x92cd, 0x11d1, 0xa1, 0xc6, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

#define SRCID_SFileSearch          CLSID_ShellSearchExt

// {B8A9C381-19DF-11d1-9193-006097DF5BD4}
DEFINE_GUID(IID_IIsWebBrowserSB, 0xb8a9c381, 0x19df, 0x11d1, 0x91, 0x93, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// 062E1261-A60E-11d0-82C2-00C04FD5AE38
DEFINE_GUID(IID_IHistSFPrivate, 0x62e1261, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);

// 22BF0C20-6DA7-11D0-B373-00A0C9034938
DEFINE_GUID(CLSID_BrandBand, 0x22BF0C20, 0x6DA7, 0x11D0, 0xB3, 0x73, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x38);

DEFINE_GUID(CLSID_BrowserBand, 0x7BA4C742L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {4D5C8C2A-D075-11d0-B416-00C04FB90376}
DEFINE_GUID(CLSID_CommBand, 0x4d5c8c2a, 0xd075, 0x11d0, 0xb4, 0x16, 0x0, 0xc0, 0x4f, 0xb9, 0x3, 0x76);

// {35C042C1-75BE-11d0-80D2-00AA005B4383}
DEFINE_GUID(CLSID_MRUList, 0x35c042c1, 0x75be, 0x11d0, 0x80, 0xd2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {91EA3F8C-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(IID_IAugmentedShellFolder,      0x91ea3f8c, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
// {8DB3B3F4-6CFE-11d1-8AE9-00C04FD918D0}
DEFINE_GUID(IID_IAugmentedShellFolder2,     0x8db3b3f4, 0x6cfe, 0x11d1, 0x8a, 0xe9, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {F61FFEC1-754F-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_BandProxy, 0xf61ffec1, 0x754f, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {91EA3F8B-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(CLSID_AugmentedShellFolder,     0x91ea3f8b, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {6413BA2C-B461-11d1-A18A-080036B11A03}
DEFINE_GUID(CLSID_AugmentedShellFolder2,    0x6413ba2c, 0xb461, 0x11d1, 0xa1, 0x8a, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);





#endif // _IEGUIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\help.h ===
// This file contains help context id's in the master windows.h file.

// Id's over 61440 are reserved and will ALWAYS use windows.hlp when
// used for context-sensitive help.

// Id's from 1-999 are reserved for Object help

// REVIEW: has to be 28440 until new help compiler is available

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_BACK    0x3023
#define IDH_NEXT    0x3024
#define IDH_FINISH  0x3025

#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_COMM_APPLYNOW               28447
#define IDH_FONT_STYLE                  28448
#define IDH_FONT_SIZE                   28449
#define IDH_FONT_SAMPLE                 28450
#define IDH_FONT_EFFECTS                28451
#define IDH_FONT_FONT                   28452
#define IDH_PRINT_SETUP_AVAIL           28453
#define IDH_PRINT_SETUP_OPTIONS         28454
#define IDH_PRINT_SETUP_DETAILS         28455
#define IDH_OPEN_LOCATION               28456
#define IDH_OPEN_FILES                  28457
#define IDH_OPEN_READONLY               28459
#define IDH_OPEN_FILETYPE               28460
#define IDH_OPEN_PATH                   28461
#define IDH_OPEN_FILENAME               28462
#define IDH_FIND_SEARCHTEXT             28463
#define IDH_FIND_NEXT_BUTTON            28464
#define IDH_FIND_WHOLE                  28467
#define IDH_FIND_CASE                   28468
#define IDH_REPLACE_REPLACE             28469
#define IDH_REPLACE_REPLACE_ALL         28470
#define IDH_REPLACE_REPLACEWITH         28471
#define IDH_PRINT_PRINTER               28472
#define IDH_PRINT_PRINTER_SETUP         28473
#define IDH_PRINT_COPIES                28474
#define IDH_PRINT_COLLATE               28475
#define IDH_PRINT_TO_FILE               28476
#define IDH_PRINT_QUALITY               28477
#define IDH_PRINT_RANGE                 28478
#define IDH_PAGE_SAMPLE                 28485
#define IDH_PAGE_ORIENTATION            28486
#define IDH_PAGE_PAPER_SIZE             28487
#define IDH_PAGE_PAPER_SOURCE           28488
#define IDH_PAGE_MARGINS                28489
#define IDH_OPEN_DRIVES                 28490
#define IDH_COMM_DRIVE                  28491
#define IDH_COMM_PASSWDBUTT             28492
#define IDH_COMM_OLDPASSWD              28493
#define IDH_BROWSE                      28496
#define IDH_COLOR_CUSTOM                28497
#define IDH_COLOR_SAMPLE_COLOR          28498
#define IDH_COLOR_HUE                   28500
#define IDH_COLOR_SAT                   28501
#define IDH_COLOR_RED                   28502
#define IDH_COLOR_GREEN                 28503
#define IDH_COLOR_BLUE                  28504
#define IDH_COLOR_LUM                   28505
#define IDH_COLOR_ADD                   28506
#define IDH_COLOR_COLOR_SOLID           28507
#define IDH_COLOR_DEFINE                28508
#define IDH_QUICKINFO                   28509
#define IDH_NO_CROSSREF                 28510
#define IDH_CHARMAP_INSERT              28511
#define IDH_COMM_USER_NAME              28512
#define IDH_COMM_USER_SERVERNAME        28513
#define IDH_COMM_USER_SELECT_FROM       28514
#define IDH_COMM_USER_SELECTED          28515
#define IDH_PRINT32_RANGE               28516
#define IDH_PRINT_PROPERTIES            28517
#define IDH_PRINT_FILENAME              28518
#define IDH_PRINT_CHOOSE_PRINTER        28519
#define IDH_FIND_DIRECTION              28520
#define IDH_FONT_COLOR                  28521
#define IDH_PRINT_SETUP_PAPER           28522
#define IDH_PRINT_SETUP_ORIENT          28523
#define IDH_OPEN_BUTTON                 28529
#define IDH_SAVE_BUTTON                 28531
#define IDH_COLOR_BASIC                 28532
#define IDH_COLOR_CUSTOM_CUSTOM         28533
#define IDH_COLOR_SAMPLE_SCROLL         28534
#define IDH_FONT_SCRIPT                 28535
#define IDH_KERNEL_TASK_LIST            28536
#define IDH_KERNEL_END_TASK             28537
#define IDH_KERNEL_SHUTDOWN             28538
#define IDH_QVIEW_DISPLAY               28539
#define IDH_CHARMAP_COPY                28540
#define IDH_CHARMAP_FONT                28541
#define IDH_CHARMAP_CHARACTERS          28542
#define IDH_CHARMAP_SELECTED_CHARS      28543
#define IDH_CHARMAP_SELECT_BUTTON       28544
#define IDH_CHARMAP_HELP_BUTTON         28545
#define IDH_BOLD                        28546
#define IDH_ITALIC                      28547
#define IDH_COMM_GROUPBOX               28548
#define IDH_OPEN_FILES32                28549
#define IDH_SAVE_FILETYPE               28550
#define IDH_SYSTEM_CFG_OLDNAME          28551
#define IDH_DIAL_WHAT_WRONG             28552
#define IDH_COMCTL_RESET                28553
#define IDH_COMCTL_MOVEUP               28554
#define IDH_COMCTL_MOVEDOWN             28555
#define IDH_COMCTL_BUTTON_LIST          28556
#define IDH_COMCTL_ADD                  28557
#define IDH_COMCTL_REMOVE               28558
#define IDH_COMCTL_AVAIL_BUTTONS        28559
#define IDH_COMCTL_CLOSE                28560
#define IDH_PAGE_PRINTER                28561
#define IDH_DCC_WHAT_WRONG              28562
#define IDH_FILEVIEWER_PREVIEW          28563
#define IDH_PRINT_NETWORK               28564
#define IDH_PRINT_SETUP_DUPLEX          28565

#define IDH_OLEPROP_SUMMARY             28569
#define IDH_OLEPROP_STATISTICS          28570
#define IDH_CONFIGURE_LPT_PORT          28571
#define IDH_ADD_LOCAL_PORT              28572
#define IDH_PRINT_PORT_NAME             28573
#define IDH_PRINT_OUTPUT_FILE           28574
#define IDH_DISKCOPY_START              28575
#define IDH_DISKCOPY_FROM               28576
#define IDH_DISKCOPY_TO                 28577

#define IDH_PRINT_FIND_PRINTER          29010
#define IDH_PRINT_PREFERENCES           29011
#define IDH_PRINT_PRINTER_FOLDER        29015

#define IDH_OPEN_SHORTCUT_BAR           29500
#define IDH_OPEN_BACK_BUTTON            29501
#define IDH_PRINT_BTN                   29510

// ID value for Win 3.1 user transition piece: jump from First experience screen
#define WIN31_TRANSITION_PIECE          30000

#define IDH_FCAB_OPENWITH_LOOKONWEB     3001            // (for the link to the Web on the Open With dialog.)
#define IDH_CANNOTOPEN_USEWEB           3002            // (For the first radio button on the Cannot open this file dialog)
#define IDH_CANNOTOPEN_SELECTLIST       3003            // (For the second radio button on the Cannot open this file dialog)


// ID values 2100-2199 are reserved for Disk Compression.
// See dos\dos86\dblspace\utility\comphelp.h

// ID values 2200-2299 are reserved for Find File. See findhlp.h.

// ID values 2400-2499 are reserved for MultiMedia control panel. See medhelp.h

// ID values 2500-2699 are reserved for Print Trouble Shooter

// ID values 2700-2799 are reserved for Network control panel. See nethelp.h

// ID values 2800-2899 are reserved for Online Registration.

// ID values 2900-2999 are reserved for Clipbook and Chat.

#define IDH_COMM_NEWPASSWD              3018    // See pwdids.h
#define IDH_COMM_NEWPASSCONF            3019    // See pwdids.h

// Briefcase ids

#define IDH_BFC_UPDATE_SCREEN           3100
#define IDH_BFC_UPDATE_BUTTON           3101
#define IDH_BFC_PROP_FILEICON           3102
#define IDH_BFC_PROP_SPLIT_BUTTON       3103
#define IDH_BFC_PROP_FINDORIG_BUTTON    3104
#define IDH_BFC_FILTER_TYPE             3105
#define IDH_BFC_FILTER_INCLUDE          3106

// ID values 3300-3499 are reserved for international. See intlhlp.h

// ID values for the Keyboard property sheet

#define IDH_DLGKEY_REPDEL               4000
#define IDH_DLGKEY_REPSPEED             4001
#define IDH_DLGKEY_REPTEST              4002
#define IDH_DLGKEY_TYPE                 4008
#define IDH_DLGKEY_CHANGE               4010
#define IDH_DLGKEY_CURSBLNK             4011
#define IDH_DLGKEY_CURSOR_GRAPHIC       4012

#define IDH_KEYB_INPUT_LIST             4028
#define IDH_KEYB_INPUT_ADD              4029
#define IDH_KEYB_INPUT_PROP             4030
#define IDH_KEYB_INPUT_DEL              4031
#define IDH_KEYB_INPUT_DEFAULT          4032
#define IDH_KEYB_CAPSLOCK_LAYOUT        4033
#define IDH_KEYB_INPUT_LANG             4034
#define IDH_KEYB_INPUT_INDICATOR        4035
#define IDH_KEYB_INPUT_ONSCRN_KEYB      4036
#define IDH_KEYB_INPUT_PROP_LANG        4039
#define IDH_KEYB_INPUT_PROP_KEYLAY      4042
#define IDH_KEYB_INPUT_DEF_LANG         4043
#define IDH_KEYB_INPUT_SHORTCUT         4044
#define IDH_KEYB_INDICATOR_ON_TASKBAR   4045
#define IDH_KEYB_IME_SETTINGS           4046
#define IDH_KEYB_HOTKEY_LIST            4047
#define IDH_KEYB_CHANGE_HOTKEY          4048
#define IDH_KEYB_CHANGE_KEY             4049

// ID values for Desktop Property sheet

// Settings Page
#define IDH_SETTINGS_DISPLAYDESK        4064    //Monitor icon display area
#define IDH_SETTINGS_DISPLAYLIST        4065    //Monitor dropdown
#define IDH_SETTINGS_COLORBOX           4066    //Colors dropdown   
#define IDH_SETTINGS_SCREENSIZE         4067    //Screen Area dropdown      
#define IDH_SETTINGS_DISPLAYUSEME       4068    //Use this monitor chkbx
#define IDH_SETTINGS_DISPLAYPROPERTIES  4069    //Advanced button

// General Page
#define IDH_GENERAL_FONTSIZEGRP         4080    //Font size dropdown
#define IDH_GENERAL_DYNA                4081    //Compatibility option group
#define IDH_GENERAL_NODYNA              4082    //Restart the computer option
#define IDH_GENERAL_YESDYNA             4083    //Apply the changes option  
#define IDH_GENERAL_SHUTUP              4084    //Always prompt before option

// Background Page (Now the "Desktop" Page)
#define IDH_DSKTPBACKGROUND_MONITOR     4100
#define IDH_DSKTPBACKGROUND_PATTLIST    4102
#define IDH_DSKTPBACKGROUND_WALLLIST    4104
#define IDH_DSKTPBACKGROUND_BROWSE      4105
#define IDH_DSKTPBACKGROUND_TILE        4106
#define IDH_DSKTPBACKGROUND_CENTER      4107
#define IDH_DSKTPBACKGROUND_DISPLAY     4108
#define IDH_DSKTPBACKGROUND_EDITPAT     4109

// Screen Saver Page
#define IDH_DSKTPSCRSAVER_LISTBX        4111
#define IDH_DSKTPSCRSAVER_WAIT          4112
#define IDH_DSKTPSCRSAVER_TEST          4113
#define IDH_DSKTPSCRSAVER_SETTINGS      4114
#define IDH_DSKTPSCRSAVER_MONITOR       4115
#define IDH_SCRSAVER_GRAPHIC            4116
#define IDH_SCRSAVER_LOWPOWSTANDBY      4117
#define IDH_SCRSAVER_SHUTOFFPOW         4118

// Appearance Page

#define IDH_APPEAR_SCHEME               4120
#define IDH_APPEAR_SAVEAS               4121
#define IDH_APPEAR_DELETE               4122
#define IDH_APPEAR_GRAPHIC              4123
#define IDH_APPEAR_ITEMSIZE             4124
#define IDH_APPEAR_FONTBOLD             4125
#define IDH_APPEAR_FONTSIZE             4126
#define IDH_APPEAR_FONTCOLOR            4127
#define IDH_APPEAR_FONTITALIC           4128
#define IDH_APPEAR_BACKGRNDCOLOR        4129
#define IDH_APPEAR_ITEM                 4130
#define IDH_APPEAR_FONT                 4131

// Monitor Settings Page




#define IDH_DSKTPMONITOR_CHANGE_DISPLAY 4134
#define IDH_DSKTPMONITOR_COLOR          4135
#define IDH_DSKTPMONITOR_AREA           4136
#define IDH_DSKTPMONITOR_REFRESH        4137
#define IDH_DSKTPMONITOR_LIST_MODES     4138
#define IDH_DSKTPMONITOR_ENERGY         4139
#define IDH_DSKTPMONITOR_MONITOR        4140
#define IDH_DSKTPMONITOR_TEST           4141
#define IDH_DSKTPMONITOR_ADTYPE         4143
#define IDH_DSKTPMONITOR_CHANGE1        4144
#define IDH_DSKTPMONITOR_CHANGE2        4145
#define IDH_DSKTPMONITOR_MONTYPE        4146
#define IDH_DSKTPMONITOR_CUSTOM         4148
#define IDH_DSKTPMONITOR_FONTSIZE       4149
#define IDH_DSKTPMONITOR_AD_FACTS       4150
#define IDH_DSKTPMONITOR_DRIVER         4151
#define IDH_DSKTPMONITOR_DETECT         4152


#define IDH_SAVESCHEME_EDITFIELD        4170
#define IDH_CUSTOMFONTS_FONTSCALE       4171
#define IDH_CUSTOMFONTS_RULER           4172
#define IDH_CUSTOMFONTS_SAMPLE          4173

#define IDH_PATTERN_EDIT_NAME           4174
#define IDH_PATTERN_EDIT_SAMPLE         4175
#define IDH_PATTERN_EDIT_PIXEL_SCREEN   4176
#define IDH_PATTERN_EDIT_EXIT           4177
#define IDH_PATTERN_EDIT_ADD            4178
#define IDH_PATTERN_EDIT_CHANGE         4179
#define IDH_PATTERN_EDIT_REMOVE         4180

// ID values for Defrag

#define IDH_DEFRAG_START                        4200
#define IDH_DEFRAG_STOP                         4201
#define IDH_DEFRAG_PAUSE                        4202
#define IDH_DEFRAG_SHOWDETAILS                  4203
#define IDH_DEFRAG_HIDEDETAILS                  4204
#define IDH_DEFRAG_LEGEND                       4205
#define IDH_DEFRAG_SPARKLESCRN                  4206
#define IDH_DEFRAG_DEFRAGNOW_ANYWY              4207
#define IDH_DEFRAG_SELECTDRIVE                  4208
#define IDH_DEFRAG_ADVANCED                     4209
#define IDH_DEFRAG_EXIT                         4210
#define IDH_DEFRAG_DRIVELIST                    4211
#define IDH_DEFRAG_RESUME                       4212
#define IDH_DEFRAG_FULL                         4213
#define IDH_DEFRAG_FILESONLY                    4214
#define IDH_DEFRAG_FRSPCONLY                    4215
#define IDH_DEFRAG_USEONCE                      4218
#define IDH_DEFRAG_USEALWAYS                    4219
#define IDH_DEFRAG_GASGAUGE                     4220
#define IDH_DEFRAG_CHECK_DRIVE_FOR_ERRORS       4221

// RNA id values

#define IDH_RNA_CONNECT_NAME            4250
#define IDH_RNA_CONNECT_USER            4251
#define IDH_RNA_CONNECT_PASSWORD        4252
#define IDH_RNA_CONNECT_SAVEPW          4253
#define IDH_RNA_CONNECT_FROM            4254
#define IDH_RNA_OUT_PHONE_NUMBER        4255
#define IDH_RNA_OUT_DIALASST            4256
#define IDH_RNA_OUT_COMPLETE_PHONE      4257
#define IDH_RNA_OUT_CONNECT_BUTTON      4258
#define IDH_RNA_CHOOSE_MODEM            4273
#define IDH_RNA_CONFIG_MODEM            4274
#define IDH_RNA_MODEM_SERVER            4275
#define IDH_RNA_SERVERS                 4276
#define IDH_RNA_CONNECTION_LIST         4277
#define IDH_RNA_SERVER_COMPRESS         4278
#define IDH_RNA_SERVER_ENCRYPT          4279
#define IDH_RNA_SERVER_NETLOGON         4280
#define IDH_RNA_SERVER_PROTOCOL         4281
#define IDH_RNA_SERVER_TCPIPSET         4282
#define IDH_RNA_TCPIP_ASSIGNED_IP       4283
#define IDH_RNA_TCPIP_SPECIFY_IP        4284
#define IDH_RNA_TCPIP_ASSIGNED_DNS      4285
#define IDH_RNA_TCPIP_SPECIFY_DNS       4286
#define IDH_RNA_TCPIP_COMPRESS          4287
#define IDH_RNA_TCPIP_GATEWAY           4288
#define IDH_RNA_SETTINGS_REDIAL         4290
#define IDH_RNA_SETTINGS_TIMES          4291
#define IDH_RNA_SETTINGS_MINSEC         4292
#define IDH_RNA_SETTINGS_PROMPT         4293

// ID values for printing property sheets

#define IDH_PRTPROPS_TYPE_LOCATION              4501
#define IDH_PRTPROPS_COMMENT                    4502
#define IDH_PRTPROPS_NAME_STATIC                4505
#define IDH_PRTPROPS_PORT                       4506
#define IDH_PRTPROPS_DRIVER                     4507
#define IDH_PRTPROPS_NEW_PORT                   4508
#define IDH_PRTPROPS_NEW_DRIVER                 4509
#define IDH_PRTPROPS_SEPARATOR                  4510
#define IDH_PRTPROPS_ICON                       4512
#define IDH_PRTPROPS_SPOOL_SETTINGS             4513
#define IDH_PRTPROPS_PORT_SETTINGS              4514
#define IDH_PRTPROPS_SETUP                      4515
#define IDH_PRTPROPS_SEPARATOR_BROWSE           4516
#define IDH_PRTPROPS_TIMEOUT_NOTSELECTED        4517
#define IDH_PRTPROPS_TIMEOUT_TRANSRETRY         4518
#define IDH_PRTPROPS_TEST_PAGE                  4519
#define IDH_SPOOLSETTINGS_SPOOL                 4520
#define IDH_SPOOLSETTINGS_NOSPOOL               4521
#define IDH_SPOOLSETTINGS_PRINT_FASTER          4522
#define IDH_SPOOLSETTINGS_LESS_SPACE            4523
#define IDH_SPOOLSETTINGS_DATA_FORMAT           4524
#define IDH_SPOOLSETTINGS_RESTORE               4525
#define IDH_PRTPROPS_DEL_PORT                   4528
#define IDH_ADDPORT_NETWORK                     4529
#define IDH_ADDPORT_PORTMON                     4530
#define IDH_ADDPORT_NETPATH                     4531
#define IDH_ADDPORT_BROWSE                      4532
#define IDH_ADDPORT_LB                          4533
#define IDH_DELPORT_LB                          4534
#define IDH_PRTPROPS_MAP_PRN_PORT               4535
#define IDH_PRTPROPS_UNMAP_PRN_PORT             4536
#define IDH_SPOOLSETTINGS_ENABLE_BIDI           4537
#define IDH_SPOOLSETTINGS_DISABLE_BIDI          4538

// ID values for System property sheets

#define IDH_SYSTEM_SYSTEM               4600
#define IDH_SYSTEM_RESOURCES            4602
#define IDH_SYSTEM_OWNER                4603
#define IDH_SYSTEM_PRO_COPY             4624
#define IDH_SYSTEM_PRO_RENAME           4625
#define IDH_SYSTEM_PRO_DELETE           4626
#define IDH_SYSTEM_PRO_LIST             4627
#define IDH_SYSTEM_LOGO                 4628
#define IDH_SYSTEM_CFG_EDIT             4629
#define IDH_SYSTEM_PROCESSOR            4630
#define IDH_SYSTEM_VIEW_RESOURCETYPE    4631
#define IDH_SYSTEM_PAGING               4632
#define IDH_SYSTEM_ADVANCED             4633
#define IDH_SYSTEM_VIRTMEM_ADJUST       4634
#define IDH_SYSTEM_VIRTMEM_DISABLE      4635

#define IDH_SYSTEM_RESERVE_PICKONE      4636

#define IDH_SYSTEM_RESERVE_MODIFY       4639
#define IDH_SYSTEM_RESERVE_ADD          4640
#define IDH_SYSTEM_RESERVE_REMOVE       4641
#define IDH_SYSTEM_CLASSLIST            4642
#define IDH_SYS_PERF_GRAPHICS           4643
#define IDH_SYS_PERF_GRAPHICS_SLIDER    4644

#define IDH_SYSTEM_FILESYSTEM           4661
#define IDH_SYSTEM_DISK                 4662
#define IDH_SYSTEM_CDROM                4663
#define IDH_SYSTEM_CACHE                4664
#define IDH_SYSTEM_BALANCE              4665
#define IDH_SYSTEM_TROUBLESHOOT         4666
#define IDH_SYSTEM_FSCHANGE             4667
#define IDH_DEVMGR_REMOVEONE            4671
#define IDH_DEVMGR_REMOVEALL            4672
#define IDH_SYSTEM_VIEW_RESRES          4673
#define IDH_DEVMGR_CLASS                4674
#define IDH_DEVMGR_ENABLE_HEAD          4675
#define IDH_DEVMGR_PRINT_SELECT         4676
#define IDH_DEVMGR_PRINT_FILE           4677
#define IDH_DEVMGR_SCSI_INFO            4678
#define IDH_DEVMGR_DISKOPTIONS          4679
#define IDH_DEVMGR_DISCONNECT           4680
#define IDH_DEVMGR_SYNC                 4681
#define IDH_DEVMGR_AUTOINSERT           4682
#define IDH_DEVMGR_REMOVABLE            4683
#define IDH_DEVMGR_INT13                4684
#define IDH_DEVMGR_DRIVE_LETTER         4685
#define IDH_DEVMGR_DRIVE_RESERVED       4686
#define IDH_NHF_HELP                4687
#define IDH_NHF_WINDOWS             4688
#define IDH_NHF_DISK                4689
#define IDH_NHF_NODRIVER            4690
#define IDH_NHF_SIMILAR             4691
#define IDH_DMA_MEMORY              4692
#define IDH_DMA_ADDRESS             4693
#define IDH_DMA_DEFAULT             4694
#define IDH_SCSIPROP_SETTINGS       4695
#define IDH_PCI_ENUMTYPE            4697
#define IDH_PCI_IRQ_STEERING        4698
#define IDH_PCI_SETDEFAULTS         4699

// ID's for File properties

#define IDH_FPROP_VER_INFO                      4700
#define IDH_FPROP_GEN_COMPRESSED                4701
#define IDH_FPROP_GEN_COMPRESSED_SIZE           4702
#define IDH_FPROP_SECURITY_PERMISSIONS          4703
#define IDH_FPROP_SECURITY_AUDITING             4704
#define IDH_FPROP_SECURITY_OWNERSHIP            4705
#define IDH_FPROP_ENCRYPT_DETAILS               4706
#define IDH_FPROP_GEN_NAME                      4708
#define IDH_FPROP_GEN_TYPE                      4709
#define IDH_FPROP_GEN_SIZE                      4710
#define IDH_FPROP_GEN_LOCATION                  4711
#define IDH_FPROP_GEN_DOSNAME                   4712
#define IDH_FPROP_GEN_LASTCHANGE                4713
#define IDH_FPROP_GEN_LASTACCESS                4714
#define IDH_FPROP_GEN_READONLY                  4715
#define IDH_FPROP_GEN_ARCHIVE                   4716
#define IDH_FPROP_GEN_HIDDEN                    4717
#define IDH_FPROP_GEN_SYSTEM                    4718
#define IDH_FPROP_GEN_PATH                      4719
#define IDH_FPROP_VER_ABOUT                     4720
#define IDH_FCAB_LINK_NAME                      4721
#define IDH_FCAB_DRV_CLEANUP                    4722
#define IDH_FCAB_LINK_LOCATION                  4723
#define IDH_FCAB_LINK_LINKTO                    4724
#define IDH_FCAB_LINK_LINKTYPE                  4725
#define IDH_FCAB_LINK_SIZE                      4726
#define IDH_FCAB_LINK_WORKING                   4727
#define IDH_FCAB_LINK_HOTKEY                    4728
#define IDH_FCAB_LINK_RUN                       4729
#define IDH_FCAB_LINK_CHANGEICON                4730
#define IDH_FCAB_LINK_FIND                      4731
#define IDH_FCAB_LINK_ICONNAME                  4732
#define IDH_FCAB_LINK_CURRENT_ICON              4733
#define IDH_FCAB_DRV_ICON                       4734
#define IDH_FCAB_DRV_LABEL                      4735
#define IDH_FCAB_DRV_TYPE                       4736
#define IDH_FCAB_DRV_USEDCOLORS                 4737
#define IDH_FCAB_DRV_TOTSEP                     4738
#define IDH_FCAB_DRV_PIE                        4739
#define IDH_FCAB_DRV_LETTER                     4740
#define IDH_FCAB_DRV_FS                         4741
#define IDH_FCAB_DISKTOOLS_CHKNOW               4742
#define IDH_FCAB_DISKTOOLS_BKPNOW               4743
#define IDH_FCAB_DISKTOOLS_OPTNOW               4744
#define IDH_FCAB_DELFILEPROP_DELETED            4745
#define IDH_FCAB_DRV_COMPRESS                   4746
#define IDH_FPROP_GEN_DATE_CREATED              4747
#define IDH_FCAB_FOLDEROPTIONS_ALWAYS           4748
#define IDH_FCAB_FOLDEROPTIONS_NEVER            4749
#define IDH_FCAB_VIEWOPTIONS_SHOWALL            4750
#define IDH_FCAB_VIEWOPTIONS_HIDDENEXTS         4751
#define IDH_FCAB_VIEWOPTIONS_SHOWFULLPATH       4752
#define IDH_FCAB_VIEWOPTIONS_HIDEEXTS           4753
#define IDH_FCAB_VIEWOPTIONS_SHOWDESCBAR        4754
#define IDH_FCAB_FT_PROP_LV_FILETYPES           4755
#define IDH_FCAB_FT_PROP_NEW                    4756
#define IDH_FCAB_FT_PROP_REMOVE                 4757
#define IDH_FCAB_FT_PROP_FINDEXT                4758
#define IDH_FCAB_FT_PROP_EDIT                   4759
#define IDH_FCAB_FT_PROP_DETAILS                4760
#define IDH_FCAB_FT_CMD_ACTION                  4761
#define IDH_FCAB_FT_CMD_EXE                     4762
#define IDH_FCAB_FT_CMD_BROWSE                  4763
#define IDH_FCAB_FT_CMD_USEDDE                  4764
#define IDH_FCAB_FT_CMD_DDEMSG                  4765
#define IDH_FCAB_FT_CMD_DDEAPP                  4766
#define IDH_FCAB_FT_CMD_DDEAPPNOT               4767
#define IDH_FCAB_FT_CMD_DDETOPIC                4768
#define IDH_FCAB_FT_EDIT_DOCICON                4769
#define IDH_FCAB_FT_EDIT_CHANGEICON             4770
#define IDH_FCAB_FT_EDIT_DESC                   4771
#define IDH_FCAB_FT_EDIT_EXT                    4772
#define IDH_FCAB_FT_EDIT_LV_CMDS                4773
#define IDH_FCAB_FT_EDIT_DEFAULT                4774
#define IDH_FCAB_FT_EDIT_NEW                    4775
#define IDH_FCAB_FT_EDIT_EDIT                   4776
#define IDH_FCAB_FT_EDIT_REMOVE                 4777
#define IDH_FCAB_DELFILEPROP_COMPRESSED         4778
#define IDH_FPROP_GEN_ICON                      4779
#define IDH_MULTPROP_NAME                       4780
#define IDH_FPROP_FOLDER_CONTAINS               4781
#define IDH_FCAB_LINK_ICON                      4782
#define IDH_FCAB_DELFILEPROP_LOCATION           4783
#define IDH_FCAB_DELFILEPROP_READONLY           4784
#define IDH_FCAB_DELFILEPROP_HIDDEN             4785
#define IDH_FCAB_DELFILEPROP_ARCHIVE            4786
#define IDH_FCAB_DELFILEPROP_SYSTEM             4787
#define IDH_FCAB_OPENAS_DESCRIPTION             4788
#define IDH_FCAB_OPENAS_APPLIST                 4789
#define IDH_FCAB_OPENAS_OTHER                   4790
#define IDH_FCAB_FT_EDIT_QUICKVIEW              4791
#define IDH_GENDRV_CHKWARN                      4792
#define IDH_GENDRV_MBFREE                       4793
#define IDH_FCAB_OPENAS_MAKEASSOC               4794
#define IDH_FCAB_FT_EDIT_SHOWEXT                4795
#define IDH_FCAB_FT_PROP_CONTTYPERO             4796    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_CONTTYPE               4797    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_DEFEXT                 4798    // T.B.D. IExplorer merge
#define IDH_FCAB_VIEWOPTIONS_SHOWCOMPCOLOR      4799


// Screen saver ids

#define IDH_BEZIER_SPEED                4800
#define IDH_BEZIER_LINES                4801
#define IDH_BEZIER_CURVES               4802
#define IDH_BEZIER_DENSITY              4803
#define IDH_BEZIER_ONECOLOR             4804
#define IDH_BEZIER_CHOOSECLR            4805
#define IDH_BEZIER_MULTCOLOR            4806
#define IDH_BEZIER_CLRSCRN              4807
#define IDH_FLYINGWIN_WARP              4808
#define IDH_FLYINGWIN_DENSTY            4809
#define IDH_COMM_PASSWDCHKBOX           4810
#define IDH_MARQUEE_CENTER              4811
#define IDH_MARQUEE_RANDOM              4812
#define IDH_MARQUEE_SPEED               4813
#define IDH_MARQUEE_COLOR               4814
#define IDH_MARQUEE_TEXT                4815
#define IDH_MARQUEE_FORMAT              4817
#define IDH_MYST_SHAPE                  4818
#define IDH_MYST_ACTVBOX                4819
#define IDH_MYST_LINES                  4820
#define IDH_MYST_TWOCOLORS              4821
#define IDH_MYST_MULTIPLE               4822
#define IDH_MYST_CLEARSCRN              4823
#define IDH_STARS_WARP                  4824
#define IDH_STARS_DENSTY                4825
#define IDH_HOP_DELAY                   4826
#define IDH_HOP_SCALE                   4827

// More ids for file properties (first range wasn't big enough)
#define IDH_FCAB_VIEWOPTIONS_WEBVIEW                    4850
#define IDH_FCAB_VIEWOPTIONS_WIN95VIEW                  4851
#define IDH_FCAB_VIEWOPTIONS_DOUBLECLICKINWEBVIEW       4852
#define IDH_FCAB_VIEWOPTIONS_SINGLECLICKINWEBVIEW       4853
#define IDH_FCAB_LINK_DESCRIPTION                       4854

// New filetype's dialog help ID's
#define IDH_FCAB_FT_NE_ADV_BUT                          4855
#define IDH_FCAB_FT_NE_FILETYPE                         4856
#define IDH_FPROP_GEN_OPENSWITH                         4857
#define IDH_FPROP_GEN_ADVANCED                          4858
#define IDH_FPROP_GEN_INDEX                             4859
#define IDH_FPROP_GEN_ENCRYPT                           4860
#define IDH_FCAB_LINK_RUNASUSER                         4861
#define IDH_FCAB_DRV_INDEX                              4862

#define IDH_FCAB_FT_NE_FILEEXT                          4863
#define IDH_FCAB_FT_PROP_EDIT_RESTORE                   4864

#define IDH_FPROP_GEN_MOUNTEDPROP                       4865
#define IDH_FPROP_GEN_MOUNTEDTARGET                     4866

#define IDH_FPROP_GEN_FOLDER_READONLY                   4867

// id's for date-time property sheet

#define IDH_DATETIME_MONTH              4901
#define IDH_DATETIME_YEAR               4902
#define IDH_DATETIME_DATE               4903
#define IDH_DATETIME_TIME               4904
#define IDH_DATETIME_TIMEZONE           4907
#define IDH_DATETIME_BITMAP             4908
#define IDH_DATETIME_DAYLIGHT_SAVE      4909
#define IDH_DATETIME_CURRENT_TIME_ZONE  4910
#define IDH_DATETIME_DATE_GROUP         4911

// id's for Modem Setup

#define IDH_MODEM_SELECT                5000
#define IDH_MODEM_DETECT                5001
#define IDH_MODEM_PORT                  5002
#define IDH_MODEM_NAME                  5003
#define IDH_MODEM_INSTALLED             5004
#define IDH_MODEM_PROP                  5005
#define IDH_MODEM_NEW                   5006
#define IDH_MODEM_DELETE                5007

// id's for Unimodem property pages

#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056
//#define IDH_UNI_CON_TONE                5057      Deleted
#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060
#define IDH_UNI_CON_PORT                5061
#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072
//#define IDH_UNI_OPT_CONNECTION          5073      Deleted
#define IDH_UNI_OPT_PRE_DIAL            5074
#define IDH_UNI_OPT_POST_DIAL           5075
#define IDH_UNI_OPT_MANUAL              5076
#define IDH_UNI_OPT_STATUS              5077
#define IDH_UNI_TERMINAL                5078
#define IDH_UNI_STATUS_TALK             5079
#define IDH_UNI_STATUS_HANGUP           5080
#define IDH_UNI_GEN_PORT_INT            5081
#define IDH_UNI_OPT_WAIT                5082

#define IDH_LIGHTS                      5099

// id's for TAPI Dial Helper (5100-5199)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// id's 5200 - 5500 are reserved for DOS

//  Add/Remove Program IDs reserved 5600-5699

// Miscellaneous ids

#define IDH_TRAY_RUN_COMMAND            6002
#define IDH_TRAY_RUN_SEPMEM             6003
#define IDH_TRAY_TASKBAR_ONTOP          6004
#define IDH_TRAY_TASKBAR_AUTOHIDE       6005
#define IDH_TRAY_SHUTDOWN_SHUTDOWN      6007
#define IDH_TRAY_SHUTDOWN_RESTART       6008
#define IDH_TRAY_SHUTDOWN_LOGOFF        6009
#define IDH_STARTMENU_SMALLICONS        6010
#define IDH_MENUCONFIG_CLEAR            6011
#define IDH_TRAY_ADD_PROGRAM            6012
#define IDH_TRAY_REMOVE_PROGRAM         6013
#define IDH_TRAY_ADVANCED               6014
#define IDH_TRAY_SHUTDOWN_HELP          6015
#define IDH_TRAY_SHOW_CLOCK             6016
#define IDH_TRAY_REMOVEDLG_LIST         6017
#define IDH_TRAY_REMOVEDLG_DEL          6018
#define IDH_TASKBAR_OPTIONS_BITMAP      6019
#define IDH_TRAY_USE_ADAPTIVE_MENUS     6020
#define IDH_TRAY_RESORT_BUTTON          6021
#define IDH_TRAY_RUN_OK                 6022
#define IDH_TRAY_RUN_CANCEL             6023
#define IDH_TRAY_GROUPING               6024
#define IDH_START_PREVIEW               6025
#define IDH_TRAY_CUSTOMIZE_ICONS        6026
#define IDH_TRAY_RESTOREDEFBUTTON       6027
#define IDH_TRAY_HIDE_ICONS             6028
#define IDH_START_SELECTCLASSIC         6029
#define IDH_START_CUSTOMIZECLASSIC      6030
#define IDH_START_SELECTPERSONAL        6031
#define IDH_START_CUSTOMIZEPERSONAL     6032
#define IDH_TRAY_QUICKLAUNCH            6033

// for the general and advanced tabs of the customize new start menu
#define IDH_START_SPCUST_LARGE          6050
#define IDH_START_SPCUST_SMALL          6051
#define IDH_START_SPCUST_MINPROGS       6052
#define IDH_START_SPCUST_CLEARPROG      6053
#define IDH_START_SPCUST_INTERNET       6054
#define IDH_START_SPCUST_INTERNETCB     6055
#define IDH_START_SPCUST_EMAIL          6056
#define IDH_START_SPCUST_EMAILCB        6057

#define IDH_START_SPCUST_HOVEROPEN      6058
#define IDH_START_SPCUST_NOTIFYNEW      6059
#define IDH_START_STARTMENUSETTINGS     6060
#define IDH_START_SPCUST_RECENT         6061
#define IDH_START_SPCUST_CLEARDOCS      6062

// ID values for Virtual Memory Property sheet

#define IDH_DEVMGR_VIEW_BY              6204
#define IDH_SYSTEM_DM_PRINT             6205
#define IDH_DEVMGR_PATH                 6206

#define IDH_DEVMGR_CONFLICT_TRB         6260
#define IDH_DEVMGR_DRIVERINFO           6261
#define IDH_DEVMGR_CHANGEDRIVER         6262
#define IDH_DEVMGR_DRIVERS              6264
#define IDH_DEVMGR_PRINTER              6265
#define IDH_DEVMGR_PRINTOVERVIEW        6266
#define IDH_DEVMGR_PRINT_SYS            6267
#define IDH_DEVMGR_PRINT_CLASS          6268
#define IDH_DEVMGR_SHOW                 6271
#define IDH_DEVMGR_HAVEDISK             6272
#define IDH_DEVMGR_CHOOSE_DEVICE        6273

//  Ids for the performance page
#define IDH_PERFLOWRES                  6301
#define IDH_PERFLOWMEM                  6302
#define IDH_4MBHELP                     6303
#define IDH_PERFCOMPATVIRTMEM           6304
#define IDH_PERFVIRTMEMOFF              6305
#define IDH_PERFPCMCIAOFF               6306
#define IDH_PERFRMCOMPRESS              6307
#define IDH_PERFNOPMODEDRIVES           6308
#define IDH_PERFMBRHOOK                 6309
#define IDH_PERFREALMODEDRIVE           6310
#define IDH_PERFNOPMODETSR              6311

#define IDH_SYS_PERF_MEMORY             6320
#define IDH_SYS_PERF_SR                 6321
#define IDH_SYS_PERF_FS                 6322
#define IDH_SYS_PERF_VMEM               6323
#define IDH_SYS_PERF_COMPRESS           6324
#define IDH_SYS_PERF_PCMCIA             6325
#define IDH_SYS_PERF_PROBLEM            6326
#define IDH_SYS_PERF_DETAILS            6327


//  sysclass.dll
#define IDH_FPU_DIAGTEXT                6350
#define IDH_FPU_SETTING                 6351
#define IDH_POWERCFG_ENABLE_PM          6352
#define IDH_POWERCFG_FORCE_APM          6353
#define IDH_POWERCFG_DISABLE_INTEL      6354
#define IDH_POWERCFG_POLLING            6355


// More ids for system cpl (ran out of #'s above)
#define IDH_SYSTEM_DMCONFIG_RETRY               6400
#define IDH_SYSTEM_DMCONFIG_IGNORE              6401

#define IDH_SYSTEM_OEMSUPPORT           6407
#define IDH_SYSTEM_DEVGEN_STATUS                6408
#define IDH_SYSTEM_DEGEN_SPECIALMF      6409
#define IDH_SYSTEM_DEVRES_SETTINGS              6410
#define IDH_SYSTEM_USESYSSETTINGS               6411
#define IDH_SYSTEM_DEVRES_CHANGE                6412
#define IDH_SYSTEM_LOGCONFIGLIST                6413
#define IDH_SYSTEM_REGRSTR_RESTORE              6417
#define IDH_SYSTEM_TREE                         6418
#define IDH_SYSTEM_PROPERTIES                   6419
#define IDH_SYSTEM_DM_REFRESH                   6420

#define IDH_SYSTEM_VIRTMEM_ON                   6421
#define IDH_SYSTEM_VIRTMEM_DEFAULT              6422
#define IDH_SYSTEM_VIRTMEM_SWAPDRIVE            6424
#define IDH_SYSTEM_VIRTMEM_MINSIZE              6427
#define IDH_SYSTEM_VIRTMEM_MAXSIZE              6428

#define IDH_SYSTEM_DEVRES_DESC                  6442
#define IDH_SYSTEM_CONFLICT_IO                  6443
#define IDH_SYSTEM_EDITRANGE_STARTVAL           6444
#define IDH_SYSTEM_CONFLICT_USED                6445
#define IDH_SYSTEM_DM_REMOVE                    6446

#define IDH_POWERCFG_ENABLEMETER                        6452
#define IDH_POWERCFG_POWERSTATUSBAR                     6453
#define IDH_POWERCFG_PMLEVELLIST                        6454
#define IDH_POWERCFG_OPTIONS                            6455

#define IDH_PCMCIA_SELECT                               6458
#define IDH_PCMCIA_MEMORY                               6459
#define IDH_PCMCIA_SOUND                                6460
#define IDH_PCMCIA_CARDSERV                             6461

#define IDH_SYSTEM_DEVGEN_DEVDESC                       6462
#define IDH_SYSTEM_DEVRES_MAKEFC                        6463

#define IDH_SYSTEM_DEVRES_LISTCONFLICT                  6474

#define IDH_SYSTEM_VIEW_LIST                            6483
#define IDH_SYSTEM_RCW_LIST                             6485
#define IDH_SYSTEM_RCW_DETAILS                          6488

#define IDH_POWERCFG_STARTMENU          6491
#define IDH_BATMETER_LOWBATWARN         6492

#define IDH_PCMCIA_TRAY                                 6493
#define IDH_PCMCIA_EJECT                                6494
#define IDH_PCMCIA_WARN                                 6495
#define IDH_PCMCIA_LIST                                 6496

// browseui.dll
#define IDH_BROWSEUI_TB_TEXTOPTIONS                             6800
#define IDH_BROWSEUI_TB_ICONOPTIONS                             6801

// More WinDisk IDs

#define IDH_WINDISK_DDEMDBPB_IGNORE                             7000
#define IDH_WINDISK_DDEMDBPB_REPAIR                             7005
#define IDH_WINDISK_DDERRBOOT_IGNORE                            7010
#define IDH_WINDISK_DDERRBOOT_REPAIR                            7015
#define IDH_WINDISK_DDERRCVFNM_IGNORE                           7020
#define IDH_WINDISK_DDERRCVFNM_REPAIR                           7025
#define IDH_WINDISK_DDERRLSTSQZ_DISCARD                         7030
#define IDH_WINDISK_DDERRLSTSQZ_IGNORE                          7035
#define IDH_WINDISK_DDERRLSTSQZ_KEEP                            7040
#define IDH_WINDISK_DDERRMDFAT_IGNORE                           7045
#define IDH_WINDISK_DDERRMDFAT_REPAIR                           7050
#define IDH_WINDISK_DDERRSIG_IGNORE                             7055
#define IDH_WINDISK_DDERRSIG_REPAIR                             7060
#define IDH_WINDISK_DDERRXLSQZ_COPY                             7065
#define IDH_WINDISK_DDERRXLSQZ_DELETE                           7070
#define IDH_WINDISK_DDERRXLSQZ_IGNORE                           7075
#define IDH_WINDISK_DDESIZE2_IGNORE                             7080
#define IDH_WINDISK_DDESIZE2_REPAIR                             7085
#define IDH_WINDISK_FATERRCDLIMIT_DELETE                        7090
#define IDH_WINDISK_FATERRCDLIMIT_IGNORE                        7095
#define IDH_WINDISK_FATERRCDLIMIT_REPAIR                        7100
#define IDH_WINDISK_FATERRFILE_DELETE_FILE                      7105
#define IDH_WINDISK_FATERRFILE_DELETE_FOLDER                    7107
#define IDH_WINDISK_FATERRFILE_IGNORE                           7110
#define IDH_WINDISK_FATERRFILE_REPAIR                           7115
#define IDH_WINDISK_FATERRLSTCLUS_CONVERT                       7120
#define IDH_WINDISK_FATERRLSTCLUS_DISCARD                       7125
#define IDH_WINDISK_FATERRLSTCLUS_IGNORE                        7130
#define IDH_WINDISK_FATERRMISMAT_DONT_REPAIR                    7135
#define IDH_WINDISK_FATERRMISMAT_REPAIR                         7140
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FILE                    7145
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FOLDER                  7150
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FILE                    7155
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FOLDER                  7160
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FILE                    7165
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FOLDER                  7170
#define IDH_WINDISK_FATERRRESVAL_DONT_REPAIR                    7175
#define IDH_WINDISK_FATERRRESVAL_REPAIR                         7180
#define IDH_WINDISK_FATERRXLNK_COPY                             7185
#define IDH_WINDISK_FATERRXLNK_DELETE                           7190
#define IDH_WINDISK_FATERRXLNK_IGNORE                           7195
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_DEL_OTH                 7200
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_TRUNC_OTH               7205
#define IDH_WINDISK_FATERRXLNK_TRUNCATE_ALL                     7210
#define IDH_WINDISK_ISBAD_COMP_HOST_DONE_REPAIR                 7215
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_REPAIR              7220
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_RESTART             7225
#define IDH_WINDISK_ISBAD_COMP_RETRY                            7230
#define IDH_WINDISK_ISBAD_IGNORE                                7235
#define IDH_WINDISK_ISBAD_SYSTEM_IGNORE                         7240
#define IDH_WINDISK_ISBAD_SYSTEM_RETRY                          7245
#define IDH_WINDISK_ISBAD_UNCOMP_DATA_REPAIR                    7250
#define IDH_WINDISK_ISBAD_UNCOMP_RETRY                          7255
#define IDH_WINDISK_ISNTBAD_RETRY                               7260
#define IDH_WINDISK_ISNTBAD_CLEAR                               7265
#define IDH_WINDISK_ISNTBAD_LEAVE                               7270
#define IDH_WINDISK_ISTR_FATERRCIRCC_DELETE                     7275
#define IDH_WINDISK_ISTR_FATERRCIRCC_IGNORE                     7280
#define IDH_WINDISK_ISTR_FATERRCIRCC_TRUNCATE                   7285
#define IDH_WINDISK_ISTR_FATERRDIR_DELETE                       7290
#define IDH_WINDISK_ISTR_FATERRDIR_IGNORE                       7295
#define IDH_WINDISK_ISTR_FATERRDIR_REPAIR                       7300
#define IDH_WINDISK_ISTR_FATERRINVCLUS_DELETE                   7305
#define IDH_WINDISK_ISTR_FATERRINVCLUS_IGNORE                   7310
#define IDH_WINDISK_ISTR_FATERRINVCLUS_TRUNCATE                 7315
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_NOTSET      7320
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_SET         7330
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_NOTSET      7340
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_SET         7350
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_NOTSET      7360
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_SET         7370
#define IDH_WINDISK_MEMORYERROR_IGNORE                          7380
#define IDH_WINDISK_MEMORYERROR_RETRY                           7385
#define IDH_WINDISK_READERROR_RETRY                             7390
#define IDH_WINDISK_READWRITEERROR_COMP_SYSTEM_IGNORE           7395
#define IDH_WINDISK_READWRITEERROR_COMP_THOROUGH                7400
#define IDH_WINDISK_READWRITEERROR_DATA_IGNORE                  7405
#define IDH_WINDISK_READWRITEERROR_UNCOMP_SYSTEM_IGNORE         7410
#define IDH_WINDISK_READWRITEERROR_UNCOMP_THOROUGH              7415
#define IDH_WINDISK_WRITEERROR_RETRY                            7420
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FILE              7425
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FOLDER            7430
#define IDH_SCANDISK                                            7431
#define IDH_SCANDISK_FINISH                                     7432
#define IDH_SCANDISK_FINISH_SURF_HOST                           7433
#define IDH_SCANDISK_FINISH_SURF                                7434
#define IDH_COMPRESS_CORRECT_SIZE                               7435
#define IDH_COMPRESS_CORRECT_RATIO                              7436
#define IDH_UTILITIES_DEFRAG_DISK_ERROR                         7437
#define IDH_CVF_TOO_SMALL_CHECK_HOST                            7438
#define IDH_THOROUGH_TEST_CHECK_HOST                            7439
#define IDH_DISK_LOGICAL                                        7440
#define IDH_DISK_PHYSICAL                                       7441
#define IDH_WINDISK_DDERRMDFAT_LOST_REPAIR                      7442
#define IDH_WINDISK_DDERRMDFAT_LOST_IGNORE                      7443
#define IDH_WINDISK_ISBAD_NO_FREE_CLUSTER                       7444
#define IDH_WINDISK_MAIN_LIST                                   7445
#define IDH_WINDISK_MAIN_STANDARD                               7446
#define IDH_WINDISK_MAIN_OPTIONS                                7447
#define IDH_WINDISK_MAIN_THOROUGH                               7448
#define IDH_WINDISK_MAIN_AUTOFIX                                7449
#define IDH_WINDISK_MAIN_ADVANCED                               7450
#define IDH_WINDISK_ADV_ALWAYS                                  7451
#define IDH_WINDISK_ADV_NEVER                                   7452
#define IDH_WINDISK_ADV_ONLY_IF_FOUND                           7453
#define IDH_WINDISK_ADV_DELETE                                  7454
#define IDH_WINDISK_ADV_MAKE_COPIES                             7455
#define IDH_WINDISK_ADV_IGNORE                                  7456
#define IDH_WINDISK_ADV_FILENAME                                7457
#define IDH_WINDISK_ADV_DATE_TIME                               7458
#define IDH_WINDISK_ADV_CHECK_HOST                              7459
#define IDH_WINDISK_ADV_FREE                                    7460
#define IDH_WINDISK_ADV_CONVERT                                 7461
#define IDH_WINDISK_OPTIONS_SYS_AND_DATA                        7462
#define IDH_WINDISK_OPTIONS_SYS_ONLY                            7463
#define IDH_WINDISK_OPTIONS_DATA_ONLY                           7464
#define IDH_WINDISK_OPTIONS_NO_WRITE_TEST                       7465
#define IDH_WINDISK_OPTIONS_NO_HID_SYS                          7466
#define IDH_FORMATDLG_CAPACITY                                  7467
#define IDH_FORMATDLG_QUICK                                     7468
#define IDH_FORMATDLG_FULL                                      7469
#define IDH_FORMATDLG_DOSYS                                     7470
#define IDH_FORMATDLG_LABEL                                     7471
#define IDH_FORMATDLG_NOLAB                                     7472
#define IDH_FORMATDLG_REPORT                                    7473
#define IDH_FORMATDLG_MKSYS                                     7474
#define IDH_WINDISK_MAIN_START                                  7475
#define IDH_WINDISK_MAIN_CLOSE                                  7476
#define IDH_WINDISK_OK_FOR_ERRORS                               7477
#define IDH_WINDISK_CANCEL_FOR_ERRORS                           7478
#define IDH_WINDISK_MORE_INFO                                   7479
#define IDH_FORMATDLG_START                                     7480
#define IDH_WINDISK_REPLACE_LOG                                 7481
#define IDH_WINDISK_APPEND_LOG                                  7482
#define IDH_WINDISK_NO_LOG                                      7483
#define IDH_FORMATDLG_FILESYS                                   7484
#define IDH_FORMATDLG_ALLOCSIZE                                 7485
#define IDH_FORMATDLG_QUICKFULL                                 7486
#define IDH_FORMATDLG_COMPRESS                                  7487

#define IDH_CHKDSKDLG_START                                     7488
#define IDH_CHKDSKDLG_FIXERRORS                                 7489
#define IDH_CHKDSKDLG_SCAN                                      7490
#define IDH_CHKDSKDLG_CANCEL                                    7491
#define IDH_CHKDSKDLG_PROGRESS                                  7492
#define IDH_FORMATDLG_PROGRESS                                  7493

// IDs for Port Settings

#define IDH_PORT_BAUD                                           7900
#define IDH_PORT_DATA                                           7901
#define IDH_PORT_PARITY                                         7902
#define IDH_PORT_STOPBITS                                       7903
#define IDH_PORT_FLOW                                           7904
#define IDH_PORT_RESTORE                                        7905

// IDs for Modem Diagnostics

#define IDH_MODEM_DIAG_INSTALLED                                7950
#define IDH_MODEM_DIAG_HELP                                     7951
#define IDH_MODEM_DIAG_MOREINFO                                 7952
#define IDH_MODEM_DIAG_DRIVER                                   7953

// IDs for Wastebasket/Recycle

#define IDH_WASTE_FREEING_DISK_SPACE                            8000
#define IDH_RECYCLE_CONFIG_INDEP                                8001
#define IDH_RECYCLE_CONFIG_ALL                                  8002
#define IDH_RECYCLE_PURGE_ON_DEL                                8003
#define IDH_RECYCLE_MAX_SIZE                                    8004
#define IDH_RECYCLE_DRIVE_SIZE                                  8005
#define IDH_RECYCLE_BIN_SIZE                                    8006
#define IDH_DELETE_CONFIRM_DLG                                  8007

#define IDH_FPROP_GEN_CHANGE                                    475102
#define IDH_CONFIRM_OPEN                                        51065
#define IDH_SAME_WINDOW                                         51066

// ID values 8100-8199 are reserved for Font dialog.

#define IDH_TRAY_START_MENU_SETTINGS                            51132
#define IDH_TRAY_DISPLAY_LOGOFF                                 51133
#define IDH_TRAY_DISPLAY_FAVORITES                              51134
#define IDH_TRAY_EXPAND_CPANEL                                  51135
#define IDH_TRAY_EXPAND_MYDOCS                                  51136
#define IDH_TRAY_EXPAND_PRINTERS                                51137
#define IDH_TRAY_SCROLL_PROGRAMS                                51138
#define IDH_TRAY_PERSONALIZED_MENUS                             51139
#define IDH_TRAY_DISPLAY_ADMIN_TOOLS                            51140

#define IDH_TRAY_ENABLEMOVERESIZE                               51143
#define IDH_TRAY_CONTEXTMENU                                    51144

#define IDH_DATETIME_AUTOSETFROMINTERNET                        51150
#define IDH_DATETIME_UPDATEFROMINTERNET                         51151
#define IDH_DATETIME_SERVER_EDIT                                51152
#define IDH_DATETIME_INFOTEXT                                   51153
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\msprintx.h ===
//////////////////////////////////////////////////////////////////////////
//
// This is the public header file for apps that call MSPRINT.DLL
//
//////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

// Typedef for the following function:
//
// BOOL WINAPI PrinterSetup32(HWND hWnd,WORD wAction,WORD wBufSize,
//                            LPBYTE lpBuffer,LPWORD lpwRequired);

typedef BOOL (WINAPI* PRINTERSETUPPROC32)(HWND,WORD,WORD,LPBYTE,LPWORD);

#define MSPRINT2_PRINTERSETUP32  ("PrinterSetup32")

#endif

#define MSP_NEWPRINTER             1
#define MSP_NETPRINTER             2
#define MSP_NEWDRIVER              3
#define MSP_NETADMIN               4
#define MSP_TESTPAGEFULLPROMPT     5
#define MSP_TESTPAGEPARTIALPROMPT  6
#define MSP_TESTPAGENOPROMPT       7
#define MSP_REMOVEPRINTER          8
#define MSP_SPOOLERFOUNDPRINTER    9
#define MSP_REMOVENETPRINTER       10
#define MSP_NEWPRINTER_MODELESS    11
#define MSP_FINDPRINTER            12

#if 0

#define MSPRINT_TESTONLY

#define MSP_BATCHPRINTERS        100

#define PBD_INSTALLED             1L

typedef struct tagONEPRINTERBATCHDATA
{
    char  szFriendlyName[32];
    char  szModelName[32];
    char  szPort[60];
    DWORD dwFlags;
} ONEPRINTERBATCHDATA, FAR * LPONEPRINTERBATCHDATA;

typedef struct tagPRINTERBATCHDATA
{
    char                szFileSource[60];
    DWORD               dwCount;
    ONEPRINTERBATCHDATA Printers[1];
} PRINTERBATCHDATA, FAR * LPPRINTERBATCHDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\inetcpl.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*         Copyright(c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _INETCPLP_H_
#define _INETCPLP_H_

// property sheet page IDs
#define INET_PAGE_GENERAL       0x00000001
#define INET_PAGE_CONNECTION    0x00000002
#define INET_PAGE_PLACES        0x00000004      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_PROGRAMS      0x00000008
#define INET_PAGE_SECURITY_OLD  0x00000010      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_ADVANCED      0x00000020
#define INET_PAGE_PRINT         0x00000040      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_CONTENT       0x00000080
#define INET_PAGE_SECURITY      0x00000100
#define INET_PAGE_ASSOC         0x00000200      // UNIX Assocations
#define INET_PAGE_ALIAS         0x00000400      // UNIX Aliases
#define INET_PAGE_PRIVACY       0x00000800


//  restrict flags
#define R_MULTIMEDIA    0x00000001              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_COLORS        0x00000002              // colors section of the Colors Dialog
#define R_LINKS         0x00000004              // links section of the Colors Dialog
#define R_TOOLBARS      0x00000008              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_FONTS         0x00000010              // Fonts Dialog
#define R_DIALING       0x00000020              // Connection section of Connection tab (incl Settings subdialog)
#define R_PROXYSERVER   0x00000040              // Proxy server section of Connection tab (incl Advanced subdialog)
#define R_CUSTOMIZE     0x00000080              // Homepage section of General tab
#define R_HISTORY       0x00000100              // History section of General tab
#define R_MAILANDNEWS   0x00000200              // Messaging section of Programs tab
#define R_VIEWERS       0x00000400              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_RATINGS       0x00000800              // Ratings section of Content tab
#define R_CERTIFICATES  0x00001000              // Certificates section of Content tab
#define R_ACTIVECONTENT 0x00002000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_WARNINGS      0x00004000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CACHE         0x00008000              // Temporary Internet Files section of General Tab (incl Settings subdialog)
#define R_CRYPTOGRAPHY  0x00010000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_PLACESDEFAULT 0x00020000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_OTHER         0x00040000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CHECKBROWSER  0x00080000              // "IE should check if default browser" checkbox on Programs tab
#define R_LANGUAGES     0x00100000              // Languages Dialog off of the General tab
#define R_ACCESSIBILITY 0x00200000              // Accessibility Dialog off of the General tab
#define R_SECURITY_HKLM_ONLY 0x00400000         // Security tab settings (everything is read only)
#define R_SECURITY_CHANGE_SETTINGS 0x00800000   // Security tab settings (can't change security level for a zone)
#define R_SECURITY_CHANGE_SITES 0x01000000      // Security tab settings (disable everything on Add sites)
#define R_PROFILES      0x02000000              // Profile Asst. section of Content tab
#define R_WALLET        0x04000000              // MS Wallet section of Content tab
#define R_CONNECTION_WIZARD 0x08000000          // Connection wizard button on Connection tab
#define R_AUTOCONFIG    0x10000000              // Auto config section of Programs tab
#define R_ADVANCED      0x20000000              // Entire Advanced tab (including "Restore Defaults")
#define R_CAL_CONTACT   0x40000000              // Personal Info section of Programs tab

#define STR_INETCPL TEXT("inetcpl.cpl") // LoadLibrary() with this string

// structure to pass info to the control panel
typedef struct {
    UINT cbSize;                    // size of the structure
    DWORD dwFlags;                  // enabled page flags (remove pages)
    LPSTR pszCurrentURL;            // the current URL (NULL=none)
    DWORD dwRestrictMask;           // disable sections of the control panel
    DWORD dwRestrictFlags;          // masking for the above
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETS "AddInternetPropertySheets"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETS)(
    LPFNADDPROPSHEETPAGE pfnAddPage,   // add PS callback function
    LPARAM lparam,                     // pointer to prop. sheet header
    PUINT pucRefCount,                 // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback        // PS-to-be-added's callback function (NULL if not used);
);


// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETSEX "AddInternetPropertySheetsEx"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETSEX)(
    LPFNADDPROPSHEETPAGE pfnAddPage, // add PS callback function
    LPARAM lparam,                   // pointer to prop. sheet header
    PUINT pucRefCount,               // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback,     // PS-to-be-added's callback function (NULL if not used)
    LPIEPROPPAGEINFO piepi           // structure to pass info to control panel
);

STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath);
STDAPI_(BOOL) LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, DWORD dwFlags);

#define STR_LAUNCHSECURITYDIALOGEX TEXT("LaunchSecurityDialogEx")

// Flags understood by LaunchSecurityDialog
typedef enum {
    LSDFLAG_DEFAULT    = 0x00000000,
    LSDFLAG_NOADDSITES = 0x00000001,
    LSDFLAG_FORCEUI    = 0x00000002
} LSDFLAG;

typedef BOOL (STDMETHODCALLTYPE * PFNLAUNCHSECURITYDIALOGEX)(
    HWND        hDlg,    // Parent Window
    DWORD       dwZone,  // Initial Zone to display, as defined in urlmon
    DWORD       dwFlags // Initialization flags: or'd combination of LSD_FLAGS
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\lpcgeneric.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCGeneric.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are generic to
//  any API.
//
//  History:    1999-11-17  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-10-12  vtan        moved from DS to SHELL depot
//  --------------------------------------------------------------------------

#ifndef     _LPCGeneric_
#define     _LPCGeneric_

enum
{
    API_GENERIC_STOPSERVER              =   0x00010000,
    API_GENERIC_EXECUTE_IMMEDIATELY     =   0x80000000,

    API_GENERIC_SPECIAL_MASK            =   0x00FF0000,
    API_GENERIC_OPTIONS_MASK            =   0xFF000000,
    API_GENERIC_RESERVED_MASK           =   0xFFFF0000,
    API_GENERIC_NUMBER_MASK             =   0x0000FFFF
};

typedef union
{
    unsigned long   ulAPINumber;        //   IN: API number request to server
    NTSTATUS        status;             //  OUT: NTSTATUS error code returned from server
} API_GENERIC;

#endif  /*  _LPCGeneric_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\lpcfus.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCFUS.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are specific to
//  the bad application API.
//
//  History:    2000-08-26  vtan        created
//              2000-10-12  vtan        moved from DS to SHELL depot
//  --------------------------------------------------------------------------

#ifndef     _LPCFUS_
#define     _LPCFUS_

#include <LPCGeneric.h>

static  const TCHAR     FUS_PORT_NAME[]             =   L"\\FusApiPort";
static  const TCHAR     FUS_CONNECTION_REQUEST[]    =   L"FusApiConnectionRequest";

enum
{
    API_BAM_QUERYRUNNING            =   1,
    API_BAM_REGISTERRUNNING,
    API_BAM_QUERYUSERPERMISSION,
    API_BAM_TERMINATERUNNING,

    API_BAM_REQUESTSWITCHUSER       =   1001,
};

typedef enum
{
    BAM_TYPE_MINIMUM                            =   0,
    BAM_TYPE_UNKNOWN                            =   BAM_TYPE_MINIMUM,
    BAM_TYPE_SECOND_INSTANCE_START,
    BAM_TYPE_SWITCH_USER,
    BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE,
    BAM_TYPE_SWITCH_TO_NEW_USER,
    BAM_TYPE_MAXIMUM
} BAM_TYPE;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
} API_BAM_QUERYRUNNING_IN;

typedef struct
{
    bool            fResult;
} API_BAM_QUERYRUNNING_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
    DWORD           dwProcessID;
    BAM_TYPE        bamType;
} API_BAM_REGISTERRUNNING_IN;

typedef struct
{
} API_BAM_REGISTERRUNNING_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
    WCHAR           *pszUser;
    int             cchUser;
} API_BAM_QUERYUSERPERMISSION_IN;

typedef struct
{
    bool            fCanShutdownApplication;
} API_BAM_QUERYUSERPERMISSION_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
} API_BAM_TERMINATERUNNING_IN;

typedef struct
{
    bool            fResult;
} API_BAM_TERMINATERUNNING_OUT;

typedef struct
{
} API_BAM_REQUESTSWITCHUSER_IN;

typedef struct
{
    bool            fAllowSwitch;
} API_BAM_REQUESTSWITCHUSER_OUT;

typedef union
{
    union
    {
        API_BAM_QUERYRUNNING_IN             in;
        API_BAM_QUERYRUNNING_OUT            out;
    } apiQueryRunning;
    union
    {
        API_BAM_REGISTERRUNNING_IN          in;
        API_BAM_REGISTERRUNNING_OUT         out;
    } apiRegisterRunning;
    union
    {
        API_BAM_QUERYUSERPERMISSION_IN      in;
        API_BAM_QUERYUSERPERMISSION_OUT     out;
    } apiQueryUserPermission;
    union
    {
        API_BAM_TERMINATERUNNING_IN         in;
        API_BAM_TERMINATERUNNING_OUT        out;
    } apiTerminateRunning;
    union
    {
        API_BAM_REQUESTSWITCHUSER_IN        in;
        API_BAM_REQUESTSWITCHUSER_OUT       out;
    } apiRequestSwitchUser;
} API_BAM_SPECIFIC;

typedef struct
{
    API_GENERIC         apiGeneric;
    API_BAM_SPECIFIC    apiSpecific;
} API_BAM, *PAPI_BAM;

typedef struct
{
    PORT_MESSAGE    portMessage;
    API_BAM         apiBAM;
} FUSAPI_PORT_MESSAGE, *PFUSAPI_PORT_MESSAGE;

#endif  /*  _LPCFUS_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\makefile.inc ===
#
#
#  R E A D   T H I S
#
#  See the inference rules below (the section marked "Inference rules") to
#  see if any of them cover the rule that you want performed for your file.
#  The inference rules should cover most of the cases.  If they don't, try
#  to add a new inference rule rather than adding a special-case rule for
#  your file.
#

#
# Explicit dependencies for .w files -- needed to make inference rules apply
#

# cmnquery.w -> $(SDK_INC_PATH)\cmnquery.h
# (reinerf) - why are we splitting this if we only use the public file??
$(O)\cmnquery.h : cmnquery.w

# commctrl.w -> $(SDK_INC_PATH)\commctrl.h, $(SDK_INC_PATH)\commctrl.rh, $(PROJECT_INC_PATH)\comctrlp.h
$(O)\commctrl.h $(O)\commctrlp.h : commctrl.w

# commdlg.w -> $(SDK_INC_PATH)\commdlg.h, $(PROJECT_INC_PATH)\commdlgp.h
$(O)\commdlg.h $(O)\commdlgp.h : commdlg.w

# cpl.w -> $(SDK_INC_PATH)\cpl.h, $(PROJECT_INC_PATH)\cplp.h
$(O)\cpl.h $(O)\cplp.h : cpl.w

# dsclient.w -> $(SDK_INC_PATH)\dsclient.h, $(PROJECT_INC_PATH)\dsclintp.h
$(O)\dsclient.h $(O)\dsclientp.h : dsclient.w

# dsquery.w -> $(SDK_INC_PATH)\dsquery.h, $(PROJECT_INC_PATH)\dsqueryp.h
$(O)\dsquery.h $(O)\dsqueryp.h : dsquery.w

# intshcut.w -> $(SDK_INC_PATH)\intshcut.h, $(PROJECT_INC_PATH)\intshctp.h
$(O)\intshcut.h $(O)\intshcutp.h : intshcut.w

# multimon.w -> $(SDK_INC_PATH)\multimon.h, $(PROJECT_INC_PATH)\multimop.h
$(O)\multimon.h $(O)\multimonp.h : multimon.w

# prsht.w -> $(SDK_INC_PATH)\prsht.h, $(PROJECT_INC_PATH)\prshtp.h
$(O)\prsht.h $(O)\prshtp.h : prsht.w

# powrprof.w -> $(SDK_INC_PATH)\powrprof.h, $(PROJECT_INC_PATH)\powrprofp.h
$(O)\powrprof.h $(O)\powrprofp.h : powrprof.w

# shellapi.w -> $(SDK_INC_PATH)\shellapi.h, $(PROJECT_INC_PATH)\shlapip.h
$(O)\shellapi.h $(O)\shellapip.h : shellapi.w

#shlguid.w -> $(SDK_INC_PATH)\shlguid.h, $(PROJECT_INC_PATH)\shlguidp.h
$(O)\shlguid.h $(O)\shlguidp.h : shlguid.w

# shlobj.w -> $(SDK_INC_PATH)\shlobj.h, $(PROJECT_INC_PATH)\shlobjp.h
$(O)\shlobj.h $(O)\shlobjp.h : shlobj.w

# shlwapi.w -> $(SDK_INC_PATH)\shlwapi.h, $(PROJECT_INC_PATH)\shlwapip.h
$(O)\shlwapi.h $(O)\shlwapip.h : shlwapi.w

# winver.w -> $(SDK_INC_PATH)\winver.h
$(O)\winver.h : winver.w


$(O)\commctrl.rh: $(O)\commctrl.h
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    commctrl.rh

Abstract:

    This module defines the 32-Bit Windows resource codes from commctrl.h.

Revision History:

--*/
<<
    hextract -o $@ -lt r_commctrl -bt begin_r_commctrl end_r_commctrl $(O)\commctrl.h

#
# Explicit dependencies for public files that must be done on pass0
#

$(O)\shobjidl_pub.idl : shobjidl.idl
    hsplit -e -o $(O)\shobjidl_pub.idl $(O)\shobjidl_priv.idl $**

$(O)\shobjidl_pub.h : $(O)\shobjidl.h
    hsplit -e -o $(O)\shobjidl_pub.h $(O)\shobjidl_priv.h $**

#
# Explicit dependencies for private files that must be done on pass0
#

$(PROJECT_ROOT)\lib\$(O)\brdispp.tlb : $(O)\brdispp.tlb
$(O)\brdispp.tlb : brdispp.idl $(O)\brdispp.h
$(PROJECT_ROOT)\inc\$(O)\brdispp.h : $(O)\brdispp.h
$(PROJECT_ROOT)\lib\$O\brdispp_i.c : $(O)\brdispp_i.c

$(PROJECT_ROOT)\inc\$(O)\intshctp.h : $(O)\intshcut.h
    copy $(O)\intshcutp.h $(PROJECT_ROOT)\inc\$(O)\intshctp.h

$(PROJECT_ROOT)\inc\$(O)\navbar.h : $(O)\navbar.h

$(PROJECT_ROOT)\inc\$(O)\navlog.h : $(O)\navlog.h

$(PROJECT_ROOT)\inc\$(O)\shobjidlp.h : $(O)\shobjidl_pub.h
    copy $(O)\shobjidl_priv.h $(PROJECT_ROOT)\inc\$(O)\shobjidlp.h

$(PROJECT_ROOT)\lib\$(O)\msieftp.tlb : $(O)\msieftp.tlb
$(O)\msieftp.tlb : msieftp.idl $(O)\msieftp.h
$(PROJECT_ROOT)\inc\$(O)\msieftp.h : $(O)\msieftp.h
$(PROJECT_ROOT)\lib\$O\msieftp_i.c : $(O)\msieftp_i.c

$(PROJECT_ROOT)\lib\$(O)\theme.tlb : $(O)\theme.tlb
$(O)\theme.tlb : theme.idl $(O)\theme.h
$(PROJECT_ROOT)\inc\$(O)\theme.h : $(O)\theme.h
$(PROJECT_ROOT)\lib\$O\theme_i.c : $(O)\theme_i.c

$(PROJECT_ROOT)\lib\$(O)\shgina.tlb : $(O)\shgina.tlb
$(O)\shgina.tlb : shgina.idl $(O)\shgina.h

$(PROJECT_ROOT)\lib\$(O)\shldisp.tlb : $(O)\shldisp.tlb
$(O)\shldisp.tlb : shldisp.idl $(O)\shldisp.h

$(PROJECT_ROOT)\lib\$(O)\shimgvw.tlb : $(O)\shimgvw.tlb
$(O)\shimgvw.tlb : shimgvw.idl $(O)\shimgvw.h
$(PROJECT_ROOT)\inc\$(O)\shimgvw.h : $(O)\shimgvw.h
$(PROJECT_ROOT)\lib\$(O)\shimgvw_i.c : $(O)\shimgvw_i.c

$(PROJECT_ROOT)\inc\$(O)\opsprof.h : $(O)\opsprof.h

$(PROJECT_ROOT)\lib\$(O)\webvw.tlb : $(O)\webvw.tlb
$(O)\webvw.tlb : webvw.idl $(O)\webvw.h
$(PROJECT_ROOT)\inc\$(O)\webvw.h : $(O)\webvw.h
$(PROJECT_ROOT)\lib\$(O)\webvw_i.c : $(O)\webvw_i.c

$(PROJECT_ROOT)\lib\$(O)\shpriv_i.c : $(O)\shpriv_i.c
$(O)\shpriv_i.c : shpriv.idl

$(PROJECT_ROOT)\lib\$(O)\iepriv_i.c : $(O)\iepriv_i.c
$(O)\iepriv_i.c : iepriv.idl

#
# Inference rules.  These help build whatever is in the NTTARGETFILES and
# NTTARGETFILE0 lists.
#

.SUFFIXES:.w .h .tlb

# generate header.h and headerp.h from header.w
{}.w{$O}.h:
    hsplit -e -o $(*R).x $(*R)p.x $**
    wcshdr < $(*R)p.x > $(*R)p.h
    wcshdr < $(*R).x > $(*R).y
    shfusion2 $(*R).y > $@

# copy generated headers to shell\inc
{$O}.h{$(PROJECT_ROOT)\inc\$(O)}.h:
    copy $** $@

# copy generated tlb's to shell\lib\$O
{$O}.tlb{$(PROJECT_ROOT)\lib\$O}.tlb:
    copy $** $@

# copy generated c's to shell\lib\$O
{$O}.c{$(PROJECT_ROOT)\lib\$O}.c:
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\msluguid.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _MSLUGUID_H_
#define _MSLUGUID_H_

// 95D0F020-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(CLSID_LocalUsers, 0x95D0F020L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F023-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUser,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F022-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserDatabase,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F024-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserProfileInit,0x95D0F024L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

#ifdef USER_SETTINGS_IMPLEMENTED
// EA7364C0-0730-11D0-83B1-00C04FD705B2
DEFINE_GUID(IID_IUserSettings,0xEA7364C0L, 0x0730, 0x11D0, 0x83, 0xB1, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xB2);
#endif

#endif  // _MSLUGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\lpcthemes.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCThemes.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are specific to
//  the theme services API.
//
//  History:    2000-10-10  vtan        created
//              2000-11-11  vtan        collapse to single instance
//  --------------------------------------------------------------------------

#ifndef     _LPCThemes_
#define     _LPCThemes_

#include <LPCGeneric.h>

static  const WCHAR     THEMES_PORT_NAME[]              =   L"\\ThemeApiPort";
static  const WCHAR     THEMES_CONNECTION_REQUEST[]     =   L"ThemeApiConnectionRequest";
static  const WCHAR     THEMES_START_EVENT_NAME[]       =   L"ThemesStartEvent";

enum
{
    API_THEMES_THEMEHOOKSON             =   1,
    API_THEMES_THEMEHOOKSOFF,
    API_THEMES_GETSTATUSFLAGS,
    API_THEMES_GETCURRENTCHANGENUMBER,
    API_THEMES_GETNEWCHANGENUMBER,
    API_THEMES_SETGLOBALTHEME,
    API_THEMES_GETGLOBALTHEME,
    API_THEMES_CHECKTHEMESIGNATURE,
    API_THEMES_LOADTHEME,
    API_THEMES_MARKSECTION,
    API_THEMES_PROCESSLOADTHEME,
    API_THEMES_PROCESSASSIGNSECTION,

    API_THEMES_USERLOGON                =   1001,
    API_THEMES_USERLOGOFF,
    API_THEMES_SESSIONCREATE,
    API_THEMES_SESSIONDESTROY,
    API_THEMES_PING
};

typedef struct
{
} API_THEMES_THEMEHOOKSON_IN;

typedef struct
{
    HRESULT             hr;
} API_THEMES_THEMEHOOKSON_OUT;

typedef struct
{
} API_THEMES_THEMEHOOKSOFF_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_THEMEHOOKSOFF_OUT;

typedef struct
{
} API_THEMES_GETSTATUSFLAGS_IN;

typedef struct
{
    DWORD           dwFlags;
} API_THEMES_GETSTATUSFLAGS_OUT;

typedef struct
{
} API_THEMES_GETCURRENTCHANGENUMBER_IN;

typedef struct
{
    int             iChangeNumber;
} API_THEMES_GETCURRENTCHANGENUMBER_OUT;

typedef struct
{
} API_THEMES_GETNEWCHANGENUMBER_IN;

typedef struct
{
    int             iChangeNumber;
} API_THEMES_GETNEWCHANGENUMBER_OUT;

typedef struct
{
    HANDLE          hSection;
} API_THEMES_SETGLOBALTHEME_IN;

typedef struct
{
    HANDLE          hSection;
    DWORD           dwAdd;
    DWORD           dwRemove;
} API_THEMES_MARKSECTION_IN;

typedef struct
{
} API_THEMES_MARKSECTION_OUT;

typedef struct
{
    HRESULT         hr;
} API_THEMES_SETGLOBALTHEME_OUT;

typedef struct
{
} API_THEMES_GETGLOBALTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_GETGLOBALTHEME_OUT;

typedef struct
{
    const WCHAR     *pszName;
    int             cchName;
} API_THEMES_CHECKTHEMESIGNATURE_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_CHECKTHEMESIGNATURE_OUT;

typedef struct
{
    const WCHAR     *pszName;
    int             cchName;
    const WCHAR     *pszColor;
    int             cchColor;
    const WCHAR     *pszSize;
    int             cchSize;
    HANDLE          hSection;
} API_THEMES_LOADTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_LOADTHEME_OUT;

typedef struct
{
    const WCHAR     *pszName;    // full path of msstyles file
    int             cchName;     // count of chars of pszName, including NULL.
    const WCHAR     *pszColor;   // color variant name
    int             cchColor;    // count of chars of pszColor, including NULL.
    const WCHAR     *pszSize;    // size variant name
    int             cchSize;     // count of chars of pszSize, including NULL.
} API_THEMES_PROCESSLOADTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_PROCESSLOADTHEME_OUT;

typedef struct
{
    HRESULT         hrLoad;
    HANDLE          hSection;
    ULONG           dwHash;
} API_THEMES_PROCESSASSIGNSECTION_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_PROCESSASSIGNSECTION_OUT;

typedef struct
{
} API_THEMES_GETLASTERRORCONTEXT_IN;

typedef struct
{
} API_THEMES_GETLASTERRORCONTEXT_OUT;

typedef struct
{
} API_THEMES_GETERRORCONTEXTSECTION_IN;

typedef struct
{
    HANDLE          hSection;
} API_THEMES_GETERRORCONTEXTSECTION_OUT;

typedef struct
{
    HANDLE          hToken;
} API_THEMES_USERLOGON_IN;

typedef struct
{
} API_THEMES_USERLOGON_OUT;

typedef struct
{
} API_THEMES_USERLOGOFF_IN;

typedef struct
{
} API_THEMES_USERLOGOFF_OUT;

typedef struct
{
    void            *pfnRegister;
    void            *pfnUnregister;
    void            *pfnClearStockObjects;
    DWORD           dwStackSizeReserve;
    DWORD           dwStackSizeCommit;
} API_THEMES_SESSIONCREATE_IN;

typedef struct
{
} API_THEMES_SESSIONCREATE_OUT;

typedef struct
{
} API_THEMES_SESSIONDESTROY_IN;

typedef struct
{
} API_THEMES_SESSIONDESTROY_OUT;

typedef struct
{
} API_THEMES_PING_IN;

typedef struct
{
} API_THEMES_PING_OUT;

typedef union
{
    union
    {
        API_THEMES_THEMEHOOKSON_IN             in;
        API_THEMES_THEMEHOOKSON_OUT            out;
    } apiThemeHooksOn;
    union
    {
        API_THEMES_THEMEHOOKSOFF_IN             in;
        API_THEMES_THEMEHOOKSOFF_OUT            out;
    } apiThemeHooksOff;
    union
    {
        API_THEMES_GETSTATUSFLAGS_IN            in;
        API_THEMES_GETSTATUSFLAGS_OUT           out;
    } apiGetStatusFlags;
    union
    {
        API_THEMES_GETCURRENTCHANGENUMBER_IN    in;
        API_THEMES_GETCURRENTCHANGENUMBER_OUT   out;
    } apiGetCurrentChangeNumber;
    union
    {
        API_THEMES_GETNEWCHANGENUMBER_IN        in;
        API_THEMES_GETNEWCHANGENUMBER_OUT       out;
    } apiGetNewChangeNumber;
    union
    {
        API_THEMES_SETGLOBALTHEME_IN            in;
        API_THEMES_SETGLOBALTHEME_OUT           out;
    } apiSetGlobalTheme;
    union
    {
        API_THEMES_MARKSECTION_IN               in;
        API_THEMES_MARKSECTION_OUT              out;
    } apiMarkSection;
    union
    {
        API_THEMES_GETGLOBALTHEME_IN            in;
        API_THEMES_GETGLOBALTHEME_OUT           out;
    } apiGetGlobalTheme;
    union
    {
        API_THEMES_CHECKTHEMESIGNATURE_IN       in;
        API_THEMES_CHECKTHEMESIGNATURE_OUT      out;
    } apiCheckThemeSignature;
    union
    {
        API_THEMES_LOADTHEME_IN                 in;
        API_THEMES_LOADTHEME_OUT                out;
    } apiLoadTheme;
    union
    {
        API_THEMES_PROCESSLOADTHEME_IN          in;
        API_THEMES_PROCESSLOADTHEME_OUT         out;
    } apiProcessLoadTheme;
    union
    {
        API_THEMES_PROCESSASSIGNSECTION_IN         in;
        API_THEMES_PROCESSASSIGNSECTION_OUT        out;
    } apiProcessAssignSection;
    union
    {
        API_THEMES_USERLOGON_IN                 in;
        API_THEMES_USERLOGON_OUT                out;
    } apiUserLogon;
    union
    {
        API_THEMES_USERLOGOFF_IN                in;
        API_THEMES_USERLOGOFF_OUT               out;
    } apiUserLogoff;
    union
    {
        API_THEMES_SESSIONCREATE_IN             in;
        API_THEMES_SESSIONCREATE_OUT            out;
    } apiSessionCreate;
    union
    {
        API_THEMES_SESSIONDESTROY_IN            in;
        API_THEMES_SESSIONDESTROY_OUT           out;
    } apiSessionDestroy;
    union
    {
        API_THEMES_PING_IN                      in;
        API_THEMES_PING_OUT                     out;
    } apiPing;
} API_THEMES_SPECIFIC;

typedef struct
{
    API_GENERIC             apiGeneric;
    API_THEMES_SPECIFIC     apiSpecific;
} API_THEMES, *PAPI_THEMES;

typedef struct
{
    PORT_MESSAGE    portMessage;
    API_THEMES      apiThemes;
} THEMESAPI_PORT_MESSAGE, *PTHEMESAPI_PORT_MESSAGE;

EXTERN_C    DWORD   WINAPI  ThemeWaitForServiceReady (DWORD dwTimeout);
EXTERN_C    BOOL    WINAPI  ThemeWatchForStart (void);
EXTERN_C    BOOL    WINAPI  ThemeUserLogon (HANDLE hToken);
EXTERN_C    BOOL    WINAPI  ThemeUserLogoff (void);
EXTERN_C    BOOL    WINAPI  ThemeUserTSReconnect (void);
EXTERN_C    BOOL    WINAPI  ThemeUserStartShell (void);

typedef DWORD   (WINAPI * PFNTHEMEWAITFORSERVICEREADY) (DWORD dwTimeout);
typedef BOOL    (WINAPI * PFNTHEMEWATCHFORSTART) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERLOGON) (HANDLE hToken);
typedef HANDLE  (WINAPI * PFNTHEMEUSERLOGOFF) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERTSRECONNECT) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERSTARTSHELL) (void);

#define ORDINAL_THEMEWAITFORSERVICEREADY    1
#define ORDINAL_THEMEWATCHFORSTART          2
#define ORDINAL_THEMEUSERLOGON              3
#define ORDINAL_THEMEUSERLOGFF              4
#define ORDINAL_THEMEUSERTSRECONNECT        5
#define ORDINAL_THEMEUSERSTARTSHELL         6

#endif  /*  _LPCThemes_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\msluapi.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _MSLUAPI_H_
#define _MSLUAPI_H_

#ifdef USER_SETTINGS_IMPLEMENTED

/************************************************************************

IUserSettings interface

This interface is used to manipulate the settings for a particular component,
corresponding to a local user account.  An IUserSettings interface may be
obtained by CLSID or name, or through enumeration;  in both cases, this is
relative to a particular user.

Member functions, other than IUnknown:

GetCLSID(CLSID *pclsidOut)
	Returns the CLSID identifying the component.  May be GUID_NULL if no
	CLSID is defined for the component.

GetName(LPSTR pbBuffer, UINT cbBuffer)
	Returns a unique name identifying the component.  This may be used
	instead of a CLSID if the component provider does not wish to provide
	a COM server to help administer the settings.

GetDisplayName(LPSTR pbBuffer, UINT cbBuffer)
	Returns a user-friendly name for the component, suitable for presentation
	to the user.

QueryKey(HKEY *phkeyOut)
	Returns a registry key where the component stores settings for the
	specified user.  The key is owned by the interface and must not be
	closed by the application using RegCloseKey, otherwise changes will
	not be propagated correctly.

((((
OpenKey(HKEY *phkeyOut, DWORD fdwAccess)
	Returns a registry key where the component stores settings for the
	specified user.  The key MUST be closed using IUserSettings::CloseKey
	so that changes will be propagated correctly.  fdwAccess indicates
	the type of access desired;  valid values include GENERIC_READ and
	GENERIC_WRITE.

CloseKey(HKEY hKey)
	Closes a registry key obtained via IUserSettings::OpenKey.

Lock(BOOL fLock)
	Locks or unlocks the settings for updates.  Attempting to lock the
	settings will fail if they are already locked.  Locking the settings
	does not, however, affect any of the other member functions
))))
************************************************************************/

DECLARE_INTERFACE_(IUserSettings, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetCLSID) (THIS_ CLSID *pclsidOut) PURE;
	STDMETHOD(GetName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;
	STDMETHOD(GetDisplayName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;

	STDMETHOD(QueryKey) (THIS_ HKEY *phkeyOut) PURE;
};
#endif  /* USER_SETTINGS_IMPLEMENTED */


/************************************************************************

IUser interface

This interface is used to manipulate a local user account.  It allows
various operations to be performed on a particular user.  To obtain one
of these interfaces, the companion interface IUserDatabase must be
used -- its AddUser, GetUser, and GetCurrentUser member functions all
return IUser objects, as does IEnumUsers::Next.

In all descriptions here, "the user" refers to the user which this
ILocalUser object describes.  "The current user" means the user who
is currently logged on at the workstation.

If the current user is a supervisor, all functions are allowed.  Otherwise,
a more limited set of member functions is available if the IUser object
corresponds to the current user.  If the current user is not a supervisor
and the IUser object refers to a different user, a still more limited set
of functions is allowed.

Member functions, other than IUnknown:

GetName(LPSTR pbBuffer, UINT cbBuffer)
	Returns the user's logon name.

GetProfileDirectory(LPSTR pbBuffer, UINT cbBuffer)
	Returns the user's local profile directory (e.g., C:\WINDOWS\PROFILES\gregj).
	May fail if the user is the default user (doesn't really have a profile
	directory as such).

IsSupervisor()
	Returns whether the user is a supervisor or not.  This is not a generic
	property because it's actually based on the presence of security info
	in the user's PWL (at least on win95).

SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
	Grants or revokes supervisor privilege for the user.  Only supervisors
	can grant or revoke that privilege, of course.  If pszSupervisorPassword
    is not NULL, it is used to determine whether the current user is a
    supervisor.  If it is NULL, then the current user's password cache is
    used instead.  This allows making any user into a supervisor without
    the current user being one.

MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
    Grants or revokes supervisor privilege for the user, but only for the
    lifetime of this IUser object.  As soon as the object is destroyed,
    the user is no longer considered a supervisor, and in fact other IUser
    objects currently in existence which refer to the same user will not
    indicate him as a supervisor.

    Note that MakeTempSupervisor(FALSE) only revokes temporary-supervisor
    privilege granted by MakeTempSupervisor(TRUE).  If the user still has
    the supervisor password in his PWL, he will still be considered a
    supervisor.

AppearsSupervisor()
	Returns whether or not the user should appear as a supervisor in a list
	of users.  This allows querying this property on each user for display
	purposes without taking the large performance hit to locate each user's
	PWL, open it up, get the supervisor key out, and validate it.  Instead,
	a registry value under the user's key is used to maintain this value.
	It should NOT be used to determine whether the user has permission to
	do something, because the simple registry value is not as secure.

Authenticate(LPCSTR pszPassword)
	Attempts to authenticate the user using the given password.  Returns
	S_OK if the password is correct for the user, or an error otherwise.
	No user interface is displayed by this function.

ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
	Attempts to change the user's password from the given old password
	to the given new password.  Returns an error code indicating success
	or failure.  If the current user is a supervisor, the old password
	may be NULL, in which case the supervisor's credentials are used to
	get the password via other means.

GetPasswordCache(LPCSTR pszPassword, LPHPWL phOut)
	Returns a handle to the user's password cache, suitable for use with
	the MSPWL32.DLL APIs.  May fail, of course, if password caching is
	disabled.

LoadProfile(LPHKEY phkeyUser)
    Loads the user's profile into the registry and returns a handle to the
    root key.  The current user can always load his own profile (just returns
    HKEY_CURRENT_USER);  to load other users' profiles, the current user must
    be a supervisor.  IUser::UnloadProfile() should always be called when the
    caller is done playing with the user's profile.

UnloadProfile(HKEY hkeyUser)
    Unloads the user's profile from the registry if possible, and closes the
    key handle returned by IUser::LoadProfile.  If the specified user is the
    current user, this function does nothing.

GetComponentSettings(REFCLSID clsidComponent, LPCSTR pszName,
					 IUnknown **ppOut, DWORD fdwAccess)
    CURRENTLY NOT IMPLEMENTED
	Returns an IUserSettings interface which can be used to access the
	user's settings for a particular component.  Either clsidComponent or
	pszName may be used to refer to the component whose settings are to be
	accessed.  If pszName is not NULL, it takes precedence over clsidComponent.
	fdwAccess specifies whether the caller wants read or write access to the
	settings.  If the component's settings are restricted and the current user
	is not a supervisor, only GENERIC_READ access will be allowed;
	GENERIC_WRITE will fail.

EnumerateComponentSettings(IEnumUnknown **ppOut, DWORD fdwAccess)
    CURRENTLY NOT IMPLEMENTED
	Returns an IEnumUnknown interface which can be used to enumerate all
	components which have settings recorded for the user.  fdwAccess
	specifies the desired access, read or write.  If the current user
	is not a supervisor and the caller requests write access, the enumerator
	will not return any components which do not permit such access.

************************************************************************/

DECLARE_INTERFACE_(IUser, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;
	STDMETHOD(GetProfileDirectory) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;

	STDMETHOD(IsSupervisor) (THIS) PURE;
	STDMETHOD(SetSupervisorPrivilege) (THIS_ BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword) PURE;
	STDMETHOD(MakeTempSupervisor) (THIS_ BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword) PURE;
	STDMETHOD(AppearsSupervisor) (THIS) PURE;

	STDMETHOD(Authenticate) (THIS_ LPCSTR pszPassword) PURE;
	STDMETHOD(ChangePassword) (THIS_ LPCSTR pszOldPassword, LPCSTR pszNewPassword) PURE;
	STDMETHOD(GetPasswordCache) (THIS_ LPCSTR pszPassword, LPHANDLE phOut) PURE;

    STDMETHOD(LoadProfile) (THIS_ HKEY *phkeyUser) PURE;
    STDMETHOD(UnloadProfile) (THIS_ HKEY hkeyUser) PURE;

	STDMETHOD(GetComponentSettings) (THIS_ REFCLSID clsidComponent,
									 LPCSTR pszName, IUnknown **ppOut,
									 DWORD fdwAccess) PURE;
	STDMETHOD(EnumerateComponentSettings) (THIS_ IEnumUnknown **ppOut,
										   DWORD fdwAccess) PURE;
};


/************************************************************************

IUserProfileInit interface

This interface is a helper for IUserDatabase::Install and IUserDatabase::Create.
It allows the client of those functions to perform initialization of a new
user's profile before and after the new user's per-user folders are set up.

Member functions, other than IUnknown:

PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
	Called when the user's profile has been created, but no per-user folders
    have been created or initialized yet.  Here the implementer can add keys to
    the user's profile which will affect the initialization of those per-user
    folders.  hkeyUser is the root of the user's profile, which would be
    HKEY_CURRENT_USER if the user were currently logged on.

PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
    Called after the user's per-user folders have been created and initialized.
    Here the implementer can add keys to the user's profile which will control
    roaming of per-user folders, without causing the IUserDatabase profile
    cloning code to want to initialize those folders from their default
    locations.

************************************************************************/

DECLARE_INTERFACE_(IUserProfileInit, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(PreInitProfile) (THIS_ HKEY hkeyUser, LPCSTR pszProfileDir) PURE;
    STDMETHOD(PostInitProfile) (THIS_ HKEY hkeyUser, LPCSTR pszProfileDir) PURE;
};


/************************************************************************

IUserDatabase interface

This interface is used to manage the local user database as a whole.  Any
activities which deal with the list of users in any way are done through
this interface;  operations which deal with the properties (other than the
name) of an existing user are done through IUser.

Member functions, other than IUnknown:

Install(LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
        LPCSTR pszRatingsPassword, IUserProfileInit *pInit)
	Installs the user settings subsystem.  This includes creating an account
	for the supervisor.  A separate member function is necessary for doing
	this because all the others would insist that the current user already
	be a supervisor.  The pInit object (optional, may be NULL) is called
    back to allow the installer to do initialization of the profile being
    created, before and after its per-user files are copied.

AddUser(LPCSTR pszName, IUser *pSourceUser, IUserProfileInit *pInit,
        IUser **ppOut)
	Creates a new user on the system.  This includes creating a profile
	for the user.  It does not, however, include creating a password list
	file.  IUser::ChangePassword can be used to configure the password
	for the user.  An IUser object is returned to the caller so that the
	caller can configure the properties of the user.  This function will
	fail if the current user is not a supervisor.  The caller can optionally
	specify a user account to be cloned.  The pInit object (optional, may be
	NULL) is called back to allow the installer to do initialization of the
	profile being created, before and after its per-user files are copied.

GetUser(LPCSTR pszName, IUser **ppOut)
	Gets an IUser object corresponding to the specified user.  The current
	user need not be a supervisor to call this function, and any user's
	name may be specified.  The IUser interface will control what a non-
	supervisor can and cannot do to the user object.

GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut)
	Gets an IUser object corresponding to a special particular user.
	Current values for nSpecialUserCode include GSU_CURRENT, meaning
	the currently logged on user, and GSU_DEFAULT, meaning the default
	user identity (i.e., the identity used when nobody is logged on,
	also used as a template when creating new identities).

GetCurrentUser(IUser **ppOut)
	Gets an IUser object corresponding to the currently logged on user.
	Shorthand for GetSpecialUser(GSU_CURRENT, ppOut).

SetCurrentUser(IUser *pUser)
	Sets this IUserDatabase object's idea of who the current user is.
	The user must have previously been authenticated.  This user object
	is used for all checks which, for example, determine whether the
	"current user" is a supervisor, or whether a user can access his
	or her own settings, etc.  SetCurrentUser does not AddRef the IUser
	object passed.

DeleteUser(LPCSTR pszName)
	Deletes the profile and password cache for the specified user,
	effectively destroying that user's identity.  This function may
	only be called if the current user is a supervisor.  Any existing
	IUser objects which refer to the user are no longer useful, but
	still must be destroyed in the ordinary way (Release()).

RenameUser(LPCSTR pszOldName, LPCSTR pszNewName)
	Changes the username of a user.  This function may only be called
	if the current user is a supervisor.

EnumUsers(IEnumUnknown **ppOut)
	Returns an IEnumUnknown object which the caller can use to enumerate
	the local users on the system.

Authenticate(HWND hwndOwner, DWORD dwFlags, LPCSTR pszName, LPCSTR pszPassword,
			 IUser **ppOut)
	Attempts to authenticate a user.  dwFlags specifies whether or not
	to prompt for credentials, and whether or not non-supervisors are
	acceptable.  If no dialog is to be displayed by the API, then the
	pszName and pszPassword parameters are used instead.  If the credentials
	are authenticated succcessfully, S_OK is returned.  The ppOut parameter,
	if not NULL, is filled with a pointer to an IUser object describing the
	user who was authenticated, in case the caller cares to find out about
	who typed in their name and password.

    The dwFlags parameter specifies whether UI will be displayed by the
    function, and whether or not the credentials will be cached in memory
    for use at the next logon.

InstallComponent(REFCLSID clsidComponent, LPCSTR pszName, DWORD dwFlags)
    CURRENTLY NOT IMPLEMENTED

	Installs a component into the settings database, so that it will appear
	in the settings UI.  clsidComponent or pszName can be used to refer to
	the component being installed;  use of a CLSID is preferable because
	then the component can provide server code which renders the settings
	UI for that component, and knows how to initialize the settings for a
	new user.

	The only bit currently defined for dwFlags is:

	SETTINGS_NS_CAN_WRITE:		Non-supervisors can change their own settings
								for this component.

	A component's settings for the current user can always be read, at least
	programmatically -- there is no point in storing settings which can only
	be accessed if the current user is a supervisor.  If non-supervisors
	should not be shown the UI for restricted settings (even a read-only UI),
	that decision can be made at the UI level.

	InstallComponent fails if the current user is not a supervisor.

RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName)
    CURRENTLY NOT IMPLEMENTED

	Removes a component from the settings database, so that it will no longer
	appear in the settings UI.  This also removes this component's settings
	from all user identities.

	RemoveComponent fails if the current user is not a supervisor.

InstallWizard(HWND hwndParent)
    Runs the wizard that switches to multiuser mode.

AddUserWizard(HWND hwndParent)
    Runs the wizard that adds a new user, invoking the go-multiuser wizard
    if necessary.

UserCPL(HWND hwndParent)
    Invokes the general user management UI as seen in Control panel, invoking
    the go-multiuser wizard if necessary.

************************************************************************/

DECLARE_INTERFACE_(IUserDatabase, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(Install) (THIS_ LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
	                    LPCSTR pszRatingsPassword, IUserProfileInit *pInit) PURE;
	STDMETHOD(AddUser) (THIS_ LPCSTR pszName, IUser *pSourceUser,
	                    IUserProfileInit *pInit, IUser **ppOut) PURE;
	STDMETHOD(GetUser) (THIS_ LPCSTR pszName, IUser **ppOut) PURE;
	STDMETHOD(GetSpecialUser) (THIS_ DWORD nSpecialUserCode, IUser **ppOut) PURE;
	STDMETHOD(GetCurrentUser) (THIS_ IUser **ppOut) PURE;
	STDMETHOD(SetCurrentUser) (THIS_ IUser *pUser) PURE;
	STDMETHOD(DeleteUser) (THIS_ LPCSTR pszName) PURE;
	STDMETHOD(RenameUser) (THIS_ LPCSTR pszOldName, LPCSTR pszNewName) PURE;
	STDMETHOD(EnumUsers) (THIS_ IEnumUnknown **ppOut) PURE;

	STDMETHOD(Authenticate) (THIS_ HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut) PURE;

	STDMETHOD(InstallComponent) (THIS_ REFCLSID clsidComponent, LPCSTR pszName,
								 DWORD dwFlags) PURE;
	STDMETHOD(RemoveComponent) (THIS_ REFCLSID clsidComponent, LPCSTR pszName) PURE;
    STDMETHOD(InstallWizard) (THIS_ HWND hwndParent) PURE;
    STDMETHOD(AddUserWizard) (THIS_ HWND hwndParent) PURE;

    STDMETHOD(UserCPL) (THIS_ HWND hwndParent) PURE;
};

// codes for IUserDatabase::GetSpecialUser

const DWORD GSU_CURRENT = 0;				// current user
const DWORD GSU_DEFAULT = 1;				// default user profile

// flags for IUserDatabase::Authenticate
const DWORD LUA_DIALOG = 0x00000001;			// display dialog to get credentials
												// otherwise use pszName, pszPassword
const DWORD LUA_SUPERVISORONLY = 0x00000002;	// authenticate supervisors only
const DWORD LUA_FORNEXTLOGON = 0x00000004;      // cache credentials for next logon

// flags for IUserDatabase::InstallComponent
const DWORD SETTINGS_NS_CAN_WRITE = 0x01;	// non-supervisors can change their own settings

#endif  // _MSLUAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\pif.h ===
/*
 *  Microsoft  Confidential
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  All Rights Reserved.
 *
 *
 *  PIF.H
 *  DOS Program Information File structures, constants, etc.
 */


#ifndef _INC_PIF
#define _INC_PIF

#include <shlobj.h>

/* XLATOFF */
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */
/* XLATON */

// for DOJ compliance, size defines moved to shlobj.w

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

#define LARGEST_GROUP   sizeof(PROPPRG)

// for DOJ compliance, some property flags moved to shlobj.h
#define OPENPROPS_RAWIO         0x0001		//;Internal
#define OPENPROPS_INFONLY       0x0002		//;Internal
#define OPENPROPS_FORCEREALMODE 0x0004		//;Internal

#define GETPROPS_RAWIO          0x0001		//;Internal
#define GETPROPS_EXTENDED       0x0004          //;Internal
#define GETPROPS_OEM            0x0008		//;Internal

#define FLUSHPROPS_NONE         0x0000		//;Internal
#define FLUSHPROPS_DISCARD      0x0001		//;Internal

#define CREATEPROPS_NONE        0x0000		//;Internal

#define SETPROPS_RAWIO          0x0001		//;Internal
#define SETPROPS_CACHE          0x0002		//;Internal
#define SETPROPS_EXTENDED       0x0004          //;Internal
#define SETPROPS_OEM            0x0008		//;Internal

#define DELETEPROPS_NONE        0x0000		
#define DELETEPROPS_DISCARD     0x0001		
#define DELETEPROPS_ABORT       0x0002

#define LOADPROPLIB_DEFER       0x0001



/* XLATOFF */
#ifndef FAR
#define FAR
#endif
/* XLATON */

//#ifdef  RECT
//#define _INC_WINDOWS
//#endif

//#ifndef _INC_WINDOWS

/* ASM
RECT    struc
        rcLeft      dw  ?
        rcTop       dw  ?
        rcRight     dw  ?
        rcBottom    dw  ?
RECT    ends
*/

/* XLATOFF */
typedef struct tagPIFRECT {
    WORD left;
    WORD top;
    WORD right;
    WORD bottom;
} PIFRECT;
typedef PIFRECT *PPIFRECT;
typedef PIFRECT FAR *LPPIFRECT;
/* XLATON */

//#endif


/*
 *  Property groups, used by PIFMGR.DLL and VxD interfaces
 *
 *  The structures for each of the pre-defined, ordinal-based groups
 *  is a logical view of data in the associated PIF file, if any -- not a
 *  physical view.
 */

#define GROUP_PRG               1           // program group

#define PRG_DEFAULT             0
#define PRG_CLOSEONEXIT         0x0001      // MSflags & EXITMASK
#define PRG_NOSUGGESTMSDOS      0x0400      // see also: PfW386Flags & fNoSuggestMSDOS

#define PRGINIT_DEFAULT         0
#define PRGINIT_MINIMIZED       0x0001      // see also: PfW386Flags & fMinimized
#define PRGINIT_MAXIMIZED       0x0002      // see also: PfW386Flags & fMaximized
#define PRGINIT_WINLIE          0x0004      // see also: PfW386Flags & fWinLie
#define PRGINIT_REALMODE        0x0008      // see also: PfW386Flags & fRealMode
#define PRGINIT_REALMODESILENT  0x0100      // see also: PfW386Flags & fRealModeSilent
#define PRGINIT_QUICKSTART      0x0200      // see also: PfW386Flags & fQuickStart  /* ;Internal */
#define PRGINIT_AMBIGUOUSPIF    0x0400      // see also: PfW386Flags & fAmbiguousPIF
#define PRGINIT_NOPIF           0x1000      // no PIF found
#define PRGINIT_DEFAULTPIF      0x2000      // default PIF found
#define PRGINIT_INFSETTINGS     0x4000      // INF settings found
#define PRGINIT_INHIBITPIF      0x8000      // INF indicates that no PIF be created

/*
 *  Real mode option flags.  NOTE: this field is a dword.  The low word
 *  uses these flags to indicate required options.  The high word is used
 *  to specify "nice" but not required options.
 */
#define RMOPT_MOUSE             0x0001      // Real mode mouse
#define RMOPT_EMS               0x0002      // Expanded Memory
#define RMOPT_CDROM             0x0004      // CD-ROM support
#define RMOPT_NETWORK           0x0008      // Network support
#define RMOPT_DISKLOCK          0x0010      // disk locking required
#define RMOPT_PRIVATECFG        0x0020      // use private configuration (ie, CONFIG/AUTOEXEC)
#define RMOPT_VESA              0x0040      // VESA driver


#define ICONFILE_DEFAULT        TEXT("PIFMGR.DLL")
#define ICONINDEX_DEFAULT       0


// for DOJ compliance, PROPPRG moved to shlobj.w


#define GROUP_TSK               2           // tasking group

#define TSK_DEFAULT             (TSK_BACKGROUND)
#define TSK_ALLOWCLOSE          0x0001      // PfW386Flags & fEnableClose
#define TSK_BACKGROUND          0x0002      // PfW386Flags & fBackground
#define TSK_EXCLUSIVE           0x0004      // PfW386Flags & fExclusive             /* ;Internal */
#define TSK_NOWARNTERMINATE     0x0010      // Don't warn before closing
#define TSK_NOSCREENSAVER       0x0020      // Do not activate screen saver

#define TSKINIT_DEFAULT         0

#define TSKFGNDBOOST_DEFAULT    0           // fgnd boost                           /* ;Internal */
#define TSKBGNDBOOST_DEFAULT    0           // bgnd boost                           /* ;Internal */
                                                                                    /* ;Internal */
#define TSKFGND_OLD_DEFAULT     100         // normal fgnd setting                  /* ;Internal */
#define TSKBGND_OLD_DEFAULT     50          // normal bgnd setting                  /* ;Internal */
                                                                                    /* ;Internal */
#define TSKIDLESENS_DEFAULT     50          // % (min-max == 0-100)

typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    wReserved4;                     // (reserved, must be zero)
    WORD    wIdleSensitivity;               // %, also affects PfW386Flags & fPollingDetect
} PROPTSK;
typedef UNALIGNED PROPTSK *PPROPTSK;
typedef UNALIGNED PROPTSK FAR *LPPROPTSK;


#define GROUP_VID               3           // video group

#define VID_DEFAULT             (VID_TEXTEMULATE)
#define VID_TEXTEMULATE         0x0001      // PfW386Flags2 & fVidTxtEmulate
#define VID_RETAINMEMORY        0x0080      // PfW386Flags2 & fVidRetainAllo
#define VID_FULLSCREEN          0x0100      // PfW386Flags  & fFullScreen

#define VIDINIT_DEFAULT         0

#define VIDSCREENLINES_MIN      0           // in # lines (0 = use VDD value)
#define VIDSCREENLINES_DEFAULT  0           // in # lines
#define VIDSCREENLINES_MAX      50          // in # lines                           /* ;Internal */

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
} PROPVID;
typedef UNALIGNED PROPVID *PPROPVID;
typedef UNALIGNED PROPVID FAR *LPPROPVID;


#define GROUP_MEM               4           // memory group

#define MEM_DEFAULT             0

#define MEMINIT_DEFAULT         0
#define MEMINIT_NOHMA           0x0001      // PfW386Flags & fNoHMA
#define MEMINIT_LOWLOCKED       0x0002      // PfW386Flags & fVMLocked
#define MEMINIT_EMSLOCKED       0x0004      // PfW386Flags & fEMSLocked
#define MEMINIT_XMSLOCKED       0x0008      // PfW386Flags & fXMSLocked
#define MEMINIT_GLOBALPROTECT   0x0010      // PfW386Flags & fGlobalProtect
#define MEMINIT_STRAYPTRDETECT  0x0020      // PfW386Flags & fStrayPtrDetect        /* ;Internal */
#define MEMINIT_LOCALUMBS       0x0040      // PfW386Flags & fLocalUMBs             /* ;Internal */

#define MEMLOW_MIN              0           // in KB
#define MEMLOW_DEFAULT          0           // in KB
#define MEMLOW_MAX              640         // in KB

#define MEMEMS_MIN              0           // in KB
#define MEMEMS_DEFAULT          0           // in KB
#define MEMEMS_MAX              0xFFFF      // in KB

#define MEMXMS_MIN              0           // in KB
#define MEMXMS_DEFAULT          0           // in KB
#define MEMXMS_MAX              0xFFFF      // in KB

typedef struct PROPMEM {                    /* mem */
    WORD    flMem;                          // see MEM_ flags
    WORD    flMemInit;                      // see MEMINIT_ flags
    WORD    wMinLow;                        // PfW386minmem
    WORD    wMaxLow;                        // PfW386maxmem
    WORD    wMinEMS;                        // PfMinEMMK
    WORD    wMaxEMS;                        // PfMaxEMMK
    WORD    wMinXMS;                        // PfMinXmsK
    WORD    wMaxXMS;                        // PfMaxXmsK
} PROPMEM;
typedef UNALIGNED PROPMEM *PPROPMEM;
typedef UNALIGNED PROPMEM FAR *LPPROPMEM;


#define GROUP_KBD               5           // keyboard group

#define KBD_DEFAULT             (KBD_FASTPASTE)
#define KBD_FASTPASTE           0x0001      // PfW386Flags & fINT16Paste
#define KBD_NOALTTAB            0x0020      // PfW386Flags & fALTTABdis
#define KBD_NOALTESC            0x0040      // PfW386Flags & fALTESCdis
#define KBD_NOALTSPACE          0x0080      // PfW386Flags & fALTSPACEdis
#define KBD_NOALTENTER          0x0100      // PfW386Flags & fALTENTERdis
#define KBD_NOALTPRTSC          0x0200      // PfW386Flags & fALTPRTSCdis
#define KBD_NOPRTSC             0x0400      // PfW386Flags & fPRTSCdis
#define KBD_NOCTRLESC           0x0800      // PfW386Flags & fCTRLESCdis

#define KBDINIT_DEFAULT         0

#define KBDALTDELAY_MIN             1
#define KBDALTDELAY_DEFAULT         5
#define KBDALTDELAY_MAX             5000

#define KBDALTPASTEDELAY_MIN        1
#define KBDALTPASTEDELAY_DEFAULT    25
#define KBDALTPASTEDELAY_MAX        5000

#define KBDPASTEDELAY_MIN           1
#define KBDPASTEDELAY_DEFAULT       3
#define KBDPASTEDELAY_MAX           5000

#define KBDPASTEFULLDELAY_MIN       1
#define KBDPASTEFULLDELAY_DEFAULT   200
#define KBDPASTEFULLDELAY_MAX       5000

#define KBDPASTETIMEOUT_MIN         1
#define KBDPASTETIMEOUT_DEFAULT     1000
#define KBDPASTETIMEOUT_MAX         5000

#define KBDPASTESKIP_MIN            1
#define KBDPASTESKIP_DEFAULT        2
#define KBDPASTESKIP_MAX            100

#define KBDPASTECRSKIP_MIN          1
#define KBDPASTECRSKIP_DEFAULT      10
#define KBDPASTECRSKIP_MAX          100

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef UNALIGNED PROPKBD *PPROPKBD;
typedef UNALIGNED PROPKBD FAR *LPPROPKBD;


#define GROUP_MSE               6           // mouse group

/* No VxD currently pays attention to PROPMSE. VMDOSAPP should know how to
 * handle all cases resulting from a change in these flags.
 *
 * Note that MSE_WINDOWENABLE corresponds to the Windows NT "QuickEdit"
 * property, except backwards.
 */

#define MSE_DEFAULT             (MSE_WINDOWENABLE)
#define MSE_WINDOWENABLE        0x0001      // ([NonWindowsApp]:MouseInDosBox)
#define MSE_EXCLUSIVE           0x0002      //

#define MSEINIT_DEFAULT         0           // default flags

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef UNALIGNED PROPMSE *PPROPMSE;
typedef UNALIGNED PROPMSE FAR *LPPROPMSE;


#define GROUP_SND               7           // sound group                  /* ;Internal */
                                                                            /* ;Internal */
#define SND_DEFAULT             (SND_SPEAKERENABLE)                         /* ;Internal */
#define SND_SPEAKERENABLE       0x0001      //                              /* ;Internal */
                                                                            /* ;Internal */
#define SNDINIT_DEFAULT         0                                           /* ;Internal */
                                                                            /* ;Internal */
typedef struct PROPSND {                    /* snd */                       /* ;Internal */
    WORD    flSnd;                          // see SND_ flags               /* ;Internal */
    WORD    flSndInit;                      // see SNDINIT_ flags           /* ;Internal */
} PROPSND;                                                                  /* ;Internal */
typedef UNALIGNED PROPSND *PPROPSND;                                        /* ;Internal */
typedef UNALIGNED PROPSND FAR *LPPROPSND;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
#define GROUP_FNT               8           // font group

#define FNT_DEFAULT             (FNT_BOTHFONTS | FNT_AUTOSIZE)
#define FNT_RASTERFONTS         0x0004      // allow raster fonts in dialog
#define FNT_TTFONTS             0x0008      // allow truetype fonts in dialog
#define FNT_BOTHFONTS           (FNT_RASTERFONTS | FNT_TTFONTS)
#define FNT_AUTOSIZE            0x0010      // enable auto-sizing
#define FNT_RASTER              0x0400      // specified font is raster
#define FNT_TT                  0x0800      // specified font is truetype

#define FNT_FONTMASK            (FNT_BOTHFONTS)
#define FNT_FONTMASKBITS        2           // # of bits shifted left

#define FNTINIT_DEFAULT         0
#define FNTINIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    CHAR    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    CHAR    achTTFaceName[LF_FACESIZE];     // name to use for tt font
    WORD    wCurrentCP;                     // Current Codepage
} PROPFNT;
typedef UNALIGNED PROPFNT *PPROPFNT;
typedef UNALIGNED PROPFNT FAR *LPPROPFNT;

#define GROUP_WIN               9          // window group

#define WIN_DEFAULT             (WIN_SAVESETTINGS | WIN_TOOLBAR)
#define WIN_SAVESETTINGS        0x0001      // save settings on exit (default)
#define WIN_TOOLBAR             0x0002      // enable toolbar

#define WININIT_DEFAULT         0
#define WININIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    PIFRECT rcNormal;
} PROPWIN;
typedef UNALIGNED PROPWIN *PPROPWIN;
typedef UNALIGNED PROPWIN FAR *LPPROPWIN;

#define PIF_WP_SIZE             ((sizeof(WORD)*7) + sizeof(PIFRECT))

#define GROUP_ENV               10          // environment/startup group

#define ENV_DEFAULT             0

#define ENVINIT_DEFAULT         0

#define ENVSIZE_MIN             0
#define ENVSIZE_DEFAULT         0
#define ENVSIZE_MAX             32768

#define ENVDPMI_MIN             0           // in KB
#define ENVDPMI_DEFAULT         0           // in KB (0 = Auto)
#define ENVDPMI_MAX             0xFFFF      // in KB

typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    CHAR    achBatchFile[PIFDEFFILESIZE];   //
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
    WORD    wMaxDPMI;                       // (NEW)
} PROPENV;
typedef UNALIGNED PROPENV *PPROPENV;
typedef UNALIGNED PROPENV FAR *LPPROPENV;

#ifdef WINNT

#define GROUP_NT31              11
#ifndef UNICODE
#define MAX_VALID_GROUP         GROUP_NT31
#endif

typedef struct PROPNT31 {
   DWORD dwWNTFlags;                                                        /* ;Internal */
   DWORD dwRes1;                                                            /* ;Internal */
   DWORD dwRes2;                                                            /* ;Internal */
   char  achConfigFile[PIFDEFPATHSIZE];                                     /* ;Internal */
   char  achAutoexecFile[PIFDEFPATHSIZE];                                   /* ;Internal */
} PROPNT31;
typedef UNALIGNED PROPNT31 *PPROPNT31;
typedef UNALIGNED PROPNT31 FAR *LPPROPNT31;
#define COMPAT_TIMERTIC 0x10                                                /* ;Internal */
#define NT31_COMPATTIMER COMPAT_TIMERTIC                                    /* ;Internal */
#endif

#ifdef UNICODE
#ifdef GROUP_NT31
#define GROUP_NT40              12
#else
#define GROUP_NT40              11
#endif
#define MAX_VALID_GROUP         GROUP_NT40


#define WNT_LET_SYS_POS         0x0001
#define WNT_CONSOLE_PROPS       0x0002

typedef struct PROPNT40 {                                   /* wnt */
   DWORD    flWnt;                                          // NT Specific PIF falgs

// UNICODE version of strings, and copy of ANSI to see if they've changed

   WCHAR    awchCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];   // Command line
   CHAR     achSaveCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// Saved ANSI Command Line

   WCHAR    awchOtherFile[PIFDEFFILESIZE];                  // name of "other" file in directory
   CHAR     achSaveOtherFile[PIFDEFFILESIZE];               // Saved ANSI "other" file in directory

   WCHAR    awchPIFFile[PIFDEFFILESIZE];                    // name of PIF file
   CHAR     achSavePIFFile[PIFDEFFILESIZE];                 // Saved ANSI name of PIF file

   WCHAR    awchTitle[PIFNAMESIZE];                         // Title for cmd window
   CHAR     achSaveTitle[PIFNAMESIZE];                      // Saved ANSI Title for cmd window

   WCHAR    awchIconFile[PIFDEFFILESIZE];                   // Name of file containing icons
   CHAR     achSaveIconFile[PIFDEFFILESIZE];                // Saved ANSI Name of file containing icons

   WCHAR    awchWorkDir[PIFDEFPATHSIZE];                    // working directory
   CHAR     achSaveWorkDir[PIFDEFPATHSIZE];                 // Saved ANSI working directory

   WCHAR    awchBatchFile[PIFDEFFILESIZE];                  // batch file
   CHAR     achSaveBatchFile[PIFDEFFILESIZE];               // Saved ANSI batch file

// Console properties

   DWORD    dwForeColor;                                    // Console Text Foreground Color
   DWORD    dwBackColor;                                    // Console Text Background Color
   DWORD    dwPopupForeColor;                               // Console Popup Text Foreground Color
   DWORD    dwPopupBackColor;                               // Console Popup Text Background Color
   COORD    WinSize;                                        // Console Window Size
   COORD    BuffSize;                                       // Console Buffer Size
   POINT    WinPos;                                         // Console Window Position
   DWORD    dwCursorSize;                                   // Console Cursor Size
   DWORD    dwCmdHistBufSize;                               // Console Command Histroy Buffer Size
   DWORD    dwNumCmdHist;                                   // Number of Command Histories for Console

} PROPNT40;
typedef UNALIGNED PROPNT40 *PPROPNT40;
typedef UNALIGNED PROPNT40 FAR *LPPROPNT40;

#else

#ifndef WINNT
#define MAX_VALID_GROUP         GROUP_ENV
#endif

#endif // UNICODE

#define GROUP_ICON              (MAX_VALID_GROUP+1)
#define GROUP_MAX               0x0FF

                                                                                // ;Internal
                                                                                // ;Internal
/*                                                                              // ;Internal
 * Additional group ordinal bits that can be passed to VxD property hooks       // ;Internal
 */                                                                             // ;Internal
#define EXT_GROUP_QUERY         0x100                                           // ;Internal
#define EXT_GROUP_UPDATE        0x200                                           // ;Internal
                                                                                // ;Internal
                                                                                // ;Internal
/*
 *  PIF "file" structures, used by .PIFs
 */

#define PIFEXTSIGSIZE   16                  // Length of extension signatures
#define MAX_GROUP_NAME  PIFEXTSIGSIZE       //
#define STDHDRSIG       "MICROSOFT PIFEX"   // extsig value for stdpifext
#define LASTHDRPTR      0xFFFF              // This value in the
                                            //  extnxthdrfloff field indicates
                                            //   there are no more extensions.
#define W286HDRSIG30     "WINDOWS 286 3.0"
#define W386HDRSIG30     "WINDOWS 386 3.0"
#define WNTHDRSIG31      "WINDOWS NT  3.1"
#define WENHHDRSIG40     "WINDOWS VMM 4.0"  //
#define WNTHDRSIG40      "WINDOWS NT  4.0"

#define CONFIGHDRSIG40   "CONFIG  SYS 4.0"  //
#define AUTOEXECHDRSIG40 "AUTOEXECBAT 4.0"  //

#define MAX_CONFIG_SIZE     4096
#define MAX_AUTOEXEC_SIZE   4096

#define CONFIGFILE      TEXT("\\CONFIG.SYS")      // normal filenames
#define AUTOEXECFILE    TEXT("\\AUTOEXEC.BAT")

#define MCONFIGFILE     TEXT("\\CONFIG.APP")      // msdos-mode temp filenames
#define MAUTOEXECFILE   TEXT("\\AUTOEXEC.APP")

#define WCONFIGFILE     TEXT("\\CONFIG.WOS")      // windows-mode temp filenames
#define WAUTOEXECFILE   TEXT("\\AUTOEXEC.WOS")


typedef struct PIFEXTHDR {                  /* peh */
    CHAR    extsig[PIFEXTSIGSIZE];
    WORD    extnxthdrfloff;
    WORD    extfileoffset;
    WORD    extsizebytes;
} PIFEXTHDR;
typedef UNALIGNED PIFEXTHDR *PPIFEXTHDR;
typedef UNALIGNED PIFEXTHDR FAR *LPPIFEXTHDR;


/* Flags for MSflags
 */

#define fResident       0x01    // Directly Modifies: Memory
#define fGraphics       0x02    // Screen Exchange: Graphics/Text
#define fNoSwitch       0x04    // Program Switch: Prevent
#define fNoGrab         0x08    // Screen Exchange: None
#define fDestroy        0x10    // Close Window on exit
#define fCOM2           0x40    // Directly Modifies: COM2
#define fCOM1           0x80    // Directly Modifies: COM1

#define MEMMASK         fResident
#define GRAPHMASK       fGraphics
#define TEXTMASK        ((BYTE)(~GRAPHMASK))
#define PSMASK          fNoSwitch
#define SGMASK          fNoGrab
#define EXITMASK        fDestroy
#define COM2MASK        fCOM2
#define COM1MASK        fCOM1

/* Flags for behavior
 */
#define fScreen         0x80    // Directly Modifies: Screen
#define fForeground     0x40    // Set same as fScreen (alias)
#define f8087           0x20    // No PIFEDIT control
#define fKeyboard       0x10    // Directly Modifies: Keyboard

#define SCRMASK         (fScreen + fForeground)
#define MASK8087        f8087
#define KEYMASK         fKeyboard

/* Flags for sysflags
 */

#define SWAPMASK        0x20
#define PARMMASK        0x40

/*
 * All strings in the STDPIF are in the OEM character set.
 */
typedef struct STDPIF {                     /* std */ //Examples
    BYTE    unknown;                        // 0x00     0x00
    BYTE    id;                             // 0x01     0x78
    CHAR    appname[PIFNAMESIZE];           // 0x02     'MS-DOS Prompt'
    WORD    maxmem;                         // 0x20     0x0200 (512Kb)
    WORD    minmem;                         // 0x22     0x0080 (128Kb)
    CHAR    startfile[PIFSTARTLOCSIZE];     // 0x24     "COMMAND.COM"
    BYTE    MSflags;                        // 0x63     0x10
    BYTE    reserved;                       // 0x64     0x00
    CHAR    defpath[PIFDEFPATHSIZE];        // 0x65     "\"
    CHAR    params[PIFPARAMSSIZE];          // 0xA5     ""
    BYTE    screen;                         // 0xE5     0x00
    BYTE    cPages;                         // 0xE6     0x01 (ALWAYS!)
    BYTE    lowVector;                      // 0xE7     0x00 (ALWAYS!)
    BYTE    highVector;                     // 0xE8     0xFF (ALWAYS!)
    BYTE    rows;                           // 0xE9     0x19 (Not used)
    BYTE    cols;                           // 0xEA     0x50 (Not used)
    BYTE    rowoff;                         // 0xEB     0x00 (Not used)
    BYTE    coloff;                         // 0xEC     0x00 (Not used)
    WORD    sysmem;                         // 0xED   0x0007 (Not used; 7=>Text, 23=>Grfx/Mult Text)
    CHAR    shprog[PIFSHPROGSIZE];          // 0xEF     0's  (Not used)
    CHAR    shdata[PIFSHDATASIZE];          // 0x12F    0's  (Not used)
    BYTE    behavior;                       // 0x16F    0x00
    BYTE    sysflags;                       // 0x170    0x00 (Not used)
} STDPIF;
typedef UNALIGNED STDPIF *PSTDPIF;
typedef UNALIGNED STDPIF FAR *LPSTDPIF;


/* Flags for PfW286Flags
 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020              // New for 3.10
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

typedef struct W286PIF30 {                  /* 286 */ //Examples
    WORD    PfMaxXmsK;                      // 0x19D    0x0000
    WORD    PfMinXmsK;                      // 0x19F    0x0000
    WORD    PfW286Flags;                    // 0x1A1    0x0000
} W286PIF30;
typedef UNALIGNED W286PIF30 *PW286PIF30;
typedef UNALIGNED W286PIF30 FAR *LPW286PIF30;


/* Flags for PfW386Flags
 */

#define fEnableClose    0x00000001          //
#define fEnableCloseBit             0       //
#define fBackground     0x00000002          //
#define fBackgroundBit              1       //
#define fExclusive      0x00000004          //                          /* ;Internal */
#define fExclusiveBit               2       //                          /* ;Internal */
#define fFullScreen     0x00000008          //
#define fFullScreenBit              3       //
#define fALTTABdis      0x00000020          //
#define fALTTABdisBit               5       //
#define fALTESCdis      0x00000040          //
#define fALTESCdisBit               6       //
#define fALTSPACEdis    0x00000080          //
#define fALTSPACEdisBit             7       //
#define fALTENTERdis    0x00000100          //
#define fALTENTERdisBit             8       //
#define fALTPRTSCdis    0x00000200          //
#define fALTPRTSCdisBit             9       //
#define fPRTSCdis       0x00000400          //
#define fPRTSCdisBit                10      //
#define fCTRLESCdis     0x00000800          //
#define fCTRLESCdisBit              11      //
#define fPollingDetect  0x00001000          //
#define fPollingDetectBit           12      //
#define fNoHMA          0x00002000          //
#define fNoHMABit                   13      //
#define fHasHotKey      0x00004000          //
#define fHasHotKeyBit               14      //
#define fEMSLocked      0x00008000          //
#define fEMSLockedBit               15      //
#define fXMSLocked      0x00010000          //
#define fXMSLockedBit               16      //
#define fINT16Paste     0x00020000          //
#define fINT16PasteBit              17      //
#define fVMLocked       0x00040000          //
#define fVMLockedBit                18      //
#define fGlobalProtect  0x00080000          //  New for 4.00
#define fGlobalProtectBit           19      //  New for 4.00
#define fMinimized      0x00100000          //  New for 4.00
#define fMinimizedBit               20      //  New for 4.00
#define fMaximized      0x00200000          //  New for 4.00
#define fMaximizedBit               21      //  New for 4.00
//                      0x00400000          //  Not used                /* ;Internal */
//                                  22      //  Not used                /* ;Internal */
#define fRealMode       0x00800000          //  New for 4.00
#define fRealModeBit                23      //  New for 4.00
#define fWinLie         0x01000000          //  New for 4.00
#define fWinLieBit                  24      //  New for 4.00
#define fStrayPtrDetect 0x02000000          //  New for 4.00            /* ;Internal */
#define fStrayPtrDetectBit          25      //  New for 4.00            /* ;Internal */
#define fNoSuggestMSDOS 0x04000000          //  New for 4.00
#define fNoSuggestMSDOSBit          26      //  New for 4.00
#define fLocalUMBs      0x08000000          //  New for 4.00            /* ;Internal */
#define fLocalUMBsBit               27      //  New for 4.00            /* ;Internal */
#define fRealModeSilent 0x10000000          //  New for 4.00
#define fRealModeSilentBit          28      //  New for 4.00
#define fQuickStart     0x20000000          //  New for 4.00            /* ;Internal */
#define fQuickStartBit              29      //  New for 4.00            /* ;Internal */
#define fAmbiguousPIF   0x40000000          //  New for 4.00
#define fAmbiguousPIFBit            30      //  New for 4.00

/* Flags for PfW386Flags2
 *
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED
 *  NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS
 *
 *  You cannot monkey with these bits locations without breaking
 *  all VDDs as well as all old PIFs. SO DON'T MESS WITH THEM.
 */

#define fVDDMask        0x0000FFFF          //
#define fVDDMinBit                  0       //
#define fVDDMaxBit                  15      //

#define fVidTxtEmulate  0x00000001          //
#define fVidTxtEmulateBit           0       //
#define fVidNoTrpTxt    0x00000002          // Obsolete
#define fVidNoTrpTxtBit             1       // Obsolete
#define fVidNoTrpLRGrfx 0x00000004          // Obsolete
#define fVidNoTrpLRGrfxBit          2       // Obsolete
#define fVidNoTrpHRGrfx 0x00000008          // Obsolete
#define fVidNoTrpHRGrfxBit          3       // Obsolete
#define fVidTextMd      0x00000010          // Obsolete
#define fVidTextMdBit               4       // Obsolete
#define fVidLowRsGrfxMd 0x00000020          // Obsolete
#define fVidLowRsGrfxMdBit          5       // Obsolete
#define fVidHghRsGrfxMd 0x00000040          // Obsolete
#define fVidHghRsGrfxMdBit          6       // Obsolete
#define fVidRetainAllo  0x00000080          //
#define fVidRetainAlloBit           7       //

/*                                                                             ;Internal
 * This mask is used to isolate status bits shared with VM_Descriptor          ;Internal
 */                                                                         /* ;Internal */
                                                                            /* ;Internal */
#define PifDescMask                                                         /* ;Internal */ \
(fALTTABdis   + fALTESCdis    + fALTSPACEdis +                              /* ;Internal */ \
 fALTENTERdis + fALTPRTSCdis  + fPRTSCdis +                                 /* ;Internal */ \
 fCTRLESCdis  + fPollingDetect+ fNoHMA +                                    /* ;Internal */ \
 fHasHotKey   + fEMSLocked    + fXMSLocked +                                /* ;Internal */ \
 fINT16Paste  + fVMLocked)                                                  /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
typedef struct W386PIF30 {                  /* 386 */ //Examples
    // These new maxmem/minmem fields allow values
    // that will not conflict with the 286-specific values
    WORD    PfW386maxmem;                   // 0x1B9    0xFFFF (-1)
    WORD    PfW386minmem;                   // 0x1BB    0xFFFF (-1)
    WORD    PfFPriority;                    // 0x1BD    0x0064 (100)
    WORD    PfBPriority;                    // 0x1BF    0x0032 (50)
    WORD    PfMaxEMMK;                      // 0x1C1    0x0000 (0)
    WORD    PfMinEMMK;                      // 0x1C3    0x0000 (0)
    WORD    PfMaxXmsK;                      // 0x1C5    0x0800 (2048)
    WORD    PfMinXmsK;                      // 0x1C7    0x0000 (0)
    DWORD   PfW386Flags;                    // 0x1C9    0x00021003
    DWORD   PfW386Flags2;                   // 0x1CD    0x0000001F
    WORD    PfHotKeyScan;                   // 0x1D1    Scan code in lower byte
    WORD    PfHotKeyShVal;                  // 0x1D3    Shift state
    WORD    PfHotKeyShMsk;                  // 0x1D5    Mask for shift states interested in
    BYTE    PfHotKeyVal;                    // 0x1D7    Enhanced flags
    BYTE    PfHotKeyPad[9];                 // 0x1D8    Pad Hot key section to 16 bytes
    CHAR    PfW386params[PIFPARAMSSIZE];    // 0x1E1
} W386PIF30;
typedef UNALIGNED W386PIF30 *PW386PIF30;
typedef UNALIGNED W386PIF30 FAR *LPW386PIF30;


typedef struct WENHPIF40 {                  /* enh */                       /* ;Internal */
    DWORD   dwEnhModeFlagsProp;             // PROPPRG data (subset)        /* ;Internal */
    DWORD   dwRealModeFlagsProp;            // PROPPRG data (subset)        /* ;Internal */
    CHAR    achOtherFileProp[PIFDEFFILESIZE];//PROPPRG data (subset)        /* ;Internal */
    CHAR    achIconFileProp[PIFDEFFILESIZE];// PROPPRG data (subset)        /* ;Internal */
    WORD    wIconIndexProp;                 // PROPPRG data (subset)        /* ;Internal */
    PROPTSK tskProp;                        // PROPTSK data                 /* ;Internal */
    PROPVID vidProp;                        // PROPVID data                 /* ;Internal */
    PROPKBD kbdProp;                        // PROPKBD data                 /* ;Internal */
    PROPMSE mseProp;                        // PROPMSE data                 /* ;Internal */
    PROPSND sndProp;                        // PROPSND data                 /* ;Internal */
    PROPFNT fntProp;                        // PROPFNT data                 /* ;Internal */
    PROPWIN winProp;                        // PROPWIN data                 /* ;Internal */
    PROPENV envProp;                        // PROPENV data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WENHPIF40 version   /* ;Internal */
} WENHPIF40;                                                                /* ;Internal */
typedef UNALIGNED WENHPIF40 *PWENHPIF40;                                    /* ;Internal */
typedef UNALIGNED WENHPIF40 FAR *LPWENHPIF40;                               /* ;Internal */

#ifdef WINNT
/* Windows NT extension format */
typedef struct WNTPIF31 {                                                   /* ;Internal */
   PROPNT31 nt31Prop;                                                       /* ;Internal */
   WORD     wInternalRevision;                                              /* ;Internal */
} WNTPIF31;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF31 *PWNTPIF31;                                      /* ;Internal */
typedef UNALIGNED WNTPIF31 FAR *LPWNTPIF31;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
#ifdef UNICODE
typedef struct WNTPIF40 {                   /* adv */                       /* ;Internal */
    PROPNT40 nt40Prop;                      // PROPWNT data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WNTPIF40 version    /* ;Internal */
} WNTPIF40;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF40 *PWNTPIF40;                                      /* ;Internal */
typedef UNALIGNED WNTPIF40 FAR *LPWNTPIF40;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
//                                                                          /* ;Internal */
// Whenever a previously reserved field or bit becomes used, increment      /* ;Internal */
// the internal revision so that we know to zero them out when we see a     /* ;Internal */
// down-level PIF file.                                                     /* ;Internal */
//                                                                          /* ;Internal */
#define WENHPIF40_VERSION       1           // Current internal version     /* ;Internal */
#define WNTPIF40_VERSION        1           // Current internal version     /* ;Internal */
#define WNTPIF31_VERSION        1           // Current internal version     /* ;Internal */

                                                                            /* ;Internal */
typedef struct PIFDATA {                    /* pd */  //Examples            /* ;Internal */
                                                                            /* ;Internal */
    STDPIF      stdpifdata;                 // 0x000                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   stdpifext;                  // 0x171                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x171    "MICROSOFT PIFEX"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x181    0x0187 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x183    0x0000              /* ;Internal */
//      WORD    extsizebytes;               // 0x185    0x0171              /* ;Internal */
//  };                                                                      /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w286hdr30;                  // 0x187                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x187    "WINDOWS 286 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x197    0x01A3 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x199    0x019D              /* ;Internal */
//      WORD    extsizebytes;               // 0x19B    0x0006              /* ;Internal */
//  };                                                                      /* ;Internal */
    W286PIF30   w286ext30;                  // 0x19D                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w386hdr30;                  // 0x1A3                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x1A3    "WINDOWS 386 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x1B3    0xFFFF (ENH=0x221)  /* ;Internal */
//      WORD    extfileoffset;              // 0x1B5    0x01B9              /* ;Internal */
//      WORD    extsizebytes;               // 0x1B7    0x0068              /* ;Internal */
//  };                                                                      /* ;Internal */
    W386PIF30   w386ext30;                  // 0x1B9                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   wenhhdr40;                  // 0x221                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x221    "WINDOWS VMM 4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x231    0x????              /* ;Internal */
//      WORD    extfileoffset;              // 0x233    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x235    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WENHPIF40   wenhext40;                  // 0x237                        /* ;Internal */

#ifdef WINNT
    PIFEXTHDR   wnthdr31;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  3.1"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF31    wntpif31;                   // 0x000                        /* ;Internal */
#endif


#ifdef UNICODE
    PIFEXTHDR   wnthdr40;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF40    wntpif40;                   // 0x000                        /* ;Internal */
#endif
                                                                            /* ;Internal */
} PIFDATA;                                  // 0x221 if Windows 3.x PIF     /* ;Internal */
typedef UNALIGNED PIFDATA *PPIFDATA;                                        /* ;Internal */
typedef UNALIGNED PIFDATA FAR *LPPIFDATA;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */                                                                            /* ;Internal */
/* AssociateProperties associations
 */

#define HVM_ASSOCIATION         1
#define HWND_ASSOCIATION        2
#define LPARGS_ASSOCIATION      3                                           /* ;Internal */


/* SHEETTYPEs for AddPropertySheet/EnumPropertySheets
 */

#define SHEETTYPE_SIMPLE    0
#define SHEETTYPE_ADVANCED  1


/*  External function ordinals and prototypes
 */

#define ORD_OPENPROPERTIES      2
#define ORD_GETPROPERTIES       3
#define ORD_SETPROPERTIES       4
#define ORD_EDITPROPERTIES      5
#define ORD_FLUSHPROPERTIES     6
#define ORD_ENUMPROPERTIES      7
#define ORD_ASSOCIATEPROPERTIES 8
#define ORD_CLOSEPROPERTIES     9
#define ORD_LOADPROPERTYLIB     10
#define ORD_ENUMPROPERTYLIBS    11
#define ORD_FREEPROPERTYLIB     12
#define ORD_ADDPROPERTYSHEET    13
#define ORD_REMOVEPROPERTYSHEET 14
#define ORD_LOADPROPERTYSHEETS  15
#define ORD_ENUMPROPERTYSHEETS  16
#define ORD_FREEPROPERTYSHEETS  17
#define ORD_CREATESTARTUPPROPERTIES 20
#define ORD_DELETESTARTUPPROPERTIES 21

typedef UINT PIFWIZERR;

#define PIFWIZERR_SUCCESS           0
#define PIFWIZERR_GENERALFAILURE    1
#define PIFWIZERR_INVALIDPARAM      2
#define PIFWIZERR_UNSUPPORTEDOPT    3
#define PIFWIZERR_OUTOFMEM          4
#define PIFWIZERR_USERCANCELED      5

#define WIZACTION_UICONFIGPROP      0
#define WIZACTION_SILENTCONFIGPROP  1
#define WIZACTION_CREATEDEFCLEANCFG 2

/* XLATOFF */

#ifdef WINAPI
PIFWIZERR WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT action);

int  WINAPI OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt);
int  WINAPI GetProperties(HANDLE hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
int  WINAPI SetProperties(HANDLE hProps, LPCSTR lpszGroup, const VOID FAR *lpProps, int cbProps, UINT flOpt);
int  WINAPI EditProperties(HANDLE hProps, LPCTSTR lpszTitle, UINT uStartPage, HWND hwnd, UINT uMsgPost);
int  WINAPI FlushProperties(HANDLE hProps, UINT flOpt);
HANDLE  WINAPI EnumProperties(HANDLE hProps);
LONG_PTR WINAPI AssociateProperties(HANDLE hProps, int iAssociate, LONG_PTR lData);
int  WINAPI CloseProperties(HANDLE hProps, UINT flOpt);
int  WINAPI CreateStartupProperties(HANDLE hProps, UINT flOpt);
int  WINAPI DeleteStartupProperties(HANDLE hProps, UINT flOpt);
BOOL WINAPI PifPropGetPages(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);


#ifdef  PIF_PROPERTY_SHEETS
HANDLE  WINAPI LoadPropertyLib(LPCTSTR lpszDLL, int fLoad);
HANDLE  WINAPI EnumPropertyLibs(HANDLE iLib, LPHANDLE lphDLL, LPSTR lpszDLL, int cbszDLL);
BOOL WINAPI FreePropertyLib(HANDLE hLib);
HANDLE  WINAPI AddPropertySheet(const PROPSHEETPAGE FAR *lppsi, int iType);
BOOL WINAPI RemovePropertySheet(HANDLE hSheet);
int  WINAPI LoadPropertySheets(HANDLE hProps, int flags);
INT_PTR  WINAPI EnumPropertySheets(HANDLE hProps, int iType, INT_PTR iSheet, LPPROPSHEETPAGE lppsi);
HANDLE  WINAPI FreePropertySheets(HANDLE hProps, int flags);
#endif  /* PIF_PROPERTY_SHEETS */

#endif  /* WINAPI */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

/* XLATON */

#endif // _INC_PIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\msshrui.h ===
/*****************************************************************/
/**                      Microsoft Windows                      **/
//*   Copyright (c) Microsoft Corporation. All rights reserved. **/
/*****************************************************************/

/*
    msshrui.h
    Prototypes and definitions for sharing APIs

    FILE HISTORY:
    gregj    06/03/93    Created
    brucefo  3/5/96      Fixed prototypes for NT
*/

#ifndef _INC_MSSHRUI
#define _INC_MSSHRUI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


// Note: ANSI entrypoints are no longer supported!

STDAPI_(BOOL) IsPathSharedW(
    IN LPCWSTR lpPath,
    IN BOOL fRefresh
    );

typedef
BOOL
(WINAPI* PFNISPATHSHARED)(
    IN LPCWSTR lpPath,
    IN BOOL fRefresh
    );

STDAPI_(BOOL) SharingDialogW(
    IN HWND hwndParent,
    IN LPCWSTR pszComputerName,
    IN LPCWSTR pszPath
    );

typedef
BOOL
(WINAPI* PFNSHARINGDIALOG)(
    IN HWND hwndParent,
    IN LPCWSTR pszComputerName,
    IN LPCWSTR pszPath
    );

STDAPI_(BOOL) GetNetResourceFromLocalPathW(
    IN     LPCWSTR lpcszPath,
    IN OUT LPWSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    );

typedef
BOOL
(WINAPI* PFNGETNETRESOURCEFROMLOCALPATH)(
    IN     LPCWSTR lpcszPath,
    IN OUT LPWSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    );

STDAPI_(BOOL) GetLocalPathFromNetResourceW(
    IN     LPCWSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPWSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    );

typedef
BOOL
(WINAPI* PFNGETLOCALPATHFROMNETRESOURCE)(
    IN     LPCWSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPWSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    );

#ifdef UNICODE
#define IsPathShared                    IsPathSharedW
#define SharingDialog                   SharingDialogW
#define GetNetResourceFromLocalPath     GetNetResourceFromLocalPathW
#define GetLocalPathFromNetResource     GetLocalPathFromNetResourceW
#endif

// Flags returned by IsFolderPrivateForUser via pdwPrivateType
#define IFPFU_NOT_PRIVATE               0x0000
#define IFPFU_PRIVATE                   0x0001
#define IFPFU_PRIVATE_INHERITED         0x0002
#define IFPFU_NOT_NTFS                  0x0004

STDAPI_(BOOL) IsFolderPrivateForUser(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    );

typedef
BOOL
(WINAPI* PFNISFOLDERPRIVATEFORUSER)(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    );

STDAPI_(BOOL) SetFolderPermissionsForSharing(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    );

typedef
BOOL
(WINAPI* PFNSETFOLDERPERMISSIONSFORSHARING)(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    );

#ifndef RC_INVOKED
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* !_INC_MSSHRUI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\systrayp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       SYSTRAY.H
*
*  VERSION:     2.1
*
*  AUTHOR:      Tracy Sharpe / RAL
*
*  DATE:        20 Feb 1994
*
*  Public definitions of the system tray applet (battery meter, PCMCIA, etc).
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.
*  11/8/94     RAL Converted to systray
*  10/23/95    Shawnb Unicode enabled
*
*******************************************************************************/

#ifndef _INC_SYSTRAY
#define _INC_SYSTRAY

#define SYSTRAY_CLASSNAME          TEXT ("SystemTray_Main")

//  Private tray icon notification message sent to the BatteryMeter window.
#define STWM_NOTIFYPOWER                (WM_USER + 201)
#define STWM_NOTIFYPCMCIA               (WM_USER + 202)
#define STWM_NOTIFYVOLUME               (WM_USER + 203)
#define STWM_NOTIFYSTICKYKEYS           (WM_USER + 204)
#define STWM_NOTIFYMOUSEKEYS            (WM_USER + 205)
#define STWM_NOTIFYFILTERKEYS           (WM_USER + 206)
#define STWM_NOTIFYCSC                  (WM_USER + 207)
#define STWM_NOTIFYUSBUI                (WM_USER + 208)

//  Private tray icon notification messages sent to the BatteryMeter window.
#define STWM_ENABLESERVICE              (WM_USER + 220)
#define STWM_GETSTATE                   (WM_USER + 221)

#define STSERVICE_POWER                 1
#define STSERVICE_PCMCIA                2
#define STSERVICE_VOLUME                4
#define STSERVICE_CSC                   8
#define STSERVICE_USBUI                 16
#define STSERVICE_ALL                   31   // Internal

//
//  Flags for the PCMCIA registry entry
//
#define PCMCIA_REGFLAG_NOWARN           1

//      Prototypes
_inline BOOL SysTray_EnableService(int idSTService, BOOL fEnable)
{
    HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
    if (hwndST) 
    {
        SendMessage(hwndST, STWM_ENABLESERVICE, idSTService, fEnable);
        return TRUE;
    }
    else
    {
        if (fEnable) 
        {
            static const TCHAR szOPEN[]     = TEXT ("open");
            static const TCHAR szFILE[]     = TEXT ("%windir%\\system32\\SYSTRAY.EXE");
            static const TCHAR szFORMAT[]   = TEXT ("%i");
            TCHAR szPARAMS[32]; // make this large enough that the sprintf can't fail
            
            wsprintf (szPARAMS, szFORMAT, idSTService);

            if ((HINSTANCE)32 >= ShellExecute (NULL, szOPEN, szFILE, szPARAMS, NULL, SW_SHOWNOACTIVATE))
            {
                return FALSE;
            }
        }
        return TRUE;
    } 
} // End SysTray_EnableService


_inline BOOL SysTray_IsServiceEnabled(WPARAM idSTService)
{
    HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
    if (hwndST) 
    {
        return((BOOL)SendMessage(hwndST, STWM_GETSTATE, idSTService, 0));
    } 
    else 
    {
        return (FALSE);
    }
} // End SysTray_IsServiceEnabled


#endif // _INC_SYSTRAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\shellids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//
//  Contents:   Helpids for Shell Help project (windows.hlp) - the help ids
//              in this DLL are for shell componentns (not browser only or redist)
//              ie.  Shdoc401 has a "fixed in stone" version of this headerfile
//              for the "update.hlp" help file shipped with IE.
//              ("iexplore.hlp" is used for shdocvw.dll/browseui.dll.  see iehelpid.h)
//
//  Please keep this file ordered by help ID.  That way we can
//  find space for new ids easily.
//

#define IDH_MYDOCS_TARGET       1101
#define IDH_MYDOCS_BROWSE       1102
#define IDH_MYDOCS_FIND_TARGET  1103
#define IDH_MYDOCS_RESET        1104

// Background Tab implemented in shell32.dll (Win2K version) which replaces
// the background tab implemented in desk.cpl.  The "Background" tab has been
// renamed to "Desktop" in Whistler
// (The corresponding help texts for these IDs are in "Display.hlp")
#define IDH_DISPLAY_BACKGROUND_MONITOR              4000
#define IDH_DISPLAY_BACKGROUND_WALLPAPERLIST        4001
#define IDH_DISPLAY_BACKGROUND_BROWSE_BUTTON        4002
#define IDH_DISPLAY_BACKGROUND_PICTUREDISPLAY       4003
#define IDH_DISPLAY_BACKGROUND_DISPLAY_TILE         4004
#define IDH_DISPLAY_BACKGROUND_DISPLAY_CENTER       4005
#define IDH_DISPLAY_BACKGROUND_DISPLAY_STRETCH      4006
#define IDH_DISPLAY_BACKGROUND_PATTERN_BUTTON       4007
#define IDH_DISPLAY_BACKGROUND_PATTERN_PATTERNLIST  4008
#define IDH_DISPLAY_BACKGROUND_PATTERN_PREVIEW      4009
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_BUTTON   4010
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_NAME     4011
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_SAMPLE   4012
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_PATTERN  4013
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_DONE     4177
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_ADD      4178
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_CHANGE   4179
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_REMOVE   4180
#define IDH_DISPLAY_BACKGROUND_DESKTOP_ITEMS        4181        // This brings up the "Desktop Items..." dialog, previously the "Web" tab.
#define IDH_DISPLAY_BACKGROUND_BACKGROUND_COLOR     4182        // This is the help for the Color Picking control that lets users change their background color

// Web Tab implemented in shell32.dll (Win2K version)
// (The corresponding help texts for these IDs are in "Display.hlp")
#define IDH_DISPLAY_WEB_GRAPHIC                     4500
#define IDH_DISPLAY_WEB_SHOWWEB_CHECKBOX            4501
#define IDH_DISPLAY_WEB_ACTIVEDESKTOP_LIST          4502
#define IDH_DISPLAY_WEB_NEW_BUTTON                  4503
#define IDH_DISPLAY_WEB_DELETE_BUTTON               4504
#define IDH_DISPLAY_WEB_PROPERTIES_BUTTON           4505
#define IDH_DISPLAY_WEB_SYNCHRONIZE_BUTTON          4506


// For Display Properties, Background Tab (implemented in shdoc401.dll)
#define IDH_GROUPBOX                       51000
#define IDH_WALLPAPER_LIST                 51001
#define IDH_BROWSE_WALLPAPER               51002
#define IDH_DESKTOP_PATTERN                51003
#define IDH_DISPLAY_WALLPAPER              51004
#define IDH_DISABLE_ACTIVE_DESKTOP         51005
#define IDH_WALLPAPER_SAMPLE               51006

// For Properties button (implemented in shdoc401.dll)
#define IDH_DISPLAY_PATTERN                51010
#define IDH_EDIT_PATTERN                   51011

// For Pattern Editor (implemented in shdoc401.dll)
#define IDH_PATTERN_NAME                   51012
#define IDH_PATTERN_SAMPLE                 51013
#define IDH_PATTERN_EDIT                   51014
#define IDH_ADD_PATTERN                    51015
#define IDH_CHANGE_PATTERN                 51016
#define IDH_REMOVE_PATTERN                 51017

// For Display Properties, Web tab (implemented in shdoc401.dll)
#define IDH_LIST_CHANNELS                  51020
#define IDH_NEW_CHANNEL                    51021
#define IDH_DELETE_CHANNEL                 51022
#define IDH_CHANNEL_PROPERTIES             51023
#define IDH_TRY_IT                         51024
#define IDH_RESET_ALL                      51025
#define IDH_DISPLAY_CHANNELS               51027
#define IDH_VIEW_AS_WEB_PAGE               51026
#define IDH_FOLDER_OPTIONS                 51029

// For Web tab, Properties button, Subscription tab
#define IDH_SUBSCRIBED_URL                 51030
#define IDH_SUBSCRIPTION_SUMMARY           51031
// Login button
#define IDH_CHANNEL_LOGIN                  51032
// Login Options dialog
#define IDH_LOGIN_USER_ID                  51033
#define IDH_LOGIN_PASSWORD                 51034


// For Web tab, Properties button, Receiving tab
#define IDH_EMAIL_NOTIFICATION             51035
#define IDH_DOWNLOAD                       51036
#define IDH_ADVANCED                       51028
// Change Address button
#define IDH_CHANGE_ADDRESS                 51037
// Mail Options dialog
#define IDH_EMAIL_ADDRESS                  51038
#define IDH_EMAIL_SERVER                   51039

// Advanced Download Options dialog
#define IDH_MAX_DOWNLOAD                   51040
#define IDH_HIGH_PRIORITY                  51041
#define IDH_DOWNLOAD_IMAGES                51042
#define IDH_DOWNLOAD_SOUND                 51043
#define IDH_DOWNLOAD_ACTIVEX               51044
#define IDH_DOWNLOAD_PAGES_DEEP            51045
#define IDH_FOLLOW_LINKS                   51046

// For Web tab, Properties button, Schedule tab
#define IDH_AUTO_SCHEDULE                  51050
#define IDH_CUSTOM_SCHEDULE                51051
#define IDH_MANUAL_SCHEDULE                51052

// For Custom Schedule dialog
#define IDH_NEW_NAME                       51053
#define IDH_SCHED_DAYS                     51054
#define IDH_SCHED_FREQUENCY                51055
#define IDH_SCHED_TIME                     51056
#define IDH_SCHED_REPEAT                   51057
#define IDH_VARY_START                     51058

// For View, Options, General tab, Folders and desktop (My Computer)
//#define IDH_SAMPLE_GRAPHIC                 51060 // shdoc401
//#define IDH_WEB_VIEW                       51061 // shdoc401

//  View\Options menu, Files Types tab, Add New File Type dialog box
#define  IDH_MIME_TYPE                     51063
#define  IDH_DEFAULT_EXT                   51064
#define  IDH_CONFIRM_OPEN                  51065
#define  IDH_SAME_WINDOW                   51066

//  View\Options menu, File Types tab
#define  IDH_EXTENSION                     51067
#define  IDH_OPENS_WITH                    51068

// For View, Options, View tab (My Computer)
//#define IDH_SHOW_MAP_NETWORK               51070 // shdoc401 selfreg
#define IDH_SHOW_FILE_ATTRIB               51071
#define IDH_ALLOW_UPPERCASE                51072 // shell32 selfreg
#define IDH_SMOOTH_EDGES                   51073 // shell32 selfreg
#define IDH_SHOW_WINDOW                    51074 // shell32 selfreg
#define IDH_RESTORE_DEFAULT                51075
#define IDH_VIEW_STATE                     51076 // shell32 selfreg
#define IDH_USE_CURRENT_FOLDER             51077
#define IDH_RESET_TO_ORIGINAL              51078
#define IDH_FOLDERS_IN_SEP_PROCESS         51079 // shell32 selfreg

// For Folder Properties, General tab
#define IDH_PROPERTIES_GENERAL_THUMBNAIL   51080

// For Browse for Folder (right-click taskbar, Toolbar, New Toolbar)
#define IDH_BROWSE_FOLDER_ADDRESS          51082

//   Display properties, Screen Saver tab, Channel Screen Saver settings
#define  IDH_CHANNELS_LIST                 51083
#define  IDH_SET_LENGTH                    51084
#define  IDH_PLAY_SOUNDS                   51085
#define  IDH_CLOSE_SCREENSAVER             51086

//  Subscription properties, Unsubscribe button
#define  IDH_UNSUBSCRIBE                   51087

//  Subscription properties, Schedule
#define  IDH_SCHEDULE_NEW                  51088
#define  IDH_SCHEDULE_REMOVE               51089

// For View, Options, General tab, Folders and desktop (My Computer)
//#define IDH_CLASSIC_STYLE                  51090 // shdoc401
//#define IDH_CUSTOM                         51091 // shdoc401

// For View, Options, General Tab
#define IDH_BROWSE_SAME_WINDOW             51092
#define IDH_BROWSE_SEPARATE_WINDOWS        51093
#define IDH_SHOW_WEB_WHEN_POSSIBLE         51094
#define IDH_SHOW_WEB_WHEN_CHOOSE           51095
#define IDH_SINGLE_CLICK_MODE              51096
#define IDH_TITLES_LIKE_LINKS              51097
#define IDH_TITLES_WHEN_POINT              51098
#define IDH_DOUBLE_CLICK_MODE              51099

// For View, Folder Options, Advanced
#define IDH_FULL_PATH                      51100 // shell32 selfreg
#define IDH_HIDE_EXTENSIONS                51101 // shell32 selfreg
#define IDH_SHOW_TIPS                      51102 // shell32 selfreg
#define IDH_HIDE_HIDDEN_SYSTEM             51103 // shell32 selfreg
#define IDH_HIDE_HIDDEN_ONLY               51104 // shell32 selfreg
#define IDH_SHOW_ALL                       51105 // shell32 selfreg
#define IDH_HIDE_ICONS                     51106 // shell32 selfreg
#define IDH_FULL_PATH_ADDRESSBAR           51107 // shdoc401

// For View, Options, General Tab
#define IDH_ENABLE_WEB_CONTENT             51108
#define IDH_USE_WINDOWS_CLASSIC            51109
//#define IDH_CUSTOMIZE_ACTIVE_DESKTOP       51110 // shdoc401
#define IDH_ACTIVEDESKTOP_GEN              51111
#define IDH_WEB_VIEW_GEN                   51112
#define IDH_BROWSE_FOLDERS_GEN             51113
#define IDH_ICON_OPEN_GEN                  51114
#define IDH_RESTORE_DEFAULTS_GEN           51115


// For Folder Customization Wizard
// Start Page
#define IDH_FCW_CHOOSE_OR_EDIT_TEMPLATE    51116
#define IDH_FCW_CHOOSE_BACKGROUND_PICTURE  51117
#define IDH_FCW_REMOVE_CUST                51118
#define IDH_FCW_DESCRIBE_CHOICE            51119
// Template Page
#define IDH_FCW_TEMPLATE_LIST              51120
#define IDH_FCW_TEMPLATE_PREVIEW           51121
#define IDH_FCW_DESCRIBE_TEMPLATE          51122
#define IDH_FCW_ENABLE_EDITING             51123
// Background Page
#define IDH_FCW_BACKGROUND_PREVIEW         51124
#define IDH_FCW_BACKGROUND_LIST            51125
#define IDH_FCW_BACKGROUND_BROWSE          51126
#define IDH_FCW_ICON_TEXT_COLOR            51127
#define IDH_FCW_ENABLE_ICON_BACKGROUND_COLOR    51128
#define IDH_FCW_ICON_BACKGROUND_COLOR      51129

#define IDH_SHOW_COMP_COLOR                51130 // shell32 selfreg
#define IDH_HIDDEN_FILES_GROUP             51131 // shell32 selfreg
#define IDH_STARTMENU                      51132 // shell32 selfreg
#define IDH_STARTMENU_FAVORITES            51133 // shell32 selfreg
#define IDH_STARTMENU_LOGOFF               51134 // shell32 selfreg
#define IDH_STARTMENU_CONTROLPANEL         51135 // shell32 selfreg
#define IDH_STARTMENU_MYDOCUMENTS          51136 // shell32 selfreg
#define IDH_STARTMENU_PRINTERS             51137 // shell32 selfreg
#define IDH_STARTMENU_SCROLLPROGRAMS       51138 // shell32 selfreg
#define IDH_STARTMENU_INTELLIMENUS         51139 // shell32 selfreg
#define IDH_FILES_AND_FOLDERS              51140 // shell32 selfreg

#define IDH_SHOW_MY_DOCUMENTS              51141 // mydocs selfreg (shell.hlp)

#define IDH_TASKBAR_EXPAND_NETCONNECT      51141 // shell32 selfreg
#define IDH_TASKBAR_DISPLAY_RUN            51142 // shell32 selfreg
#define IDH_TASKBAR_SIZE_MOVE              51143 // shell32 selfreg
#define IDH_TASKBAR_CONTEXTMENU            51144 // shell32 selfreg
#define IDH_TASKBAR_STARTMENU_DRAGDROP     51145 // shell32 selfreg
#define IDH_TASKBAR_EXPAND_MYPICTURES      51146 // shell32 selfreg

#define IDH_DISABLE_NETCRAWLER             51147 // shell32 selfreg
#define IDH_HIDE_CONTENT                   51148 // shell32 selfreg
#define IDH_FRIENDLY_TREE                  51149 // shell32 selfreg

// Themes Tab in Display Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_THEMES_PREVIEW               51190       // Preview window
#define IDH_DISPLAY_THEMES_LIST                 51191       // Drop Down containing Plus! Themes
#define IDH_DISPLAY_THEMES_SETTINGS             51192       // "Properties" button to Advanced settings.
#define IDH_DISPLAY_THEMES_SAVEAS               51196       // Button for Theme "Save As..."
#define IDH_DISPLAY_THEMES_DELETETHEME          51197       // Button for Theme "Delete"

// Theme Settings: These controls go on the "Theme Settings" dialog
// which is the Advanced dialog for the Theme tab in the Display
// Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_THEMESETTINGS_NAMELABLE     51200
#define IDH_DISPLAY_THEMESETTINGS_NAME          51201
#define IDH_DISPLAY_THEMESETTINGS_LABEL         51202
#define IDH_DISPLAY_THEMESETTINGS_WALLPAPER     51203
#define IDH_DISPLAY_THEMESETTINGS_SOUNDS        51204
#define IDH_DISPLAY_THEMESETTINGS_MOUSE         51205
#define IDH_DISPLAY_THEMESETTINGS_SCREENSAVER   51206
#define IDH_DISPLAY_THEMESETTINGS_ICONS         51207
#define IDH_DISPLAY_THEMESETTINGS_COLORS        51208
#define IDH_DISPLAY_THEMESETTINGS_FONTS         51209
#define IDH_DISPLAY_THEMESETTINGS_BORDERS       51210

// Appearance Tab in Display Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_APPEARANCE_PREVIEW          51220
#define IDH_DISPLAY_APPEARANCE_LOOKFEEL         51221
#define IDH_DISPLAY_APPEARANCE_LOOKFEELLABEL    51222
#define IDH_DISPLAY_APPEARANCE_COLORSCHEMELABEL 51223
#define IDH_DISPLAY_APPEARANCE_COLORSCHEME      51224
#define IDH_DISPLAY_APPEARANCE_WNDSIZELABEL     51225
#define IDH_DISPLAY_APPEARANCE_WNDSIZE          51226 
#define IDH_DISPLAY_APPEARANCE_EFFECTS          51227
#define IDH_DISPLAY_APPEARANCE_ADVANCED         51228

// Desktop Items Dialog: These controls go on the dialog
// that appears when "Desktop Items" is click in the
// Desktop tab of the Display Control Panel.
#define IDH_DESKTOPITEMS_DESKTOPICONS_GROUP     51235
#define IDH_DESKTOPITEMS_ICON_MYDOCS            51236
#define IDH_DESKTOPITEMS_ICON_MYCOMP            51237
#define IDH_DESKTOPITEMS_ICON_MYNET             51238
#define IDH_DESKTOPITEMS_ICON_RECYCLE           51239
#define IDH_DESKTOPITEMS_CHANGEDESKTOPICON_LABEL 51240
#define IDH_DESKTOPITEMS_ICONS                  51241       // List of icons
#define IDH_DESKTOPITEMS_CHANGEICON2            51242       // Change Icon Button
#define IDH_DESKTOPITEMS_ICONDEFAULT            51243       // Default Icon Button
#define IDH_DESKTOPITEMS_DESKTOPWEBPAGES_LABEL  51244
#define IDH_DESKTOPITEMS_DESKCLNR_CHECK         51245
#define IDH_DESKTOPITEMS_DESKCLNR_RUNNOW        51246
#define IDH_DESKTOPITEMS_LOCKDESKITEMS_CHECK    51247
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\shdispid.h ===
#ifndef _SHDISPID_H_
#define _SHDISPID_H_

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: shdispid.h
//
//--------------------------------------------------------------------------

// define the events for the shell folder view
#define DISPID_SELECTIONCHANGED     200     // The Selected Items Changed
#define DISPID_FILELISTENUMDONE     201     // Done enumerating the shell folder
#define DISPID_VERBINVOKED          202     // A verb (either from the main or context menu) was invoked in the folder view
#define DISPID_DEFAULTVERBINVOKED   203     // default verb (either from the main or context menu) was invoked in the folder view
#define DISPID_BEGINDRAG            204     // user clicked on an item
#define DISPID_VIEWMODECHANGED      205     // The ListViewMode Changed
#define DISPID_NOITEMSTATE_CHANGED  206     // We went from 0->some or some->0 items in the view
#define DISPID_CONTENTSCHANGED      207     // contents of the view have changed somehow
#define DISPID_FOCUSCHANGED         208     // The Focused Item Changed

// define the events for the ComboBoxEx control
#define DISPID_ENTERPRESSED         200     // The user hit Enter or Return


// Define Events for search object
#define DISPID_SEARCHCOMMAND_START      1
#define DISPID_SEARCHCOMMAND_COMPLETE   2
#define DISPID_SEARCHCOMMAND_ABORT      3
#define DISPID_SEARCHCOMMAND_UPDATE     4
#define DISPID_SEARCHCOMMAND_PROGRESSTEXT 5
#define DISPID_SEARCHCOMMAND_ERROR      6
#define DISPID_SEARCHCOMMAND_RESTORE    7


// Shell Add/Remove Programs events
#define DISPID_IADCCTL_DIRTY            0x100
#define DISPID_IADCCTL_PUBCAT           0x101
#define DISPID_IADCCTL_SORT             0x102
#define DISPID_IADCCTL_FORCEX86         0x103
#define DISPID_IADCCTL_SHOWPOSTSETUP    0x104
#define DISPID_IADCCTL_ONDOMAIN         0x105
#define DISPID_IADCCTL_DEFAULTCAT       0x106

#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\schemadef.h ===
//-----------------------------------------------------------------
//   SchemaDef.h - defines needed to build a Theme Manager schema
//                file
//-----------------------------------------------------------------
#ifndef SCHEMA_STRINGS           // FIRST PASS of this hdr file
//-----------------------------------------------------------------
#ifndef SCHEMADEF_H
#define SCHEMADEF_H
//-----------------------------------------------------------------
#define SCHEMADEF_VERSION   1    // defines the exported func(s) implemented
//-----------------------------------------------------------------
struct TMPROPINFO
{
    LPCWSTR pszName;
    SHORT sEnumVal;
    BYTE bPrimVal;
};
//-----------------------------------------------------------------
struct TMSCHEMAINFO
{
    DWORD dwSize;               // size of this struct
    int iSchemaDefVersion;      // version number from this file
    int iThemeMgrVersion;       // version number from "thschema.h"
    int iPropCount;             // # of entries in prop table
    const struct TMPROPINFO *pPropTable;       // ptr to prop table 
};
//---------------------------------------------------------------------------
#define BEGIN_TM_SCHEMA(name)               
#define BEGIN_TM_PROPS()                    enum PropValues { DummyProp = 49,
#define BEGIN_TM_ENUM(name)                 enum name {
#define BEGIN_TM_CLASS_PARTS(name)          enum name##PARTS { name##PartFiller0,
#define BEGIN_TM_PART_STATES(name)          enum name##STATES { name##StateFiller0,

#define TM_PROP(val, prefix, name, primval) prefix##_##name = val, 
#define TM_ENUM(val, prefix, name)          prefix##_##name = val,
#define TM_PART(val, prefix, name)          prefix##_##name = val, 
#define TM_STATE(val, prefix, name)         prefix##_##name = val, 

#define END_TM_CLASS_PARTS()                };
#define END_TM_PART_STATES()                };
#define END_TM_PROPS()                      };
#define END_TM_ENUM()                       };
#define END_TM_SCHEMA(name)
//---------------------------------------------------------------------------
#endif      // SCHEMADEF_H
//---------------------------------------------------------------------------
#else                   // SECOND PASS of this hdr file
//---------------------------------------------------------------------------
#undef BEGIN_TM_SCHEMA
#undef BEGIN_TM_PROPS
#undef BEGIN_TM_ENUM
#undef BEGIN_TM_CLASS_PARTS
#undef BEGIN_TM_PART_STATES
#undef TM_PROP
#undef TM_PART
#undef TM_STATE
#undef TM_ENUM
#undef END_TM_CLASS_PARTS
#undef END_TM_PART_STATES
#undef END_TM_PROPS
#undef END_TM_ENUM
#undef END_TM_SCHEMA
//---------------------------------------------------------------------------
#define BEGIN_TM_SCHEMA(name)              static const TMPROPINFO name[] = {
#define BEGIN_TM_PROPS()   
#define BEGIN_TM_ENUM(name)                 {L#name, TMT_ENUMDEF, TMT_ENUMDEF},
#define BEGIN_TM_CLASS_PARTS(name)          {L#name L"PARTS", TMT_ENUMDEF, TMT_ENUMDEF},
#define BEGIN_TM_PART_STATES(name)          {L#name L"STATES", TMT_ENUMDEF, TMT_ENUMDEF},

#define TM_PROP(val, prefix, name, primval) {L#name, prefix##_##name, TMT_##primval},
#define TM_PART(val, prefix, name)          {L#name, prefix##_##name, TMT_ENUMVAL},
#define TM_STATE(val, prefix, name)         {L#name, prefix##_##name, TMT_ENUMVAL},
#define TM_ENUM(val, prefix, name)          {L#name, prefix##_##name, TMT_ENUMVAL},

#define END_TM_CLASS_PARTS() 
#define END_TM_PART_STATES() 
#define END_TM_PROPS() 
#define END_TM_ENUM()
#define END_TM_SCHEMA(name)                };  \
    static const TMSCHEMAINFO *GetSchemaInfo() \
    {  \
        static TMSCHEMAINFO si = {sizeof(si)};  \
        si.iSchemaDefVersion = SCHEMADEF_VERSION; \
        si.iThemeMgrVersion = THEMEMGR_VERSION; \
        si.iPropCount = sizeof(name)/sizeof(name[0]); \
        si.pPropTable = name; \
        \
        return &si; \
    }

//-----------------------------------------------------------------
#endif
//-----------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\shfusion.h ===
#ifndef SHFUSION_H
#define SHFUSION_H

#include <winbase.h>

#ifdef __cplusplus
extern "C" {
#endif

extern HANDLE g_hActCtx;       // Global app context for this DLL.

#define SHFUSION_DEFAULT_RESOURCE_ID    ( 123 )
#define SHFUSION_CPL_RESOURCE_ID        ( 124 )

// These are only needed for the callers, not the implementation
// define SHFUSION_NO_API_REDEFINE to prevent this API redefinition
#if !defined(SHFUSION_IMPL) && !defined(SHFUSION_NO_API_REDEFINE)

// The following require app contexts
//#undef LoadLibrary
#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
//#undef GetClassInfo
//#undef GetClassInfoEx


//#define LoadLibrary                  SHFusionLoadLibrary
#define CreateWindow                   SHFusionCreateWindow
#define CreateWindowEx                 SHFusionCreateWindowEx
#define CreateDialogParam              SHFusionCreateDialogParam
#define CreateDialogIndirectParam      SHFusionCreateDialogIndirectParam
#define DialogBoxParam                 SHFusionDialogBoxParam
#define DialogBoxIndirectParam         SHFusionDialogBoxIndirectParam
//#define GetClassInfo                   SHFusionGetClassInfo
//#define GetClassInfoEx                 SHFusionGetClassInfoEx
#endif

void __stdcall SHGetManifest(PTSTR pszManifest, int cch);
BOOL __stdcall SHFusionInitialize(PTSTR pszPath);
BOOL __stdcall SHFusionInitializeFromModule(HMODULE hMod);
BOOL __stdcall SHFusionInitializeFromModuleID(HMODULE hMod, int id);
BOOL __stdcall SHFusionInitializeFromModuleIDCC(HMODULE hMod, int id, BOOL fLoadCC);
BOOL __stdcall SHFusionInitializeFromModuleIDNoCC(HMODULE hMod, int id);
void __stdcall SHFusionUninitialize();
BOOL __stdcall SHActivateContext(ULONG_PTR * pdwCookie);
void __stdcall SHDeactivateContext(ULONG_PTR dwCookie);
BOOL __stdcall NT5_ActivateActCtx(HANDLE h, ULONG_PTR * p);
BOOL __stdcall NT5_DeactivateActCtx(ULONG_PTR p);

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageW (LPCPROPSHEETPAGEW a);
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageA (LPCPROPSHEETPAGEA a);


STDAPI __stdcall SHSquirtManifest(HINSTANCE hInst, UINT uIdManifest, LPTSTR pszPath);

HMODULE __stdcall SHFusionLoadLibrary(LPCTSTR lpLibFileName);

HWND __stdcall SHFusionCreateWindow(
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);

// NOTE: There are times when we don't want to use the manifest for creating a window.
// The #1 case is creating the host for MSHTML. Since MSHTML is a host of ActiveX controls,
// the window manager will keep enabling fusion.
HWND __stdcall SHNoFusionCreateWindowEx(
  DWORD dwExStyle,      // extended window style
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);


HWND __stdcall SHFusionCreateWindowEx(
  DWORD dwExStyle,      // extended window style
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);

HWND __stdcall SHFusionCreateDialogIndirect(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc        // dialog box procedure
);

HWND __stdcall SHFusionCreateDialogParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
);

HWND __stdcall SHFusionCreateDialogIndirectParam(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
);

HWND __stdcall SHNoFusionCreateDialogIndirectParam(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
);

INT_PTR __stdcall SHFusionDialogBoxIndirectParam(
  HINSTANCE hInstance,             // handle to module
  LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
  HWND hWndParent,                 // handle to owner window
  DLGPROC lpDialogFunc,            // dialog box procedure
  LPARAM dwInitParam               // initialization value
);

INT_PTR __stdcall SHFusionDialogBoxParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
);


ATOM __stdcall SHFusionRegisterClass(
  CONST WNDCLASS *lpWndClass  // class data
);

ATOM __stdcall SHFusionRegisterClassEx(
  CONST WNDCLASSEX *lpwcx  // class data
);

BOOL __stdcall SHFusionGetClassInfo(
  HINSTANCE hInstance,    // handle to application instance
  LPCTSTR lpClassName,    // class name
  LPWNDCLASS lpWndClass   // class data
);

BOOL __stdcall SHFusionGetClassInfoEx(
  HINSTANCE hinst,    // handle to application instance
  LPCTSTR lpszClass,  // class name
  LPWNDCLASSEX lpwcx  // class data
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\webvwid.h ===
// Events IDs for Thumb Control
#define DISPID_ONTHUMBNAILREADY                         200
#define DISPID_WEBVIEWFOLDERICON_ONTHUMBNAILREADY       201

// Property IDs for WebView Folder Icon
#define DISPID_PROP_WVFOLDERICON_SCALE                  1
#define DISPID_PROP_WVFOLDERICON_PATH                   2
#define DISPID_PROP_WVFOLDERICON_VIEW                   3
#define DISPID_PROP_WVFOLDERICON_ADVPROPERTY            4

// New for IWebViewFolderIcon2
#define DISPID_WVFOLDERICON_SETSLICE                    5
// New for IWebViewFolderIcon3
#define DISPID_PROP_WVFOLDERICON_ITEM                   6
#define DISPID_PROP_WVFOLDERICON_CLICKSTYLE             7
#define DISPID_PROP_WVFOLDERICON_LABELGAP               8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\shfolder.h ===
// functions to get shell special folders/
// shfolder.dll supports these on all platforms including Win95, Win98, NT4 and IE4 shell

// all CSIDL values referred to here are supported natively by shfolder.dll, that is they
// will work on all platforms.

#ifndef _SHFOLDER_H_
#define _SHFOLDER_H_

#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif

#ifndef CSIDL_PERSONAL
#define CSIDL_PERSONAL                  0x0005      // My Documents
#endif

#ifndef CSIDL_MYMUSIC
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#endif

#ifndef CSIDL_APPDATA
#define CSIDL_APPDATA                   0x001A      // Application Data, new for NT4
#endif

#ifndef CSIDL_LOCAL_APPDATA

#define CSIDL_LOCAL_APPDATA             0x001C      // non roaming, user\Local Settings\Application Data
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023      // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024      // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025      // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026      // C:\Program Files
#define CSIDL_MYPICTURES                0x0027      // My Pictures, new for Win2K
#define CSIDL_PROGRAM_FILES_COMMON      0x002b      // C:\Program Files\Common 
#define CSIDL_COMMON_DOCUMENTS          0x002e      // All Users\Documents
#define CSIDL_RESOURCES                 0x0038      // %windir%\Resources\, For theme and other windows resources.
#define CSIDL_RESOURCES_LOCALIZED       0x0039      // %windir%\Resources\<LangID>, for theme and other windows specific resources.


#define CSIDL_FLAG_CREATE               0x8000      // new for Win2K, or this in to force creation of folder

#define CSIDL_COMMON_ADMINTOOLS         0x002f      // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030      // <user name>\Start Menu\Programs\Administrative Tools

#endif // CSIDL_LOCAL_APPDATA


SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

// protos so callers can GetProcAddress() from shfolder.dll

typedef HRESULT (__stdcall * PFNSHGETFOLDERPATHA)(HWND, int, HANDLE, DWORD, LPSTR);  // "SHGetFolderPathA"
typedef HRESULT (__stdcall * PFNSHGETFOLDERPATHW)(HWND, int, HANDLE, DWORD, LPWSTR); // "SHGetFolderPathW"

#ifdef UNICODE
#define SHGetFolderPath     SHGetFolderPathW
#define PFNSHGETFOLDERPATH  PFNSHGETFOLDERPATHW
#else
#define SHGetFolderPath     SHGetFolderPathA
#define PFNSHGETFOLDERPATH  PFNSHGETFOLDERPATHA
#endif

#endif //  _SHFOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\uxthemep.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : uxthemep.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEMEP_H_                   
#define _UXTHEMEP_H_                   
//---------------------------------------------------------------------------
#include <uxtheme.h> 
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following routines are provided for use by Theme Selection UI.
//---------------------------------------------------------------------------

//---- bits returned by QueryThemeServices() ----

#define QTS_AVAILABLE  (1 << 0)  // services are available
#define QTS_RUNNING    (1 << 1)  // services are running

//---------------------------------------------------------------------------
//  QueryThemeServices()
//                      - returns flags about theme services (see above)
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) QueryThemeServices();

//---------------------------------------------------------------------------
typedef HANDLE HTHEMEFILE;    // handle to a loaded theme file

//---------------------------------------------------------------------------
//  OpenThemeFile()    - Load specified theme into memory (doesn't apply it)
//
//  pszThemePath       - full path of .msstyles file to load
//
//  pszColorScheme     - (optional) name of theme color scheme to load
//
//  pszSize            - (optional) name of theme size to load
//
//  phThemeFile        - if a theme is successfully opened, this handle
//                        is set to a non-NULL value and holds a ref-count 
//                        on the theme to keep it in loaded in memory.
//
//  fGlobalTheme       - FALSE if it's a preview, TRUE if the theme is intended
//                         to be made permanent for the user
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFile(LPCWSTR pszThemePath, OPTIONAL LPCWSTR pszColorParam,
   OPTIONAL LPCWSTR pszSizeParam, OUT HTHEMEFILE *phThemeFile, BOOL fGlobalTheme);

//---------------------------------------------------------------------------
//  CloseThemeFile()   - decrements the ref-count for the theme identified
//                       by the hThemeFile handle
//
//  hThemeFile         - open handle to the loaded theme file
//---------------------------------------------------------------------------
THEMEAPI CloseThemeFile(HTHEMEFILE hThemeFile);

//---------------------------------------------------------------------------
//--- WM_THEMECHANGED msg parameters (internal use only) ----
//---   "wParam" is the "change number" ----

//---- lParam bits ----
#define WTC_THEMEACTIVE     (1 << 0)        // new theme is now active
#define WTC_CUSTOMTHEME     (1 << 1)        // this msg for custom-themed apps

//---------------------------------------------------------------------------
//---- option flags for ApplyTheme() ----

#define AT_LOAD_SYSMETRICS          (1 << 0)        // apply the theme's metrics w/theme
                                                    // or default classic metrics when
                                                    // turning themes off.

#define AT_PROCESS                  (1 << 1)        // apply to current process only
#define AT_EXCLUDE                  (1 << 2)        // all but the specified process/window
#define AT_CACHETHEME               (1 << 3)        // cache this theme file, if applied

#define AT_NOREGUPDATE              (1 << 4)        // don't update the CU registry for theme info
#define AT_SYNC_LOADMETRICS         (1 << 5)        // load system metrics on calling thread

//---- below flags currently not supported ----
#define AT_DISABLE_FRAME_THEMING    (1 << 10)
#define AT_DISABLE_DIALOG_THEMING   (1 << 11)

//---------------------------------------------------------------------------
//  ApplyTheme()        - Apply (or remove) a loaded theme file globally
//                        or to specified apps/windows.
//
//                        Note that when a theme is applied globally
//                        (hwndTarget is NULL), the theme services manager 
//                        will hold a refcount on the theme file.  This
//                        means that the caller can close his HTHEMEFILE 
//                        handle after the ApplyTheme() call.
//
//                        When the global theme is removed, the theme
//                        services manager will drop is refcount.      
//
//      hThemeFile      - (optional)handle to the loaded theme file. 
//                        if NULL then any theme on target app/windows 
//                        will be removed.
//
//      dwApplyFlags    - options for applying theme (see above)
//
//      hwndTarget      - (optional) only theme this window
//---------------------------------------------------------------------------
THEMEAPI ApplyTheme(OPTIONAL HTHEMEFILE hThemeFile, DWORD dwApplyFlags,
    OPTIONAL HWND hwndTarget);


//---------------------------------------------------------------------------
//  SetSystemVisualStyle() - Securely loads and applies (or clears) a global theme.
//
//  pszVisualStylesFile  - full path of .msstyles file to load
//
//  pszColorScheme       - (optional) name of visual style color scheme to load
//
//  pszSize              - (optional) name of visual style size to load
//
//
//  dwApplyFlags         - options for applying the visual style (see ApplyTheme above)
//---------------------------------------------------------------------------
THEMEAPI SetSystemVisualStyle(
    LPCWSTR pszVisualStylesFile, 
    OPTIONAL LPCWSTR pszColorScheme,
    OPTIONAL LPCWSTR pszSize, 
    DWORD dwApplyFlags );

//---------------------------------------------------------------------------
//  RegisterDefaultTheme()
//                      - registers the specified theme as the default
//                        for all users on the system.
//
//  pszThemeFileName    - the name of the theme file (NULL = no theme)
//
//  fOverride           - if TRUE, will override current default theme
//---------------------------------------------------------------------------
THEMEAPI RegisterDefaultTheme(LPCWSTR pszFileName, BOOL fOverride);

//---------------------------------------------------------------------------
//  THEMECALLBACK is a enum describing the type of callback being done
//---------------------------------------------------------------------------
typedef enum THEMECALLBACK
{
    TCB_THEMENAME,      // theme name enumeration
    TCB_COLORSCHEME,    // color scheme enumeration
    TCB_SIZENAME,       // size name enumeration
    TCB_SUBSTTABLE,     // substitution table enumeration
    TCB_CDFILENAME,     // classdata file name enumeration
    TCB_CDFILECOMBO,    // classdata file color/size combinations

    TCB_FILENAME,         // parsed a filename
    TCB_DOCPROPERTY,      // parsed a standard doc property
    TCB_NEEDSUBST,        // callback to get a substituted symbol
    TCB_MINCOLORDEPTH,    // parsed the min color depth

    //---- localizable property callbacks ----
    TCB_FONT,             // parsed a font string
    TCB_MIRRORIMAGE,      // parsed the MirrorImage property
    TCB_LOCALIZABLE_RECT, // parsed a RECT property that needs to be localizable
};

//---------------------------------------------------------------------------
typedef struct 
{
    WCHAR szName[MAX_PATH+1];
    WCHAR szDisplayName[MAX_PATH+1];
    WCHAR szToolTip[MAX_PATH+1];
} THEMENAMEINFO;

//---------------------------------------------------------------------------
//  THEMEENUMPROC()     - callback used by the theme enum/parsing functions.
//                        the return value is used to continue or abort
//                        the enumeration.
//
//  tcbType             - callback type being made 
//  pszName             - simple name of the item being enumerated
//  pszName2            - varies by callback type
//  pszName3            - varies by callback type
//  iIndex              - index number associated with some items
//  lParam              - callback param supplied by caller
//---------------------------------------------------------------------------
typedef BOOL (CALLBACK* THEMEENUMPROC)(enum THEMECALLBACK tcbType,
    LPCWSTR pszName, OPTIONAL LPCWSTR pszName2, 
    OPTIONAL LPCWSTR pszName3, OPTIONAL int iIndex, LPARAM lParam);

//---------------------------------------------------------------------------
//  EnumThemes()        - calls the callback function "lpEnumFunc" with each 
//                        theme.  During the callback, the filename,
//                        Display name, and tooltip string for each theme
//                        are returned.
//
//  pszThemeRoot        - the theme root directory; each theme DLL found in 
//                        a separate subdir immediately under the theme root 
//                        dir is enumerated.  The root name of the DLL must 
//                        match its containing subdir name
//
//  lpEnumFunc          - ptr to the caller's callback function which will
//                        be called for each theme enumerated
//
//  lParam              - caller's callback parameter (will be passed to
//                        lpEnumFunc())
//---------------------------------------------------------------------------
THEMEAPI EnumThemes(LPCWSTR pszThemeRoot, THEMEENUMPROC lpEnumFunc, 
    LPARAM lParam);

//---------------------------------------------------------------------------
//  EnumThemeSizes()    - support direct enumeration of all available theme
//                        sizes.  
//
//  pszThemeName        - is the name of the theme file.
//  pszColorScheme      - (optional) only sizes for this color are enum-ed
//  dwSizeIndex         - 0-relative index of the size being queryed
//  ptn                 - ptr to struct to receive name strings
//---------------------------------------------------------------------------
THEMEAPI EnumThemeSizes(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, 
    OUT THEMENAMEINFO *ptn);

//---------------------------------------------------------------------------
//  EnumThemeColors()   - support direct enumeration of all available theme
//                        color schemes.  
//
//  pszThemeName        - name of the theme file.
//  pszSizeName         - (optional) only colors for this size are enum-ed
//  dwColorIndex        - 0-relative index of the color being queryed
//  ptn                 - ptr to struct to receive name strings
//---------------------------------------------------------------------------
THEMEAPI EnumThemeColors(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, 
    OUT THEMENAMEINFO *ptn);

//---------------------------------------------------------------------------
//  GetThemeDefaults() - returns the default Color name and default Size
//                       name for the specified theme file
//
//  pszThemeName        - name of the theme file
//
//  pszDefaultColor     - buffer to receive the default color name
//                        (the canonical name, not the display version)
//  cchMaxColorChars    - max chars that pszDefaultColor can contain
//
//  pszDefaultSize      - buffer to receive the default size name
//                        (the canonical name, not the display version)
//  cchMaxSizeChars     - max chars that pszDefaultSize can contain
//---------------------------------------------------------------------------
THEMEAPI GetThemeDefaults(LPCWSTR pszThemeName,
    OUT OPTIONAL LPWSTR pszDefaultColor, int cchMaxColorChars, 
    OUT OPTIONAL LPWSTR pszDefaultSize, int cchMaxSizeChars);

//---------------------------------------------------------------------------
#define PTF_CONTAINER_PARSE         0x0001  // parse as a "themes.ini" file
#define PTF_CLASSDATA_PARSE         0x0002  // parse as a "bigred.ini" classdata file

#define PTF_CALLBACK_COLORSECTION   0x0004  // callback on all [colorscheme.xxx] sections
#define PTF_CALLBACK_SIZESECTION    0x0008  // callback on all [size.xxx] sections
#define PTF_CALLBACK_FILESECTION    0x0010  // callback on all [file.xxx] sections 

#define PTF_CALLBACK_FILENAMES      0x0020  // callback on all "filename=" properties
#define PTF_CALLBACK_LOCALIZATIONS  0x0040  // callback on all localizable properties
#define PTF_CALLBACK_DOCPROPERTIES  0x0080  // callback on all standard properties in [doc] section
#define PTF_QUERY_DOCPROPERTY       0x0100  // query for value of specified property (internal)
#define PTF_CALLBACK_SUBSTTABLE     0x0400  // callback on all [subst.xxx] sections 
#define PTF_CALLBACK_SUBSTSYMBOLS   0x0800  // callback on a substituted symbol (##)
#define PTF_CALLBACK_MINCOLORDEPTH  0x1000  // callback on "MinColorDepth="

//---------------------------------------------------------------------------
//  ParseThemeIniFile() - Parse the "themes.inc" file specified by 
//                        "pszFileName". 

//  pzFileName          - name of the theme.inc file to parse
//  dwParseFlags        - flags that control parsing & callback options
//  pfnCallBack         - ptr to caller-supplied callback function
//  lparam              - caller's callback param
//---------------------------------------------------------------------------
THEMEAPI ParseThemeIniFile(LPCWSTR pszFileName, DWORD dwParseFlags,
    OPTIONAL THEMEENUMPROC pFnCallBack, OPTIONAL LPARAM lparam);

//---------------------------------------------------------------------------
#define THEME_PARSING_ERROR(hr)  (SCODE_CODE(hr) == ERROR_UNKNOWN_PROPERTY)

typedef struct _PARSE_ERROR_INFO
{
    DWORD dwSize;                   // of this structure

    //---- last parse error info ----
    DWORD dwParseErrCode;           // error code from last error
    WCHAR szMsg[2*MAX_PATH];    // value of first param for msg
    WCHAR szFileName[MAX_PATH];     // associated source filename
    WCHAR szSourceLine[MAX_PATH];   // source line
    int iLineNum;                   // source line number
} 
PARSE_ERROR_INFO, *PPARSE_ERROR_INFO;
//---------------------------------------------------------------------------
//  GetThemeParseErrorInfo()
//                      - fill in the PARSE_ERROR_CONTEXT structure
//                        with needed information about the last theme API 
//                        parse error.
//
//  pInfo               - ptr to the PARSE_ERROR_INFO to be filled
//---------------------------------------------------------------------------
THEMEAPI GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo);

//---------------------------------------------------------------------------
// resource base numbers for localizable string tables in a .msstyles file
//---------------------------------------------------------------------------
#define RES_BASENUM_COLORDISPLAYS   1000
#define RES_BASENUM_COLORTOOLTIPS   2000

#define RES_BASENUM_SIZEDISPLAYS    3000
#define RES_BASENUM_SIZETOOLTIPS    4000

#define RES_BASENUM_DOCPROPERTIES   5000        // in order shown in TmSchema.h

#define RES_BASENUM_PROPVALUEPAIRS  6000        // property names & localizable values

//---------------------------------------------------------------------------
//  DrawNCPreview()     - Previews the theme for the NC area of a window
//
//  hdc                 - HDC for preview to be draw into
//  prc                 - RECT for preview
//
//---------------------------------------------------------------------------
#define NCPREV_INACTIVEWINDOW   0x00000001
#define NCPREV_ACTIVEWINDOW     0x00000002
#define NCPREV_MESSAGEBOX       0x00000004
#define NCPREV_RTL              0x00000008

THEMEAPI DrawNCPreview(HDC hdc, DWORD dwFlags, LPRECT prc, LPCWSTR pszVSPath, 
    LPCWSTR pszVSColor, LPCWSTR pszVSSize, NONCLIENTMETRICS* pncm, 
    COLORREF* prgb);


//---------------------------------------------------------------------------
//  DumpLoadedThemeToTextFile()     
//                      - (for internal testing) dumps the contents of the
//                        loaded theme file to the specified text file
//
//      hThemeFile      - the handle of the loaded theme file
//
//      pszTextFile     - path of the text file to create & write to
//
//      fPacked         - TRUE to dump packed objects; FALSE for normal
//                        properties
//
//      fFullInfo       - includes sizes, offsets, paths, etc.  Use FALSE
//                        for info that will be DIFF-ed across builds/machines
//---------------------------------------------------------------------------
THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, 
    LPCWSTR pszTextFile, BOOL fPacked, BOOL fFullInfo);

#ifdef __cplusplus

class CDrawBase;          // forward
class CTextDraw;          // forward

//---------------------------------------------------------------------------
//  CreateThemeDataFromObjects() 
//                      - creates a theme handle from a CBorderFill, 
//                        CImageFile, and/or CTextDraw object.  At lease one
//                        non-NULL ptr must be passed (either or both).
//
//      pDrawObj       - (optional) ptr to an object derived from CDrawBase
//                       NOTE: if pDrawObj is a CImageFile ptr and its
//                       "_pImageData" contains any alpha channel bitmaps,
//                       the bits in those bitmaps will be "pre-multiplied"
//                       for alpha blending.
//
//      pTextObj       - (optional) ptr to a CTextDraw object
//
//      dwOtdFlags     - theme override flags (see OpenThemeDataEx())
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags);
#endif

//---------------------------------------------------------------------------
//  OpenThemeDataFromFile() 
//                      - Open the theme data for the specified loaded theme
//                        file and semi-colon separated list of class names.  
//                        OpenThemeDataFromFile() will try each class name, 
//                        one at a time, and use the first matching theme info
//                        found.  If none match, "NULL" is returned.  
//
//                        Note: normal controls should NOT use this API;
//                        they should use "OpenThemeData()" (which uses the
//                        current global or app theme).
//
//      hLoadedThemeFile - handle to the loaded theme file.
//
//      hwnd             - (optional) hwnd to base the HTHEME on
//
//      pszClassList     - (optional) class name (or list of names) to match 
//                         to theme data section; if NULL, will get match
//                         to [globals] section.
//
//      fClient          - TRUE if theming a client window with returned 
//                         HTHEME.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient);

//---------------------------------------------------------------------------
//  OpenThemeFileFromData() 
//                      - Open the theme file corresponding to the HTHEME.
//
//      hTheme          - handle to the theme data from OpenThemeData().
//
//      phThemeFile     - ptr to return HTHEMEFILE to.
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFileFromData(HTHEME hTheme, HTHEMEFILE *phThemeFile);

//---------------------------------------------------------------------------
//  GetThemeSysSize96() - Get the value of the specified System size metric. 
//                        (original value authored for 96 dpi)
//
//  hTheme              - the theme data handle (required).  Will return
//                        size from [SysMetrics] section of theme.
//
//  iSizeId             - only the following sizes are supported:
//
//                          SM_CXBORDER   (border width)
//                          SM_CXVSCROLL  (scrollbar width)
//                          SM_CYHSCROLL  (scrollbar height)
//                          SM_CXSIZE     (caption width)
//                          SM_CYSIZE     (caption height)
//                          SM_CXSMSIZE   (small caption width)
//                          SM_CYSMSIZE   (small caption height)
//                          SM_CXMENUSIZE (menubar width)
//                          SM_CYMENUSIZE (menubar height)
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize96(HTHEME hTheme, int iSizeId);

//---------------------------------------------------------------------------
//  GetThemeSysFont96() - Get the LOGFONT for the specified System font. 
//                        (original value authored for 96 dpi)
//
//  hTheme              - the theme data handle (required).  Will return
//                        size from [SysMetrics] section of theme.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont96(HTHEME hTheme, int iFontId, OUT LOGFONT *plf);

//---------------------------------------------------------------------------
//  RefreshThemeForTS() 
//                      - turn themes on/off for current Terminal Server user
//---------------------------------------------------------------------------
THEMEAPI RefreshThemeForTS();

//---------------------------------------------------------------------------
//---- flag bits for OpenThemeDataEx() ----

#define OTD_FORCE_RECT_SIZING   0x0001      // make all parts size to rect
#define OTD_NONCLIENT           0x0002      // set if hTheme to be used for nonclient area
//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataEx(HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags);

THEMEAPI CheckThemeSignature (LPCWSTR pszName);

//---------------------------------------------------------------------------
//  ClassicGetSystemMetrics( int iMetric );
//  
//  ClassicSystemParametersInfoA( IN UINT uiAction, IN UINT uiParam, 
//                                IN OUT PVOID pvParam, IN UINT fWinIni);
//  ClassicSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, 
//                                IN OUT PVOID pvParam, IN UINT fWinIni);
//  ClassicAdjustWindowRectEx( IN LPRECT prcWnd, IN DWORD dwStyle, IN BOOL fMenu, IN DWORD dwExStyle );
//
//  These exports correspond to their Win32 API counterparts and ensure that
//  the classic visual style metrics are retrieved.   Theme hooks are shunted.
//---------------------------------------------------------------------------
THEMEAPI_(int)  ClassicGetSystemMetrics( int iMetric );
THEMEAPI_(BOOL) ClassicSystemParametersInfoA( UINT uiAction, UINT uiParam, IN OUT PVOID pvParam, UINT fWinIni);
THEMEAPI_(BOOL) ClassicSystemParametersInfoW( UINT uiAction, UINT uiParam, IN OUT PVOID pvParam, UINT fWinIni);
THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, BOOL fMenu, DWORD dwExStyle );

#ifdef UNICODE
#define ClassicSystemParametersInfo ClassicSystemParametersInfoW
#else  UNICODE
#define ClassicSystemParametersInfo ClassicSystemParametersInfoA
#endif UNICODE 

//---------------------------------------------------------------------------
#define PACKTHEM_VERSION 3      // latest change: localizable properties

//---------------------------------------------------------------------------
#endif // _UXTHEMEP_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\themeid.h ===
/**************************************************************************\
    FILE: ThemeID.h
    DATE: BryanSt (3/31/2000)

    DESCRIPTION:
        Theme API (Object Model).

    Copyright (c) Microsoft Corporation. All rights reserved.
\**************************************************************************/

#ifndef _THEMEIDLID_H_

// define the ...
#define DISPID_NXOBJ_MIN                 0x00000000
#define DISPID_NXOBJ_MAX                 0x0000FFFF
#define DISPID_NXOBJ_BASE                DISPID_NXOBJ_MIN


//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------


// IThemeManager Properties
#define DISPIDTHTM_CURRENTTHEME         (DISPID_NXOBJ_BASE + 100)
#define DISPIDTHTM_LENGTH               (DISPID_NXOBJ_BASE + 101)
#define DISPIDTHTM_ITEM                 (DISPID_NXOBJ_BASE + 102)
#define DISPIDTHTM_SELECTEDSCHEME       (DISPID_NXOBJ_BASE + 103)
#define DISPIDTHTM_WEBVIEWCSS           (DISPID_NXOBJ_BASE + 104)
#define DISPIDTHTM_SCHEMELENGTH         (DISPID_NXOBJ_BASE + 105)
#define DISPIDTHTM_SCHEMEITEM           (DISPID_NXOBJ_BASE + 106)
// IThemeManager Methods
#define DISPIDTHTM_GETSELSCHPROPERTY    (DISPID_NXOBJ_BASE + 150)
#define DISPIDTHTM_GETSPECIALTHEME      (DISPID_NXOBJ_BASE + 151)
#define DISPIDTHTM_SETSPECIALTHEME      (DISPID_NXOBJ_BASE + 152)
#define DISPIDTHTM_GETSPECIALSCHEME     (DISPID_NXOBJ_BASE + 153)
#define DISPIDTHTM_SETSPECIALSCHEME     (DISPID_NXOBJ_BASE + 154)
#define DISPIDTHTM_APPLYNOW             (DISPID_NXOBJ_BASE + 155)


// ITheme Properties
#define DISPIDTHTH_DISPLAYNAME          (DISPID_NXOBJ_BASE + 200)
#define DISPIDTHTH_BKGD                 (DISPID_NXOBJ_BASE + 201)
#define DISPIDTHTH_BKGDTILE             (DISPID_NXOBJ_BASE + 202)
#define DISPIDTHTH_SCRNSAVER            (DISPID_NXOBJ_BASE + 203)
#define DISPIDTHTH_LENGTH               (DISPID_NXOBJ_BASE + 204)
#define DISPIDTHTH_ITEM                 (DISPID_NXOBJ_BASE + 205)
#define DISPIDTHTH_SELECTEDSCHEME       (DISPID_NXOBJ_BASE + 206)
// ITheme Methods
#define DISPIDTHTH_GETPATH              (DISPID_NXOBJ_BASE + 250)
#define DISPIDTHTH_SETPATH              (DISPID_NXOBJ_BASE + 251)
#define DISPIDTHTH_VS                   (DISPID_NXOBJ_BASE + 252)
#define DISPIDTHTH_VSCOLOR              (DISPID_NXOBJ_BASE + 253)
#define DISPIDTHTH_VSSIZE               (DISPID_NXOBJ_BASE + 254)
#define DISPIDTHTH_GETCURSOR            (DISPID_NXOBJ_BASE + 255)
#define DISPIDTHTH_SETCURSOR            (DISPID_NXOBJ_BASE + 256)
#define DISPIDTHTH_GETSOUND             (DISPID_NXOBJ_BASE + 257)
#define DISPIDTHTH_SETSOUND             (DISPID_NXOBJ_BASE + 258)
#define DISPIDTHTH_GETICON              (DISPID_NXOBJ_BASE + 259)
#define DISPIDTHTH_SETICON              (DISPID_NXOBJ_BASE + 260)
#define DISPIDTHTH_GETICONBYKEY         (DISPID_NXOBJ_BASE + 261)
#define DISPIDTHTH_SETICONBYKEY         (DISPID_NXOBJ_BASE + 262)
#define DISPIDTHTH_GETWEBVW             (DISPID_NXOBJ_BASE + 263)
#define DISPIDTHTH_SETWEBVW             (DISPID_NXOBJ_BASE + 264)


// IThemeScheme Properties
#define DISPIDTHTS_SCHDISPNAME          (DISPID_NXOBJ_BASE + 301)
#define DISPIDTHTS_SCHEMEPATH           (DISPID_NXOBJ_BASE + 302)
#define DISPIDTHTS_LENGTH               (DISPID_NXOBJ_BASE + 303)
#define DISPIDTHTS_ITEM                 (DISPID_NXOBJ_BASE + 304)
#define DISPIDTHTS_SELECTEDSTYLE        (DISPID_NXOBJ_BASE + 305)
// IThemeScheme Methods
#define DISPIDTHTS_ADDSTYLE             (DISPID_NXOBJ_BASE + 350)


// IThemeStyle Properties
#define DISPIDTHSY_DISPNAME             (DISPID_NXOBJ_BASE + 400)
#define DISPIDTHSY_NAME                 (DISPID_NXOBJ_BASE + 401)
#define DISPIDTHSY_LENGTH               (DISPID_NXOBJ_BASE + 402)
#define DISPIDTHSY_ITEM                 (DISPID_NXOBJ_BASE + 403)
#define DISPIDTHSY_SELECTEDSIZE         (DISPID_NXOBJ_BASE + 404)
// IThemeStyle Methods
#define DISPIDTHSY_ADDSIZE              (DISPID_NXOBJ_BASE + 450)


// IThemeSize Properties
#define DISPIDTHSZ_DISPNAME             (DISPID_NXOBJ_BASE + 500)
#define DISPIDTHSZ_NAME                 (DISPID_NXOBJ_BASE + 501)
#define DISPIDTHSZ_SYSMETCOLOR          (DISPID_NXOBJ_BASE + 502)
#define DISPIDTHSZ_SYSMETSIZE           (DISPID_NXOBJ_BASE + 503)
#define DISPIDTHSZ_WEBVIEWCSS           (DISPID_NXOBJ_BASE + 504)
#define DISPIDTHSZ_CONTRASTLVL          (DISPID_NXOBJ_BASE + 505)
// IThemeSize Methods
#define DISPIDTHSZ_GETSYSMETFONT        (DISPID_NXOBJ_BASE + 550)
#define DISPIDTHSZ_PUTSYSMETFONT        (DISPID_NXOBJ_BASE + 551)

// IThemePreview Methods
#define DISPIDTHPV_UPDATE               (DISPID_NXOBJ_BASE + 650)
#define DISPIDTHPV_CREATEPREVIEW        (DISPID_NXOBJ_BASE + 651)

#define SZ_HELPTHTM_GETCURRENTTHEME                 helpstring("Get the current theme")
#define SZ_HELPTHTM_PUTCURRENTTHEME                 helpstring("Set the current theme")
#define SZ_HELPTHTM_GETLENGTH                       helpstring("Get the number of existing themes")
#define SZ_HELPTHTM_GETITEM                         helpstring("Get a theme by its index")
#define SZ_HELPTHTM_INSTALLTHEME                    helpstring("Install the theme specified by the path")
#define SZ_HELPTHTM_GETSELECTEDSCHEME               helpstring("Get the currently selected scheme")
#define SZ_HELPTHTM_PUTSELECTEDSCHEME               helpstring("Set the currently selected scheme")
#define SZ_HELPTHTM_WEBVIEWCSS                      helpstring("Get the webview CSS file.")
#define SZ_HELPTHTM_GETSCHEMELENGTH                 helpstring("Get the number of existing schemes")
#define SZ_HELPTHTM_GETSCHEMEITEM                   helpstring("Get a scheme by its index")

#define SZ_HELPTHTM_GETSELSCHPROPERTY               helpstring("Get a property of a special marked scheme.  Like a filename, displayname, or canonical name.")
#define SZ_HELPTHTM_GETSPECIALTHEME                 helpstring("Get a special theme by name")
#define SZ_HELPTHTM_SETSPECIALTHEME                 helpstring("Set a special theme by name")
#define SZ_HELPTHTM_GETSPECIALSCHEME                helpstring("Get a special scheme by name")
#define SZ_HELPTHTM_SETSPECIALSCHEME                helpstring("Set a special scheme by name")
#define SZ_HELPTHTM_APPLYNOW                        helpstring("Apply the settings now")

#define SZ_HELPTHTH_GETDISPLAYNAME                  helpstring("Get the display name for the theme")
#define SZ_HELPTHTH_PUTDISPLAYNAME                  helpstring("Set the display name for the theme")
#define SZ_HELPTHTH_GETPATH                         helpstring("Get the path to the theme file")
#define SZ_HELPTHTH_PUTPATH                         helpstring("Set the path to the theme file")
#define SZ_HELPTHTH_GETVS                           helpstring("Get the path to the Visual Style file")
#define SZ_HELPTHTH_PUTVS                           helpstring("Set the path to the Visual Style file")
#define SZ_HELPTHTH_GETVSCOLOR                      helpstring("Get the path to the Visual Style color")
#define SZ_HELPTHTH_PUTVSCOLOR                      helpstring("Set the path to the Visual Style color")
#define SZ_HELPTHTH_GETVSSIZE                       helpstring("Get the path to the Visual Style size")
#define SZ_HELPTHTH_PUTVSSIZE                       helpstring("Set the path to the Visual Style size")
#define SZ_HELPTHTH_GETBKGD                         helpstring("Get the background picture path")
#define SZ_HELPTHTH_PUTBKGD                         helpstring("Set the background picture path")
#define SZ_HELPTHTH_GETBKGDTILE                     helpstring("Get the background tile method")
#define SZ_HELPTHTH_PUTBKGDTILE                     helpstring("Set the background tile method")
#define SZ_HELPTHTH_GETCURSOR                       helpstring("Get a cursor's filename")
#define SZ_HELPTHTH_PUTCURSOR                       helpstring("Set a cursor's filename")
#define SZ_HELPTHTH_GETSOUND                        helpstring("Get a sound's filename")
#define SZ_HELPTHTH_PUTSOUND                        helpstring("Set a sound's filename")
#define SZ_HELPTHTH_GETICON                         helpstring("Get an icon's filename")
#define SZ_HELPTHTH_PUTICON                         helpstring("Set an icon's filename")
#define SZ_HELPTHTH_GETICONBYKEY                    helpstring("Get an icon's filename by specifying the registry key")
#define SZ_HELPTHTH_PUTICONBYKEY                    helpstring("Set an icon's filename by specifying the registry key")
#define SZ_HELPTHTH_GETSCRNSAVER                    helpstring("Get the ScreenSaver filename")
#define SZ_HELPTHTH_PUTSCRNSAVER                    helpstring("Get the ScreenSaver filename")
#define SZ_HELPTHTH_GETWEBVW                        helpstring("Get a webview's filename")
#define SZ_HELPTHTH_PUTWEBVW                        helpstring("Set a webview's filename")
#define SZ_HELPTHTH_GETLENGTH                       helpstring("Get the number of existing schemes")
#define SZ_HELPTHTH_GETITEM                         helpstring("Get a scheme by its index")
#define SZ_HELPTHTH_GETSELECTEDSCHEME               helpstring("Get the currently selected scheme")
#define SZ_HELPTHTH_PUTSELECTEDSCHEME               helpstring("Set the currently selected scheme")

#define SZ_HELPTHTS_GETSCHDISPNAME                  helpstring("Get the display name for the scheme")
#define SZ_HELPTHTS_PUTSCHDISPNAME                  helpstring("Set the display name for the scheme")
#define SZ_HELPTHTS_GETSCHEMEPATH                   helpstring("Get the path to the scheme file")
#define SZ_HELPTHTS_PUTSCHEMEPATH                   helpstring("Set the path to the scheme file")
#define SZ_HELPTHTS_GETLENGTH                       helpstring("Get the number of existing theme styles")
#define SZ_HELPTHTS_GETITEM                         helpstring("Get a style by its index")
#define SZ_HELPTHTS_GETSELECTEDSTYLE                helpstring("Get the currently selected style")
#define SZ_HELPTHTS_PUTSELECTEDSTYLE                helpstring("Set the currently selected style")
#define SZ_HELPTHTS_ADDSTYLE                        helpstring("Add a style")

#define SZ_HELPTHSY_GETDISPNAME                     helpstring("Get the display name for the style")
#define SZ_HELPTHSY_PUTDISPNAME                     helpstring("Set the display name for the style")
#define SZ_HELPTHSY_GETNAME                         helpstring("Get the canonical name for the style")
#define SZ_HELPTHSY_PUTNAME                         helpstring("Set the canonical name for the style")
#define SZ_HELPTHSY_GETLENGTH                       helpstring("Get the number of existing theme sizes")
#define SZ_HELPTHSY_GETITEM                         helpstring("Get a size by its index")
#define SZ_HELPTHSY_GETSELECTEDSIZE                 helpstring("Get the currently selected size")
#define SZ_HELPTHSY_PUTSELECTEDSIZE                 helpstring("Set the currently selected size")
#define SZ_HELPTHSY_ADDSIZE                         helpstring("Add a size")

#define SZ_HELPTHSZ_GETDISPNAME                     helpstring("Get the display name for the size")
#define SZ_HELPTHSZ_PUTDISPNAME                     helpstring("Set the display name for the size")
#define SZ_HELPTHSZ_GETNAME                         helpstring("Get the canonical name for the size")
#define SZ_HELPTHSZ_PUTNAME                         helpstring("Set the canonical name for the size")
#define SZ_HELPTHSZ_GETSYSMETCOLOR                  helpstring("Get the specified SystemMetric color")
#define SZ_HELPTHSZ_PUTSYSMETCOLOR                  helpstring("Set the specified SystemMetric color")
#define SZ_HELPTHSZ_GETSYSMETFONT                   helpstring("Get the specified SystemMetric font")
#define SZ_HELPTHSZ_PUTSYSMETFONT                   helpstring("Set the specified SystemMetric font")
#define SZ_HELPTHSZ_GETSYSMETSIZE                   helpstring("Get the specified SystemMetric size")
#define SZ_HELPTHSZ_PUTSYSMETSIZE                   helpstring("Set the specified SystemMetric size")
#define SZ_HELPTHSZ_WEBVIEWCSS                      helpstring("Get the webview CSS file.")
#define SZ_HELPTHSZ_GETCONTRASTLVL                  helpstring("Get the scheme's contrast level.")
#define SZ_HELPTHSZ_PUTCONTRASTLVL                  helpstring("Set the scheme's contrast level.")
#define SZ_HELPTHPV_UPDATE                          helpstring("Update the preview based on changes")
#define SZ_HELPTHPV_CREATEPREVIEW                   helpstring("Create the preview window")

#define _THEMEIDLID_H_
#endif // _THEMEIDLID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\tmschema.h ===
//-----------------------------------------------------------------
//   TmSchema.h - Theme Manager schema (properties, parts, etc)
//-----------------------------------------------------------------
//   Note: this file is normally #include-ed twice a single .cpp 
//         file.  The 2nd time, SCHEME_STRINGS should be defined.  
//         This allows the enums and strings to be kept in a 
//         single logical table and ensure they stay in sync with
//         each other.
//-----------------------------------------------------------------
#if (defined(SCHEMA_STRINGS)) || (! defined(TMSCHEMA_H))
//-----------------------------------------------------------------
#define TMSCHEMA_H
//-----------------------------------------------------------------
#include "SchemaDef.h"
//-----------------------------------------------------------------
#define THEMEMGR_VERSION 1  // increment if order of props changes or 
                            // any props are deleted (will prevent loading
                            // of controlsets that use older version
//-----------------------------------------------------------------
BEGIN_TM_SCHEMA(ThemeMgrSchema)

//-----------------------------------------------------------------
//   TM_ENUM (must also be declared in PROPERTIES section)
//
//    these cannot be renumbered (part of uxtheme API)
//-----------------------------------------------------------------
BEGIN_TM_ENUM(BGTYPE)
    TM_ENUM(0, BT, IMAGEFILE)
    TM_ENUM(1, BT, BORDERFILL)
    TM_ENUM(2, BT, NONE)
END_TM_ENUM()

BEGIN_TM_ENUM(IMAGELAYOUT)
    TM_ENUM(0, IL, VERTICAL)
    TM_ENUM(1, IL, HORIZONTAL)
END_TM_ENUM()

BEGIN_TM_ENUM(BORDERTYPE)
    TM_ENUM(0, BT, RECT)
    TM_ENUM(1, BT, ROUNDRECT)
    TM_ENUM(2, BT, ELLIPSE)
END_TM_ENUM()

BEGIN_TM_ENUM(FILLTYPE)
    TM_ENUM(0, FT, SOLID)
    TM_ENUM(1, FT, VERTGRADIENT)
    TM_ENUM(2, FT, HORZGRADIENT)
    TM_ENUM(3, FT, RADIALGRADIENT)
    TM_ENUM(4, FT, TILEIMAGE)
END_TM_ENUM()

BEGIN_TM_ENUM(SIZINGTYPE)
    TM_ENUM(0, ST, TRUESIZE)
    TM_ENUM(1, ST, STRETCH)
    TM_ENUM(2, ST, TILE)
END_TM_ENUM()

BEGIN_TM_ENUM(HALIGN)
    TM_ENUM(0, HA, LEFT)
    TM_ENUM(1, HA, CENTER)
    TM_ENUM(2, HA, RIGHT)
END_TM_ENUM()

BEGIN_TM_ENUM(CONTENTALIGNMENT)
    TM_ENUM(0, CA, LEFT)
    TM_ENUM(1, CA, CENTER)
    TM_ENUM(2, CA, RIGHT)
END_TM_ENUM()

BEGIN_TM_ENUM(VALIGN)
    TM_ENUM(0, VA, TOP)
    TM_ENUM(1, VA, CENTER)
    TM_ENUM(2, VA, BOTTOM)
END_TM_ENUM()

BEGIN_TM_ENUM(OFFSETTYPE)
    TM_ENUM(0, OT, TOPLEFT)
    TM_ENUM(1, OT, TOPRIGHT)
    TM_ENUM(2, OT, TOPMIDDLE)
    TM_ENUM(3, OT, BOTTOMLEFT)
    TM_ENUM(4, OT, BOTTOMRIGHT)
    TM_ENUM(5, OT, BOTTOMMIDDLE)
    TM_ENUM(6, OT, MIDDLELEFT)
    TM_ENUM(7, OT, MIDDLERIGHT)
    TM_ENUM(8, OT, LEFTOFCAPTION)
    TM_ENUM(9, OT, RIGHTOFCAPTION)
    TM_ENUM(10, OT, LEFTOFLASTBUTTON)
    TM_ENUM(11, OT, RIGHTOFLASTBUTTON)
    TM_ENUM(12, OT, ABOVELASTBUTTON)
    TM_ENUM(13, OT, BELOWLASTBUTTON)
END_TM_ENUM()

BEGIN_TM_ENUM(ICONEFFECT)
    TM_ENUM(0, ICE, NONE)
    TM_ENUM(1, ICE, GLOW)
    TM_ENUM(2, ICE, SHADOW)
    TM_ENUM(3, ICE, PULSE)
    TM_ENUM(4, ICE, ALPHA)
END_TM_ENUM()

BEGIN_TM_ENUM(TEXTSHADOWTYPE)
    TM_ENUM(0, TST, NONE)
    TM_ENUM(1, TST, SINGLE)
    TM_ENUM(2, TST, CONTINUOUS)
END_TM_ENUM()

BEGIN_TM_ENUM(GLYPHTYPE)
    TM_ENUM(0, GT, NONE)
    TM_ENUM(1, GT, IMAGEGLYPH)
    TM_ENUM(2, GT, FONTGLYPH)
END_TM_ENUM()

BEGIN_TM_ENUM(IMAGESELECTTYPE)
    TM_ENUM(0, IST, NONE)
    TM_ENUM(1, IST, SIZE)
    TM_ENUM(2, IST, DPI)
END_TM_ENUM()

BEGIN_TM_ENUM(TRUESIZESCALINGTYPE)
    TM_ENUM(0, TSST, NONE)
    TM_ENUM(1, TSST, SIZE)
    TM_ENUM(2, TSST, DPI)
END_TM_ENUM()

BEGIN_TM_ENUM(GLYPHFONTSIZINGTYPE)
    TM_ENUM(0, GFST, NONE)
    TM_ENUM(1, GFST, SIZE)
    TM_ENUM(2, GFST, DPI)
END_TM_ENUM()

//-----------------------------------------------------------------
//    PROPERTIES - used by uxtheme rendering and controls
//      
//    these cannot be renumbered (part of uxtheme API)
//-----------------------------------------------------------------
BEGIN_TM_PROPS()

    //---- primitive types ----
    TM_PROP(201, TMT, STRING,    STRING)
    TM_PROP(202, TMT, INT,       INT)
    TM_PROP(203, TMT, BOOL,      BOOL)
    TM_PROP(204, TMT, COLOR,     COLOR)
    TM_PROP(205, TMT, MARGINS,   MARGINS)
    TM_PROP(206, TMT, FILENAME,  FILENAME)
    TM_PROP(207, TMT, SIZE,      SIZE)
    TM_PROP(208, TMT, POSITION,  POSITION)
    TM_PROP(209, TMT, RECT,      RECT)
    TM_PROP(210, TMT, FONT,      FONT)
    TM_PROP(211, TMT, INTLIST,   INTLIST)

    //---- special misc. properties ----
    TM_PROP(401, TMT, COLORSCHEMES,   STRING)
    TM_PROP(402, TMT, SIZES,          STRING)
    TM_PROP(403, TMT, CHARSET,        INT)

    //---- [documentation] properties ----

#define TMT_FIRST_RCSTRING_NAME   TMT_DISPLAYNAME
#define TMT_LAST_RCSTRING_NAME    TMT_DESCRIPTION

    TM_PROP(601, TMT, DISPLAYNAME,    STRING)
    TM_PROP(602, TMT, TOOLTIP,        STRING)
    TM_PROP(603, TMT, COMPANY,        STRING)
    TM_PROP(604, TMT, AUTHOR,         STRING)
    TM_PROP(605, TMT, COPYRIGHT,      STRING)
    TM_PROP(606, TMT, URL,            STRING)
    TM_PROP(607, TMT, VERSION,        STRING)
    TM_PROP(608, TMT, DESCRIPTION,    STRING)

    //---- theme metrics: fonts ----

#define TMT_FIRSTFONT TMT_CAPTIONFONT
#define TMT_LASTFONT  TMT_ICONTITLEFONT

    TM_PROP(801, TMT, CAPTIONFONT,        FONT)
    TM_PROP(802, TMT, SMALLCAPTIONFONT,   FONT)
    TM_PROP(803, TMT, MENUFONT,           FONT)
    TM_PROP(804, TMT, STATUSFONT,         FONT)
    TM_PROP(805, TMT, MSGBOXFONT,         FONT)
    TM_PROP(806, TMT, ICONTITLEFONT,      FONT)

    //---- theme metrics: bools ----

#define TMT_FIRSTBOOL   TMT_FLATMENUS
#define TMT_LASTBOOL    TMT_FLATMENUS

    TM_PROP(1001, TMT, FLATMENUS,            BOOL)

    //---- theme metrics: sizes ----

#define TMT_FIRSTSIZE   TMT_SIZINGBORDERWIDTH
#define TMT_LASTSIZE    TMT_MENUBARHEIGHT

    TM_PROP(1201, TMT, SIZINGBORDERWIDTH,    SIZE)
    TM_PROP(1202, TMT, SCROLLBARWIDTH,       SIZE)
    TM_PROP(1203, TMT, SCROLLBARHEIGHT,      SIZE)
    TM_PROP(1204, TMT, CAPTIONBARWIDTH,      SIZE)
    TM_PROP(1205, TMT, CAPTIONBARHEIGHT,     SIZE)
    TM_PROP(1206, TMT, SMCAPTIONBARWIDTH,    SIZE)
    TM_PROP(1207, TMT, SMCAPTIONBARHEIGHT,   SIZE)
    TM_PROP(1208, TMT, MENUBARWIDTH,         SIZE)
    TM_PROP(1209, TMT, MENUBARHEIGHT,        SIZE)

    //---- theme metrics: ints ----

#define TMT_FIRSTINT   TMT_MINCOLORDEPTH
#define TMT_LASTINT    TMT_MINCOLORDEPTH

    TM_PROP(1301, TMT, MINCOLORDEPTH,     INT)

    //---- theme metrics: strings ----

#define TMT_FIRSTSTRING   TMT_CSSNAME
#define TMT_LASTSTRING    TMT_XMLNAME

    TM_PROP(1401, TMT, CSSNAME,            STRING)
    TM_PROP(1402, TMT, XMLNAME,            STRING)

    //---- theme metrics: colors ----

#define TMT_FIRSTCOLOR  TMT_SCROLLBAR
#define TMT_LASTCOLOR   TMT_MENUBAR

    TM_PROP(1601, TMT, SCROLLBAR,          COLOR)
    TM_PROP(1602, TMT, BACKGROUND,         COLOR)
    TM_PROP(1603, TMT, ACTIVECAPTION,      COLOR)
    TM_PROP(1604, TMT, INACTIVECAPTION,    COLOR)
    TM_PROP(1605, TMT, MENU,               COLOR)
    TM_PROP(1606, TMT, WINDOW,             COLOR)
    TM_PROP(1607, TMT, WINDOWFRAME,        COLOR)
    TM_PROP(1608, TMT, MENUTEXT,           COLOR)
    TM_PROP(1609, TMT, WINDOWTEXT,         COLOR)
    TM_PROP(1610, TMT, CAPTIONTEXT,        COLOR)
    TM_PROP(1611, TMT, ACTIVEBORDER,       COLOR)
    TM_PROP(1612, TMT, INACTIVEBORDER,     COLOR)
    TM_PROP(1613, TMT, APPWORKSPACE,       COLOR)
    TM_PROP(1614, TMT, HIGHLIGHT,          COLOR)
    TM_PROP(1615, TMT, HIGHLIGHTTEXT,      COLOR)
    TM_PROP(1616, TMT, BTNFACE,            COLOR)
    TM_PROP(1617, TMT, BTNSHADOW,          COLOR)
    TM_PROP(1618, TMT, GRAYTEXT,           COLOR)
    TM_PROP(1619, TMT, BTNTEXT,            COLOR)
    TM_PROP(1620, TMT, INACTIVECAPTIONTEXT,     COLOR)
    TM_PROP(1621, TMT, BTNHIGHLIGHT,            COLOR)
    TM_PROP(1622, TMT, DKSHADOW3D,              COLOR)
    TM_PROP(1623, TMT, LIGHT3D,                 COLOR)
    TM_PROP(1624, TMT, INFOTEXT,                COLOR)
    TM_PROP(1625, TMT, INFOBK,                  COLOR)
    TM_PROP(1626, TMT, BUTTONALTERNATEFACE,     COLOR)
    TM_PROP(1627, TMT, HOTTRACKING,             COLOR)
    TM_PROP(1628, TMT, GRADIENTACTIVECAPTION,   COLOR)
    TM_PROP(1629, TMT, GRADIENTINACTIVECAPTION, COLOR)
    TM_PROP(1630, TMT, MENUHILIGHT,             COLOR)
    TM_PROP(1631, TMT, MENUBAR,                 COLOR)

    //---- hue substitutions ----
    TM_PROP(1801, TMT, FROMHUE1,  INT)
    TM_PROP(1802, TMT, FROMHUE2,  INT)
    TM_PROP(1803, TMT, FROMHUE3,  INT)
    TM_PROP(1804, TMT, FROMHUE4,  INT)
    TM_PROP(1805, TMT, FROMHUE5,  INT)
    TM_PROP(1806, TMT, TOHUE1,    INT)
    TM_PROP(1807, TMT, TOHUE2,    INT)
    TM_PROP(1808, TMT, TOHUE3,    INT)
    TM_PROP(1809, TMT, TOHUE4,    INT)
    TM_PROP(1810, TMT, TOHUE5,    INT)

    //---- color substitutions ----
    TM_PROP(2001, TMT, FROMCOLOR1,  COLOR)
    TM_PROP(2002, TMT, FROMCOLOR2,  COLOR)
    TM_PROP(2003, TMT, FROMCOLOR3,  COLOR)
    TM_PROP(2004, TMT, FROMCOLOR4,  COLOR)
    TM_PROP(2005, TMT, FROMCOLOR5,  COLOR)
    TM_PROP(2006, TMT, TOCOLOR1,    COLOR)
    TM_PROP(2007, TMT, TOCOLOR2,    COLOR)
    TM_PROP(2008, TMT, TOCOLOR3,    COLOR)
    TM_PROP(2009, TMT, TOCOLOR4,    COLOR)
    TM_PROP(2010, TMT, TOCOLOR5,    COLOR)

    //---- rendering BOOL properties ----
    TM_PROP(2201, TMT, TRANSPARENT,   BOOL)       // image has transparent areas (see TransparentColor)
    TM_PROP(2202, TMT, AUTOSIZE,      BOOL)       // if TRUE, nonclient caption width varies with text extent
    TM_PROP(2203, TMT, BORDERONLY,    BOOL)       // only draw the border area of the image
    TM_PROP(2204, TMT, COMPOSITED,    BOOL)       // control will handle the composite drawing
    TM_PROP(2205, TMT, BGFILL,        BOOL)       // if TRUE, TRUESIZE images should be drawn on bg fill
    TM_PROP(2206, TMT, GLYPHTRANSPARENT,  BOOL)   // glyph has transparent areas (see GlyphTransparentColor)
    TM_PROP(2207, TMT, GLYPHONLY,         BOOL)   // only draw glyph (not background)
    TM_PROP(2208, TMT, ALWAYSSHOWSIZINGBAR, BOOL)
    TM_PROP(2209, TMT, MIRRORIMAGE,         BOOL) // default=TRUE means image gets mirrored in RTL (Mirror) windows
    TM_PROP(2210, TMT, UNIFORMSIZING,       BOOL) // if TRUE, height & width must be uniformly sized 
    TM_PROP(2211, TMT, INTEGRALSIZING,      BOOL) // for TRUESIZE and Border sizing; if TRUE, factor must be integer
    TM_PROP(2212, TMT, SOURCEGROW,          BOOL) // if TRUE, will scale up src image when needed
    TM_PROP(2213, TMT, SOURCESHRINK,        BOOL) // if TRUE, will scale down src image when needed

    //---- rendering INT properties ----
    TM_PROP(2401, TMT, IMAGECOUNT,        INT)    // the number of state images in an imagefile
    TM_PROP(2402, TMT, ALPHALEVEL,        INT)    // (0-255) alpha value for an icon (DrawThemeIcon part)
    TM_PROP(2403, TMT, BORDERSIZE,        INT)    // the size of the border line for bgtype=BorderFill
    TM_PROP(2404, TMT, ROUNDCORNERWIDTH,  INT)    // (0-100) % of roundness for rounded rects
    TM_PROP(2405, TMT, ROUNDCORNERHEIGHT, INT)    // (0-100) % of roundness for rounded rects
    TM_PROP(2406, TMT, GRADIENTRATIO1,    INT)    // (0-255) - amt of gradient color 1 to use (all must total=255)
    TM_PROP(2407, TMT, GRADIENTRATIO2,    INT)    // (0-255) - amt of gradient color 2 to use (all must total=255)
    TM_PROP(2408, TMT, GRADIENTRATIO3,    INT)    // (0-255) - amt of gradient color 3 to use (all must total=255)
    TM_PROP(2409, TMT, GRADIENTRATIO4,    INT)    // (0-255) - amt of gradient color 4 to use (all must total=255)
    TM_PROP(2410, TMT, GRADIENTRATIO5,    INT)    // (0-255) - amt of gradient color 5 to use (all must total=255)
    TM_PROP(2411, TMT, PROGRESSCHUNKSIZE, INT)    // size of progress control chunks
    TM_PROP(2412, TMT, PROGRESSSPACESIZE, INT)    // size of progress control spaces
    TM_PROP(2413, TMT, SATURATION,        INT)    // (0-255) amt of saturation for DrawThemeIcon() part
    TM_PROP(2414, TMT, TEXTBORDERSIZE,    INT)    // size of border around text chars
    TM_PROP(2415, TMT, ALPHATHRESHOLD,    INT)    // (0-255) the min. alpha value of a pixel that is solid
    TM_PROP(2416, TMT, WIDTH,             SIZE)   // custom window prop: size of part (min. window)
    TM_PROP(2417, TMT, HEIGHT,            SIZE)   // custom window prop: size of part (min. window)
    TM_PROP(2418, TMT, GLYPHINDEX,        INT)    // for font-based glyphs, the char index into the font
    TM_PROP(2419, TMT, TRUESIZESTRETCHMARK, INT)  // stretch TrueSize image when target exceeds source by this percent
    TM_PROP(2420, TMT, MINDPI1,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2421, TMT, MINDPI2,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2422, TMT, MINDPI3,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2423, TMT, MINDPI4,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2424, TMT, MINDPI5,         INT)      // min DPI ImageFile1 was designed for

    //---- rendering FONT properties ----
    TM_PROP(2601, TMT, GLYPHFONT,         FONT)   // the font that the glyph is drawn with

    //---- rendering INTLIST properties ----
    // start with 2801
                                                // (from smallest to largest)
    //---- rendering FILENAME properties ----
    TM_PROP(3001, TMT, IMAGEFILE,         FILENAME)   // the filename of the image (or basename, for mult. images)
    TM_PROP(3002, TMT, IMAGEFILE1,        FILENAME)   // multiresolution image file
    TM_PROP(3003, TMT, IMAGEFILE2,        FILENAME)   // multiresolution image file
    TM_PROP(3004, TMT, IMAGEFILE3,        FILENAME)   // multiresolution image file
    TM_PROP(3005, TMT, IMAGEFILE4,        FILENAME)   // multiresolution image file
    TM_PROP(3006, TMT, IMAGEFILE5,        FILENAME)   // multiresolution image file
    TM_PROP(3007, TMT, STOCKIMAGEFILE,    FILENAME)   // These are the only images that you can call GetThemeBitmap on
    TM_PROP(3008, TMT, GLYPHIMAGEFILE,    FILENAME)   // the filename for the glyph image

    //---- rendering STRING properties ----
    TM_PROP(3201, TMT, TEXT,              STRING)

    //---- rendering POSITION (x and y values) properties ----
    TM_PROP(3401, TMT, OFFSET,            POSITION)   // for window part layout
    TM_PROP(3402, TMT, TEXTSHADOWOFFSET,  POSITION)   // where char shadows are drawn, relative to orig. chars
    TM_PROP(3403, TMT, MINSIZE,           POSITION)   // min dest rect than ImageFile was designed for
    TM_PROP(3404, TMT, MINSIZE1,          POSITION)   // min dest rect than ImageFile1 was designed for
    TM_PROP(3405, TMT, MINSIZE2,          POSITION)   // min dest rect than ImageFile2 was designed for
    TM_PROP(3406, TMT, MINSIZE3,          POSITION)   // min dest rect than ImageFile3 was designed for
    TM_PROP(3407, TMT, MINSIZE4,          POSITION)   // min dest rect than ImageFile4 was designed for
    TM_PROP(3408, TMT, MINSIZE5,          POSITION)   // min dest rect than ImageFile5 was designed for
    TM_PROP(3409, TMT, NORMALSIZE,        POSITION)   // size of dest rect that exactly source

    //---- rendering MARGIN properties ----
    TM_PROP(3601, TMT, SIZINGMARGINS,     MARGINS)    // margins used for 9-grid sizing
    TM_PROP(3602, TMT, CONTENTMARGINS,    MARGINS)    // margins that define where content can be placed
    TM_PROP(3603, TMT, CAPTIONMARGINS,    MARGINS)    // margins that define where caption text can be placed

    //---- rendering COLOR properties ----
    TM_PROP(3801, TMT, BORDERCOLOR,      COLOR)       // color of borders for BorderFill 
    TM_PROP(3802, TMT, FILLCOLOR,        COLOR)       // color of bg fill 
    TM_PROP(3803, TMT, TEXTCOLOR,        COLOR)       // color text is drawn in
    TM_PROP(3804, TMT, EDGELIGHTCOLOR,     COLOR)     // edge color
    TM_PROP(3805, TMT, EDGEHIGHLIGHTCOLOR, COLOR)     // edge color
    TM_PROP(3806, TMT, EDGESHADOWCOLOR,    COLOR)     // edge color
    TM_PROP(3807, TMT, EDGEDKSHADOWCOLOR,  COLOR)     // edge color
    TM_PROP(3808, TMT, EDGEFILLCOLOR,  COLOR)         // edge color
    TM_PROP(3809, TMT, TRANSPARENTCOLOR, COLOR)       // color of pixels that are treated as transparent (not drawn)
    TM_PROP(3810, TMT, GRADIENTCOLOR1,   COLOR)       // first color in gradient
    TM_PROP(3811, TMT, GRADIENTCOLOR2,   COLOR)       // second color in gradient
    TM_PROP(3812, TMT, GRADIENTCOLOR3,   COLOR)       // third color in gradient
    TM_PROP(3813, TMT, GRADIENTCOLOR4,   COLOR)       // forth color in gradient
    TM_PROP(3814, TMT, GRADIENTCOLOR5,   COLOR)       // fifth color in gradient
    TM_PROP(3815, TMT, SHADOWCOLOR,      COLOR)       // color of text shadow
    TM_PROP(3816, TMT, GLOWCOLOR,        COLOR)       // color of glow produced by DrawThemeIcon
    TM_PROP(3817, TMT, TEXTBORDERCOLOR,  COLOR)       // color of text border
    TM_PROP(3818, TMT, TEXTSHADOWCOLOR,  COLOR)       // color of text shadow
    TM_PROP(3819, TMT, GLYPHTEXTCOLOR,        COLOR)  // color that font-based glyph is drawn with
    TM_PROP(3820, TMT, GLYPHTRANSPARENTCOLOR, COLOR)  // color of transparent pixels in GlyphImageFile
    TM_PROP(3821, TMT, FILLCOLORHINT, COLOR)          // hint about fill color used (for custom controls)
    TM_PROP(3822, TMT, BORDERCOLORHINT, COLOR)        // hint about border color used (for custom controls)
    TM_PROP(3823, TMT, ACCENTCOLORHINT, COLOR)        // hint about accent color used (for custom controls)

    //---- rendering enum properties (must be declared in TM_ENUM section above) ----
    TM_PROP(4001, TMT, BGTYPE,           ENUM)        // basic drawing type for each part
    TM_PROP(4002, TMT, BORDERTYPE,       ENUM)        // type of border for BorderFill parts
    TM_PROP(4003, TMT, FILLTYPE,         ENUM)        // fill shape for BorderFill parts
    TM_PROP(4004, TMT, SIZINGTYPE,       ENUM)        // how to size ImageFile parts
    TM_PROP(4005, TMT, HALIGN,           ENUM)        // horizontal alignment for TRUESIZE parts & glyphs
    TM_PROP(4006, TMT, CONTENTALIGNMENT, ENUM)        // custom window prop: how text is aligned in caption
    TM_PROP(4007, TMT, VALIGN,           ENUM)        // horizontal alignment for TRUESIZE parts & glyphs
    TM_PROP(4008, TMT, OFFSETTYPE,       ENUM)        // how window part should be placed
    TM_PROP(4009, TMT, ICONEFFECT,       ENUM)        // type of effect to use with DrawThemeIcon
    TM_PROP(4010, TMT, TEXTSHADOWTYPE,   ENUM)        // type of shadow to draw with text
    TM_PROP(4011, TMT, IMAGELAYOUT,      ENUM)        // how multiple images are arranged (horz. or vert.)
    TM_PROP(4012, TMT, GLYPHTYPE,             ENUM)   // controls type of glyph in imagefile objects
    TM_PROP(4013, TMT, IMAGESELECTTYPE,       ENUM)   // controls when to select from IMAGEFILE1...IMAGEFILE5
    TM_PROP(4014, TMT, GLYPHFONTSIZINGTYPE,   ENUM)   // controls when to select a bigger/small glyph font size
    TM_PROP(4015, TMT, TRUESIZESCALINGTYPE,   ENUM)   // controls how TrueSize image is scaled
    
    //---- custom properties (used only by controls/shell) ----
    TM_PROP(5001, TMT, USERPICTURE,           BOOL)
    TM_PROP(5002, TMT, DEFAULTPANESIZE,       RECT)
    TM_PROP(5003, TMT, BLENDCOLOR,            COLOR)

END_TM_PROPS()

//---------------------------------------------------------------------------------------
//   "Window" (i.e., non-client) Parts & States
//
//    these cannot be renumbered (part of uxtheme API)
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(WINDOW)
    TM_PART(1, WP, CAPTION)
    TM_PART(2, WP, SMALLCAPTION)
    TM_PART(3, WP, MINCAPTION)
    TM_PART(4, WP, SMALLMINCAPTION)
    TM_PART(5, WP, MAXCAPTION)
    TM_PART(6, WP, SMALLMAXCAPTION)
    TM_PART(7, WP, FRAMELEFT)
    TM_PART(8, WP, FRAMERIGHT)
    TM_PART(9, WP, FRAMEBOTTOM)
    TM_PART(10, WP, SMALLFRAMELEFT)
    TM_PART(11, WP, SMALLFRAMERIGHT)
    TM_PART(12, WP, SMALLFRAMEBOTTOM)
    //---- window frame buttons ----
    TM_PART(13, WP, SYSBUTTON)
    TM_PART(14, WP, MDISYSBUTTON)
    TM_PART(15, WP, MINBUTTON)
    TM_PART(16, WP, MDIMINBUTTON)
    TM_PART(17, WP, MAXBUTTON)
    TM_PART(18, WP, CLOSEBUTTON)
    TM_PART(19, WP, SMALLCLOSEBUTTON)
    TM_PART(20, WP, MDICLOSEBUTTON)
    TM_PART(21, WP, RESTOREBUTTON)
    TM_PART(22, WP, MDIRESTOREBUTTON)
    TM_PART(23, WP, HELPBUTTON)
    TM_PART(24, WP, MDIHELPBUTTON)
    //---- scrollbars 
    TM_PART(25, WP, HORZSCROLL)
    TM_PART(26, WP, HORZTHUMB)
    TM_PART(27, WP, VERTSCROLL)
    TM_PART(28, WP, VERTTHUMB)
    //---- dialog ----
    TM_PART(29, WP, DIALOG)
    //---- hit-test templates ---
    TM_PART(30, WP, CAPTIONSIZINGTEMPLATE)
    TM_PART(31, WP, SMALLCAPTIONSIZINGTEMPLATE)
    TM_PART(32, WP, FRAMELEFTSIZINGTEMPLATE)
    TM_PART(33, WP, SMALLFRAMELEFTSIZINGTEMPLATE)
    TM_PART(34, WP, FRAMERIGHTSIZINGTEMPLATE)
    TM_PART(35, WP, SMALLFRAMERIGHTSIZINGTEMPLATE)
    TM_PART(36, WP, FRAMEBOTTOMSIZINGTEMPLATE)
    TM_PART(37, WP, SMALLFRAMEBOTTOMSIZINGTEMPLATE)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(FRAME)
    TM_STATE(1, FS, ACTIVE)
    TM_STATE(2, FS, INACTIVE)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(CAPTION)
    TM_STATE(1, CS, ACTIVE)
    TM_STATE(2, CS, INACTIVE)
    TM_STATE(3, CS, DISABLED)
END_TM_PART_STATES()
    
BEGIN_TM_PART_STATES(MAXCAPTION)
    TM_STATE(1, MXCS, ACTIVE)
    TM_STATE(2, MXCS, INACTIVE)
    TM_STATE(3, MXCS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(MINCAPTION)
    TM_STATE(1, MNCS, ACTIVE)
    TM_STATE(2, MNCS, INACTIVE)
    TM_STATE(3, MNCS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HORZSCROLL)
    TM_STATE(1, HSS, NORMAL)
    TM_STATE(2, HSS, HOT)
    TM_STATE(3, HSS, PUSHED)
    TM_STATE(4, HSS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HORZTHUMB)
    TM_STATE(1, HTS, NORMAL)
    TM_STATE(2, HTS, HOT)
    TM_STATE(3, HTS, PUSHED)
    TM_STATE(4, HTS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(VERTSCROLL)
    TM_STATE(1, VSS, NORMAL)
    TM_STATE(2, VSS, HOT)
    TM_STATE(3, VSS, PUSHED)
    TM_STATE(4, VSS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(VERTTHUMB)
    TM_STATE(1, VTS, NORMAL)
    TM_STATE(2, VTS, HOT)
    TM_STATE(3, VTS, PUSHED)
    TM_STATE(4, VTS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SYSBUTTON)
    TM_STATE(1, SBS, NORMAL)
    TM_STATE(2, SBS, HOT)
    TM_STATE(3, SBS, PUSHED)
    TM_STATE(4, SBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(MINBUTTON)
    TM_STATE(1, MINBS, NORMAL)
    TM_STATE(2, MINBS, HOT)
    TM_STATE(3, MINBS, PUSHED)
    TM_STATE(4, MINBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(MAXBUTTON)
    TM_STATE(1, MAXBS, NORMAL)
    TM_STATE(2, MAXBS, HOT)
    TM_STATE(3, MAXBS, PUSHED)
    TM_STATE(4, MAXBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(RESTOREBUTTON)
    TM_STATE(1, RBS, NORMAL)
    TM_STATE(2, RBS, HOT)
    TM_STATE(3, RBS, PUSHED)
    TM_STATE(4, RBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HELPBUTTON)
    TM_STATE(1, HBS, NORMAL)
    TM_STATE(2, HBS, HOT)
    TM_STATE(3, HBS, PUSHED)
    TM_STATE(4, HBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(CLOSEBUTTON)
    TM_STATE(1, CBS, NORMAL)
    TM_STATE(2, CBS, HOT)
    TM_STATE(3, CBS, PUSHED)
    TM_STATE(4, CBS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Button" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(BUTTON)
    TM_PART(1, BP, PUSHBUTTON)
    TM_PART(2, BP, RADIOBUTTON)
    TM_PART(3, BP, CHECKBOX)
    TM_PART(4, BP, GROUPBOX)
    TM_PART(5, BP, USERBUTTON)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(PUSHBUTTON)
    TM_STATE(1, PBS, NORMAL)
    TM_STATE(2, PBS, HOT)
    TM_STATE(3, PBS, PRESSED)
    TM_STATE(4, PBS, DISABLED)
    TM_STATE(5, PBS, DEFAULTED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(RADIOBUTTON)
    TM_STATE(1, RBS, UNCHECKEDNORMAL)
    TM_STATE(2, RBS, UNCHECKEDHOT)
    TM_STATE(3, RBS, UNCHECKEDPRESSED)
    TM_STATE(4, RBS, UNCHECKEDDISABLED)
    TM_STATE(5, RBS, CHECKEDNORMAL)
    TM_STATE(6, RBS, CHECKEDHOT)
    TM_STATE(7, RBS, CHECKEDPRESSED)
    TM_STATE(8, RBS, CHECKEDDISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(CHECKBOX)
    TM_STATE(1, CBS, UNCHECKEDNORMAL)
    TM_STATE(2, CBS, UNCHECKEDHOT)
    TM_STATE(3, CBS, UNCHECKEDPRESSED)
    TM_STATE(4, CBS, UNCHECKEDDISABLED)
    TM_STATE(5, CBS, CHECKEDNORMAL)
    TM_STATE(6, CBS, CHECKEDHOT)
    TM_STATE(7, CBS, CHECKEDPRESSED)
    TM_STATE(8, CBS, CHECKEDDISABLED)
    TM_STATE(9, CBS, MIXEDNORMAL)
    TM_STATE(10, CBS, MIXEDHOT)
    TM_STATE(11, CBS, MIXEDPRESSED)
    TM_STATE(12, CBS, MIXEDDISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(GROUPBOX)
    TM_STATE(1, GBS, NORMAL)
    TM_STATE(2, GBS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Rebar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(REBAR)
    TM_PART(1, RP, GRIPPER)
    TM_PART(2, RP, GRIPPERVERT)
    TM_PART(3, RP, BAND)
    TM_PART(4, RP, CHEVRON)
    TM_PART(5, RP, CHEVRONVERT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(CHEVRON)
    TM_STATE(1, CHEVS, NORMAL)
    TM_STATE(2, CHEVS, HOT)
    TM_STATE(3, CHEVS, PRESSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Toolbar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TOOLBAR)
    TM_PART(1, TP, BUTTON)
    TM_PART(2, TP, DROPDOWNBUTTON)
    TM_PART(3, TP, SPLITBUTTON)
    TM_PART(4, TP, SPLITBUTTONDROPDOWN)
    TM_PART(5, TP, SEPARATOR)
    TM_PART(6, TP, SEPARATORVERT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TOOLBAR)
    TM_STATE(1, TS, NORMAL)
    TM_STATE(2, TS, HOT)
    TM_STATE(3, TS, PRESSED)
    TM_STATE(4, TS, DISABLED)
    TM_STATE(5, TS, CHECKED)
    TM_STATE(6, TS, HOTCHECKED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Status" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(STATUS)
    TM_PART(1, SP, PANE)
    TM_PART(2, SP, GRIPPERPANE)
    TM_PART(3, SP, GRIPPER)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "Menu" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(MENU)
    TM_PART(1, MP, MENUITEM)
    TM_PART(2, MP, MENUDROPDOWN)
    TM_PART(3, MP, MENUBARITEM)
    TM_PART(4, MP, MENUBARDROPDOWN)
    TM_PART(5, MP, CHEVRON)
    TM_PART(6, MP, SEPARATOR)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(MENU)
    TM_STATE(1, MS, NORMAL)
    TM_STATE(2, MS, SELECTED)
    TM_STATE(3, MS, DEMOTED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "ListView" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(LISTVIEW)
    TM_PART(1, LVP, LISTITEM)
    TM_PART(2, LVP, LISTGROUP)
    TM_PART(3, LVP, LISTDETAIL)
    TM_PART(4, LVP, LISTSORTEDDETAIL)
    TM_PART(5, LVP, EMPTYTEXT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(LISTITEM)
    TM_STATE(1, LIS, NORMAL)
    TM_STATE(2, LIS, HOT)
    TM_STATE(3, LIS, SELECTED)
    TM_STATE(4, LIS, DISABLED)
    TM_STATE(5, LIS, SELECTEDNOTFOCUS)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Header" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(HEADER)
    TM_PART(1, HP, HEADERITEM)
    TM_PART(2, HP, HEADERITEMLEFT)
    TM_PART(3, HP, HEADERITEMRIGHT)
    TM_PART(4, HP, HEADERSORTARROW)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(HEADERITEM)
    TM_STATE(1, HIS, NORMAL)
    TM_STATE(2, HIS, HOT)
    TM_STATE(3, HIS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERITEMLEFT)
    TM_STATE(1, HILS, NORMAL)
    TM_STATE(2, HILS, HOT)
    TM_STATE(3, HILS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERITEMRIGHT)
    TM_STATE(1, HIRS, NORMAL)
    TM_STATE(2, HIRS, HOT)
    TM_STATE(3, HIRS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERSORTARROW)
    TM_STATE(1, HSAS, SORTEDUP)
    TM_STATE(2, HSAS, SORTEDDOWN)
END_TM_PART_STATES()
//---------------------------------------------------------------------------------------
//   "Progress" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(PROGRESS)
    TM_PART(1, PP, BAR)
    TM_PART(2, PP, BARVERT)
    TM_PART(3, PP, CHUNK)
    TM_PART(4, PP, CHUNKVERT)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "Tab" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TAB)
    TM_PART(1, TABP, TABITEM)
    TM_PART(2, TABP, TABITEMLEFTEDGE)
    TM_PART(3, TABP, TABITEMRIGHTEDGE)
    TM_PART(4, TABP, TABITEMBOTHEDGE)
    TM_PART(5, TABP, TOPTABITEM)
    TM_PART(6, TABP, TOPTABITEMLEFTEDGE)
    TM_PART(7, TABP, TOPTABITEMRIGHTEDGE)
    TM_PART(8, TABP, TOPTABITEMBOTHEDGE)
    TM_PART(9, TABP, PANE)
    TM_PART(10, TABP, BODY)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TABITEM)
    TM_STATE(1, TIS, NORMAL)
    TM_STATE(2, TIS, HOT)
    TM_STATE(3, TIS, SELECTED)
    TM_STATE(4, TIS, DISABLED)
    TM_STATE(5, TIS, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TABITEMLEFTEDGE)
    TM_STATE(1, TILES, NORMAL)
    TM_STATE(2, TILES, HOT)
    TM_STATE(3, TILES, SELECTED)
    TM_STATE(4, TILES, DISABLED)
    TM_STATE(5, TILES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TABITEMRIGHTEDGE)
    TM_STATE(1, TIRES, NORMAL)
    TM_STATE(2, TIRES, HOT)
    TM_STATE(3, TIRES, SELECTED)
    TM_STATE(4, TIRES, DISABLED)
    TM_STATE(5, TIRES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TABITEMBOTHEDGES)
    TM_STATE(1, TIBES, NORMAL)
    TM_STATE(2, TIBES, HOT)
    TM_STATE(3, TIBES, SELECTED)
    TM_STATE(4, TIBES, DISABLED)
    TM_STATE(5, TIBES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEM)
    TM_STATE(1, TTIS, NORMAL)
    TM_STATE(2, TTIS, HOT)
    TM_STATE(3, TTIS, SELECTED)
    TM_STATE(4, TTIS, DISABLED)
    TM_STATE(5, TTIS, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEMLEFTEDGE)
    TM_STATE(1, TTILES, NORMAL)
    TM_STATE(2, TTILES, HOT)
    TM_STATE(3, TTILES, SELECTED)
    TM_STATE(4, TTILES, DISABLED)
    TM_STATE(5, TTILES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEMRIGHTEDGE)
    TM_STATE(1, TTIRES, NORMAL)
    TM_STATE(2, TTIRES, HOT)
    TM_STATE(3, TTIRES, SELECTED)
    TM_STATE(4, TTIRES, DISABLED)
    TM_STATE(5, TTIRES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEMBOTHEDGES)
    TM_STATE(1, TTIBES, NORMAL)
    TM_STATE(2, TTIBES, HOT)
    TM_STATE(3, TTIBES, SELECTED)
    TM_STATE(4, TTIBES, DISABLED)
    TM_STATE(5, TTIBES, FOCUSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Trackbar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TRACKBAR)
    TM_PART(1, TKP, TRACK)
    TM_PART(2, TKP, TRACKVERT)
    TM_PART(3, TKP, THUMB)
    TM_PART(4, TKP, THUMBBOTTOM)
    TM_PART(5, TKP, THUMBTOP)
    TM_PART(6, TKP, THUMBVERT)
    TM_PART(7, TKP, THUMBLEFT)
    TM_PART(8, TKP, THUMBRIGHT)
    TM_PART(9, TKP, TICS)
    TM_PART(10, TKP, TICSVERT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TRACKBAR)
    TM_STATE(1, TKS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TRACK)
    TM_STATE(1, TRS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TRACKVERT)
    TM_STATE(1, TRVS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMB)
    TM_STATE(1, TUS, NORMAL)
    TM_STATE(2, TUS, HOT)
    TM_STATE(3, TUS, PRESSED)
    TM_STATE(4, TUS, FOCUSED)
    TM_STATE(5, TUS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBBOTTOM)
    TM_STATE(1, TUBS, NORMAL)
    TM_STATE(2, TUBS, HOT)
    TM_STATE(3, TUBS, PRESSED)
    TM_STATE(4, TUBS, FOCUSED)
    TM_STATE(5, TUBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBTOP)
    TM_STATE(1, TUTS, NORMAL)
    TM_STATE(2, TUTS, HOT)
    TM_STATE(3, TUTS, PRESSED)
    TM_STATE(4, TUTS, FOCUSED)
    TM_STATE(5, TUTS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBVERT)
    TM_STATE(1, TUVS, NORMAL)
    TM_STATE(2, TUVS, HOT)
    TM_STATE(3, TUVS, PRESSED)
    TM_STATE(4, TUVS, FOCUSED)
    TM_STATE(5, TUVS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBLEFT)
    TM_STATE(1, TUVLS, NORMAL)
    TM_STATE(2, TUVLS, HOT)
    TM_STATE(3, TUVLS, PRESSED)
    TM_STATE(4, TUVLS, FOCUSED)
    TM_STATE(5, TUVLS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBRIGHT)
    TM_STATE(1, TUVRS, NORMAL)
    TM_STATE(2, TUVRS, HOT)
    TM_STATE(3, TUVRS, PRESSED)
    TM_STATE(4, TUVRS, FOCUSED)
    TM_STATE(5, TUVRS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TICS)
    TM_STATE(1, TSS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TICSVERT)
    TM_STATE(1, TSVS, NORMAL)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Tooltips" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TOOLTIP)
    TM_PART(1, TTP, STANDARD)
    TM_PART(2, TTP, STANDARDTITLE)
    TM_PART(3, TTP, BALLOON)
    TM_PART(4, TTP, BALLOONTITLE)
    TM_PART(5, TTP, CLOSE)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(CLOSE)
	TM_STATE(1, TTCS, NORMAL)
	TM_STATE(2, TTCS, HOT)
	TM_STATE(3, TTCS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(STANDARD)
	TM_STATE(1, TTSS, NORMAL)
	TM_STATE(2, TTSS, LINK)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(BALLOON)
	TM_STATE(1, TTBS, NORMAL)
	TM_STATE(2, TTBS, LINK)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "TreeView" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TREEVIEW)
    TM_PART(1, TVP, TREEITEM)
    TM_PART(2, TVP, GLYPH)
    TM_PART(3, TVP, BRANCH)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TREEITEM)
    TM_STATE(1, TREIS, NORMAL)
    TM_STATE(2, TREIS, HOT)
    TM_STATE(3, TREIS, SELECTED)
    TM_STATE(4, TREIS, DISABLED)
    TM_STATE(5, TREIS, SELECTEDNOTFOCUS)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(GLYPH)
    TM_STATE(1, GLPS, CLOSED)
    TM_STATE(2, GLPS, OPENED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Spin" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(SPIN)
    TM_PART(1, SPNP, UP)
    TM_PART(2, SPNP, DOWN)
    TM_PART(3, SPNP, UPHORZ)
    TM_PART(4, SPNP, DOWNHORZ)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(UP)
    TM_STATE(1, UPS, NORMAL)
    TM_STATE(2, UPS, HOT)
    TM_STATE(3, UPS, PRESSED)
    TM_STATE(4, UPS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(DOWN)
    TM_STATE(1, DNS, NORMAL)
    TM_STATE(2, DNS, HOT)
    TM_STATE(3, DNS, PRESSED)
    TM_STATE(4, DNS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(UPHORZ)
    TM_STATE(1, UPHZS, NORMAL)
    TM_STATE(2, UPHZS, HOT)
    TM_STATE(3, UPHZS, PRESSED)
    TM_STATE(4, UPHZS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(DOWNHORZ)
    TM_STATE(1, DNHZS, NORMAL)
    TM_STATE(2, DNHZS, HOT)
    TM_STATE(3, DNHZS, PRESSED)
    TM_STATE(4, DNHZS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Page" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(PAGE)
    TM_PART(1, PGRP, UP)
    TM_PART(2, PGRP, DOWN)
    TM_PART(3, PGRP, UPHORZ)
    TM_PART(4, PGRP, DOWNHORZ)
END_TM_CLASS_PARTS()

//--- Pager uses same states as Spin ---

//---------------------------------------------------------------------------------------
//   "Scrollbar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(SCROLLBAR)
    TM_PART(1, SBP, ARROWBTN)
    TM_PART(2, SBP, THUMBBTNHORZ)
    TM_PART(3, SBP, THUMBBTNVERT)
    TM_PART(4, SBP, LOWERTRACKHORZ)
    TM_PART(5, SBP, UPPERTRACKHORZ)
    TM_PART(6, SBP, LOWERTRACKVERT)
    TM_PART(7, SBP, UPPERTRACKVERT)
    TM_PART(8, SBP, GRIPPERHORZ)
    TM_PART(9, SBP, GRIPPERVERT)
    TM_PART(10, SBP, SIZEBOX)
END_TM_CLASS_PARTS()



BEGIN_TM_PART_STATES(ARROWBTN)
    TM_STATE(1, ABS, UPNORMAL)
    TM_STATE(2, ABS, UPHOT)
    TM_STATE(3, ABS, UPPRESSED)
    TM_STATE(4, ABS, UPDISABLED)
    TM_STATE(5, ABS, DOWNNORMAL)
    TM_STATE(6, ABS, DOWNHOT)
    TM_STATE(7, ABS, DOWNPRESSED)
    TM_STATE(8, ABS, DOWNDISABLED)
    TM_STATE(9, ABS, LEFTNORMAL)
    TM_STATE(10, ABS, LEFTHOT)
    TM_STATE(11, ABS, LEFTPRESSED)
    TM_STATE(12, ABS, LEFTDISABLED)
    TM_STATE(13, ABS, RIGHTNORMAL)
    TM_STATE(14, ABS, RIGHTHOT)
    TM_STATE(15, ABS, RIGHTPRESSED)
    TM_STATE(16, ABS, RIGHTDISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SCROLLBAR)
    TM_STATE(1, SCRBS, NORMAL)
    TM_STATE(2, SCRBS, HOT)
    TM_STATE(3, SCRBS, PRESSED)
    TM_STATE(4, SCRBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SIZEBOX)
    TM_STATE(1, SZB, RIGHTALIGN)
    TM_STATE(2, SZB, LEFTALIGN)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Edit" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(EDIT)
    TM_PART(1, EP, EDITTEXT)
    TM_PART(2, EP, CARET)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(EDITTEXT)
    TM_STATE(1, ETS, NORMAL)
    TM_STATE(2, ETS, HOT)
    TM_STATE(3, ETS, SELECTED)
    TM_STATE(4, ETS, DISABLED)
    TM_STATE(5, ETS, FOCUSED)
    TM_STATE(6, ETS, READONLY)
    TM_STATE(7, ETS, ASSIST)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "ComboBox" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(COMBOBOX)
    TM_PART(1, CP, DROPDOWNBUTTON)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(COMBOBOX)
    TM_STATE(1, CBXS, NORMAL)
    TM_STATE(2, CBXS, HOT)
    TM_STATE(3, CBXS, PRESSED)
    TM_STATE(4, CBXS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Taskbar Clock" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(CLOCK)
    TM_PART(1, CLP, TIME)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(CLOCK)
    TM_STATE(1, CLS, NORMAL)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Tray Notify" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TRAYNOTIFY)
    TM_PART(1, TNP, BACKGROUND)
    TM_PART(2, TNP, ANIMBACKGROUND)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "TaskBar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TASKBAR)
    TM_PART(1, TBP, BACKGROUNDBOTTOM)
    TM_PART(2, TBP, BACKGROUNDRIGHT)
    TM_PART(3, TBP, BACKGROUNDTOP)
    TM_PART(4, TBP, BACKGROUNDLEFT)
    TM_PART(5, TBP, SIZINGBARBOTTOM)
    TM_PART(6, TBP, SIZINGBARRIGHT)
    TM_PART(7, TBP, SIZINGBARTOP)
    TM_PART(8, TBP, SIZINGBARLEFT)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "TaskBand" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TASKBAND)
    TM_PART(1, TDP, GROUPCOUNT)
    TM_PART(2, TDP, FLASHBUTTON)
    TM_PART(3, TDP, FLASHBUTTONGROUPMENU)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "StartPanel" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(STARTPANEL)
    TM_PART(1, SPP, USERPANE)
    TM_PART(2, SPP, MOREPROGRAMS)
    TM_PART(3, SPP, MOREPROGRAMSARROW)
    TM_PART(4, SPP, PROGLIST)
    TM_PART(5, SPP, PROGLISTSEPARATOR)
    TM_PART(6, SPP, PLACESLIST)
    TM_PART(7, SPP, PLACESLISTSEPARATOR)
    TM_PART(8, SPP, LOGOFF)
    TM_PART(9, SPP, LOGOFFBUTTONS)
    TM_PART(10, SPP, USERPICTURE)
    TM_PART(11, SPP, PREVIEW)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(MOREPROGRAMSARROW)
    TM_STATE(1, SPS, NORMAL)
    TM_STATE(2, SPS, HOT)
    TM_STATE(3, SPS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(LOGOFFBUTTONS)
    TM_STATE(1, SPLS, NORMAL)
    TM_STATE(2, SPLS, HOT)
    TM_STATE(3, SPLS, PRESSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "ExplorerBar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(EXPLORERBAR)
    TM_PART(1, EBP, HEADERBACKGROUND)
    TM_PART(2, EBP, HEADERCLOSE)
    TM_PART(3, EBP, HEADERPIN)
    TM_PART(4, EBP, IEBARMENU)
    TM_PART(5, EBP, NORMALGROUPBACKGROUND)
    TM_PART(6, EBP, NORMALGROUPCOLLAPSE)
    TM_PART(7, EBP, NORMALGROUPEXPAND)
    TM_PART(8, EBP, NORMALGROUPHEAD)
    TM_PART(9, EBP, SPECIALGROUPBACKGROUND)
    TM_PART(10, EBP, SPECIALGROUPCOLLAPSE)
    TM_PART(11, EBP, SPECIALGROUPEXPAND)
    TM_PART(12, EBP, SPECIALGROUPHEAD)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(HEADERCLOSE)
    TM_STATE(1, EBHC, NORMAL)
    TM_STATE(2, EBHC, HOT)
    TM_STATE(3, EBHC, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERPIN)
    TM_STATE(1, EBHP, NORMAL)
    TM_STATE(2, EBHP, HOT)
    TM_STATE(3, EBHP, PRESSED)
    TM_STATE(4, EBHP, SELECTEDNORMAL)
    TM_STATE(5, EBHP, SELECTEDHOT)
    TM_STATE(6, EBHP, SELECTEDPRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(IEBARMENU)
    TM_STATE(1, EBM, NORMAL)
    TM_STATE(2, EBM, HOT)
    TM_STATE(3, EBM, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(NORMALGROUPCOLLAPSE)
    TM_STATE(1, EBNGC, NORMAL)
    TM_STATE(2, EBNGC, HOT)
    TM_STATE(3, EBNGC, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(NORMALGROUPEXPAND)
    TM_STATE(1, EBNGE, NORMAL)
    TM_STATE(2, EBNGE, HOT)
    TM_STATE(3, EBNGE, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SPECIALGROUPCOLLAPSE)
    TM_STATE(1, EBSGC, NORMAL)
    TM_STATE(2, EBSGC, HOT)
    TM_STATE(3, EBSGC, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SPECIALGROUPEXPAND)
    TM_STATE(1, EBSGE, NORMAL)
    TM_STATE(2, EBSGE, HOT)
    TM_STATE(3, EBSGE, PRESSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "TaskBand" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(MENUBAND)
    TM_PART(1, MDP, NEWAPPBUTTON)
    TM_PART(2, MDP, SEPERATOR)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(MENUBAND)
    TM_STATE(1, MDS, NORMAL)
    TM_STATE(2, MDS, HOT)
    TM_STATE(3, MDS, PRESSED)
    TM_STATE(4, MDS, DISABLED)
    TM_STATE(5, MDS, CHECKED)
    TM_STATE(6, MDS, HOTCHECKED)
END_TM_PART_STATES()
//---------------------------------------------------------------------------
END_TM_SCHEMA(ThemeMgrSchema)
//---------------------------------------------------------------------------
#endif      // TMSCHEMA_H
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\w95wraps.h ===
/*****************************************************************************\
*                                                                             *
* w95wraps.h - Unicode wrappers for ANSI functions on Win95                   *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

//
//  This file is for internal use only.  Do not put it in the SDK.
//

#ifndef _INC_W95WRAPS
#define _INC_W95WRAPS

// no wrappers are needed for non x86, since win9x only runs on x86!
#ifdef _X86_

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_W95WRAPS_UNITHUNK  Unicode wrapper functions
//    NO_W95WRAPS_TPS       Thread Pool Services
//    NO_W95WRAPS_MLUI      MLUI wrapper functions
//
//  You are expected to have done a #include <shlwapi.h> before including
//  this file.
//
// WARNING: you can't include shlwapi.h before this, as ATL templates
// require things like TranlsateAccelerator which, due to munging, get
// turned into TranslateAcceleratorWrapW at compile time.  So w95wraps.h
// pretty much needs to be included FIRST so all the interface definitions
// get munged too.
//#ifndef _INC_SHLWAPI
//#error "You must include shlwapi.h *before* w95wraps.h
//#endif

//=============== Unicode Wrapper Routines ===================================

#ifndef NO_W95WRAPS_UNITHUNK

//
//  If you #include this file, then calls to many UNICODE functions
//  are re-routed through wrapper functions in SHLWAPI which will
//  either call the UNICODE version (on NT) or thunk the parameters
//  to ANSI and call the ANSI version (on 9x).
//
//  Note that these wrapper functions must be used with care, because
//
//  *   They do not account for subtle differences between UNICODE and
//      ANSI versions of the same API.  Examples:
//
//      -   RegisterClassW register a UNICODE window class, whereas
//          RegisterClassA registers an ANSI window class.  Consequently,
//          if you use RegisterClassWrapW, your WNDPROC will receive
//          *ANSI* WM_SETTEXT messages on Windows 9x.
//
//      -   SetWindowLongW(GWL_WNDPROC) and CallWindowProcW behave
//          very differently from their ANSI counterparts.
//
//      -   DialogBoxW will send your dialog procedure UNICODE window
//          messages, whereas DialogBoxA will send ANSI window messages.
//
//      -   Anything that manipulates window messages or MSG structures
//          will be subtly affected by character set discrepancies.
//
//  *   Not all features of the underlying API are always supported,
//      or are supported with restrictions.  Examples:
//
//      -   DialogBoxWrapW does not support named dialog resources.
//
//      -   AppendMenuWrapW does not support bitmap or owner-draw
//          menu items.
//
//      -   FormatMessageWrapW does not support insertions.
//
//      -   If you use RegQueryValueExWrapW with a NULL output buffer to
//          query the size of a buffer, you must also pass *lpcbData = 0.
//
//      -   SendMessageWrapW requires that the window message not conflict
//          with messages used by any of the Windows common controls.
//

#define IsCharAlphaW                IsCharAlphaWrapW
#define IsCharUpperW                IsCharUpperWrapW
#define IsCharLowerW                IsCharLowerWrapW
#define IsCharAlphaNumericW         IsCharAlphaNumericWrapW

#define AppendMenuW                 AppendMenuWrapW
#define CallMsgFilterW              CallMsgFilterWrapW
#define CallWindowProcW             CallWindowProcWrapW
#define CharLowerW                  CharLowerWrapW
#define CharLowerBuffW              CharLowerBuffWrapW
#define CharNextW                   CharNextWrapW
#define CharPrevW                   CharPrevWrapW
#define CharToOemW                  CharToOemWrapW
#define CharUpperW                  CharUpperWrapW
#define CharUpperBuffW              CharUpperBuffWrapW
#define CompareStringW              CompareStringWrapW
#define CopyAcceleratorTableW       CopyAcceleratorTableWrapW
#define CreateAcceleratorTableW     CreateAcceleratorTableWrapW
#define CreateDCW                   CreateDCWrapW
#define CreateDirectoryW            CreateDirectoryWrapW
#define CreateEventW                CreateEventWrapW
#define CreateFileW                 CreateFileWrapW
#define CreateFontW                 CreateFontWrapW
#define CreateFontIndirectW         CreateFontIndirectWrapW
#define CreateMetaFileW             CreateMetaFileWrapW
#define CreateMutexW                CreateMutexWrapW
#define CreateICW                   CreateICWrapW
#define CreateSemaphoreW            CreateSemaphoreWrapW
#define CreateWindowExW             CreateWindowExWrapW
#define GetFileVersionInfoSizeW     GetFileVersionInfoSizeWrapW
#define GetFileVersionInfoW         GetFileVersionInfoWrapW
#define lstrcmpiW                   StrCmpIW
#define lstrcmpW                    StrCmpW
#define VerQueryValueW              VerQueryValueWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define DefWindowProcW              DefWindowProcWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define DeleteFileW                 DeleteFileWrapW
#define DispatchMessageW            DispatchMessageWrapW
#define DragQueryFileW              DragQueryFileWrapW
#define DrawTextExW                 DrawTextExWrapW
#define DrawTextW                   DrawTextWrapW
#define EnumFontFamiliesW           EnumFontFamiliesWrapW
#define EnumFontFamiliesExW         EnumFontFamiliesExWrapW
#define EnumResourceNamesW          EnumResourceNamesWrapW
#define ExpandEnvironmentStringsW   ExpandEnvironmentStringsWrapW
#define ExtractIconExW              ExtractIconExWrapW
#define ExtTextOutW                 ExtTextOutWrapW
#define FindFirstFileW              FindFirstFileWrapW
#define FindResourceW               FindResourceWrapW
#define FindNextFileW               FindNextFileWrapW
#define FindWindowW                 FindWindowWrapW
#define FindWindowExW               FindWindowExWrapW
#define FormatMessageW              FormatMessageWrapW
#ifndef NO_W95_GETCLASSINFO_WRAPS
// #define NO_W95_GETCLASSINFO_WRAPS if one of the objects uses IProvideClassInfo which has a GetClassInfo method.
#define GetClassInfoW               GetClassInfoWrapW
#define GetClassInfoExW             GetClassInfoExWrapW
#endif  // NO_W95_GETCLASSINFO_WRAPS
#define GetClassLongW               GetClassLongWrapW
#define GetClassNameW               GetClassNameWrapW
#define GetClipboardFormatNameW     GetClipboardFormatNameWrapW
#define GetCurrentDirectoryW        GetCurrentDirectoryWrapW
#define GetDlgItemTextW             GetDlgItemTextWrapW
#define GetFileAttributesW          GetFileAttributesWrapW
#define GetFullPathNameW            GetFullPathNameWrapW
#define GetLocaleInfoW              GetLocaleInfoWrapW
#define GetMenuItemInfoW            GetMenuItemInfoWrapW
#define GetMenuStringW              GetMenuStringWrapW
#define GetMessageW                 GetMessageWrapW
#define GetModuleFileNameW          GetModuleFileNameWrapW
#define GetNumberFormatW            GetNumberFormatWrapW
#define GetSystemDirectoryW         GetSystemDirectoryWrapW
#define GetModuleHandleW            GetModuleHandleWrapW
#define GetObjectW                  GetObjectWrapW
#define GetPrivateProfileIntW       GetPrivateProfileIntWrapW
#define GetPrivateProfileStringW    GetPrivateProfileStringWrapW
#define GetProfileStringW           GetProfileStringWrapW
#define GetPropW                    GetPropWrapW
#define GlobalAddAtomW              GlobalAddAtomWrapW
#define GlobalFindAtomW             GlobalFindAtomWrapW
#define GetShortPathNameW           GetShortPathNameWrapW
#define GetLongPathNameW            GetLongPathNameWrapW
#define GetLongPathNameA            GetLongPathNameWrapA
#define GetStringTypeExW            GetStringTypeExWrapW
#define GetTempFileNameW            GetTempFileNameWrapW
#define GetTempPathW                GetTempPathWrapW
#define GetTextExtentPoint32W       GetTextExtentPoint32WrapW
#define GetTextFaceW                GetTextFaceWrapW
#define GetTextMetricsW             GetTextMetricsWrapW
#define GetTimeFormatW              GetTimeFormatWrapW
#define GetDateFormatW              GetDateFormatWrapW
#define GetUserNameW                GetUserNameWrapW
#define GetWindowLongW              GetWindowLongWrapW
#define GetEnvironmentVariableW     GetEnvironmentVariableWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define GetWindowTextW              GetWindowTextWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define GetWindowTextLengthW        GetWindowTextLengthWrapW
#define GetWindowsDirectoryW        GetWindowsDirectoryWrapW
#define InsertMenuW                 InsertMenuWrapW
#define InsertMenuItemW             InsertMenuItemWrapW
#define IsBadStringPtrW             IsBadStringPtrWrapW
#define IsDialogMessageW            IsDialogMessageWrapW
#define LoadAcceleratorsW           LoadAcceleratorsWrapW
#define LoadBitmapW                 LoadBitmapWrapW
#define LoadCursorW                 LoadCursorWrapW
#define LoadIconW                   LoadIconWrapW
#define LoadImageW                  LoadImageWrapW
#define LoadLibraryW                LoadLibraryWrapW
#define LoadLibraryExW              LoadLibraryExWrapW
#define LoadMenuW                   LoadMenuWrapW
#define LoadStringW                 LoadStringWrapW
#define MessageBoxIndirectW         MessageBoxIndirectWrapW
#define MessageBoxW                 MessageBoxWrapW
#define ModifyMenuW                 ModifyMenuWrapW
#define GetCharWidth32W             GetCharWidth32WrapW
#define GetCharacterPlacementW      GetCharacterPlacementWrapW
#define CopyFileW                   CopyFileWrapW
#define MoveFileW                   MoveFileWrapW
#define OemToCharW                  OemToCharWrapW
#define OpenEventW                  OpenEventWrapW
#define OutputDebugStringW          OutputDebugStringWrapW
#define PeekMessageW                PeekMessageWrapW
#define PostMessageW                PostMessageWrapW
#define PostThreadMessageW          PostThreadMessageWrapW
#define RegCreateKeyW               RegCreateKeyWrapW
#define RegCreateKeyExW             RegCreateKeyExWrapW
#define RegDeleteKeyW               RegDeleteKeyWrapW
#define RegDeleteValueW             RegDeleteValueWrapW
#define RegEnumKeyW                 RegEnumKeyWrapW
#define RegEnumKeyExW               RegEnumKeyExWrapW
#define RegOpenKeyW                 RegOpenKeyWrapW
#define RegOpenKeyExW               RegOpenKeyExWrapW
#define RegQueryInfoKeyW            RegQueryInfoKeyWrapW
#define RegQueryValueW              RegQueryValueWrapW
#define RegQueryValueExW            RegQueryValueExWrapW
#define RegSetValueW                RegSetValueWrapW
#define RegSetValueExW              RegSetValueExWrapW
#define RegisterClassW              RegisterClassWrapW
#define RegisterClassExW            RegisterClassExWrapW
#define RegisterClipboardFormatW    RegisterClipboardFormatWrapW
#define RegisterWindowMessageW      RegisterWindowMessageWrapW
#define RemoveDirectoryW            RemoveDirectoryWrapW
#define RemovePropW                 RemovePropWrapW
#define SearchPathW                 SearchPathWrapW
#define SendDlgItemMessageW         SendDlgItemMessageWrapW
#define SendMessageW                SendMessageWrapW
#define SendMessageTimeoutW         SendMessageTimeoutWrapW
#define SetCurrentDirectoryW        SetCurrentDirectoryWrapW
#define SetDlgItemTextW             SetDlgItemTextWrapW
#define SetMenuItemInfoW            SetMenuItemInfoWrapW
#define SetPropW                    SetPropWrapW
#define SetFileAttributesW          SetFileAttributesWrapW
#define SetWindowLongW              SetWindowLongWrapW

#ifndef NO_W95_SHELL32_WRAPS
#define ExtractIconW                ExtractIconWrapW
#define SHGetFileInfoW              SHGetFileInfoWrapW
#define SHBrowseForFolderW          SHBrowseForFolderWrapW
#define ShellExecuteExW             ShellExecuteExWrapW
#define SHFileOperationW            SHFileOperationWrapW
#define SHGetNewLinkInfoW           SHGetNewLinkInfoWrapW
#define SHDefExtractIconW           SHDefExtractIconWrapW
#define SHChangeNotify              SHChangeNotifyWrap
#define SHFlushSFCache              SHFlushSFCacheWrap
#define SHGetPathFromIDListW        SHGetPathFromIDListWrapW
#endif // NO_W95_SHELL32_WRAPS

#define GetUserNameW                GetUserNameWrapW
#define RegEnumValueW               RegEnumValueWrapW
#define WritePrivateProfileStructW  WritePrivateProfileStructWrapW
#define GetPrivateProfileStructW    GetPrivateProfileStructWrapW
#define CreateProcessW              CreateProcessWrapW
#define DdeInitializeW              DdeInitializeWrapW
#define DdeCreateStringHandleW      DdeCreateStringHandleWrapW
#define DdeQueryStringW             DdeQueryStringWrapW
#define GetSaveFileNameW            GetSaveFileNameWrapW
#define GetOpenFileNameW            GetOpenFileNameWrapW
#define PageSetupDlgW               PageSetupDlgWrapW
#define PrintDlgW                   PrintDlgWrapW
#define SetWindowsHookExW           SetWindowsHookExWrapW
#define SetWindowTextW              SetWindowTextWrapW
#define StartDocW                   StartDocWrapW
#define CreateColorSpaceW           CreateColorSpaceWrapW
#define SystemParametersInfoW       SystemParametersInfoWrapW

#ifndef NO_W95_TRANSACCEL_WRAPS_TBS
// #define NO_W95_TRANSACCEL_WRAPS_TBS if one of the objects uses IOleInPlaceActiveObject which has a TranslateAccelerator method.
#define TranslateAcceleratorW       TranslateAcceleratorWrapW
#endif // NO_W95_TRANSACCEL_WRAPS_TBS

#define UnregisterClassW            UnregisterClassWrapW
#define VkKeyScanW                  VkKeyScanWrapW
#define WinHelpW                    WinHelpWrapW
#define WritePrivateProfileStringW  WritePrivateProfileStringWrapW
#define WNetRestoreConnectionW      WNetRestoreConnectionWrapW
#define WNetGetLastErrorW           WNetGetLastErrorWrapW

#endif // NO_W95WRAPS_UNITHUNK

#if !defined(NO_W95WRAPS_UNITHUNK) && !defined(NO_W95WRAPS_MLUI)

#define CreateDialogIndirectParamW  CreateDialogIndirectParamWrapW
#define CreateDialogParamW          CreateDialogParamWrapW
#define DialogBoxIndirectParamW     DialogBoxIndirectParamWrapW                 // UNICODE, ML
//#ifdef DialogBoxIndirectW
//#undef DialogBoxIndirectW
//#endif
//#define DialogBoxIndirectW(i,h,w,f) DialogBoxIndirectParamWrapW(i,h,w,f,d,0)    // UNICODE, ML
#define DialogBoxParamW             DialogBoxParamWrapW                         // UNICODE, ML
//#ifdef DialogBoxW
//#undef DialogBoxW
//#endif
//#define DialogBoxW(i,t,w,f)         DialogBoxParamWrapW(i,t,w,f,0)              // UNICODE, ML
#define ShellMessageBoxW            ShellMessageBoxWrapW

#define TrackPopupMenu              TrackPopupMenuWrap
#define TrackPopupMenuEx            TrackPopupMenuExWrap

#define DeleteMenu                  DeleteMenuWrap
#define DestroyMenu                 DestroyMenuWrap

#endif // !defined(NO_W95WRAPS_UNITHUNK) || !defined(NO_W95WRAPS_MLUI)


#if !defined(NO_OLE32_WRAPS)
#define CLSIDFromString             CLSIDFromStringWrap
#define CLSIDFromProgID             CLSIDFromProgIDWrap
#endif

#endif // _X86_

#endif // _INC_W95WRAPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\uxtheme.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : uxtheme.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEME_H_
#define _UXTHEME_H_
//---------------------------------------------------------------------------
#include <commctrl.h>
//---------------------------------------------------------------------------
//#if (_WIN32_WINNT >= 0x0500)     // only available on XP
//---------------------------------------------------------------------------
// Define API decoration for direct importing of DLL references.
#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define THEMEAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define THEMEAPI          STDAPI
#define THEMEAPI_(type)   STDAPI_(type)
#endif
#endif // THEMEAPI
//---------------------------------------------------------------------------
typedef HANDLE HTHEME;          // handle to a section of theme data for class

//---------------------------------------------------------------------------
// NOTE: PartId's and StateId's used in the theme API are defined in the 
//       hdr file <tmschema.h> using the TM_PART and TM_STATE macros.  For
//       example, "TM_PART(BP, PUSHBUTTON)" defines the PartId "BP_PUSHBUTTON".

//---------------------------------------------------------------------------
//  OpenThemeData()     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeData(HWND hwnd, LPCWSTR pszClassList);

//---------------------------------------------------------------------------
//  CloseTHemeData()    - closes the theme data handle.  This should be done 
//                        when the window being themed is destroyed or
//                        whenever a WM_THEMECHANGED msg is received 
//                        (followed by an attempt to create a new Theme data 
//                        handle).
//
//  hTheme              - open theme data handle (returned from prior call
//                        to OpenThemeData() API).
//---------------------------------------------------------------------------
THEMEAPI CloseThemeData(HTHEME hTheme);

//---------------------------------------------------------------------------
//    functions for basic drawing support 
//---------------------------------------------------------------------------
// The following methods are the theme-aware drawing services.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// For the list of all themed classes and the definition of all
// parts and states, see the file "tmschmea.h".
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Note: draw operations are always scaled to fit (and not to exceed)  
// the specified "Rect".
//-----------------------------------------------------------------------

//------------------------------------------------------------------------
//  DrawThemeBackground()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pClipRect           - optional clipping rect (don't draw outside it)
//------------------------------------------------------------------------
THEMEAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);

//---------------------------------------------------------------------------
//----- DrawThemeText() flags ----

#define DTT_GRAYED      0x1         // draw a grayed-out string  

//-------------------------------------------------------------------------
//  DrawThemeText()     - draws the text using the theme-specified 
//                        color and font for the "iPartId" and 
//                        "iStateId".  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pszText             - actual text to draw
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  dwTextFlags2        - additional drawing options 
//  pRect               - defines the size/location of the part
//-------------------------------------------------------------------------
THEMEAPI DrawThemeText(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    DWORD dwTextFlags2, const RECT *pRect);

//-------------------------------------------------------------------------
//  GetThemeBackgroundContentRect()
//                      - gets the size of the content for the theme-defined 
//                        background.  This is usually the area inside
//                        the borders or Margins.  
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pBoundingRect   - the outer RECT of the part being drawn
//      pContentRect    - RECT to receive the content area
//-------------------------------------------------------------------------
THEMEAPI GetThemeBackgroundContentRect(HTHEME hTheme, OPTIONAL HDC hdc, 
    int iPartId, int iStateId,  const RECT *pBoundingRect, 
    OUT RECT *pContentRect);

//-------------------------------------------------------------------------
//  GetThemeBackgroundExtent() - calculates the size/location of the theme-
//                               specified background based on the 
//                               "pContentRect".
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pContentRect    - RECT that defines the content area
//      pBoundingRect   - RECT to receive the overall size/location of part
//-------------------------------------------------------------------------
THEMEAPI GetThemeBackgroundExtent(HTHEME hTheme, OPTIONAL HDC hdc,
    int iPartId, int iStateId, const RECT *pContentRect, 
    OUT RECT *pExtentRect);

//-------------------------------------------------------------------------
typedef enum THEMESIZE
{
    TS_MIN,             // minimum size
    TS_TRUE,            // size without stretching
    TS_DRAW,            // size that theme mgr will use to draw part
};
//-------------------------------------------------------------------------
//  GetThemePartSize() - returns the specified size of the theme part
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font into & measure against
//  iPartId             - part number to retrieve size for
//  iStateId            - state number (of the part) 
//  prc                 - (optional) rect for part drawing destination
//  eSize               - the type of size to be retreived
//  psz                 - receives the specified size of the part 
//-------------------------------------------------------------------------
THEMEAPI GetThemePartSize(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
    OPTIONAL RECT *prc, enum THEMESIZE eSize, OUT SIZE *psz);

//-------------------------------------------------------------------------
//  GetThemeTextExtent() - calculates the size/location of the specified 
//                         text when rendered in the Theme Font. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font & measure into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pszText             - the text to be measured
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  pszBoundingRect     - optional: to control layout of text
//  pszExtentRect       - receives the RECT for text size/location
//-------------------------------------------------------------------------
THEMEAPI GetThemeTextExtent(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, 
    DWORD dwTextFlags, OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect);

//-------------------------------------------------------------------------
//  GetThemeTextMetrics()
//                      - returns info about the theme-specified font
//                        for the part/state passed in.
//
//  hTheme              - theme data handle
//  hdc                 - optional: HDC for screen context
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  ptm                 - receives the font info
//-------------------------------------------------------------------------
THEMEAPI GetThemeTextMetrics(HTHEME hTheme, OPTIONAL HDC hdc, 
    int iPartId, int iStateId, OUT TEXTMETRIC* ptm);

//-------------------------------------------------------------------------
//  GetThemeBackgroundRegion()
//                      - computes the region for a regular or partially 
//                        transparent theme-specified background that is 
//                        bound by the specified "pRect".
//                        If the rectangle is empty, sets the HRGN to NULL 
//                        and return S_FALSE.
//
//  hTheme              - theme data handle
//  hdc                 - optional HDC to draw into (DPI scaling)
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pRect               - the RECT used to draw the part
//  pRegion             - receives handle to calculated region
//-------------------------------------------------------------------------
THEMEAPI GetThemeBackgroundRegion(HTHEME hTheme, OPTIONAL HDC hdc,  
    int iPartId, int iStateId, const RECT *pRect, OUT HRGN *pRegion);

//-------------------------------------------------------------------------
//----- HitTestThemeBackground, HitTestThemeBackgroundRegion flags ----

//  Theme background segment hit test flag (default). possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTTOP, HTLEFT, HTTOPLEFT, etc:  // hit test succeeded in the the respective theme background segment.
#define HTTB_BACKGROUNDSEG          0x0000  

//  Fixed border hit test option.  possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTBORDER: hit test succeeded in any other background segment
#define HTTB_FIXEDBORDER            0x0002  // Return code may be either HTCLIENT or HTBORDER. 

//  Caption hit test option.  Possible return values are:
//  HTCAPTION: hit test succeeded in the top, top left, or top right background segments
//  HTNOWHERE or another return code, depending on absence or presence of accompanying flags, resp.
#define HTTB_CAPTION                0x0004  

//  Resizing border hit test flags.  Possible return values are:
//  HTCLIENT: hit test succeeded in middle background segment
//  HTTOP, HTTOPLEFT, HTLEFT, HTRIGHT, etc:    hit test succeeded in the respective system resizing zone
//  HTBORDER: hit test failed in middle segment and resizing zones, but succeeded in a background border segment
#define HTTB_RESIZINGBORDER_LEFT    0x0010  // Hit test left resizing border, 
#define HTTB_RESIZINGBORDER_TOP     0x0020  // Hit test top resizing border
#define HTTB_RESIZINGBORDER_RIGHT   0x0040  // Hit test right resizing border
#define HTTB_RESIZINGBORDER_BOTTOM  0x0080  // Hit test bottom resizing border

#define HTTB_RESIZINGBORDER         (HTTB_RESIZINGBORDER_LEFT|HTTB_RESIZINGBORDER_TOP|\
                                     HTTB_RESIZINGBORDER_RIGHT|HTTB_RESIZINGBORDER_BOTTOM)

// Resizing border is specified as a template, not just window edges.
// This option is mutually exclusive with HTTB_SYSTEMSIZINGWIDTH; HTTB_SIZINGTEMPLATE takes precedence  
#define HTTB_SIZINGTEMPLATE      0x0100

// Use system resizing border width rather than theme content margins.   
// This option is mutually exclusive with HTTB_SIZINGTEMPLATE, which takes precedence.
#define HTTB_SYSTEMSIZINGMARGINS 0x0200

//-------------------------------------------------------------------------
//  HitTestThemeBackground()
//                      - returns a HitTestCode (a subset of the values 
//                        returned by WM_NCHITTEST) for the point "ptTest" 
//                        within the theme-specified background
//                        (bound by pRect).  "pRect" and "ptTest" should 
//                        both be in the same coordinate system 
//                        (client, screen, etc).
//
//      hTheme          - theme data handle
//      hdc             - HDC to draw into
//      iPartId         - part number to test against
//      iStateId        - state number (of the part) 
//      pRect           - the RECT used to draw the part
//      hrgn            - optional region to use; must be in same coordinates as
//                      -    pRect and pTest.
//      ptTest          - the hit point to be tested
//      dwOptions       - HTTB_xxx constants
//      pwHitTestCode   - receives the returned hit test code - one of:
//  
//                        HTNOWHERE, HTLEFT, HTTOPLEFT, HTBOTTOMLEFT,
//                        HTRIGHT, HTTOPRIGHT, HTBOTTOMRIGHT,
//                        HTTOP, HTBOTTOM, HTCLIENT
//-------------------------------------------------------------------------
THEMEAPI HitTestThemeBackground(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, DWORD dwOptions, const RECT *pRect, OPTIONAL HRGN hrgn, 
    POINT ptTest, OUT WORD *pwHitTestCode);

//------------------------------------------------------------------------
//  DrawThemeEdge()     - Similar to the DrawEdge() API, but uses part colors
//                        and is high-DPI aware
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pDestRect           - the RECT used to draw the line(s)
//  uEdge               - Same as DrawEdge() API
//  uFlags              - Same as DrawEdge() API
//  pContentRect        - Receives the interior rect if (uFlags & BF_ADJUST)
//------------------------------------------------------------------------
THEMEAPI DrawThemeEdge(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
                       const RECT *pDestRect, UINT uEdge, UINT uFlags, OPTIONAL OUT RECT *pContentRect);

//------------------------------------------------------------------------
//  DrawThemeIcon()     - draws an image within an imagelist based on 
//                        a (possible) theme-defined effect. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pRect               - the RECT to draw the image within
//  himl                - handle to IMAGELIST 
//  iImageIndex         - index into IMAGELIST (which icon to draw)
//------------------------------------------------------------------------
THEMEAPI DrawThemeIcon(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex);

//---------------------------------------------------------------------------
//  IsThemePartDefined() - returns TRUE if the theme has defined parameters
//                         for the specified "iPartId" and "iStateId".
//
//  hTheme              - theme data handle
//  iPartId             - part number to find definition for
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemePartDefined(HTHEME hTheme, int iPartId, 
    int iStateId);

//---------------------------------------------------------------------------
//  IsThemeBackgroundPartiallyTransparent()
//                      - returns TRUE if the theme specified background for 
//                        the part/state has transparent pieces or 
//                        alpha-blended pieces.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeBackgroundPartiallyTransparent(HTHEME hTheme, 
    int iPartId, int iStateId);

//---------------------------------------------------------------------------
//    lower-level theme information services
//---------------------------------------------------------------------------
// The following methods are getter routines for each of the Theme Data types.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Each method also take a "iPropId" param because multiple instances of 
// the same primitive type can be defined in the theme schema.
//-----------------------------------------------------------------------


//-----------------------------------------------------------------------
//  GetThemeColor()     - Get the value for the specified COLOR property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pColor              - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeColor(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT COLORREF *pColor);

//-----------------------------------------------------------------------
//  GetThemeMetric()    - Get the value for the specified metric/size
//                        property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn into (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeMetric(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal);

//-----------------------------------------------------------------------
//  GetThemeString()    - Get the value for the specified string property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pszBuff             - receives the string property value
//  cchMaxBuffChars     - max. number of chars allowed in pszBuff
//-----------------------------------------------------------------------
THEMEAPI GetThemeString(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars);

//-----------------------------------------------------------------------
//  GetThemeBool()      - Get the value for the specified BOOL property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pfVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeBool(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT BOOL *pfVal);

//-----------------------------------------------------------------------
//  GetThemeInt()       - Get the value for the specified int property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeInt(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal);

//-----------------------------------------------------------------------
//  GetThemeEnumValue() - Get the value for the specified ENUM property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the enum (cast to int*)
//-----------------------------------------------------------------------
THEMEAPI GetThemeEnumValue(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal);

//-----------------------------------------------------------------------
//  GetThemePosition()  - Get the value for the specified position
//                        property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pPoint              - receives the value of the position property
//-----------------------------------------------------------------------
THEMEAPI GetThemePosition(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT POINT *pPoint);

//-----------------------------------------------------------------------
//  GetThemeFont()      - Get the value for the specified font property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn to (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pFont               - receives the value of the LOGFONT property
//                        (scaled for the current logical screen dpi) 
//-----------------------------------------------------------------------
THEMEAPI GetThemeFont(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OUT LOGFONT *pFont);

//-----------------------------------------------------------------------
//  GetThemeRect()      - Get the value for the specified RECT property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pRect               - receives the value of the RECT property
//-----------------------------------------------------------------------
THEMEAPI GetThemeRect(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT RECT *pRect);

//-----------------------------------------------------------------------
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//-----------------------------------------------------------------------
//  GetThemeMargins()   - Get the value for the specified MARGINS property
//
//      hTheme          - theme data handle
//      hdc             - (optional) hdc to be used for drawing
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      prc             - RECT for area to be drawn into
//      pMargins        - receives the value of the MARGINS property
//-----------------------------------------------------------------------
THEMEAPI GetThemeMargins(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OPTIONAL RECT *prc, OUT MARGINS *pMargins);

//-----------------------------------------------------------------------
#define MAX_INTLIST_COUNT 10

typedef struct _INTLIST
{
    int iValueCount;      // number of values in iValues
    int iValues[MAX_INTLIST_COUNT];
} INTLIST, *PINTLIST;

//-----------------------------------------------------------------------
//  GetThemeIntList()   - Get the value for the specified INTLIST struct
//
//      hTheme          - theme data handle
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      pIntList        - receives the value of the INTLIST property
//-----------------------------------------------------------------------
THEMEAPI GetThemeIntList(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT INTLIST *pIntList);

//-----------------------------------------------------------------------
typedef enum PROPERTYORIGIN
{
    PO_STATE,           // property was found in the state section
    PO_PART,            // property was found in the part section
    PO_CLASS,           // property was found in the class section
    PO_GLOBAL,          // property was found in [globals] section
    PO_NOTFOUND         // property was not found
};

//-----------------------------------------------------------------------
//  GetThemePropertyOrigin()
//                      - searches for the specified theme property
//                        and sets "pOrigin" to indicate where it was 
//                        found (or not found)
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pOrigin             - receives the value of the property origin
//-----------------------------------------------------------------------
THEMEAPI GetThemePropertyOrigin(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT enum PROPERTYORIGIN *pOrigin);

//---------------------------------------------------------------------------
//  SetWindowTheme()
//                      - redirects an existing Window to use a different 
//                        section of the current theme information than its 
//                        class normally asks for.
//
//  hwnd                - the handle of the window (cannot be NULL)
//
//  pszSubAppName       - app (group) name to use in place of the calling
//                        app's name.  If NULL, the actual calling app 
//                        name will be used.
//
//  pszSubIdList        - semicolon separated list of class Id names to 
//                        use in place of actual list passed by the 
//                        window's class.  if NULL, the id list from the 
//                        calling class is used.
//---------------------------------------------------------------------------
// The Theme Manager will remember the "pszSubAppName" and the
// "pszSubIdList" associations thru the lifetime of the window (even 
// if themes are subsequently changed).  The window is sent a 
// "WM_THEMECHANGED" msg at the end of this call, so that the new
// theme can be found and applied.
//---------------------------------------------------------------------------
// When "pszSubAppName" or "pszSubIdList" are NULL, the Theme Manager 
// removes the previously remember association.  To turn off theme-ing for 
// the specified window, you can pass an empty string (L"") so it 
// won't match any section entries.
//---------------------------------------------------------------------------
THEMEAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList);

//---------------------------------------------------------------------------
//  GetThemeFilename()  - Get the value for the specified FILENAME property.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pszThemeFileName    - output buffer to receive the filename
//  cchMaxBuffChars     - the size of the return buffer, in chars
//---------------------------------------------------------------------------
THEMEAPI GetThemeFilename(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszThemeFileName, int cchMaxBuffChars);

//---------------------------------------------------------------------------
//  GetThemeSysColor()  - Get the value of the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        color from [SysMetrics] section of theme.
//                        if NULL, will return the global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF) GetThemeSysColor(HTHEME hTheme, int iColorId);

//---------------------------------------------------------------------------
//  GetThemeSysColorBrush() 
//                      - Get the brush for the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        brush matching color from [SysMetrics] section of 
//                        theme.  if NULL, will return the brush matching
//                        global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH) GetThemeSysColorBrush(HTHEME hTheme, int iColorId);

//---------------------------------------------------------------------------
//  GetThemeSysBool()   - Get the boolean value of specified System metric. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        BOOL from [SysMetrics] section of theme.
//                        if NULL, will return the specified system boolean.
//
//  iBoolId             - the TMT_XXX BOOL number (first BOOL
//                        is TMT_FLATMENUS)
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) GetThemeSysBool(HTHEME hTheme, int iBoolId);

//---------------------------------------------------------------------------
//  GetThemeSysSize()   - Get the value of the specified System size metric. 
//                        (scaled for the current logical screen dpi) 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        size from [SysMetrics] section of theme.
//                        if NULL, will return the global system metric.
//
//  iSizeId             - the following values are supported when 
//                        hTheme is non-NULL:
//
//                          SM_CXBORDER   (border width)
//                          SM_CXVSCROLL  (scrollbar width)
//                          SM_CYHSCROLL  (scrollbar height)
//                          SM_CXSIZE     (caption width)
//                          SM_CYSIZE     (caption height)
//                          SM_CXSMSIZE   (small caption width)
//                          SM_CYSMSIZE   (small caption height)
//                          SM_CXMENUSIZE (menubar width)
//                          SM_CYMENUSIZE (menubar height)
//
//                        when hTheme is NULL, iSizeId is passed directly
//                        to the GetSystemMetrics() function
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize(HTHEME hTheme, int iSizeId);

//---------------------------------------------------------------------------
//  GetThemeSysFont()   - Get the LOGFONT for the specified System font. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        font from [SysMetrics] section of theme.
//                        if NULL, will return the specified system font.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//                        (scaled for the current logical screen dpi) 
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont(HTHEME hTheme, int iFontId, OUT LOGFONT *plf);

//---------------------------------------------------------------------------
//  GetThemeSysString() - Get the value of specified System string metric. 
//
//  hTheme              - the theme data handle (required)
//
//  iStringId           - must be one of the following values:
//
//                          TMT_CSSNAME
//                          TMT_XMLNAME
//
//  pszStringBuff       - the buffer to receive the string value
//
//  cchMaxStringChars   - max. number of chars that pszStringBuff can hold
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysString(HTHEME hTheme, int iStringId, 
    OUT LPWSTR pszStringBuff, int cchMaxStringChars);

//---------------------------------------------------------------------------
//  GetThemeSysInt() - Get the value of specified System int.
//
//  hTheme              - the theme data handle (required)
//
//  iIntId              - must be one of the following values:
//
//                          TMT_DPIX
//                          TMT_DPIY
//                          TMT_MINCOLORDEPTH
//
//  piValue             - ptr to int to receive value
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysInt(HTHEME hTheme, int iIntId, int *piValue);

//---------------------------------------------------------------------------
//  IsThemeActive()     - can be used to test if a system theme is active
//                        for the current user session.  
//
//                        use the API "IsAppThemed()" to test if a theme is
//                        active for the calling process.
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeActive();

//---------------------------------------------------------------------------
//  IsAppThemed()       - returns TRUE if a theme is active and available to
//                        the current process
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsAppThemed();


//---------------------------------------------------------------------------
//  GetWindowTheme()    - if window is themed, returns its most recent
//                        HTHEME from OpenThemeData() - otherwise, returns
//                        NULL.
//
//      hwnd            - the window to get the HTHEME of
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd);


//---------------------------------------------------------------------------
//  EnableThemeDialogTexture() 
//
//  - Enables/disables dialog background theme.  This method can be used to 
//    tailor dialog compatibility with child windows and controls that 
//    may or may not coordinate the rendering of their client area backgrounds 
//    with that of their parent dialog in a manner that supports seamless 
//    background texturing.
//
//      hdlg         - the window handle of the target dialog
//      dwFlags      - ETDT_ENABLE to enable the theme-defined dialog background texturing,
//                     ETDT_DISABLE to disable background texturing,
//                     ETDT_ENABLETAB to enable the theme-defined background 
//                          texturing using the Tab texture
//---------------------------------------------------------------------------

#define ETDT_DISABLE        0x00000001
#define ETDT_ENABLE         0x00000002
#define ETDT_USETABTEXTURE  0x00000004
#define ETDT_ENABLETAB      (ETDT_ENABLE  | ETDT_USETABTEXTURE)

THEMEAPI EnableThemeDialogTexture(HWND hwnd, DWORD dwFlags);


//---------------------------------------------------------------------------
//  IsThemeDialogTextureEnabled() 
//
//  - Reports whether the dialog supports background texturing.
//
//      hdlg         - the window handle of the target dialog
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeDialogTextureEnabled(HWND hwnd);


//---------------------------------------------------------------------------
//---- flags to control theming within an app ----

#define STAP_ALLOW_NONCLIENT    (1 << 0)
#define STAP_ALLOW_CONTROLS     (1 << 1)
#define STAP_ALLOW_WEBCONTENT   (1 << 2)

//---------------------------------------------------------------------------
//  GetThemeAppProperties()
//                      - returns the app property flags that control theming
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) GetThemeAppProperties();

//---------------------------------------------------------------------------
//  SetThemeAppProperties()
//                      - sets the flags that control theming within the app
//
//      dwFlags         - the flag values to be set
//---------------------------------------------------------------------------
THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags);

//---------------------------------------------------------------------------
//  GetCurrentThemeName()
//                      - Get the name of the current theme in-use.  
//                        Optionally, return the ColorScheme name and the 
//                        Size name of the theme.
//
//  pszThemeFileName    - receives the theme path & filename
//  cchMaxNameChars     - max chars allowed in pszNameBuff
//
//  pszColorBuff        - (optional) receives the canonical color scheme name
//                        (not the display name)
//  cchMaxColorChars    - max chars allowed in pszColorBuff
//
//  pszSizeBuff         - (optional) receives the canonical size name 
//                        (not the display name)
//  cchMaxSizeChars     - max chars allowed in pszSizeBuff
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    OUT LPWSTR pszThemeFileName, int cchMaxNameChars, 
    OUT OPTIONAL LPWSTR pszColorBuff, int cchMaxColorChars,
    OUT OPTIONAL LPWSTR pszSizeBuff, int cchMaxSizeChars);

//---------------------------------------------------------------------------
//  GetThemeDocumentationProperty()
//                      - Get the value for the specified property name from 
//                        the [documentation] section of the themes.ini file 
//                        for the specified theme.  If the property has been 
//                        localized in the theme files string table, the 
//                        localized version of the property value is returned. 
//
//  pszThemeFileName    - filename of the theme file to query
//  pszPropertyName     - name of the string property to retreive a value for
//  pszValueBuff        - receives the property string value
//  cchMaxValChars      - max chars allowed in pszValueBuff
//---------------------------------------------------------------------------
#define SZ_THDOCPROP_DISPLAYNAME                L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME              L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP                    L"ToolTip"
#define SZ_THDOCPROP_AUTHOR                     L"author"

THEMEAPI GetThemeDocumentationProperty(LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName, OUT LPWSTR pszValueBuff, int cchMaxValChars);

//---------------------------------------------------------------------------
//  Theme API Error Handling
//
//      All functions in the Theme API not returning an HRESULT (THEMEAPI_) 
//      use the WIN32 function "SetLastError()" to record any call failures.  
//
//      To retreive the error code of the last failure on the
//      current thread for these type of API's, use the WIN32 function 
//      "GetLastError()".
//
//      All Theme API error codes (HRESULT's and GetLastError() values)
//      should be normal win32 errors which can be formatted into
//      strings using the Win32 API FormatMessage().
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// DrawThemeParentBackground()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//
//  hwnd                - handle of the child control

//  hdc                 - hdc of the child control

//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//---------------------------------------------------------------------------
THEMEAPI DrawThemeParentBackground(HWND hwnd, HDC hdc, OPTIONAL RECT* prc);

//---------------------------------------------------------------------------
//  EnableTheming()     - enables or disables themeing for the current user
//                        in the current and future sessions.
//
//  fEnable             - if FALSE, disable theming & turn themes off.
//                      - if TRUE, enable themeing and, if user previously
//                        had a theme active, make it active now.
//---------------------------------------------------------------------------
THEMEAPI EnableTheming(BOOL fEnable);

//------------------------------------------------------------------------
//---- bits used in dwFlags of DTBGOPTS ----
#define DTBG_CLIPRECT        0x00000001   // rcClip has been specified
#define DTBG_DRAWSOLID       0x00000002   // draw transparent/alpha images as solid
#define DTBG_OMITBORDER      0x00000004   // don't draw border of part
#define DTBG_OMITCONTENT     0x00000008   // don't draw content area of part

#define DTBG_COMPUTINGREGION 0x00000010   // TRUE if calling to compute region

#define DTBG_MIRRORDC        0x00000020   // assume the hdc is mirrorred and
                                          // flip images as appropriate (currently 
                                          // only supported for bgtype=imagefile)
//------------------------------------------------------------------------
typedef struct _DTBGOPTS
{
    DWORD dwSize;           // size of the struct
    DWORD dwFlags;          // which options have been specified
    RECT rcClip;            // clipping rectangle
}
DTBGOPTS, *PDTBGOPTS;

//------------------------------------------------------------------------
//  DrawThemeBackgroundEx()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  NOTE: This will be
//                        merged back into DrawThemeBackground() after 
//                        BETA 2.
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pOptions            - ptr to optional params
//------------------------------------------------------------------------
THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions);


//---------------------------------------------------------------------------
//#endif  /* (_WIN32_WINNT >= 0x0500) *// 
//---------------------------------------------------------------------------
#endif // _UXTHEME_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\uastrfnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       uastrfnc.h
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA, ...
//
//  Classes:
//
//  Functions:
//
//;begin_internal
//  History:    1-11-95   davepl   Created
//;end_internal
//
//--------------------------------------------------------------------------

// NOTE: This file assumes it is included from shellprv.h

#ifndef _UASTRFNC_H_
#define _UASTRFNC_H_

#ifdef __cplusplus
extern "C" {
#endif

// If we are running on a platform that requires aligned data, we need
// to provide custom string functions that can deal with unaligned
// strings.  On other platforms, these call directly to the normal string
// functions.

#ifndef _X86_
#define ALIGNMENT_MACHINE
#endif

#ifdef ALIGNMENT_MACHINE

#define IS_ALIGNED(p)   (((ULONG_PTR)(p) & (sizeof(*(p))-1) )==0)

UNALIGNED WCHAR * ualstrcpynW(UNALIGNED WCHAR * lpString1,
    		  	      UNALIGNED const WCHAR * lpString2,
    			      int iMaxLength);

int 		  ualstrcmpiW (UNALIGNED const WCHAR * dst,
			       UNALIGNED const WCHAR * src);

int 		  ualstrcmpW  (UNALIGNED const WCHAR * src,
			       UNALIGNED const WCHAR * dst);

size_t 		  ualstrlenW  (UNALIGNED const WCHAR * wcs);

UNALIGNED WCHAR * ualstrcpyW  (UNALIGNED WCHAR * dst,
			       UNALIGNED const WCHAR * src);


#else

#define ualstrcpynW StrCpyNW     // lstrcpynW is stubbed out on Windows 95
#define ualstrcmpiW StrCmpIW     // lstrcmpiW is stubbed out on Windows 95
#define ualstrcmpW  StrCmpW      // lstrcmpW is stubbed out on Windows 95
#define ualstrlenW  lstrlenW
#define ualstrcpyW  StrCpyW      // lstrcpyW is stubbed out on Windows 95

#endif // ALIGNMENT_MACHINE

#define ualstrcpynA lstrcpynA
#define ualstrcmpiA lstrcmpiA
#define ualstrcmpA  lstrcmpA
#define ualstrlenA  lstrlenA
#define ualstrcpyA  lstrcpyA

#ifdef UNICODE
#define ualstrcpyn ualstrcpynW
#define ualstrcmpi ualstrcmpiW
#define ualstrcmp  ualstrcmpW
#define ualstrlen  ualstrlenW
#define ualstrcpy  ualstrcpyW
#else
#define ualstrcpyn ualstrcpynA
#define ualstrcmpi ualstrcmpiA
#define ualstrcmp  ualstrcmpA
#define ualstrlen  ualstrlenA
#define ualstrcpy  ualstrcpyA
#endif

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // _UASTRFNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\uuid\makefile.inc ===
#
# Explicit rules for copying generated *_i.c files from ..\inc\$(O) to $(O)
#

$(O)\chanmgr_i.c : ..\inc\$(O)\chanmgr_i.c
    copy $** $@

$(O)\CommonControls_i.c : ..\inc\$(O)\CommonControls_i.c
    copy $** $@

$(O)\emptyvc_i.c : ..\inc\$(O)\emptyvc_i.c
    copy $** $@

$(O)\imapi_i.c : ..\inc\$(O)\imapi_i.c
    copy $** $@

$(O)\mlang_i.c : ..\inc\$(O)\mlang_i.c
    copy $** $@

$(O)\opsprof_i.c : ..\inc\$(O)\opsprof_i.c
    copy $** $@

$(O)\shappmgr_i.c : ..\inc\$(O)\shappmgr_i.c
    copy $** $@

$(O)\shimgdata_i.c : ..\inc\$(O)\shimgdata_i.c
    copy $** $@

$(O)\shgina_i.c : ..\inc\$(O)\shgina_i.c
    copy $** $@

$(O)\shhelper_i.c : ..\inc\$(O)\shhelper_i.c
    copy $** $@

$(O)\shldisp_i.c : ..\inc\$(O)\shldisp_i.c
    copy $** $@

$(O)\shobjidl_i.c : ..\inc\$(O)\shobjidl_i.c
    copy $** $@

$(O)\tlog_i.c : ..\inc\$(O)\tlog_i.c
    copy $** $@

$(O)\tlogstg_i.c : ..\inc\$(O)\tlogstg_i.c
    copy $** $@

$(O)\vrsscan_i.c : ..\inc\$(O)\vrsscan_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\inc\wire_mar.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: wire_mar.c
//
//  Contents: wire_marshal routines for shell data types
//
//  History:  18-JUN-99 ZekeL - created file
//
//--------------------------------------------------------------------------

#define DUMMYUNIONNAME
#include <shtypes.h>
#include <ole2.h>

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

ULONG MyILSize(LPCITEMIDLIST pidl)
{
    ULONG cb = 0;
    if (pidl)
    {
        cb = sizeof(pidl->mkid.cb);     // Null terminator
        while (pidl->mkid.cb)
        {
            cb += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cb;
}

ULONG __RPC_USER LPITEMIDLIST_UserSize(ULONG *pFlags, ULONG StartingSize, LPITEMIDLIST *ppidl)
{
    return StartingSize + sizeof(ULONG) + MyILSize(*ppidl);
}

ULONG __RPC_USER LPITEMIDLIST_UserSize64(ULONG *pFlags, ULONG StartingSize, LPITEMIDLIST *ppidl) {
    return StartingSize + sizeof(ULONG) + MyILSize(*ppidl);
}

UCHAR * __RPC_USER LPITEMIDLIST_UserMarshal(ULONG *pFlags, UCHAR *pBuffer, LPITEMIDLIST *ppidl)
{
    ULONG cb = MyILSize(*ppidl);

    //  set the size of the BYTE_BLOB
    *((ULONG UNALIGNED *)pBuffer) = cb;
    pBuffer += sizeof(ULONG);

    if (cb)
    {
        //  copy the pidl over
        memcpy(pBuffer, *ppidl, cb);
    }
    
    return pBuffer + cb;
}

UCHAR * __RPC_USER LPITEMIDLIST_UserMarshal64(ULONG *pFlags, UCHAR *pBuffer, LPITEMIDLIST *ppidl) {
    return LPITEMIDLIST_UserMarshal(pFlags, pBuffer, ppidl);
}

UCHAR * __RPC_USER LPITEMIDLIST_UserUnmarshal(ULONG *pFlags, UCHAR *pBuffer, LPITEMIDLIST *ppidl)
{
    ULONG cb = *((ULONG UNALIGNED *)pBuffer);
    pBuffer += sizeof(ULONG);

    if (cb)
    {
        //ASSERT(cb == MyILSize((LPCITEMIDLIST)pBuffer);
        
        *ppidl = (LPITEMIDLIST)CoTaskMemRealloc(*ppidl, cb);
        if (*ppidl)
        {
            memcpy(*ppidl, pBuffer, cb);
        }
        else
        {
            RpcRaiseException(E_OUTOFMEMORY);
        }
    }
    else 
        *ppidl = NULL;
    
    return pBuffer + cb;
}

UCHAR * __RPC_USER LPITEMIDLIST_UserUnmarshal64(ULONG *pFlags, UCHAR *pBuffer, LPITEMIDLIST *ppidl) {
    return LPITEMIDLIST_UserUnmarshal(pFlags, pBuffer, ppidl);
}

void __RPC_USER LPITEMIDLIST_UserFree(ULONG *pFlags, LPITEMIDLIST *ppidl)
{
    CoTaskMemFree(*ppidl);
}

void __RPC_USER LPITEMIDLIST_UserFree64(ULONG *pFlags, LPITEMIDLIST *ppidl) {
    CoTaskMemFree(*ppidl);
}

ULONG __RPC_USER LPCITEMIDLIST_UserSize(ULONG *pFlags, ULONG StartingSize, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserSize(pFlags, StartingSize, (LPITEMIDLIST *)ppidl);
}

ULONG __RPC_USER LPCITEMIDLIST_UserSize64(ULONG *pFlags, ULONG StartingSize, LPCITEMIDLIST *ppidl) {
    return LPITEMIDLIST_UserSize(pFlags, StartingSize, (LPITEMIDLIST *)ppidl);
}

UCHAR * __RPC_USER LPCITEMIDLIST_UserMarshal(ULONG *pFlags, UCHAR *pBuffer, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserMarshal(pFlags, pBuffer, (LPITEMIDLIST *)ppidl);
}

UCHAR * __RPC_USER LPCITEMIDLIST_UserMarshal64(ULONG *pFlags, UCHAR *pBuffer, LPCITEMIDLIST *ppidl) {
    return LPITEMIDLIST_UserMarshal(pFlags, pBuffer, (LPITEMIDLIST *)ppidl);
}

UCHAR * __RPC_USER LPCITEMIDLIST_UserUnmarshal(ULONG *pFlags, UCHAR *pBuffer, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserUnmarshal(pFlags, pBuffer, (LPITEMIDLIST *)ppidl);
}

UCHAR * __RPC_USER LPCITEMIDLIST_UserUnmarshal64(ULONG *pFlags, UCHAR *pBuffer, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserUnmarshal(pFlags, pBuffer, (LPITEMIDLIST *)ppidl);
}

void __RPC_USER LPCITEMIDLIST_UserFree(ULONG *pFlags, LPCITEMIDLIST *ppidl)
{
    CoTaskMemFree((LPITEMIDLIST)*ppidl);
}

void __RPC_USER LPCITEMIDLIST_UserFree64(ULONG *pFlags, LPCITEMIDLIST *ppidl) {
    CoTaskMemFree((LPITEMIDLIST)*ppidl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\published\uuid\shguids.c ===
#define INITGUID
#include <guiddef.h>

#include <shlguid.h>
#include <commdlg.h>
#include <dsclient.h>
#include <dsclintp.h>
#include <cmnquery.h>
#include <cmnquryp.h>
#include <dsquery.h>
#include <dsqueryp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplication.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplication.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to encapsulate identification of a bad application.
//
//  History:    2000-08-25  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifndef     _BadApplication_
#define     _BadApplication_

//  --------------------------------------------------------------------------
//  CBadApplication
//
//  Purpose:    Implements abstraction of what defines a bad application.
//
//  History:    2000-08-25  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

class   CBadApplication
{
    public:
                CBadApplication (void);
                CBadApplication (const TCHAR *pszImageName);
                ~CBadApplication (void);

        bool    operator == (const CBadApplication& compareObject)  const;
    private:
        TCHAR   _szImageName[MAX_PATH];
};

#endif  /*  _BadApplication_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationapirequest.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIRequest.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  requests.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationAPIRequest_
#define     _BadApplicationAPIRequest_

#include "APIDispatcher.h"
#include "APIRequest.h"
#include "BadApplicationManager.h"
#include "PortMessage.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest
//
//  Purpose:    This is an intermediate class that contains a common method
//              that can be used by sub-classes.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//              2002-03-24  scotthan    propagate DispatchSync to API request instance.
//  --------------------------------------------------------------------------

class   CBadApplicationAPIRequest : public CAPIRequest
{
    private:
                                            CBadApplicationAPIRequest (void);
    public:
                                            CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher);
                                            CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage);
        virtual                             ~CBadApplicationAPIRequest (void);

        virtual NTSTATUS                    Execute (CAPIDispatchSync* pAPIDispatchSync);

        static  NTSTATUS                    StaticInitialize (HINSTANCE hInstance);
        static  NTSTATUS                    StaticTerminate (void);
    private:
                NTSTATUS                    Execute_QueryRunning (void);
                NTSTATUS                    Execute_RegisterRunning (void);
                NTSTATUS                    Execute_QueryUserPermission (void);
                NTSTATUS                    Execute_TerminateRunning (void);
                NTSTATUS                    Execute_RequestSwitchUser (void);
    private:
        static  CBadApplicationManager*     s_pBadApplicationManager;
};

#endif  /*  _BadApplicationAPIRequest_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplication.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplication.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to encapsulate identification of a bad application.
//
//  History:    2000-08-25  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplication.h"

//  --------------------------------------------------------------------------
//  CBadApplication::CBadApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Default constructor for CBadApplication. This just clears the
//              application image name.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplication::CBadApplication (void)

{
    ZeroMemory(&_szImageName, sizeof(_szImageName));
}

//  --------------------------------------------------------------------------
//  CBadApplication::CBadApplication
//
//  Arguments:  pszImageName    =   Image name of application.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBadApplication. This copies the given
//              application image name.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplication::CBadApplication (const TCHAR *pszImageName)

{
    ZeroMemory(&_szImageName, sizeof(_szImageName));
    lstrcpyn(_szImageName, pszImageName, ARRAYSIZE(_szImageName));
}

//  --------------------------------------------------------------------------
//  CBadApplication::~CBadApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBadApplication. Releases any resources used.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplication::~CBadApplication (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplication::operator ==
//
//  Arguments:  compareObject   =   Object to compare against.
//
//  Returns:    bool
//
//  Purpose:    Overloaded operator == to facilitate easier comparison on two
//              CBadApplication objects.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

bool    CBadApplication::operator == (const CBadApplication& compareObject) const

{
    return(lstrcmpi(compareObject._szImageName, _szImageName) == 0);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationapirequest.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIRequest.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  requests.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationAPIRequest.h"

#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::s_pBadApplicationManager
//
//  Purpose:    Single instance of the CBadApplicationManager object.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationManager*     CBadApplicationAPIRequest::s_pBadApplicationManager     =   NULL;

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::CBadApplicationAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationAPIRequest class. It just passes the
//              control to the super class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIRequest::CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher) :
    CAPIRequest(pAPIDispatcher)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::CBadApplicationAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//              portMessage     =   CPortMessage to copy construct.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationAPIRequest class. It just passes the
//              control to the super class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIRequest::CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage) :
    CAPIRequest(pAPIDispatcher, portMessage)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::~CBadApplicationAPIRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CBadApplicationAPIRequest class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIRequest::~CBadApplicationAPIRequest (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute
//
//  Arguments:  pAPIDispatchSync - allows request execution access to various
//              service notifications and events
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute implementation for bad application API requests. This
//              function dispatches requests based on the API request number.
//
//  History:    2000-08-25  vtan        created
//              2002-03-24  scotthan    add DispatchSync arg
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute (CAPIDispatchSync* pAPIDispatchSync)

{
    NTSTATUS    status;

    UNREFERENCED_PARAMETER(pAPIDispatchSync);

    switch (reinterpret_cast<API_BAM*>(&_data)->apiGeneric.ulAPINumber)
    {
        case API_BAM_QUERYRUNNING:
            status = Execute_QueryRunning();
            break;
        case API_BAM_REGISTERRUNNING:
            status = Execute_RegisterRunning();
            break;
        case API_BAM_QUERYUSERPERMISSION:
            status = Execute_QueryUserPermission();
            break;
        case API_BAM_TERMINATERUNNING:
            status = Execute_TerminateRunning();
            break;
        case API_BAM_REQUESTSWITCHUSER:
            status = Execute_RequestSwitchUser();
            break;
        default:
            DISPLAYMSG("Unknown API request in CBadApplicationAPIRequest::Execute");
            status = STATUS_NOT_IMPLEMENTED;
            break;
    }
    TSTATUS(status);
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static initializer for the class. It creates the static
//              instance of the CBadApplicationManager which must be a single
//              instance and knows about bad running applications.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::StaticInitialize (HINSTANCE hInstance)

{
    NTSTATUS    status;

    if (s_pBadApplicationManager == NULL)
    {
        s_pBadApplicationManager = new CBadApplicationManager(hInstance);
        if (s_pBadApplicationManager != NULL)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static destructor for the class. This terminates the bad
//              application manager, releases the reference on the object and
//              clears out the static variable. When the thread dies it will
//              clean itself up.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::StaticTerminate (void)

{
    if (s_pBadApplicationManager != NULL)
    {
        s_pBadApplicationManager->Terminate();
        s_pBadApplicationManager->Release();
        s_pBadApplicationManager = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_QueryRunning
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_QUERYRUNNING. Returns whether or not the
//              requested image path is currently a known (tracked)
//              executable that is running. Let the bad application manager
//              do the work. Exclude checking in the same session.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_QueryRunning (void)

{
    NTSTATUS                    status;
    HANDLE                      hProcessClient;
    SIZE_T                      dwNumberOfBytesRead;
    API_BAM_QUERYRUNNING_IN     *pAPIIn;
    API_BAM_QUERYRUNNING_OUT    *pAPIOut;
    WCHAR                       szImageName[MAX_PATH];

    hProcessClient = _pAPIDispatcher->GetClientProcess();
    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryRunning.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryRunning.out;
    if (ReadProcessMemory(hProcessClient,
                          pAPIIn->pszImageName,
                          szImageName,
                          pAPIIn->cchImageName * sizeof(WCHAR),
                          &dwNumberOfBytesRead) != FALSE)
    {
        CBadApplication                 badApplication(szImageName);

        pAPIOut->fResult = s_pBadApplicationManager->QueryRunning(badApplication, _pAPIDispatcher->GetClientSessionID());
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_RegisterRunning
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_REGISTERRUNNING. Adds the given image
//              executable to the list of currently running bad applications
//              so that further instances can be excluded.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_RegisterRunning (void)

{
    NTSTATUS                        status;
    SIZE_T                          dwNumberOfBytesRead;
    API_BAM_REGISTERRUNNING_IN      *pAPIIn;
    API_BAM_REGISTERRUNNING_OUT     *pAPIOut;
    WCHAR                           szImageName[MAX_PATH];

    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiRegisterRunning.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiRegisterRunning.out;
    if ((pAPIIn->bamType > BAM_TYPE_MINIMUM) && (pAPIIn->bamType < BAM_TYPE_MAXIMUM))
    {
        if (ReadProcessMemory(_pAPIDispatcher->GetClientProcess(),
                              pAPIIn->pszImageName,
                              szImageName,
                              pAPIIn->cchImageName * sizeof(WCHAR),
                              &dwNumberOfBytesRead) != FALSE)
        {
            HANDLE              hProcess;
            CBadApplication     badApplication(szImageName);

            hProcess = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,
                                   FALSE,
                                   pAPIIn->dwProcessID);
            if (hProcess != NULL)
            {
                status = s_pBadApplicationManager->RegisterRunning(badApplication, hProcess, pAPIIn->bamType);
                TBOOL(CloseHandle(hProcess));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }
    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_QueryUserPermission
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_QUERYUSERPERMISSION. Queries the client
//              permission to close down the bad application. Also returns
//              the current user of the bad application.
//
//  History:    2000-08-31  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_QueryUserPermission (void)

{
    NTSTATUS                            status;
    SIZE_T                              dwNumberOfBytesRead;
    API_BAM_QUERYUSERPERMISSION_IN      *pAPIIn;
    API_BAM_QUERYUSERPERMISSION_OUT     *pAPIOut;
    WCHAR                               szImageName[MAX_PATH];

    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryUserPermission.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryUserPermission.out;
    if (ReadProcessMemory(_pAPIDispatcher->GetClientProcess(),
                          pAPIIn->pszImageName,
                          szImageName,
                          pAPIIn->cchImageName * sizeof(WCHAR),
                          &dwNumberOfBytesRead) != FALSE)
    {
        HANDLE              hProcess;
        CBadApplication     badApplication(szImageName);

        //  Query information on the bad application
        //  (get back the process handle).

        status = s_pBadApplicationManager->QueryInformation(badApplication, hProcess);
        if (NT_SUCCESS(status))
        {
            HANDLE  hToken;

            //  Get the client token and impersonate that user.

            status = OpenClientToken(hToken);
            if (NT_SUCCESS(status))
            {
                bool                fCanShutdownApplication;
                HANDLE              hTokenProcess;
                CTokenInformation   tokenInformationClient(hToken);

                fCanShutdownApplication = tokenInformationClient.IsUserAnAdministrator();

                //  Get the bad application process token to get
                //  information on the user for the process.

                if (OpenProcessToken(hProcess,
                                     TOKEN_QUERY,
                                     &hTokenProcess) != FALSE)
                {
                    const WCHAR         *pszUserDisplayName;
                    CTokenInformation   tokenInformationProcess(hTokenProcess);

                    pszUserDisplayName = tokenInformationProcess.GetUserDisplayName();
                    if (pszUserDisplayName != NULL)
                    {
                        int     iCharsToWrite;
                        SIZE_T  dwNumberOfBytesWritten;

                        //  Return the information back to the client.

                        pAPIOut->fCanShutdownApplication = fCanShutdownApplication;
                        iCharsToWrite = lstrlen(pszUserDisplayName) + sizeof('\0');
                        if (iCharsToWrite > pAPIIn->cchUser)
                        {
                            iCharsToWrite = pAPIIn->cchUser;
                        }
                        if (WriteProcessMemory(_pAPIDispatcher->GetClientProcess(),
                                               pAPIIn->pszUser,
                                               const_cast<WCHAR*>(pszUserDisplayName),
                                               iCharsToWrite * sizeof(WCHAR),
                                               &dwNumberOfBytesWritten) != FALSE)
                        {
                            status = STATUS_SUCCESS;
                        }
                        else
                        {
                            status = CStatusCode::StatusCodeOfLastError();
                        }
                    }
                    else
                    {
                        status = CStatusCode::StatusCodeOfLastError();
                    }
                    TBOOL(CloseHandle(hTokenProcess));
                }
                else
                {
                    status = CStatusCode::StatusCodeOfLastError();
                }
                TBOOL(CloseHandle(hToken));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseHandle(hProcess));
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_QueryUserPermission
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_TERMINATERUNNING. Terminates the given running
//              bad application so a different instance on a different
//              window station can start it.
//
//  History:    2000-08-31  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_TerminateRunning (void)

{
    NTSTATUS                        status;
    SIZE_T                          dwNumberOfBytesRead;
    API_BAM_TERMINATERUNNING_IN     *pAPIIn;
    API_BAM_TERMINATERUNNING_OUT    *pAPIOut;
    WCHAR                           szImageName[MAX_PATH];

    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiTerminateRunning.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiTerminateRunning.out;
    if (ReadProcessMemory(_pAPIDispatcher->GetClientProcess(),
                          pAPIIn->pszImageName,
                          szImageName,
                          pAPIIn->cchImageName * sizeof(WCHAR),
                          &dwNumberOfBytesRead) != FALSE)
    {
        HANDLE  hToken;

        //  Get the client token and for membership of the local administrators
        //  group. DO NOT IMPERSONATE THE CLIENT. This will almost certainly
        //  guarantee that the process cannot be terminated.

        status = OpenClientToken(hToken);
        if (NT_SUCCESS(status))
        {
            CTokenInformation   tokenInformationClient(hToken);

            if (tokenInformationClient.IsUserAnAdministrator())
            {
                HANDLE              hProcess;
                CBadApplication     badApplication(szImageName);

                //  Query information on the bad application
                //  (get back the process handle).

                status = s_pBadApplicationManager->QueryInformation(badApplication, hProcess);
                if (NT_SUCCESS(status))
                {
                    do
                    {
                        status = CBadApplicationManager::PerformTermination(hProcess, true);
                        TBOOL(CloseHandle(hProcess));
                    } while (NT_SUCCESS(status) &&
                             NT_SUCCESS(s_pBadApplicationManager->QueryInformation(badApplication, hProcess)));
                }

                //  If the information could not be found then it's
                //  probably not running. This indicates success.

                else
                {
                    status = STATUS_SUCCESS;
                }
            }
            else
            {
                status = STATUS_ACCESS_DENIED;
            }
            TBOOL(CloseHandle(hToken));
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    pAPIOut->fResult = NT_SUCCESS(status);
    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_RequestSwitchUser
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_REQUESTSWITCHUSER. Request from
//              winlogon/msgina to switch a user. Terminate all bad
//              applications related to disconnect. Reject the disconnect if
//              it fails.
//
//  History:    2000-11-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_RequestSwitchUser (void)

{
    API_BAM_REQUESTSWITCHUSER_OUT   *pAPIOut;

    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiRequestSwitchUser.out;
    pAPIOut->fAllowSwitch = NT_SUCCESS(s_pBadApplicationManager->RequestSwitchUser());
    SetDataLength(sizeof(API_BAM));
    return(STATUS_SUCCESS);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\resource.h ===
//  --------------------------------------------------------------------------
//  Module Name: Resource.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  Resource ID declarations common to the shared shell service DLL.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ShellServicesResource_
#define     _ShellServicesResource_

//  Bad Application Service.

#define IDD_BADAPP_CLOSE                    0x1000
#define IDC_BADAPP_CLOSEPROGRAM             0x1001
#define IDC_BADAPP_CLOSE                    0x1002
#define IDD_BADAPP_STOP                     0x1100
#define IDC_BADAPP_STOP                     0x1101
#define IDD_PROGRESS                        0x1200
#define IDC_PROGRESS_PROGRESSBAR            0x1201
#define IDC_PROGRESS_CLOSE                  0x1202

#define IDS_WARNING_CAPTION                 0x1E00
#define IDS_TERMINATEPROCESS_FAILURE        0x1E01

#define IDS_BAMSERVER_DISPLAYNAME           0x1F00
#define IDS_BAMSERVER_DESCRIPTION           0x1F01

//  Theme Service.

#define IDS_THEMESERVER_DISPLAYNAME         0x2000
#define IDS_THEMESERVER_DESCRIPTION         0x2001

//  Hardware Detection Service.

#define IDS_SHELLHWDETECTION_FRIENDLYNAME   0x3000
#define IDS_SHELLHWDETECTION_DESCRIPTION    0x3001

#endif  /*  _ShellServicesResource_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationapiserver.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIServer.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationAPIServer_
#define     _BadApplicationAPIServer_

#include "APIDispatcher.h"
#include "ServerAPI.h"
#include "PortMessage.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer
//
//  Purpose:    This class implements the interface that the
//              CAPIConnectionThread uses to create create the LPC port,
//              accept or reject connections to the LPC port and create the
//              LPC request handling thread.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

class   CBadApplicationAPIServer : public CServerAPI
{
    public:
                                    CBadApplicationAPIServer (void);
        virtual                     ~CBadApplicationAPIServer (void);

        static  DWORD               StrToInt (const WCHAR *pszString);
    protected:
        virtual const WCHAR*        GetPortName (void);
        virtual const TCHAR*        GetServiceName (void);
        virtual bool                ConnectionAccepted (const CPortMessage& portMessage);
        virtual CAPIDispatcher*     CreateDispatcher (const CPortMessage& portMessage);
        virtual NTSTATUS            Connect (HANDLE* phPort);
    private:
};

#endif  /*  _BadApplicationAPIServer_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationapiserver.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIServer.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationAPIServer.h"

#include <lpcfus.h>

#include "BadApplicationDispatcher.h"
#include "BadApplicationService.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::CBadApplicationAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationAPIServer class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIServer::CBadApplicationAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::~CBadApplicationAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CBadApplicationAPIServer class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIServer::~CBadApplicationAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::StrToInt
//
//  Arguments:  pszString   =   String to convert to a DWORD
//
//  Returns:    DWORD
//
//  Purpose:    Converts the string to a DWORD - UNSIGNED.
//
//  History:    2000-11-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CBadApplicationAPIServer::StrToInt (const WCHAR *pszString)

{
    DWORD   dwProcessID;
    WCHAR   c;

    //  Convert inline from decimal WCHAR string to int.

    dwProcessID = 0;
    c = *pszString++;
    while (c != L'\0')
    {
        dwProcessID *= 10;
        ASSERTMSG((c >= L'0') && (c <= L'9'), "Invalid decimal digit in CBadApplicationAPIServer::StrToInt");
        dwProcessID += (c - L'0');
        c = *pszString++;
    }
    return(dwProcessID);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns a unicode string (const pointer) to the name of the
//              port for this server that supports multiple API sets.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CBadApplicationAPIServer::GetPortName (void)

{
    return(FUS_PORT_NAME);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Uses a common routine to get the theme service name.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CBadApplicationAPIServer::GetServiceName (void)

{
    return(CBadApplicationService::GetName());
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::ConnectionAccepted
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    bool
//
//  Purpose:    Accepts or rejects a port connection request. Accepts all
//              connections currently.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

bool    CBadApplicationAPIServer::ConnectionAccepted (const CPortMessage& portMessage)

{
    return(lstrcmpW(reinterpret_cast<const WCHAR*>(portMessage.GetData()), FUS_CONNECTION_REQUEST) == 0);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::CreateDispatchThread
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    CAPIDispatcher*
//
//  Purpose:    Called by the LPC connection request handler to create a new
//              thread to handle client requests.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CAPIDispatcher*     CBadApplicationAPIServer::CreateDispatcher (const CPortMessage& portMessage)

{
    HANDLE              hClientProcess;
    OBJECT_ATTRIBUTES   objectAttributes;
    CLIENT_ID           clientID;
    CAPIDispatcher      *pAPIDispatcher;

    pAPIDispatcher = NULL;
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    clientID.UniqueProcess = portMessage.GetUniqueProcess();
    clientID.UniqueThread = NULL;

    //  Open a handle to the client process. The handle must have PROCESS_DUP_HANDLE
    //  for the server to be able to deliver handles to the client. It also needs
    //  PROCESS_VM_READ | PROCESS_VM_WRITE if it's to read and write the client
    //  address space to store data that's too big for the LPC port.

    //  That handle is stored by the thread handler. It's not closed here.

    if (NT_SUCCESS(NtOpenProcess(&hClientProcess,
                                 PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                                 &objectAttributes,
                                 &clientID)))
    {
        pAPIDispatcher = new CBadApplicationDispatcher(hClientProcess);
    }
    return(pAPIDispatcher);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::Connect
//
//  Arguments:  phPort  =   Handle to the port received on connection.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the server.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIServer::Connect (HANDLE* phPort)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[64];

    RtlInitUnicodeString(&portName, GetPortName());
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    return(NtConnectPort(phPort,
                         &portName,
                         &sqos,
                         NULL,
                         NULL,
                         NULL,
                         szConnectionInfo,
                         &ulConnectionInfoLength));
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationmanager.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationManager.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Classes to manage bad applications in the fast user switching environment.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationManager.h"

#include <wtsapi32.h>
#include <winsta.h>

#include "GracefulTerminateApplication.h"
#include "RestoreApplication.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CBadApplicationManager::INDEX_EVENT
//  CBadApplicationManager::INDEX_HANDLES
//  CBadApplicationManager::INDEX_RESERVED
//  CBadApplicationManager::s_szDefaultDesktop
//
//  Purpose:    Constant indicies into a HANDLE array passed to
//              user32!MsgWaitForMultipleObjects. The first handle is always
//              the synchronization event. Subsequent HANDLEs are built into
//              a static ARRAY passed with the dynamic amount.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

const int       CBadApplicationManager::INDEX_EVENT             =   0;
const int       CBadApplicationManager::INDEX_HANDLES           =   INDEX_EVENT + 1;
const int       CBadApplicationManager::INDEX_RESERVED          =   2;
const WCHAR     CBadApplicationManager::s_szDefaultDesktop[]    =   L"WinSta0\\Default";

//  --------------------------------------------------------------------------
//  CBadApplicationManager::CBadApplicationManager
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBadApplicationManager. This creates a thread
//              that watches HANDLEs in the bad application list. The watcher
//              knows when the offending process dies. It also creates a
//              synchronization event that is signalled when the array of
//              bad applications changes (is incremented). The thread
//              maintains removal cases.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationManager::CBadApplicationManager (HINSTANCE hInstance) :
    CThread(),
    _hInstance(hInstance),
    _hModule(NULL),
    _atom(NULL),
    _hwnd(NULL),
    _fTerminateWatcherThread(false),
    _fRegisteredNotification(false),
    _dwSessionIDLastConnect(static_cast<DWORD>(-1)),
    _hTokenLastUser(NULL),
    _hEvent(NULL),
    _badApplications(sizeof(BAD_APPLICATION_INFO)),
    _restoreApplications()

{
    Resume();
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::~CBadApplicationManager
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBadApplicationManager. Releases any resources
//              used.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationManager::~CBadApplicationManager (void)

{

    //  In case the token hasn't been released yet - release it.

    ReleaseHandle(_hTokenLastUser);
    Cleanup();
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Forces the watcher thread to terminate. Acquire the lock. Walk
//              the list of entries and release the HANDLE on the process
//              objects so they don't leak. Set the bool to terminate the
//              thread. Set the event to wake the thread up. Release the lock.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::Terminate (void)

{
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    for (i = _badApplications.GetCount() - 1; i >= 0; --i)
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
        {
            TBOOL(CloseHandle(badApplicationInfo.hProcess));
        }
        _badApplications.Remove(i);
    }
    _fTerminateWatcherThread = true;
    return(_hEvent.Set());
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::QueryRunning
//
//  Arguments:  badApplication  =   Bad application identifier to query.
//              dwSessionID     =   Session ID of the request.
//
//  Returns:    bool
//
//  Purpose:    Queries the current running known bad applications list
//              looking for a match. Again because this typically runs on a
//              different thread to the watcher thread access to the list is
//              protected by a critical section.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

bool    CBadApplicationManager::QueryRunning (const CBadApplication& badApplication, DWORD dwSessionID)

{
    bool                        fResult;
    NTSTATUS                    status;
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    status = STATUS_SUCCESS;
    fResult = false;

    //  Loop looking for a match. This uses the overloaded operator ==.

    for (i = _badApplications.GetCount() - 1; !fResult && (i >= 0); --i)
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        status = _badApplications.Get(&badApplicationInfo, i);
        if (NT_SUCCESS(status))
        {

            //  Make sure the client is not in the same session as the running
            //  bad application. This API exists to prevent cross session instances.
            //  It's assumed that applications have their own mechanisms for multiple
            //  instances in the same session (or object name space).

            fResult = ((badApplicationInfo.dwSessionID != dwSessionID) &&
                       (badApplicationInfo.badApplication == badApplication));
        }
    }
    TSTATUS(status);
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::RegisterRunning
//
//  Arguments:  badApplication  =   Bad application identifier to add.
//              hProcess        =   HANDLE to the process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the given bad application to the known running list. The
//              process object is added as well so that when the process
//              terminates it can be cleaned up out of the list.
//
//              Access to the bad application list is serialized with a
//              critical section. This is important because the thread
//              watching for termination always run on a different thread to
//              the thread on which this function executes. Because they both
//              access the same member variables this must be protected with
//              a critical section.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::RegisterRunning (const CBadApplication& badApplication, HANDLE hProcess, BAM_TYPE bamType)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    listLock(_lock);

    ASSERTMSG((bamType > BAM_TYPE_MINIMUM) && (bamType < BAM_TYPE_MAXIMUM), "Invalid BAM_TYPE value passed to CBadApplicationManager::AddRunning");

    //  Have we reached the maximum number of wait object allowed? If not
    //  then proceed to add this. Otherwise reject the call. This is a
    //  hard coded limit in the kernel so we abide by it.

    if (_badApplications.GetCount() < (MAXIMUM_WAIT_OBJECTS - INDEX_RESERVED))
    {
        BOOL                    fResult;
        BAD_APPLICATION_INFO    badApplicationInfo;

        //  Duplicate the HANDLE with SYNCHRONIZE access. That's
        //  all we need to call the wait function.

        fResult = DuplicateHandle(GetCurrentProcess(),
                                  hProcess,
                                  GetCurrentProcess(),
                                  &badApplicationInfo.hProcess,
                                  SYNCHRONIZE | PROCESS_QUERY_INFORMATION,
                                  FALSE,
                                  0);
        if (fResult != FALSE)
        {
            PROCESS_SESSION_INFORMATION     processSessionInformation;
            ULONG                           ulReturnLength;

            //  Add the information to the list.

            badApplicationInfo.bamType = bamType;
            badApplicationInfo.badApplication = badApplication;
            status = NtQueryInformationProcess(badApplicationInfo.hProcess,
                                               ProcessSessionInformation,
                                               &processSessionInformation,
                                               sizeof(processSessionInformation),
                                               &ulReturnLength);
            if (NT_SUCCESS(status))
            {
                badApplicationInfo.dwSessionID = processSessionInformation.SessionId;
                status = _badApplications.Add(&badApplicationInfo);
                if (NT_SUCCESS(status))
                {
                    status = _hEvent.Set();
                }
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::QueryInformation
//
//  Arguments:  badApplication  =   Bad application identifier to query.
//              hProcess        =   Handle to running process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Finds the given application in the running bad application
//              list and returns a duplicated handle to the caller.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::QueryInformation (const CBadApplication& badApplication, HANDLE& hProcess)

{
    NTSTATUS                    status;
    bool                        fResult;
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    //  Assume failure
    
    hProcess = NULL;
    status = STATUS_OBJECT_NAME_NOT_FOUND;

    fResult = false;

    //  Loop looking for a match. This uses the overloaded operator ==.

    for (i = _badApplications.GetCount() - 1; !fResult && (i >= 0); --i)
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
        {

            //  Make sure the client is not in the same session as the running
            //  bad application. This API exists to prevent cross session instances.
            //  It's assumed that applications have their own mechanisms for multiple
            //  instances in the same session (or object name space).

            fResult = (badApplicationInfo.badApplication == badApplication);
            if (fResult)
            {
                if (DuplicateHandle(GetCurrentProcess(),
                                    badApplicationInfo.hProcess,
                                    GetCurrentProcess(),
                                    &hProcess,
                                    0,
                                    FALSE,
                                    DUPLICATE_SAME_ACCESS) != FALSE)
                {
                    status = STATUS_SUCCESS;
                }
                else
                {
                    status = CStatusCode::StatusCodeOfLastError();
                }
            }
        }
    }

    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::RequestSwitchUser
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute terminate of BAM_TYPE_SWITCH_USER. These appications
//              are really poorly behaved. A good example is a DVD player
//              which bypasses GDI and draws directly into the VGA stream.
//
//              Try to kill these and reject the request if it fails.
//
//  History:    2000-11-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::RequestSwitchUser (void)

{
    NTSTATUS    status;
    int         i;

    //  Walk the _badApplications list.

    status = STATUS_SUCCESS;
    _lock.Acquire();
    i = _badApplications.GetCount() - 1;
    while (NT_SUCCESS(status) && (i >= 0))
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
        {

            //  Look for BAM_TYPE_SWITCH_USER processes. It doesn't matter
            //  what session ID is tagged. This process is getting terminated.

            if (badApplicationInfo.bamType == BAM_TYPE_SWITCH_USER)
            {

                //  In any case release the lock, kill the process
                //  remove it from the watch list. Then reset the
                //  index back to the end of the list. Make sure to
                //  account for the "--i;" instruction below by not
                //  decrementing by 1.

                _lock.Release();
                status = PerformTermination(badApplicationInfo.hProcess, false);
                _lock.Acquire();
                i = _badApplications.GetCount();
            }
        }
        --i;
    }
    _lock.Release();
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::PerformTermination
//
//  Arguments:  hProcess        =   Handle to running process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Terminates the given process. This is a common routine used
//              by both the internal wait thread of this class as well as
//              externally by bad application server itself.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::PerformTermination (HANDLE hProcess, bool fAllowForceTerminate)

{
    NTSTATUS    status;

    status = TerminateGracefully(hProcess);
    if (!NT_SUCCESS(status) && fAllowForceTerminate)
    {
        status = TerminateForcibly(hProcess);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Watcher thread for process objects. This thread builds the
//              array of proces handles to wait on as well as including the
//              synchronization event that gets signaled by the Add member
//              function. When that event is signaled the wait is re-executed
//              with the new array of objects to wait on.
//
//              When a process object is signaled it is cleared out of the
//              known list to allow further creates to succeed.
//
//              Acquisition of the critical section is carefully placed in
//              this function so that the critical section is not held when
//              the wait call is made.
//
//              Added to this is a window and a message pump to enable
//              listening for session notifications from terminal server.
//
//  History:    2000-08-25  vtan        created
//              2000-10-23  vtan        added HWND message pump mechanism
//  --------------------------------------------------------------------------

DWORD   CBadApplicationManager::Entry (void)

{
    WNDCLASSEX  wndClassEx;

    //  Register this window class.

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(WNDCLASSEX);
    wndClassEx.lpfnWndProc = NotificationWindowProc;
    wndClassEx.hInstance = _hInstance;
    wndClassEx.lpszClassName = TEXT("BadApplicationNotificationWindowClass");
    _atom = RegisterClassEx(&wndClassEx);

    //  Create the notification window

    _hwnd = CreateWindow(MAKEINTRESOURCE(_atom),
                         TEXT("BadApplicationNotificationWindow"),
                         WS_OVERLAPPED,
                         0, 0,
                         0, 0,
                         NULL,
                         NULL,
                         _hInstance,
                         this);

    if (_hwnd != NULL)
    {
        _fRegisteredNotification = (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_ALL_SESSIONS) != FALSE);
        if (!_fRegisteredNotification)
        {
            _hModule = LoadLibrary(TEXT("shsvcs.dll"));
            if (_hModule != NULL)
            {
                DWORD   dwThreadID;
                HANDLE  hThread;

                //  If the register fails then create a thread to wait on the event
                //  and then register onces it's available. If the thread cannot be
                //  created it's no biggy. The notification mechanism fails and the
                //  welcome screen isn't updated.

                AddRef();
                hThread = CreateThread(NULL,
                                       0,
                                       RegisterThreadProc,
                                       this,
                                       0,
                                       &dwThreadID);
                if (hThread != NULL)
                {
                    TBOOL(CloseHandle(hThread));
                }
                else
                {
                    Release();
                    TBOOL(FreeLibrary(_hModule));
                    _hModule = NULL;
                }
            }
        }
    }

    //  Acquire the lock. This is necessary because to fill the array of
    //  handles to wait on requires access to the internal list.

    _lock.Acquire();
    do
    {
        DWORD                   dwWaitResult;
        int                     i, iLimit;
        BAD_APPLICATION_INFO    badApplicationInfo;
        HANDLE                  hArray[MAXIMUM_WAIT_OBJECTS];

        ZeroMemory(&hArray, sizeof(hArray));
        hArray[INDEX_EVENT] = _hEvent;
        iLimit = _badApplications.GetCount();
        for (i = 0; i < iLimit; ++i)
        {
            if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
            {
                hArray[INDEX_HANDLES + i] = badApplicationInfo.hProcess;
            }
        }

        //  Release the lock before we enter the wait state.
        //  Wait on ANY of the objects to be signaled.

        _lock.Release();
        dwWaitResult = MsgWaitForMultipleObjects(INDEX_HANDLES + iLimit,
                                                 hArray,
                                                 FALSE,
                                                 INFINITE,
                                                 QS_ALLINPUT);
        ASSERTMSG(dwWaitResult != WAIT_FAILED, "WaitForMultipleObjects failed in CBadApplicationManager::Entry");

        //  We were woken up by an object being signaled. Is this the
        //  synchronization object?

        dwWaitResult -= WAIT_OBJECT_0;
        if (dwWaitResult == INDEX_EVENT)
        {

            //  Yes. Acquire the lock. Reset the synchronization event. It's
            //  important to acquire the lock before resetting the event because
            //  the Add function could have the lock and be adding to the list.
            //  Once the Add function releases the lock it cannot signal the event.
            //  Otherwise we could reset the event during the Add function adding
            //  a new object and this would be missed.

            _lock.Acquire();
            TSTATUS(_hEvent.Reset());
        }

        //  No. Is this a message that requires dispatching as part of the
        //  message pump?

        else if (dwWaitResult == WAIT_OBJECT_0 + INDEX_HANDLES + static_cast<DWORD>(iLimit))
        {

            //  Yes. Remove the message from the message queue and dispatch it.

            MSG     msg;

            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
            {
                (BOOL)TranslateMessage(&msg);
                (LRESULT)DispatchMessage(&msg);
            }
            _lock.Acquire();
        }
        else
        {

            //  No. One of the bad applications we are watching has terminated
            //  and its proces object is now signaled. Go to the correct index
            //  in the array. Acquire the lock. Close the HANDLE. It's not needed
            //  anymore. Then remove the entry from the list.

            dwWaitResult -= INDEX_HANDLES;
            _lock.Acquire();
            if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, dwWaitResult)))
            {
                TBOOL(CloseHandle(badApplicationInfo.hProcess));
            }
            TSTATUS(_badApplications.Remove(dwWaitResult));
        }

        //  At this point we still hold the lock. This is important because the top
        //  of the loop expects the lock to be held to build the HANDLE array.

    } while (!_fTerminateWatcherThread);

    //  Clean up stuff that happened on this thread.

    Cleanup();

    //  If we here then the thread is being terminated for some reason.
    //  Release the lock. It doesn't matter what happens now anyway.

    _lock.Release();
    return(0);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::TerminateForcibly
//
//  Arguments:  hProcess    =   Process to terminate.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Inject a user mode thread into the process which calls
//              kernel32!ExitProcess. If the thread injection fails then fall
//              back to kernel32!TerminatProcess to force in.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::TerminateForcibly (HANDLE hProcess)

{
    NTSTATUS    status;
    HANDLE      hProcessTerminate;

    //  Duplicate the process handle and request all the access required
    //  to create a remote thread in the process.

    if (DuplicateHandle(GetCurrentProcess(),
                        hProcess,
                        GetCurrentProcess(),
                        &hProcessTerminate,
                        SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                        FALSE,
                        0) != FALSE)
    {
        DWORD   dwWaitResult;
        HANDLE  hThread, hWaitArray[2];

        //  Go and create the remote thread that immediately turns
        //  around and calls kernel32!ExitProcess. This allows
        //  a clean process shutdown to occur. If this times out
        //  then kill the process with terminate process.

        status = RtlCreateUserThread(hProcessTerminate,
                                     NULL,
                                     FALSE,
                                     0,
                                     0,
                                     0,
                                     reinterpret_cast<PUSER_THREAD_START_ROUTINE>(ExitProcess),
                                     NULL,
                                     &hThread,
                                     NULL);
        if (NT_SUCCESS(status))
        {

            hWaitArray[0] = hThread;
            hWaitArray[1] = hProcessTerminate;
            dwWaitResult = WaitForMultipleObjects(ARRAYSIZE(hWaitArray),
                                                  hWaitArray,
                                                  TRUE,
                                                  5000);
            TBOOL(CloseHandle(hThread));
            if (dwWaitResult != WAIT_TIMEOUT)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_TIMEOUT;
            }
        }
        if (status != STATUS_SUCCESS)
        {
            if (TerminateProcess(hProcessTerminate, 0) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
        }
        TBOOL(CloseHandle(hProcessTerminate));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::TerminateGracefully
//
//  Arguments:  hProcess    =   Process to terminate.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates a rundll32 process on the session of the target
//              process in WinSta0\Default which will re-enter this dll and
//              call the "terminate" functionality. This allows the process to
//              walk the window list corresponding to that session and send
//              those windows close messages and wait for graceful
//              termination.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::TerminateGracefully (HANDLE hProcess)

{
    NTSTATUS                    status;
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &processBasicInformation,
                                       sizeof(processBasicInformation),
                                       &ulReturnLength);
    if (NT_SUCCESS(status))
    {
        HANDLE  hToken;

        if (OpenProcessToken(hProcess,
                             TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY,
                             &hToken) != FALSE)
        {
            STARTUPINFOW            startupInfo;
            PROCESS_INFORMATION     processInformation;
            WCHAR                   szCommandLine[MAX_PATH];

            ZeroMemory(&startupInfo, sizeof(startupInfo));
            ZeroMemory(&processInformation, sizeof(processInformation));
            startupInfo.cb = sizeof(startupInfo);
            startupInfo.lpDesktop = const_cast<WCHAR*>(s_szDefaultDesktop);
            wsprintfW(szCommandLine, L"rundll32 shsvcs.dll,FUSCompatibilityEntry terminate %d", static_cast<DWORD>(processBasicInformation.UniqueProcessId));
            if (CreateProcessAsUserW(hToken,
                                     NULL,
                                     szCommandLine,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     0,
                                     NULL,
                                     NULL,
                                     &startupInfo,
                                     &processInformation) != FALSE)
            {
                DWORD   dwWaitResult;
                HANDLE  hArray[2];

                //  Assume that this whole thing failed.

                status = STATUS_UNSUCCESSFUL;
                TBOOL(CloseHandle(processInformation.hThread));

                //  Wait on both process objects. If the process to be terminated
                //  is signaled then the rundll32 stub did its job. If the rundll32
                //  stub is signaled then find out what its exit code is and either
                //  continue waiting on the process to be terminated or return back
                //  a code to the caller indicating success or failure. Failure
                //  forces the process to be terminated abruptly.

                hArray[0] = hProcess;
                hArray[1] = processInformation.hProcess;
                dwWaitResult = WaitForMultipleObjects(ARRAYSIZE(hArray),
                                                      hArray,
                                                      FALSE,
                                                      10000);

                //  If the process to be terminated is signaled then we're done.

                if (dwWaitResult == WAIT_OBJECT_0)
                {
                    status = STATUS_SUCCESS;
                }

                //  If the rundll32 stub is signaled then find out what it found.

                else if (dwWaitResult == WAIT_OBJECT_0 + 1)
                {
                    DWORD   dwExitCode;

                    dwExitCode = STILL_ACTIVE;
                    if (GetExitCodeProcess(processInformation.hProcess, &dwExitCode) != FALSE)
                    {
                        ASSERTMSG((dwExitCode == CGracefulTerminateApplication::NO_WINDOWS_FOUND) || (dwExitCode == CGracefulTerminateApplication::WAIT_WINDOWS_FOUND), "Unexpected process exit code in CBadApplicationManager::TerminateGracefully");

                        //  If the rundll32 stub says it found some windows then
                        //  wait for the process to terminate itself.

                        if (dwExitCode == CGracefulTerminateApplication::WAIT_WINDOWS_FOUND)
                        {

                            //  If the process terminates within the timeout period
                            //  then we're done.

                            if (WaitForSingleObject(hProcess, 10000) == WAIT_OBJECT_0)
                            {
                                status = STATUS_SUCCESS;
                            }
                        }
                    }
                }
                TBOOL(CloseHandle(processInformation.hProcess));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseHandle(hToken));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Cleanup
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases used resources in the class. Used by both the
//              constructor and the thread - whoever wins.
//
//  History:    2000-12-12  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Cleanup (void)

{
    if (_fRegisteredNotification)
    {
        (BOOL)WinStationUnRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd);
        _fRegisteredNotification = false;
    }
    if (_hwnd != NULL)
    {
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
        _atom = 0;
    }
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Logon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Nothing at present.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Logon (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Logoff
//
//  Arguments:  dwSessionID     =   Session ID that is logging off.
//
//  Returns:    <none>
//
//  Purpose:    Remove any restore processes we have in the list. The user
//              is logging off so they shouldn't come back. Releases the last
//              user to actively connect to the machine.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Logoff (DWORD dwSessionID)

{
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    for (i = _restoreApplications.GetCount() - 1; i >= 0; --i)
    {
        CRestoreApplication     *pRestoreApplication;

        pRestoreApplication = static_cast<CRestoreApplication*>(_restoreApplications.Get(i));
        if ((pRestoreApplication != NULL) &&
            pRestoreApplication->IsEqualSessionID(dwSessionID))
        {
            TSTATUS(_restoreApplications.Remove(i));
        }
    }
    ReleaseHandle(_hTokenLastUser);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Connect
//
//  Arguments:  dwSessionID     =   Session ID connecting.
//              hToken          =   Handle to token of user connecting.
//
//  Returns:    <none>
//
//  Purpose:    Handles BAM3. This is the save for restoration all processes
//              that use resources that aren't easily shared and restore all
//              processes that were saved which aren't easily shared.
//
//              It's optimized for not closing the processes of the same user
//              should that user re-connect. This allows the screen saver to
//              kick in and return to welcome without killing the user's
//              processes unnecessarily.
//
//              Also handles BAM4.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Connect (DWORD dwSessionID, HANDLE hToken)

{
    if ((_hTokenLastUser != NULL) && (hToken != NULL))
    {
        PSID                pSIDLastUser, pSIDCurrentUser;
        CTokenInformation   tokenLastUser(_hTokenLastUser);
        CTokenInformation   tokenCurrentUser(hToken);

        pSIDLastUser = tokenLastUser.GetUserSID();
        pSIDCurrentUser = tokenCurrentUser.GetUserSID();
        if ((pSIDLastUser != NULL) && (pSIDCurrentUser != NULL) && !EqualSid(pSIDLastUser, pSIDCurrentUser))
        {
            int                     i;
            DWORD                   dwSessionIDMatch;
            ULONG                   ulReturnLength;
            CRestoreApplication     *pRestoreApplication;

            if (NT_SUCCESS(NtQueryInformationToken(_hTokenLastUser,
                                                   TokenSessionId,
                                                   &dwSessionIDMatch,
                                                   sizeof(dwSessionIDMatch),
                                                   &ulReturnLength)))
            {

                //  Walk the _badApplications list.

                _lock.Acquire();
                i = _badApplications.GetCount() - 1;
                while (i >= 0)
                {
                    BAD_APPLICATION_INFO    badApplicationInfo;

                    if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
                    {
                        bool    fTerminateProcess;

                        fTerminateProcess = false;

                        //  Look for BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE processes
                        //  which have token session IDs that match the _hTokenLastUser
                        //  session ID. These processes must be terminated and added to
                        //  a list to be restarted on reconnection.

                        if ((badApplicationInfo.bamType == BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE) &&
                            (badApplicationInfo.dwSessionID == dwSessionIDMatch))
                        {
                            pRestoreApplication = new CRestoreApplication;
                            if (pRestoreApplication != NULL)
                            {
                                if (NT_SUCCESS(pRestoreApplication->GetInformation(badApplicationInfo.hProcess)))
                                {
                                    TSTATUS(_restoreApplications.Add(pRestoreApplication));
                                    fTerminateProcess = true;
                                }
                                pRestoreApplication->Release();
                            }
                        }

                        //  Look for BAM_TYPE_SWITCH_TO_NEW_USER (even though this is
                        //  a connect/reconnect). Always kill these processes.

                        if (badApplicationInfo.bamType == BAM_TYPE_SWITCH_TO_NEW_USER)
                        {
                            fTerminateProcess = true;
                        }
                        if (fTerminateProcess)
                        {

                            //  In any case release the lock, kill the process
                            //  remove it from the watch list. Then reset the
                            //  index back to the end of the list. Make sure to
                            //  account for the "--i;" instruction below by not
                            //  decrementing by 1.

                            _lock.Release();
                            TSTATUS(PerformTermination(badApplicationInfo.hProcess, true));
                            _lock.Acquire();
                            TBOOL(CloseHandle(badApplicationInfo.hProcess));
                            TSTATUS(_badApplications.Remove(i));
                            i = _badApplications.GetCount();
                        }
                    }
                    --i;
                }
                _lock.Release();
            }

            //  Now walk the restore list looking for matches against the
            //  connecting session ID. Restore these processes.

            _lock.Acquire();
            i = _restoreApplications.GetCount() - 1;
            while (i >= 0)
            {
                pRestoreApplication = static_cast<CRestoreApplication*>(_restoreApplications.Get(i));
                if ((pRestoreApplication != NULL) &&
                    pRestoreApplication->IsEqualSessionID(dwSessionID))
                {
                    HANDLE  hProcess;

                    _lock.Release();
                    if (NT_SUCCESS(pRestoreApplication->Restore(&hProcess)))
                    {
                        CBadApplication     badApplication(pRestoreApplication->GetCommandLine());

                        TBOOL(CloseHandle(hProcess));
                    }
                    _lock.Acquire();
                    TSTATUS(_restoreApplications.Remove(i));
                    i = _restoreApplications.GetCount();
                }
                --i;
            }
            _lock.Release();
        }
    }
    if (hToken != NULL)
    {
        _dwSessionIDLastConnect = static_cast<DWORD>(-1);
    }
    else
    {
        _dwSessionIDLastConnect = dwSessionID;
    }
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Disconnect
//
//  Arguments:  dwSessionID     =   Session ID that is disconnecting.
//              hToken          =   Token of the user disconnecting.
//
//  Returns:    <none>
//
//  Purpose:    If the session isn't the same as the last connected session
//              then release the last user token and save the current one.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Disconnect (DWORD dwSessionID, HANDLE hToken)

{
    if (_dwSessionIDLastConnect != dwSessionID)
    {
        ReleaseHandle(_hTokenLastUser);
        if (hToken != NULL)
        {
            TBOOL(DuplicateHandle(GetCurrentProcess(),
                                  hToken,
                                  GetCurrentProcess(),
                                  &_hTokenLastUser,
                                  0,
                                  FALSE,
                                  DUPLICATE_SAME_ACCESS));
        }
    }
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_WM_WTSSESSION_CHANGE
//
//  Arguments:  wParam  =   Type of session change.
//              lParam  =   Pointer to WTSSESSION_NOTIFICATION struct.
//
//  Returns:    LRESULT
//
//  Purpose:    Handles WM_WTSSESSION_CHANGE messages.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CBadApplicationManager::Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam)

{
    ULONG                       ulReturnLength;
    WINSTATIONUSERTOKEN         winStationUserToken;

    winStationUserToken.ProcessId = reinterpret_cast<HANDLE>(GetCurrentProcessId());
    winStationUserToken.ThreadId = reinterpret_cast<HANDLE>(GetCurrentThreadId());
    winStationUserToken.UserToken = NULL;
    (BOOLEAN)WinStationQueryInformation(SERVERNAME_CURRENT,
                                        lParam,
                                        WinStationUserToken,
                                        &winStationUserToken,
                                        sizeof(winStationUserToken),
                                        &ulReturnLength);
    switch (wParam)
    {
        case WTS_SESSION_LOGOFF:
            Handle_Logoff(lParam);
            break;
        case WTS_SESSION_LOGON:
            Handle_Logon();
            //  Fall thru to connect case.
        case WTS_CONSOLE_CONNECT:
        case WTS_REMOTE_CONNECT:
            Handle_Connect(lParam, winStationUserToken.UserToken);
            break;
        case WTS_CONSOLE_DISCONNECT:
        case WTS_REMOTE_DISCONNECT:
            Handle_Disconnect(lParam, winStationUserToken.UserToken);
            break;
        default:
            break;
    }
    if (winStationUserToken.UserToken != NULL)
    {
        TBOOL(CloseHandle(winStationUserToken.UserToken));
    }
    return(1);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::NotificationWindowProc
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    LRESULT
//
//  Purpose:    Handles messages for the Notification window.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

LRESULT CALLBACK    CBadApplicationManager::NotificationWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    LRESULT                 lResult;
    CBadApplicationManager  *pThis;

    pThis = reinterpret_cast<CBadApplicationManager*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT    *pCreateStruct;

            pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams));
            lResult = 0;
            break;
        }
        case WM_WTSSESSION_CHANGE:
            lResult = pThis->Handle_WM_WTSSESSION_CHANGE(wParam, lParam);
            break;
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::RegisterThreadProc
//
//  Arguments:  pParameter  =   Object pointer.
//
//  Returns:    DWORD
//
//  Purpose:    Opens the TermSrvReadyEvent and waits on it. Once ready it
//              registers for a notifications.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CBadApplicationManager::RegisterThreadProc (void *pParameter)

{
    int                     iCounter;
    HANDLE                  hTermSrvReadyEvent;
    HMODULE                 hModule;
    CBadApplicationManager  *pThis;

    pThis = reinterpret_cast<CBadApplicationManager*>(pParameter);
    hModule = pThis->_hModule;
    ASSERTMSG(hModule != NULL, "NULL HMODULE in CBadApplicationManager::RegisterThreadProc");
    iCounter = 0;
    hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE,
                                   FALSE,
                                   TEXT("TermSrvReadyEvent"));
    while ((hTermSrvReadyEvent == NULL) && (iCounter < 60))
    {
        ++iCounter;
        Sleep(1000);
        hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE,
                                       FALSE,
                                       TEXT("TermSrvReadyEvent"));
    }
    if (hTermSrvReadyEvent != NULL)
    {
        if (WaitForSingleObject(hTermSrvReadyEvent, 60000) == WAIT_OBJECT_0)
        {
            pThis->_fRegisteredNotification = (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, pThis->_hwnd, NOTIFY_FOR_ALL_SESSIONS) != FALSE);
        }
        TBOOL(CloseHandle(hTermSrvReadyEvent));
    }
    pThis->Release();
    FreeLibraryAndExitThread(hModule, 0);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationmanager.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationManager.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Classes to manage bad applications in the fast user switching environment.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationManager_
#define     _BadApplicationManager_

#include <lpcfus.h>

#include "BadApplication.h"
#include "DynamicArray.h"
#include "KernelResources.h"
#include "Thread.h"

//  --------------------------------------------------------------------------
//  CBadApplicationManager
//
//  Purpose:    Implements managing of bad applications started on this
//              machine. This object should only exist once.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

class   CBadApplicationManager : public CThread
{
    private:
        typedef struct
        {
            HANDLE                      hProcess;
            BAM_TYPE                    bamType;
            DWORD                       dwSessionID;
            CBadApplication             badApplication;
        } BAD_APPLICATION_INFO, *PBAD_APPLICATION_INFO;
    public:
                                            CBadApplicationManager (HINSTANCE hInstance);
        virtual                             ~CBadApplicationManager (void);

                NTSTATUS                    Terminate (void);
                bool                        QueryRunning (const CBadApplication& badApplication, DWORD dwSessionID);
                NTSTATUS                    RegisterRunning (const CBadApplication& badApplication, HANDLE hProcess, BAM_TYPE bamType);
                NTSTATUS                    QueryInformation (const CBadApplication& badApplication, HANDLE& hProcess);
                NTSTATUS                    RequestSwitchUser (void);

        static  NTSTATUS                    PerformTermination (HANDLE hProcess, bool fAllowForceTerminate);
    protected:
        virtual DWORD                       Entry (void);
    private:
        static  NTSTATUS                    TerminateForcibly (HANDLE hProcess);
        static  NTSTATUS                    TerminateGracefully (HANDLE hProcess);

                void                        Cleanup (void);
                void                        Handle_Logon (void);
                void                        Handle_Logoff (DWORD dwSessionID);
                void                        Handle_Connect (DWORD dwSessionID, HANDLE hToken);
                void                        Handle_Disconnect (DWORD dwSessionID, HANDLE hToken);
                LRESULT                     Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam);
        static  LRESULT CALLBACK            NotificationWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  DWORD   WINAPI              RegisterThreadProc (void *pParameter);
    private:
                HINSTANCE                   _hInstance;
                HMODULE                     _hModule;
                ATOM                        _atom;
                HWND                        _hwnd;
                bool                        _fTerminateWatcherThread,
                                            _fRegisteredNotification;
                DWORD                       _dwSessionIDLastConnect;
                HANDLE                      _hTokenLastUser;
                CCriticalSection            _lock;
                CEvent                      _hEvent;
                CDynamicArray               _badApplications;
                CDynamicCountedObjectArray  _restoreApplications;

        static  const int                   INDEX_EVENT;
        static  const int                   INDEX_HANDLES;
        static  const int                   INDEX_RESERVED;
        static  const WCHAR                 s_szDefaultDesktop[];
};

#endif  /*  _BadApplicationManager_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationService.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the bad application manager
//  service specifics.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "BadApplicationService.h"

const TCHAR     CBadApplicationService::s_szName[]   =   TEXT("FastUserSwitchingCompatibility");

//  --------------------------------------------------------------------------
//  CBadApplicationService::CBadApplicationService
//
//  Arguments:  pAPIConnection  =   CAPIConnection passed to base class.
//              pServerAPI      =   CServerAPI passed to base class.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBadApplicationService.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationService::CBadApplicationService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI) :
    CService(pAPIConnection, pServerAPI, GetName())

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationService::~CBadApplicationService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBadApplicationService.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationService::~CBadApplicationService (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationService::GetName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Returns the name of the service (ThemeService).
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CBadApplicationService::GetName (void)

{
    return(s_szName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationexports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationServerExports.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains functions exported by name from the BAM service dll.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"

#include "BadApplicationAPIServer.h"
#include "GracefulTerminateApplication.h"

extern  HINSTANCE   g_hInstance;

//  --------------------------------------------------------------------------
//  ::FUSCompatibilityEntryTerminate
//
//  Arguments:  pszCommand  =   Command line from rundll32.
//
//  Returns:    <none>
//
//  Purpose:    Internal entry point to execute termination of a specified
//              process on behalf of the BAM server. The server starts the
//              rundll32 process on the correct session so that it can find
//              the window belonging to that session.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  FUSCompatibilityEntryTerminate (const WCHAR *pszCommand)

{
    CGracefulTerminateApplication   terminateApplication;

    terminateApplication.Terminate(CBadApplicationAPIServer::StrToInt(pszCommand));
    DISPLAYMSG("Where was the call to kernel32!ExitProcess in CGracefulTerminateApplication::Terminate");
}

//  --------------------------------------------------------------------------
//  ::FUSCompatibilityEntryPrompt
//
//  Arguments:  pszCommand  =   Command line from rundll32.
//
//  Returns:    <none>
//
//  Purpose:    Internal entry point to execute a prompt for termination of
//              the parent process of this one. This is used by the BAM shim
//              for type 1. Instead of bringing up UI in the application it
//              creates a rundll32 process to call this entry point which
//              brings up UI and returns a result to the parent in the exit
//              code.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  FUSCompatibilityEntryPrompt (const WCHAR *pszCommand)

{
    CGracefulTerminateApplication::Prompt(g_hInstance, reinterpret_cast<HANDLE>(CBadApplicationAPIServer::StrToInt(pszCommand)));
    DISPLAYMSG("Where was the call to kernel32!ExitProcess in CGracefulTerminateApplication::Prompt");
}

//  --------------------------------------------------------------------------
//  ::FUSCompatibilityEntryW
//
//  Arguments:  hwndStub    =   ?
//              hInstance   =   ?
//              pszCmdLine  =   ?
//              nCmdShow    =   ?
//
//  Returns:    <none>
//
//  Purpose:    External named entry point for rundll32.exe in case of
//              external process hosting.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  FUSCompatibilityEntryW (HWND hwndStub, HINSTANCE hInstance, LPWSTR pszCmdLine, int nCmdShow)

{
    UNREFERENCED_PARAMETER(hwndStub);
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    typedef void    (WINAPI * PFNCOMMANDPROC) (const WCHAR *pszCommand);

    typedef struct
    {
        const WCHAR*    szCommand;
        PFNCOMMANDPROC  pfnCommandProc;
    } COMMAND_ENTRY, *PCOMMAND_ENTRY;

    static  const COMMAND_ENTRY     s_commands[]    =   
    {
        {   L"terminate",   FUSCompatibilityEntryTerminate  },
        {   L"prompt",      FUSCompatibilityEntryPrompt     }
    };

    int     i, iLength;
    WCHAR   szCommand[32];

    i = 0;
    iLength = lstrlenW(pszCmdLine);
    while ((i < iLength) && (pszCmdLine[i] != L' '))
    {
        ++i;
    }
    iLength = i;
    ASSERTMSG((i + sizeof('\0')) < ARRAYSIZE(szCommand), "Impending string overflow in ::BadApplicationEntryW");
    lstrcpy(szCommand, pszCmdLine);
    szCommand[iLength] = L'\0';
    for (i = 0; i < ARRAYSIZE(s_commands); ++i)
    {
        if (lstrcmpiW(s_commands[i].szCommand, szCommand) == 0)
        {
            const WCHAR     *pszParameter;

            pszParameter = pszCmdLine + iLength;
            if (pszCmdLine[iLength] == L' ')
            {
                ++pszParameter;
            }
            s_commands[i].pfnCommandProc(pszParameter);
        }
    }
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationdispatcher.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationDispatcher.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  request dispatch handling.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationDispatcher_
#define     _BadApplicationDispatcher_

#include "APIDispatcher.h"
#include "PortMessage.h"

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher
//
//  Purpose:    This sub-class implements CAPIDispatcher::QueueRequest to
//              create a CBadApplicationRequest which knows how to handle
//              API requests for the bad application manager.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CBadApplicationDispatcher : public CAPIDispatcher
{
    private:
                                CBadApplicationDispatcher (void);
    public:
                                CBadApplicationDispatcher (HANDLE hClientProcess);
        virtual                 ~CBadApplicationDispatcher (void);

        virtual NTSTATUS        CreateAndQueueRequest (const CPortMessage& portMessage);
        virtual NTSTATUS        CreateAndExecuteRequest (const CPortMessage& portMessage);
};

#endif  /*  _BadApplicationDispatcher_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationdispatcher.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationDispatcher.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  request dispatch handling.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationDispatcher.h"

#include "BadApplicationAPIRequest.h"

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::CBadApplicationDispatcher
//
//  Arguments:  hClientProcess  =   HANDLE to the client process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationDispatcher class. This
//              stores the client handle. It does not duplicate it.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationDispatcher::CBadApplicationDispatcher (HANDLE hClientProcess) :
    CAPIDispatcher(hClientProcess)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::~CBadApplicationDispatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CBadApplicationDispatcher class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationDispatcher::~CBadApplicationDispatcher (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::CreateAndQueueRequest
//
//  Arguments:  portMessage     =   PORT_MESSAGE request to queue to handler.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queues the client request to the dispatcher. Tells the
//              handler thread that there is input waiting. This function
//              knows what kind of CAPIRequest to create so that
//              CAPIRequest::Execute will work correctly.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationDispatcher::CreateAndQueueRequest(const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CQueueElement   *pQueueElement;

    pQueueElement = new CBadApplicationAPIRequest(this, portMessage);
    if (pQueueElement != NULL)
    {
        _queue.Add(pQueueElement);
        status = SignalRequestPending();
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::CreateAndExecuteRequest
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Executes the given request immediately and returns the result
//              back to the caller. The API request is done on the server
//              listen thread.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationDispatcher::CreateAndExecuteRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CAPIRequest     *pAPIRequest;

    pAPIRequest = new CBadApplicationAPIRequest(this, portMessage);
    if (pAPIRequest != NULL)
    {
        status = Execute(pAPIRequest);
        delete pAPIRequest;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\badapplicationservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationService.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the bad application manager
//  service specifics.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationService_
#define     _BadApplicationService_

#include "Service.h"

//  --------------------------------------------------------------------------
//  CBadApplicationService
//
//  Purpose:    Implements bad application manager server specific
//              functionality to the CService class.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

class   CBadApplicationService : public CService
{
    private:
                                CBadApplicationService (void);
    public:
                                CBadApplicationService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI);
        virtual                 ~CBadApplicationService (void);
    public:
        static  const TCHAR*    GetName (void);
    private:
        static  const TCHAR     s_szName[];
};

#endif  /*  _BadApplicationService_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\gracefulterminateapplication.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: GracefulTerminateApplication.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager terminating applications gracefully.
//
//  History:    2000-10-27  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "GracefulTerminateApplication.h"

#include "KernelResources.h"
#include "Thread.h"
#include "WarningDialog.h"

//  --------------------------------------------------------------------------
//  CProgressDialog
//
//  Purpose:    A class to manage displaying a progress dialog on a separate
//              thread if a certain period of time elapses. This is so that
//              in case the process doesn't terminate in a period of time
//              a dialog indicating wait is shown so the user is not left
//              staring at a blank screen.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

class   CProgressDialog : public CThread
{
    private:
                                    CProgressDialog (void);
    public:
                                    CProgressDialog (CWarningDialog *pWarningDialog);
        virtual                     ~CProgressDialog (void);

                void                SignalTerminated (void);
    protected:
        virtual DWORD               Entry (void);
    private:
                CWarningDialog*     _pWarningDialog;
                CEvent              _event;
};

//  --------------------------------------------------------------------------
//  CProgressDialog::CProgressDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CProgressDialog. Keeps a reference to the
//              given CWarningDialog.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

CProgressDialog::CProgressDialog (CWarningDialog *pWarningDialog) :
    _pWarningDialog(NULL),
    _event(NULL)

{
    if (IsCreated())
    {
        pWarningDialog->AddRef();
        _pWarningDialog = pWarningDialog;
        Resume();
    }
}

//  --------------------------------------------------------------------------
//  CProgressDialog::~CProgressDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the CWarningDialog reference.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

CProgressDialog::~CProgressDialog (void)

{
    _pWarningDialog->Release();
    _pWarningDialog = NULL;
}

//  --------------------------------------------------------------------------
//  CProgressDialog::SignalTerminated
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Signals the internal event that the process being watched is
//              termination. This is necessary because there is no handle to
//              the actual process to watch as it's kept on the server side
//              and not given to us the client. However, the result of the
//              termination is. Signaling this object will release the waiting
//              thread and cause it to exit.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

void    CProgressDialog::SignalTerminated (void)

{
    TSTATUS(_event.Set());
}

//  --------------------------------------------------------------------------
//  CProgressDialog::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Thread which waits for the internal event to be signaled. If
//              the event is signaled it will "cancel" the 3 second wait and
//              the thread will exit. Otherwise the wait times out and the
//              progress dialog is shown - waiting for termination.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

DWORD   CProgressDialog::Entry (void)

{
    DWORD   dwWaitResult;

    //  Wait for the event to be signaled or for it to timeout. If signaled
    //  then the process is terminated and no progress is required. Otherwise
    //  prepare to show progress while the process is being terminated.

    if (NT_SUCCESS(_event.Wait(2000, &dwWaitResult)) && (WAIT_TIMEOUT == dwWaitResult))
    {
        _pWarningDialog->ShowProgress(100, 7500);
    }
    return(0);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::CGracefulTerminateApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CGracefulTerminateApplication.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

CGracefulTerminateApplication::CGracefulTerminateApplication (void) :
    _dwProcessID(0),
    _fFoundWindow(false)

{
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::~CGracefulTerminateApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CGracefulTerminateApplication.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

CGracefulTerminateApplication::~CGracefulTerminateApplication (void)

{
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::Terminate
//
//  Arguments:  dwProcessID     =   Process ID of process to terminate.
//
//  Returns:    <none>
//
//  Purpose:    Walk the window list for top level windows that correspond
//              to this process ID and are visible. Close them. The callback
//              handles the work and this function returns the result in the
//              process exit code which the server examines.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

void    CGracefulTerminateApplication::Terminate (DWORD dwProcessID)

{
    DWORD   dwExitCode;

    _dwProcessID = dwProcessID;
    TBOOL(EnumWindows(EnumWindowsProc, reinterpret_cast<LPARAM>(this)));
    if (_fFoundWindow)
    {
        dwExitCode = WAIT_WINDOWS_FOUND;
    }
    else
    {
        dwExitCode = NO_WINDOWS_FOUND;
    }
    ExitProcess(dwExitCode);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::Prompt
//
//  Arguments:  hInstance   =   HINSTANCE of this DLL.
//              hProcess    =   Inherited handle to parent process.
//
//  Returns:    <none>
//
//  Purpose:    Shows a prompt that handles termination of the parent of this
//              process. The parent is assumed to be a bad application type 1
//              that caused this stub to be executed via the
//              "rundll32 shsvcs.dll,FUSCompatibilityEntry prompt" command.
//              Because there can only be a single instance of the type 1
//              application running and the parent of this process hasn't
//              registered yet querying for this process by image name will
//              always find the correct process.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

void    CGracefulTerminateApplication::Prompt (HINSTANCE hInstance, HANDLE hProcess)

{
    bool                        fTerminated;
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    //  Read the parent's image name from the RTL_USER_PROCESS_PARAMETERS.

    fTerminated = false;
    if (hProcess != NULL)
    {
        if (NT_SUCCESS(NtQueryInformationProcess(hProcess,
                                                 ProcessBasicInformation,
                                                 &processBasicInformation,
                                                 sizeof(processBasicInformation),
                                                 &ulReturnLength)))
        {
            SIZE_T  dwNumberOfBytesRead;
            PEB     peb;

            if (ReadProcessMemory(hProcess,
                                  processBasicInformation.PebBaseAddress,
                                  &peb,
                                  sizeof(peb),
                                  &dwNumberOfBytesRead) != FALSE)
            {
                RTL_USER_PROCESS_PARAMETERS     processParameters;

                if (ReadProcessMemory(hProcess,
                                      peb.ProcessParameters,
                                      &processParameters,
                                      sizeof(processParameters),
                                      &dwNumberOfBytesRead) != FALSE)
                {
                    WCHAR   *pszImageName;

                    pszImageName = (WCHAR*)LocalAlloc(LMEM_FIXED, processParameters.ImagePathName.Length + sizeof(WCHAR));  // sizeof(WCHAR) for null terminator
                    if (pszImageName != NULL)
                    {
                        if (ReadProcessMemory(hProcess,
                                              processParameters.ImagePathName.Buffer,
                                              pszImageName,
                                              processParameters.ImagePathName.Length,
                                              &dwNumberOfBytesRead) != FALSE)
                        {
                            pszImageName[processParameters.ImagePathName.Length / sizeof(WCHAR)] = L'\0';

                            //  And show a prompt for this process.

                            fTerminated = ShowPrompt(hInstance, pszImageName);
                        }
                        
                        LocalFree(pszImageName);
                    }
                }
            }
        }
        TBOOL(CloseHandle(hProcess));
    }
    ExitProcess(fTerminated);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::ShowPrompt
//
//  Arguments:  hInstance       =   HINSTANCE of this DLL.
//              pszImagename    =   Image name of process to terminate.
//
//  Returns:    bool
//
//  Purpose:    Shows the appropriate prompt for termination of the first
//              instance of a BAM type 1 process. If the current user does
//              not have administrator privileges then a "STOP" dialog is
//              shown that the user must get the other user to close the
//              program. Otherwise the "PROMPT" dialog is shown which gives
//              the user the option to terminate the process.
//
//              If termination is requested and the termatinion fails the
//              another warning dialog to that effect is shown.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CGracefulTerminateApplication::ShowPrompt (HINSTANCE hInstance, const WCHAR *pszImageName)

{
    bool                            fTerminated;
    ULONG                           ulConnectionInfoLength;
    HANDLE                          hPort;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[32];

    fTerminated = false;
    RtlInitUnicodeString(&portName, FUS_PORT_NAME);
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    if (NT_SUCCESS(NtConnectPort(&hPort,
                                 &portName,
                                 &sqos,
                                 NULL,
                                 NULL,
                                 NULL,
                                 szConnectionInfo,
                                 &ulConnectionInfoLength)))
    {
        bool            fCanTerminateFirstInstance;
        CWarningDialog  *pWarningDialog;
        WCHAR           szUser[256];

        //  Get the user's privilege level for this operation. This API also
        //  returns the current user for the BAM type 1 process.

        fCanTerminateFirstInstance = CanTerminateFirstInstance(hPort, pszImageName, szUser, ARRAYSIZE(szUser));
        pWarningDialog = new CWarningDialog(hInstance, NULL, pszImageName, szUser);
        if (pWarningDialog != NULL)
        {

            //  Show the appropriate dialog based on the privilege level.

            if (pWarningDialog->ShowPrompt(fCanTerminateFirstInstance) == IDOK)
            {
                CProgressDialog     *pProgressDialog;

                //  Create a progress dialog object in case of delayed termination.
                //  This will create the watcher thread.

                pProgressDialog = new CProgressDialog(pWarningDialog);
                if ((pProgressDialog != NULL) && !pProgressDialog->IsCreated())
                {
                    pProgressDialog->Release();
                    pProgressDialog = NULL;
                }

                //  Attempt to terminate the process if requested by the user.

                fTerminated = TerminatedFirstInstance(hPort, pszImageName);

                //  Once this function returns signal the event (in case the
                //  thread is still waiting). If the thread is still waiting this
                //  effectively cancels the dialog. Either way if the dialog is
                //  shown then close it, wait for the thread to exit and release
                //  the reference to destroy the object.

                if (pProgressDialog != NULL)
                {
                    pProgressDialog->SignalTerminated();
                    pWarningDialog->CloseDialog();
                    pProgressDialog->WaitForCompletion(INFINITE);
                    pProgressDialog->Release();
                }

                //  If there was some failure then let the user know.

                if (!fTerminated)
                {
                    pWarningDialog->ShowFailure();
                }
            }
            pWarningDialog->Release();
        }
        TBOOL(CloseHandle(hPort));
    }
    return(fTerminated);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::CanTerminateFirstInstance
//
//  Arguments:  hPort           =   Port to server.
//              pszImageName    =   Image name of process to terminate.
//              pszUser         =   User of process (returned).
//              cchUser         =   Count of characters for buffer.
//
//  Returns:    bool
//
//  Purpose:    Asks the server whether the current user has privileges to
//              terminate the BAM type 1 process of the given image name
//              which is known to be running. The API returns whether the
//              operation is allowed and who the current user of the process
//              is.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CGracefulTerminateApplication::CanTerminateFirstInstance (HANDLE hPort, const WCHAR *pszImageName, WCHAR *pszUser, int cchUser)

{
    bool    fCanTerminate;

    fCanTerminate = false;
    if ((hPort != NULL) && (pszImageName != NULL))
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_QUERYUSERPERMISSION;
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.pszImageName = pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.cchImageName = lstrlen(pszImageName) + sizeof('\0');
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.pszUser = pszUser;
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.cchUser = cchUser;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        if (NT_SUCCESS(NtRequestWaitReplyPort(hPort, &portMessageIn.portMessage, &portMessageOut.portMessage)) &&
            NT_SUCCESS(portMessageOut.apiBAM.apiGeneric.status))
        {
            fCanTerminate = portMessageOut.apiBAM.apiSpecific.apiQueryUserPermission.out.fCanShutdownApplication;
            pszUser[cchUser - sizeof('\0')] = L'\0';
        }
        else
        {
            pszUser[0] = L'\0';
        }
    }
    return(fCanTerminate);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::TerminatedFirstInstance
//
//  Arguments:  hPort           =   Port to server.
//              pszImageName    =   Image name to terminate.
//
//  Returns:    bool
//
//  Purpose:    Asks the server to terminate the first running instance of the
//              BAM type 1 process.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CGracefulTerminateApplication::TerminatedFirstInstance (HANDLE hPort, const WCHAR *pszImageName)

{
    bool    fTerminated;

    fTerminated = false;
    if (hPort != NULL)
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_TERMINATERUNNING;
        portMessageIn.apiBAM.apiSpecific.apiTerminateRunning.in.pszImageName = pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiTerminateRunning.in.cchImageName = lstrlen(pszImageName) + sizeof('\0');
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        if (NT_SUCCESS(NtRequestWaitReplyPort(hPort, &portMessageIn.portMessage, &portMessageOut.portMessage)) &&
            NT_SUCCESS(portMessageOut.apiBAM.apiGeneric.status))
        {
            fTerminated = portMessageOut.apiBAM.apiSpecific.apiTerminateRunning.out.fResult;
        }
    }
    return(fTerminated);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::EnumWindowsProc
//
//  Arguments:  See the platform SDK under EnumWindowsProc.
//
//  Returns:    See the platform SDK under EnumWindowsProc.
//
//  Purpose:    Top level window enumerator callback which compares the
//              process IDs of the windows and whether they are visible. If
//              there is a match on BOTH counts the a WM_CLOSE message is
//              posted to the window to allow a graceful termination.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

BOOL    CALLBACK    CGracefulTerminateApplication::EnumWindowsProc (HWND hwnd, LPARAM lParam)

{
    DWORD                           dwThreadID, dwProcessID;
    CGracefulTerminateApplication   *pThis;

    pThis = reinterpret_cast<CGracefulTerminateApplication*>(lParam);
    dwThreadID = GetWindowThreadProcessId(hwnd, &dwProcessID);
    if ((dwProcessID == pThis->_dwProcessID) && IsWindowVisible(hwnd))
    {
        pThis->_fFoundWindow = true;
        TBOOL(PostMessage(hwnd, WM_CLOSE, 0, 0));
    }
    return(TRUE);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\bamservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: BAMService.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the FUS service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BAMService_
#define     _BAMService_

//  --------------------------------------------------------------------------
//  CThemeService
//
//  Purpose:    Class that implements entry points for the common shell
//              service to invoke BAM service functionality.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

class   CBAMService
{
    public:
        static  BOOL        Main (DWORD dwReason);
        static  NTSTATUS    RegisterServer (void);
        static  NTSTATUS    UnregisterServer (void);
};

#endif  /*  _BAMService_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\bamservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BAMService.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the BAM service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "BAMService.h"
#include <shlwapi.h>
#include <shlwapip.h>

#include "BadApplicationAPIRequest.h"
#include "BadApplicationAPIServer.h"
#include "BadApplicationService.h"
#include "Resource.h"

extern  HINSTANCE   g_hInstance;

//  --------------------------------------------------------------------------
//  CThemeService::Main
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2000-10-12  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

BOOL CBAMService::Main (DWORD dwReason)

{
    UNREFERENCED_PARAMETER(dwReason);

    return TRUE;
}

//  --------------------------------------------------------------------------
//  ::DllRegisterServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Register entry point to allow the BAM server to install
//              itself into the registry.
//
//  History:    2000-12-04  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CBAMService::RegisterServer (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;

#ifdef _WIN64

    //  In upgrade cases for 64-bit, remove the service

    (NTSTATUS)CService::Remove(CBadApplicationService::GetName());

#else
    
    //  This is 32-bit only. Check if this is REALLY 32-bit and not 32-bit on 64-bit.
    //  This will also not be installed on any server, as it is irrelevent.

    if (!IsOS(OS_WOW6432) && !IsOS(OS_ANYSERVER))
    {
        static  const TCHAR     s_szDependencies[]  =   TEXT("TermService\0");

        //  Now install the new service by name.

        status = CService::Install(CBadApplicationService::GetName(),
                                   TEXT("%SystemRoot%\\System32\\svchost.exe -k netsvcs"),
                                   NULL,
                                   NULL,
                                   TEXT("shsvcs.dll"),
                                   s_szDependencies,
                                   TEXT("netsvcs"),
                                   TEXT("BadApplicationServiceMain"),
                                   SERVICE_DEMAND_START,
                                   g_hInstance,
                                   IDS_BAMSERVER_DISPLAYNAME,
                                   IDS_BAMSERVER_DESCRIPTION);
    }

#endif

    return(status);
}

//  --------------------------------------------------------------------------
//  ::DllUnregisterServer
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Unregister entry point to allow the BAM server to uninstall
//              itself from the registry.
//
//  History:    2000-12-04  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CBAMService::UnregisterServer (void)

{
    (NTSTATUS)CService::Remove(CBadApplicationService::GetName());
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::BadApplicationServiceMain
//
//  Arguments:  dwArgc      =   Number of arguments.
//              lpszArgv    =   Argument array.
//
//  Returns:    <none>
//
//  Purpose:    ServiceMain entry point for BAM server.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to the BAM service
//  --------------------------------------------------------------------------

#ifdef      _X86_

void    WINAPI  BadApplicationServiceMain (DWORD dwArgc, LPWSTR *lpszArgv)

{
    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    NTSTATUS    status;

    //  Because svchost doesn't unload the DLL ever we need to call static
    //  initializers here so that if the service is stopped and restarted
    //  the static member variables can be initialized. Statically destruct
    //  what was initialized. The initialize code accounts for already
    //  initialized member variables.

    status = CBadApplicationAPIRequest::StaticInitialize(g_hInstance);
    if (NT_SUCCESS(status))
    {
        CBadApplicationAPIServer    *pBadApplicationAPIServer;

        pBadApplicationAPIServer = new CBadApplicationAPIServer;
        if (pBadApplicationAPIServer != NULL)
        {
            CAPIConnection  *pAPIConnection;

            pAPIConnection = new CAPIConnection(pBadApplicationAPIServer);
            if (pAPIConnection != NULL)
            {
                CBadApplicationService  *pBadApplicationService;

                pBadApplicationService = new CBadApplicationService(pAPIConnection, pBadApplicationAPIServer);
                if (pBadApplicationService != NULL)
                {
                    static  SID_IDENTIFIER_AUTHORITY    s_SecurityWorldAuthority    =   SECURITY_WORLD_SID_AUTHORITY;

                    PSID    pSIDWorld;

                    //  Explicitly add access for S-1-1-0 <everybody> as PORT_CONNECT.

                    if (AllocateAndInitializeSid(&s_SecurityWorldAuthority,
                                                 1,
                                                 SECURITY_WORLD_RID,
                                                 0, 0, 0, 0, 0, 0, 0,
                                                 &pSIDWorld) != FALSE)
                    {
                        TSTATUS(pAPIConnection->AddAccess(pSIDWorld, PORT_CONNECT));
                        (void*)FreeSid(pSIDWorld);
                    }
                    pBadApplicationService->Start();
                    pBadApplicationService->Release();
                }
                pAPIConnection->Release();
            }
            pBadApplicationAPIServer->Release();
        }
        TSTATUS(CBadApplicationAPIRequest::StaticTerminate());
    }
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\contextactivation.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ContextActivation.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement creating, destroy and scoping a fusion activation
//  context.
//
//  History:    2000-10-09  vtan        created
//              2000-11-04  vtan        copied from winlogon
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "ContextActivation.h"

//  --------------------------------------------------------------------------
//  CContextActivation::s_hActCtx
//
//  Purpose:    The global activation context for this process.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CContextActivation::s_hActCtx   =   INVALID_HANDLE_VALUE;

//  --------------------------------------------------------------------------
//  CContextActivation::CContextActivation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Activate the global activation context for this process.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

CContextActivation::CContextActivation (void)

{
    (BOOL)ActivateActCtx(s_hActCtx, &ulCookie);
}

//  --------------------------------------------------------------------------
//  CContextActivation::~CContextActivation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Deactivates the global activation context for this process.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

CContextActivation::~CContextActivation (void)

{
    (BOOL)DeactivateActCtx(0, ulCookie);
}

//  --------------------------------------------------------------------------
//  CContextActivation::Create
//
//  Arguments:  pszPath     =   Path to the manifest.
//
//  Returns:    <none>
//
//  Purpose:    Creates an activation context for this process from a given
//              manifest. If the creation fails use NULL.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

void    CContextActivation::Create (const TCHAR *pszPath)

{
    ACTCTX  actCtx;

    ZeroMemory(&actCtx, sizeof(actCtx));
    actCtx.cbSize = sizeof(actCtx);
    actCtx.lpSource = pszPath;
    s_hActCtx = CreateActCtx(&actCtx);
    if (INVALID_HANDLE_VALUE == s_hActCtx)
    {
        s_hActCtx = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CContextActivation::Destroy
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destroy an activation context created in
//              CContextActivation::Create.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

void    CContextActivation::Destroy (void)

{
    if (s_hActCtx != NULL)
    {
        ReleaseActCtx(s_hActCtx);
        s_hActCtx = INVALID_HANDLE_VALUE;
    }
}

//  --------------------------------------------------------------------------
//  CContextActivation::HasContext
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether a fusion activation context is available.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

bool    CContextActivation::HasContext (void)

{
    return(s_hActCtx != NULL);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\gracefulterminateapplication.h ===
//  --------------------------------------------------------------------------
//  Module Name: GracefulTerminateApplication.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager terminating applications gracefully.
//
//  History:    2000-10-27  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifndef     _GracefulTerminateApplication_
#define     _GracefulTerminateApplication_

#include <lpcfus.h>

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication
//
//  Purpose:    Class that works on the user side to try to gracefully
//              terminate a bad process.
//
//  History:    2000-10-27  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

class   CGracefulTerminateApplication
{
    public:
        enum
        {
            NO_WINDOWS_FOUND    =   47647,
            WAIT_WINDOWS_FOUND  =   48517
        };
    public:
                                    CGracefulTerminateApplication (void);
                                    ~CGracefulTerminateApplication (void);

                void                Terminate (DWORD dwProcessID);
        static  void                Prompt (HINSTANCE hInstance, HANDLE hProcess);
    private:
        static  bool                ShowPrompt (HINSTANCE hInstance, const WCHAR *pszImageName);
        static  bool                CanTerminateFirstInstance (HANDLE hPort, const WCHAR *pszImageName, WCHAR *pszUser, int cchUser);
        static  bool                TerminatedFirstInstance (HANDLE hPort, const WCHAR *pszImageName);
        static  BOOL    CALLBACK    EnumWindowsProc (HWND hwnd, LPARAM lParam);
    private:
                DWORD               _dwProcessID;
                bool                _fFoundWindow;
};

#endif  /*  _GracefulTerminateApplication_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\contextactivation.h ===
//  --------------------------------------------------------------------------
//  Module Name: ContextActivation.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement creating, destroy and scoping a fusion activation
//  context.
//
//  History:    2000-10-09  vtan        created
//              2000-11-04  vtan        copied from winlogon
//  --------------------------------------------------------------------------

#ifndef     _ContextActivation_
#define     _ContextActivation_

//  --------------------------------------------------------------------------
//  CContextActivation
//
//  Purpose:    A class that handles activation context management. The
//              static functions managing context creation and destruction.
//              The member function manage context activation and
//              deactivation.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

class   CContextActivation
{
    public:
                            CContextActivation (void);
                            ~CContextActivation (void);

        static  void        Create (const TCHAR *pszPath);
        static  void        Destroy (void);
        static  bool        HasContext (void);
    private:
        static  HANDLE      s_hActCtx;
                ULONG       ulCookie;
};

#endif  /*  _ContextActivation_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\restoreapplication.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: RestoreApplication.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement holding information required to restore an application
//  and to actually restore it.
//
//  History:    2000-10-26  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "RestoreApplication.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CRestoreApplication::CRestoreApplication
//
//  Purpose:    Static const string to the user desktop..
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

const WCHAR     CRestoreApplication::s_szDefaultDesktop[]   =   L"WinSta0\\Default";

//  --------------------------------------------------------------------------
//  CRestoreApplication::CRestoreApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CRestoreApplication.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

CRestoreApplication::CRestoreApplication (void) :
    _hToken(NULL),
    _dwSessionID(static_cast<DWORD>(-1)),
    _pszCommandLine(NULL),
    _pEnvironment(NULL),
    _pszCurrentDirectory(NULL),
    _pszDesktop(NULL),
    _pszTitle(NULL),
    _dwFlags(0),
    _wShowWindow(0),
    _hStdInput(NULL),
    _hStdOutput(NULL),
    _hStdError(NULL)

{
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::~CRestoreApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CRestoreApplication. Release any resources.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

CRestoreApplication::~CRestoreApplication (void)

{
    ReleaseMemory(_pszTitle);
    ReleaseMemory(_pszDesktop);
    ReleaseMemory(_pszCurrentDirectory);
    ReleaseMemory(_pEnvironment);
    ReleaseMemory(_pszCommandLine);
    ReleaseHandle(_hToken);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetInformation
//
//  Arguments:  hProcessIn  =   Handle to the process to get information.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets information about the currently running process to
//              allow it to be re-run in the case when the user re-connects.
//              This effectively restores the process but it's not identical
//              to how it was originally run.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetInformation (HANDLE hProcessIn)

{
    NTSTATUS    status;
    HANDLE      hProcess;

    if (DuplicateHandle(GetCurrentProcess(),
                        hProcessIn,
                        GetCurrentProcess(),
                        &hProcess,
                        PROCESS_VM_READ | PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION,
                        FALSE,
                        0) != FALSE)
    {
        status = GetToken(hProcess);
        if (NT_SUCCESS(status))
        {
            status = GetSessionID(hProcess);
            if (NT_SUCCESS(status))
            {
                RTL_USER_PROCESS_PARAMETERS     processParameters;

                status = GetProcessParameters(hProcess, &processParameters);
                if (NT_SUCCESS(status))
                {
                    status = GetCommandLine(hProcess, processParameters);
                    if (NT_SUCCESS(status))
                    {
                        TSTATUS(GetEnvironment(hProcess, processParameters));
                        TSTATUS(GetCurrentDirectory(hProcess, processParameters));
                        TSTATUS(GetDesktop(hProcess, processParameters));
                        TSTATUS(GetTitle(hProcess, processParameters));
                        TSTATUS(GetFlags(hProcess, processParameters));
                        TSTATUS(GetStdHandles(hProcess, processParameters));
                    }
                }
            }
        }
        TBOOL(CloseHandle(hProcess));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::IsEqualSessionID
//
//  Arguments:  dwSessionID     =   Session ID to check.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given session ID is the same as the
//              process that needs restoration. This assists in determining
//              whether restoration is required.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

bool    CRestoreApplication::IsEqualSessionID (DWORD dwSessionID)    const

{
    return(_dwSessionID == dwSessionID);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetCommandLine
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the pointer to the internal storage for the command
//              line of the process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CRestoreApplication::GetCommandLine (void)                  const

{
    return(_pszCommandLine);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::Restore
//
//  Arguments:  phProcess   =   Receives the handle to the restored process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Restores the process whose information was gathered with
//              GetInformation to as close as possibly to the original start
//              state. Relevant information was saved off to allow an
//              effective restore.
//
//              The handle returned is optional. If requested a non-NULL
//              phProcess must be passed in and it is the caller's
//              responsibility to close that handle. If not required then
//              NULL is passed in and the handle is closed.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::Restore (HANDLE *phProcess)             const

{
    NTSTATUS                status;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInformation;

    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInformation, sizeof(processInformation));
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.lpDesktop = _pszDesktop;
    startupInfo.lpTitle = _pszTitle;
    startupInfo.dwFlags = _dwFlags;
    startupInfo.wShowWindow = _wShowWindow;
    if (ImpersonateLoggedOnUser(_hToken) != FALSE)
    {
        if (CreateProcessAsUser(_hToken,
                                NULL,
                                _pszCommandLine,
                                NULL,
                                NULL,
                                FALSE,
                                0,
                                NULL,
                                _pszCurrentDirectory,
                                &startupInfo,
                                &processInformation) != FALSE)
        {
            if (phProcess != NULL)
            {
                *phProcess = processInformation.hProcess;
            }
            else
            {
                TBOOL(CloseHandle(processInformation.hProcess));
            }
            TBOOL(CloseHandle(processInformation.hThread));
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(RevertToSelf());
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetProcessParameters
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the RTL_USER_PROCESS_PARAMETERS information from the
//              given process. Addresses in this struct belong to the given
//              process address space.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetProcessParameters (HANDLE hProcess, RTL_USER_PROCESS_PARAMETERS* pProcessParameters)

{
    NTSTATUS                    status;
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &processBasicInformation,
                                       sizeof(processBasicInformation),
                                       &ulReturnLength);
    if (NT_SUCCESS(status))
    {
        SIZE_T  dwNumberOfBytesRead;
        PEB     peb;

        if ((ReadProcessMemory(hProcess,
                               processBasicInformation.PebBaseAddress,
                               &peb,
                               sizeof(peb),
                               &dwNumberOfBytesRead) != FALSE) &&
            (ReadProcessMemory(hProcess,
                               peb.ProcessParameters,
                               pProcessParameters,
                               sizeof(*pProcessParameters),
                               &dwNumberOfBytesRead) != FALSE))
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetUnicodeString
//
//  Arguments:  hProcess    =   Handle to the process.
//              string      =   UNICODE_STRING to read from process.
//              psz         =   Received newly allocated memory for string.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the given UNICODE_STRING from the process and allocates
//              memory to hold this string and copies it. The string is
//              NULL terminated.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetUnicodeString (HANDLE hProcess, const UNICODE_STRING& string, WCHAR** ppsz)

{
    NTSTATUS    status;
    WCHAR       *psz;

    // sizeof(WCHAR) is for the '\0' terminator
    psz = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, string.Length + sizeof(WCHAR)));
    if (psz != NULL)
    {
        SIZE_T  dwNumberOfBytesRead;

        if (ReadProcessMemory(hProcess,
                              string.Buffer,
                              psz,
                              string.Length,
                              &dwNumberOfBytesRead) != FALSE)
        {
            psz[string.Length / sizeof(WCHAR)] = L'\0';
            status = STATUS_SUCCESS;
        }
        else
        {
            ReleaseMemory(psz);
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    *ppsz = psz;
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetToken
//
//  Arguments:  hProcess    =   Handle to process to get token of.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores internally the token of the give process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetToken (HANDLE hProcess)

{
    NTSTATUS    status;

    if ((OpenProcessToken(hProcess,
                          TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY,
                          &_hToken) != FALSE))
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetSessionID
//
//  Arguments:  hProcess    =   Handle to the process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the session ID associated with the process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetSessionID (HANDLE hProcess)

{
    NTSTATUS                        status;
    ULONG                           ulReturnLength;
    PROCESS_SESSION_INFORMATION     processSessionInformation;

    status = NtQueryInformationProcess(hProcess,
                                       ProcessSessionInformation,
                                       &processSessionInformation,
                                       sizeof(processSessionInformation),
                                       &ulReturnLength);
    if (NT_SUCCESS(status))
    {
        _dwSessionID = processSessionInformation.SessionId;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetCommandLine
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the command line (that started the process) from the
//              given process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetCommandLine (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    return(GetUnicodeString(hProcess, processParameters.CommandLine, &_pszCommandLine));
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetEnvironment
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the environment block for the given process. Currently
//              this is NOT implemented.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetEnvironment (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    UNREFERENCED_PARAMETER(hProcess);
    UNREFERENCED_PARAMETER(processParameters);

    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetCurrentDirectory
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the current directory of the given process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetCurrentDirectory (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    return(GetUnicodeString(hProcess, processParameters.CurrentDirectory.DosPath, &_pszCurrentDirectory));
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetDesktop
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the window station and desktop that the given process
//              was started on.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetDesktop (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    NTSTATUS    status;

    status = GetUnicodeString(hProcess, processParameters.DesktopInfo, &_pszDesktop);
    if (!NT_SUCCESS(status))
    {
        _pszDesktop = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, sizeof(s_szDefaultDesktop)));
        if (_pszDesktop != NULL)
        {
            CopyMemory(_pszDesktop, s_szDefaultDesktop, sizeof(s_szDefaultDesktop));
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetTitle
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the window title used to start the given process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetTitle (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    return(GetUnicodeString(hProcess, processParameters.WindowTitle, &_pszTitle));
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetFlags
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the flags and wShowWindow used to start the given
//              process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetFlags (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    UNREFERENCED_PARAMETER(hProcess);

    _dwFlags = processParameters.WindowFlags;
    _wShowWindow = static_cast<WORD>(processParameters.ShowWindowFlags);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetStdHandles
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the standard handles that may have been used to start
//              the given process. Currently NOT implemented.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetStdHandles (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    UNREFERENCED_PARAMETER(hProcess);
    UNREFERENCED_PARAMETER(processParameters);

    return(STATUS_SUCCESS);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shsrvice.inc ===
CCSHELL_DIR= $(PROJECT_ROOT)

MSC_WARNING_LEVEL=/W4

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED= $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

SHSRVICE=$(PROJECT_ROOT)\services\hdsrv
SHSRVICE_INC_PATH=$(SHSRVICE)\inc;$(SHSRVICE)\idl\$(O)

INCLUDES=                           \
         $(INCLUDES);               \
         $(TERMSRV_INC_PATH);       \
         $(DS_INC_PATH);            \
         $(PROJECT_ROOT)\services;  \
         $(SHSRVICE_INC_PATH)

# what the heck is this for?!?
!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DRBDEBUG
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\warningdialog.h ===
//  --------------------------------------------------------------------------
//  Module Name: WarningDialog.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage dialog presentation for warnings and errors on termination
//  of bad applications.
//
//  History:    2000-08-31  vtan        created
//              2000-11-04  vtan        moved from fusapi to fussrv
//  --------------------------------------------------------------------------

#ifndef     _WarningDialog_
#define     _WarningDialog_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CWarningDialog
//
//  Purpose:    Implements a class that presents warning and error dialogs in
//              the FUS client DLL.
//
//  History:    2000-08-31  vtan        created
//  --------------------------------------------------------------------------

class   CWarningDialog : public CCountedObject
{
    private:
                                        CWarningDialog (void);
    public:
                                        CWarningDialog (HINSTANCE hInstance, HWND hwndParent, const WCHAR *pszApplication, const WCHAR *pszUser);
                                        ~CWarningDialog (void);

                INT_PTR                 ShowPrompt (bool fCanShutdownApplication);
                void                    ShowFailure (void);
                void                    ShowProgress (DWORD dwTickRefresh, DWORD dwTickMaximum);

                void                    CloseDialog (void);
    private:
                void                    CenterWindow (HWND hwnd);

                void                    Handle_Prompt_WM_INITDIALOG (HWND hwnd);
        static  INT_PTR     CALLBACK    PromptDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

                void                    Handle_Progress_WM_INITDIALOG (HWND hwnd);
                void                    Handle_Progress_WM_DESTROY (HWND hwnd);
        static  INT_PTR     CALLBACK    ProgressDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  void        CALLBACK    ProgressTimerProc (HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
    private:
                HINSTANCE               _hInstance;
                HMODULE                 _hModuleComctlv6;
                HWND                    _hwndParent;
                HWND                    _hwnd;
                bool                    _fCanShutdownApplication;
                UINT                    _uiTimerID;
                DWORD                   _dwTickStart,
                                        _dwTickRefresh,
                                        _dwTickMaximum;
                WCHAR                   _szApplication[MAX_PATH];
                const WCHAR             *_pszUser;
};

#endif  /*  _WarningDialog_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\dbg.h ===
///////////////////////////////////////////////////////////////////////////////
// MISC
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG

#include <windows.h> // required to avoid error while building platform.h
#include <platform.h> // for __endexcept
#pragma warning(disable: 4127)

#endif

///////////////////////////////////////////////////////////////////////////////
// ASSERT
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
    // to use within classes that define this member fct
    #define ASSERTVALIDSTATE() _DbgAssertValidState()

    #ifdef RBDEBUG
        #ifndef _RBDEBUG_H
            #include "rbdebug.h"
        #endif

        #ifdef _X86_
            #define ASSERT(a) do { CRBDebug::Init(); if ((a)) {;} else { \
                if (RBD_ASSERT_BEEP & CRBDebug::_dwFlags) { Beep(1000, 500); } \
                else {;} \
                if (RBD_ASSERT_TRACE & CRBDebug::_dwFlags) \
                { TRACE(TF_ASSERT, TEXT("ASSERT: " TEXT(#a))); } else {;} \
                if (RBD_ASSERT_STOP &  CRBDebug::_dwFlags) { _try { _asm int 3 } \
                _except (EXCEPTION_EXECUTE_HANDLER) {;} } else {;} \
            }} while (0)
        #else
            #define ASSERT(a) do { CRBDebug::Init(); if ((a)) {;} else { \
                if (RBD_ASSERT_BEEP & CRBDebug::_dwFlags) { Beep(1000, 500); } \
                else {;} \
                if (RBD_ASSERT_TRACE & CRBDebug::_dwFlags) \
                { TRACE(TF_ASSERT, TEXT("ASSERT: " TEXT(#a))); } else {;} \
                if (RBD_ASSERT_STOP &  CRBDebug::_dwFlags) { _try { DebugBreak(); } \
                _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } else {;} \
            }} while (0)
        #endif
    #else
        #ifdef _X86_
            #define ASSERT(a) do { if ((a)) {;} else { Beep(1000, 500); \
                _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } } \
                while (0)
        #else
            #define ASSERT(a) do { if ((a)) {;} else { Beep(1000, 500); \
                _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} \
                __endexcept } } while (0)
        #endif
    #endif

#else
    #define ASSERT(a)
    #define ASSERTVALIDSTATE()
#endif

///////////////////////////////////////////////////////////////////////////////
// TRACE
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG

    #ifdef RBDEBUG
        #ifndef _RBDEBUG_H
            #include "rbdebug.h"
        #endif

        #define TRACE CRBDebug::SetTraceFileAndLine(__FILE__, __LINE__); \
            CRBDebug::TraceMsg
    #else
        #define TRACE DbgTrace
    #endif

#else
    #define TRACE   1 ? (void)0 : (void)
#endif

///////////////////////////////////////////////////////////////////////////////
// EVAL
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
    #ifdef _X86_
        #define SHOULDNOTFAIL(a) do { if ((a)) {;} else { Beep(1000, 500); \
            _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } } \
            while (0)
    #else
        #define SHOULDNOTFAIL(a) do { if ((a)) {;} else { Beep(1000, 500); \
            _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} \
            __endexcept } } while (0)
    #endif
#else
    #define SHOULDNOTFAIL(a) (a)
#endif

///////////////////////////////////////////////////////////////////////////////
// Others
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
    #define INCDEBUGCOUNTER(a) ++(a)
    #define DECDEBUGCOUNTER(a) --(a)

    #define DEBUG_ONLY(a) a

    void __cdecl DbgTrace(DWORD dwFlags, LPTSTR pszMsg, ...);
#else
    #define INCDEBUGCOUNTER(a)
    #define DECDEBUGCOUNTER(a)
    #define DEBUG_ONLY(a)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\dll\shellservicesexports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ShellServicesExports.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that exported from shsvcs.dll.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include "ServerAPI.h"
#include "BAMService.h"
#include "HDService.h"
#include "ThemeService.h"

HINSTANCE   g_hInstance     =   NULL;


STDAPI_(BOOL) _ProcessAttach()
{
    BOOL f = NT_SUCCESS(CServerAPI::StaticInitialize());
    if (!f)
        goto cleanup;

    f = CThemeService::Main(DLL_PROCESS_ATTACH);
    if (!f)
        goto cleanup1;

    f = CBAMService::Main(DLL_PROCESS_ATTACH);
    if (!f)
        goto cleanup2;

    f = CHDService::Main(DLL_PROCESS_ATTACH);
    if (!f)
        goto cleanup3;

    // success!
    goto cleanup;

cleanup3:
    CBAMService::Main(DLL_PROCESS_DETACH);
cleanup2:
    CThemeService::Main(DLL_PROCESS_DETACH);
cleanup1:
    CServerAPI::StaticTerminate();
cleanup:

    return f;
}


//  --------------------------------------------------------------------------
//  ::DllMain
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpvReserved)
{
    UNREFERENCED_PARAMETER(lpvReserved);

    BOOL f;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
#ifdef DEBUG
            __try
            {
#endif  // DEBUG

            f = _ProcessAttach();

#ifdef DEBUG
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                f = FALSE;
                OutputDebugString(TEXT("_ProcessAttach threw an unhandled exception! This should NOT happen \n"));
                DebugBreak();
            }
#endif  // DEBUG
            break;

        case DLL_PROCESS_DETACH:
            CHDService::Main(fdwReason);
            CBAMService::Main(fdwReason);
            CThemeService::Main(fdwReason);
            TSTATUS(CServerAPI::StaticTerminate());
            f = TRUE;
            break;

        default:
            f = TRUE;
            break;
    }

    return f;
}

//  --------------------------------------------------------------------------
//  ::DllInstall
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllInstall (BOOL fInstall, LPCWSTR pszCmdLine)

{
    return(CHDService::Install(fInstall, pszCmdLine));
}

//  --------------------------------------------------------------------------
//  ::DllRegisterServer
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Register entry point to allow any service to install itself
//              into the registry.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllRegisterServer (void)

{
    HRESULT     hr;
    NTSTATUS    status1, status2;

    status1 = CThemeService::RegisterServer();
    status2 = CBAMService::RegisterServer();
    hr = CHDService::RegisterServer();
    if (!NT_SUCCESS(status1))
    {
        hr = HRESULT_FROM_NT(status1);
    }
    else if (!NT_SUCCESS(status2))
    {
        hr = HRESULT_FROM_NT(status2);
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  ::DllUnregisterServer
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Unregister entry point to allow any service to uninstall
//              itself from the registry.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllUnregisterServer (void)

{
    HRESULT     hr;
    NTSTATUS    status1, status2;

    hr = CHDService::UnregisterServer();
    status2 = CBAMService::UnregisterServer();
    status1 = CThemeService::UnregisterServer();
    if (!NT_SUCCESS(status1))
    {
        hr = HRESULT_FROM_NT(status1);
    }
    else if (!NT_SUCCESS(status2))
    {
        hr = HRESULT_FROM_NT(status2);
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  ::DllCanUnloadNow
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Returns whether the DLL can unload because there are no
//              outstanding COM object references.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllCanUnloadNow (void)

{
    return(CHDService::CanUnloadNow());
}

//  --------------------------------------------------------------------------
//  ::DllGetClassObject
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Returns a constructed COM object of the specified class.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllGetClassObject (REFCLSID rclsid, REFIID riid, void** ppv)

{
    return(CHDService::GetClassObject(rclsid, riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\warningdialog.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: WarningDialog.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage dialog presentation for warnings and errors on termination
//  of bad applications.
//
//  History:    2000-08-31  vtan        created
//              2000-11-06  vtan        moved from fusapi to fussrv
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "WarningDialog.h"

#include <commctrl.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include "resource.h"

#include "ContextActivation.h"

static  const int   TEMP_STRING_SIZE    =   512;
static  const int   PROGRESS_TIMER_ID   =   48517;

//  --------------------------------------------------------------------------
//  CWarningDialog::CWarningDialog
//
//  Arguments:  hInstance       =   HINSTANCE of the hosting DLL.
//              hwndParent      =   HWND of the parenting window/dialog.
//              pszApplication  =   Path to the application known to be bad.
//              pszUser         =   User of the application known to be bad.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CWarningDialog. This stores the static
//              parameters and converts the path to a friendly display name
//              using shlwapi!SHGetFileDescriptionW. If the friendly display
//              name cannot be obtained the executable name is used.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

CWarningDialog::CWarningDialog (HINSTANCE hInstance, HWND hwndParent, const WCHAR *pszApplication, const WCHAR *pszUser) :
    _hInstance(hInstance),
    _hModuleComctlv6(NULL),
    _hwndParent(hwndParent),
    _hwnd(NULL),
    _fCanShutdownApplication(false),
    _uiTimerID(0),
    _dwTickStart(0),
    _dwTickRefresh(0),
    _dwTickMaximum(0),
    _pszUser(pszUser)

{
    UINT    uiDisplayNameCount;
    WCHAR   szTemp[MAX_PATH];

    //  Borrow winlogon's manifest. This needs to be changed to a resource
    //  within the server dll.

    static  const TCHAR     s_szLogonManifest[]  =   TEXT("WindowsLogon.manifest");

    TCHAR   szPath[MAX_PATH];

    if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)) != 0)
    {
        if ((lstrlen(szPath) + sizeof('\\') + lstrlen(s_szLogonManifest)) < ARRAYSIZE(szPath))
        {
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, s_szLogonManifest);
            CContextActivation::Create(szPath);
        }
    }

    uiDisplayNameCount = ARRAYSIZE(_szApplication);

    //  If the path is quoted then remove the quotes.

    if (pszApplication[0] == L'\"')
    {
        int     i, iStart;

        iStart = i = sizeof('\"');
        while ((pszApplication[i] != L'\"') && (pszApplication[i] != L'\0'))
        {
            ++i;
        }
        lstrcpyW(szTemp, pszApplication + iStart);
        szTemp[i - iStart] = L'\0';
    }

    //  Otherwise just copy the path as is.

    else
    {
        lstrcpyW(szTemp, pszApplication);
    }
    if (SHGetFileDescriptionW(szTemp, NULL, NULL, _szApplication, &uiDisplayNameCount) == FALSE)
    {
        const WCHAR     *pszFileName;

        pszFileName = PathFindFileNameW(szTemp);
        if (pszFileName == NULL)
        {
            pszFileName = pszApplication;
        }
        (WCHAR*)lstrcpynW(_szApplication, pszFileName, ARRAYSIZE(_szApplication));
    }

    //  Bring in comctl32.dll while the manifest is active. This will
    //  bring in comctlv6.dll which will register its window classes so
    //  the dialogs can be themed.

    if (CContextActivation::HasContext())
    {
        CContextActivation  context;

        _hModuleComctlv6 = LoadLibrary(TEXT("comctl32.dll"));
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::~CWarningDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CWarningDialog. Releases used resources.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

CWarningDialog::~CWarningDialog (void)

{
    if (_hModuleComctlv6 != NULL)
    {
        TBOOL(FreeLibrary(_hModuleComctlv6));
        _hModuleComctlv6 = NULL;
    }
    CContextActivation::Destroy();
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ShowPrompt
//
//  Arguments:  fCanShutdownApplication     =   Decides which dialog to show.
//
//  Returns:    INT_PTR
//
//  Purpose:    Displays the appropriate warning dialog to the user based
//              on their privilege level (fCanShutdownApplication).
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

INT_PTR     CWarningDialog::ShowPrompt (bool fCanShutdownApplication)

{
    CContextActivation  context;

    _fCanShutdownApplication = fCanShutdownApplication;
    return(DialogBoxParam(_hInstance,
                          MAKEINTRESOURCE(fCanShutdownApplication ? IDD_BADAPP_CLOSE : IDD_BADAPP_STOP),
                          _hwndParent,
                          PromptDialogProc,
                          reinterpret_cast<LPARAM>(this)));
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ShowFailure
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the failure to shut down the application dialog on the
//              assumption that the process cannot be terminated.
//
//  History:    2000-09-01  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::ShowFailure (void)

{
    WCHAR   *pszTemp;

    pszTemp = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, TEMP_STRING_SIZE * 3 * sizeof(TCHAR)));
    if (pszTemp != NULL)
    {
        WCHAR   *pszText, *pszCaption;

        pszText = pszTemp + TEMP_STRING_SIZE;
        pszCaption = pszText + TEMP_STRING_SIZE;
        if ((LoadString(_hInstance,
                        IDS_TERMINATEPROCESS_FAILURE,
                        pszTemp,
                        TEMP_STRING_SIZE) != 0) &&
            (LoadString(_hInstance,
                        IDS_WARNING_CAPTION,
                        pszCaption,
                        TEMP_STRING_SIZE) != 0))
        {
            LPCTSTR             pszArray[2];
            CContextActivation  context;

            pszArray[0] = _szApplication;
            pszArray[1] = _pszUser;
            (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 pszTemp,
                                 0,
                                 0,
                                 pszText,
                                 TEMP_STRING_SIZE,
                                 reinterpret_cast<va_list*>(&pszArray));
            (int)MessageBox(_hwndParent, pszText, pszCaption, MB_OK | MB_ICONERROR);
        }
        (HLOCAL)LocalFree(pszTemp);
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ShowProgress
//
//  Arguments:  dwTickRefresh   =   Number of ticks for each refresh.
//              dwTickMaximum   =   Number of ticks for the progress dialog.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the comctl32 progress control and invokes the
//              dialogs for the progress. It's self terminating after the
//              maximum number of ticks have been reached.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::ShowProgress (DWORD dwTickRefresh, DWORD dwTickMaximum)

{
    CContextActivation  context;

    INITCOMMONCONTROLSEX    iccEx;

    //  Init comctl32 to get the progress control.

    iccEx.dwSize = sizeof(iccEx);
    iccEx.dwICC = ICC_PROGRESS_CLASS;
    if (InitCommonControlsEx(&iccEx) != FALSE)
    {
        _dwTickRefresh = dwTickRefresh;
        _dwTickMaximum  = dwTickMaximum;
        (INT_PTR)DialogBoxParam(_hInstance,
                                MAKEINTRESOURCE(IDD_PROGRESS),
                                _hwndParent,
                                ProgressDialogProc,
                                reinterpret_cast<LPARAM>(this));
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::CloseDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Ends the current dialog (with IDCANCEL) if being shown. If
//              there was a timing mechanism on the dialog then make sure it
//              is visible for at least 2 seconds.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::CloseDialog (void)

{
    if (_hwnd != NULL)
    {
        if (_dwTickStart != 0)
        {
            DWORD   dwTickElapsed;

            dwTickElapsed = GetTickCount() - _dwTickStart;
            if (dwTickElapsed < 2000)
            {
                Sleep(2000 - dwTickElapsed);
            }
        }
        TBOOL(EndDialog(_hwnd, IDCANCEL));
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::CenterWindow
//
//  Arguments:  hwnd    =   HWND to center.
//
//  Returns:    <none>
//
//  Purpose:    Centers the given (assumed top level) window on the primary
//              monitor.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::CenterWindow (HWND hwnd)

{
    RECT    rc;

    TBOOL(GetWindowRect(hwnd, &rc));
    rc.left = (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2;
    rc.top  = (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 3;
    TBOOL(SetWindowPos(hwnd, HWND_TOP, rc.left, rc.top, 0, 0, SWP_NOSIZE));
    TBOOL(SetForegroundWindow(hwnd));
}

//  --------------------------------------------------------------------------
//  CWarningDialog::Handle_Prompt_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the strings in the text fields of the dialog. It
//              uses the correct dialog for the access level.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::Handle_Prompt_WM_INITDIALOG (HWND hwnd)

{
    TCHAR   *pszTemp1;

    _hwnd = hwnd;
    pszTemp1 = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, TEMP_STRING_SIZE * 2 * sizeof(TCHAR)));
    if (pszTemp1 != NULL)
    {
        TCHAR       *pszTemp2;
        LPCTSTR     pszArray[5];

        pszTemp2 = pszTemp1 + TEMP_STRING_SIZE;
        if (_fCanShutdownApplication)
        {
            (UINT)GetDlgItemText(hwnd, IDC_BADAPP_CLOSE, pszTemp1, TEMP_STRING_SIZE);
            pszArray[0] = pszArray[2] = pszArray[3] = pszArray[4] = _pszUser;
            pszArray[1] = _szApplication;
            (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 pszTemp1,
                                 0,
                                 0,
                                 pszTemp2,
                                 TEMP_STRING_SIZE,
                                 reinterpret_cast<va_list*>(&pszArray));
            TBOOL(SetDlgItemText(hwnd, IDC_BADAPP_CLOSE, pszTemp2));
        }
        else
        {
            (UINT)GetDlgItemText(hwnd, IDC_BADAPP_STOP, pszTemp1, TEMP_STRING_SIZE);
            pszArray[0] = pszArray[2] = _pszUser;
            pszArray[1] = _szApplication;
            (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 pszTemp1,
                                 0,
                                 0,
                                 pszTemp2,
                                 TEMP_STRING_SIZE,
                                 reinterpret_cast<va_list*>(&pszArray));
            TBOOL(SetDlgItemText(hwnd, IDC_BADAPP_STOP, pszTemp2));
        }
        (HLOCAL)LocalFree(pszTemp1);
    }
    _dwTickStart = 0;
    CenterWindow(hwnd);
}

//  --------------------------------------------------------------------------
//  CWarningDialog::PromptDialogProc
//
//  Arguments:  See the platform SDK under DlgProc.
//
//  Returns:    See the platform SDK under DlgProc.
//
//  Purpose:    Handles messages to the dialog. IDOK and IDCANCEL are treated
//              as IDCANCEL when incoming. IDC_BADAPP_CLOSEPROGRAM is treated
//              as IDOK back to the caller. You must tab to the button or
//              click on it to get the desired effect.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CWarningDialog::PromptDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR         iResult;
    CWarningDialog  *pThis;

    pThis = reinterpret_cast<CWarningDialog*>(GetWindowLongPtr(hwnd, DWLP_USER));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CWarningDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis->Handle_Prompt_WM_INITDIALOG(hwnd);
            iResult = TRUE;
            break;
        case WM_DESTROY:
            pThis->_hwnd = NULL;
            iResult = TRUE;
            break;
        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                case IDOK:
                    TBOOL(EndDialog(hwnd, IDCANCEL));
                    break;
                case IDC_BADAPP_CLOSEPROGRAM:
                    TBOOL(EndDialog(hwnd, IDOK));
                    break;
                default:
                    break;
            }
            iResult = TRUE;
            break;
        default:
            iResult = FALSE;
            break;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CWarningDialog::Handle_Progress_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the strings in the text fields of the dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::Handle_Progress_WM_INITDIALOG (HWND hwnd)

{
    HWND    hwndProgress;
    TCHAR   *pszTemp1;

    _hwnd = hwnd;
    pszTemp1 = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, 2048 * sizeof(TCHAR)));
    if (pszTemp1 != NULL)
    {
        TCHAR       *pszTemp2;
        LPCTSTR     pszArray[2];

        pszTemp2 = pszTemp1 + TEMP_STRING_SIZE;
        (UINT)GetDlgItemText(hwnd, IDC_PROGRESS_CLOSE, pszTemp1, TEMP_STRING_SIZE);
        pszArray[0] = _szApplication;
        pszArray[1] = _pszUser;
        (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             pszTemp1,
                             0,
                             0,
                             pszTemp2,
                             TEMP_STRING_SIZE,
                             reinterpret_cast<va_list*>(&pszArray));
        TBOOL(SetDlgItemText(hwnd, IDC_PROGRESS_CLOSE, pszTemp2));
        (HLOCAL)LocalFree(pszTemp1);
    }
    CenterWindow(hwnd);
    hwndProgress = GetDlgItem(hwnd, IDC_PROGRESS_PROGRESSBAR);
    if (hwndProgress != NULL)
    {
        (LRESULT)SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, _dwTickMaximum));
        _uiTimerID = SetTimer(hwnd, PROGRESS_TIMER_ID, _dwTickRefresh, ProgressTimerProc);
        _dwTickStart = GetTickCount();
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::Handle_Progress_WM_DESTROY
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Removes the timer from the associated progress dialog if one
//              was created for the dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::Handle_Progress_WM_DESTROY (HWND hwnd)

{
    if (_uiTimerID != 0)
    {
        TBOOL(KillTimer(hwnd, _uiTimerID));
        _uiTimerID = 0;
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ProgressTimerProc
//
//  Arguments:  See the platform SDK under TimerProc.
//
//  Returns:    See the platform SDK under TimerProc.
//
//  Purpose:    Timer procedure that it called back periodically. This
//              function animates the progress bar by setting it's completion
//              state to the amount of time that has elapsed. The progress
//              bar is based purely on time.
//
//              If the time elapsed exceeds the maximum time then end the
//              dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CALLBACK    CWarningDialog::ProgressTimerProc (HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)

{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(idEvent);

    HWND            hwndProgress;
    CWarningDialog  *pThis;

    pThis = reinterpret_cast<CWarningDialog*>(GetWindowLongPtr(hwnd, DWLP_USER));
    hwndProgress = GetDlgItem(hwnd, IDC_PROGRESS_PROGRESSBAR);
    if (hwndProgress != NULL)
    {
        (LRESULT)SendMessage(hwndProgress, PBM_SETPOS, dwTime - pThis->_dwTickStart, 0);
        if ((dwTime - pThis->_dwTickStart) > pThis->_dwTickMaximum)
        {
            TBOOL(EndDialog(hwnd, IDCANCEL));
        }
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ProgressDialogProc
//
//  Arguments:  See the platform SDK under DlgProc.
//
//  Returns:    See the platform SDK under DlgProc.
//
//  Purpose:    Handles messages for the progress dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CWarningDialog::ProgressDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    UNREFERENCED_PARAMETER(wParam);

    INT_PTR         iResult;
    CWarningDialog  *pThis;

    pThis = reinterpret_cast<CWarningDialog*>(GetWindowLongPtr(hwnd, DWLP_USER));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CWarningDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis->Handle_Progress_WM_INITDIALOG(hwnd);
            iResult = TRUE;
            break;
        case WM_DESTROY:
            pThis->Handle_Progress_WM_DESTROY(hwnd);
            pThis->_hwnd = NULL;
            iResult = TRUE;
            break;
        default:
            iResult = FALSE;
            break;
    }
    return(iResult);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\fact.h ===
#ifndef _FACT_H_
#define _FACT_H_

#include <objbase.h>
#include "factdata.h"

class CCOMBase;
class CCOMBaseFactory;

class CCOMBaseFactory : public IClassFactory
{
///////////////////////////////////////////////////////////////////////////////
// COM Interfaces
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    
    // IClassFactory
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, REFIID riid,
        void** ppv);
    virtual STDMETHODIMP LockServer(BOOL fLock);

///////////////////////////////////////////////////////////////////////////////
// 
public:
    CCOMBaseFactory(const CFactoryData* pFactoryData);
    ~CCOMBaseFactory() {}

public: // only for use in dll.cpp, or internally
    static HRESULT DllAttach(HINSTANCE hinst);
    static HRESULT DllDetach();

    static HRESULT _RegisterAll();
    static HRESULT _UnregisterAll();
    static HRESULT _CanUnloadNow();
    static HRESULT _CheckForUnload();

///////////////////////////////////////////////////////////////////////////////
// Helpers
private:
    static BOOL _IsLocked();
    static HRESULT _LockServer(BOOL fLock);

    static void _COMFactoryCB(BOOL fIncrement);

public: // only for use in dll.cpp
    static HRESULT _GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);

public: // only for use in COM exe server
    static BOOL _ProcessConsoleCmdLineParams(int argc, wchar_t* argv[],
        BOOL* pfRun, BOOL* pfEmbedded);
//    static BOOL _ProcessWindowsCmdLineParams(LPWSTR pszCmdLine);
    static void _WaitForAllClientsToGo();
    static BOOL _RegisterFactories(BOOL fEmbedded);
    static BOOL _UnregisterFactories(BOOL fEmbedded);
    static BOOL _SuspendFactories();
    static BOOL _ResumeFactories();

public:
    const CFactoryData*         _pFactoryData;
    static const CFactoryData*  _pDLLFactoryData;
    static const DWORD          _cDLLFactoryData;
    static struct OUTPROCINFO*  _popinfo;
    static HMODULE              _hModule;
    static CRITICAL_SECTION     _cs;

private:
    LONG                        _cRef;

    static LONG                 _cComponents;   
    static LONG                 _cServerLocks;

    static DWORD                _dwThreadID;
    static BOOL                 _fCritSectInit;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\bamsrv\restoreapplication.h ===
//  --------------------------------------------------------------------------
//  Module Name: RestoreApplication.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement holding information required to restore an application
//  and to actually restore it.
//
//  History:    2000-10-26  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifndef     _RestoreApplication_
#define     _RestoreApplication_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CRestoreApplication
//
//  Purpose:    Class to manage information required to restore an application
//              that was terminated because of a different user switch.
//
//  History:    2000-10-26  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

class   CRestoreApplication : public CCountedObject
{
    public:
                                CRestoreApplication (void);
                                ~CRestoreApplication (void);

                NTSTATUS        GetInformation (HANDLE hProcess);

                bool            IsEqualSessionID (DWORD dwSessionID)    const;
                const WCHAR*    GetCommandLine (void)                   const;
                NTSTATUS        Restore (HANDLE *phProcess)             const;
    private:
                NTSTATUS        GetProcessParameters (HANDLE hProcess, RTL_USER_PROCESS_PARAMETERS *pProcessParameters);
                NTSTATUS        GetUnicodeString (HANDLE hProcess, const UNICODE_STRING& string, WCHAR** ppsz);

                NTSTATUS        GetToken (HANDLE hProcess);
                NTSTATUS        GetSessionID (HANDLE hProcess);
                NTSTATUS        GetCommandLine (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetEnvironment (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetCurrentDirectory (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetDesktop (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetTitle (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetFlags (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetStdHandles (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
    private:
                HANDLE          _hToken;
                DWORD           _dwSessionID;
                WCHAR           *_pszCommandLine;
                void            *_pEnvironment;
                WCHAR           *_pszCurrentDirectory;
                WCHAR           *_pszDesktop;
                WCHAR           *_pszTitle;
                DWORD           _dwFlags;
                WORD            _wShowWindow;
                HANDLE          _hStdInput;
                HANDLE          _hStdOutput;
                HANDLE          _hStdError;

        static  const WCHAR     s_szDefaultDesktop[];
};

#endif  /*  _RestoreApplication_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\mischlpr.h ===
#ifndef _MISCHLPR_H_
#define _MISCHLPR_H_

#include <objbase.h>

#include "dbg.h"
#include "tfids.h"

#define UNREF_PARAM(a)
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

class CRefCounted
{
public:
    ULONG RCAddRef() { return ::InterlockedIncrement(&_cRef); }
    ULONG RCRelease()
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = ::InterlockedDecrement(&_cRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

    CRefCounted() : _cRef(1) {}
    virtual ~CRefCounted() {}

private:
    LONG _cRef;
};

class CRefCountedCritSect : public CRefCounted, public CRITICAL_SECTION
{};

class CCritSect : CRITICAL_SECTION
{
public:
    HRESULT Init()
    {
        if (InitializeCriticalSectionAndSpinCount(this, 0))
        {
            _fInited = TRUE;
        }

#ifdef DEBUG
        _iLevel = 0;
#endif
        return _fInited ? S_OK : E_FAIL;
    }
    void Enter()
    {
        ASSERT(_fInited);
        EnterCriticalSection(this);
#ifdef DEBUG
        ++_iLevel;
#endif
    }
    void Leave()
    {
        ASSERT(_fInited);
#ifdef DEBUG
        --_iLevel;
#endif
        LeaveCriticalSection(this);
    }

    void Delete()
    {
        if (_fInited)
        {
            _fInited = FALSE;
            DeleteCriticalSection(this);
        }
    }

    BOOL IsInitialized()
    {
        return _fInited;
    }

    BOOL _fInited;

    CCritSect() : _fInited(FALSE) {}
#ifdef DEBUG
    BOOL IsInside()
    {
        ASSERT(_fInited);

        return _iLevel;
    }

    DWORD _iLevel;
#endif
};

class CThreadTask
{
public:
    virtual ~CThreadTask() {}

public:
    // Uses CreateThread, delete 'this' at the end
    HRESULT RunWithTimeout(DWORD dwTimeout);

    // Uses Thread Pool, delete 'this' at the end
    HRESULT Run();

    // Run on 'this' thread, does NOT delete 'this' at the end
    HRESULT RunSynchronously();

protected:
    virtual HRESULT _DoStuff() = 0;

private:
    static DWORD WINAPI _ThreadProc(void* pv);
};

template<typename TDataPtr>
HRESULT _AllocMemoryChunk(DWORD cbSize, TDataPtr* pdataOut)
{
    HRESULT hr;

    *pdataOut = (TDataPtr)LocalAlloc(LPTR, cbSize);

    if (*pdataOut)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template<typename TDataPtr>
HRESULT _DupMemoryChunk(TDataPtr pdata, DWORD cbSize, TDataPtr* pdataOut)
{
    HRESULT hr;
    *pdataOut = (TDataPtr)LocalAlloc(LPTR, cbSize);

    if (*pdataOut)
    {
        CopyMemory((void*)*pdataOut, pdata, cbSize);

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template<typename TDataPtr>
HRESULT _FreeMemoryChunk(TDataPtr pdata)
{
    HRESULT hr = S_OK;

    if (LocalFree((HLOCAL)pdata))
    {
        hr = E_FAIL;
    }

    return hr;
}

#endif //_MISCHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\hdservice.h ===
#ifndef _HDService_
#define _HDService_

class CHDService
{
public:
    static BOOL Main(DWORD dwReason);
    static HRESULT Install(BOOL fInstall, LPCWSTR pszCmdLine);
    static HRESULT RegisterServer();
    static HRESULT UnregisterServer();
    static HRESULT CanUnloadNow();
    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\sfstr.h ===
#include <objbase.h>

// Review 500?
#define E_BUFFERTOOSMALL MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 500)
#define E_SOURCEBUFFERTOOSMALL MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 501)

// SafeStrCpyN & SafeStrCatN return values:
//      S_OK:               Success and guaranteed NULL terminated.
//      E_INVALIDARG:       If any ptr is NULL, or cchDest <= 0.
//      E_BUFFERTOOSMALL:   If cchDest is too small.  Content of pszDest is
//                          undefined.

HRESULT SafeStrCpyN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest);
HRESULT SafeStrCatN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest);

// Same return values as for the corresponding SafeStrCxxN, and
//      FAILED(hres):       *ppchLeft and *ppszEnd are undefined.
// 
// *pcchLeft = nb char left in pszDest including the '\0\ just put there
// *ppszEnd = points to the '\0' just put there
//
HRESULT SafeStrCpyNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft);
HRESULT SafeStrCatNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft);

// Comment: Do not use to copy only N first char of a string.  Will return
//      failure if does not encounter '\0' in source.

HRESULT SafeStrCpyNReq(LPWSTR pszDest, LPWSTR pszSrc, DWORD cchDest,
    DWORD* pcchRequired);

// SafeStrCpyNExact & SafeStrCpyNExactEx return values:
//      Same as SaStrCpyN, plus:
//      E_SOURCEBUFFERTOOSMALL: The source buffer did not contain at least
//                              cchExact chars
//
// cchExact has to include the NULL terminator
HRESULT SafeStrCpyNExact(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact);
HRESULT SafeStrCpyNExactEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact, LPWSTR* ppszEnd, DWORD* pcchLeft);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\factdata.h ===
#ifndef _FACTDATA_H_
#define _FACTDATA_H_

#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
//  Component creation function
typedef void (*COMFACTORYCB)(BOOL fIncrement);

typedef HRESULT (*FPCREATEINSTANCE)(COMFACTORYCB, IUnknown*, IUnknown**);

#define THREADINGMODEL_FREE             0x00000001
#define THREADINGMODEL_APARTMENT        0x00000002
#define THREADINGMODEL_NEUTRAL          0x00000004

#define THREADINGMODEL_BOTH             (THREADINGMODEL_FREE | THREADINGMODEL_APARTMENT)

extern const CLSID APPID_ShellHWDetection;

///////////////////////////////////////////////////////////////////////////////
// CFactoryData
//   Information CFactory needs to create a component supported by the DLL
class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* _pCLSID;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance;

    // Name of the component to register in the registry
    LPCWSTR _pszRegistryName;

    // ProgID
    LPCWSTR _pszProgID;

    // Version-independent ProgID
    LPCWSTR _pszVerIndProgID;

    // ThreadingModel
    DWORD _dwThreadingModel;

    // For CoRegisterClassObject (used only for COM Exe server)
    DWORD _dwClsContext;

    // For CoRegisterClassObject (used only for COM Exe server)
    DWORD _dwFlags;

    // LocalService
    LPCWSTR _pszLocalService;

    // AppID
    const CLSID* _pAppID;

    // Helper function for finding the class ID
    BOOL IsClassID(REFCLSID rclsid) const
    { return (*_pCLSID == rclsid);}

    //
    BOOL IsInprocServer() const
    { return !_dwClsContext || ((CLSCTX_INPROC_SERVER |
                    CLSCTX_INPROC_HANDLER) & _dwClsContext); }

    BOOL IsLocalServer() const
    { return ((CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER) & _dwClsContext) && !_pszLocalService; }

    BOOL IsLocalService() const
    { return ((CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER) & _dwClsContext) &&
        _pszLocalService;  }
};

#endif //_FACTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\reg.h ===
#ifndef _REG_H
#define _REG_H

#include <objbase.h>

#define MAX_KEY                 MAX_PATH
#define MAX_VALUE               MAX_PATH

HRESULT _RegOpenKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey);
HRESULT _RegCreateKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey, DWORD* pdwDisp);
HRESULT _RegCloseKey(HKEY hkey);

HRESULT _RegQueryType(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwType);

HRESULT _RegQueryGenericWithType(HKEY hkey, LPCWSTR pszSubKey,
    LPCWSTR pszValueName, DWORD* pdwType, PBYTE pbValue, DWORD cbValue);

HRESULT _RegQueryValueSize(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pcbValue);
HRESULT _RegQueryString(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    LPWSTR pszValue, DWORD cchValue);
HRESULT _RegQueryDWORD(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwValue);
HRESULT _RegEnumStringValue(HKEY hkey, DWORD dwIndex, LPWSTR pszValue,
    DWORD cchValue);
HRESULT _RegEnumStringKey(HKEY hkey, DWORD dwIndex, LPWSTR pszKey,
    DWORD cchKey);

HRESULT _RegDeleteValue(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName);

HRESULT _RegSetString(HKEY hkey, LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT _RegSetDWORD(HKEY hkey, LPCWSTR pszValueName, DWORD dwValue);
HRESULT _RegSetBinary(HKEY hkey, LPCWSTR pszValueName, PVOID pvValue, DWORD cbValue);
HRESULT _RegSetKeyAndString(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszSubkey,
    LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT _RegSubkeyExists(HKEY hkey, LPCWSTR pszPath, LPCWSTR pszSubkey);

#endif //_REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\str.h ===
#ifndef _STR_H
#define _STR_H

#include <objbase.h>

HRESULT _CreateGUID(LPWSTR pszGUID, DWORD cchGUID);
HRESULT _StringFromGUID(const GUID* pguid, LPWSTR psz, DWORD cch);
HRESULT _GUIDFromString(LPCWSTR psz, GUID* pguid);

#endif //_STR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\namellst.h ===
#ifndef _NAMELLST_H_
#define _NAMELLST_H_

#include <objbase.h>

#include "mischlpr.h"

///////////////////////////////////////////////////////////////////////////////
//
class CNamedElem : public CRefCounted
{
public:
    HRESULT GetName(LPTSTR psz, DWORD cch, DWORD* pcchRequired);

    virtual HRESULT Init(LPCTSTR pszElemName) PURE;

#ifdef DEBUG
    LPCTSTR DbgGetName();
#endif

protected:
    CNamedElem();
    virtual ~CNamedElem();

    HRESULT _SetName(LPCTSTR pszElemName);
    HRESULT _FreeName();

protected:
    LPTSTR      _pszElemName;

    // for access to _pelemNext
    friend class CNamedElemList;
};

///////////////////////////////////////////////////////////////////////////////
//
class CFillEnum : public CRefCounted
{
public:
    virtual HRESULT Next(LPTSTR pszElemName, DWORD cchElemName,
        DWORD* pcchRequired) = 0;
};
///////////////////////////////////////////////////////////////////////////////
//
typedef HRESULT (*NAMEDELEMCREATEFCT)(CNamedElem** ppelem);

// return values:
//      S_OK when everything's all right
//      S_FALSE when no more items
//      E_BUFFERTOOSMALL if buffer too small
typedef HRESULT (*NAMEDELEMGETFILLENUMFCT)(CFillEnum** ppfillenum);

///////////////////////////////////////////////////////////////////////////////
//
class CElemSlot : public CRefCounted
{
public:
    HRESULT Init(CNamedElem* pelem, CElemSlot* pesPrev, CElemSlot* pesNext);
    HRESULT Remove();

    HRESULT GetNamedElem(CNamedElem** ppelem);
    void SetPrev(CElemSlot* pes);

    CElemSlot* GetNext();
    CElemSlot* GetNextValid();
    CElemSlot* GetPrevValid();

    BOOL IsValid();

    void SetCallbackPointer(CNamedElemList* pnel);

public:
    CElemSlot();
    virtual ~CElemSlot();

private:
    // Payload
    CNamedElem*             _pelem;

    // Impl details
    BOOL                    _fValid;
    CElemSlot*              _pesPrev;
    CElemSlot*              _pesNext;

    // for callback
    class CNamedElemList*   _pnel;
};

///////////////////////////////////////////////////////////////////////////////
//
class CNamedElemEnum : public CRefCounted
{
public:
    HRESULT Next(CNamedElem** ppelem);

public:
    CNamedElemEnum();
    virtual ~CNamedElemEnum();

private:
    HRESULT _Init(CElemSlot* pesHead, CRefCountedCritSect* pcsList);

private:
    CElemSlot*              _pesCurrent;
    BOOL                    _fFirst;
    CRefCountedCritSect*    _pcsList;

    // for access to _Init
    friend class CNamedElemList;
};

///////////////////////////////////////////////////////////////////////////////
//
class CNamedElemList : public CRefCounted
{
public:
    HRESULT Init(NAMEDELEMCREATEFCT createfct,
        NAMEDELEMGETFILLENUMFCT enumfct);

    // Returns S_FALSE if cannot find it
    HRESULT Get(LPCTSTR pszElemName, CNamedElem** ppelem);

    // Returns S_OK if was already existing
    //         S_FALSE if was just added
    HRESULT GetOrAdd(LPCTSTR pszElemName, CNamedElem** ppelem);

    HRESULT Add(LPCTSTR pszElemName, CNamedElem** ppelem);
    HRESULT Remove(LPCTSTR pszElemName);

    HRESULT ReEnum();
    HRESULT EmptyList();

    HRESULT GetEnum(CNamedElemEnum** ppenum);

#ifdef DEBUG
    HRESULT InitDebug(LPWSTR pszDebugName);
    void AssertAllElemsRefCount1();
    void AssertNoDuplicate();
#endif

    void RealRemoveElemSlotCallback(CElemSlot* pes);

public:
    CNamedElemList();
    virtual ~CNamedElemList();

private:
    HRESULT _Add(LPCTSTR pszElemName, CNamedElem** ppelem);
    HRESULT _GetTail(CElemSlot** ppes);
    HRESULT _GetElemSlot(LPCTSTR pszElemName, CElemSlot** ppes);
    HRESULT _Remove(LPCTSTR pszElemName);
    HRESULT _EmptyList();
    CElemSlot* _GetValidHead();

private:
    CElemSlot*              _pesHead;
    NAMEDELEMCREATEFCT      _createfct;
    NAMEDELEMGETFILLENUMFCT _enumfct;

    CRefCountedCritSect*    _pcs;

#ifdef DEBUG
    WCHAR                   _szDebugName[100];
#endif
};

#endif //_NAMELLST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\rbdebug.h ===
#ifndef _RBDEBUG_H
#define _RBDEBUG_H

#include <objbase.h>

// Registry Based Debug

// We first look in HKCU, then HKLM (there's no HKCU for a service)
// + HKCU\Software\Microsoft\Debug\MyApp.exe
//      . RBD_FLAGS = ...
//      + File
//          . FileName = ... (e.g.: c:\mytrace.txt)
//      + Pipe
//          . MachineName = ... [Default: "." (local machine)] (e.g.: stephstm_dev)
//          . PipeName = ... [Default: MyApp.exe (name of the app)] (e.g.: MyPipe)

#define RBD_TRACE_NONE          0x00000000
#define RBD_TRACE_OUTPUTDEBUG   0x00000001
#define RBD_TRACE_TOFILEANSI    0x00000002
#define RBD_TRACE_TOFILE        0x00000004
#define RBD_TRACE_TOPIPE        0x00000008
#define RBD_TRACE_MASK          0x000000FF

#define RBD_ASSERT_NONE         0x00000000
#define RBD_ASSERT_STOP         0x00000100
#define RBD_ASSERT_TRACE        0x00000200
#define RBD_ASSERT_BEEP         0x00000400
#define RBD_ASSERT_MASK         0x0000FF00

#define TF_ASSERT           0x80000000
#define TF_NOFILEANDLINE    0x40000000
#define TF_THREADID         0x20000000
#define TF_TIME             0x10000000

class CRBDebug
{
public:
    static void SetTraceFileAndLine(LPCSTR pszFile, const int iLine);
    static void __cdecl TraceMsg(DWORD dwFlags, LPTSTR pszMsg, ...);

    static HRESULT Init();

private:
    static HRESULT _Init();
    static HRESULT _InitFile(HKEY hkeyRoot);
    static HRESULT _InitPipe(HKEY hkeyRoot);
    static void _Trace(LPTSTR pszMsg);

public:
    static BOOL             _fInited;
    static DWORD            _dwTraceFlags;
    static DWORD            _dwFlags;
    static TCHAR            _szTraceFile[MAX_PATH];
    static TCHAR            _szTracePipe[MAX_PATH];
    static TCHAR            _szModuleName[MAX_PATH];
    static HANDLE           _hfileTraceFile;
    // + 12: yep, limited to files of less than 10 billion lines...
    // + 13: for threadid
    // + 17: for time
    static TCHAR            _szFileAndLine[MAX_PATH + 12 + 13 + 17];
    static CRITICAL_SECTION _cs;
};

#endif // _RBDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\dbg.cpp ===
#include "dbg.h"

#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#ifdef DEBUG

void __cdecl DbgTrace(DWORD, LPTSTR pszMsg, ...)
{
    TCHAR szBuf[4096];
    va_list vArgs;

    va_start(vArgs, pszMsg);

    StringCchVPrintf(szBuf, ARRAYSIZE(szBuf), pszMsg, vArgs);
    
    va_end(vArgs);

    OutputDebugString(szBuf);
    OutputDebugString(TEXT("\n"));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\tfids.h ===
///////////////////////////////////////////////////////////////////////////////
// !!!!!!!! Do not use 0x10000000, 0x20000000, 0x40000000, 0x80000000 !!!!!!!!!
// see rbdebug.h
///////////////////////////////////////////////////////////////////////////////

// Generic Service stuff
#define TF_SERVICE                  0x00000001
// Generic Service stuff, but with more granularity
#define TF_SERVICEDETAILED          0x00000002

#define TF_SERVICEASPROCESS         0x00000004

// Shell HW Detection stuff, related to service
#define TF_SHHWDTCTSVC              0x00000010
// Shell HW Detection stuff, related to detection
#define TF_SHHWDTCTDTCT             0x00000020
#define TF_SHHWDTCTDTCTDETAILED     0x00000040
#define TF_SHHWDTCTDTCTREG          0x00000080

// COM Server stuff
#define TF_COMSERVER                0x00001000

#define TF_COMSERVERSTGINFO         0x00002000
#define TF_COMSERVERDEVINFO         0x00004000

#define TF_NAMEDELEMLISTMODIF       0x00100000

#define TF_RCADDREF                 0x00200000

#define TF_USERS                    0x00400000

#define TF_LEAK                     0x00800000

#define TF_SVCSYNC                  0x01000000

#define TF_WIA                      0x02000000
#define TF_ADVISE                   0x04000000
#define TF_VOLUME                   0x08000000

#define TF_SESSION                  0x08000000

///////////////////////////////////////////////////////////////////////////////
// !!!!!!!! Do not use 0x10000000, 0x20000000, 0x40000000, 0x80000000 !!!!!!!!!
// see rbdebug.h
///////////////////////////////////////////////////////////////////////////////

/*
Diagnostic ranges:

0000 - 0050: Hardware Events
0051 - 0100: Content
0101 - 0150: Handler identification and execution
0151 - 0200: Autoplay Settings
0201 - 0250: User Settings
0251 - 0300: Custom Properties
0301 - 0350: Volume stuff
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\unk.h ===
#ifndef _UNK_H_
#define _UNK_H_

#include <objbase.h>

typedef void (*COMFACTORYCB)(BOOL fIncrement);

class CCOMBase
{
public:
    virtual HRESULT UnkInit() { return S_OK; }
};

struct INTFMAPENTRY
{
    const IID*  piid;
    DWORD       dwOffset;
};

template <class CCOMBASE>
class CUnkTmpl : public CCOMBASE
{
public:
    CUnkTmpl(IUnknown*) : _cRef(1) {}
    ~CUnkTmpl() { if (_cfcb) { _cfcb(FALSE); } }

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv)
    {
        HRESULT hres;

        if (IID_IUnknown == riid)
        {
            IUnknown* punk;

            *ppv = (IUnknown*)(((PBYTE)this) + _pintfmap[0].dwOffset);

            punk = (IUnknown*)(*ppv);
            punk->AddRef();

            hres = S_OK;
        }
        else
        {
            hres = _GetInterfaceFromMap(riid, ppv);
        }

        return hres;
    }

	STDMETHODIMP_(ULONG) AddRef() { return ::InterlockedIncrement(&_cRef); }
	STDMETHODIMP_(ULONG) Release()
    {
#if DBG==1
        if ( 0 == _cRef )
        {
            DebugBreak( );  // ref counter problem
        }
#endif
        ULONG cRef = ::InterlockedDecrement(&_cRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

protected:
    HRESULT _GetInterfaceFromMap(REFIID riid, void** ppv)
    {
        HRESULT hres = E_NOINTERFACE;

        for (DWORD dw = 0; dw < _cintfmap; ++dw)
        {
            if (riid == *(_pintfmap[dw].piid))
            {
                IUnknown* punk = (IUnknown*)(((PBYTE)this) +
                    _pintfmap[dw].dwOffset);
                punk->AddRef();
                *ppv = punk;
                hres = S_OK;
                break;
            }
        }

        return hres;
    }

public:
    static HRESULT UnkCreateInstance(COMFACTORYCB cfcb,
        IUnknown* pUnknownOuter, IUnknown** ppunkNew)
    {
        HRESULT hres = E_OUTOFMEMORY;

        if (!_cfcb)
        {
            _cfcb = cfcb;
        }

        CUnkTmpl<CCOMBASE>* pNew = new CUnkTmpl<CCOMBASE>(pUnknownOuter);

        if (pNew)
        {
            hres = pNew->UnkInit();

            if (FAILED(hres))
            {
                delete pNew;
            }
            else
            {
                *ppunkNew = (IUnknown*)(((PBYTE)pNew) +
                    pNew->_pintfmap[0].dwOffset);
            }
        }

        return hres;
    }

private:
    LONG                        _cRef;

    static COMFACTORYCB         _cfcb;
    static const INTFMAPENTRY*  _pintfmap;
    static const DWORD          _cintfmap;
};

// for now: begin
#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(static_cast<base*>((derived*)8))-8)
#endif
// for now: end

#define _INTFMAPENTRY(Cthis, Ifoo) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Ifoo, Cthis) }

#define _INTFMAPENTRY2(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#endif // _UNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\inc\users.h ===
#pragma once

#include "mischlpr.h"

#include <winsta.h>

// In between _CoGetCallingUserHKCU and _CoCloseCallingUserHKCU
// we impersonate the calling user

// phThreadToken is out only
HRESULT _CoGetCallingUserHKCU(HANDLE* phThreadToken, HKEY* phkey);
HRESULT _CoCloseCallingUserHKCU(HANDLE hThreadToken, HKEY hkey);

HRESULT _GetCurrentUserHKCU(HANDLE* phThreadToken, HKEY* phkey);
HRESULT _CloseCurrentUserHKCU(HANDLE hThreadToken, HKEY hkey);

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid,
    IUnknown* punkOuter, DWORD dwClsContext, REFIID riid, void** ppv);

HRESULT _GiveAllowForegroundToConsoleShell();

class CImpersonateBase
{
public:
    virtual HRESULT Impersonate() = 0;
    virtual HRESULT RevertToSelf() = 0;
};

class CImpersonateTokenBased : public CImpersonateBase
{
public:
    CImpersonateTokenBased();
    virtual ~CImpersonateTokenBased();

public:
    HRESULT Impersonate();
    HRESULT RevertToSelf();

protected:
    virtual HRESULT _GetToken(HANDLE* phToken) = 0;

private:
    HRESULT _RevertToSelf();

private:

    HANDLE          _hToken;
};

class CImpersonateConsoleSessionUser : public CImpersonateTokenBased
{
protected:
    HRESULT _GetToken(HANDLE* phToken);
};

class CImpersonateEveryone : public CImpersonateTokenBased, public CRefCounted
{
protected:
    HRESULT _GetToken(HANDLE* phToken);
};

class CImpersonateCOMCaller : public CImpersonateBase
{
public:
    CImpersonateCOMCaller();
    ~CImpersonateCOMCaller();

public:
    HRESULT Impersonate();
    HRESULT RevertToSelf();

private:
    HRESULT _RevertToSelf();

private:
    BOOL    _fImpersonating;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\mischlpr.cpp ===
#include "mischlpr.h"

HRESULT CThreadTask::RunWithTimeout(DWORD /*dwTimeout*/)
{
    return E_NOTIMPL;
}

HRESULT CThreadTask::Run()
{
    BOOL fResult;
    HRESULT hr = S_OK;

    fResult = QueueUserWorkItem(_ThreadProc, this, WT_EXECUTELONGFUNCTION);
    if (!fResult)
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}

HRESULT CThreadTask::RunSynchronously()
{
    return _DoStuff();
}

//static
DWORD WINAPI CThreadTask::_ThreadProc(void* pv)
{
    DWORD dwRet;
    CThreadTask* pTask = (CThreadTask*)pv;

    dwRet = (DWORD)(pTask->_DoStuff());

    delete pTask;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\guids.cpp ===
#include <objbase.h>

// {02506D0A-A7F5-419d-94D2-ED26F0753654}
extern "C" const IID IID_IService =
    {0x02506d0a, 0xa7f5, 0x419d,
    {0x94, 0xd2, 0xed, 0x26, 0xf0, 0x75, 0x36, 0x54}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\dll.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "fact.h"
#include "HDService.h"
#include "shsrvice\shsrvice.h"

///////////////////////////////////////////////////////////////////////////////
// Exported functions

//  These are static C++ member functions that are called from the common exported functions.

extern  HINSTANCE   g_hInstance;

BOOL CHDService::Main(DWORD dwReason)
{
    BOOL f;

    if (DLL_PROCESS_ATTACH == dwReason)
    {
        f = SUCCEEDED(CCOMBaseFactory::DllAttach(g_hInstance));

        if (f)
        {
            f = SUCCEEDED(CGenericServiceManager::DllAttach(g_hInstance));
        }
    }
    else
    {
        if (DLL_PROCESS_DETACH == dwReason)
        {
            f = SUCCEEDED(CCOMBaseFactory::DllDetach());

            if (f)
            {
                f = SUCCEEDED(CGenericServiceManager::DllDetach());
            }
        }
        else
        {
            // Whatever...
            f = TRUE;
        }
    }

    return f;
}

HRESULT CHDService::RegisterServer ()
{
    return CCOMBaseFactory::_RegisterAll();
}

HRESULT CHDService::UnregisterServer()
{
    return CCOMBaseFactory::_UnregisterAll();
}

HRESULT CHDService::CanUnloadNow()
{
    return CCOMBaseFactory::_CanUnloadNow();
}

HRESULT CHDService::GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    return CCOMBaseFactory::_GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\rbdebug.cpp ===
#ifdef DEBUG

#include "rbdebug.h"

#include <objbase.h>
#include <strsafe.h>

BOOL CRBDebug::_fInited = FALSE;
DWORD CRBDebug::_dwFlags = 0;
DWORD CRBDebug::_dwTraceFlags = 0;
TCHAR CRBDebug::_szTraceFile[] = TEXT("");
TCHAR CRBDebug::_szModuleName[] = TEXT("");
HANDLE CRBDebug::_hfileTraceFile = INVALID_HANDLE_VALUE;
TCHAR CRBDebug::_szTracePipe[] = TEXT("");
TCHAR CRBDebug::_szFileAndLine[] = TEXT("");
CRITICAL_SECTION CRBDebug::_cs = {0}; 
    
#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CRBDebug::_InitFile(HKEY hkeyRoot)
{
    HRESULT hres = E_FAIL;
    HKEY hkeyFile;

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, TEXT("File"), 0,
        MAXIMUM_ALLOWED, &hkeyFile))
    {
        DWORD dwSize = sizeof(_szTraceFile);

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyFile, TEXT("FileName"),
            0, NULL, (PBYTE)_szTraceFile, &dwSize))
        {
            _hfileTraceFile = CreateFile(_szTraceFile,
                GENERIC_WRITE, FILE_SHARE_READ, NULL,
                OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != _hfileTraceFile)
            {
                SetFilePointer(_hfileTraceFile, 0, 0,
                    FILE_END);

                hres = S_OK;
            }
        }

        RegCloseKey(hkeyFile);
    }

    return hres;
}

HRESULT CRBDebug::_InitPipe(HKEY hkeyRoot)
{
    HRESULT hres = S_OK;
    HKEY hkeyFile;
    TCHAR szMachineName[MAX_PATH];
    TCHAR szPipeName[MAX_PATH];

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, TEXT("Pipe"), 0,
        MAXIMUM_ALLOWED, &hkeyFile))
    {
        DWORD dwSize = sizeof(szMachineName);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyFile, TEXT("MachineName"),
            0, NULL, (PBYTE)szMachineName, &dwSize))
        {
            hres = StringCchCopy(szMachineName, ARRAYSIZE(szMachineName),
                TEXT("."));
        }

        if (SUCCEEDED(hres))
        {
            dwSize = sizeof(szPipeName);

            if (ERROR_SUCCESS != RegQueryValueEx(hkeyFile, TEXT("PipeName"),
                0, NULL, (PBYTE)szPipeName, &dwSize))
            {
                hres = StringCchCopy(szPipeName, ARRAYSIZE(szPipeName),
                _szModuleName);
            }
        }
        
        RegCloseKey(hkeyFile);
    }
    else
    {
        // Defaults
        hres = StringCchCopy(szMachineName, ARRAYSIZE(szMachineName),
            TEXT("."));

        if (SUCCEEDED(hres))
        {
            hres = StringCchCopy(szPipeName, ARRAYSIZE(szPipeName),
                _szModuleName);
        }
    }

    if (SUCCEEDED(hres))
    {
        hres = StringCchPrintf(_szTracePipe, ARRAYSIZE(_szTracePipe),
            TEXT("\\\\%s\\pipe\\%s"), szMachineName, szPipeName);
    }
    
    return hres;
}

// static
HRESULT CRBDebug::_Init()
{
    HRESULT hres = S_FALSE;

    if (!_fInited)
    {
        // Read the flags
        WCHAR szKey[MAX_PATH];
        WCHAR szModule[MAX_PATH];
        BOOL fKeyExist = FALSE;

        hres = E_FAIL;
        
        if (InitializeCriticalSectionAndSpinCount(&_cs, 0))
        {
            hres = StringCchCopy(szKey, ARRAYSIZE(szKey), L"Software\\Microsoft\\Debug\\");
            
            if (SUCCEEDED(hres))
            {
                hres = E_FAIL;

                if (GetModuleFileName(GetModuleHandle(NULL), szModule,
                    ARRAYSIZE(szModule)))
                {
                    HKEY hkey;
                    LONG lSuccess;
                    int c = lstrlen(szModule);

                    while (c && (L'\\' != szModule[c]))
                    {
                        --c;
                    }

                    hres = StringCchCopy(_szModuleName, ARRAYSIZE(_szModuleName),
                        szModule + c + 1);
                        
                    if (SUCCEEDED(hres))
                    {
                        hres = StringCchCat(szKey, ARRAYSIZE(szKey), _szModuleName);
                    }
                    
                    if (SUCCEEDED(hres))
                    {
                        hres = E_FAIL;
                    
                        lSuccess = RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0,
                            MAXIMUM_ALLOWED, &hkey);

                        if (ERROR_SUCCESS != lSuccess)
                        {
                            lSuccess = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0,
                                MAXIMUM_ALLOWED, &hkey);
                        }

                        if (ERROR_SUCCESS == lSuccess)
                        {
                            DWORD dwSize = sizeof(DWORD);
            
                            fKeyExist = TRUE;

                            if (ERROR_SUCCESS == RegQueryValueEx(hkey, L"RBD_FLAGS", 0,
                                NULL, (PBYTE)&_dwFlags, &dwSize))
                            {
                                if (_dwFlags & RBD_TRACE_OUTPUTDEBUG)
                                {
                                    hres = S_OK;
                                }

                                if ((_dwFlags & RBD_TRACE_TOFILE) ||
                                    (_dwFlags & RBD_TRACE_TOFILEANSI))
                                {
                                    hres = _InitFile(hkey);

                                    if (FAILED(hres))
                                    {
                                        _dwFlags &= ~RBD_TRACE_TOFILE;
                                    }
                                }

                                if (_dwFlags & RBD_TRACE_TOPIPE)
                                {
                                    hres = _InitPipe(hkey);

                                    if (FAILED(hres))
                                    {
                                        _dwFlags &= ~RBD_TRACE_TOPIPE;
                                    }
                                }
                            }
                            else
                            {
                                _dwFlags = RBD_TRACE_OUTPUTDEBUG | RBD_ASSERT_STOP;

                                hres = S_FALSE;
                            }

                            if (ERROR_SUCCESS != RegQueryValueEx(hkey, L"TRACE_FLAGS", 0,
                                NULL, (PBYTE)&_dwTraceFlags, &dwSize))
                            {
                                // Default...
                                _dwTraceFlags = 0;
                            }

                            RegCloseKey(hkey);
                        }
                    }
                }
                
                if (!fKeyExist)
                {
                    // If we can't find a key for this app then we revert to default
                    // behavior
                    _dwFlags = RBD_TRACE_OUTPUTDEBUG | RBD_ASSERT_STOP;

                    hres = S_FALSE;
                }
            }
        }

        if (SUCCEEDED(hres))
        {    
            _fInited = TRUE;
        }
    }

    return hres;
}

// static
void __cdecl CRBDebug::TraceMsg(DWORD dwFlags, LPTSTR pszMsg, ...)
{
    HRESULT hres = S_OK;

    if (!_fInited)
    {
        hres = _Init();
    }

    if (SUCCEEDED(hres))
    {
        if ((_dwTraceFlags & dwFlags) &&
            (TF_NOFILEANDLINE != (_dwTraceFlags & dwFlags)))
        {
            if (!((_dwTraceFlags & TF_NOFILEANDLINE) ||
                (dwFlags & TF_NOFILEANDLINE)))
            {
                // File and line
                _Trace(_szFileAndLine);
            }
            {
                TCHAR szBuf[4096];
                va_list vArgs;
                LPTSTR pszNext;
                size_t cchLeft;

                va_start(vArgs, pszMsg);

                hres = StringCchVPrintfEx(szBuf, ARRAYSIZE(szBuf),
                    &pszNext, &cchLeft, 0, pszMsg, vArgs);

                va_end(vArgs);

                if (SUCCEEDED(hres))
                {
                    hres = StringCchCopy(pszNext, cchLeft, TEXT("\r\n"));
                }
                
                _Trace(szBuf);
            }
        }
    }

    if (_cs.DebugInfo)
    {
        LeaveCriticalSection(&_cs);
    }
}

// static
void CRBDebug::SetTraceFileAndLine(LPCSTR pszFile, const int iLine)
{
    HRESULT hres = S_OK;

    if (!_fInited)
    {
        hres = _Init();
    }

    if (_cs.DebugInfo)
    {
        EnterCriticalSection(&_cs);
    }

    if (SUCCEEDED(hres))
    {
        LPTSTR pszFinal;
        WCHAR szwBuf[MAX_PATH + 12 + 17];
        CHAR szBuf[MAX_PATH + 12 + 17];
        int c = lstrlenA(pszFile);
        LPCSTR pszFileName;
        DWORD dwTimeOffset = 0;

        while (c && ('\\' != *(pszFile + c)))
        {
            --c;
        }

        pszFileName = pszFile + c + 1;

        if (_dwTraceFlags & TF_TIME)
        {
            DWORD dwTick = GetTickCount();
            DWORD dwMilliSec = dwTick % 1000;

            dwTick -= dwMilliSec;
            dwTick /= 1000;
            DWORD dwSec = dwTick % 60;

            dwTick -= dwSec;
            dwTick /= 60;
            DWORD dwMin = dwTick % 60;

            dwTick -= dwMin;
            dwTick /= 60;
            DWORD dwHour = dwTick;

            hres = StringCchPrintfA(szBuf, ARRAYSIZE(szBuf),
                "{%04d:%02d:%02d.%03d}", dwHour, dwMin, dwSec, dwMilliSec);

            dwTimeOffset = 16;
        }

        if (SUCCEEDED(hres))
        {
            if (_dwTraceFlags & TF_THREADID)
            {
                hres = StringCchPrintfA(szBuf + dwTimeOffset,
                    ARRAYSIZE(szBuf) - dwTimeOffset, "~0x%08X~[%s, %d]",
                    GetCurrentThreadId(), pszFileName, iLine);
            }
            else
            {
                hres = StringCchPrintfA(szBuf + dwTimeOffset,
                    ARRAYSIZE(szBuf) - dwTimeOffset, "[%s, %d] ", pszFileName,
                    iLine);
            }

            if (SUCCEEDED(hres))
            {
#ifdef UNICODE
                pszFinal = szwBuf;

                MultiByteToWideChar(CP_ACP, 0, szBuf, lstrlenA(szBuf) + 1, szwBuf,
                    sizeof(szwBuf) / sizeof(WCHAR));
#else
                pszFinal = szBuf;
#endif
                hres = StringCchCopy(_szFileAndLine, ARRAYSIZE(_szFileAndLine),
                    pszFinal);
            }
        }
    }
}

void CRBDebug::_Trace(LPTSTR pszMsg)
{
    if (RBD_TRACE_OUTPUTDEBUG & _dwFlags)
    {
        OutputDebugString(pszMsg);
    }

#ifdef UNICODE
    if (RBD_TRACE_TOFILE & _dwFlags)
#else
    if ((RBD_TRACE_TOFILE & _dwFlags) || (RBD_TRACE_TOFILEANSI & _dwFlags))
#endif
    {
        DWORD dwWritten = 0;

        WriteFile(_hfileTraceFile, pszMsg, lstrlen(pszMsg) * sizeof(TCHAR),
            &dwWritten, NULL);
    }
    else
    {
#ifdef UNICODE
        if (RBD_TRACE_TOFILEANSI & _dwFlags)
        {
            CHAR szBuf[4096];
            DWORD dwWritten = 0;

            WideCharToMultiByte(CP_ACP, 0, pszMsg,
                (lstrlen(pszMsg) + 1), szBuf, sizeof(szBuf), NULL,
                NULL);

            WriteFile(_hfileTraceFile, szBuf, lstrlenA(szBuf), &dwWritten,
                NULL);
        }
#endif
    }

    if (RBD_TRACE_TOPIPE & _dwFlags)
    {
        CallNamedPipe(_szTracePipe, pszMsg, lstrlen(pszMsg) * sizeof(TCHAR),
            NULL, 0, NULL, NMPWAIT_NOWAIT);
    }
}

// static
HRESULT CRBDebug::Init()
{
    return CRBDebug::_Init();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\fact.cpp ===
///////////////////////////////////////////////////////////////////////////////
// CCOMBaseFactory
//    Base class for reusing a single class factory for all components in a DLL

#include "fact.h"
#include "unk.h"
#include "regsvr.h"

#include "dbg.h"

struct OUTPROCINFO
{
    // Reserved (used only for COM Exe server)
    IClassFactory* _pfact;
    DWORD _dwRegister;
};

LONG CCOMBaseFactory::_cServerLocks = 0;
LONG CCOMBaseFactory::_cComponents = 0;
HMODULE CCOMBaseFactory::_hModule = NULL;
CRITICAL_SECTION CCOMBaseFactory::_cs = {0};

OUTPROCINFO* CCOMBaseFactory::_popinfo = NULL;
DWORD CCOMBaseFactory::_dwThreadID = 0;
BOOL CCOMBaseFactory::_fCritSectInit = FALSE;

///////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
STDMETHODIMP CCOMBaseFactory::QueryInterface(REFIID iid, void** ppv)
{   
    IUnknown* punk = NULL;
    HRESULT hres = S_OK;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        punk = this;
        punk->AddRef();
    }
    else
    {
        hres = E_NOINTERFACE;
    }

    *ppv = punk;

    return hres;
}

STDMETHODIMP_(ULONG) CCOMBaseFactory::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CCOMBaseFactory::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = ::InterlockedDecrement(&_cRef);

    if (!cRef)
    {
        delete this;
    }

    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
// IFactory implementation
STDMETHODIMP CCOMBaseFactory::CreateInstance(IUnknown* pUnknownOuter,
    REFIID riid, void** ppv)
{
    HRESULT hres = CLASS_E_NOAGGREGATION;

    // We don't support aggregation at all for now
    if (!pUnknownOuter)
    {
        // Aggregate only if the requested IID is IID_IUnknown.
        if ((pUnknownOuter != NULL) && (riid != IID_IUnknown))
        {
            hres = CLASS_E_NOAGGREGATION;
        }
        else
        {
            // Create the component.
            IUnknown* punkNew;

            hres = _pFactoryData->CreateInstance(
                CCOMBaseFactory::_COMFactoryCB, pUnknownOuter, &punkNew);

            if (SUCCEEDED(hres))
            {
                _COMFactoryCB(TRUE);

                // Get the requested interface.
//                hres = pNewComponent->NondelegatingQueryInterface(iid, ppv);
                hres = punkNew->QueryInterface(riid, ppv);

                // Release the reference held by the class factory.
//                pNewComponent->NondelegatingRelease();
                punkNew->Release();
            }
        }
    }

    return hres;
}

STDMETHODIMP CCOMBaseFactory::LockServer(BOOL fLock)
{
    return _LockServer(fLock);
}

//static
HRESULT CCOMBaseFactory::DllAttach(HINSTANCE hinst)
{
    HRESULT hr;

    _hModule = (HMODULE)hinst;

    if (InitializeCriticalSectionAndSpinCount(&_cs, 0))
    {
        _fCritSectInit = TRUE;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//static
HRESULT CCOMBaseFactory::DllDetach()
{
    if (_fCritSectInit)
    {
        DeleteCriticalSection(&_cs);
        _fCritSectInit = FALSE;
    }            

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Install/Unintall
//static
HRESULT CCOMBaseFactory::_RegisterAll()
{
    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        RegisterServer(_hModule,
           *(_pDLLFactoryData[dw]._pCLSID),
           _pDLLFactoryData[dw]._pszRegistryName,
           _pDLLFactoryData[dw]._pszVerIndProgID,
           _pDLLFactoryData[dw]._pszProgID,
           _pDLLFactoryData[dw]._dwThreadingModel,
           _pDLLFactoryData[dw].IsInprocServer(),
           _pDLLFactoryData[dw].IsLocalServer(),
           _pDLLFactoryData[dw].IsLocalService(),
           _pDLLFactoryData[dw]._pszLocalService,
           _pDLLFactoryData[dw]._pAppID);
    }

    return S_OK;
}

//static
HRESULT CCOMBaseFactory::_UnregisterAll()
{
    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        UnregisterServer(*(_pDLLFactoryData[dw]._pCLSID),
            _pDLLFactoryData[dw]._pszVerIndProgID,
            _pDLLFactoryData[dw]._pszProgID);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CCOMBaseFactory implementation
CCOMBaseFactory::CCOMBaseFactory(const CFactoryData* pFactoryData) : _cRef(1),
    _pFactoryData(pFactoryData)
{}

//static
BOOL CCOMBaseFactory::_IsLocked()
{
    // Always need to be called from within Critical Section

    return (_cServerLocks > 0);
}

//static
HRESULT CCOMBaseFactory::_CanUnloadNow()
{
    HRESULT hres = S_OK;

    // Always need to be called from within Critical Section

    if (_IsLocked())
    {
        hres = S_FALSE;
    }
    else
    {
        if (_cComponents)
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

//static
HRESULT CCOMBaseFactory::_CheckForUnload()
{
    // Always need to be called from within Critical Section

    if (S_OK == _CanUnloadNow())
    {
        ::PostThreadMessage(_dwThreadID, WM_QUIT, 0, 0);
    }

    return S_OK;
}

//static
HRESULT CCOMBaseFactory::_LockServer(BOOL fLock)
{
    HRESULT hres = S_OK;

    EnterCriticalSection(&_cs);

    if (fLock) 
    {
        ++_cServerLocks;
    }
    else
    {
        --_cServerLocks;

        hres = _CheckForUnload();
    }

    LeaveCriticalSection(&_cs);

    return hres;
}

//static
void CCOMBaseFactory::_COMFactoryCB(BOOL fIncrement)
{
    EnterCriticalSection(&_cs);

    if (fIncrement) 
    {
        ++_cComponents;
    }
    else
    {
        --_cComponents;
        _CheckForUnload();
    }

    LeaveCriticalSection(&_cs);
}

///////////////////////////////////////////////////////////////////////////////
// 
// static
HRESULT CCOMBaseFactory::_GetClassObject(REFCLSID rclsid, REFIID riid,
    void** ppv)
{
    HRESULT hres = S_OK;

    ASSERT(_fCritSectInit);

    if ((riid != IID_IUnknown) && (riid != IID_IClassFactory))
    {
        hres = E_NOINTERFACE;
    }
    else
    {
        hres = CLASS_E_CLASSNOTAVAILABLE;

        // Traverse the array of data looking for this class ID.
        for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
        {
            const CFactoryData* pData = &_pDLLFactoryData[dw];

            if (pData->IsClassID(rclsid) && pData->IsInprocServer())
            {
                // Found the ClassID in the array of components we can
                // create.  So create a class factory for this component.
                // Pass the CDLLFactoryData structure to the class factory
                // so that it knows what kind of components to create.
                *ppv = (IUnknown*) new CCOMBaseFactory(pData);

                if (*ppv == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                else
                {
                    hres = S_OK;
                }

                break;
            }
        }
    }

    return hres;
}

//static
BOOL CCOMBaseFactory::_ProcessConsoleCmdLineParams(int argc, wchar_t* argv[],
    BOOL* pfRun, BOOL* pfEmbedded)
{
    _dwThreadID = GetCurrentThreadId();

    if (argc > 1)
    {
        if (!lstrcmpi(argv[1], TEXT("-i")) ||
            !lstrcmpi(argv[1], TEXT("/i")))
        {
            CCOMBaseFactory::_RegisterAll();

            *pfRun = FALSE;
        }
        else
        {
            if (!lstrcmpi(argv[1], TEXT("-u")) ||
                !lstrcmpi(argv[1], TEXT("/u")))
            {
                CCOMBaseFactory::_UnregisterAll();

                *pfRun = FALSE;
            }
            else
            {
                if (!lstrcmpi(argv[1], TEXT("-Embedding")) ||
                    !lstrcmpi(argv[1], TEXT("/Embedding")))
                {
                    *pfRun = TRUE;
                    *pfEmbedded = TRUE;
                }
            }
        }
    }
    else
    {
        *pfEmbedded = FALSE;
        *pfRun = TRUE;
    }

    return TRUE;
}

//static
BOOL CCOMBaseFactory::_RegisterFactories(BOOL fEmbedded)
{
    HRESULT hres = S_OK;
    
    if (!fEmbedded)
    {
        hres = _LockServer(TRUE);
    }

    _popinfo = (OUTPROCINFO*)LocalAlloc(LPTR, sizeof(OUTPROCINFO) * _cDLLFactoryData);

    if (_popinfo)
    {
        for (DWORD dw = 0; SUCCEEDED(hres) && (dw < _cDLLFactoryData); ++dw)
        {
            const CFactoryData* pData = &_pDLLFactoryData[dw];

            if (pData->IsLocalServer() || pData->IsLocalService())
            {
                _popinfo[dw]._pfact = NULL;
                _popinfo[dw]._dwRegister = NULL;

                IClassFactory* pfact = new CCOMBaseFactory(pData);

                if (pfact)
                {
                    DWORD dwRegister;

                    hres = ::CoRegisterClassObject(*pData->_pCLSID,
                        static_cast<IUnknown*>(pfact), pData->_dwClsContext,
                        pData->_dwFlags, &dwRegister);

                    if (SUCCEEDED(hres))
                    {
                        _popinfo[dw]._pfact = pfact;
                        _popinfo[dw]._dwRegister = dwRegister;
                    }
                    else
                    {
                        pfact->Release();
                    }            
                }
                else
                {
                    hres = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return SUCCEEDED(hres);
}

//static
BOOL CCOMBaseFactory::_SuspendFactories()
{
    return SUCCEEDED(::CoSuspendClassObjects());
}

//static
BOOL CCOMBaseFactory::_ResumeFactories()
{
    return SUCCEEDED(::CoResumeClassObjects());
}

//static
BOOL CCOMBaseFactory::_UnregisterFactories(BOOL fEmbedded)
{
    HRESULT hres = S_OK;

    ASSERT(_popinfo);

    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        if (_popinfo[dw]._pfact)
        {
            _popinfo[dw]._pfact->Release();

            HRESULT hresTmp = ::CoRevokeClassObject(_popinfo[dw]._dwRegister);

            if (FAILED(hresTmp) && (S_OK == hres))
            {
                hres = hresTmp;
            }
        }
    }
    
    LocalFree(_popinfo);
    _popinfo = NULL;

    if (!fEmbedded)
    {
        HRESULT hresTmp = _LockServer(FALSE);

        if (FAILED(hresTmp) && (S_OK == hres))
        {
            hres = hresTmp;
        }
    }

    return SUCCEEDED(hres);
}

//static
void CCOMBaseFactory::_WaitForAllClientsToGo()
{
    MSG msg;

    while (::GetMessage(&msg, 0, 0, 0))
    {
        ::DispatchMessage(&msg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\reg.cpp ===
#include "reg.h"

#include "sfstr.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// Forward decl
HRESULT _RegQueryGeneric(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwType, PBYTE pbValue, DWORD* pcbValue);

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _RegOpenKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey)
{
    HRESULT hres;

    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, pszKey, 0, MAXIMUM_ALLOWED, phkey))
    {
        hres = S_OK;
    }
    else
    {
        hres = S_FALSE;
        *phkey = NULL;
    }

    return hres;
}

HRESULT _RegCreateKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey, DWORD* pdwDisp)
{
    HRESULT hres;

    if (ERROR_SUCCESS == RegCreateKeyEx(hkey, pszKey, 0, 0,
        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, phkey, pdwDisp))
    {
        hres = S_OK;
    }
    else
    {
        hres = S_FALSE;
        *phkey = NULL;
    }

    return hres;
}


HRESULT _RegCloseKey(HKEY hkey)
{
    RegCloseKey(hkey);

    return S_OK;
}

HRESULT _RegQueryType(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwType)
{
    return _RegQueryGeneric(hkey, pszSubKey, pszValueName, pdwType, NULL,
        NULL);
}

HRESULT _RegQueryDWORD(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwValue)
{
    DWORD cbValue = sizeof(*pdwValue);

    return _RegQueryGeneric(hkey, pszSubKey, pszValueName, NULL,
        (PBYTE)pdwValue, &cbValue);
}

HRESULT _RegQueryGeneric(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwType, PBYTE pbValue, DWORD* pcbValue)
{
    HRESULT hres = S_FALSE;
    HKEY hkeyLocal = hkey;

    if (pszSubKey)
    {
        hres = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hres = S_OK;
    }

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyLocal, pszValueName, 0, pdwType,
            pbValue, pcbValue))
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hres;
}

HRESULT _RegQueryGenericWithType(HKEY hkey, LPCWSTR pszSubKey,
    LPCWSTR pszValueName, DWORD* pdwType, PBYTE pbValue, DWORD cbValue)
{
    return _RegQueryGeneric(hkey, pszSubKey, pszValueName, pdwType, pbValue,
        &cbValue);
}

HRESULT _RegDeleteValue(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName)
{
    HRESULT hr = S_FALSE;
    HKEY hkeyLocal = hkey;

    if (pszSubKey)
    {
        hr = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        if (ERROR_SUCCESS == RegDeleteValue(hkeyLocal, pszValueName))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hr;
}

HRESULT _RegQueryValueSize(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pcbValue)
{
    return _RegQueryGeneric(hkey, pszSubKey, pszValueName, NULL, NULL,
        pcbValue);
}

HRESULT _RegSetGeneric(HKEY hkey, LPCWSTR pszValueName, DWORD dwType,
    PBYTE pbValue, DWORD cbValue)
{
    HRESULT hres = S_FALSE;

    if (ERROR_SUCCESS == RegSetValueEx(hkey, pszValueName, 0, dwType, pbValue,
        cbValue))
    {
        hres = S_OK;
    }

    return hres;
}

HRESULT _RegSetString(HKEY hkey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    DWORD cb = (lstrlen(pszValue) + 1) * sizeof(WCHAR);

    return _RegSetGeneric(hkey, pszValueName, REG_SZ, (PBYTE)pszValue, cb);
}

HRESULT _RegSetDWORD(HKEY hkey, LPCWSTR pszValueName, DWORD dwValue)
{
    return _RegSetGeneric(hkey, pszValueName, REG_DWORD, (PBYTE)&dwValue,
        sizeof(dwValue));
}

HRESULT _RegSetBinary(HKEY hkey, LPCWSTR pszValueName, PVOID pvValue, DWORD cbValue)
{
    return _RegSetGeneric(hkey, pszValueName, REG_BINARY, (LPBYTE)pvValue, cbValue);
}

HRESULT _RegQueryString(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    LPWSTR pszValue, DWORD cchValue)
{
    DWORD cb = cchValue * sizeof(WCHAR);

    HRESULT hr = _RegQueryGeneric(hkey, pszSubKey, pszValueName, NULL,
        (PBYTE)pszValue, &cb);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Should get back an even number of bytes
        if (!(cb % 2))
        {
            DWORD cchRetrieved = cb / 2;

            // Is it NULL terminated?
            if (pszValue[cchRetrieved - 1])
            {
                // No
                if (cchRetrieved >= (cchValue - 1))
                {
                    pszValue[cchRetrieved] = 0;
                }
                else
                {
                    *pszValue = 0;
                    hr = S_FALSE;
                }
            }
        }
        else
        {
            *pszValue = 0;
            hr = S_FALSE;
        }
    }

    return hr;
}

HRESULT _RegEnumStringValue(HKEY hkey, DWORD dwIndex, LPWSTR pszValue,
    DWORD cchValue)
{
    HRESULT hres = S_FALSE;
    LONG lRes;

    if (ERROR_SUCCESS == (lRes = RegEnumValue(hkey, dwIndex, pszValue,
        &cchValue, 0, 0, 0, 0)))
    {
        hres = S_OK;
    }
    else
    {
        if ((ERROR_SUCCESS != lRes) && (ERROR_NO_MORE_ITEMS != lRes))
        {
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT _RegEnumStringKey(HKEY hkey, DWORD dwIndex, LPWSTR pszKey,
    DWORD cchKey)
{
    HRESULT hres = S_FALSE;
    LONG lRes;

    if (ERROR_SUCCESS == (lRes = RegEnumKeyEx(hkey, dwIndex, pszKey,
        &cchKey, NULL, NULL, NULL, NULL)))
    {
        hres = S_OK;
    }
    else
    {
        if (ERROR_NO_MORE_ITEMS != lRes)
        {
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT _RegSetKeyAndString(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszSubkey,
    LPCWSTR pszValueName, LPCWSTR pszValue)
{
    ASSERT(pszKey && *pszKey);

    WCHAR szKeyBuf[MAX_KEY];
    LPWSTR pszNext;
    DWORD cchLeft;
    HRESULT hres = SafeStrCpyNEx(szKeyBuf, pszKey, ARRAYSIZE(szKeyBuf),
        &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
        HKEY hkeyNew;

	    if (pszSubkey)
	    {
            hres = SafeStrCpyNEx(pszNext, TEXT("\\"), cchLeft, &pszNext,
                &cchLeft);

            if (SUCCEEDED(hres))
            {
                hres = SafeStrCpyNEx(pszNext, pszSubkey, cchLeft, &pszNext,
                    &cchLeft);
            }
	    }

        if (SUCCEEDED(hres))
        {
	        // Create and open key and subkey.
	        hres= _RegCreateKey(hkey, szKeyBuf, &hkeyNew, NULL);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
	            if (pszValue)
	            {
                    hres = _RegSetString(hkeyNew, pszValueName, pszValue);
	            }

	            RegCloseKey(hkeyNew);
            }
        }
    }

	return hres;
}

HRESULT _RegSubkeyExists(HKEY hkey, LPCWSTR pszPath, LPCWSTR pszSubkey)
{
	WCHAR szKeyBuf[MAX_PATH];
    LPWSTR pszNext;
    DWORD cchLeft;

	// Copy keyname into buffer.
	HRESULT hres = SafeStrCpyNEx(szKeyBuf, pszPath, ARRAYSIZE(szKeyBuf),
        &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
	    HKEY hkey2;

	    if (pszSubkey)
	    {
		    hres = SafeStrCpyNEx(pszNext, TEXT("\\"),  cchLeft, &pszNext,
                &cchLeft);

            if (SUCCEEDED(hres))
            {
		        hres = SafeStrCpyNEx(pszNext, pszSubkey,  cchLeft, &pszNext,
                    &cchLeft);
            }
	    }

        if (SUCCEEDED(hres))
        {
	        // Determine if key exists by trying to open it.
	        hres = _RegOpenKey(hkey, szKeyBuf, &hkey2);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
    		    _RegCloseKey(hkey2);
            }
        }
    }

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\namellst.cpp ===
#include "namellst.h"

#include "sfstr.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

//=============================================================================
//=============================================================================
//==                          CNamedElem                                     ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CNamedElem::GetName(LPTSTR psz, DWORD cch, DWORD* pcchRequired)
{
    return SafeStrCpyNReq(psz, _pszElemName, cch, pcchRequired);
}

#ifdef DEBUG
LPCTSTR CNamedElem::DbgGetName()
{
    return _pszElemName;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Protected
CNamedElem::CNamedElem() : _pszElemName(NULL)
{}

CNamedElem::~CNamedElem()
{
    if (_pszElemName)
    {
        _FreeName();
    }
}

HRESULT CNamedElem::_SetName(LPCTSTR pszElemName)
{
    ASSERT(!_pszElemName);
    HRESULT hres;
    DWORD cch = lstrlen(pszElemName) + 1;

    ASSERT(cch);

    _pszElemName = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));

    if (_pszElemName)
    {
        hres = SafeStrCpyN(_pszElemName, pszElemName, cch);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CNamedElem::_FreeName()
{
    ASSERT(_pszElemName);
    LocalFree((HLOCAL)_pszElemName);
    return S_OK;
}

//=============================================================================
//=============================================================================
//==                          CNamedElemList                                 ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CNamedElemList::Init(NAMEDELEMCREATEFCT createfct,
    NAMEDELEMGETFILLENUMFCT enumfct)
{
    HRESULT hres;

    _createfct = createfct;
    _enumfct = enumfct;

    _pcs = new CRefCountedCritSect();

    if (_pcs)
    {
        if (InitializeCriticalSectionAndSpinCount(_pcs, 0))
        {
            hres = S_OK;
        }
        else
        {
            delete _pcs;
            _pcs = NULL;

            hres = E_FAIL;
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CNamedElemList::GetOrAdd(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    HRESULT hres = E_INVALIDARG;

    *ppelem = NULL;

    if (pszElemName)
    {
        CElemSlot* pes;

        EnterCriticalSection(_pcs);

        hres = _GetElemSlot(pszElemName, &pes);

        if (SUCCEEDED(hres))
        {
            if (S_FALSE != hres)
            {
                // Got one
                hres = pes->GetNamedElem(ppelem);

                pes->RCRelease();
            }
            else
            {
                // None found
                hres = _Add(pszElemName, ppelem);

                if (SUCCEEDED(hres))
                {
#ifdef DEBUG
                    TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Added to '%s': '%s'"),
                        _szDebugName, pszElemName);
#endif
                    hres = S_FALSE;
                }
            }
        }

        LeaveCriticalSection(_pcs);
    }

    return hres;
}

HRESULT CNamedElemList::Get(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    HRESULT hres = E_INVALIDARG;

    *ppelem = NULL;

    if (pszElemName)
    {
        CElemSlot* pes;

        EnterCriticalSection(_pcs);

        hres = _GetElemSlot(pszElemName, &pes);

        if (SUCCEEDED(hres))
        {
            if (S_FALSE != hres)
            {
                // Got one
                hres = pes->GetNamedElem(ppelem);

                pes->RCRelease();
            }
        }

        LeaveCriticalSection(_pcs);
    }

    return hres;
}

HRESULT CNamedElemList::Add(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    HRESULT hres = E_INVALIDARG;

    if (pszElemName)
    {
        EnterCriticalSection(_pcs);

        hres = _Add(pszElemName, ppelem);

        LeaveCriticalSection(_pcs);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Added to '%s': '%s'"),
                _szDebugName, pszElemName);
        }
#endif
    }

    return hres;
}

HRESULT CNamedElemList::Remove(LPCTSTR pszElemName)
{
    HRESULT hres = E_INVALIDARG;

    if (pszElemName)
    {
        EnterCriticalSection(_pcs);

        hres = _Remove(pszElemName);

        LeaveCriticalSection(_pcs);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            if (S_FALSE != hres)
            {
                TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Removed from '%s': '%s'"),
                    _szDebugName, pszElemName);
            }
            else
            {
                TRACE(TF_NAMEDELEMLISTMODIF,
                    TEXT("TRIED to remove from '%s': '%s'"),
                    _szDebugName, pszElemName);
            }
        }
#endif
    }

    return hres;
}

HRESULT CNamedElemList::ReEnum()
{
    HRESULT hres = E_FAIL;

    if (_enumfct)
    {
#ifdef DEBUG
        TRACE(TF_NAMEDELEMLISTMODIF, TEXT("ReEnum '%s' beginning"),
            _szDebugName);
#endif
        EnterCriticalSection(_pcs);
    
        hres = _EmptyList();

        if (SUCCEEDED(hres))
        {
            CFillEnum* pfillenum;

            hres = _enumfct(&pfillenum);

            if (SUCCEEDED(hres))
            {
                TCHAR szElemName[MAX_PATH];
                LPTSTR pszElemName = szElemName;
                DWORD cchReq;

                do
                {
                    hres = pfillenum->Next(szElemName, ARRAYSIZE(szElemName),
                        &cchReq);

                    if (S_FALSE != hres)
                    {
                        if (E_BUFFERTOOSMALL == hres)
                        {
                            pszElemName = (LPTSTR)LocalAlloc(LPTR, cchReq *
                                sizeof(TCHAR));

                            if (pszElemName)
                            {
                                hres = pfillenum->Next(pszElemName, cchReq,
                                    &cchReq);
                            }
                            else
                            {
                                hres = E_OUTOFMEMORY;
                            }
                        }

                        if (SUCCEEDED(hres) && (S_FALSE != hres))
                        {
                            hres = _Add(pszElemName, NULL);

#ifdef DEBUG
                            if (SUCCEEDED(hres))
                            {
                                TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Added to '%s': '%s'"),
                                    _szDebugName, pszElemName);
                            }
#endif
                            if (FAILED(hres))
                            {
                                // We want to continue the enumeration
                                hres = S_OK;
                            }
                        }

                        if (pszElemName && (pszElemName != szElemName))
                        {
                            LocalFree((HLOCAL)pszElemName);
                        }
                    }
                }
                while (SUCCEEDED(hres) && (S_FALSE != hres));

                pfillenum->RCRelease();
            }
        }

        LeaveCriticalSection(_pcs);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            TRACE(TF_NAMEDELEMLISTMODIF, TEXT("ReEnumed '%s'"), _szDebugName);
        }
#endif
    }

    return hres;
}

HRESULT CNamedElemList::EmptyList()
{
    HRESULT hres;

    EnterCriticalSection(_pcs);

    hres = _EmptyList();

    LeaveCriticalSection(_pcs);

#ifdef DEBUG
    if (SUCCEEDED(hres))
    {
        TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Emptied '%s'"), _szDebugName);
    }
#endif

    return hres;
}

HRESULT CNamedElemList::GetEnum(CNamedElemEnum** ppenum)
{
    HRESULT hres;

    CNamedElemEnum* penum = new CNamedElemEnum();

    if (penum)
    {
        CElemSlot* pesTail;

        EnterCriticalSection(_pcs);

        hres = _GetTail(&pesTail);

        if (SUCCEEDED(hres))
        {
            hres = penum->_Init(pesTail, _pcs);

            if (SUCCEEDED(hres))
            {
                *ppenum = penum;
            }
            else
            {
                delete penum;
            }

            if (pesTail)
            {
                pesTail->RCRelease();
            }
        }

        LeaveCriticalSection(_pcs);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

CNamedElemList::CNamedElemList() : _pcs(NULL), _pesHead(NULL)
{
#ifdef DEBUG
    _szDebugName[0] = 0;
#endif
}

void CNamedElemList::RealRemoveElemSlotCallback(CElemSlot* pes)
{
    ASSERT(pes == _pesHead);

    _pesHead = pes->GetNext();

    if (_pesHead)
    {
        // we don't keep a ref on the head
        _pesHead->RCRelease();

        _pesHead->SetCallbackPointer(this);
    }
}

CNamedElemList::~CNamedElemList()
{
    if (_pcs)
    {
        EnterCriticalSection(_pcs);

        if (_pesHead)
        {
            // This list is going away.  We don't want this CElemSlot to
            // callback on an invalid pointer.
            _pesHead->SetCallbackPointer(NULL);
        }

        _EmptyList();

        LeaveCriticalSection(_pcs);

        DeleteCriticalSection(_pcs);

        _pcs->RCRelease();
    }
}
///////////////////////////////////////////////////////////////////////////////
// Private
// All these fcts have to be called from within The critical section
HRESULT CNamedElemList::_Add(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    CNamedElem* pelem;
    HRESULT hres = _createfct(&pelem);

    if (SUCCEEDED(hres))
    {
        hres = pelem->Init(pszElemName);

        if (SUCCEEDED(hres))
        {
            CElemSlot* pes = new CElemSlot();

            if (pes)
            {
                // This takes an additionnal ref on pelem
                hres = pes->Init(pelem, NULL, _pesHead);

                if (SUCCEEDED(hres))
                {
                    if (_pesHead)
                    {
                        _pesHead->SetCallbackPointer(NULL);

                        _pesHead->SetPrev(pes);
                    }

                    _pesHead = pes;
                    _pesHead->SetCallbackPointer(this);
                }
                else
                {
                    pes->RCRelease();
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }

        pelem->RCRelease();

        if (FAILED(hres))
        {
            pelem = NULL;
        }
    }
    
    if (ppelem)
    {
        if (pelem)
        {
            pelem->RCAddRef();
        }

        *ppelem = pelem;
    }

    return hres;
}

HRESULT CNamedElemList::_GetTail(CElemSlot** ppes)
{
    HRESULT hr;
    CElemSlot* pesLastValid = _GetValidHead();
        
    if (pesLastValid)
    {
        CElemSlot* pesOld = pesLastValid;

        while (NULL != (pesLastValid = pesLastValid->GetNextValid()))
        {
            pesOld->RCRelease();

            pesOld = pesLastValid;
        }

        pesLastValid = pesOld;

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    // pesLastValid is already RCAddRef'ed
    *ppes = pesLastValid;

    return hr;
}

HRESULT CNamedElemList::_GetElemSlot(LPCTSTR pszElemName, CElemSlot** ppes)
{
    HRESULT hres = S_FALSE;

    CElemSlot* pes = _GetValidHead();
    CElemSlot* pesOld = pes;

    while (pes && SUCCEEDED(hres) && (S_FALSE == hres))
    {
        CNamedElem* pelem;

        hres = pes->GetNamedElem(&pelem);

        if (SUCCEEDED(hres))
        {
            TCHAR szElemName[MAX_PATH];
            LPTSTR pszElemNameLocal = szElemName;
            DWORD cchReq;

            hres = pelem->GetName(szElemName, ARRAYSIZE(szElemName), &cchReq);

            if (E_BUFFERTOOSMALL == hres)
            {
                pszElemNameLocal = (LPTSTR)LocalAlloc(LPTR, cchReq *
                    sizeof(TCHAR));

                if (pszElemNameLocal)
                {
                    hres = pelem->GetName(pszElemNameLocal, cchReq, &cchReq);
                }
                else
                {
                    hres = E_OUTOFMEMORY;
                }
            }

            pelem->RCRelease();

            if (SUCCEEDED(hres))
            {
                if (!lstrcmpi(pszElemNameLocal, pszElemName))
                {
                    // Found it!
                    pes->RCAddRef();

                    *ppes = pes;

                    hres = S_OK;
                }
                else
                {
                    ASSERT(pesOld == pes);

                    pes = pes->GetNextValid();

                    hres = S_FALSE;
                }
            }

            if (pszElemNameLocal && (pszElemNameLocal != szElemName))
            {
                LocalFree((HLOCAL)pszElemNameLocal);
            }
        }

        pesOld->RCRelease();
        pesOld = pes;
    }

    return hres;
}

HRESULT CNamedElemList::_Remove(LPCTSTR pszElemName)
{
    ASSERT(pszElemName);
    CElemSlot* pes;

    HRESULT hres = _GetElemSlot(pszElemName, &pes);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        hres = pes->Remove();

        // 2: one to balance the _GetElemSlot and one to remove from list
        pes->RCRelease();
        pes->RCRelease();
    }

    return hres;
}

HRESULT CNamedElemList::_EmptyList()
{
    HRESULT hres = S_FALSE;

    CElemSlot* pes = _GetValidHead();

    if (_pesHead)
    {
        _pesHead->SetCallbackPointer(NULL);
    }

    while (pes)
    {
        CElemSlot* pesOld = pes;

        pes->Remove();

        pes = pes->GetNextValid();

        // 2: one to balance the _GetValidHead/GetNextValid and one to remove
        // from list
        pesOld->RCRelease();
        pesOld->RCRelease();
    }

    _pesHead = NULL;

    return hres;
}

CElemSlot* CNamedElemList::_GetValidHead()
{
    CElemSlot* pes = _pesHead;

    if (pes)
    {
        if (pes->IsValid())
        {
            pes->RCAddRef();
        }
        else
        {
            pes = pes->GetNextValid();
        }
    }
    
    return pes;
}

#ifdef DEBUG
HRESULT CNamedElemList::InitDebug(LPWSTR pszDebugName)
{
    return SafeStrCpyN(_szDebugName, pszDebugName,
        ARRAYSIZE(_szDebugName));
}

void CNamedElemList::AssertNoDuplicate()
{
    EnterCriticalSection(_pcs);

    CElemSlot* pes = _GetValidHead();

    while (pes)
    {
        CElemSlot* pesOld = pes;
        CNamedElem* pelem;
        WCHAR szName[1024];

        HRESULT hres = pes->GetNamedElem(&pelem);
        
        if (SUCCEEDED(hres))
        {
            DWORD cchReq;
            hres = pelem->GetName(szName, ARRAYSIZE(szName), &cchReq);

            if (SUCCEEDED(hres))
            {
                CElemSlot* pesIn = pes->GetNextValid();

                while (pesIn)
                {
                    CElemSlot* pesInOld = pesIn;
                    CNamedElem* pelemIn;
                    WCHAR szNameIn[1024];

                    hres = pesIn->GetNamedElem(&pelemIn);
        
                    if (SUCCEEDED(hres))
                    {
                        DWORD cchReqIn;
                        hres = pelemIn->GetName(szNameIn, ARRAYSIZE(szNameIn),
                            &cchReqIn);

                        if (SUCCEEDED(hres))
                        {
                            ASSERT(lstrcmp(szName, szNameIn));
                        }

                        pelemIn->RCRelease();
                    }

                    pesIn = pesIn->GetNextValid();

                    pesInOld->RCRelease();
                }
            }

            pelem->RCRelease();
        }

        pes = pes->GetNextValid();

        pesOld->RCRelease();
    }

    LeaveCriticalSection(_pcs);
}

void CNamedElemList::AssertAllElemsRefCount1()
{
    EnterCriticalSection(_pcs);

    CElemSlot* pes = _GetValidHead();

    while (pes)
    {
        CElemSlot* pesOld = pes;
        CNamedElem* pelem;

        HRESULT hres = pes->GetNamedElem(&pelem);
        
        if (SUCCEEDED(hres))
        {
            pelem->RCRelease();
        }

        pes = pes->GetNextValid();

        pesOld->RCRelease();
    }

    LeaveCriticalSection(_pcs);
}
#endif
//=============================================================================
//=============================================================================
//==                          CNamedElemEnum                                 ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CNamedElemEnum::Next(CNamedElem** ppelem)
{
    HRESULT hres = S_FALSE;

    *ppelem = NULL;

    EnterCriticalSection(_pcsList);

    if (_pesCurrent)
    {
        CElemSlot* pes = _pesCurrent;

        if (!_fFirst || !pes->IsValid())
        {
            pes = pes->GetPrevValid();

            _pesCurrent->RCRelease();
            _pesCurrent = pes;
        }

        if (pes)
        {
            hres = pes->GetNamedElem(ppelem);
        }

        _fFirst = FALSE;
    }

    LeaveCriticalSection(_pcsList);

    return hres;
}

CNamedElemEnum::CNamedElemEnum() : _pesCurrent(NULL), _pcsList(NULL)
{
#ifdef DEBUG
    static TCHAR _szDebugName[] = TEXT("CNamedElemEnum");
#endif
}

CNamedElemEnum::~CNamedElemEnum()
{
    if (_pcsList)
    {
        EnterCriticalSection(_pcsList);

        if (_pesCurrent)
        {
            _pesCurrent->RCRelease();
        }

        LeaveCriticalSection(_pcsList);

        _pcsList->RCRelease();
    }
}
///////////////////////////////////////////////////////////////////////////////
// Private
HRESULT CNamedElemEnum::_Init(CElemSlot* pesHead, CRefCountedCritSect* pcsList)
{
    pcsList->RCAddRef();

    _pcsList = pcsList;
    _fFirst = TRUE;

    EnterCriticalSection(_pcsList);

    _pesCurrent = pesHead;

    if (_pesCurrent)
    {
        _pesCurrent->RCAddRef();
    }

    LeaveCriticalSection(_pcsList);

    return S_OK;
}

//=============================================================================
//=============================================================================
//==                          CElemSlot                                      ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CElemSlot::Init(CNamedElem* pelem, CElemSlot* pesPrev,
    CElemSlot* pesNext)
{
    _pelem = pelem;
    pelem->RCAddRef();
    
    _fValid = TRUE;
    _pesPrev = pesPrev;
    _pesNext = pesNext;

    return S_OK;
}

HRESULT CElemSlot::Remove()
{
    _fValid = FALSE;
    _pelem->RCRelease();
    _pelem = NULL; 

    return S_OK;
}

HRESULT CElemSlot::GetNamedElem(CNamedElem** ppelem)
{
    ASSERT(_fValid);

    _pelem->RCAddRef();
    *ppelem = _pelem;
    
    return S_OK;
}

void CElemSlot::SetPrev(CElemSlot* pes)
{
    _pesPrev = pes;
}

CElemSlot* CElemSlot::GetNextValid()
{
    CElemSlot* pes = _pesNext;

    while (pes && !pes->IsValid())
    {
        pes = pes->_pesNext;
    }

    if (pes)
    {
        pes->RCAddRef();
    }
    
    return pes;
}

CElemSlot* CElemSlot::GetNext()
{
    if (_pesNext)
    {
        _pesNext->RCAddRef();
    }

    return _pesNext;
}

CElemSlot* CElemSlot::GetPrevValid()
{
    CElemSlot* pes = _pesPrev;

    while (pes && !pes->IsValid())
    {
        pes = pes->_pesPrev;
    }

    if (pes)
    {
        pes->RCAddRef();
    }
    
    return pes;
}

BOOL CElemSlot::IsValid()
{
    return _fValid;
}

void CElemSlot::SetCallbackPointer(CNamedElemList* pnel)
{
    _pnel = pnel;
}

CElemSlot::CElemSlot() : _fValid(FALSE), _pesPrev(NULL), _pesNext(NULL),
    _pnel(NULL)
{
#ifdef DEBUG
    static TCHAR _szDebugName[] = TEXT("CElemSlot");
#endif
}

CElemSlot::~CElemSlot()
{
    ASSERT(!_fValid);

    if (_pnel)
    {
        // This elem is the head of the list
        _pnel->RealRemoveElemSlotCallback(this);
    }

    if (_pesPrev)
    {
        _pesPrev->_pesNext = _pesNext;
    }

    if (_pesNext)
    {
        _pesNext->_pesPrev = _pesPrev;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\str.cpp ===
#include "str.h"

#include "sfstr.h"

#include "dbg.h"

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _StringFromGUID(const GUID* pguid, LPWSTR psz, DWORD cch)
{
    LPOLESTR pstr;
    HRESULT hres = StringFromCLSID(*pguid, &pstr);

    if (SUCCEEDED(hres))
    {
        // check size of string
        hres = SafeStrCpyN(psz, pstr, cch);

        CoTaskMemFree(pstr);
    }

    return hres;
}

HRESULT _GUIDFromString(LPCWSTR psz, GUID* pguid)
{
    return CLSIDFromString((LPOLESTR)psz, pguid);
} 

HRESULT _CreateGUID(LPWSTR pszGUID, DWORD cchGUID)
{
    GUID guid;
    HRESULT hr = CoCreateGuid(&guid);

    if (SUCCEEDED(hr))
    {
        hr = _StringFromGUID(&guid, pszGUID, cchGUID);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\sfstr.cpp ===
#include "sfstr.h"

#include "dbg.h"

HRESULT _SafeStrCpyN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest)
{
    ASSERT(pszDest && pszSrc && (cchDest > 0));
    HRESULT hres = E_BUFFERTOOSMALL;

    // Need room for NULL terminator
    --cchDest;

    while (cchDest && *pszSrc)
    {
        *pszDest = *pszSrc;

        ++pszDest;
        ++pszSrc;
        --cchDest;
    }

    // Did we reach the end?
    if (!*pszSrc)
    {
        // Yep
        *pszDest = 0;
        hres = S_OK;
    }
    
    return hres;    
}

HRESULT SafeStrCpyN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0))
    {
        hres = _SafeStrCpyN(pszDest, pszSrc, cchDest);
    }

    return hres;
}

HRESULT SafeStrCatN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0))
    {
        LPWSTR psz = pszDest;

        hres = E_BUFFERTOOSMALL;

        while (cchDest && *psz)
        {
            ++psz;
            --cchDest;
        }

        if (cchDest)
        {
            hres = _SafeStrCpyN(psz, pszSrc, cchDest);
        }
    }
    
    return hres;
}

HRESULT _SafeStrCpyNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    ASSERT(pszDest && pszSrc && (cchDest > 0) && ppszEnd && pcchLeft);

    HRESULT hres = E_BUFFERTOOSMALL;

    // Need room for NULL terminator
    --cchDest;

    while (cchDest && *pszSrc)
    {
        *pszDest = *pszSrc;

        ++pszDest;
        ++pszSrc;
        --cchDest;
    }

    // Did we reach the end?
    if (!*pszSrc)
    {
        // Yep
        *pszDest = 0;
        *ppszEnd = pszDest;
        *pcchLeft = (cchDest + 1);

        hres = S_OK;
    }
    
    return hres;
}

HRESULT SafeStrCpyNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0) && ppszEnd && pcchLeft)
    {
        hres = _SafeStrCpyNEx(pszDest, pszSrc, cchDest, ppszEnd, pcchLeft);
    }

    return hres;
}

HRESULT SafeStrCatNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0) && ppszEnd && pcchLeft)
    {
        LPWSTR psz = pszDest;

        hres = E_BUFFERTOOSMALL;

        while (cchDest && *psz)
        {
            ++psz;
            --cchDest;
        }

        if (cchDest)
        {
            hres = _SafeStrCpyNEx(psz, pszSrc, cchDest, ppszEnd, pcchLeft);
        }
    }
    
    return hres;
}

HRESULT SafeStrCpyNReq(LPWSTR pszDest, LPWSTR pszSrc, DWORD cchDest,
    DWORD* pcchRequired)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && cchDest && pcchRequired)
    {
        hres = SafeStrCpyN(pszDest, pszSrc, cchDest);

        if (E_BUFFERTOOSMALL == hres)
        {
            *pcchRequired = lstrlen(pszSrc) + 1;
        }
        else
        {
            *pcchRequired = 0;
        }
    }

    return hres;
}

HRESULT _SafeStrCpyNExactEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact, LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT((ppszEnd && pcchLeft) || (!ppszEnd && !pcchLeft));

    if (pszDest && pszSrc && (cchDest > 0) && (cchExact > 0))
    {
        // Need room for NULL terminator
        --cchDest;
        --cchExact;

        while (cchDest && cchExact && *pszSrc)
        {
            *pszDest = *pszSrc;

            ++pszDest;
            ++pszSrc;
            --cchDest;
            --cchExact;
        }

        // Did we stop because we copied the Exact # of chars to copy?
        if (!cchExact)
        {
            // Yep, NULL terminate it!
            *pszDest = 0;

            if (ppszEnd)
            {
                *ppszEnd = pszDest;
                *pcchLeft = (cchDest + 1);
            }

            hres = S_OK;
        }
        else
        {
            // Did we stop because we met the end of the sources string before
            // copying cchExact chars?
            if (!*pszSrc)
            {
                // Yes
                hres = E_SOURCEBUFFERTOOSMALL;
            }
            else
            {
                // No
                hres = E_BUFFERTOOSMALL;
            }
        }
    }
    
    return hres;
}

HRESULT SafeStrCpyNExact(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact)
{
    return _SafeStrCpyNExactEx(pszDest, pszSrc, cchDest, cchExact, NULL, NULL);
}

HRESULT SafeStrCpyNExactEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact, LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    if (ppszEnd && pcchLeft)
    {
        hres = _SafeStrCpyNExactEx(pszDest, pszSrc, cchDest, cchExact, ppszEnd,
            pcchLeft);
    }
    
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\regsvr.cpp ===
#include "regsvr.h"

#include "reg.h"
#include "str.h"
#include "sfstr.h"

#include "factdata.h"

#include <sddl.h>


#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
// Internal helper functions prototypes
LONG _RecursiveDeleteKey(HKEY hKeyParent, LPCWSTR szKeyChild);

///////////////////////////////////////////////////////////////////////////////
// Constants

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39;


///////////////////////////////////////////////////////////////////////////////
// Public function implementation

HRESULT RegisterAppID(const CLSID* pclsidAppID)
{
    WCHAR szAppID[CLSID_STRING_SIZE];
    WCHAR szKey[MAX_KEY] = TEXT("AppID\\");

    HRESULT hres = _StringFromGUID(pclsidAppID, szAppID, ARRAYSIZE(szAppID));
    if (SUCCEEDED(hres))
    {
        hres = SafeStrCatN(szKey, szAppID, ARRAYSIZE(szKey));
        if (SUCCEEDED(hres))
        {
            // Add the CLSID key and the FriendlyName
            HKEY hkey;
            hres= _RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey, NULL);
            if (S_OK == hres)
            {
                hres = _RegSetString(hkey, L"LocalService", L"ShellHWDetection");

                if (SUCCEEDED(hres))
                {
                    PSECURITY_DESCRIPTOR pSD;
                    ULONG cbSD;

                    //
                    // NTRAID#NTBUG9-258937-2001/01/17-jeffreys
                    //
                    // Set the launch permissions to prevent COM from ever
                    // launching the service. The only time we want the service
                    // to launch is at system startup.
                    //
                    // Don't think the owner and group matter, but they must be
                    // present, or COM thinks the security descriptor is invalid.
                    // O:SY --> Owner = LocalSystem
                    // G:BA --> Group = Local Administrators group
                    //
                    // The DACL has a single Deny ACE
                    // D:(D;;1;;;WD) --> Deny COM_RIGHTS_EXECUTE (1) to Everyone (WD)
                    //
                    if (ConvertStringSecurityDescriptorToSecurityDescriptorW(L"O:SYG:BAD:(D;;1;;;WD)", SDDL_REVISION, &pSD, &cbSD))
                    {
                        hres = _RegSetBinary(hkey, L"LaunchPermission", pSD, cbSD);
                        LocalFree(pSD);
                    }
                    else
                    {
                        hres = E_OUTOFMEMORY;
                    }
                }

                RegCloseKey(hkey);
            }
        }
    }
    return hres;
}

// Register the component in the registry.
HRESULT RegisterServer(HMODULE hModule, REFCLSID rclsid,
    LPCWSTR pszFriendlyName, LPCWSTR pszVerIndProgID, LPCWSTR pszProgID,
    DWORD dwThreadingModel, BOOL fInprocServer, BOOL fLocalServer,
    BOOL fLocalService, LPCWSTR pszLocalService, const CLSID* pclsidAppID)
{
    WCHAR szCLSID[CLSID_STRING_SIZE];
    WCHAR szKey[MAX_KEY] = TEXT("CLSID\\");

    HRESULT hres = _StringFromGUID(&rclsid, szCLSID, ARRAYSIZE(szCLSID));
    if (SUCCEEDED(hres))
    {
        LPWSTR pszModel = NULL;
        WCHAR szFree[] = TEXT("Free");
        WCHAR szApartment[] = TEXT("Apartment");
        WCHAR szNeutral[] = TEXT("Neutral");
        WCHAR szBoth[] = TEXT("Both");

        hres = SafeStrCatN(szKey, szCLSID, ARRAYSIZE(szKey));

        // Boring set of operations....
        if (SUCCEEDED(hres))
        {
            // Add the CLSID key and the FriendlyName
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey, NULL, NULL,
                pszFriendlyName);
        }

        if (SUCCEEDED(hres))
        {
            switch (dwThreadingModel)
            {
                case THREADINGMODEL_BOTH:
                    pszModel = szBoth;
                    break;
                case THREADINGMODEL_FREE:
                    pszModel = szFree;
                    break;
                case THREADINGMODEL_APARTMENT:
                    pszModel = szApartment;
                    break;
                case THREADINGMODEL_NEUTRAL:
                    pszModel = szNeutral;
                    break;

                default:
                    hres = E_FAIL;
                    break;
            }
        }

        if (SUCCEEDED(hres))
        {
	        // Add the server filename subkey under the CLSID key.
            if (fInprocServer)
            {
	            WCHAR szModule[MAX_PATH];
	            DWORD dwResult = GetModuleFileName(hModule, szModule,
                    ARRAYSIZE(szModule));

                if (dwResult)
                {
                    // Register as Inproc
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                        TEXT("InprocServer32"), NULL, szModule);

                    if (SUCCEEDED(hres))
                    {
                        hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                            TEXT("InprocServer32"), TEXT("ThreadingModel"),
                            pszModel);
                    }
                }
            }
        }

        if (SUCCEEDED(hres))
        {
	        // Add the server filename subkey under the CLSID key.
            if (fLocalServer)
            {
	            WCHAR szModule[MAX_PATH];
                // Note the NULL as 1st arg.  This way a DLL can register a
                // factory as part of an EXE.  Obviously, if this is done
                // from 2 EXE's, only the last one will win...
	            DWORD dwResult = GetModuleFileName(NULL, szModule,
                    ARRAYSIZE(szModule));

                if (dwResult)
                {
                    // Register as LocalServer
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                        TEXT("LocalServer32"), NULL, szModule);

                    if (SUCCEEDED(hres))
                    {
                        hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                            TEXT("LocalServer32"), TEXT("ThreadingModel"),
                            pszModel);
                    }
                }
            }
        }

        if (SUCCEEDED(hres))
        {
	        // Add the server filename subkey under the CLSID key.
            if (fLocalService)
            {
                // Register as LocalServer
                hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                    TEXT("LocalService"), NULL, pszLocalService);

                if (SUCCEEDED(hres))
                {
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                        TEXT("LocalService"), TEXT("ThreadingModel"),
                        pszModel);
                }

                {
                    // We had this bug for a while that a LocalServer32 key was
                    // also installed
                    // Delete it on upgrade (stephstm: Jun/02/2000)
                    // Remove this code when nobody will upgrade from
                    // builds earlier than 2242
                    WCHAR szKeyLocal[MAX_KEY];

                    SafeStrCpyN(szKeyLocal, szKey, ARRAYSIZE(szKeyLocal));

                    SafeStrCatN(szKeyLocal, TEXT("\\LocalServer32"),
                        ARRAYSIZE(szKeyLocal));

                    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKeyLocal);
                }
            }
        }
        
        if (SUCCEEDED(hres))
        {
            // Add the ProgID subkey under the CLSID key.
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                TEXT("ProgID"), NULL, pszProgID);
        }

        if (SUCCEEDED(hres))
        {
	        // Add the version-independent ProgID subkey under CLSID
            // key.
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                TEXT("VersionIndependentProgID"), NULL, pszVerIndProgID);
        }

        if (SUCCEEDED(hres))
        {
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszVerIndProgID,
                NULL, NULL, pszFriendlyName);
        }

        if (SUCCEEDED(hres))
        {
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszVerIndProgID,
                TEXT("CLSID"), NULL, szCLSID);
        }

        if (SUCCEEDED(hres))
        {
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszVerIndProgID,
                TEXT("CurVer"), NULL, pszProgID);
        }

        if (SUCCEEDED(hres))
        {
	        // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszProgID,
                NULL, NULL, pszFriendlyName);
        }

        if (SUCCEEDED(hres))
        {
	        // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszProgID,
                TEXT("CLSID"), NULL, szCLSID);
        }

        if (SUCCEEDED(hres))
        {
            if (pclsidAppID)
            {
                // do the AppID.

                WCHAR szAppID[CLSID_STRING_SIZE];
                hres = _StringFromGUID(pclsidAppID, szAppID, ARRAYSIZE(szAppID));
                if (SUCCEEDED(hres))
                {
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey, NULL, TEXT("AppID"), szAppID);
                }

                RegisterAppID(pclsidAppID);
            }
        }
    }
    
    return hres;
}

// Remove the component from the registry.
HRESULT UnregisterServer(REFCLSID rclsid, LPCWSTR pszVerIndProgID,
    LPCWSTR pszProgID)
{
	WCHAR szCLSID[CLSID_STRING_SIZE];
	WCHAR szKey[MAX_KEY] = TEXT("CLSID\\");
   
    HRESULT hres = _StringFromGUID(&rclsid, szCLSID, ARRAYSIZE(szCLSID));

    if (SUCCEEDED(hres))
    {
        SafeStrCatN(szKey, szCLSID, ARRAYSIZE(szKey));

	    // Delete the CLSID Key - CLSID\{...}
	    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKey);

	    // Delete the version-independent ProgID Key.
	    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszVerIndProgID);

	    // Delete the ProgID key.
	    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszProgID);
    }

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Internal helper functions

// Delete a key and all of its descendents.
LONG _RecursiveDeleteKey(HKEY hKeyParent, LPCWSTR pszKeyChild)
{
	HKEY hkeyChild;
	LONG lRes = RegOpenKeyEx(hKeyParent, pszKeyChild, 0, KEY_ALL_ACCESS,
        &hkeyChild);

	if (ERROR_SUCCESS == lRes)
	{
	    // Enumerate all of the decendents of this child.
	    WCHAR szBuffer[MAX_PATH];
	    DWORD dwSize = ARRAYSIZE(szBuffer);

	    while ((ERROR_SUCCESS == lRes) && (S_OK == RegEnumKeyEx(hkeyChild, 0,
            szBuffer, &dwSize, NULL, NULL, NULL, NULL)))
	    {
		    // Delete the decendents of this child.
		    lRes = _RecursiveDeleteKey(hkeyChild, szBuffer);

		    dwSize = ARRAYSIZE(szBuffer);
	    }

	    // Close the child.
	    RegCloseKey(hkeyChild);
    }

    if (ERROR_SUCCESS == lRes)
    {
    	// Delete this child.
        lRes = RegDeleteKey(hKeyParent, pszKeyChild);
    }

	return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\regsvr.h ===
#ifndef _REGSVR_H_
#define _REGSVR_H_

#include <objbase.h>

HRESULT RegisterServer(HMODULE hModule, REFCLSID rclsid,
    LPCWSTR pszFriendlyName, LPCWSTR pszVerIndProgID, LPCWSTR pszProgID,
    DWORD dwThreadingModel, BOOL fInprocServer, BOOL fLocalServer,
    BOOL fLocalService, LPCWSTR pszLocalService, const CLSID* pclsidAppID);

HRESULT UnregisterServer(REFCLSID rclsid, LPCWSTR pszVerIndProgID,
    LPCWSTR pszProgID);

HRESULT RegisterAppID(const CLSID* pclsidAppID);

#endif //_REGSVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\cmmn.h ===
#ifndef _CMMN_H_
#define _CMMN_H_

#include "namellst.h"
#include "mischlpr.h"

#include <objbase.h>
#include <dbt.h>
#include <cfgmgr32.h>
#include <devioctl.h>

#define MAX_SURPRISEREMOVALFN   50

///////////////////////////////////////////////////////////////////////////////
//
extern const GUID guidVolumeClass;
extern const GUID guidDiskClass;
extern const GUID guidCdRomClass;
extern const GUID guidImagingDeviceClass;
extern const GUID guidVideoCameraClass;
extern const GUID guidInvalid;

///////////////////////////////////////////////////////////////////////////////
//
class CHandleNotifTarget
{
public:
    virtual HRESULT HNTHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType) = 0;

    HRESULT HNTInitSurpriseRemoval();
    BOOL HNTIsSurpriseRemovalAware();

    virtual ~CHandleNotifTarget();
};

enum HWEDLIST
{
    HWEDLIST_INVALID = -1,
    HWEDLIST_HANDLENOTIF,
    HWEDLIST_VOLUME,
    HWEDLIST_DISK,
    HWEDLIST_MTPT,
    HWEDLIST_MISCDEVINTF,
    HWEDLIST_MISCDEVNODE,
    HWEDLIST_ADVISECLIENT,
    HWEDLIST_COUNT_OF_LISTS, //always last, not a list
};

class CHWEventDetectorHelper
{
public:
    static HRESULT Init();
    static HRESULT Cleanup();

    static void TraceDiagnosticMsg(LPTSTR pszMsg, ...);
    static HRESULT CheckDiagnosticAppPresence();
    static HRESULT SetServiceStatusHandle(SERVICE_STATUS_HANDLE ssh);
    static HRESULT CreateLists();
    static HRESULT DeleteLists();
    static HRESULT FillLists();
    static HRESULT EmptyLists();

    static HRESULT GetList(HWEDLIST hwedlist, CNamedElemList** ppnel);

    static HRESULT RegisterDeviceNotification(PVOID pvNotificationFilter,
        HDEVNOTIFY* phdevnotify, BOOL fAllInterfaceClasses);

    static HRESULT InitDockState();
    static HRESULT DockStateChanged(BOOL* pfDockStateChanged);

    static HRESULT GetImpersonateEveryone(class CImpersonateEveryone** ppieo);

#ifdef DEBUG
public:
    static void _DbgAssertValidState();
#endif

public:
    static BOOL                     _fDiagnosticAppPresent;

private:
    static DWORD                    _dwDiagAppLastCheck;
    static SERVICE_STATUS_HANDLE    _ssh;
    static BOOL                     _fListCreated;
    static CNamedElemList*          _rgpnel[];
    static DWORD                    _cpnel;
    static BOOL                     _fDocked;
    static CImpersonateEveryone*    _pieo;
    static CCritSect                _cs;
    static BOOL                     _fInited;
};

///////////////////////////////////////////////////////////////////////////////
//
typedef HRESULT (*INTERFACEENUMFILTERCALLBACK)(LPCWSTR pszDeviceIntfID);

class CIntfFillEnum
{
public:
    HRESULT Next(LPWSTR pszElemName, DWORD cchElemName, DWORD* pcchRequired);
    HRESULT _Init(const GUID* pguidInterface, INTERFACEENUMFILTERCALLBACK iecb);

public:
    CIntfFillEnum();
    ~CIntfFillEnum();

private:
    LPWSTR                          _pszNextInterface;
    LPWSTR                          _pszDeviceInterface;
    INTERFACEENUMFILTERCALLBACK     _iecb;
};

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _DeviceInstIsRemovable(DEVINST devinst, BOOL* pfRemovable);

HANDLE _GetDeviceHandle(LPCTSTR psz, DWORD dwDesiredAccess);
void _CloseDeviceHandle(HANDLE hDevice);

HRESULT _GetDeviceNumberInfoFromHandle(HANDLE h, DEVICE_TYPE* pdevtype,
    ULONG* pulDeviceNumber, ULONG* pulPartitionNumber);

HRESULT _GetVolumeName(LPCWSTR pszDeviceID, LPWSTR pszVolumeName,
    DWORD cchVolumeName);

HRESULT _GetDeviceIDFromMtPtName(LPCWSTR pszMtPt, LPWSTR pszDeviceID,
    DWORD cchDeviceID);

HRESULT _GetDeviceID(LPCWSTR pszName, LPWSTR pszDeviceID,
    DWORD cchDeviceID);

HRESULT _GetHWDeviceInstFromDeviceOrVolumeIntfID(LPCWSTR pszDeviceIntfID,
    class CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);

HRESULT _GetHWDeviceInstFromVolumeIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);
HRESULT _GetHWDeviceInstFromDeviceIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);
HRESULT _GetHWDeviceInstFromDeviceNode(LPCWSTR pszDeviceNode,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);

HRESULT _GetAltDeviceID(LPCWSTR pszDeviceID, LPWSTR pszDeviceIDAlt,
    DWORD cchDeviceIDAlt);

HRESULT _CoTaskMemCopy(LPCWSTR pszSrc, LPWSTR* ppszDest);
void _CoTaskMemFree(void* pv);

HRESULT DupString(LPCWSTR pszSrc, LPWSTR* ppszDest);

HRESULT _GetDeviceInstance(LPCWSTR pszDeviceIntfID, DEVINST* pdevinst,
    GUID* pguidInterface);

HRESULT _GetDeviceInstanceFromDevNode(LPCWSTR pszDeviceNode,
    DEVINST* pdevinst);

HRESULT _MachineIsDocked(BOOL* pfDocked);

HRESULT _BuildMoniker(LPCWSTR pszEventHandler, REFCLSID rclsid,
    DWORD dwSessionID, IMoniker** ppmoniker);

///////////////////////////////////////////////////////////////////////////////
//
#define DIAGNOSTIC(__allargs) { if (CHWEventDetectorHelper::_fDiagnosticAppPresent) \
    { CHWEventDetectorHelper::TraceDiagnosticMsg __allargs ; } else \
    { ; } }
    
#endif //_CMMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\lib\users.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <lmaccess.h>
#include <lmapibuf.h>

#include <winsta.h>
#include <dsgetdc.h>

#include <userenv.h>
#include <userenvp.h>

extern "C"
{
#include <syslib.h>
}

#ifdef ASSERT
#undef ASSERT
#endif

#include "users.h"

#include "sfstr.h"
#include "str.h"
#include "mischlpr.h"

#include "dbg.h"
#include "tfids.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _GetUserHKCU(HANDLE hThreadToken, LPCWSTR pszUserName, HKEY* phkey)
{
    HRESULT hr;
    PROFILEINFO profileinfo = {0};

    *phkey = NULL;

    profileinfo.dwSize     = sizeof(profileinfo);
    profileinfo.dwFlags    = PI_NOUI | PI_LITELOAD;
    profileinfo.lpUserName = (LPWSTR)pszUserName;

    if (LoadUserProfile(hThreadToken, &profileinfo))
    {
        *phkey = (HKEY)(profileinfo.hProfile);
        hr = S_OK;

        TRACE(TF_USERS, TEXT("Loaded user profile"));
    }
    else
    {
        hr = S_FALSE;

        TRACE(TF_USERS,
            TEXT("FAILED to load user profile: GLE = 0x%08X"),
            GetLastError());
    }

    return hr;
}

HRESULT _GetThreadTokenAndUserName(HANDLE* phThreadToken,
    LPWSTR pszUserName, DWORD cchUserName)
{
    HRESULT hr = E_FAIL;

    if (OpenThreadToken(GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        TRUE, phThreadToken))
    {
#ifdef DEBUG
        // For information only
        DWORD dwImp = 0;
        DWORD dwBytesReturned;

        if (GetTokenInformation(*phThreadToken, TokenImpersonationLevel,
            &dwImp, sizeof(DWORD), &dwBytesReturned))
        {
            switch (dwImp)
            {
                case SecurityAnonymous:
                    TRACE(TF_USERS, TEXT("SecurityAnonymous"));
                    break;

                case SecurityIdentification:
                    TRACE(TF_USERS, TEXT("SecurityIdentification"));
                    break;

                case SecurityImpersonation:
                    TRACE(TF_USERS, TEXT("SecurityImpersonation"));
                    break;

                case SecurityDelegation:
                    TRACE(TF_USERS, TEXT("SecurityDelegation"));
                    break;

                default:
                    TRACE(TF_USERS, TEXT("Error. Unable to determine impersonation level"));
                    break;
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("Unable to read impersonation level"));
        }
#endif
        if (GetUserName(pszUserName, &cchUserName))
        {
            TRACE(TF_USERS, TEXT("UserName: %s"), pszUserName);
            hr = S_OK;
        }
        else
        {
            TRACE(TF_USERS, TEXT("Failed to get username"));
        }
    }
    else
    {
        TRACE(TF_USERS, TEXT("Unable to read thread token (%d)"),
            GetLastError());
    }

    return hr;
}

HRESULT _GetCurrentUserHKCU(HANDLE* phThreadToken, HKEY* phkey)
{
    HRESULT hr = E_INVALIDARG;

    if (phkey && phThreadToken)
    {
        CImpersonateConsoleSessionUser icsu;

        hr = icsu.Impersonate();

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szUserName[UNLEN + 1];

            hr = _GetThreadTokenAndUserName(phThreadToken,
                szUserName, ARRAYSIZE(szUserName));

            icsu.RevertToSelf();

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetUserHKCU(*phThreadToken, szUserName, phkey);
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("WinStationQueryInformation FAILED"));
        }
    }

    if (FAILED(hr) || (S_FALSE == hr))
    {
        TRACE(TF_USERS, TEXT("_GetCurrentUserHKCU FAILED or S_FALSE'D: 0x%08X"), hr);
    }
    else
    {
        TRACE(TF_USERS, TEXT("_GetCurrentUserHKCU SUCCEEDED"));
    }

    return hr;
}

HRESULT _CloseCurrentUserHKCU(HANDLE hThreadToken, HKEY hkey)
{
    UnloadUserProfile(hThreadToken, hkey);

    CloseHandle(hThreadToken);

    return S_OK;
}

HRESULT _CoGetCallingUserHKCU(HANDLE* phThreadToken, HKEY* phkey)
{
    HRESULT hr = E_INVALIDARG;

    if (phkey && phThreadToken)
    {
        CImpersonateCOMCaller icc;

        // You must call this before trying to open a thread token!
        hr = icc.Impersonate();
        
        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szUserName[UNLEN + 1];

            hr = _GetThreadTokenAndUserName(phThreadToken,
                szUserName, ARRAYSIZE(szUserName));

            icc.RevertToSelf();

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetUserHKCU(*phThreadToken, szUserName, phkey);
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("CoImpersonateClient failed: 0x%08X"), hr);
        }
    }

    if (FAILED(hr) || (S_FALSE == hr))
    {
        TRACE(TF_USERS, TEXT("_CoGetCallingUserHKCU FAILED or S_FALSE'D: 0x%08X"), hr);
    }
    else
    {
        TRACE(TF_USERS, TEXT("_CoGetCallingUserHKCU SUCCEEDED"));
    }

    return hr;
}

HRESULT _CoCloseCallingUserHKCU(HANDLE hThreadToken, HKEY hkey)
{
    UnloadUserProfile(hThreadToken, hkey);

    CloseHandle(hThreadToken);

    return S_OK;
}

#define SESSION_MONIKER TEXT("Session:Console!clsid:")

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid, IUnknown* punkOuter,
    DWORD /*dwClsContext*/, REFIID riid, void** ppv)
{
    IBindCtx* pbc;
    HRESULT hr = CreateBindCtx(0, &pbc);

    *ppv = NULL;

    if (SUCCEEDED(hr)) 
    {
        WCHAR szCLSID[39];

        hr = _StringFromGUID(&rclsid, szCLSID, ARRAYSIZE(szCLSID));

        if (SUCCEEDED(hr))
        {
            ULONG ulEaten;
            IMoniker* pmoniker;
            WCHAR szDisplayName[ARRAYSIZE(SESSION_MONIKER) + ARRAYSIZE(szCLSID)] =
                SESSION_MONIKER;

            // We want something like: "Session:Console!clsid:760befd0-5b0b-44d7-957e-969af35ce954"
            szCLSID[ARRAYSIZE(szCLSID) - 2] = 0;

            // Form display name string
            hr = SafeStrCatN(szDisplayName, szCLSID + 1, ARRAYSIZE(szDisplayName));

            if (SUCCEEDED(hr))
            {
                // Parse the name and get a moniker:
                hr = MkParseDisplayName(pbc, szDisplayName, &ulEaten, &pmoniker);

                if (SUCCEEDED(hr))
                {
                    IClassFactory* pcf;

                    hr = pmoniker->BindToObject(pbc, NULL, IID_IClassFactory, (void**)&pcf);

                    if (SUCCEEDED(hr))
                    {
                        hr = pcf->CreateInstance(punkOuter, riid, ppv);

                        TRACE(TF_USERS,
                            TEXT("pcf->CreateInstance returned: hr = 0x%08X"), hr);

                        pcf->Release();
                    }
                    else
                    {
                        TRACE(TF_USERS, TEXT("pmoniker->BindToObject returned: hr = 0x%08X"), hr);
                    }

                    pmoniker->Release();
                }
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("MkParseDisplayName returned: hr = 0x%08X"), hr);
        }

        pbc->Release();
    }
    else
    {
        TRACE(TF_USERS, TEXT("CreateBindCtxt returned: hr = 0x%08X"), hr);
    }

    return hr;
}

HRESULT CImpersonateTokenBased::Impersonate()
{
    HRESULT hr = S_FALSE;

    if (!_hToken)
    {
        hr = _GetToken(&_hToken);
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        if (ImpersonateLoggedOnUser(_hToken))
        {
            hr = S_OK;
        }
        else
        {
            TRACE(TF_USERS, TEXT("Impersonate FAILED"));
        }
    }

    return hr;
}

HRESULT CImpersonateTokenBased::RevertToSelf()
{
    return _RevertToSelf();
}

HRESULT CImpersonateTokenBased::_RevertToSelf()
{
    if (_hToken)
    {
        ::RevertToSelf();
        CloseHandle(_hToken);
        _hToken = NULL;
    }

    return S_OK;
}

CImpersonateTokenBased::CImpersonateTokenBased()
{
    _hToken = NULL;
}

CImpersonateTokenBased::~CImpersonateTokenBased()
{
    _RevertToSelf();
}

HRESULT CImpersonateConsoleSessionUser::_GetToken(HANDLE* phToken)
{
    HRESULT hr;
    ULONG ulReturnLength;
    WINSTATIONUSERTOKEN wsUserToken = {0};

    // Yep, the next casts are intentional...
    wsUserToken.ProcessId = (HANDLE)(DWORD_PTR)GetCurrentProcessId();
    wsUserToken.ThreadId = (HANDLE)(DWORD_PTR)GetCurrentThreadId();
    wsUserToken.UserToken = NULL;

    BOOL fActiveConsole = WinStationQueryInformation(SERVERNAME_CURRENT,
        USER_SHARED_DATA->ActiveConsoleId, WinStationUserToken,
        &wsUserToken, sizeof(wsUserToken), &ulReturnLength);

    if (fActiveConsole)
    {
        *phToken = wsUserToken.UserToken;
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CImpersonateEveryone::_GetToken(HANDLE* phToken)
{
    HRESULT hr = S_FALSE;

    PSID gAdminSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
 
    NTSTATUS ntstatus = RtlAllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &gAdminSid);

    if (NT_SUCCESS(ntstatus))
    {
        HANDLE hTokenProcess;

        ntstatus = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_ALL_ACCESS,
                        &hTokenProcess);

        if (NT_SUCCESS(ntstatus))
        {
            TOKEN_GROUPS TokenGroups = {0};

            TokenGroups.GroupCount = 1 ;
            TokenGroups.Groups[0].Attributes = 0 ;
            TokenGroups.Groups[0].Sid = gAdminSid ;

            ntstatus = NtFilterToken(
                        hTokenProcess,
                        DISABLE_MAX_PRIVILEGE,
                        &TokenGroups,
                        NULL,
                        NULL,
                        phToken);

            NtClose(hTokenProcess);

            hr = S_OK;
        }

        RtlFreeSid(gAdminSid);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CImpersonateCOMCaller::Impersonate()
{
    HRESULT hr = CoImpersonateClient();

    if (SUCCEEDED(hr))
    {
        _fImpersonating = TRUE;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CImpersonateCOMCaller::RevertToSelf()
{
    return _RevertToSelf();
}

HRESULT CImpersonateCOMCaller::_RevertToSelf()
{
    if (_fImpersonating)
    {
        CoRevertToSelf();
        _fImpersonating = FALSE;
    }

    return S_OK;
}

CImpersonateCOMCaller::CImpersonateCOMCaller() : _fImpersonating(FALSE)
{}

CImpersonateCOMCaller::~CImpersonateCOMCaller()
{
    _RevertToSelf();
}

HRESULT _GiveAllowForegroundToConsoleShell()
{
    HANDLE hImpersonationToken;
    DWORD dwSessionID = USER_SHARED_DATA->ActiveConsoleId;

    if (GetWinStationUserToken(dwSessionID, &hImpersonationToken))
    {
        HANDLE hUserToken;

        if (DuplicateTokenEx(hImpersonationToken, 0, NULL,
            SecurityImpersonation, TokenPrimary, &hUserToken))
        {
            WCHAR szApp[MAX_PATH];

            if (ExpandEnvironmentStringsForUser(NULL, // system vars only
                    L"%SystemRoot%\\system32\\rundll32.exe",
                    szApp, ARRAYSIZE(szApp)))
            {
                STARTUPINFO StartupInfo = {0};
                PROCESS_INFORMATION ProcessInfo = {0};
                WCHAR szCommand[] = TEXT("rundll32.exe shell32.dll,Activate_RunDLL");

                StartupInfo.cb = sizeof(StartupInfo);
                StartupInfo.wShowWindow = SW_SHOW;
                StartupInfo.lpDesktop = L"WinSta0\\Default";

                if (CreateProcessAsUser(hUserToken, szApp, szCommand,
                    NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL,
                    &StartupInfo, &ProcessInfo))
                {
                    CloseHandle(ProcessInfo.hProcess);
                    CloseHandle(ProcessInfo.hThread);
                }
            }

            CloseHandle(hUserToken);
        }

        CloseHandle(hImpersonationToken);
    }
 
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\cstmprop.h ===
///////////////////////////////////////////////////////////////////////////////
// HWDeviceCustomProperties
///////////////////////////////////////////////////////////////////////////////
#ifndef _CSTMPROP_H
#define _CSTMPROP_H

#include "unk.h"

#include <shpriv.h>

//extern const CLSID CLSID_HWDeviceCustomProperties;

class CHWDeviceCustomPropertiesImpl : public CCOMBase,
    public IHWDeviceCustomProperties
{
public:
    // Interface IHWDeviceCustomProperties
    STDMETHODIMP InitFromDeviceID(LPCWSTR pszDeviceID, DWORD dwFlags);
    STDMETHODIMP InitFromDevNode(LPCWSTR pszDevNode, DWORD dwFlags);

    STDMETHODIMP GetDWORDProperty(LPCWSTR pszPropName, DWORD* pdwProp);

    STDMETHODIMP GetStringProperty(LPCWSTR pszPropName, LPWSTR* ppszProp);

    STDMETHODIMP GetMultiStringProperty(LPCWSTR pszPropName,
        BOOL fMergeMultiSz, WORD_BLOB** ppblob);

    STDMETHODIMP GetBlobProperty(LPCWSTR pszPropName, BYTE_BLOB** ppblob);

public:
    CHWDeviceCustomPropertiesImpl();
    ~CHWDeviceCustomPropertiesImpl();

private:
    class CHWDeviceInst*    _phwdevinst;
    class CNamedElem*       _pelemToRelease;
    DWORD                   _dwFlags;
    BOOL                    _fInited;
};

typedef CUnkTmpl<CHWDeviceCustomPropertiesImpl> CHWDeviceCustomProperties;

#endif // _CSTMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\services\hdsrv\shhwdtct\cmmn.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#include "cmmn.h"

#include <shlwapi.h>

#include "hwdev.h"
#include "hnotif.h"
#include "vol.h"
#include "mtpts.h"
#include "miscdev.h"
#include "drvbase.h"
#include "regnotif.h"
#include "users.h"
#include "logging.h"

#include "sfstr.h"
#include "dbg.h"

#include "tfids.h"

#include <setupapi.h>

#pragma warning(disable: 4201)
#include <winioctl.h>
#pragma warning(default: 4201)

#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
const GUID guidVolumeClass =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

const GUID guidDiskClass =
    {0x53f56307, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

const GUID guidCdRomClass = 
    {0x53f56308L, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

const GUID guidImagingDeviceClass =
    {0x6bdd1fc6L, 0x810f, 0x11d0,
    {0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f}};

const GUID guidVideoCameraClass =
    {0x6994AD05L, 0x93EF, 0x11D0,
    {0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96}};

const GUID guidInvalid = 
    {0xFFFFFFFFL, 0xFFFF, 0xFFFF,
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};

///////////////////////////////////////////////////////////////////////////////
//
BOOL                    CHWEventDetectorHelper::_fDiagnosticAppPresent = FALSE;
DWORD                   CHWEventDetectorHelper::_dwDiagAppLastCheck = (DWORD)-1;
SERVICE_STATUS_HANDLE   CHWEventDetectorHelper::_ssh = NULL;
BOOL                    CHWEventDetectorHelper::_fListCreated = FALSE;
CNamedElemList*         CHWEventDetectorHelper::
    _rgpnel[HWEDLIST_COUNT_OF_LISTS] = {0};

// For the debugger extension
DWORD                   CHWEventDetectorHelper::_cpnel =
    ARRAYSIZE(CHWEventDetectorHelper::_rgpnel);

BOOL                    CHWEventDetectorHelper::_fDocked = FALSE;
CImpersonateEveryone*   CHWEventDetectorHelper::_pieo = NULL;
CCritSect               CHWEventDetectorHelper::_cs;
BOOL                    CHWEventDetectorHelper::_fInited = FALSE;

#ifdef DEBUG
DWORD                   _cDbgDeviceHandle = 0;
#endif
///////////////////////////////////////////////////////////////////////////////
//
HRESULT _DeviceInstIsRemovable(DEVINST devinst, BOOL* pfRemovable)
{
    DWORD dwCap;
    DWORD cbCap = sizeof(dwCap);

    CONFIGRET cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
        CM_DRP_CAPABILITIES, NULL, &dwCap, &cbCap, 0, NULL);

    if (CR_SUCCESS == cr)
    {
        if (CM_DEVCAP_REMOVABLE & dwCap)
        {
            *pfRemovable = TRUE;
        }
        else
        {
            *pfRemovable = FALSE;
        }
    }
    else
    {
        *pfRemovable = FALSE;
    }

    return S_OK;
}

HANDLE _GetDeviceHandle(LPCTSTR psz, DWORD dwDesiredAccess)
{
    HANDLE hDevice = CreateFile(psz, dwDesiredAccess,
       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    
#ifdef DEBUG
    if (INVALID_HANDLE_VALUE != hDevice)
    {
        ++_cDbgDeviceHandle;

        TRACE(TF_LEAK, TEXT("_GetDeviceHandle: %d"), _cDbgDeviceHandle);
    }
#endif

    return hDevice;
}

void _CloseDeviceHandle(HANDLE hDevice)
{
    CloseHandle(hDevice);

#ifdef DEBUG
    if (INVALID_HANDLE_VALUE != hDevice)
    {
        --_cDbgDeviceHandle;

        TRACE(TF_LEAK, TEXT("_CloseDeviceHandle: %d"), _cDbgDeviceHandle);
    }
#endif
}

HRESULT _GetVolumeName(LPCWSTR pszDeviceID, LPWSTR pszVolumeName,
    DWORD cchVolumeName)
{
    WCHAR szDeviceIDWithSlash[MAX_DEVICEID];
    LPWSTR pszNext;
    DWORD cchLeft;

    HRESULT hres = SafeStrCpyNEx(szDeviceIDWithSlash, pszDeviceID,
        ARRAYSIZE(szDeviceIDWithSlash), &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
        hres = SafeStrCpyN(pszNext, TEXT("\\"), cchLeft);

        if (SUCCEEDED(hres))
        {
            if (GetVolumeNameForVolumeMountPoint(szDeviceIDWithSlash,
                pszVolumeName, cchVolumeName))
            {
                hres = S_OK;
            }
            else
            {
                *pszVolumeName = 0;

                hres = S_FALSE;
            }
        }
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromVolumeIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    *pphwdevinst = NULL;
    *ppelemToRelease = NULL;

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->Get(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            CVolume* pvol = (CVolume*)pelem;

            hres = pvol->GetHWDeviceInst(pphwdevinst);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                *ppelemToRelease = pelem;
            }
            else
            {
                pelem->RCRelease();
            }
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromDeviceNode(LPCWSTR pszDeviceNode,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MISCDEVNODE, &pnel);

    *pphwdevinst = NULL;
    *ppelemToRelease = NULL;

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->GetOrAdd(pszDeviceNode, &pelem);

        if (SUCCEEDED(hres))
        {
            CMiscDeviceNode* pmiscdevnode =
                (CMiscDeviceNode*)pelem;

            hres = pmiscdevnode->GetHWDeviceInst(pphwdevinst);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                *ppelemToRelease = pelem;
            }
            else
            {
                pelem->RCRelease();
            }
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromDeviceIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MISCDEVINTF, &pnel);

    *pphwdevinst = NULL;
    *ppelemToRelease = NULL;

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->Get(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            CMiscDeviceInterface* pmiscdevintf =
                (CMiscDeviceInterface*)pelem;

            hres = pmiscdevintf->GetHWDeviceInst(pphwdevinst);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                *ppelemToRelease = pelem;
            }
            else
            {
                pelem->RCRelease();
            }
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromDeviceOrVolumeIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    HRESULT hres = _GetHWDeviceInstFromVolumeIntfID(pszDeviceIntfID,
        pphwdevinst, ppelemToRelease);

    if (S_FALSE == hres)
    {
        // Not a volume ID, try other devices
        hres = _GetHWDeviceInstFromDeviceIntfID(pszDeviceIntfID,
            pphwdevinst, ppelemToRelease);
    }

    return hres;
}

HRESULT _GetDeviceIDFromMtPtName(LPCWSTR pszMtPt, LPWSTR pszDeviceID,
    DWORD cchDeviceID)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->Get(pszMtPt, &pelem);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            CMtPt* pmtpt = (CMtPt*)pelem;

            hres = pmtpt->GetVolumeName(pszDeviceID, cchDeviceID);

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetDeviceID(LPCWSTR pszName, LPWSTR pszDeviceID, DWORD cchDeviceID)
{
    HRESULT hres;

    if (*pszName && (TEXT('\\') == *pszName) &&
        *(pszName + 1) && (TEXT('\\') == *(pszName + 1)) &&
        *(pszName + 2) && (TEXT('?') == *(pszName + 2)))
    {
        hres = SafeStrCpyN(pszDeviceID, pszName, cchDeviceID);
    }
    else
    {
        hres = _GetDeviceIDFromMtPtName(pszName, pszDeviceID, cchDeviceID);
    }

    return hres;
}

HRESULT _GetAltDeviceID(LPCWSTR pszDeviceID, LPWSTR pszDeviceIDAlt,
    DWORD cchDeviceIDAlt)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

    if (S_OK == hres)
    {
        CNamedElemEnum* penum;

        hres = pnel->GetEnum(&penum);

        if (SUCCEEDED(hres))
        {
            BOOL fFoundIt = FALSE;
            CNamedElem* pelem;

            while (!fFoundIt && SUCCEEDED(hres = penum->Next(&pelem)) &&
                (S_FALSE != hres))
            {
                CMtPt* pmtpt = (CMtPt*)pelem;
                WCHAR szDeviceIDVolume[MAX_DEVICEID];

                hres = pmtpt->GetVolumeName(szDeviceIDVolume,
                    ARRAYSIZE(szDeviceIDVolume));

                if (SUCCEEDED(hres))
                {
                    if (!lstrcmp(szDeviceIDVolume, pszDeviceID))
                    {
                        // Use me!
                        DWORD cchReq;
                        fFoundIt = TRUE;

                        hres = pmtpt->GetName(pszDeviceIDAlt,
                            cchDeviceIDAlt, &cchReq);
                    }
                }

                pelem->RCRelease();
            }

            penum->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetDeviceNumberInfoFromHandle(HANDLE hDevice, DEVICE_TYPE* pdevtype,
    ULONG* pulDeviceNumber, ULONG* pulPartitionNumber)
{
    HRESULT hr;
    STORAGE_DEVICE_NUMBER sdn = {0};
    DWORD dwDummy;

    BOOL b = DeviceIoControl(hDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL, 0, &sdn, sizeof(sdn), &dwDummy, NULL);

    if (b)
    {
        *pdevtype = sdn.DeviceType;
        *pulDeviceNumber = sdn.DeviceNumber;
        *pulPartitionNumber = sdn.PartitionNumber;

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _CoTaskMemCopy(LPCWSTR pszSrc, LPWSTR* ppszDest)
{
    HRESULT hres = S_OK;
    DWORD cch = lstrlen(pszSrc) + 1;

    *ppszDest = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));

    if (*ppszDest)
    {
        // This should not fail
        SHOULDNOTFAIL(SUCCEEDED(StringCchCopy(*ppszDest, cch, pszSrc)));
    }
    else
    {
        *ppszDest = NULL;
        hres  = E_OUTOFMEMORY;
    }

    return hres;
}

void _CoTaskMemFree(void* pv)
{
    if (p